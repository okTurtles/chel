#!/usr/bin/env -S deno run --allow-net --allow-read=. --allow-write=. --allow-sys --allow-env
import { createRequire } from "node:module";
var __require = createRequire(import.meta.url);


// deno:https://jsr.io/@std/internal/1.0.10/_os.ts
function checkWindows() {
  const global2 = globalThis;
  const os = global2.Deno?.build?.os;
  return typeof os === "string" ? os === "windows" : global2.navigator?.platform?.startsWith("Win") ?? global2.process?.platform?.startsWith("win") ?? false;
}

// deno:https://jsr.io/@std/internal/1.0.10/os.ts
var isWindows = checkWindows();

// deno:https://jsr.io/@std/path/1.1.1/_common/assert_path.ts
function assertPath(path) {
  if (typeof path !== "string") {
    throw new TypeError(`Path must be a string, received "${JSON.stringify(path)}"`);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/_common/basename.ts
function stripSuffix(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i2 = suffix.length - 1; i2 >= 0; --i2) {
    if (name.charCodeAt(lenDiff + i2) !== suffix.charCodeAt(i2)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}
function lastPathSegment(path, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path.length;
  for (let i2 = path.length - 1; i2 >= start; --i2) {
    if (isSep(path.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        start = i2 + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i2 + 1;
    }
  }
  return path.slice(start, end);
}
function assertArgs(path, suffix) {
  assertPath(path);
  if (path.length === 0) return path;
  if (typeof suffix !== "string") {
    throw new TypeError(`Suffix must be a string, received "${JSON.stringify(suffix)}"`);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/_common/from_file_url.ts
function assertArg(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol !== "file:") {
    throw new TypeError(`URL must be a file URL: received "${url.protocol}"`);
  }
  return url;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/from_file_url.ts
function fromFileUrl(url) {
  url = assertArg(url);
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

// deno:https://jsr.io/@std/path/1.1.1/_common/strip_trailing_separators.ts
function stripTrailingSeparators(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i2 = segment.length - 1; i2 > 0; i2--) {
    if (isSep(segment.charCodeAt(i2))) {
      end = i2;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/constants.ts
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;

// deno:https://jsr.io/@std/path/1.1.1/posix/_util.ts
function isPosixPathSeparator(code2) {
  return code2 === CHAR_FORWARD_SLASH;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/basename.ts
function basename(path, suffix = "") {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertArgs(path, suffix);
  const lastSegment = lastPathSegment(path, isPosixPathSeparator);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/_util.ts
function isPosixPathSeparator2(code2) {
  return code2 === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code2) {
  return code2 === CHAR_FORWARD_SLASH || code2 === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code2) {
  return code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z || code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/from_file_url.ts
function fromFileUrl2(url) {
  url = assertArg(url);
  let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname !== "") {
    path = `\\\\${url.hostname}${path}`;
  }
  return path;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/basename.ts
function basename2(path, suffix = "") {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertArgs(path, suffix);
  let start = 0;
  if (path.length >= 2) {
    const drive = path.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path.charCodeAt(1) === CHAR_COLON) start = 2;
    }
  }
  const lastSegment = lastPathSegment(path, isPathSeparator, start);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}

// deno:https://jsr.io/@std/path/1.1.1/basename.ts
function basename3(path, suffix = "") {
  return isWindows ? basename2(path, suffix) : basename(path, suffix);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/dirname.ts
function assertArg2(path) {
  assertPath(path);
  if (path.length === 0) return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/posix/dirname.ts
function dirname(path) {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertArg2(path);
  let end = -1;
  let matchedNonSeparator = false;
  for (let i2 = path.length - 1; i2 >= 1; --i2) {
    if (isPosixPathSeparator(path.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        end = i2;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/dirname.ts
function dirname2(path) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertArg2(path);
  const len = path.length;
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return path;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator(path.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1) return ".";
    else end = rootEnd;
  }
  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator2);
}

// deno:https://jsr.io/@std/path/1.1.1/dirname.ts
function dirname3(path) {
  return isWindows ? dirname2(path) : dirname(path);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/extname.ts
function extname(path) {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertPath(path);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path.length - 1; i2 >= 0; --i2) {
    const code2 = path.charCodeAt(i2);
    if (isPosixPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/extname.ts
function extname2(path) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertPath(path);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path.length - 1; i2 >= start; --i2) {
    const code2 = path.charCodeAt(i2);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}

// deno:https://jsr.io/@std/path/1.1.1/extname.ts
function extname3(path) {
  return isWindows ? extname2(path) : extname(path);
}

// deno:https://jsr.io/@std/path/1.1.1/from_file_url.ts
function fromFileUrl3(url) {
  return isWindows ? fromFileUrl2(url) : fromFileUrl(url);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/is_absolute.ts
function isAbsolute(path) {
  assertPath(path);
  return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));
}

// deno:https://jsr.io/@std/path/1.1.1/windows/is_absolute.ts
function isAbsolute2(path) {
  assertPath(path);
  const len = path.length;
  if (len === 0) return false;
  const code2 = path.charCodeAt(0);
  if (isPathSeparator(code2)) {
    return true;
  } else if (isWindowsDeviceRoot(code2)) {
    if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {
      if (isPathSeparator(path.charCodeAt(2))) return true;
    }
  }
  return false;
}

// deno:https://jsr.io/@std/path/1.1.1/is_absolute.ts
function isAbsolute3(path) {
  return isWindows ? isAbsolute2(path) : isAbsolute(path);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/normalize.ts
function assertArg4(path) {
  assertPath(path);
  if (path.length === 0) return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/_common/normalize_string.ts
function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i2 = 0; i2 <= path.length; ++i2) {
    if (i2 < path.length) code2 = path.charCodeAt(i2);
    else if (isPathSeparator3(code2)) break;
    else code2 = CHAR_FORWARD_SLASH;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) res += `${separator}..`;
          else res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i2);
        else res = path.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/normalize.ts
function normalize(path) {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertArg4(path);
  const isAbsolute6 = isPosixPathSeparator(path.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));
  path = normalizeString(path, !isAbsolute6, "/", isPosixPathSeparator);
  if (path.length === 0 && !isAbsolute6) path = ".";
  if (path.length > 0 && trailingSeparator) path += "/";
  if (isAbsolute6) return `/${path}`;
  return path;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/join.ts
function join(path, ...paths) {
  if (path === void 0) return ".";
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  paths = path ? [
    path,
    ...paths
  ] : paths;
  paths.forEach((path2) => assertPath(path2));
  const joined = paths.filter((path2) => path2.length > 0).join("/");
  return joined === "" ? "." : normalize(joined);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/normalize.ts
function normalize2(path) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertArg4(path);
  const len = path.length;
  let rootEnd = 0;
  let device;
  let isAbsolute6 = false;
  const code2 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      isAbsolute6 = true;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) {
            isAbsolute6 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(path.slice(rootEnd), !isAbsolute6, "\\", isPathSeparator);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute6) tail = ".";
  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute6) {
      if (tail.length > 0) return `\\${tail}`;
      else return "\\";
    }
    return tail;
  } else if (isAbsolute6) {
    if (tail.length > 0) return `${device}\\${tail}`;
    else return `${device}\\`;
  }
  return device + tail;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/join.ts
function join2(path, ...paths) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  paths = path ? [
    path,
    ...paths
  ] : paths;
  paths.forEach((path2) => assertPath(path2));
  paths = paths.filter((path2) => path2.length > 0);
  if (paths.length === 0) return ".";
  let needsReplace = true;
  let slashCount = 0;
  const firstPart = paths[0];
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  let joined = paths.join("\\");
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
    }
    if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize2(joined);
}

// deno:https://jsr.io/@std/path/1.1.1/join.ts
function join3(path, ...paths) {
  return isWindows ? join2(path, ...paths) : join(path, ...paths);
}

// deno:https://jsr.io/@std/path/1.1.1/normalize.ts
function normalize3(path) {
  return isWindows ? normalize2(path) : normalize(path);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/parse.ts
function parse(path) {
  assertPath(path);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  if (path.length === 0) return ret;
  const isAbsolute6 = isPosixPathSeparator(path.charCodeAt(0));
  let start;
  if (isAbsolute6) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i2 = path.length - 1;
  let preDotState = 0;
  for (; i2 >= start; --i2) {
    const code2 = path.charCodeAt(i2);
    if (isPosixPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute6) {
        ret.base = ret.name = path.slice(1, end);
      } else {
        ret.base = ret.name = path.slice(startPart, end);
      }
    }
    ret.base = ret.base || "/";
  } else {
    if (startPart === 0 && isAbsolute6) {
      ret.name = path.slice(1, startDot);
      ret.base = path.slice(1, end);
    } else {
      ret.name = path.slice(startPart, startDot);
      ret.base = path.slice(startPart, end);
    }
    ret.ext = path.slice(startDot, end);
  }
  if (startPart > 0) {
    ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);
  } else if (isAbsolute6) ret.dir = "/";
  return ret;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/parse.ts
function parse2(path) {
  assertPath(path);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  const len = path.length;
  if (len === 0) return ret;
  let rootEnd = 0;
  let code2 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path;
              ret.base = "\\";
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path;
          return ret;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    ret.root = ret.dir = path;
    ret.base = "\\";
    return ret;
  }
  if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i2 = path.length - 1;
  let preDotState = 0;
  for (; i2 >= rootEnd; --i2) {
    code2 = path.charCodeAt(i2);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path.slice(startPart, end);
    }
  } else {
    ret.name = path.slice(startPart, startDot);
    ret.base = path.slice(startPart, end);
    ret.ext = path.slice(startDot, end);
  }
  ret.base = ret.base || "\\";
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path.slice(0, startPart - 1);
  } else ret.dir = ret.root;
  return ret;
}

// deno:https://jsr.io/@std/path/1.1.1/parse.ts
function parse3(path) {
  return isWindows ? parse2(path) : parse(path);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/resolve.ts
function resolve(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path;
    if (i2 >= 0) path = pathSegments[i2];
    else {
      const { Deno: Deno3 } = globalThis;
      if (typeof Deno3?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path = Deno3.cwd();
    }
    assertPath(path);
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) return `/${resolvedPath}`;
    else return "/";
  } else if (resolvedPath.length > 0) return resolvedPath;
  else return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/_common/relative.ts
function assertArgs2(from6, to) {
  assertPath(from6);
  assertPath(to);
  if (from6 === to) return "";
}

// deno:https://jsr.io/@std/path/1.1.1/posix/relative.ts
function relative(from6, to) {
  assertArgs2(from6, to);
  from6 = resolve(from6);
  to = resolve(to);
  if (from6 === to) return "";
  let fromStart = 1;
  const fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (!isPosixPathSeparator(from6.charCodeAt(fromStart))) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;
  }
  const toLen = toEnd - toStart;
  const length4 = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length4; ++i2) {
    if (i2 === length4) {
      if (toLen > length4) {
        if (isPosixPathSeparator(to.charCodeAt(toStart + i2))) {
          return to.slice(toStart + i2 + 1);
        } else if (i2 === 0) {
          return to.slice(toStart + i2);
        }
      } else if (fromLen > length4) {
        if (isPosixPathSeparator(from6.charCodeAt(fromStart + i2))) {
          lastCommonSep = i2;
        } else if (i2 === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode) break;
    else if (isPosixPathSeparator(fromCode)) lastCommonSep = i2;
  }
  let out = "";
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || isPosixPathSeparator(from6.charCodeAt(i2))) {
      if (out.length === 0) out += "..";
      else out += "/..";
    }
  }
  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;
    return to.slice(toStart);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/windows/resolve.ts
function resolve2(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path;
    const { Deno: Deno3 } = globalThis;
    if (i2 >= 0) {
      path = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno3?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a current working directory (CWD)");
      }
      path = Deno3.cwd();
    } else {
      if (typeof Deno3?.env?.get !== "function" || typeof Deno3?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path = Deno3.cwd();
      if (path === void 0 || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path = `${resolvedDevice}\\`;
      }
    }
    assertPath(path);
    const len = path.length;
    if (len === 0) continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute6 = false;
    const code2 = path.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        isAbsolute6 = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path.charCodeAt(j))) break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path.charCodeAt(2))) {
              isAbsolute6 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      rootEnd = 1;
      isAbsolute6 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute6;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0) break;
  }
  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}

// deno:https://jsr.io/@std/path/1.1.1/windows/relative.ts
function relative2(from6, to) {
  assertArgs2(from6, to);
  const fromOrig = resolve2(from6);
  const toOrig = resolve2(to);
  if (fromOrig === toOrig) return "";
  from6 = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from6 === to) return "";
  let fromStart = 0;
  let fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from6.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;
  }
  const toLen = toEnd - toStart;
  const length4 = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length4; ++i2) {
    if (i2 === length4) {
      if (toLen > length4) {
        if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i2 + 1);
        } else if (i2 === 2) {
          return toOrig.slice(toStart + i2);
        }
      }
      if (fromLen > length4) {
        if (from6.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i2;
        } else if (i2 === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode) break;
    else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i2;
  }
  if (i2 !== length4 && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1) lastCommonSep = 0;
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from6.charCodeAt(i2) === CHAR_BACKWARD_SLASH) {
      if (out.length === 0) out += "..";
      else out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/relative.ts
function relative3(from6, to) {
  return isWindows ? relative2(from6, to) : relative(from6, to);
}

// deno:https://jsr.io/@std/path/1.1.1/resolve.ts
function resolve3(...pathSegments) {
  return isWindows ? resolve2(...pathSegments) : resolve(...pathSegments);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/to_file_url.ts
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string3) {
  return string3.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS[c] ?? c;
  });
}

// deno:https://jsr.io/@std/path/1.1.1/posix/to_file_url.ts
function toFileUrl(path) {
  if (!isAbsolute(path)) {
    throw new TypeError(`Path must be absolute: received "${path}"`);
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/to_file_url.ts
function toFileUrl2(path) {
  if (!isAbsolute2(path)) {
    throw new TypeError(`Path must be absolute: received "${path}"`);
  }
  const [, hostname2, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname2 !== void 0 && hostname2 !== "localhost") {
    url.hostname = hostname2;
    if (!url.hostname) {
      throw new TypeError(`Invalid hostname: "${url.hostname}"`);
    }
  }
  return url;
}

// deno:https://jsr.io/@std/path/1.1.1/to_file_url.ts
function toFileUrl3(path) {
  return isWindows ? toFileUrl2(path) : toFileUrl(path);
}

// deno:https://jsr.io/@db/sqlite/0.12.0/deno.json
var deno_default = {
  name: "@db/sqlite",
  version: "0.12.0",
  github: "https://github.com/denodrivers/sqlite3",
  exports: "./mod.ts",
  exclude: [
    "sqlite",
    "scripts"
  ],
  tasks: {
    test: "deno test --unstable-ffi -A test/test.ts",
    build: "deno run -A scripts/build.ts",
    "bench-deno": "deno run -A --unstable-ffi bench/bench_deno.js 50 1000000",
    "bench-deno-ffi": "deno run -A --unstable-ffi bench/bench_deno_ffi.js 50 1000000",
    "bench-deno-wasm": "deno run -A --unstable-ffi bench/bench_deno_wasm.js 50 1000000",
    "bench-node": "node bench/bench_node.js 50 1000000",
    "bench-bun": "bun run bench/bench_bun.js 50 1000000",
    "bench-bun-ffi": "bun run bench/bench_bun_ffi.js 50 1000000",
    "bench-c": "./bench/bench 50 1000000",
    "bench-python": "python ./bench/bench_python.py",
    "bench:northwind": "deno bench -A --unstable-ffi bench/northwind/deno.js",
    "bench-wasm:northwind": "deno run -A --unstable-ffi bench/northwind/deno_wasm.js",
    "bench-node:northwind": "node bench/northwind/node.mjs",
    "bench-bun:northwind": "bun run bench/northwind/bun.js"
  },
  fmt: {
    exclude: [
      "sqlite"
    ]
  },
  lint: {
    rules: {
      exclude: [
        "camelcase",
        "no-explicit-any"
      ],
      include: [
        "explicit-function-return-type",
        "eqeqeq",
        "explicit-module-boundary-types"
      ]
    }
  }
};

// deno:https://jsr.io/@std/path/0.217.0/_common/from_file_url.ts
function assertArg7(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol !== "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return url;
}

// deno:https://jsr.io/@std/path/0.217.0/windows/from_file_url.ts
function fromFileUrl4(url) {
  url = assertArg7(url);
  let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname !== "") {
    path = `\\\\${url.hostname}${path}`;
  }
  return path;
}

// deno:https://jsr.io/@std/path/0.217.0/posix/from_file_url.ts
function fromFileUrl5(url) {
  url = assertArg7(url);
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

// deno:https://jsr.io/@std/path/0.217.0/_os.ts
var osType = (() => {
  const { Deno: Deno3 } = globalThis;
  if (typeof Deno3?.build?.os === "string") {
    return Deno3.build.os;
  }
  const { navigator: navigator2 } = globalThis;
  if (navigator2?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows2 = osType === "windows";

// deno:https://jsr.io/@std/path/0.217.0/from_file_url.ts
function fromFileUrl6(url) {
  return isWindows2 ? fromFileUrl4(url) : fromFileUrl5(url);
}

// deno:https://jsr.io/@std/fs/1.0.19/_get_file_info_type.ts
function getFileInfoType(fileInfo) {
  return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : void 0;
}

// deno:https://jsr.io/@std/fs/1.0.19/ensure_dir.ts
async function ensureDir(dir) {
  try {
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    await Deno.mkdir(dir, {
      recursive: true
    });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
  }
}
function throwIfNotDirectory(fileInfo) {
  if (!fileInfo.isDirectory) {
    throw new Error(`Failed to ensure directory exists: expected 'dir', got '${getFileInfoType(fileInfo)}'`);
  }
}

// deno:https://jsr.io/@std/fs/1.0.19/move.ts
var EXISTS_ERROR = new Deno.errors.AlreadyExists("dest already exists.");

// deno:https://jsr.io/@std/fs/1.0.19/eol.ts
var LF = "\n";
var CRLF = "\r\n";
var EOL = globalThis.Deno?.build.os === "windows" ? CRLF : LF;

// deno:https://jsr.io/@std/fmt/1.0.8/colors.ts
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : false;
var enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code2) {
  return enabled ? `${code2.open}${str.replace(code2.regexp, code2.open)}${code2.close}` : str;
}
function red(str) {
  return run(str, code([
    31
  ], 39));
}
function green(str) {
  return run(str, code([
    32
  ], 39));
}
function yellow(str) {
  return run(str, code([
    33
  ], 39));
}
function blue(str) {
  return run(str, code([
    34
  ], 39));
}
function cyan(str) {
  return run(str, code([
    36
  ], 39));
}
function gray(str) {
  return brightBlack(str);
}
function brightBlack(str) {
  return run(str, code([
    90
  ], 39));
}
var ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
].join("|"), "g");

// deno:https://jsr.io/@std/encoding/1.0.10/_common16.ts
var alphabet = new TextEncoder().encode("0123456789abcdef");
var rAlphabet = new Uint8Array(128).fill(16);
alphabet.forEach((byte, i2) => rAlphabet[byte] = i2);
new TextEncoder().encode("ABCDEF").forEach((byte, i2) => rAlphabet[byte] = i2 + 10);
function calcSizeHex(originalSize) {
  return originalSize * 2;
}
function encode(buffer, i2, o2, alphabet5) {
  for (; i2 < buffer.length; ++i2) {
    const x3 = buffer[i2];
    buffer[o2++] = alphabet5[x3 >> 4];
    buffer[o2++] = alphabet5[x3 & 15];
  }
  return o2;
}

// deno:https://jsr.io/@std/encoding/1.0.10/_common_detach.ts
function detach(buffer, maxSize) {
  const originalSize = buffer.length;
  if (buffer.byteOffset) {
    const b = new Uint8Array(buffer.buffer);
    b.set(buffer);
    buffer = b.subarray(0, originalSize);
  }
  buffer = new Uint8Array(buffer.buffer.transfer(maxSize));
  buffer.set(buffer.subarray(0, originalSize), maxSize - originalSize);
  return [
    buffer,
    maxSize - originalSize
  ];
}

// deno:https://jsr.io/@std/encoding/1.0.10/hex.ts
var alphabet2 = new TextEncoder().encode("0123456789abcdef");
var rAlphabet2 = new Uint8Array(128).fill(16);
alphabet2.forEach((byte, i2) => rAlphabet2[byte] = i2);
new TextEncoder().encode("ABCDEF").forEach((byte, i2) => rAlphabet2[byte] = i2 + 10);
function encodeHex(src4) {
  if (typeof src4 === "string") {
    src4 = new TextEncoder().encode(src4);
  } else if (src4 instanceof ArrayBuffer) src4 = new Uint8Array(src4).slice();
  else src4 = src4.slice();
  const [output, i2] = detach(src4, calcSizeHex(src4.length));
  encode(output, i2, 0, alphabet2);
  return new TextDecoder().decode(output);
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/util.ts
var encoder = new TextEncoder();
function baseUrlToFilename(url) {
  const out = [];
  const protocol = url.protocol.replace(":", "");
  out.push(protocol);
  switch (protocol) {
    case "http":
    case "https": {
      const host = url.hostname;
      const hostPort = url.port;
      out.push(hostPort ? `${host}_PORT${hostPort}` : host);
      break;
    }
    case "file":
    case "data":
    case "blob":
      break;
    default:
      throw new TypeError(`Don't know how to create cache name for protocol: ${protocol}`);
  }
  return join3(...out);
}
function stringToURL(url) {
  return url.startsWith("file://") || url.startsWith("http://") || url.startsWith("https://") ? new URL(url) : toFileUrl3(resolve3(url));
}
async function hash(value) {
  return encodeHex(new Uint8Array(await crypto.subtle.digest("SHA-256", encoder.encode(value))));
}
async function urlToFilename(url) {
  const cacheFilename = baseUrlToFilename(url);
  const hashedFilename = await hash(url.pathname + url.search);
  return join3(cacheFilename, hashedFilename);
}
async function isFile(filePath) {
  try {
    const stats = await Deno.lstat(filePath);
    return stats.isFile;
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    }
    throw err;
  }
}
function homeDir() {
  switch (Deno.build.os) {
    case "windows":
      return Deno.env.get("USERPROFILE");
    case "linux":
    case "darwin":
    case "freebsd":
    case "netbsd":
    case "aix":
    case "solaris":
    case "illumos":
    case "android":
      return Deno.env.get("HOME");
    default:
      throw Error("unreachable");
  }
}
function cacheDir() {
  if (Deno.build.os === "darwin") {
    const home = homeDir();
    if (home) {
      return join3(home, "Library/Caches");
    }
  } else if (Deno.build.os === "windows") {
    return Deno.env.get("LOCALAPPDATA");
  } else {
    const cacheHome = Deno.env.get("XDG_CACHE_HOME");
    if (cacheHome) {
      return cacheHome;
    } else {
      const home = homeDir();
      if (home) {
        return join3(home, ".cache");
      }
    }
  }
}
function denoCacheDir() {
  const dd = Deno.env.get("DENO_DIR");
  let root;
  if (dd) {
    root = normalize3(isAbsolute3(dd) ? dd : join3(Deno.cwd(), dd));
  } else {
    const cd = cacheDir();
    if (cd) {
      root = join3(cd, "deno");
    } else {
      const hd = homeDir();
      if (hd) {
        root = join3(hd, ".deno");
      }
    }
  }
  return root;
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/download.ts
var ALL_ARCHS = [
  "x86_64",
  "aarch64"
];
var ALL_OSS = [
  "darwin",
  "linux",
  "android",
  "windows",
  "freebsd",
  "netbsd",
  "aix",
  "solaris",
  "illumos"
];
var defaultExtensions = {
  darwin: "dylib",
  linux: "so",
  windows: "dll",
  freebsd: "so",
  netbsd: "so",
  aix: "so",
  solaris: "so",
  illumos: "so",
  android: "so"
};
var defaultPrefixes = {
  darwin: "lib",
  linux: "lib",
  netbsd: "lib",
  freebsd: "lib",
  aix: "lib",
  solaris: "lib",
  illumos: "lib",
  windows: "",
  android: "lib"
};
function getCrossOption(record) {
  if (record === void 0) {
    return;
  }
  if (ALL_OSS.some((os) => os in record)) {
    const subrecord = record[Deno.build.os];
    if (subrecord && typeof subrecord === "object" && ALL_ARCHS.some((arch) => arch in subrecord)) {
      return subrecord[Deno.build.arch];
    } else {
      return subrecord;
    }
  }
  if (ALL_ARCHS.some((arch) => arch in record)) {
    const subrecord = record[Deno.build.arch];
    if (subrecord && typeof subrecord === "object" && ALL_OSS.some((os) => os in subrecord)) {
      return subrecord[Deno.build.os];
    } else {
      return subrecord;
    }
  }
}
function createDownloadURL(options3) {
  if (typeof options3 === "string" || options3 instanceof URL) {
    options3 = {
      url: options3
    };
  }
  options3.extensions ??= defaultExtensions;
  options3.prefixes ??= defaultPrefixes;
  for (const key in options3.extensions) {
    const os = key;
    if (options3.extensions[os] !== void 0) {
      options3.extensions[os] = options3.extensions[os].replace(/\.?(.+)/, "$1");
    }
  }
  let url;
  if (options3.url instanceof URL) {
    url = options3.url;
  } else if (typeof options3.url === "string") {
    url = stringToURL(options3.url);
  } else {
    const tmpUrl = getCrossOption(options3.url);
    if (tmpUrl === void 0) {
      throw new TypeError(`An URL for the "${Deno.build.os}-${Deno.build.arch}" target was not provided.`);
    }
    if (typeof tmpUrl === "string") {
      url = stringToURL(tmpUrl);
    } else {
      url = tmpUrl;
    }
  }
  if ("name" in options3 && !Object.values(options3.extensions).includes(extname3(url.pathname))) {
    if (!url.pathname.endsWith("/")) {
      url.pathname = `${url.pathname}/`;
    }
    const prefix = getCrossOption(options3.prefixes) ?? "";
    const suffix = getCrossOption(options3.suffixes) ?? "";
    const extension = options3.extensions[Deno.build.os];
    if (options3.name === void 0) {
      throw new TypeError(`Expected the "name" property for an automatically assembled URL.`);
    }
    const filename = `${prefix}${options3.name}${suffix}.${extension}`;
    url = new URL(filename, url);
  }
  return url;
}
async function ensureCacheLocation(location = "deno") {
  if (location === "deno") {
    const dir = denoCacheDir();
    if (dir === void 0) {
      throw new Error("Could not get the deno cache directory, try using another CacheLocation in the plug options.");
    }
    location = join3(dir, "plug");
  } else if (location === "cache") {
    const dir = cacheDir();
    if (dir === void 0) {
      throw new Error("Could not get the cache directory, try using another CacheLocation in the plug options.");
    }
    location = join3(dir, "plug");
  } else if (location === "cwd") {
    location = join3(Deno.cwd(), "plug");
  } else if (location === "tmp") {
    location = await Deno.makeTempDir({
      prefix: "plug"
    });
  } else if (typeof location === "string" && location.startsWith("file://")) {
    location = fromFileUrl3(location);
  } else if (location instanceof URL) {
    if (location?.protocol !== "file:") {
      throw new TypeError("Cannot use any other protocol than file:// for an URL cache location.");
    }
    location = fromFileUrl3(location);
  }
  location = resolve3(normalize3(location));
  await ensureDir(location);
  return location;
}
async function download(options3) {
  const location = (typeof options3 === "object" && "location" in options3 ? options3.location : void 0) ?? "deno";
  const setting = (typeof options3 === "object" && "cache" in options3 ? options3.cache : void 0) ?? "use";
  const url = createDownloadURL(options3);
  const directory = await ensureCacheLocation(location);
  const cacheBasePath = join3(directory, await urlToFilename(url));
  const cacheFilePath = `${cacheBasePath}${extname3(url.pathname)}`;
  const cacheMetaPath = `${cacheBasePath}.metadata.json`;
  const cached2 = setting === "use" ? await isFile(cacheFilePath) : setting === "only" || setting !== "reloadAll";
  await ensureDir(dirname3(cacheBasePath));
  if (!cached2) {
    const meta = {
      url
    };
    switch (url.protocol) {
      case "http:":
      case "https:": {
        console.log(`${green("Downloading")} ${url}`);
        const response = await fetch(url.toString());
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error(`Could not find ${url}`);
          } else {
            throw new Deno.errors.Http(`${response.status} ${response.statusText}`);
          }
        }
        await Deno.writeFile(cacheFilePath, new Uint8Array(await response.arrayBuffer()));
        break;
      }
      case "file:": {
        console.log(`${green("Copying")} ${url}`);
        await Deno.copyFile(fromFileUrl3(url), cacheFilePath);
        if (Deno.build.os !== "windows") {
          await Deno.chmod(cacheFilePath, 420);
        }
        break;
      }
      default: {
        throw new TypeError(`Cannot fetch to cache using the "${url.protocol}" protocol`);
      }
    }
    await Deno.writeTextFile(cacheMetaPath, JSON.stringify(meta));
  }
  if (!await isFile(cacheFilePath)) {
    throw new Error(`Could not find "${url}" in cache.`);
  }
  return cacheFilePath;
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/mod.ts
async function dlopen(options3, symbols2) {
  if (Deno.dlopen === void 0) {
    throw new Error("`--unstable-ffi` is required");
  }
  return Deno.dlopen(await download(options3), symbols2);
}

// deno:https://jsr.io/@db/sqlite/0.12.0/src/ffi.ts
var symbols = {
  sqlite3_open_v2: {
    parameters: [
      "buffer",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_close_v2: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_changes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_total_changes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_last_insert_rowid: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_get_autocommit: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_prepare_v2: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "buffer",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_reset: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_clear_bindings: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_step: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_column_count: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_column_type: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_text: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_value: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_finalize: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_exec: {
    parameters: [
      "pointer",
      "buffer",
      "pointer",
      "pointer",
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_free: {
    parameters: [
      "pointer"
    ],
    result: "void"
  },
  sqlite3_column_int: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_double: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "f64"
  },
  sqlite3_column_blob: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_bytes: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_name: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_decltype: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "u64"
  },
  sqlite3_bind_parameter_index: {
    parameters: [
      "pointer",
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_bind_text: {
    parameters: [
      "pointer",
      "i32",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_blob: {
    parameters: [
      "pointer",
      "i32",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_double: {
    parameters: [
      "pointer",
      "i32",
      "f64"
    ],
    result: "i32"
  },
  sqlite3_bind_int: {
    parameters: [
      "pointer",
      "i32",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_bind_int64: {
    parameters: [
      "pointer",
      "i32",
      "i64"
    ],
    result: "i32"
  },
  sqlite3_bind_null: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_expanded_sql: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_bind_parameter_count: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_complete: {
    parameters: [
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_sourceid: {
    parameters: [],
    result: "pointer"
  },
  sqlite3_libversion: {
    parameters: [],
    result: "pointer"
  },
  sqlite3_blob_open: {
    parameters: [
      "pointer",
      /* sqlite3 *db */
      "buffer",
      /* const char *zDb */
      "buffer",
      /* const char *zTable */
      "buffer",
      /* const char *zColumn */
      "i64",
      /* sqlite3_int64 iRow */
      "i32",
      /* int flags */
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_blob_read: {
    parameters: [
      "pointer",
      /* sqlite3_blob *blob */
      "buffer",
      /* void *Z */
      "i32",
      /* int N */
      "i32"
    ],
    result: "i32"
  },
  sqlite3_blob_write: {
    parameters: [
      "pointer",
      /* sqlite3_blob *blob */
      "buffer",
      /* const void *z */
      "i32",
      /* int n */
      "i32"
    ],
    result: "i32"
  },
  sqlite3_blob_bytes: {
    parameters: [
      "pointer"
      /* sqlite3_blob *blob */
    ],
    result: "i32"
  },
  sqlite3_blob_close: {
    parameters: [
      "pointer"
      /* sqlite3_blob *blob */
    ],
    result: "i32"
  },
  sqlite3_sql: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_stmt_readonly: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_parameter_name: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_errcode: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_errmsg: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_errstr: {
    parameters: [
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_int64: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i64"
  },
  sqlite3_backup_init: {
    parameters: [
      "pointer",
      "buffer",
      "pointer",
      "buffer"
    ],
    result: "pointer"
  },
  sqlite3_backup_step: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_backup_finish: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_backup_remaining: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_backup_pagecount: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_create_function: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "i32",
      "pointer",
      "pointer",
      "pointer",
      "pointer"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_result_blob: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "isize"
    ],
    result: "void"
  },
  sqlite3_result_double: {
    parameters: [
      "pointer",
      "f64"
    ],
    result: "void"
  },
  sqlite3_result_error: {
    parameters: [
      "pointer",
      "buffer",
      "i32"
    ],
    result: "void"
  },
  sqlite3_result_int: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "void"
  },
  sqlite3_result_int64: {
    parameters: [
      "pointer",
      "i64"
    ],
    result: "void"
  },
  sqlite3_result_null: {
    parameters: [
      "pointer"
    ],
    result: "void"
  },
  sqlite3_result_text: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "isize"
    ],
    result: "void"
  },
  sqlite3_value_type: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_subtype: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_blob: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_value_double: {
    parameters: [
      "pointer"
    ],
    result: "f64"
  },
  sqlite3_value_int: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_int64: {
    parameters: [
      "pointer"
    ],
    result: "i64"
  },
  sqlite3_value_text: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_value_bytes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_aggregate_context: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer",
    optional: true
  },
  sqlite3_enable_load_extension: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_load_extension: {
    parameters: [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_initialize: {
    parameters: [],
    result: "i32"
  }
};
var lib;
function tryGetEnv(key) {
  try {
    return Deno.env.get(key);
  } catch (e2) {
    if (e2 instanceof Deno.errors.PermissionDenied) {
      return void 0;
    }
    throw e2;
  }
}
try {
  const customPath = tryGetEnv("DENO_SQLITE_PATH");
  const sqliteLocal = tryGetEnv("DENO_SQLITE_LOCAL");
  if (sqliteLocal === "1") {
    lib = Deno.dlopen(new URL(`../build/${Deno.build.os === "windows" ? "" : "lib"}sqlite3${Deno.build.arch !== "x86_64" ? `_${Deno.build.arch}` : ""}.${Deno.build.os === "windows" ? "dll" : Deno.build.os === "darwin" ? "dylib" : "so"}`, import.meta.url), symbols).symbols;
  } else if (customPath) {
    lib = Deno.dlopen(customPath, symbols).symbols;
  } else {
    lib = (await dlopen({
      name: "sqlite3",
      url: `${deno_default.github}/releases/download/${deno_default.version}/`,
      suffixes: {
        aarch64: "_aarch64"
      }
    }, symbols)).symbols;
  }
} catch (e2) {
  if (e2 instanceof Deno.errors.PermissionDenied) {
    throw e2;
  }
  throw new Error("Failed to load SQLite3 Dynamic Library", {
    cause: e2
  });
}
var init = lib.sqlite3_initialize();
if (init !== 0) {
  throw new Error(`Failed to initialize SQLite3: ${init}`);
}
var ffi_default = lib;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/constants.ts
var SQLITE3_OK = 0;
var SQLITE3_MISUSE = 21;
var SQLITE3_ROW = 100;
var SQLITE3_DONE = 101;
var SQLITE3_OPEN_READONLY = 1;
var SQLITE3_OPEN_READWRITE = 2;
var SQLITE3_OPEN_CREATE = 4;
var SQLITE3_OPEN_MEMORY = 128;
var SQLITE_INTEGER = 1;
var SQLITE_FLOAT = 2;
var SQLITE_TEXT = 3;
var SQLITE_BLOB = 4;
var SQLITE_NULL = 5;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/util.ts
var { sqlite3_errmsg, sqlite3_errstr } = ffi_default;
var encoder2 = new TextEncoder();
function toCString(str) {
  return encoder2.encode(str + "\0");
}
var SqliteError = class extends Error {
  code;
  name;
  constructor(code2 = 1, message = "Unknown Error") {
    super(`${code2}: ${message}`), this.code = code2, this.name = "SqliteError";
  }
};
function unwrap(code2, db3) {
  if (code2 === SQLITE3_OK || code2 === SQLITE3_DONE) return;
  if (code2 === SQLITE3_MISUSE) {
    throw new SqliteError(code2, "SQLite3 API misuse");
  } else if (db3 !== void 0) {
    const errmsg = sqlite3_errmsg(db3);
    if (errmsg === null) throw new SqliteError(code2);
    throw new Error(Deno.UnsafePointerView.getCString(errmsg));
  } else {
    throw new SqliteError(code2, Deno.UnsafePointerView.getCString(sqlite3_errstr(code2)));
  }
}
var buf = Deno.UnsafePointerView.getArrayBuffer;
var readCstr = Deno.UnsafePointerView.getCString;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/statement.ts
var _computedKey;
var _computedKey1;
var _computedKey2;
var { sqlite3_prepare_v2, sqlite3_reset, sqlite3_clear_bindings, sqlite3_step, sqlite3_column_count, sqlite3_column_type, sqlite3_column_value, sqlite3_value_subtype, sqlite3_column_text, sqlite3_finalize, sqlite3_column_int64, sqlite3_column_double, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_name, sqlite3_expanded_sql, sqlite3_bind_parameter_count, sqlite3_bind_int, sqlite3_bind_int64, sqlite3_bind_text, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_parameter_index, sqlite3_sql, sqlite3_stmt_readonly, sqlite3_bind_parameter_name, sqlite3_changes, sqlite3_column_int } = ffi_default;
var STATEMENTS_TO_DB = /* @__PURE__ */ new Map();
var emptyStringBuffer = new Uint8Array(1);
var statementFinalizer = new FinalizationRegistry((ptr) => {
  if (STATEMENTS_TO_DB.has(ptr)) {
    sqlite3_finalize(ptr);
    STATEMENTS_TO_DB.delete(ptr);
  }
});
var JSON_SUBTYPE = 74;
var BIG_MAX = BigInt(Number.MAX_SAFE_INTEGER);
function getColumn(handle, i2, int64) {
  const ty = sqlite3_column_type(handle, i2);
  if (ty === SQLITE_INTEGER && !int64) return sqlite3_column_int(handle, i2);
  switch (ty) {
    case SQLITE_TEXT: {
      const ptr = sqlite3_column_text(handle, i2);
      if (ptr === null) return null;
      const text = readCstr(ptr, 0);
      const value = sqlite3_column_value(handle, i2);
      const subtype = sqlite3_value_subtype(value);
      if (subtype === JSON_SUBTYPE) {
        try {
          return JSON.parse(text);
        } catch (_error) {
          return text;
        }
      }
      return text;
    }
    case SQLITE_INTEGER: {
      const val = sqlite3_column_int64(handle, i2);
      if (val < -BIG_MAX || val > BIG_MAX) {
        return val;
      }
      return Number(val);
    }
    case SQLITE_FLOAT: {
      return sqlite3_column_double(handle, i2);
    }
    case SQLITE_BLOB: {
      const ptr = sqlite3_column_blob(handle, i2);
      if (ptr === null) {
        return new Uint8Array();
      }
      const bytes = sqlite3_column_bytes(handle, i2);
      return new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(ptr, bytes).slice(0));
    }
    default: {
      return null;
    }
  }
}
_computedKey = Symbol.iterator, _computedKey1 = Symbol.dispose, _computedKey2 = Symbol.for("Deno.customInspect");
var Statement = class {
  db;
  #handle;
  #finalizerToken;
  #bound;
  #hasNoArgs;
  #unsafeConcurrency;
  /**
   * Whether the query might call into JavaScript or not.
   *
   * Must enable if the query makes use of user defined functions,
   * otherwise there can be V8 crashes.
   *
   * Off by default. Causes performance degradation.
   */
  callback;
  /** Unsafe Raw (pointer) to the sqlite object */
  get unsafeHandle() {
    return this.#handle;
  }
  /** SQL string including bindings */
  get expandedSql() {
    return readCstr(sqlite3_expanded_sql(this.#handle));
  }
  /** The SQL string that we passed when creating statement */
  get sql() {
    return readCstr(sqlite3_sql(this.#handle));
  }
  /** Whether this statement doesn't make any direct changes to the DB */
  get readonly() {
    return sqlite3_stmt_readonly(this.#handle) !== 0;
  }
  /** Simply run the query without retrieving any output there may be. */
  run(...args) {
    return this.#runWithArgs(...args);
  }
  /**
   * Run the query and return the resulting rows where rows are array of columns.
   */
  values(...args) {
    return this.#valuesWithArgs(...args);
  }
  /**
   * Run the query and return the resulting rows where rows are objects
   * mapping column name to their corresponding values.
   */
  all(...args) {
    return this.#allWithArgs(...args);
  }
  #bindParameterCount;
  /** Number of parameters (to be) bound */
  get bindParameterCount() {
    return this.#bindParameterCount;
  }
  constructor(db3, sql) {
    this.db = db3;
    this.#bound = false;
    this.#hasNoArgs = false;
    this.callback = false;
    this.#bindRefs = /* @__PURE__ */ new Set();
    this.#rowObject = {};
    const pHandle = new BigUint64Array(1);
    unwrap(sqlite3_prepare_v2(db3.unsafeHandle, toCString(sql), sql.length, pHandle, null), db3.unsafeHandle);
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
    STATEMENTS_TO_DB.set(this.#handle, db3.unsafeHandle);
    this.#unsafeConcurrency = db3.unsafeConcurrency;
    this.#finalizerToken = {
      handle: this.#handle
    };
    statementFinalizer.register(this, this.#handle, this.#finalizerToken);
    if ((this.#bindParameterCount = sqlite3_bind_parameter_count(this.#handle)) === 0) {
      this.#hasNoArgs = true;
      this.all = this.#allNoArgs;
      this.values = this.#valuesNoArgs;
      this.run = this.#runNoArgs;
      this.value = this.#valueNoArgs;
      this.get = this.#getNoArgs;
    }
  }
  /** Shorthand for `this.callback = true`. Enables calling user defined functions. */
  enableCallback() {
    this.callback = true;
    return this;
  }
  /** Get bind parameter name by index */
  bindParameterName(i2) {
    return readCstr(sqlite3_bind_parameter_name(this.#handle, i2));
  }
  /** Get bind parameter index by name */
  bindParameterIndex(name) {
    if (name[0] !== ":" && name[0] !== "@" && name[0] !== "$") {
      name = ":" + name;
    }
    return sqlite3_bind_parameter_index(this.#handle, toCString(name));
  }
  #begin() {
    sqlite3_reset(this.#handle);
    if (!this.#bound && !this.#hasNoArgs) {
      sqlite3_clear_bindings(this.#handle);
      this.#bindRefs.clear();
    }
  }
  #bindRefs;
  #bind(i2, param) {
    switch (typeof param) {
      case "number": {
        if (Number.isInteger(param)) {
          if (Number.isSafeInteger(param) && param >= -(2 ** 31) && param < 2 ** 31) {
            unwrap(sqlite3_bind_int(this.#handle, i2 + 1, param));
          } else {
            unwrap(sqlite3_bind_int64(this.#handle, i2 + 1, BigInt(param)));
          }
        } else {
          unwrap(sqlite3_bind_double(this.#handle, i2 + 1, param));
        }
        break;
      }
      case "string": {
        if (param === "") {
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, emptyStringBuffer, 0, null));
        } else {
          const str = new TextEncoder().encode(param);
          this.#bindRefs.add(str);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, str, str.byteLength, null));
        }
        break;
      }
      case "object": {
        if (param === null) {
        } else if (param instanceof Uint8Array) {
          this.#bindRefs.add(param);
          unwrap(sqlite3_bind_blob(this.#handle, i2 + 1, param.byteLength === 0 ? emptyStringBuffer : param, param.byteLength, null));
        } else if (param instanceof Date) {
          const cstring = toCString(param.toISOString());
          this.#bindRefs.add(cstring);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, cstring, -1, null));
        } else {
          const cstring = toCString(JSON.stringify(param));
          this.#bindRefs.add(cstring);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, cstring, -1, null));
        }
        break;
      }
      case "bigint": {
        unwrap(sqlite3_bind_int64(this.#handle, i2 + 1, param));
        break;
      }
      case "boolean":
        unwrap(sqlite3_bind_int(this.#handle, i2 + 1, param ? 1 : 0));
        break;
      default: {
        throw new Error(`Value of unsupported type: ${Deno.inspect(param)}`);
      }
    }
  }
  /**
   * Bind parameters to the statement. This method can only be called once
   * to set the parameters to be same throughout the statement. You cannot
   * change the parameters after this method is called.
   *
   * This method is merely just for optimization to avoid binding parameters
   * each time in prepared statement.
   */
  bind(...params) {
    this.#bindAll(params);
    this.#bound = true;
    return this;
  }
  #bindAll(params) {
    if (this.#bound) throw new Error("Statement already bound to values");
    if (typeof params[0] === "object" && params[0] !== null && !(params[0] instanceof Uint8Array) && !(params[0] instanceof Date)) {
      params = params[0];
    }
    if (Array.isArray(params)) {
      for (let i2 = 0; i2 < params.length; i2++) {
        this.#bind(i2, params[i2]);
      }
    } else {
      for (const [name, param] of Object.entries(params)) {
        const i2 = this.bindParameterIndex(name);
        if (i2 === 0) {
          throw new Error(`No such parameter "${name}"`);
        }
        this.#bind(i2 - 1, param);
      }
    }
  }
  #runNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const status = sqlite3_step(handle);
    if (status !== SQLITE3_ROW && status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return sqlite3_changes(this.db.unsafeHandle);
  }
  #runWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_ROW && status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return sqlite3_changes(this.db.unsafeHandle);
  }
  #valuesNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const columnCount = sqlite3_column_count(handle);
    const result = [];
    const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
      length: columnCount
    }).map((_, i2) => `getColumn(h, ${i2}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowArray(handle));
      status = sqlite3_step(handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #valuesWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const columnCount = sqlite3_column_count(handle);
    const result = [];
    const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
      length: columnCount
    }).map((_, i2) => `getColumn(h, ${i2}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowArray(handle));
      status = sqlite3_step(handle);
    }
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #rowObjectFn;
  getRowObject() {
    if (!this.#rowObjectFn || !this.#unsafeConcurrency) {
      const columnNames = this.columnNames();
      const getRowObject = new Function("getColumn", `
        return function(h) {
          return {
            ${columnNames.map((name, i2) => `"${name}": getColumn(h, ${i2}, ${this.db.int64})`).join(",\n")}
          };
        };
        `)(getColumn);
      this.#rowObjectFn = getRowObject;
    }
    return this.#rowObjectFn;
  }
  #allNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const getRowObject = this.getRowObject();
    const result = [];
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowObject(handle));
      status = sqlite3_step(handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #allWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const getRowObject = this.getRowObject();
    const result = [];
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowObject(handle));
      status = sqlite3_step(handle);
    }
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  /** Fetch only first row as an array, if any. */
  value(...params) {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const arr = new Array(sqlite3_column_count(handle));
    sqlite3_reset(handle);
    if (!this.#hasNoArgs && !this.#bound) {
      sqlite3_clear_bindings(handle);
      this.#bindRefs.clear();
      if (params.length) {
        this.#bindAll(params);
      }
    }
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        arr[i2] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(this.#handle);
      return arr;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #valueNoArgs() {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const cc = sqlite3_column_count(handle);
    const arr = new Array(cc);
    sqlite3_reset(handle);
    const status = sqlite3_step(handle);
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < cc; i2++) {
        arr[i2] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(this.#handle);
      return arr;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #columnNames;
  #rowObject;
  columnNames() {
    if (!this.#columnNames || !this.#unsafeConcurrency) {
      const columnCount = sqlite3_column_count(this.#handle);
      const columnNames = new Array(columnCount);
      for (let i2 = 0; i2 < columnCount; i2++) {
        columnNames[i2] = readCstr(sqlite3_column_name(this.#handle, i2));
      }
      this.#columnNames = columnNames;
      this.#rowObject = {};
      for (const name of columnNames) {
        this.#rowObject[name] = void 0;
      }
    }
    return this.#columnNames;
  }
  /** Fetch only first row as an object, if any. */
  get(...params) {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const columnNames = this.columnNames();
    const row = {};
    sqlite3_reset(handle);
    if (!this.#hasNoArgs && !this.#bound) {
      sqlite3_clear_bindings(handle);
      this.#bindRefs.clear();
      if (params.length) {
        this.#bindAll(params);
      }
    }
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < columnNames.length; i2++) {
        row[columnNames[i2]] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(this.#handle);
      return row;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #getNoArgs() {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const columnNames = this.columnNames();
    const row = this.#rowObject;
    sqlite3_reset(handle);
    const status = sqlite3_step(handle);
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < columnNames?.length; i2++) {
        row[columnNames[i2]] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(handle);
      return row;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  /** Free up the statement object. */
  finalize() {
    if (!STATEMENTS_TO_DB.has(this.#handle)) return;
    this.#bindRefs.clear();
    statementFinalizer.unregister(this.#finalizerToken);
    STATEMENTS_TO_DB.delete(this.#handle);
    unwrap(sqlite3_finalize(this.#handle));
  }
  /** Coerces the statement to a string, which in this case is expanded SQL. */
  toString() {
    return readCstr(sqlite3_expanded_sql(this.#handle));
  }
  /** Iterate over resultant rows from query. */
  *iter(...params) {
    this.#begin();
    this.#bindAll(params);
    const getRowObject = this.getRowObject();
    let status = sqlite3_step(this.#handle);
    while (status === SQLITE3_ROW) {
      yield getRowObject(this.#handle);
      status = sqlite3_step(this.#handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(this.#handle);
  }
  [_computedKey]() {
    return this.iter();
  }
  [_computedKey1]() {
    this.finalize();
  }
  [_computedKey2]() {
    return `Statement { ${this.expandedSql} }`;
  }
};

// deno:https://jsr.io/@db/sqlite/0.12.0/src/blob.ts
var _computedKey3;
var _computedKey12;
var { sqlite3_blob_open, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_read, sqlite3_blob_write } = ffi_default;
_computedKey3 = Symbol.iterator, _computedKey12 = Symbol.for("Deno.customInspect");
var SQLBlob = class {
  #handle;
  constructor(db3, options3) {
    options3 = Object.assign({
      readonly: true,
      db: "main"
    }, options3);
    const pHandle = new BigUint64Array(1);
    unwrap(sqlite3_blob_open(db3.unsafeHandle, toCString(options3.db ?? "main"), toCString(options3.table), toCString(options3.column), BigInt(options3.row), options3.readonly === false ? 1 : 0, pHandle));
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
  }
  /** Byte size of the Blob */
  get byteLength() {
    return sqlite3_blob_bytes(this.#handle);
  }
  /** Read from the Blob at given offset into a buffer (Uint8Array) */
  readSync(offset, p) {
    unwrap(sqlite3_blob_read(this.#handle, p, p.byteLength, offset));
  }
  /** Write a buffer (Uint8Array) at given offset in the Blob */
  writeSync(offset, p) {
    unwrap(sqlite3_blob_write(this.#handle, p, p.byteLength, offset));
  }
  /** Close the Blob. It **must** be called to prevent leaks. */
  close() {
    unwrap(sqlite3_blob_close(this.#handle));
  }
  /** Obtains Web Stream for reading the Blob */
  get readable() {
    const length4 = this.byteLength;
    let offset = 0;
    return new ReadableStream({
      type: "bytes",
      pull: (ctx) => {
        try {
          const byob = ctx.byobRequest;
          if (byob) {
            const toRead = Math.min(length4 - offset, byob.view.byteLength);
            this.readSync(offset, byob.view.subarray(0, toRead));
            offset += toRead;
            byob.respond(toRead);
          } else {
            const toRead = Math.min(length4 - offset, ctx.desiredSize || 1024 * 16);
            if (toRead === 0) {
              ctx.close();
              return;
            }
            const buffer = new Uint8Array(toRead);
            this.readSync(offset, buffer);
            offset += toRead;
            ctx.enqueue(buffer);
          }
        } catch (e2) {
          ctx.error(e2);
          ctx.byobRequest?.respond(0);
        }
      }
    });
  }
  /** Obtains Web Stream for writing to the Blob */
  get writable() {
    const length4 = this.byteLength;
    let offset = 0;
    return new WritableStream({
      write: (chunk, ctx) => {
        if (offset + chunk.byteLength > length4) {
          ctx.error(new Error("Write exceeds blob length"));
          return;
        }
        this.writeSync(offset, chunk);
        offset += chunk.byteLength;
      }
    });
  }
  *[_computedKey3]() {
    const length4 = this.byteLength;
    let offset = 0;
    while (offset < length4) {
      const toRead = Math.min(length4 - offset, 1024 * 16);
      const buffer = new Uint8Array(toRead);
      this.readSync(offset, buffer);
      offset += toRead;
      yield buffer;
    }
  }
  [_computedKey12]() {
    return `SQLite3.Blob(0x${this.byteLength.toString(16)})`;
  }
};

// deno:https://jsr.io/@db/sqlite/0.12.0/src/database.ts
var _computedKey4;
var { sqlite3_open_v2, sqlite3_close_v2, sqlite3_changes: sqlite3_changes2, sqlite3_total_changes, sqlite3_last_insert_rowid, sqlite3_get_autocommit, sqlite3_exec, sqlite3_free, sqlite3_libversion, sqlite3_sourceid, sqlite3_complete, sqlite3_finalize: sqlite3_finalize2, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_error, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double, sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type, sqlite3_create_function, sqlite3_result_int, sqlite3_aggregate_context, sqlite3_enable_load_extension, sqlite3_load_extension, sqlite3_backup_init, sqlite3_backup_step, sqlite3_backup_finish, sqlite3_errcode } = ffi_default;
var SQLITE_VERSION = readCstr(sqlite3_libversion());
var SQLITE_SOURCEID = readCstr(sqlite3_sourceid());
var BIG_MAX2 = BigInt(Number.MAX_SAFE_INTEGER);
_computedKey4 = Symbol.for("Deno.customInspect");
var Database = class {
  #path;
  #handle;
  #open = true;
  #enableLoadExtension = false;
  /** Whether to support BigInt columns. False by default, integers larger than 32 bit will be inaccurate. */
  int64;
  unsafeConcurrency;
  /** Whether DB connection is open */
  get open() {
    return this.#open;
  }
  /** Unsafe Raw (pointer) to the sqlite object */
  get unsafeHandle() {
    return this.#handle;
  }
  /** Path of the database file. */
  get path() {
    return this.#path;
  }
  /** Number of rows changed by the last executed statement. */
  get changes() {
    return sqlite3_changes2(this.#handle);
  }
  /** Number of rows changed since the database connection was opened. */
  get totalChanges() {
    return sqlite3_total_changes(this.#handle);
  }
  /** Gets last inserted Row ID */
  get lastInsertRowId() {
    return Number(sqlite3_last_insert_rowid(this.#handle));
  }
  /** Whether autocommit is enabled. Enabled by default, can be disabled using BEGIN statement. */
  get autocommit() {
    return sqlite3_get_autocommit(this.#handle) === 1;
  }
  /** Whether DB is in mid of a transaction */
  get inTransaction() {
    return this.#open && !this.autocommit;
  }
  get enableLoadExtension() {
    return this.#enableLoadExtension;
  }
  set enableLoadExtension(enabled2) {
    if (sqlite3_enable_load_extension === null) {
      throw new Error("Extension loading is not supported by the shared library that was used.");
    }
    const result = sqlite3_enable_load_extension(this.#handle, Number(enabled2));
    unwrap(result, this.#handle);
    this.#enableLoadExtension = enabled2;
  }
  constructor(path, options3 = {}) {
    this.#path = path instanceof URL ? fromFileUrl6(path) : path;
    let flags = 0;
    this.int64 = options3.int64 ?? false;
    this.unsafeConcurrency = options3.unsafeConcurrency ?? false;
    if (options3.flags !== void 0) {
      flags = options3.flags;
    } else {
      if (options3.memory) {
        flags |= SQLITE3_OPEN_MEMORY;
      }
      if (options3.readonly ?? false) {
        flags |= SQLITE3_OPEN_READONLY;
      } else {
        flags |= SQLITE3_OPEN_READWRITE;
      }
      if ((options3.create ?? true) && !options3.readonly) {
        flags |= SQLITE3_OPEN_CREATE;
      }
    }
    const pHandle = new BigUint64Array(1);
    const result = sqlite3_open_v2(toCString(this.#path), pHandle, flags, null);
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
    if (result !== 0) sqlite3_close_v2(this.#handle);
    unwrap(result);
    if (options3.enableLoadExtension) {
      this.enableLoadExtension = options3.enableLoadExtension;
    }
  }
  /**
   * Creates a new Prepared Statement from the given SQL statement.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = ?");
   *
   * for (const row of stmt.all(1)) {
   *   console.log(row);
   * }
   * ```
   *
   * Bind parameters can be either provided as an array of values, or as an object
   * mapping the parameter name to the value.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = ?");
   * const row = stmt.get(1);
   *
   * // or
   *
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = :id");
   * const row = stmt.get({ id: 1 });
   * ```
   *
   * Statements are automatically freed once GC catches them, however
   * you can also manually free using `finalize` method.
   *
   * @param sql SQL statement string
   * @returns Statement object
   */
  prepare(sql) {
    return new Statement(this, sql);
  }
  /**
   * Open a Blob for incremental I/O.
   *
   * Make sure to close the blob after you are done with it,
   * otherwise you will have memory leaks.
   */
  openBlob(options3) {
    return new SQLBlob(this, options3);
  }
  /**
   * Simply executes the SQL statement (supports multiple statements separated by semicolon).
   * Returns the number of changes made by last statement.
   *
   * Example:
   * ```ts
   * // Create table
   * db.exec("create table users (id integer not null, username varchar(20) not null)");
   *
   * // Inserts
   * db.exec("insert into users (id, username) values(?, ?)", id, username);
   *
   * // Insert with named parameters
   * db.exec("insert into users (id, username) values(:id, :username)", { id, username });
   *
   * // Pragma statements
   * db.exec("pragma journal_mode = WAL");
   * db.exec("pragma synchronous = normal");
   * db.exec("pragma temp_store = memory");
   * ```
   *
   * Under the hood, it uses `sqlite3_exec` if no parameters are given to bind
   * with the SQL statement, a prepared statement otherwise.
   */
  exec(sql, ...params) {
    if (params.length === 0) {
      const pErr = new BigUint64Array(1);
      sqlite3_exec(this.#handle, toCString(sql), null, null, new Uint8Array(pErr.buffer));
      const errPtr = Deno.UnsafePointer.create(pErr[0]);
      if (errPtr !== null) {
        const err = readCstr(errPtr);
        sqlite3_free(errPtr);
        throw new Error(err);
      }
      return sqlite3_changes2(this.#handle);
    }
    const stmt = this.prepare(sql);
    stmt.run(...params);
    return sqlite3_changes2(this.#handle);
  }
  /** Alias for `exec`. */
  run(sql, ...params) {
    return this.exec(sql, ...params);
  }
  /** Safely execute SQL with parameters using a tagged template */
  sql(strings, ...parameters) {
    const sql = strings.join("?");
    const stmt = this.prepare(sql);
    return stmt.all(...parameters);
  }
  /**
   * Wraps a callback function in a transaction.
   *
   * - When function is called, the transaction is started.
   * - When function returns, the transaction is committed.
   * - When function throws an error, the transaction is rolled back.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("insert into users (id, username) values(?, ?)");
   *
   * interface User {
   *   id: number;
   *   username: string;
   * }
   *
   * const insertUsers = db.transaction((data: User[]) => {
   *   for (const user of data) {
   *     stmt.run(user);
   *   }
   * });
   *
   * insertUsers([
   *   { id: 1, username: "alice" },
   *   { id: 2, username: "bob" },
   * ]);
   *
   * // May also use `insertUsers.deferred`, `immediate`, or `exclusive`.
   * // They corresspond to using `BEGIN DEFERRED`, `BEGIN IMMEDIATE`, and `BEGIN EXCLUSIVE`.
   * // For eg.
   *
   * insertUsers.deferred([
   *   { id: 1, username: "alice" },
   *   { id: 2, username: "bob" },
   * ]);
   * ```
   */
  transaction(fn) {
    const controller = getController(this);
    const properties = {
      default: {
        value: wrapTransaction(fn, this, controller.default)
      },
      deferred: {
        value: wrapTransaction(fn, this, controller.deferred)
      },
      immediate: {
        value: wrapTransaction(fn, this, controller.immediate)
      },
      exclusive: {
        value: wrapTransaction(fn, this, controller.exclusive)
      },
      database: {
        value: this,
        enumerable: true
      }
    };
    Object.defineProperties(properties.default.value, properties);
    Object.defineProperties(properties.deferred.value, properties);
    Object.defineProperties(properties.immediate.value, properties);
    Object.defineProperties(properties.exclusive.value, properties);
    return properties.default.value;
  }
  #callbacks = /* @__PURE__ */ new Set();
  /**
   * Creates a new user-defined function.
   *
   * Example:
   * ```ts
   * db.function("add", (a: number, b: number) => a + b);
   * db.prepare("select add(1, 2)").value<[number]>()!; // [3]
   * ```
   */
  function(name, fn, options3) {
    if (sqlite3_create_function === null) {
      throw new Error("User-defined functions are not supported by the shared library that was used.");
    }
    const cb = new Deno.UnsafeCallback({
      parameters: [
        "pointer",
        "i32",
        "pointer"
      ],
      result: "void"
    }, (ctx, nArgs, pArgs) => {
      const argptr = new Deno.UnsafePointerView(pArgs);
      const args = [];
      for (let i2 = 0; i2 < nArgs; i2++) {
        const arg = Deno.UnsafePointer.create(argptr.getBigUint64(i2 * 8));
        const type = sqlite3_value_type(arg);
        switch (type) {
          case SQLITE_INTEGER: {
            const value = sqlite3_value_int64(arg);
            if (value < -BIG_MAX2 || value > BIG_MAX2) {
              args.push(value);
            } else {
              args.push(Number(value));
            }
            break;
          }
          case SQLITE_FLOAT:
            args.push(sqlite3_value_double(arg));
            break;
          case SQLITE_TEXT:
            args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
            break;
          case SQLITE_BLOB:
            args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
            break;
          case SQLITE_NULL:
            args.push(null);
            break;
          default:
            throw new Error(`Unknown type: ${type}`);
        }
      }
      let result;
      try {
        result = fn(...args);
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      if (result === void 0 || result === null) {
        sqlite3_result_null(ctx);
      } else if (typeof result === "boolean") {
        sqlite3_result_int(ctx, result ? 1 : 0);
      } else if (typeof result === "number") {
        if (Number.isSafeInteger(result)) {
          sqlite3_result_int64(ctx, BigInt(result));
        } else sqlite3_result_double(ctx, result);
      } else if (typeof result === "bigint") {
        sqlite3_result_int64(ctx, result);
      } else if (typeof result === "string") {
        const buffer = new TextEncoder().encode(result);
        sqlite3_result_text(ctx, buffer, buffer.byteLength, 0n);
      } else if (result instanceof Uint8Array) {
        sqlite3_result_blob(ctx, result, result.length, -1n);
      } else {
        const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
        sqlite3_result_error(ctx, buffer, buffer.byteLength);
      }
    });
    let flags = 1;
    if (options3?.deterministic) {
      flags |= 2048;
    }
    if (options3?.directOnly) {
      flags |= 524288;
    }
    if (options3?.subtype) {
      flags |= 1048576;
    }
    if (options3?.directOnly) {
      flags |= 2097152;
    }
    const err = sqlite3_create_function(this.#handle, toCString(name), options3?.varargs ? -1 : fn.length, flags, null, cb.pointer, null, null);
    unwrap(err, this.#handle);
    this.#callbacks.add(cb);
  }
  /**
   * Creates a new user-defined aggregate function.
   */
  aggregate(name, options3) {
    if (sqlite3_aggregate_context === null || sqlite3_create_function === null) {
      throw new Error("User-defined functions are not supported by the shared library that was used.");
    }
    const contexts = /* @__PURE__ */ new Map();
    const cb = new Deno.UnsafeCallback({
      parameters: [
        "pointer",
        "i32",
        "pointer"
      ],
      result: "void"
    }, (ctx, nArgs, pArgs) => {
      const aggrCtx = sqlite3_aggregate_context(ctx, 8);
      const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
      let aggregate;
      if (contexts.has(aggrPtr)) {
        aggregate = contexts.get(aggrPtr);
      } else {
        aggregate = typeof options3.start === "function" ? options3.start() : options3.start;
        contexts.set(aggrPtr, aggregate);
      }
      const argptr = new Deno.UnsafePointerView(pArgs);
      const args = [];
      for (let i2 = 0; i2 < nArgs; i2++) {
        const arg = Deno.UnsafePointer.create(argptr.getBigUint64(i2 * 8));
        const type = sqlite3_value_type(arg);
        switch (type) {
          case SQLITE_INTEGER: {
            const value = sqlite3_value_int64(arg);
            if (value < -BIG_MAX2 || value > BIG_MAX2) {
              args.push(value);
            } else {
              args.push(Number(value));
            }
            break;
          }
          case SQLITE_FLOAT:
            args.push(sqlite3_value_double(arg));
            break;
          case SQLITE_TEXT:
            args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
            break;
          case SQLITE_BLOB:
            args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
            break;
          case SQLITE_NULL:
            args.push(null);
            break;
          default:
            throw new Error(`Unknown type: ${type}`);
        }
      }
      let result;
      try {
        result = options3.step(aggregate, ...args);
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      contexts.set(aggrPtr, result);
    });
    const cbFinal = new Deno.UnsafeCallback({
      parameters: [
        "pointer"
      ],
      result: "void"
    }, (ctx) => {
      const aggrCtx = sqlite3_aggregate_context(ctx, 0);
      const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
      const aggregate = contexts.get(aggrPtr);
      contexts.delete(aggrPtr);
      let result;
      try {
        result = options3.final ? options3.final(aggregate) : aggregate;
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      if (result === void 0 || result === null) {
        sqlite3_result_null(ctx);
      } else if (typeof result === "boolean") {
        sqlite3_result_int(ctx, result ? 1 : 0);
      } else if (typeof result === "number") {
        if (Number.isSafeInteger(result)) {
          sqlite3_result_int64(ctx, BigInt(result));
        } else sqlite3_result_double(ctx, result);
      } else if (typeof result === "bigint") {
        sqlite3_result_int64(ctx, result);
      } else if (typeof result === "string") {
        const buffer = new TextEncoder().encode(result);
        sqlite3_result_text(ctx, buffer, buffer.byteLength, 0n);
      } else if (result instanceof Uint8Array) {
        sqlite3_result_blob(ctx, result, result.length, -1n);
      } else {
        const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
        sqlite3_result_error(ctx, buffer, buffer.byteLength);
      }
    });
    let flags = 1;
    if (options3?.deterministic) {
      flags |= 2048;
    }
    if (options3?.directOnly) {
      flags |= 524288;
    }
    if (options3?.subtype) {
      flags |= 1048576;
    }
    if (options3?.directOnly) {
      flags |= 2097152;
    }
    const err = sqlite3_create_function(this.#handle, toCString(name), options3?.varargs ? -1 : options3.step.length - 1, flags, null, null, cb.pointer, cbFinal.pointer);
    unwrap(err, this.#handle);
    this.#callbacks.add(cb);
    this.#callbacks.add(cbFinal);
  }
  /**
   * Loads an SQLite extension library from the named file.
   */
  loadExtension(file, entryPoint) {
    if (sqlite3_load_extension === null) {
      throw new Error("Extension loading is not supported by the shared library that was used.");
    }
    if (!this.enableLoadExtension) {
      throw new Error("Extension loading is not enabled");
    }
    const pzErrMsg = new BigUint64Array(1);
    const result = sqlite3_load_extension(this.#handle, toCString(file), entryPoint ? toCString(entryPoint) : null, pzErrMsg);
    const pzErrPtr = Deno.UnsafePointer.create(pzErrMsg[0]);
    if (pzErrPtr !== null) {
      const pzErr = readCstr(pzErrPtr);
      sqlite3_free(pzErrPtr);
      throw new Error(pzErr);
    }
    unwrap(result, this.#handle);
  }
  /**
   * Closes the database connection.
   *
   * Calling this method more than once is no-op.
   */
  close() {
    if (!this.#open) return;
    for (const [stmt, db3] of STATEMENTS_TO_DB) {
      if (db3 === this.#handle) {
        sqlite3_finalize2(stmt);
        STATEMENTS_TO_DB.delete(stmt);
      }
    }
    for (const cb of this.#callbacks) {
      cb.close();
    }
    unwrap(sqlite3_close_v2(this.#handle));
    this.#open = false;
  }
  /**
   * @param dest The destination database connection.
   * @param name Destination database name. "main" for main database, "temp" for temporary database, or the name specified after the AS keyword in an ATTACH statement for an attached database.
   * @param pages The number of pages to copy. If it is negative, all remaining pages are copied (default).
   */
  backup(dest, name = "main", pages = -1) {
    const backup = sqlite3_backup_init(dest.#handle, toCString(name), this.#handle, toCString("main"));
    if (backup) {
      unwrap(sqlite3_backup_step(backup, pages));
      unwrap(sqlite3_backup_finish(backup));
    } else {
      unwrap(sqlite3_errcode(dest.#handle), dest.#handle);
    }
  }
  [_computedKey4]() {
    return `SQLite3.Database { path: ${this.path} }`;
  }
};
var controllers = /* @__PURE__ */ new WeakMap();
var getController = (db3) => {
  let controller = controllers.get(db3);
  if (!controller) {
    const shared = {
      commit: db3.prepare("COMMIT"),
      rollback: db3.prepare("ROLLBACK"),
      savepoint: db3.prepare("SAVEPOINT `	_bs3.	`"),
      release: db3.prepare("RELEASE `	_bs3.	`"),
      rollbackTo: db3.prepare("ROLLBACK TO `	_bs3.	`")
    };
    controllers.set(db3, controller = {
      default: Object.assign({
        begin: db3.prepare("BEGIN")
      }, shared),
      deferred: Object.assign({
        begin: db3.prepare("BEGIN DEFERRED")
      }, shared),
      immediate: Object.assign({
        begin: db3.prepare("BEGIN IMMEDIATE")
      }, shared),
      exclusive: Object.assign({
        begin: db3.prepare("BEGIN EXCLUSIVE")
      }, shared)
    });
  }
  return controller;
};
var wrapTransaction = (fn, db3, { begin, commit, rollback, savepoint, release, rollbackTo }) => function sqliteTransaction(...args) {
  const { apply } = Function.prototype;
  let before, after, undo;
  if (db3.inTransaction) {
    before = savepoint;
    after = release;
    undo = rollbackTo;
  } else {
    before = begin;
    after = commit;
    undo = rollback;
  }
  before.run();
  try {
    const result = apply.call(fn, this, args);
    after.run();
    return result;
  } catch (ex) {
    if (!db3.autocommit) {
      undo.run();
      if (undo !== rollback) after.run();
    }
    throw ex;
  }
};

// build/main.js-tmp
import path8 from "node:path";
import process2 from "node:process";
import process3 from "node:process";
import { Buffer as Buffer22 } from "node:buffer";
import { Buffer as Buffer3 } from "node:buffer";
import { Buffer as Buffer4 } from "node:buffer";
import { Buffer as Buffer5 } from "node:buffer";
import { Buffer as Buffer6 } from "node:buffer";
import { Buffer as Buffer7 } from "node:buffer";
import process4 from "node:process";
import { Buffer as Buffer8 } from "node:buffer";
import { Buffer as Buffer9 } from "node:buffer";
import { randomBytes as randomBytes2, timingSafeEqual } from "node:crypto";
import { mkdir, readdir, readFile, rm, unlink, writeFile } from "node:fs/promises";
import { basename as basename42, dirname as dirname42, join as join6, normalize as normalize6, resolve as resolve52 } from "node:path";
import process5 from "node:process";
import { mkdir as mkdir2 } from "node:fs/promises";
import { basename as basename52, dirname as dirname52, join as join7, resolve as resolve6 } from "node:path";
import { resolve as resolve7 } from "node:path";
import { readFile as readFile2 } from "node:fs/promises";
import process6 from "node:process";
import fs from "node:fs";
import { readFile as readFile3, readdir as readdir2 } from "node:fs/promises";
import path9 from "node:path";
import process7 from "node:process";
import { Readable } from "node:stream";
import { Buffer as Buffer10 } from "node:buffer";
import process8 from "node:process";
import { Buffer as Buffer11 } from "node:buffer";
import { isIP } from "node:net";
import path10 from "node:path";
import process9 from "node:process";
import { basename as basename6, join as join8 } from "node:path";
import process10 from "node:process";
import { Worker } from "node:worker_threads";
import process11 from "node:process";

// deno:https://jsr.io/@std/encoding/1.0.10/_common64.ts
var padding = "=".charCodeAt(0);
var alphabet3 = {
  base64: new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
  base64url: new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")
};
var rAlphabet3 = {
  base64: new Uint8Array(128).fill(64),
  base64url: new Uint8Array(128).fill(64)
};
alphabet3.base64.forEach((byte, i2) => rAlphabet3.base64[byte] = i2);
alphabet3.base64url.forEach((byte, i2) => rAlphabet3.base64url[byte] = i2);
function decode2(buffer, i2, o2, alphabet5, padding3) {
  for (let x3 = buffer.length - 2; x3 < buffer.length; ++x3) {
    if (buffer[x3] === padding3) {
      for (let y = x3 + 1; y < buffer.length; ++y) {
        if (buffer[y] !== padding3) {
          throw new TypeError(`Cannot decode input as base64: Invalid character (${String.fromCharCode(buffer[y])})`);
        }
      }
      buffer = buffer.subarray(0, x3);
      break;
    }
  }
  if ((buffer.length - o2) % 4 === 1) {
    throw new RangeError(`Cannot decode input as base64: Length (${buffer.length - o2}), excluding padding, must not have a remainder of 1 when divided by 4`);
  }
  i2 += 3;
  for (; i2 < buffer.length; i2 += 4) {
    const x3 = getByte(buffer[i2 - 3], alphabet5) << 18 | getByte(buffer[i2 - 2], alphabet5) << 12 | getByte(buffer[i2 - 1], alphabet5) << 6 | getByte(buffer[i2], alphabet5);
    buffer[o2++] = x3 >> 16;
    buffer[o2++] = x3 >> 8 & 255;
    buffer[o2++] = x3 & 255;
  }
  switch (i2) {
    case buffer.length + 1: {
      const x3 = getByte(buffer[i2 - 3], alphabet5) << 18 | getByte(buffer[i2 - 2], alphabet5) << 12;
      buffer[o2++] = x3 >> 16;
      break;
    }
    case buffer.length: {
      const x3 = getByte(buffer[i2 - 3], alphabet5) << 18 | getByte(buffer[i2 - 2], alphabet5) << 12 | getByte(buffer[i2 - 1], alphabet5) << 6;
      buffer[o2++] = x3 >> 16;
      buffer[o2++] = x3 >> 8 & 255;
      break;
    }
  }
  return o2;
}
function getByte(char, alphabet5) {
  const byte = alphabet5[char] ?? 64;
  if (byte === 64) {
    throw new TypeError(`Cannot decode input as base64: Invalid character (${String.fromCharCode(char)})`);
  }
  return byte;
}

// deno:https://jsr.io/@std/encoding/1.0.10/base64.ts
var padding2 = "=".charCodeAt(0);
var alphabet4 = new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var rAlphabet4 = new Uint8Array(128).fill(64);
alphabet4.forEach((byte, i2) => rAlphabet4[byte] = i2);
function decodeBase64(b64) {
  const output = new TextEncoder().encode(b64);
  return new Uint8Array(output.buffer.transfer(decode2(output, 0, 0, rAlphabet4, padding2)));
}

// deno:https://jsr.io/@std/assert/0.224.0/assertion_error.ts
var AssertionError2 = class extends Error {
  /** Constructs a new instance. */
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};

// deno:https://jsr.io/@std/assert/0.224.0/assert_exists.ts
function assertExists(actual, msg) {
  if (actual === void 0 || actual === null) {
    const msgSuffix = msg ? `: ${msg}` : ".";
    msg = `Expected actual: "${actual}" to not be null or undefined${msgSuffix}`;
    throw new AssertionError2(msg);
  }
}

// deno:https://jsr.io/@std/flags/0.224.0/mod.ts
var { hasOwn } = Object;
function get(obj, key) {
  if (hasOwn(obj, key)) {
    return obj[key];
  }
}
function getForce(obj, key) {
  const v2 = get(obj, key);
  assertExists(v2);
  return v2;
}
function isNumber(x3) {
  if (typeof x3 === "number") return true;
  if (/^0x[0-9a-f]+$/i.test(String(x3))) return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x3));
}
function hasKey(obj, keys) {
  let o2 = obj;
  keys.slice(0, -1).forEach((key2) => {
    o2 = get(o2, key2) ?? {};
  });
  const key = keys.at(-1);
  return key !== void 0 && hasOwn(o2, key);
}
function parse6(args, { "--": doubleDash = false, alias = {}, boolean = false, default: defaults = {}, stopEarly = false, string: string3 = [], collect = [], negatable = [], unknown: unknown2 = (i2) => i2 } = {}) {
  const aliases = {};
  const flags = {
    bools: {},
    strings: {},
    unknownFn: unknown2,
    allBools: false,
    collect: {},
    negatable: {}
  };
  if (alias !== void 0) {
    for (const key in alias) {
      const val = getForce(alias, key);
      if (typeof val === "string") {
        aliases[key] = [
          val
        ];
      } else {
        aliases[key] = val;
      }
      const aliasesForKey = getForce(aliases, key);
      for (const alias2 of aliasesForKey) {
        aliases[alias2] = [
          key
        ].concat(aliasesForKey.filter((y) => alias2 !== y));
      }
    }
  }
  if (boolean !== void 0) {
    if (typeof boolean === "boolean") {
      flags.allBools = !!boolean;
    } else {
      const booleanArgs = typeof boolean === "string" ? [
        boolean
      ] : boolean;
      for (const key of booleanArgs.filter(Boolean)) {
        flags.bools[key] = true;
        const alias2 = get(aliases, key);
        if (alias2) {
          for (const al of alias2) {
            flags.bools[al] = true;
          }
        }
      }
    }
  }
  if (string3 !== void 0) {
    const stringArgs = typeof string3 === "string" ? [
      string3
    ] : string3;
    for (const key of stringArgs.filter(Boolean)) {
      flags.strings[key] = true;
      const alias2 = get(aliases, key);
      if (alias2) {
        for (const al of alias2) {
          flags.strings[al] = true;
        }
      }
    }
  }
  if (collect !== void 0) {
    const collectArgs = typeof collect === "string" ? [
      collect
    ] : collect;
    for (const key of collectArgs.filter(Boolean)) {
      flags.collect[key] = true;
      const alias2 = get(aliases, key);
      if (alias2) {
        for (const al of alias2) {
          flags.collect[al] = true;
        }
      }
    }
  }
  if (negatable !== void 0) {
    const negatableArgs = typeof negatable === "string" ? [
      negatable
    ] : negatable;
    for (const key of negatableArgs.filter(Boolean)) {
      flags.negatable[key] = true;
      const alias2 = get(aliases, key);
      if (alias2) {
        for (const al of alias2) {
          flags.negatable[al] = true;
        }
      }
    }
  }
  const argv = {
    _: []
  };
  function argDefined(key, arg) {
    return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
  }
  function setKey(obj, name, value, collect2 = true) {
    let o2 = obj;
    const keys = name.split(".");
    keys.slice(0, -1).forEach(function(key2) {
      if (get(o2, key2) === void 0) {
        o2[key2] = {};
      }
      o2 = get(o2, key2);
    });
    const key = keys.at(-1);
    const collectable = collect2 && !!get(flags.collect, name);
    if (!collectable) {
      o2[key] = value;
    } else if (get(o2, key) === void 0) {
      o2[key] = [
        value
      ];
    } else if (Array.isArray(get(o2, key))) {
      o2[key].push(value);
    } else {
      o2[key] = [
        get(o2, key),
        value
      ];
    }
  }
  function setArg(key, val, arg = void 0, collect2) {
    if (arg && flags.unknownFn && !argDefined(key, arg)) {
      if (flags.unknownFn(arg, key, val) === false) return;
    }
    const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
    setKey(argv, key, value, collect2);
    const alias2 = get(aliases, key);
    if (alias2) {
      for (const x3 of alias2) {
        setKey(argv, x3, value, collect2);
      }
    }
  }
  function aliasIsBoolean(key) {
    return getForce(aliases, key).some((x3) => typeof get(flags.bools, x3) === "boolean");
  }
  let notFlags = [];
  if (args.includes("--")) {
    notFlags = args.slice(args.indexOf("--") + 1);
    args = args.slice(0, args.indexOf("--"));
  }
  for (let i2 = 0; i2 < args.length; i2++) {
    const arg = args[i2];
    assertExists(arg);
    if (/^--.+=/.test(arg)) {
      const m3 = arg.match(/^--([^=]+)=(.*)$/s);
      assertExists(m3);
      const [, key, value] = m3;
      assertExists(key);
      if (flags.bools[key]) {
        const booleanValue = value !== "false";
        setArg(key, booleanValue, arg);
      } else {
        setArg(key, value, arg);
      }
    } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
      const m3 = arg.match(/^--no-(.+)/);
      assertExists(m3);
      assertExists(m3[1]);
      setArg(m3[1], false, arg, false);
    } else if (/^--.+/.test(arg)) {
      const m3 = arg.match(/^--(.+)/);
      assertExists(m3);
      assertExists(m3[1]);
      const [, key] = m3;
      const next = args[i2 + 1];
      if (next !== void 0 && !/^-/.test(next) && !get(flags.bools, key) && !flags.allBools && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
        setArg(key, next, arg);
        i2++;
      } else if (next !== void 0 && (next === "true" || next === "false")) {
        setArg(key, next === "true", arg);
        i2++;
      } else {
        setArg(key, get(flags.strings, key) ? "" : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      const letters = arg.slice(1, -1).split("");
      let broken = false;
      for (const [j, letter] of letters.entries()) {
        const next = arg.slice(j + 2);
        if (next === "-") {
          setArg(letter, next, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letter) && next.includes("=")) {
          setArg(letter, next.split(/=(.+)/)[1], arg);
          broken = true;
          break;
        }
        if (/[A-Za-z]/.test(letter) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letter, next, arg);
          broken = true;
          break;
        }
        if (letters[j + 1]?.match(/\W/)) {
          setArg(letter, arg.slice(j + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letter, get(flags.strings, letter) ? "" : true, arg);
        }
      }
      const key = arg.at(-1);
      if (!broken && key !== "-") {
        const nextArg = args[i2 + 1];
        if (nextArg && !/^(-|--)[^-]/.test(nextArg) && !get(flags.bools, key) && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
          setArg(key, nextArg, arg);
          i2++;
        } else if (nextArg && (nextArg === "true" || nextArg === "false")) {
          setArg(key, nextArg === "true", arg);
          i2++;
        } else {
          setArg(key, get(flags.strings, key) ? "" : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
      }
      if (stopEarly) {
        argv._.push(...args.slice(i2 + 1));
        break;
      }
    }
  }
  for (const [key, value] of Object.entries(defaults)) {
    if (!hasKey(argv, key.split("."))) {
      setKey(argv, key, value, false);
      const alias2 = aliases[key];
      if (alias2 !== void 0) {
        for (const x3 of alias2) {
          setKey(argv, x3, value, false);
        }
      }
    }
  }
  for (const key of Object.keys(flags.bools)) {
    if (!hasKey(argv, key.split("."))) {
      const value = get(flags.collect, key) ? [] : false;
      setKey(argv, key, value, false);
    }
  }
  for (const key of Object.keys(flags.strings)) {
    if (!hasKey(argv, key.split(".")) && get(flags.collect, key)) {
      setKey(argv, key, [], false);
    }
  }
  if (doubleDash) {
    argv["--"] = [];
    for (const key of notFlags) {
      argv["--"].push(key);
    }
  } else {
    for (const key of notFlags) {
      argv._.push(key);
    }
  }
  return argv;
}

// deno:https://jsr.io/@std/io/0.225.2/buffer.ts
var MIN_READ = 32 * 1024;
var MAX_SIZE = 2 ** 32 - 2;

// deno:https://jsr.io/@std/io/0.225.2/_constants.ts
var DEFAULT_BUFFER_SIZE = 32 * 1024;

// deno:https://jsr.io/@std/io/0.225.2/write_all.ts
async function writeAll(writer, data) {
  let nwritten = 0;
  while (nwritten < data.length) {
    nwritten += await writer.write(data.subarray(nwritten));
  }
}

// build/main.js-tmp
import process12 from "node:process";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x3) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
}) : x3)(function(x3) {
  if (typeof __require !== "undefined") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x3 + '" is not supported');
});
var __glob = (map) => (path12) => {
  var fn = map[path12];
  if (fn) return fn();
  throw new Error("Module not found in bundle: " + path12);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require22() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from6, except, desc) => {
  if (from6 && typeof from6 === "object" || typeof from6 === "function") {
    for (let key of __getOwnPropNames(from6))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from6[key], enumerable: !(desc = __getOwnPropDesc(from6, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_util = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/util.js"(exports2, module2) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder3 = new TextEncoder();
        ret = encoder3.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex2(bytes) {
      return Array.prototype.map.call(bytes, function(n) {
        return (n < 16 ? "0" : "") + n.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i2 = 0; i2 < arr.length; i2 += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i2]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i2]).toUpperCase();
        } else throw new Error("Invalid size " + size);
        if (i2 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i2 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N11, M2) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N11);
      for (let i2 = 0; i2 < N11; i2++) {
        input[i2] = i2 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i2 = 0; i2 < M2; i2++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N11 / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module2.exports = {
      normalizeInput,
      toHex: toHex2,
      debugPrint,
      testSpeed
    };
  }
});
var require_blake2b = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2b.js"(exports2, module2) {
    var util = require_util();
    function ADD64AA(v3, a, b) {
      const o0 = v3[a] + v3[b];
      let o1 = v3[a + 1] + v3[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v3[a] = o0;
      v3[a + 1] = o1;
    }
    function ADD64AC(v3, a, b0, b1) {
      let o0 = v3[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v3[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v3[a] = o0;
      v3[a + 1] = o1;
    }
    function B2B_GET32(arr, i2) {
      return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
    }
    function B2B_G(a, b, c, d, ix, iy) {
      const x0 = m3[ix];
      const x1 = m3[ix + 1];
      const y0 = m3[iy];
      const y1 = m3[iy + 1];
      ADD64AA(v2, a, b);
      ADD64AC(v2, a, x0, x1);
      let xor0 = v2[d] ^ v2[a];
      let xor1 = v2[d + 1] ^ v2[a + 1];
      v2[d] = xor1;
      v2[d + 1] = xor0;
      ADD64AA(v2, c, d);
      xor0 = v2[b] ^ v2[c];
      xor1 = v2[b + 1] ^ v2[c + 1];
      v2[b] = xor0 >>> 24 ^ xor1 << 8;
      v2[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v2, a, b);
      ADD64AC(v2, a, y0, y1);
      xor0 = v2[d] ^ v2[a];
      xor1 = v2[d + 1] ^ v2[a + 1];
      v2[d] = xor0 >>> 16 ^ xor1 << 16;
      v2[d + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v2, c, d);
      xor0 = v2[b] ^ v2[c];
      xor1 = v2[b + 1] ^ v2[c + 1];
      v2[b] = xor1 >>> 31 ^ xor0 << 1;
      v2[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x3) {
        return x3 * 2;
      })
    );
    var v2 = new Uint32Array(32);
    var m3 = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 16; i2++) {
        v2[i2] = ctx.h[i2];
        v2[i2 + 16] = BLAKE2B_IV32[i2];
      }
      v2[24] = v2[24] ^ ctx.t;
      v2[25] = v2[25] ^ ctx.t / 4294967296;
      if (last) {
        v2[28] = ~v2[28];
        v2[29] = ~v2[29];
      }
      for (i2 = 0; i2 < 32; i2++) {
        m3[i2] = B2B_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 12; i2++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
      }
      for (i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = ctx.h[i2] ^ v2[i2] ^ v2[i2 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit2(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameterBlock, i2 * 4);
      }
      if (key) {
        blake2bUpdate2(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate2(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2bFinal2(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
      }
      return out;
    }
    function blake2b4(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit2(outlen, key, salt, personal);
      blake2bUpdate2(ctx, input);
      return blake2bFinal2(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b4(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module2.exports = {
      blake2b: blake2b4,
      blake2bHex,
      blake2bInit: blake2bInit2,
      blake2bUpdate: blake2bUpdate2,
      blake2bFinal: blake2bFinal2
    };
  }
});
var require_blake2s = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2s.js"(exports2, module2) {
    var util = require_util();
    function B2S_GET32(v3, i2) {
      return v3[i2] ^ v3[i2 + 1] << 8 ^ v3[i2 + 2] << 16 ^ v3[i2 + 3] << 24;
    }
    function B2S_G(a, b, c, d, x3, y) {
      v2[a] = v2[a] + v2[b] + x3;
      v2[d] = ROTR32(v2[d] ^ v2[a], 16);
      v2[c] = v2[c] + v2[d];
      v2[b] = ROTR32(v2[b] ^ v2[c], 12);
      v2[a] = v2[a] + v2[b] + y;
      v2[d] = ROTR32(v2[d] ^ v2[a], 8);
      v2[c] = v2[c] + v2[d];
      v2[b] = ROTR32(v2[b] ^ v2[c], 7);
    }
    function ROTR32(x3, y) {
      return x3 >>> y ^ x3 << 32 - y;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v2 = new Uint32Array(16);
    var m3 = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 8; i2++) {
        v2[i2] = ctx.h[i2];
        v2[i2 + 8] = BLAKE2S_IV[i2];
      }
      v2[12] ^= ctx.t;
      v2[13] ^= ctx.t / 4294967296;
      if (last) {
        v2[14] = ~v2[14];
      }
      for (i2 = 0; i2 < 16; i2++) {
        m3[i2] = B2S_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 10; i2++) {
        B2S_G(0, 4, 8, 12, m3[SIGMA[i2 * 16 + 0]], m3[SIGMA[i2 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m3[SIGMA[i2 * 16 + 2]], m3[SIGMA[i2 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m3[SIGMA[i2 * 16 + 4]], m3[SIGMA[i2 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m3[SIGMA[i2 * 16 + 6]], m3[SIGMA[i2 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m3[SIGMA[i2 * 16 + 8]], m3[SIGMA[i2 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m3[SIGMA[i2 * 16 + 10]], m3[SIGMA[i2 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m3[SIGMA[i2 * 16 + 12]], m3[SIGMA[i2 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m3[SIGMA[i2 * 16 + 14]], m3[SIGMA[i2 * 16 + 15]]);
      }
      for (i2 = 0; i2 < 8; i2++) {
        ctx.h[i2] ^= v2[i2] ^ v2[i2 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3) & 255;
      }
      return out;
    }
    function blake2s2(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s2(input, key, outlen);
      return util.toHex(output);
    }
    module2.exports = {
      blake2s: blake2s2,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});
var require_blakejs = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/index.js"(exports2, module2) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module2.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty;
var toHex;
var fromHex;
var equals;
var coerce;
var isBinary;
var fromString;
var toString;
var init_bytes = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    fromHex = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty;
    };
    equals = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o2) => {
      if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
        return o2;
      if (o2 instanceof ArrayBuffer)
        return new Uint8Array(o2);
      if (ArrayBuffer.isView(o2)) {
        return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    isBinary = (o2) => o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b) => new TextDecoder().decode(b);
  }
});
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1;
var MSB;
var REST;
var MSBALL;
var INT;
var decode3;
var MSB$1;
var REST$1;
var N1;
var N2;
var N3;
var N4;
var N5;
var N6;
var N7;
var N8;
var N9;
var length;
var varint;
var _brrp_varint;
var varint_default;
var init_varint = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode3;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode3 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode3,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});
var decode22;
var encodeTo;
var encodingLength;
var init_varint2 = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode22 = (data, offset = 0) => {
      const code2 = varint_default.decode(data, offset);
      return [
        code2,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});
var create;
var decode32;
var equals2;
var Digest;
var init_digest = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create = (code2, digest) => {
      const size = digest.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code2, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest, digestOffset);
      return new Digest(code2, size, digest, bytes);
    };
    decode32 = (multihash) => {
      const bytes = coerce(multihash);
      const [code2, sizeOffset] = decode22(bytes);
      const [size, digestOffset] = decode22(bytes.subarray(sizeOffset));
      const digest = bytes.subarray(sizeOffset + digestOffset);
      if (digest.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size, digest, bytes);
    };
    equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
      }
    };
    Digest = class {
      constructor(code2, size, digest, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
      }
    };
  }
});
var from;
var Hasher;
var init_hasher = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from = ({ name, code: code2, encode: encode7 }) => new Hasher(name, code2, encode7);
    Hasher = class {
      constructor(name, code2, encode7) {
        this.name = name;
        this.code = code2;
        this.encode = encode7;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest) => create(this.code, digest));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x3 = ALPHABET.charAt(i2);
    var xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode13(string3) {
    var buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode7,
    decodeUnsafe,
    decode: decode13
  };
}
var src;
var _brrp__multiformats_scope_baseX;
var base_x_default;
var init_base_x = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js"() {
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});
var Encoder;
var Decoder;
var ComposedDecoder;
var or;
var Codec;
var from2;
var baseX;
var decode4;
var encode22;
var rfc4648;
var init_base = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from2 = ({ name, prefix, encode: encode7, decode: decode13 }) => new Codec(name, prefix, encode7, decode13);
    baseX = ({ prefix, name, alphabet: alphabet5 }) => {
      const { encode: encode7, decode: decode13 } = base_x_default(alphabet5, name);
      return from2({
        prefix,
        name,
        encode: encode7,
        decode: (text) => coerce(decode13(text))
      });
    };
    decode4 = (string3, alphabet5, bitsPerChar, name) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet5.length; ++i2) {
        codes[alphabet5[i2]] = i2;
      }
      let end = string3.length;
      while (string3[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string3[i2]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode22 = (data, alphabet5, bitsPerChar) => {
      const pad = alphabet5[alphabet5.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer = buffer << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet5[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet5[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name, prefix, bitsPerChar, alphabet: alphabet5 }) => {
      return from2({
        prefix,
        name,
        encode(input) {
          return encode22(input, alphabet5, bitsPerChar);
        },
        decode(input) {
          return decode4(input, alphabet5, bitsPerChar, name);
        }
      });
    };
  }
});
var base58btc;
var base58flickr;
var init_base58 = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});
var base32;
var base32upper;
var base32pad;
var base32padupper;
var base32hex;
var base32hexupper;
var base32hexpad;
var base32hexpadupper;
var base32z;
var init_base32 = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});
var CID;
var parseCIDtoBytes;
var toStringV0;
var toStringV1;
var DAG_PB_CODE;
var SHA_256_CODE;
var encodeCID;
var cidSymbol;
var readonly2;
var hidden;
var version2;
var deprecate;
var IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class _CID {
      constructor(version4, code2, multihash, bytes) {
        this.code = code2;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly2,
          version: readonly2,
          multihash: readonly2,
          bytes: readonly2,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest } = this.multihash;
            const multihash = create(code2, digest);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base4) {
        const { bytes, version: version4, _baseCache } = this;
        switch (version4) {
          case 0:
            return toStringV0(bytes, _baseCache, base4 || base58btc.encoder);
          default:
            return toStringV1(bytes, _baseCache, base4 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version4, code: code2, multihash, bytes } = value;
          return new _CID(version4, code2, multihash, bytes || encodeCID(version4, code2, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version4, multihash, code: code2 } = value;
          const digest = decode32(multihash);
          return _CID.create(version4, code2, digest);
        } else {
          return null;
        }
      }
      static create(version4, code2, digest) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version4) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version4, code2, digest, digest.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version4, code2, digest.bytes);
            return new _CID(version4, code2, digest, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest) {
        return _CID.create(0, DAG_PB_CODE, digest);
      }
      static createV1(code2, digest) {
        return _CID.create(1, code2, digest);
      }
      static decode(bytes) {
        const [cid, remainder] = _CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = _CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
        return [
          cid,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i2, length4] = decode22(initialBytes.subarray(offset));
          offset += length4;
          return i2;
        };
        let version4 = next();
        let codec = DAG_PB_CODE;
        if (version4 === 18) {
          version4 = 0;
          offset = 0;
        } else if (version4 === 1) {
          codec = next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version4,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base4) {
        const [prefix, bytes] = parseCIDtoBytes(source, base4);
        const cid = _CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base4) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base4 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base4 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base4.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes, cache3, base4) => {
      const { prefix } = base4;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
      }
      const cid = cache3.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes).slice(1);
        cache3.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes, cache3, base4) => {
      const { prefix } = base4;
      const cid = cache3.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes);
        cache3.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version4, code2, multihash) => {
      const codeOffset = encodingLength(version4);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version4, bytes, 0);
      encodeTo(code2, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly2 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version2 = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version2)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});
var init_src = __esm({
  "node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});
var blake2b_exports = {};
__export(blake2b_exports, {
  blake2b104: () => blake2b104,
  blake2b112: () => blake2b112,
  blake2b120: () => blake2b120,
  blake2b128: () => blake2b128,
  blake2b136: () => blake2b136,
  blake2b144: () => blake2b144,
  blake2b152: () => blake2b152,
  blake2b16: () => blake2b16,
  blake2b160: () => blake2b160,
  blake2b168: () => blake2b168,
  blake2b176: () => blake2b176,
  blake2b184: () => blake2b184,
  blake2b192: () => blake2b192,
  blake2b200: () => blake2b200,
  blake2b208: () => blake2b208,
  blake2b216: () => blake2b216,
  blake2b224: () => blake2b224,
  blake2b232: () => blake2b232,
  blake2b24: () => blake2b24,
  blake2b240: () => blake2b240,
  blake2b248: () => blake2b248,
  blake2b256: () => blake2b256,
  blake2b264: () => blake2b264,
  blake2b272: () => blake2b272,
  blake2b280: () => blake2b280,
  blake2b288: () => blake2b288,
  blake2b296: () => blake2b296,
  blake2b304: () => blake2b304,
  blake2b312: () => blake2b312,
  blake2b32: () => blake2b32,
  blake2b320: () => blake2b320,
  blake2b328: () => blake2b328,
  blake2b336: () => blake2b336,
  blake2b344: () => blake2b344,
  blake2b352: () => blake2b352,
  blake2b360: () => blake2b360,
  blake2b368: () => blake2b368,
  blake2b376: () => blake2b376,
  blake2b384: () => blake2b384,
  blake2b392: () => blake2b392,
  blake2b40: () => blake2b40,
  blake2b400: () => blake2b400,
  blake2b408: () => blake2b408,
  blake2b416: () => blake2b416,
  blake2b424: () => blake2b424,
  blake2b432: () => blake2b432,
  blake2b440: () => blake2b440,
  blake2b448: () => blake2b448,
  blake2b456: () => blake2b456,
  blake2b464: () => blake2b464,
  blake2b472: () => blake2b472,
  blake2b48: () => blake2b48,
  blake2b480: () => blake2b480,
  blake2b488: () => blake2b488,
  blake2b496: () => blake2b496,
  blake2b504: () => blake2b504,
  blake2b512: () => blake2b512,
  blake2b56: () => blake2b56,
  blake2b64: () => blake2b64,
  blake2b72: () => blake2b72,
  blake2b8: () => blake2b8,
  blake2b80: () => blake2b80,
  blake2b88: () => blake2b88,
  blake2b96: () => blake2b96
});
var import_blakejs;
var blake2b;
var blake2b8;
var blake2b16;
var blake2b24;
var blake2b32;
var blake2b40;
var blake2b48;
var blake2b56;
var blake2b64;
var blake2b72;
var blake2b80;
var blake2b88;
var blake2b96;
var blake2b104;
var blake2b112;
var blake2b120;
var blake2b128;
var blake2b136;
var blake2b144;
var blake2b152;
var blake2b160;
var blake2b168;
var blake2b176;
var blake2b184;
var blake2b192;
var blake2b200;
var blake2b208;
var blake2b216;
var blake2b224;
var blake2b232;
var blake2b240;
var blake2b248;
var blake2b256;
var blake2b264;
var blake2b272;
var blake2b280;
var blake2b288;
var blake2b296;
var blake2b304;
var blake2b312;
var blake2b320;
var blake2b328;
var blake2b336;
var blake2b344;
var blake2b352;
var blake2b360;
var blake2b368;
var blake2b376;
var blake2b384;
var blake2b392;
var blake2b400;
var blake2b408;
var blake2b416;
var blake2b424;
var blake2b432;
var blake2b440;
var blake2b448;
var blake2b456;
var blake2b464;
var blake2b472;
var blake2b480;
var blake2b488;
var blake2b496;
var blake2b504;
var blake2b512;
var init_blake2b = __esm({
  "node_modules/.deno/@multiformats+blake2@1.0.13/node_modules/@multiformats/blake2/esm/blake2b.js"() {
    import_blakejs = __toESM(require_blakejs(), 1);
    init_hasher();
    init_src();
    ({ blake2b } = import_blakejs.default);
    blake2b8 = from({
      name: "blake2b-8",
      code: 45569,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 1))
    });
    blake2b16 = from({
      name: "blake2b-16",
      code: 45570,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 2))
    });
    blake2b24 = from({
      name: "blake2b-24",
      code: 45571,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 3))
    });
    blake2b32 = from({
      name: "blake2b-32",
      code: 45572,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 4))
    });
    blake2b40 = from({
      name: "blake2b-40",
      code: 45573,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 5))
    });
    blake2b48 = from({
      name: "blake2b-48",
      code: 45574,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 6))
    });
    blake2b56 = from({
      name: "blake2b-56",
      code: 45575,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 7))
    });
    blake2b64 = from({
      name: "blake2b-64",
      code: 45576,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 8))
    });
    blake2b72 = from({
      name: "blake2b-72",
      code: 45577,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 9))
    });
    blake2b80 = from({
      name: "blake2b-80",
      code: 45578,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 10))
    });
    blake2b88 = from({
      name: "blake2b-88",
      code: 45579,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 11))
    });
    blake2b96 = from({
      name: "blake2b-96",
      code: 45580,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 12))
    });
    blake2b104 = from({
      name: "blake2b-104",
      code: 45581,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 13))
    });
    blake2b112 = from({
      name: "blake2b-112",
      code: 45582,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 14))
    });
    blake2b120 = from({
      name: "blake2b-120",
      code: 45583,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 15))
    });
    blake2b128 = from({
      name: "blake2b-128",
      code: 45584,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 16))
    });
    blake2b136 = from({
      name: "blake2b-136",
      code: 45585,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 17))
    });
    blake2b144 = from({
      name: "blake2b-144",
      code: 45586,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 18))
    });
    blake2b152 = from({
      name: "blake2b-152",
      code: 45587,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 19))
    });
    blake2b160 = from({
      name: "blake2b-160",
      code: 45588,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 20))
    });
    blake2b168 = from({
      name: "blake2b-168",
      code: 45589,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 21))
    });
    blake2b176 = from({
      name: "blake2b-176",
      code: 45590,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 22))
    });
    blake2b184 = from({
      name: "blake2b-184",
      code: 45591,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 23))
    });
    blake2b192 = from({
      name: "blake2b-192",
      code: 45592,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 24))
    });
    blake2b200 = from({
      name: "blake2b-200",
      code: 45593,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 25))
    });
    blake2b208 = from({
      name: "blake2b-208",
      code: 45594,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 26))
    });
    blake2b216 = from({
      name: "blake2b-216",
      code: 45595,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 27))
    });
    blake2b224 = from({
      name: "blake2b-224",
      code: 45596,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 28))
    });
    blake2b232 = from({
      name: "blake2b-232",
      code: 45597,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 29))
    });
    blake2b240 = from({
      name: "blake2b-240",
      code: 45598,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 30))
    });
    blake2b248 = from({
      name: "blake2b-248",
      code: 45599,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 31))
    });
    blake2b256 = from({
      name: "blake2b-256",
      code: 45600,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 32))
    });
    blake2b264 = from({
      name: "blake2b-264",
      code: 45601,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 33))
    });
    blake2b272 = from({
      name: "blake2b-272",
      code: 45602,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 34))
    });
    blake2b280 = from({
      name: "blake2b-280",
      code: 45603,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 35))
    });
    blake2b288 = from({
      name: "blake2b-288",
      code: 45604,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 36))
    });
    blake2b296 = from({
      name: "blake2b-296",
      code: 45605,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 37))
    });
    blake2b304 = from({
      name: "blake2b-304",
      code: 45606,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 38))
    });
    blake2b312 = from({
      name: "blake2b-312",
      code: 45607,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 39))
    });
    blake2b320 = from({
      name: "blake2b-320",
      code: 45608,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 40))
    });
    blake2b328 = from({
      name: "blake2b-328",
      code: 45609,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 41))
    });
    blake2b336 = from({
      name: "blake2b-336",
      code: 45610,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 42))
    });
    blake2b344 = from({
      name: "blake2b-344",
      code: 45611,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 43))
    });
    blake2b352 = from({
      name: "blake2b-352",
      code: 45612,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 44))
    });
    blake2b360 = from({
      name: "blake2b-360",
      code: 45613,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 45))
    });
    blake2b368 = from({
      name: "blake2b-368",
      code: 45614,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 46))
    });
    blake2b376 = from({
      name: "blake2b-376",
      code: 45615,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 47))
    });
    blake2b384 = from({
      name: "blake2b-384",
      code: 45616,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 48))
    });
    blake2b392 = from({
      name: "blake2b-392",
      code: 45617,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 49))
    });
    blake2b400 = from({
      name: "blake2b-400",
      code: 45618,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 50))
    });
    blake2b408 = from({
      name: "blake2b-408",
      code: 45619,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 51))
    });
    blake2b416 = from({
      name: "blake2b-416",
      code: 45620,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 52))
    });
    blake2b424 = from({
      name: "blake2b-424",
      code: 45621,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 53))
    });
    blake2b432 = from({
      name: "blake2b-432",
      code: 45622,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 54))
    });
    blake2b440 = from({
      name: "blake2b-440",
      code: 45623,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 55))
    });
    blake2b448 = from({
      name: "blake2b-448",
      code: 45624,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 56))
    });
    blake2b456 = from({
      name: "blake2b-456",
      code: 45625,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 57))
    });
    blake2b464 = from({
      name: "blake2b-464",
      code: 45626,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 58))
    });
    blake2b472 = from({
      name: "blake2b-472",
      code: 45627,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 59))
    });
    blake2b480 = from({
      name: "blake2b-480",
      code: 45628,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 60))
    });
    blake2b488 = from({
      name: "blake2b-488",
      code: 45629,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 61))
    });
    blake2b496 = from({
      name: "blake2b-496",
      code: 45630,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 62))
    });
    blake2b504 = from({
      name: "blake2b-504",
      code: 45631,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 63))
    });
    blake2b512 = from({
      name: "blake2b-512",
      code: 45632,
      encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 64))
    });
  }
});
var blake2s_exports = {};
__export(blake2s_exports, {
  blake2s104: () => blake2s104,
  blake2s112: () => blake2s112,
  blake2s120: () => blake2s120,
  blake2s128: () => blake2s128,
  blake2s136: () => blake2s136,
  blake2s144: () => blake2s144,
  blake2s152: () => blake2s152,
  blake2s16: () => blake2s16,
  blake2s160: () => blake2s160,
  blake2s168: () => blake2s168,
  blake2s176: () => blake2s176,
  blake2s184: () => blake2s184,
  blake2s192: () => blake2s192,
  blake2s200: () => blake2s200,
  blake2s208: () => blake2s208,
  blake2s216: () => blake2s216,
  blake2s224: () => blake2s224,
  blake2s232: () => blake2s232,
  blake2s24: () => blake2s24,
  blake2s240: () => blake2s240,
  blake2s248: () => blake2s248,
  blake2s256: () => blake2s256,
  blake2s32: () => blake2s32,
  blake2s40: () => blake2s40,
  blake2s48: () => blake2s48,
  blake2s56: () => blake2s56,
  blake2s64: () => blake2s64,
  blake2s72: () => blake2s72,
  blake2s8: () => blake2s8,
  blake2s80: () => blake2s80,
  blake2s88: () => blake2s88,
  blake2s96: () => blake2s96
});
var import_blakejs2;
var blake2s;
var blake2s8;
var blake2s16;
var blake2s24;
var blake2s32;
var blake2s40;
var blake2s48;
var blake2s56;
var blake2s64;
var blake2s72;
var blake2s80;
var blake2s88;
var blake2s96;
var blake2s104;
var blake2s112;
var blake2s120;
var blake2s128;
var blake2s136;
var blake2s144;
var blake2s152;
var blake2s160;
var blake2s168;
var blake2s176;
var blake2s184;
var blake2s192;
var blake2s200;
var blake2s208;
var blake2s216;
var blake2s224;
var blake2s232;
var blake2s240;
var blake2s248;
var blake2s256;
var init_blake2s = __esm({
  "node_modules/.deno/@multiformats+blake2@1.0.13/node_modules/@multiformats/blake2/esm/blake2s.js"() {
    import_blakejs2 = __toESM(require_blakejs(), 1);
    init_hasher();
    init_src();
    ({ blake2s } = import_blakejs2.default);
    blake2s8 = from({
      name: "blake2s-8",
      code: 45633,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 1))
    });
    blake2s16 = from({
      name: "blake2s-16",
      code: 45634,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 2))
    });
    blake2s24 = from({
      name: "blake2s-24",
      code: 45635,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 3))
    });
    blake2s32 = from({
      name: "blake2s-32",
      code: 45636,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 4))
    });
    blake2s40 = from({
      name: "blake2s-40",
      code: 45637,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 5))
    });
    blake2s48 = from({
      name: "blake2s-48",
      code: 45638,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 6))
    });
    blake2s56 = from({
      name: "blake2s-56",
      code: 45639,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 7))
    });
    blake2s64 = from({
      name: "blake2s-64",
      code: 45640,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 8))
    });
    blake2s72 = from({
      name: "blake2s-72",
      code: 45641,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 9))
    });
    blake2s80 = from({
      name: "blake2s-80",
      code: 45642,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 10))
    });
    blake2s88 = from({
      name: "blake2s-88",
      code: 45643,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 11))
    });
    blake2s96 = from({
      name: "blake2s-96",
      code: 45644,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 12))
    });
    blake2s104 = from({
      name: "blake2s-104",
      code: 45645,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 13))
    });
    blake2s112 = from({
      name: "blake2s-112",
      code: 45646,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 14))
    });
    blake2s120 = from({
      name: "blake2s-120",
      code: 45647,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 15))
    });
    blake2s128 = from({
      name: "blake2s-128",
      code: 45648,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 16))
    });
    blake2s136 = from({
      name: "blake2s-136",
      code: 45649,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 17))
    });
    blake2s144 = from({
      name: "blake2s-144",
      code: 45650,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 18))
    });
    blake2s152 = from({
      name: "blake2s-152",
      code: 45651,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 19))
    });
    blake2s160 = from({
      name: "blake2s-160",
      code: 45652,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 20))
    });
    blake2s168 = from({
      name: "blake2s-168",
      code: 45653,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 21))
    });
    blake2s176 = from({
      name: "blake2s-176",
      code: 45654,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 22))
    });
    blake2s184 = from({
      name: "blake2s-184",
      code: 45655,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 23))
    });
    blake2s192 = from({
      name: "blake2s-192",
      code: 45656,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 24))
    });
    blake2s200 = from({
      name: "blake2s-200",
      code: 45657,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 25))
    });
    blake2s208 = from({
      name: "blake2s-208",
      code: 45658,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 26))
    });
    blake2s216 = from({
      name: "blake2s-216",
      code: 45659,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 27))
    });
    blake2s224 = from({
      name: "blake2s-224",
      code: 45660,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 28))
    });
    blake2s232 = from({
      name: "blake2s-232",
      code: 45661,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 29))
    });
    blake2s240 = from({
      name: "blake2s-240",
      code: 45662,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 30))
    });
    blake2s248 = from({
      name: "blake2s-248",
      code: 45663,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 31))
    });
    blake2s256 = from({
      name: "blake2s-256",
      code: 45664,
      encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 32))
    });
  }
});
var blake2_default;
var init_blake2 = __esm({
  "node_modules/.deno/@multiformats+blake2@1.0.13/node_modules/@multiformats/blake2/esm/blake2.js"() {
    init_blake2b();
    init_blake2s();
    blake2_default = {
      blake2b: blake2b_exports,
      blake2s: blake2s_exports
    };
  }
});
function base2(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x3 = ALPHABET.charAt(i2);
    var xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode13(string3) {
    var buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode7,
    decodeUnsafe,
    decode: decode13
  };
}
var src2;
var _brrp__multiformats_scope_baseX2;
var base_x_default2;
var init_base_x2 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/vendor/base-x.js"() {
    src2 = base2;
    _brrp__multiformats_scope_baseX2 = src2;
    base_x_default2 = _brrp__multiformats_scope_baseX2;
  }
});
var empty2;
var equals3;
var coerce2;
var init_bytes2 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bytes.js"() {
    empty2 = new Uint8Array(0);
    equals3 = (aa, bb) => {
      if (aa === bb) return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce2 = (o2) => {
      if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") return o2;
      if (o2 instanceof ArrayBuffer) return new Uint8Array(o2);
      if (ArrayBuffer.isView(o2)) {
        return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
  }
});
var Encoder2;
var Decoder2;
var ComposedDecoder2;
var or2;
var Codec2;
var from3;
var baseX2;
var decode5;
var encode32;
var rfc46482;
var init_base2 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js"() {
    init_base_x2();
    init_bytes2();
    Encoder2 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       */
      constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {API.Multibase<Prefix>}
       */
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder2 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = /** @type {number} */
        prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      /**
       * @param {string} text
       */
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder) {
        return or2(this, decoder);
      }
    };
    ComposedDecoder2 = class {
      /**
       * @param {Decoders<Prefix>} decoders
       */
      constructor(decoders) {
        this.decoders = decoders;
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder) {
        return or2(this, decoder);
      }
      /**
       * @param {string} input
       * @returns {Uint8Array}
       */
      decode(input) {
        const prefix = (
          /** @type {Prefix} */
          input[0]
        );
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or2 = (left, right) => new ComposedDecoder2(
      /** @type {Decoders<L|R>} */
      {
        ...left.decoders || { [
          /** @type API.UnibaseDecoder<L> */
          left.prefix
        ]: left },
        ...right.decoders || { [
          /** @type API.UnibaseDecoder<R> */
          right.prefix
        ]: right }
      }
    );
    Codec2 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder2(name, prefix, baseEncode);
        this.decoder = new Decoder2(name, prefix, baseDecode);
      }
      /**
       * @param {Uint8Array} input
       */
      encode(input) {
        return this.encoder.encode(input);
      }
      /**
       * @param {string} input
       */
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from3 = ({ name, prefix, encode: encode7, decode: decode13 }) => new Codec2(name, prefix, encode7, decode13);
    baseX2 = ({ prefix, name, alphabet: alphabet5 }) => {
      const { encode: encode7, decode: decode13 } = base_x_default2(alphabet5, name);
      return from3({
        prefix,
        name,
        encode: encode7,
        /**
         * @param {string} text
         */
        decode: (text) => coerce2(decode13(text))
      });
    };
    decode5 = (string3, alphabet5, bitsPerChar, name) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet5.length; ++i2) {
        codes[alphabet5[i2]] = i2;
      }
      let end = string3.length;
      while (string3[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string3[i2]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode32 = (data, alphabet5, bitsPerChar) => {
      const pad = alphabet5[alphabet5.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer = buffer << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet5[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet5[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc46482 = ({ name, prefix, bitsPerChar, alphabet: alphabet5 }) => {
      return from3({
        prefix,
        name,
        encode(input) {
          return encode32(input, alphabet5, bitsPerChar);
        },
        decode(input) {
          return decode5(input, alphabet5, bitsPerChar, name);
        }
      });
    };
  }
});
var base58btc2;
var base58flickr2;
var init_base582 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bases/base58.js"() {
    init_base2();
    base58btc2 = baseX2({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr2 = baseX2({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});
function encode4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var encode_12;
var MSB2;
var REST2;
var MSBALL2;
var INT2;
var decode6;
var MSB$12;
var REST$12;
var N12;
var N22;
var N32;
var N42;
var N52;
var N62;
var N72;
var N82;
var N92;
var length2;
var varint2;
var _brrp_varint2;
var varint_default2;
var init_varint3 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/vendor/varint.js"() {
    encode_12 = encode4;
    MSB2 = 128;
    REST2 = 127;
    MSBALL2 = ~REST2;
    INT2 = Math.pow(2, 31);
    decode6 = read2;
    MSB$12 = 128;
    REST$12 = 127;
    N12 = Math.pow(2, 7);
    N22 = Math.pow(2, 14);
    N32 = Math.pow(2, 21);
    N42 = Math.pow(2, 28);
    N52 = Math.pow(2, 35);
    N62 = Math.pow(2, 42);
    N72 = Math.pow(2, 49);
    N82 = Math.pow(2, 56);
    N92 = Math.pow(2, 63);
    length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    varint2 = {
      encode: encode_12,
      decode: decode6,
      encodingLength: length2
    };
    _brrp_varint2 = varint2;
    varint_default2 = _brrp_varint2;
  }
});
var decode7;
var encodeTo2;
var encodingLength2;
var init_varint4 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/varint.js"() {
    init_varint3();
    decode7 = (data, offset = 0) => {
      const code2 = varint_default2.decode(data, offset);
      return [code2, varint_default2.decode.bytes];
    };
    encodeTo2 = (int, target, offset = 0) => {
      varint_default2.encode(int, target, offset);
      return target;
    };
    encodingLength2 = (int) => {
      return varint_default2.encodingLength(int);
    };
  }
});
var create2;
var decode8;
var equals4;
var Digest2;
var init_digest2 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/hashes/digest.js"() {
    init_bytes2();
    init_varint4();
    create2 = (code2, digest) => {
      const size = digest.byteLength;
      const sizeOffset = encodingLength2(code2);
      const digestOffset = sizeOffset + encodingLength2(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo2(code2, bytes, 0);
      encodeTo2(size, bytes, sizeOffset);
      bytes.set(digest, digestOffset);
      return new Digest2(code2, size, digest, bytes);
    };
    decode8 = (multihash) => {
      const bytes = coerce2(multihash);
      const [code2, sizeOffset] = decode7(bytes);
      const [size, digestOffset] = decode7(bytes.subarray(sizeOffset));
      const digest = bytes.subarray(sizeOffset + digestOffset);
      if (digest.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code2, size, digest, bytes);
    };
    equals4 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        const data = (
          /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
          b
        );
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals3(a.bytes, data.bytes);
      }
    };
    Digest2 = class {
      /**
       * Creates a multihash digest.
       *
       * @param {Code} code
       * @param {Size} size
       * @param {Uint8Array} digest
       * @param {Uint8Array} bytes
       */
      constructor(code2, size, digest, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
      }
    };
  }
});
var base322;
var base32upper2;
var base32pad2;
var base32padupper2;
var base32hex2;
var base32hexupper2;
var base32hexpad2;
var base32hexpadupper2;
var base32z2;
var init_base322 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bases/base32.js"() {
    init_base2();
    base322 = rfc46482({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper2 = rfc46482({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad2 = rfc46482({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper2 = rfc46482({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex2 = rfc46482({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper2 = rfc46482({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad2 = rfc46482({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper2 = rfc46482({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z2 = rfc46482({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});
var init_interface = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/link/interface.js"() {
  }
});
var format5;
var cache;
var baseCache;
var CID2;
var parseCIDtoBytes2;
var toStringV02;
var toStringV12;
var DAG_PB_CODE2;
var SHA_256_CODE2;
var encodeCID2;
var cidSymbol2;
var init_cid2 = __esm({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/cid.js"() {
    init_varint4();
    init_digest2();
    init_base582();
    init_base322();
    init_bytes2();
    init_interface();
    format5 = (link, base4) => {
      const { bytes, version: version4 } = link;
      switch (version4) {
        case 0:
          return toStringV02(
            bytes,
            baseCache(link),
            /** @type {API.MultibaseEncoder<"z">} */
            base4 || base58btc2.encoder
          );
        default:
          return toStringV12(
            bytes,
            baseCache(link),
            /** @type {API.MultibaseEncoder<Prefix>} */
            base4 || base322.encoder
          );
      }
    };
    cache = /* @__PURE__ */ new WeakMap();
    baseCache = (cid) => {
      const baseCache3 = cache.get(cid);
      if (baseCache3 == null) {
        const baseCache4 = /* @__PURE__ */ new Map();
        cache.set(cid, baseCache4);
        return baseCache4;
      }
      return baseCache3;
    };
    CID2 = class _CID {
      /**
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
       * @param {Uint8Array} bytes
       *
       */
      constructor(version4, code2, multihash, bytes) {
        this.code = code2;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes;
        this["/"] = bytes;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      /**
       * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
       */
      toV0() {
        switch (this.version) {
          case 0: {
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              this
            );
          }
          case 1: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              _CID.createV0(
                /** @type {API.MultihashDigest<API.SHA_256>} */
                multihash
              )
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 0. This is a bug please report`
            );
          }
        }
      }
      /**
       * @returns {CID<Data, Format, Alg, 1>}
       */
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest } = this.multihash;
            const multihash = create2(code2, digest);
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              _CID.createV1(this.code, multihash)
            );
          }
          case 1: {
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              this
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 1. This is a bug please report`
            );
          }
        }
      }
      /**
       * @param {unknown} other
       * @returns {other is CID<Data, Format, Alg, Version>}
       */
      equals(other) {
        return _CID.equals(this, other);
      }
      /**
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {API.Link<Data, Format, Alg, Version>} self
       * @param {unknown} other
       * @returns {other is CID}
       */
      static equals(self2, other) {
        const unknown2 = (
          /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
          other
        );
        return unknown2 && self2.code === unknown2.code && self2.version === unknown2.version && equals4(self2.multihash, unknown2.multihash);
      }
      /**
       * @param {API.MultibaseEncoder<string>} [base]
       * @returns {string}
       */
      toString(base4) {
        return format5(this, base4);
      }
      toJSON() {
        return { "/": format5(this) };
      }
      link() {
        return this;
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      // Legacy
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @template {unknown} U
       * @param {API.Link<Data, Format, Alg, Version>|U} input
       * @returns {CID<Data, Format, Alg, Version>|null}
       */
      static asCID(input) {
        if (input == null) {
          return null;
        }
        const value = (
          /** @type {any} */
          input
        );
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version4, code: code2, multihash, bytes } = value;
          return new _CID(
            version4,
            code2,
            /** @type {API.MultihashDigest<Alg>} */
            multihash,
            bytes || encodeCID2(version4, code2, multihash.bytes)
          );
        } else if (value[cidSymbol2] === true) {
          const { version: version4, multihash, code: code2 } = value;
          const digest = (
            /** @type {API.MultihashDigest<Alg>} */
            decode8(multihash)
          );
          return _CID.create(version4, code2, digest);
        } else {
          return null;
        }
      }
      /**
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
       * @returns {CID<Data, Format, Alg, Version>}
       */
      static create(version4, code2, digest) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version4) {
          case 0: {
            if (code2 !== DAG_PB_CODE2) {
              throw new Error(
                `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`
              );
            } else {
              return new _CID(version4, code2, digest, digest.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID2(version4, code2, digest.bytes);
            return new _CID(version4, code2, digest, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       *
       * @template {unknown} [T=unknown]
       * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
       * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
       */
      static createV0(digest) {
        return _CID.create(0, DAG_PB_CODE2, digest);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @param {Code} code - Content encoding format code.
       * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
       * @returns {CID<Data, Code, Alg, 1>}
       */
      static createV1(code2, digest) {
        return _CID.create(1, code2, digest);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static decode(bytes) {
        const [cid, remainder] = _CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
       * @returns {[CID<T, C, A, V>, Uint8Array]}
       */
      static decodeFirst(bytes) {
        const specs = _CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(
          bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
        );
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(
          specs.multihashSize - specs.digestSize
        );
        const digest = new Digest2(
          specs.multihashCode,
          specs.digestSize,
          digestBytes,
          multihashBytes
        );
        const cid = specs.version === 0 ? _CID.createV0(
          /** @type {API.MultihashDigest<API.SHA_256>} */
          digest
        ) : _CID.createV1(specs.codec, digest);
        return [
          /** @type {CID<T, C, A, V>} */
          cid,
          bytes.subarray(specs.size)
        ];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
       * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
       */
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i2, length4] = decode7(initialBytes.subarray(offset));
          offset += length4;
          return i2;
        };
        let version4 = (
          /** @type {V} */
          next()
        );
        let codec = (
          /** @type {C} */
          DAG_PB_CODE2
        );
        if (
          /** @type {number} */
          version4 === 18
        ) {
          version4 = /** @type {V} */
          0;
          offset = 0;
        } else {
          codec = /** @type {C} */
          next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset;
        const multihashCode = (
          /** @type {A} */
          next()
        );
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       *
       * @template {string} Prefix
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
       * @param {API.MultibaseDecoder<Prefix>} [base]
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static parse(source, base4) {
        const [prefix, bytes] = parseCIDtoBytes2(source, base4);
        const cid = _CID.decode(bytes);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache(cid).set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes2 = (source, base4) => {
      switch (source[0]) {
        // CIDv0 is parsed differently
        case "Q": {
          const decoder = base4 || base58btc2;
          return [
            /** @type {Prefix} */
            base58btc2.prefix,
            decoder.decode(`${base58btc2.prefix}${source}`)
          ];
        }
        case base58btc2.prefix: {
          const decoder = base4 || base58btc2;
          return [
            /** @type {Prefix} */
            base58btc2.prefix,
            decoder.decode(source)
          ];
        }
        case base322.prefix: {
          const decoder = base4 || base322;
          return [
            /** @type {Prefix} */
            base322.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base4 == null) {
            throw Error(
              "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
            );
          }
          return [
            /** @type {Prefix} */
            source[0],
            base4.decode(source)
          ];
        }
      }
    };
    toStringV02 = (bytes, cache3, base4) => {
      const { prefix } = base4;
      if (prefix !== base58btc2.prefix) {
        throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
      }
      const cid = cache3.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes).slice(1);
        cache3.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV12 = (bytes, cache3, base4) => {
      const { prefix } = base4;
      const cid = cache3.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes);
        cache3.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE2 = 112;
    SHA_256_CODE2 = 18;
    encodeCID2 = (version4, code2, multihash) => {
      const codeOffset = encodingLength2(version4);
      const hashOffset = codeOffset + encodingLength2(code2);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo2(version4, bytes, 0);
      encodeTo2(code2, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
  }
});
var database_fs_exports = {};
__export(database_fs_exports, {
  clear: () => clear,
  count: () => count,
  dataFolder: () => dataFolder,
  initStorage: () => initStorage,
  iterKeys: () => iterKeys,
  readData: () => readData,
  writeData: () => writeData,
  writeDataOnce: () => writeDataOnce
});
async function initStorage(options3 = {}) {
  dataFolder = resolve3(options3.dirname);
  await Deno.mkdir(dataFolder, { mode: 488, recursive: true });
}
async function clear() {
  for await (const key of iterKeys()) {
    await Deno.remove(join3(dataFolder, key));
  }
}
async function count() {
  let n = 0;
  for await (const entry of Deno.readDir(dataFolder)) {
    if (entry.isFile) {
      n++;
    }
  }
  return n;
}
async function* iterKeys() {
  for await (const entry of Deno.readDir(dataFolder)) {
    if (entry.isFile) {
      yield entry.name;
    }
  }
}
function readData(key) {
  checkKey(key);
  return Deno.readFile(join3(dataFolder, key)).catch(() => void 0);
}
async function writeData(key, value) {
  if (typeof value === "string") {
    await Deno.writeTextFile(join3(dataFolder, key), value);
  } else {
    await Deno.writeFile(join3(dataFolder, key), value);
  }
}
async function writeDataOnce(key, value) {
  const options3 = { createNew: true };
  try {
    if (typeof value === "string") {
      await Deno.writeTextFile(join3(dataFolder, key), value, options3);
    } else {
      await Deno.writeFile(join3(dataFolder, key), value, options3);
    }
  } catch (err) {
    if (err instanceof Error && err.name !== "AlreadyExists") throw err;
  }
}
var dataFolder;
var init_database_fs = __esm({
  "src/database-fs.ts"() {
    "use strict";
    init_utils();
    dataFolder = "";
  }
});
var database_sqlite_exports = {};
__export(database_sqlite_exports, {
  count: () => count2,
  dataFolder: () => dataFolder2,
  initStorage: () => initStorage2,
  iterKeys: () => iterKeys2,
  readData: () => readData2,
  writeData: () => writeData2,
  writeDataOnce: () => writeDataOnce2
});
async function initStorage2(options3 = {}) {
  const { dirname: dirname6, filename } = options3;
  dataFolder2 = resolve3(dirname6);
  const filepath = join3(dataFolder2, filename);
  if (db !== void 0) {
    if (filepath === dbPath) {
      return;
    }
    db.close();
  }
  db = new DB(filepath);
  db.run("CREATE TABLE IF NOT EXISTS Data(key TEXT NOT NULL PRIMARY KEY, value TEXT NOT NULL)");
  dbPath = filepath;
  if (!options3.internal) {
    console.log("Connected to the %s SQLite database.", filepath);
  }
  iterKeysStatement = db.prepare("SELECT key FROM Data");
  readStatement = db.prepare("SELECT value FROM Data WHERE key = ?");
  writeOnceStatement = db.prepare("INSERT INTO Data(key, value) VALUES(?, ?) ON CONFLICT (key) DO NOTHING");
  writeStatement = db.prepare("REPLACE INTO Data(key, value) VALUES(?, ?)");
}
function count2() {
  return db.prepare("SELECT COUNT(*) FROM Data").all()[0][0];
}
async function readData2(key) {
  const maybeRow = readStatement.all([key])[0];
  return maybeRow === void 0 ? void 0 : maybeRow[0] ?? new Uint8Array();
}
async function* iterKeys2() {
  for (const row of iterKeysStatement.iter()) {
    yield row[0];
  }
}
async function writeData2(key, value) {
  checkKey(key);
  writeStatement.run([key, value]);
}
async function writeDataOnce2(key, value) {
  checkKey(key);
  writeOnceStatement.run([key, value]);
}
var DB;
var db;
var dbPath;
var iterKeysStatement;
var readStatement;
var writeOnceStatement;
var writeStatement;
var dataFolder2;
var init_database_sqlite = __esm({
  "src/database-sqlite.ts"() {
    "use strict";
    init_utils();
    DB = Database;
    dataFolder2 = "";
  }
});
function checkKey(key) {
  if (!isValidKey(key)) {
    throw new Error(`bad key: ${JSON.stringify(key)}`);
  }
}
async function createEntryFromFile(filepath, multicode) {
  const buffer = await Deno.readFile(filepath);
  const key = createCID(buffer, multicode);
  return [key, buffer];
}
function createCID(data, multicode = multicodes.RAW) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = multihasher.digest(uint8array);
  return CID2.create(1, multicode, digest).toString(multibase.encoder);
}
function exit(x3, internal = false) {
  const msg = x3 instanceof Error ? x3.message : String(x3);
  if (internal) throw new Error(msg);
  console.error("[chel]", red("Error:"), msg);
  Deno.exit(1);
}
async function getBackend(src4, { type, create: create4 } = { type: "", create: false }) {
  const fsOptions = { internal: true, dirname: src4 };
  const sqliteOptions = { internal: true, dirname: dirname3(src4), filename: basename3(src4) };
  if (!create4 && !await isDir(src4) && !await isFile2(src4)) throw new Error(`not found: "${src4}"`);
  let from6 = type;
  if (!from6) {
    if (await isDir(src4)) from6 = "fs";
    else if (await isFile2(src4)) from6 = "sqlite";
    else throw new Error(`could not infer backend type. Not found: "${src4}"`);
  }
  let initOptions;
  switch (from6) {
    case "fs":
      initOptions = fsOptions;
      break;
    case "sqlite":
      initOptions = sqliteOptions;
      break;
    default:
      throw new Error(`unknown backend type: "${from6}"`);
  }
  const backend2 = backends[from6];
  try {
    await backend2.initStorage(initOptions);
  } catch (error) {
    throw new Error(`could not init '${from6}' storage backend at "${src4}": ${error.message}`);
  }
  return backend2;
}
function isArrayLength(arg) {
  return Number.isInteger(arg) && arg >= 0 && arg <= 2 ** 32 - 1;
}
async function isDir(path12) {
  try {
    return (await Deno.stat(path12)).isDirectory;
  } catch {
    return false;
  }
}
async function isFile2(path12) {
  try {
    return (await Deno.stat(path12)).isFile;
  } catch {
    return false;
  }
}
function isNotHashKey(key) {
  return key.startsWith("head=") || key.startsWith("name=");
}
function isURL(arg) {
  return URL.canParse(arg) && Boolean(new URL(arg).host);
}
function isValidKey(key) {
  return !/[\x00-\x1f\x7f\t\\/]/.test(key);
}
async function readRemoteData(src4, key) {
  const buffer = await fetch(`${src4}/file/${key}`).then(async (r) => r.ok ? await r.arrayBuffer() : await Promise.reject(new Error(`failed network request to ${src4}: ${r.status} - ${r.statusText}`)));
  return new Uint8Array(buffer);
}
async function revokeNet() {
  await Deno.permissions.revoke({ name: "net" });
}
var backends;
var multibase;
var multicodes;
var multihasher;
var readJsonFile;
var init_utils = __esm({
  "src/utils.ts"() {
    "use strict";
    init_blake2();
    init_base582();
    init_cid2();
    init_database_fs();
    init_database_sqlite();
    backends = { fs: database_fs_exports, sqlite: database_sqlite_exports };
    multibase = base58btc2;
    multicodes = {
      RAW: 0,
      JSON: 512,
      SHELTER_CONTRACT_MANIFEST: 5316096,
      SHELTER_CONTRACT_TEXT: 5316097,
      SHELTER_CONTRACT_DATA: 5316098,
      SHELTER_FILE_MANIFEST: 5316099,
      SHELTER_FILE_CHUNK: 5316100
    };
    multihasher = blake2_default.blake2b.blake2b256;
    readJsonFile = async (file) => {
      const contents = await Deno.readTextFile(resolve3(String(file)));
      return JSON.parse(contents);
    };
  }
});
function equals5(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce3(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
    return o2;
  }
  if (o2 instanceof ArrayBuffer) {
    return new Uint8Array(o2);
  }
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
var empty3;
var init_bytes3 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bytes.mjs"() {
    empty3 = new Uint8Array(0);
  }
});
function base3(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x3 = ALPHABET.charAt(i2);
    var xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode13(string3) {
    var buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode7,
    decodeUnsafe,
    decode: decode13
  };
}
var src3;
var _brrp__multiformats_scope_baseX3;
var base_x_default3;
var init_base_x3 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/base-x.mjs"() {
    src3 = base3;
    _brrp__multiformats_scope_baseX3 = src3;
    base_x_default3 = _brrp__multiformats_scope_baseX3;
  }
});
function or3(left, right) {
  var _a2, _b;
  return new ComposedDecoder3(Object.assign(Object.assign({}, (_a2 = left.decoders) !== null && _a2 !== void 0 ? _a2 : { [left.prefix]: left }), (_b = right.decoders) !== null && _b !== void 0 ? _b : { [right.prefix]: right }));
}
function from4({ name, prefix, encode: encode7, decode: decode13 }) {
  return new Codec3(name, prefix, encode7, decode13);
}
function baseX3({ name, prefix, alphabet: alphabet5 }) {
  const { encode: encode7, decode: decode13 } = base_x_default3(alphabet5, name);
  return from4({
    prefix,
    name,
    encode: encode7,
    decode: (text) => coerce3(decode13(text))
  });
}
function decode9(string3, alphabet5, bitsPerChar, name) {
  const codes = {};
  for (let i2 = 0; i2 < alphabet5.length; ++i2) {
    codes[alphabet5[i2]] = i2;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string3[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode5(data, alphabet5, bitsPerChar) {
  const pad = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet5[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46483({ name, prefix, bitsPerChar, alphabet: alphabet5 }) {
  return from4({
    prefix,
    name,
    encode(input) {
      return encode5(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode9(input, alphabet5, bitsPerChar, name);
    }
  });
}
var Encoder3;
var Decoder3;
var ComposedDecoder3;
var Codec3;
var init_base3 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base.mjs"() {
    init_bytes3();
    init_base_x3();
    Encoder3 = class {
      constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder3 = class {
      constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or3(this, decoder);
      }
    };
    ComposedDecoder3 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or3(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    Codec3 = class {
      constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder3(name, prefix, baseEncode);
        this.decoder = new Decoder3(name, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
  }
});
var base323;
var base32upper3;
var base32pad3;
var base32padupper3;
var base32hex3;
var base32hexupper3;
var base32hexpad3;
var base32hexpadupper3;
var base32z3;
var init_base323 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base32.mjs"() {
    init_base3();
    base323 = rfc46483({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper3 = rfc46483({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad3 = rfc46483({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper3 = rfc46483({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex3 = rfc46483({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper3 = rfc46483({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad3 = rfc46483({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper3 = rfc46483({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z3 = rfc46483({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});
var base58btc3;
var base58flickr3;
var init_base583 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base58.mjs"() {
    init_base3();
    base58btc3 = baseX3({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr3 = baseX3({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});
function encode6(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode6.bytes = offset - oldOffset + 1;
  return out;
}
function read3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var encode_13;
var MSB3;
var REST3;
var MSBALL3;
var INT3;
var decode10;
var MSB$13;
var REST$13;
var N13;
var N23;
var N33;
var N43;
var N53;
var N63;
var N73;
var N83;
var N93;
var length3;
var varint3;
var _brrp_varint3;
var varint_default3;
var init_varint5 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/vendor/varint.mjs"() {
    encode_13 = encode6;
    MSB3 = 128;
    REST3 = 127;
    MSBALL3 = ~REST3;
    INT3 = Math.pow(2, 31);
    decode10 = read3;
    MSB$13 = 128;
    REST$13 = 127;
    N13 = Math.pow(2, 7);
    N23 = Math.pow(2, 14);
    N33 = Math.pow(2, 21);
    N43 = Math.pow(2, 28);
    N53 = Math.pow(2, 35);
    N63 = Math.pow(2, 42);
    N73 = Math.pow(2, 49);
    N83 = Math.pow(2, 56);
    N93 = Math.pow(2, 63);
    length3 = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
    };
    varint3 = {
      encode: encode_13,
      decode: decode10,
      encodingLength: length3
    };
    _brrp_varint3 = varint3;
    varint_default3 = _brrp_varint3;
  }
});
function decode11(data, offset = 0) {
  const code2 = varint_default3.decode(data, offset);
  return [code2, varint_default3.decode.bytes];
}
function encodeTo3(int, target, offset = 0) {
  varint_default3.encode(int, target, offset);
  return target;
}
function encodingLength3(int) {
  return varint_default3.encodingLength(int);
}
var init_varint6 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/varint.mjs"() {
    init_varint5();
  }
});
function create3(code2, digest) {
  const size = digest.byteLength;
  const sizeOffset = encodingLength3(code2);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo3(code2, bytes, 0);
  encodeTo3(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest3(code2, size, digest, bytes);
}
function decode12(multihash) {
  const bytes = coerce3(multihash);
  const [code2, sizeOffset] = decode11(bytes);
  const [size, digestOffset] = decode11(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code2, size, digest, bytes);
}
function equals6(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals5(a.bytes, data.bytes);
  }
}
var Digest3;
var init_digest3 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/hashes/digest.mjs"() {
    init_bytes3();
    init_varint6();
    Digest3 = class {
      /**
       * Creates a multihash digest.
       */
      constructor(code2, size, digest, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
      }
    };
  }
});
function from5({ name, code: code2, encode: encode7 }) {
  return new Hasher2(name, code2, encode7);
}
var Hasher2;
var init_hasher2 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/hasher.mjs"() {
    init_digest3();
    Hasher2 = class {
      constructor(name, code2, encode7) {
        this.name = name;
        this.code = code2;
        this.encode = encode7;
      }
      digest(input) {
        if (input instanceof Uint8Array || input instanceof ReadableStream) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest) => create3(this.code, digest));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});
var import_blakejs3;
var blake2b2;
var blake2b82;
var blake2b162;
var blake2b242;
var blake2b322;
var blake2b402;
var blake2b482;
var blake2b562;
var blake2b642;
var blake2b722;
var blake2b802;
var blake2b882;
var blake2b962;
var blake2b1042;
var blake2b1122;
var blake2b1202;
var blake2b1282;
var blake2b1362;
var blake2b1442;
var blake2b1522;
var blake2b1602;
var blake2b1682;
var blake2b1762;
var blake2b1842;
var blake2b1922;
var blake2b2002;
var blake2b2082;
var blake2b2162;
var blake2b2242;
var blake2b2322;
var blake2b2402;
var blake2b2482;
var blake2b2562;
var blake2b2642;
var blake2b2722;
var blake2b2802;
var blake2b2882;
var blake2b2962;
var blake2b3042;
var blake2b3122;
var blake2b3202;
var blake2b3282;
var blake2b3362;
var blake2b3442;
var blake2b3522;
var blake2b3602;
var blake2b3682;
var blake2b3762;
var blake2b3842;
var blake2b3922;
var blake2b4002;
var blake2b4082;
var blake2b4162;
var blake2b4242;
var blake2b4322;
var blake2b4402;
var blake2b4482;
var blake2b4562;
var blake2b4642;
var blake2b4722;
var blake2b4802;
var blake2b4882;
var blake2b4962;
var blake2b5042;
var blake2b5122;
var init_blake2b2 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/blake2b.mjs"() {
    import_blakejs3 = __toESM(require_blakejs(), 1);
    init_bytes3();
    init_hasher2();
    ({ blake2b: blake2b2 } = import_blakejs3.default);
    blake2b82 = from5({
      name: "blake2b-8",
      code: 45569,
      encode: (input) => coerce3(blake2b2(input, void 0, 1))
    });
    blake2b162 = from5({
      name: "blake2b-16",
      code: 45570,
      encode: (input) => coerce3(blake2b2(input, void 0, 2))
    });
    blake2b242 = from5({
      name: "blake2b-24",
      code: 45571,
      encode: (input) => coerce3(blake2b2(input, void 0, 3))
    });
    blake2b322 = from5({
      name: "blake2b-32",
      code: 45572,
      encode: (input) => coerce3(blake2b2(input, void 0, 4))
    });
    blake2b402 = from5({
      name: "blake2b-40",
      code: 45573,
      encode: (input) => coerce3(blake2b2(input, void 0, 5))
    });
    blake2b482 = from5({
      name: "blake2b-48",
      code: 45574,
      encode: (input) => coerce3(blake2b2(input, void 0, 6))
    });
    blake2b562 = from5({
      name: "blake2b-56",
      code: 45575,
      encode: (input) => coerce3(blake2b2(input, void 0, 7))
    });
    blake2b642 = from5({
      name: "blake2b-64",
      code: 45576,
      encode: (input) => coerce3(blake2b2(input, void 0, 8))
    });
    blake2b722 = from5({
      name: "blake2b-72",
      code: 45577,
      encode: (input) => coerce3(blake2b2(input, void 0, 9))
    });
    blake2b802 = from5({
      name: "blake2b-80",
      code: 45578,
      encode: (input) => coerce3(blake2b2(input, void 0, 10))
    });
    blake2b882 = from5({
      name: "blake2b-88",
      code: 45579,
      encode: (input) => coerce3(blake2b2(input, void 0, 11))
    });
    blake2b962 = from5({
      name: "blake2b-96",
      code: 45580,
      encode: (input) => coerce3(blake2b2(input, void 0, 12))
    });
    blake2b1042 = from5({
      name: "blake2b-104",
      code: 45581,
      encode: (input) => coerce3(blake2b2(input, void 0, 13))
    });
    blake2b1122 = from5({
      name: "blake2b-112",
      code: 45582,
      encode: (input) => coerce3(blake2b2(input, void 0, 14))
    });
    blake2b1202 = from5({
      name: "blake2b-120",
      code: 45583,
      encode: (input) => coerce3(blake2b2(input, void 0, 15))
    });
    blake2b1282 = from5({
      name: "blake2b-128",
      code: 45584,
      encode: (input) => coerce3(blake2b2(input, void 0, 16))
    });
    blake2b1362 = from5({
      name: "blake2b-136",
      code: 45585,
      encode: (input) => coerce3(blake2b2(input, void 0, 17))
    });
    blake2b1442 = from5({
      name: "blake2b-144",
      code: 45586,
      encode: (input) => coerce3(blake2b2(input, void 0, 18))
    });
    blake2b1522 = from5({
      name: "blake2b-152",
      code: 45587,
      encode: (input) => coerce3(blake2b2(input, void 0, 19))
    });
    blake2b1602 = from5({
      name: "blake2b-160",
      code: 45588,
      encode: (input) => coerce3(blake2b2(input, void 0, 20))
    });
    blake2b1682 = from5({
      name: "blake2b-168",
      code: 45589,
      encode: (input) => coerce3(blake2b2(input, void 0, 21))
    });
    blake2b1762 = from5({
      name: "blake2b-176",
      code: 45590,
      encode: (input) => coerce3(blake2b2(input, void 0, 22))
    });
    blake2b1842 = from5({
      name: "blake2b-184",
      code: 45591,
      encode: (input) => coerce3(blake2b2(input, void 0, 23))
    });
    blake2b1922 = from5({
      name: "blake2b-192",
      code: 45592,
      encode: (input) => coerce3(blake2b2(input, void 0, 24))
    });
    blake2b2002 = from5({
      name: "blake2b-200",
      code: 45593,
      encode: (input) => coerce3(blake2b2(input, void 0, 25))
    });
    blake2b2082 = from5({
      name: "blake2b-208",
      code: 45594,
      encode: (input) => coerce3(blake2b2(input, void 0, 26))
    });
    blake2b2162 = from5({
      name: "blake2b-216",
      code: 45595,
      encode: (input) => coerce3(blake2b2(input, void 0, 27))
    });
    blake2b2242 = from5({
      name: "blake2b-224",
      code: 45596,
      encode: (input) => coerce3(blake2b2(input, void 0, 28))
    });
    blake2b2322 = from5({
      name: "blake2b-232",
      code: 45597,
      encode: (input) => coerce3(blake2b2(input, void 0, 29))
    });
    blake2b2402 = from5({
      name: "blake2b-240",
      code: 45598,
      encode: (input) => coerce3(blake2b2(input, void 0, 30))
    });
    blake2b2482 = from5({
      name: "blake2b-248",
      code: 45599,
      encode: (input) => coerce3(blake2b2(input, void 0, 31))
    });
    blake2b2562 = from5({
      name: "blake2b-256",
      code: 45600,
      encode: (input) => coerce3(blake2b2(input, void 0, 32))
    });
    blake2b2642 = from5({
      name: "blake2b-264",
      code: 45601,
      encode: (input) => coerce3(blake2b2(input, void 0, 33))
    });
    blake2b2722 = from5({
      name: "blake2b-272",
      code: 45602,
      encode: (input) => coerce3(blake2b2(input, void 0, 34))
    });
    blake2b2802 = from5({
      name: "blake2b-280",
      code: 45603,
      encode: (input) => coerce3(blake2b2(input, void 0, 35))
    });
    blake2b2882 = from5({
      name: "blake2b-288",
      code: 45604,
      encode: (input) => coerce3(blake2b2(input, void 0, 36))
    });
    blake2b2962 = from5({
      name: "blake2b-296",
      code: 45605,
      encode: (input) => coerce3(blake2b2(input, void 0, 37))
    });
    blake2b3042 = from5({
      name: "blake2b-304",
      code: 45606,
      encode: (input) => coerce3(blake2b2(input, void 0, 38))
    });
    blake2b3122 = from5({
      name: "blake2b-312",
      code: 45607,
      encode: (input) => coerce3(blake2b2(input, void 0, 39))
    });
    blake2b3202 = from5({
      name: "blake2b-320",
      code: 45608,
      encode: (input) => coerce3(blake2b2(input, void 0, 40))
    });
    blake2b3282 = from5({
      name: "blake2b-328",
      code: 45609,
      encode: (input) => coerce3(blake2b2(input, void 0, 41))
    });
    blake2b3362 = from5({
      name: "blake2b-336",
      code: 45610,
      encode: (input) => coerce3(blake2b2(input, void 0, 42))
    });
    blake2b3442 = from5({
      name: "blake2b-344",
      code: 45611,
      encode: (input) => coerce3(blake2b2(input, void 0, 43))
    });
    blake2b3522 = from5({
      name: "blake2b-352",
      code: 45612,
      encode: (input) => coerce3(blake2b2(input, void 0, 44))
    });
    blake2b3602 = from5({
      name: "blake2b-360",
      code: 45613,
      encode: (input) => coerce3(blake2b2(input, void 0, 45))
    });
    blake2b3682 = from5({
      name: "blake2b-368",
      code: 45614,
      encode: (input) => coerce3(blake2b2(input, void 0, 46))
    });
    blake2b3762 = from5({
      name: "blake2b-376",
      code: 45615,
      encode: (input) => coerce3(blake2b2(input, void 0, 47))
    });
    blake2b3842 = from5({
      name: "blake2b-384",
      code: 45616,
      encode: (input) => coerce3(blake2b2(input, void 0, 48))
    });
    blake2b3922 = from5({
      name: "blake2b-392",
      code: 45617,
      encode: (input) => coerce3(blake2b2(input, void 0, 49))
    });
    blake2b4002 = from5({
      name: "blake2b-400",
      code: 45618,
      encode: (input) => coerce3(blake2b2(input, void 0, 50))
    });
    blake2b4082 = from5({
      name: "blake2b-408",
      code: 45619,
      encode: (input) => coerce3(blake2b2(input, void 0, 51))
    });
    blake2b4162 = from5({
      name: "blake2b-416",
      code: 45620,
      encode: (input) => coerce3(blake2b2(input, void 0, 52))
    });
    blake2b4242 = from5({
      name: "blake2b-424",
      code: 45621,
      encode: (input) => coerce3(blake2b2(input, void 0, 53))
    });
    blake2b4322 = from5({
      name: "blake2b-432",
      code: 45622,
      encode: (input) => coerce3(blake2b2(input, void 0, 54))
    });
    blake2b4402 = from5({
      name: "blake2b-440",
      code: 45623,
      encode: (input) => coerce3(blake2b2(input, void 0, 55))
    });
    blake2b4482 = from5({
      name: "blake2b-448",
      code: 45624,
      encode: (input) => coerce3(blake2b2(input, void 0, 56))
    });
    blake2b4562 = from5({
      name: "blake2b-456",
      code: 45625,
      encode: (input) => coerce3(blake2b2(input, void 0, 57))
    });
    blake2b4642 = from5({
      name: "blake2b-464",
      code: 45626,
      encode: (input) => coerce3(blake2b2(input, void 0, 58))
    });
    blake2b4722 = from5({
      name: "blake2b-472",
      code: 45627,
      encode: (input) => coerce3(blake2b2(input, void 0, 59))
    });
    blake2b4802 = from5({
      name: "blake2b-480",
      code: 45628,
      encode: (input) => coerce3(blake2b2(input, void 0, 60))
    });
    blake2b4882 = from5({
      name: "blake2b-488",
      code: 45629,
      encode: (input) => coerce3(blake2b2(input, void 0, 61))
    });
    blake2b4962 = from5({
      name: "blake2b-496",
      code: 45630,
      encode: (input) => coerce3(blake2b2(input, void 0, 62))
    });
    blake2b5042 = from5({
      name: "blake2b-504",
      code: 45631,
      encode: (input) => coerce3(blake2b2(input, void 0, 63))
    });
    blake2b5122 = from5({
      name: "blake2b-512",
      code: 45632,
      encode: (input) => coerce3(blake2b2(input, void 0, 64))
    });
  }
});
var import_blakejs4;
var __awaiter;
var blake2b3;
var blake2bInit;
var blake2bUpdate;
var blake2bFinal;
var blake2b256stream;
var init_blake2bstream = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/blake2bstream.mjs"() {
    import_blakejs4 = __toESM(require_blakejs(), 1);
    init_bytes3();
    init_hasher2();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve8) {
          resolve8(value);
        });
      }
      return new (P || (P = Promise))(function(resolve8, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve8(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ({ blake2b: blake2b3, blake2bInit, blake2bUpdate, blake2bFinal } = import_blakejs4.default);
    blake2b256stream = from5({
      name: "blake2b-256",
      code: 45600,
      encode: (input) => __awaiter(void 0, void 0, void 0, function* () {
        if (input instanceof ReadableStream) {
          const ctx = blake2bInit(32);
          const reader = input.getReader();
          for (; ; ) {
            const result = yield reader.read();
            if (result.done)
              break;
            blake2bUpdate(ctx, coerce3(result.value));
          }
          return blake2bFinal(ctx);
        } else {
          return coerce3(blake2b3(input, void 0, 32));
        }
      })
    });
  }
});
var init_interface2 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/link/interface.mjs"() {
  }
});
function format22(link, base4) {
  const { bytes, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV03(bytes, baseCache2(link), base4 !== null && base4 !== void 0 ? base4 : base58btc3.encoder);
    default:
      return toStringV13(bytes, baseCache2(link), base4 !== null && base4 !== void 0 ? base4 : base323.encoder);
  }
}
function baseCache2(cid) {
  const baseCache3 = cache2.get(cid);
  if (baseCache3 == null) {
    const baseCache4 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache4);
    return baseCache4;
  }
  return baseCache3;
}
function parseCIDtoBytes3(source, base4) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base4 !== null && base4 !== void 0 ? base4 : base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base4 !== null && base4 !== void 0 ? base4 : base58btc3;
      return [base58btc3.prefix, decoder.decode(source)];
    }
    case base323.prefix: {
      const decoder = base4 !== null && base4 !== void 0 ? base4 : base323;
      return [base323.prefix, decoder.decode(source)];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base4.decode(source)];
    }
  }
}
function toStringV03(bytes, cache3, base4) {
  const { prefix } = base4;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV13(bytes, cache3, base4) {
  const { prefix } = base4;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function encodeCID3(version4, code2, multihash) {
  const codeOffset = encodingLength3(version4);
  const hashOffset = codeOffset + encodingLength3(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version4, bytes, 0);
  encodeTo3(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var _a;
var cache2;
var CID3;
var DAG_PB_CODE3;
var SHA_256_CODE3;
var cidSymbol3;
var init_cid3 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/cid.mjs"() {
    init_base323();
    init_base583();
    init_bytes3();
    init_digest3();
    init_varint6();
    init_interface2();
    cache2 = /* @__PURE__ */ new WeakMap();
    CID3 = class _CID {
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param multihash - (Multi)hash of the of the content.
       */
      constructor(version4, code2, multihash, bytes) {
        this[_a] = "CID";
        this.code = code2;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes;
        this["/"] = bytes;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          case 1: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE3) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE3) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest } = this.multihash;
            const multihash = create3(code2, digest);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return _CID.equals(this, other);
      }
      static equals(self2, other) {
        const unknown2 = other;
        return unknown2 != null && self2.code === unknown2.code && self2.version === unknown2.version && equals6(self2.multihash, unknown2.multihash);
      }
      toString(base4) {
        return format22(this, base4);
      }
      toJSON() {
        return { "/": format22(this) };
      }
      link() {
        return this;
      }
      // Legacy
      [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       */
      static asCID(input) {
        if (input == null) {
          return null;
        }
        const value = input;
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version4, code: code2, multihash, bytes } = value;
          return new _CID(version4, code2, multihash, bytes !== null && bytes !== void 0 ? bytes : encodeCID3(version4, code2, multihash.bytes));
        } else if (value[cidSymbol3] === true) {
          const { version: version4, multihash, code: code2 } = value;
          const digest = decode12(multihash);
          return _CID.create(version4, code2, digest);
        } else {
          return null;
        }
      }
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param digest - (Multi)hash of the of the content.
       */
      static create(version4, code2, digest) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version4) {
          case 0: {
            if (code2 !== DAG_PB_CODE3) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
            } else {
              return new _CID(version4, code2, digest, digest.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID3(version4, code2, digest.bytes);
            return new _CID(version4, code2, digest, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       */
      static createV0(digest) {
        return _CID.create(0, DAG_PB_CODE3, digest);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @param code - Content encoding format code.
       * @param digest - Multihash of the content.
       */
      static createV1(code2, digest) {
        return _CID.create(1, code2, digest);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       */
      static decode(bytes) {
        const [cid, remainder] = _CID.decodeFirst(bytes);
        if (remainder.length !== 0) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       */
      static decodeFirst(bytes) {
        const specs = _CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce3(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
        return [cid, bytes.subarray(specs.size)];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       */
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i2, length4] = decode11(initialBytes.subarray(offset));
          offset += length4;
          return i2;
        };
        let version4 = next();
        let codec = DAG_PB_CODE3;
        if (version4 === 18) {
          version4 = 0;
          offset = 0;
        } else {
          codec = next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       */
      static parse(source, base4) {
        const [prefix, bytes] = parseCIDtoBytes3(source, base4);
        const cid = _CID.decode(bytes);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache2(cid).set(prefix, source);
        return cid;
      }
    };
    DAG_PB_CODE3 = 112;
    SHA_256_CODE3 = 18;
    cidSymbol3 = Symbol.for("@ipld/js-cid/CID");
  }
});
var init_esm = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/index.mjs"() {
    init_base3();
    init_base323();
    init_base583();
    init_blake2b2();
    init_blake2bstream();
    init_cid3();
    init_hasher2();
    init_digest3();
  }
});
var require_scrypt_async = __commonJS({
  "node_modules/.deno/scrypt-async@2.0.1/node_modules/scrypt-async/scrypt-async.js"(exports2, module2) {
    function scrypt3(password, salt, logN, r, dkLen, interruptStep, callback, encoding) {
      "use strict";
      function SHA256(m3) {
        var K3 = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225, w4 = new Array(64);
        function blocks(p3) {
          var off = 0, len = p3.length;
          while (len >= 64) {
            var a = h0, b = h1, c = h2, d = h3, e2 = h4, f = h5, g2 = h6, h8 = h7, u2, i3, j, t1, t2;
            for (i3 = 0; i3 < 16; i3++) {
              j = off + i3 * 4;
              w4[i3] = (p3[j] & 255) << 24 | (p3[j + 1] & 255) << 16 | (p3[j + 2] & 255) << 8 | p3[j + 3] & 255;
            }
            for (i3 = 16; i3 < 64; i3++) {
              u2 = w4[i3 - 2];
              t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
              u2 = w4[i3 - 15];
              t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
              w4[i3] = (t1 + w4[i3 - 7] | 0) + (t2 + w4[i3 - 16] | 0) | 0;
            }
            for (i3 = 0; i3 < 64; i3++) {
              t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f ^ ~e2 & g2) | 0) + (h8 + (K3[i3] + w4[i3] | 0) | 0) | 0;
              t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
              h8 = g2;
              g2 = f;
              f = e2;
              e2 = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            h0 = h0 + a | 0;
            h1 = h1 + b | 0;
            h2 = h2 + c | 0;
            h3 = h3 + d | 0;
            h4 = h4 + e2 | 0;
            h5 = h5 + f | 0;
            h6 = h6 + g2 | 0;
            h7 = h7 + h8 | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m3);
        var i2, bytesLeft = m3.length % 64, bitLenHi = m3.length / 536870912 | 0, bitLenLo = m3.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m3.slice(m3.length - bytesLeft, m3.length);
        p2.push(128);
        for (i2 = bytesLeft + 1; i2 < numZeros; i2++) p2.push(0);
        p2.push(bitLenHi >>> 24 & 255);
        p2.push(bitLenHi >>> 16 & 255);
        p2.push(bitLenHi >>> 8 & 255);
        p2.push(bitLenHi >>> 0 & 255);
        p2.push(bitLenLo >>> 24 & 255);
        p2.push(bitLenLo >>> 16 & 255);
        p2.push(bitLenLo >>> 8 & 255);
        p2.push(bitLenLo >>> 0 & 255);
        blocks(p2);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password2, salt2, dkLen2) {
        if (password2.length > 64) {
          password2 = SHA256(password2.push ? password2 : Array.prototype.slice.call(password2, 0));
        }
        var i2, innerLen = 64 + salt2.length + 4, inner = new Array(innerLen), outerKey = new Array(64), dk = [];
        for (i2 = 0; i2 < 64; i2++) inner[i2] = 54;
        for (i2 = 0; i2 < password2.length; i2++) inner[i2] ^= password2[i2];
        for (i2 = 0; i2 < salt2.length; i2++) inner[64 + i2] = salt2[i2];
        for (i2 = innerLen - 4; i2 < innerLen; i2++) inner[i2] = 0;
        for (i2 = 0; i2 < 64; i2++) outerKey[i2] = 92;
        for (i2 = 0; i2 < password2.length; i2++) outerKey[i2] ^= password2[i2];
        function incrementCounter() {
          for (var i3 = innerLen - 1; i3 >= innerLen - 4; i3--) {
            inner[i3]++;
            if (inner[i3] <= 255) return;
            inner[i3] = 0;
          }
        }
        while (dkLen2 >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen2 -= 32;
        }
        if (dkLen2 > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen2));
        }
        return dk;
      }
      function salsaXOR(tmp2, B5, bin, bout) {
        var j0 = tmp2[0] ^ B5[bin++], j1 = tmp2[1] ^ B5[bin++], j2 = tmp2[2] ^ B5[bin++], j3 = tmp2[3] ^ B5[bin++], j4 = tmp2[4] ^ B5[bin++], j5 = tmp2[5] ^ B5[bin++], j6 = tmp2[6] ^ B5[bin++], j7 = tmp2[7] ^ B5[bin++], j8 = tmp2[8] ^ B5[bin++], j9 = tmp2[9] ^ B5[bin++], j10 = tmp2[10] ^ B5[bin++], j11 = tmp2[11] ^ B5[bin++], j12 = tmp2[12] ^ B5[bin++], j13 = tmp2[13] ^ B5[bin++], j14 = tmp2[14] ^ B5[bin++], j15 = tmp2[15] ^ B5[bin++], u2, i2;
        var x0 = j0, x1 = j1, x22 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15;
        for (i2 = 0; i2 < 8; i2 += 2) {
          u2 = x0 + x12;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x22;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        B5[bout++] = tmp2[0] = x0 + j0 | 0;
        B5[bout++] = tmp2[1] = x1 + j1 | 0;
        B5[bout++] = tmp2[2] = x22 + j2 | 0;
        B5[bout++] = tmp2[3] = x3 + j3 | 0;
        B5[bout++] = tmp2[4] = x4 + j4 | 0;
        B5[bout++] = tmp2[5] = x5 + j5 | 0;
        B5[bout++] = tmp2[6] = x6 + j6 | 0;
        B5[bout++] = tmp2[7] = x7 + j7 | 0;
        B5[bout++] = tmp2[8] = x8 + j8 | 0;
        B5[bout++] = tmp2[9] = x9 + j9 | 0;
        B5[bout++] = tmp2[10] = x10 + j10 | 0;
        B5[bout++] = tmp2[11] = x11 + j11 | 0;
        B5[bout++] = tmp2[12] = x12 + j12 | 0;
        B5[bout++] = tmp2[13] = x13 + j13 | 0;
        B5[bout++] = tmp2[14] = x14 + j14 | 0;
        B5[bout++] = tmp2[15] = x15 + j15 | 0;
      }
      function blockCopy(dst, di, src4, si, len) {
        while (len--) dst[di++] = src4[si++];
      }
      function blockXOR(dst, di, src4, si, len) {
        while (len--) dst[di++] ^= src4[si++];
      }
      function blockMix(tmp2, B5, bin, bout, r2) {
        blockCopy(tmp2, 0, B5, bin + (2 * r2 - 1) * 16, 16);
        for (var i2 = 0; i2 < 2 * r2; i2 += 2) {
          salsaXOR(tmp2, B5, bin + i2 * 16, bout + i2 * 8);
          salsaXOR(tmp2, B5, bin + i2 * 16 + 16, bout + i2 * 8 + r2 * 16);
        }
      }
      function integerify(B5, bi, r2) {
        return B5[bi + (2 * r2 - 1) * 16];
      }
      function stringToUTF8Bytes(s) {
        var arr = [];
        for (var i2 = 0; i2 < s.length; i2++) {
          var c = s.charCodeAt(i2);
          if (c < 128) {
            arr.push(c);
          } else if (c < 2048) {
            arr.push(192 | c >> 6);
            arr.push(128 | c & 63);
          } else if (c < 55296) {
            arr.push(224 | c >> 12);
            arr.push(128 | c >> 6 & 63);
            arr.push(128 | c & 63);
          } else {
            if (i2 >= s.length - 1) {
              throw new Error("invalid string");
            }
            i2++;
            c = (c & 1023) << 10;
            c |= s.charCodeAt(i2) & 1023;
            c += 65536;
            arr.push(240 | c >> 18);
            arr.push(128 | c >> 12 & 63);
            arr.push(128 | c >> 6 & 63);
            arr.push(128 | c & 63);
          }
        }
        return arr;
      }
      function bytesToHex(p2) {
        var enc = "0123456789abcdef".split("");
        var len = p2.length, arr = [], i2 = 0;
        for (; i2 < len; i2++) {
          arr.push(enc[p2[i2] >>> 4 & 15]);
          arr.push(enc[p2[i2] >>> 0 & 15]);
        }
        return arr.join("");
      }
      function bytesToBase64(p2) {
        var enc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        var len = p2.length, arr = [], i2 = 0, a, b, c, t;
        while (i2 < len) {
          a = i2 < len ? p2[i2++] : 0;
          b = i2 < len ? p2[i2++] : 0;
          c = i2 < len ? p2[i2++] : 0;
          t = (a << 16) + (b << 8) + c;
          arr.push(enc[t >>> 3 * 6 & 63]);
          arr.push(enc[t >>> 2 * 6 & 63]);
          arr.push(enc[t >>> 1 * 6 & 63]);
          arr.push(enc[t >>> 0 * 6 & 63]);
        }
        if (len % 3 > 0) {
          arr[arr.length - 1] = "=";
          if (len % 3 === 1) arr[arr.length - 2] = "=";
        }
        return arr.join("");
      }
      var MAX_UINT = -1 >>> 0, p = 1;
      if (typeof logN === "object") {
        if (arguments.length > 4) {
          throw new Error("scrypt: incorrect number of arguments");
        }
        var opts = logN;
        callback = r;
        logN = opts.logN;
        if (typeof logN === "undefined") {
          if (typeof opts.N !== "undefined") {
            if (opts.N < 2 || opts.N > MAX_UINT)
              throw new Error("scrypt: N is out of range");
            if ((opts.N & opts.N - 1) !== 0)
              throw new Error("scrypt: N is not a power of 2");
            logN = Math.log(opts.N) / Math.LN2;
          } else {
            throw new Error("scrypt: missing N parameter");
          }
        }
        p = opts.p || 1;
        r = opts.r;
        dkLen = opts.dkLen || 32;
        interruptStep = opts.interruptStep || 0;
        encoding = opts.encoding;
      }
      if (p < 1)
        throw new Error("scrypt: invalid p");
      if (r <= 0)
        throw new Error("scrypt: invalid r");
      if (logN < 1 || logN > 31)
        throw new Error("scrypt: logN must be between 1 and 31");
      var N11 = 1 << logN >>> 0, XY, V, B4, tmp;
      if (r * p >= 1 << 30 || r > MAX_UINT / 128 / p || r > MAX_UINT / 256 || N11 > MAX_UINT / 128 / r)
        throw new Error("scrypt: parameters are too large");
      if (typeof password === "string")
        password = stringToUTF8Bytes(password);
      if (typeof salt === "string")
        salt = stringToUTF8Bytes(salt);
      if (typeof Int32Array !== "undefined") {
        XY = new Int32Array(64 * r);
        V = new Int32Array(32 * N11 * r);
        tmp = new Int32Array(16);
      } else {
        XY = [];
        V = [];
        tmp = new Array(16);
      }
      B4 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
      var xi = 0, yi = 32 * r;
      function smixStart(pos) {
        for (var i2 = 0; i2 < 32 * r; i2++) {
          var j = pos + i2 * 4;
          XY[xi + i2] = (B4[j + 3] & 255) << 24 | (B4[j + 2] & 255) << 16 | (B4[j + 1] & 255) << 8 | (B4[j + 0] & 255) << 0;
        }
      }
      function smixStep1(start, end) {
        for (var i2 = start; i2 < end; i2 += 2) {
          blockCopy(V, i2 * (32 * r), XY, xi, 32 * r);
          blockMix(tmp, XY, xi, yi, r);
          blockCopy(V, (i2 + 1) * (32 * r), XY, yi, 32 * r);
          blockMix(tmp, XY, yi, xi, r);
        }
      }
      function smixStep2(start, end) {
        for (var i2 = start; i2 < end; i2 += 2) {
          var j = integerify(XY, xi, r) & N11 - 1;
          blockXOR(XY, xi, V, j * (32 * r), 32 * r);
          blockMix(tmp, XY, xi, yi, r);
          j = integerify(XY, yi, r) & N11 - 1;
          blockXOR(XY, yi, V, j * (32 * r), 32 * r);
          blockMix(tmp, XY, yi, xi, r);
        }
      }
      function smixFinish(pos) {
        for (var i2 = 0; i2 < 32 * r; i2++) {
          var j = XY[xi + i2];
          B4[pos + i2 * 4 + 0] = j >>> 0 & 255;
          B4[pos + i2 * 4 + 1] = j >>> 8 & 255;
          B4[pos + i2 * 4 + 2] = j >>> 16 & 255;
          B4[pos + i2 * 4 + 3] = j >>> 24 & 255;
        }
      }
      var nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      function interruptedFor(start, end, step, fn, donefn) {
        (function performStep() {
          nextTick(function() {
            fn(start, start + step < end ? start + step : end);
            start += step;
            if (start < end)
              performStep();
            else
              donefn();
          });
        })();
      }
      function getResult(enc) {
        var result = PBKDF2_HMAC_SHA256_OneIter(password, B4, dkLen);
        if (enc === "base64")
          return bytesToBase64(result);
        else if (enc === "hex")
          return bytesToHex(result);
        else if (enc === "binary")
          return new Uint8Array(result);
        else
          return result;
      }
      function calculateSync() {
        for (var i2 = 0; i2 < p; i2++) {
          smixStart(i2 * 128 * r);
          smixStep1(0, N11);
          smixStep2(0, N11);
          smixFinish(i2 * 128 * r);
        }
        callback(getResult(encoding));
      }
      function calculateAsync(i2) {
        smixStart(i2 * 128 * r);
        interruptedFor(0, N11, interruptStep * 2, smixStep1, function() {
          interruptedFor(0, N11, interruptStep * 2, smixStep2, function() {
            smixFinish(i2 * 128 * r);
            if (i2 + 1 < p) {
              nextTick(function() {
                calculateAsync(i2 + 1);
              });
            } else {
              callback(getResult(encoding));
            }
          });
        });
      }
      if (typeof interruptStep === "function") {
        encoding = callback;
        callback = interruptStep;
        interruptStep = 1e3;
      }
      if (interruptStep <= 0) {
        calculateSync();
      } else {
        calculateAsync(0);
      }
    }
    if (typeof module2 !== "undefined") module2.exports = scrypt3;
  }
});
var require_nacl_fast = __commonJS({
  "node_modules/.deno/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl4) {
      "use strict";
      var gf = function(init2) {
        var i2, r = new Float64Array(16);
        if (init2) for (i2 = 0; i2 < init2.length; i2++) r[i2] = init2[i2];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x3, i2, h2, l) {
        x3[i2] = h2 >> 24 & 255;
        x3[i2 + 1] = h2 >> 16 & 255;
        x3[i2 + 2] = h2 >> 8 & 255;
        x3[i2 + 3] = h2 & 255;
        x3[i2 + 4] = l >> 24 & 255;
        x3[i2 + 5] = l >> 16 & 255;
        x3[i2 + 6] = l >> 8 & 255;
        x3[i2 + 7] = l & 255;
      }
      function vn(x3, xi, y, yi, n) {
        var i2, d = 0;
        for (i2 = 0; i2 < n; i2++) d |= x3[xi + i2] ^ y[yi + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x3, xi, y, yi) {
        return vn(x3, xi, y, yi, 16);
      }
      function crypto_verify_32(x3, xi, y, yi) {
        return vn(x3, xi, y, yi, 32);
      }
      function core_salsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x22 = x22 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x1 >>> 0 & 255;
        o2[5] = x1 >>> 8 & 255;
        o2[6] = x1 >>> 16 & 255;
        o2[7] = x1 >>> 24 & 255;
        o2[8] = x22 >>> 0 & 255;
        o2[9] = x22 >>> 8 & 255;
        o2[10] = x22 >>> 16 & 255;
        o2[11] = x22 >>> 24 & 255;
        o2[12] = x3 >>> 0 & 255;
        o2[13] = x3 >>> 8 & 255;
        o2[14] = x3 >>> 16 & 255;
        o2[15] = x3 >>> 24 & 255;
        o2[16] = x4 >>> 0 & 255;
        o2[17] = x4 >>> 8 & 255;
        o2[18] = x4 >>> 16 & 255;
        o2[19] = x4 >>> 24 & 255;
        o2[20] = x5 >>> 0 & 255;
        o2[21] = x5 >>> 8 & 255;
        o2[22] = x5 >>> 16 & 255;
        o2[23] = x5 >>> 24 & 255;
        o2[24] = x6 >>> 0 & 255;
        o2[25] = x6 >>> 8 & 255;
        o2[26] = x6 >>> 16 & 255;
        o2[27] = x6 >>> 24 & 255;
        o2[28] = x7 >>> 0 & 255;
        o2[29] = x7 >>> 8 & 255;
        o2[30] = x7 >>> 16 & 255;
        o2[31] = x7 >>> 24 & 255;
        o2[32] = x8 >>> 0 & 255;
        o2[33] = x8 >>> 8 & 255;
        o2[34] = x8 >>> 16 & 255;
        o2[35] = x8 >>> 24 & 255;
        o2[36] = x9 >>> 0 & 255;
        o2[37] = x9 >>> 8 & 255;
        o2[38] = x9 >>> 16 & 255;
        o2[39] = x9 >>> 24 & 255;
        o2[40] = x10 >>> 0 & 255;
        o2[41] = x10 >>> 8 & 255;
        o2[42] = x10 >>> 16 & 255;
        o2[43] = x10 >>> 24 & 255;
        o2[44] = x11 >>> 0 & 255;
        o2[45] = x11 >>> 8 & 255;
        o2[46] = x11 >>> 16 & 255;
        o2[47] = x11 >>> 24 & 255;
        o2[48] = x12 >>> 0 & 255;
        o2[49] = x12 >>> 8 & 255;
        o2[50] = x12 >>> 16 & 255;
        o2[51] = x12 >>> 24 & 255;
        o2[52] = x13 >>> 0 & 255;
        o2[53] = x13 >>> 8 & 255;
        o2[54] = x13 >>> 16 & 255;
        o2[55] = x13 >>> 24 & 255;
        o2[56] = x14 >>> 0 & 255;
        o2[57] = x14 >>> 8 & 255;
        o2[58] = x14 >>> 16 & 255;
        o2[59] = x14 >>> 24 & 255;
        o2[60] = x15 >>> 0 & 255;
        o2[61] = x15 >>> 8 & 255;
        o2[62] = x15 >>> 16 & 255;
        o2[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x5 >>> 0 & 255;
        o2[5] = x5 >>> 8 & 255;
        o2[6] = x5 >>> 16 & 255;
        o2[7] = x5 >>> 24 & 255;
        o2[8] = x10 >>> 0 & 255;
        o2[9] = x10 >>> 8 & 255;
        o2[10] = x10 >>> 16 & 255;
        o2[11] = x10 >>> 24 & 255;
        o2[12] = x15 >>> 0 & 255;
        o2[13] = x15 >>> 8 & 255;
        o2[14] = x15 >>> 16 & 255;
        o2[15] = x15 >>> 24 & 255;
        o2[16] = x6 >>> 0 & 255;
        o2[17] = x6 >>> 8 & 255;
        o2[18] = x6 >>> 16 & 255;
        o2[19] = x6 >>> 24 & 255;
        o2[20] = x7 >>> 0 & 255;
        o2[21] = x7 >>> 8 & 255;
        o2[22] = x7 >>> 16 & 255;
        o2[23] = x7 >>> 24 & 255;
        o2[24] = x8 >>> 0 & 255;
        o2[25] = x8 >>> 8 & 255;
        o2[26] = x8 >>> 16 & 255;
        o2[27] = x8 >>> 24 & 255;
        o2[28] = x9 >>> 0 & 255;
        o2[29] = x9 >>> 8 & 255;
        o2[30] = x9 >>> 16 & 255;
        o2[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m3, mpos, b, n, k) {
        var z = new Uint8Array(16), x3 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = m3[mpos + i2] ^ x3[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z[i2] & 255) | 0;
            z[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = m3[mpos + i2] ^ x3[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x3 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = x3[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z[i2] & 255) | 0;
            z[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = x3[i2];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m3, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20_xor(c, cpos, m3, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m3, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m3[mpos + 0] & 255 | (m3[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m3[mpos + 2] & 255 | (m3[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m3[mpos + 4] & 255 | (m3[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m3[mpos + 6] & 255 | (m3[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m3[mpos + 8] & 255 | (m3[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m3[mpos + 10] & 255 | (m3[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m3[mpos + 12] & 255 | (m3[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m3[mpos + 14] & 255 | (m3[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c, mask, f, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c;
          c = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g2[0] = this.h[0] + 5;
        c = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this.h[i2] + c;
          c = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g2[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask | g2[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this.h[i2] + this.pad[i2] | 0) + (f >>> 16) | 0;
          this.h[i2] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m3, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m3[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m3, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m3[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m3, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m3, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m3, mpos, n, k) {
        var x3 = new Uint8Array(16);
        crypto_onetimeauth(x3, 0, m3, mpos, n, k);
        return crypto_verify_16(h2, hpos, x3, 0);
      }
      function crypto_secretbox(c, m3, d, n, k) {
        var i2;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m3, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i2 = 0; i2 < 16; i2++) c[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m3, c, d, n, k) {
        var i2;
        var x3 = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x3, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x3) !== 0) return -1;
        crypto_stream_xor(m3, 0, c, 0, d, n, k);
        for (i2 = 0; i2 < 32; i2++) m3[i2] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r[i2] = a[i2] | 0;
      }
      function car25519(o2) {
        var i2, v2, c = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v2 = o2[i2] + c + 65535;
          c = Math.floor(v2 / 65536);
          o2[i2] = v2 - c * 65536;
        }
        o2[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t = c & (p[i2] ^ q[i2]);
          p[i2] ^= t;
          q[i2] ^= t;
        }
      }
      function pack25519(o2, n) {
        var i2, j, b;
        var m3 = gf(), t = gf();
        for (i2 = 0; i2 < 16; i2++) t[i2] = n[i2];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m3[0] = t[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m3[i2] = t[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
            m3[i2 - 1] &= 65535;
          }
          m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
          b = m3[15] >> 16 & 1;
          m3[14] &= 65535;
          sel25519(t, m3, 1 - b);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o2[2 * i2] = t[i2] & 255;
          o2[2 * i2 + 1] = t[i2] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o2, n) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o2[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
        o2[15] &= 32767;
      }
      function A2(o2, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a[i2] + b[i2];
      }
      function Z(o2, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a[i2] - b[i2];
      }
      function M2(o2, a, b) {
        var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v2 = a[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b2;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b2;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b2;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b2;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b2;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b2;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b2;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b2;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b2;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b2;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b2;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b2;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b2;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b2;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b2;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b2;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o2[0] = t0;
        o2[1] = t1;
        o2[2] = t2;
        o2[3] = t3;
        o2[4] = t4;
        o2[5] = t5;
        o2[6] = t6;
        o2[7] = t7;
        o2[8] = t8;
        o2[9] = t9;
        o2[10] = t10;
        o2[11] = t11;
        o2[12] = t12;
        o2[13] = t13;
        o2[14] = t14;
        o2[15] = t15;
      }
      function S2(o2, a) {
        M2(o2, a, a);
      }
      function inv25519(o2, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 253; a >= 0; a--) {
          S2(c, c);
          if (a !== 2 && a !== 4) M2(c, c, i2);
        }
        for (a = 0; a < 16; a++) o2[a] = c[a];
      }
      function pow2523(o2, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 250; a >= 0; a--) {
          S2(c, c);
          if (a !== 1) M2(c, c, i2);
        }
        for (a = 0; a < 16; a++) o2[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x3 = new Float64Array(80), r, i2;
        var a = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf();
        for (i2 = 0; i2 < 31; i2++) z[i2] = n[i2];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x3, p);
        for (i2 = 0; i2 < 16; i2++) {
          b[i2] = x3[i2];
          d[i2] = a[i2] = c[i2] = 0;
        }
        a[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r = z[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A2(e2, a, c);
          Z(a, a, c);
          A2(c, b, d);
          Z(b, b, d);
          S2(d, e2);
          S2(f, a);
          M2(a, c, a);
          M2(c, b, e2);
          A2(e2, a, c);
          Z(a, a, c);
          S2(b, a);
          Z(c, d, f);
          M2(a, c, _121665);
          A2(a, a, d);
          M2(c, c, a);
          M2(a, d, f);
          M2(d, b, x3);
          S2(b, e2);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x3[i2 + 16] = a[i2];
          x3[i2 + 32] = c[i2];
          x3[i2 + 48] = b[i2];
          x3[i2 + 64] = d[i2];
        }
        var x32 = x3.subarray(32);
        var x16 = x3.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x3) {
        randombytes(x3, 32);
        return crypto_scalarmult_base(y, x3);
      }
      function crypto_box_beforenm(k, y, x3) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x3, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m3, d, n, y, x3) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x3);
        return crypto_box_afternm(c, m3, d, n, k);
      }
      function crypto_box_open(m3, c, d, n, y, x3) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x3);
        return crypto_box_open_afternm(m3, c, d, n, k);
      }
      var K3 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m3, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j, h2, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m3[j + 0] << 24 | m3[j + 1] << 16 | m3[j + 2] << 8 | m3[j + 3];
            wl[i2] = m3[j + 4] << 24 | m3[j + 5] << 16 | m3[j + 6] << 8 | m3[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = K3[i2 * 2];
            l = K3[i2 * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = wh[i2 % 16];
            l = wl[i2 % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h2 = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h2 = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h2 = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h2 & 65535;
                d = h2 >>> 16;
                h2 = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h2 = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h2 = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h2 = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h2 = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h2 = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h2 = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h2 = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h2 = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m3, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x3 = new Uint8Array(256), i2, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m3, n);
        n %= 128;
        for (i2 = 0; i2 < n; i2++) x3[i2] = m3[b - n + i2];
        x3[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x3[n - 9] = 0;
        ts64(x3, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x3, n);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf(), g2 = gf(), h2 = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M2(a, a, t);
        A2(b, p[0], p[1]);
        A2(t, q[0], q[1]);
        M2(b, b, t);
        M2(c, p[3], q[3]);
        M2(c, c, D2);
        M2(d, p[2], q[2]);
        A2(d, d, d);
        Z(e2, b, a);
        Z(f, d, c);
        A2(g2, d, c);
        A2(h2, b, a);
        M2(p[0], e2, f);
        M2(p[1], h2, g2);
        M2(p[2], g2, f);
        M2(p[3], e2, h2);
      }
      function cswap(p, q, b) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p[i2], q[i2], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M2(tx, p[0], zi);
        M2(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i2;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b = s[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M2(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x3) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x3[j] += carry - 16 * x3[i2] * L[j - (i2 - 32)];
            carry = Math.floor((x3[j] + 128) / 256);
            x3[j] -= carry * 256;
          }
          x3[j] += carry;
          x3[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x3[j] += carry - (x3[31] >> 4) * L[j];
          carry = x3[j] >> 8;
          x3[j] &= 255;
        }
        for (j = 0; j < 32; j++) x3[j] -= carry * L[j];
        for (i2 = 0; i2 < 32; i2++) {
          x3[i2 + 1] += x3[i2] >> 8;
          r[i2] = x3[i2] & 255;
        }
      }
      function reduce(r) {
        var x3 = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x3[i2] = r[i2];
        for (i2 = 0; i2 < 64; i2++) r[i2] = 0;
        modL(r, x3);
      }
      function crypto_sign(sm, m3, n, sk) {
        var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
        var i2, j, x3 = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i2 = 0; i2 < n; i2++) sm[64 + i2] = m3[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d[32 + i2];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h2, sm, n + 64);
        reduce(h2);
        for (i2 = 0; i2 < 64; i2++) x3[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x3[i2] = r[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x3[i2 + j] += h2[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x3);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S2(num, r[1]);
        M2(den, num, D);
        Z(num, num, r[2]);
        A2(den, r[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r[0], t, den);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r[0], r[0], I2);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M2(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m3, sm, n, pk) {
        var i2;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i2 = 0; i2 < n; i2++) m3[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m3[i2 + 32] = pk[i2];
        crypto_hash(h2, m3, n);
        reduce(h2);
        scalarmult(p, q, h2);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i2 = 0; i2 < n; i2++) m3[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n; i2++) m3[i2] = sm[i2 + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl4.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
      }
      nacl4.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl4.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m3 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m3.length);
        for (var i2 = 0; i2 < msg.length; i2++) m3[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c, m3, m3.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl4.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m3 = new Uint8Array(c.length);
        for (var i2 = 0; i2 < box.length; i2++) c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m3, c, c.length, nonce, key) !== 0) return null;
        return m3.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl4.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl4.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl4.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl4.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl4.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl4.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl4.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl4.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl4.box.before(publicKey, secretKey);
        return nacl4.secretbox(msg, nonce, k);
      };
      nacl4.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl4.box.after = nacl4.secretbox;
      nacl4.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl4.box.before(publicKey, secretKey);
        return nacl4.secretbox.open(msg, nonce, k);
      };
      nacl4.box.open.after = nacl4.secretbox.open;
      nacl4.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl4.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl4.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl4.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl4.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl4.box.nonceLength = crypto_box_NONCEBYTES;
      nacl4.box.overheadLength = nacl4.secretbox.overheadLength;
      nacl4.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl4.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m3 = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m3.length; i2++) m3[i2] = tmp[i2];
        return m3;
      };
      nacl4.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl4.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl4.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
      };
      nacl4.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl4.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl4.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl4.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl4.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl4.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl4.sign.signatureLength = crypto_sign_BYTES;
      nacl4.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl4.hash.hashLength = crypto_hash_BYTES;
      nacl4.verify = function(x3, y) {
        checkArrayTypes(x3, y);
        if (x3.length === 0 || y.length === 0) return false;
        if (x3.length !== y.length) return false;
        return vn(x3, 0, y, 0, x3.length) === 0 ? true : false;
      };
      nacl4.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl4.setPRNG(function(x3, n) {
            var i2, v2 = new Uint8Array(n);
            for (i2 = 0; i2 < n; i2 += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n; i2++) x3[i2] = v2[i2];
            cleanup(v2);
          });
        } else if (typeof __require2 !== "undefined") {
          crypto2 = __require2("crypto");
          if (crypto2 && crypto2.randomBytes) {
            nacl4.setPRNG(function(x3, n) {
              var i2, v2 = crypto2.randomBytes(n);
              for (i2 = 0; i2 < n; i2++) x3[i2] = v2[i2];
              cleanup(v2);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});
var import_scrypt_async;
var import_tweetnacl;
var bufToStr;
var strToBuf;
var blake32Hash;
var b64ToBuf;
var ENULL;
var SNULL;
var EDWARDS25519SHA512BATCH;
var CURVE25519XSALSA20POLY1305;
var XSALSA20POLY1305;
var EXTERNALKM32;
var bytesOrObjectToB64;
var keygen;
var generateSalt;
var serializeKey;
var deserializeKey;
var keyId;
var sign;
var verifySignature;
var encrypt;
var decrypt;
var init_esm2 = __esm({
  "node_modules/.deno/@chelonia+crypto@1.0.1/node_modules/@chelonia/crypto/dist/esm/index.mjs"() {
    init_esm();
    import_scrypt_async = __toESM(require_scrypt_async(), 1);
    import_tweetnacl = __toESM(require_nacl_fast(), 1);
    bufToStr = (() => {
      const textDecoder = new TextDecoder();
      return (buf2) => {
        return textDecoder.decode(buf2);
      };
    })();
    strToBuf = (() => {
      const textEncoder = new TextEncoder();
      return (str) => {
        return textEncoder.encode(str);
      };
    })();
    blake32Hash = (data) => {
      const uint8array = typeof data === "string" ? strToBuf(data) : data;
      const digest = blake2b2562.digest(uint8array);
      return base58btc3.encode(digest.bytes);
    };
    b64ToBuf = (data) => new Uint8Array(atob(data).split("").map((b) => b.charCodeAt(0)));
    ENULL = "eNULL";
    SNULL = "sNULL";
    EDWARDS25519SHA512BATCH = "edwards25519sha512batch";
    CURVE25519XSALSA20POLY1305 = "curve25519xsalsa20poly1305";
    XSALSA20POLY1305 = "xsalsa20poly1305";
    EXTERNALKM32 = "externalkm32";
    if (false) {
      throw new Error("ENABLE_UNSAFE_NULL_CRYPTO cannot be enabled in production mode");
    }
    bytesOrObjectToB64 = (ary) => {
      if (!(ary instanceof Uint8Array)) {
        throw TypeError("Unsupported type");
      }
      return btoa(Array.from(ary).map((c) => String.fromCharCode(c)).join(""));
    };
    keygen = (type) => {
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (type === ENULL || type === SNULL)) {
        const res = {
          type,
          publicKey: bytesOrObjectToB64(import_tweetnacl.default.randomBytes(18))
        };
        Object.defineProperty(res, "secretKey", { value: res.publicKey });
        return res;
      }
      if (type === EDWARDS25519SHA512BATCH) {
        const key = import_tweetnacl.default.sign.keyPair();
        const res = {
          type,
          publicKey: key.publicKey
        };
        Object.defineProperty(res, "secretKey", { value: key.secretKey });
        return res;
      } else if (type === CURVE25519XSALSA20POLY1305) {
        const key = import_tweetnacl.default.box.keyPair();
        const res = {
          type,
          publicKey: key.publicKey
        };
        Object.defineProperty(res, "secretKey", { value: key.secretKey });
        return res;
      } else if (type === XSALSA20POLY1305) {
        const res = {
          type
        };
        Object.defineProperty(res, "secretKey", { value: import_tweetnacl.default.randomBytes(import_tweetnacl.default.secretbox.keyLength) });
        return res;
      } else if (type === EXTERNALKM32) {
        const res = {
          type
        };
        Object.defineProperty(res, "secretKey", { value: import_tweetnacl.default.randomBytes(32) });
        return res;
      }
      throw new Error("Unsupported key type");
    };
    generateSalt = () => {
      return bytesOrObjectToB64(import_tweetnacl.default.randomBytes(18));
    };
    serializeKey = (key, saveSecretKey) => {
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (key.type === ENULL || key.type === SNULL)) {
        return JSON.stringify([
          key.type,
          saveSecretKey ? null : key.publicKey,
          saveSecretKey ? key.secretKey : null
        ], void 0, 0);
      }
      if (key.type === EDWARDS25519SHA512BATCH || key.type === CURVE25519XSALSA20POLY1305) {
        if (!saveSecretKey) {
          if (!key.publicKey) {
            throw new Error("Unsupported operation: no public key to export");
          }
          return JSON.stringify([
            key.type,
            bytesOrObjectToB64(key.publicKey),
            null
          ], void 0, 0);
        }
        if (!key.secretKey) {
          throw new Error("Unsupported operation: no secret key to export");
        }
        return JSON.stringify([
          key.type,
          null,
          bytesOrObjectToB64(key.secretKey)
        ], void 0, 0);
      } else if (key.type === XSALSA20POLY1305) {
        if (!saveSecretKey) {
          throw new Error("Unsupported operation: no public key to export");
        }
        if (!key.secretKey) {
          throw new Error("Unsupported operation: no secret key to export");
        }
        return JSON.stringify([
          key.type,
          null,
          bytesOrObjectToB64(key.secretKey)
        ], void 0, 0);
      }
      throw new Error("Unsupported key type");
    };
    deserializeKey = (data) => {
      const keyData = JSON.parse(data);
      if (!keyData || keyData.length !== 3) {
        throw new Error("Invalid key object");
      }
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (keyData[0] === ENULL || keyData[0] === SNULL)) {
        const res = {
          type: keyData[0]
        };
        if (keyData[2]) {
          Object.defineProperty(res, "secretKey", { value: keyData[2] });
          res.publicKey = keyData[2];
        } else {
          res.publicKey = keyData[1];
        }
        return res;
      }
      if (keyData[0] === EDWARDS25519SHA512BATCH) {
        if (keyData[2]) {
          const key = import_tweetnacl.default.sign.keyPair.fromSecretKey(b64ToBuf(keyData[2]));
          const res = {
            type: keyData[0],
            publicKey: key.publicKey
          };
          Object.defineProperty(res, "secretKey", { value: key.secretKey });
          return res;
        } else if (keyData[1]) {
          return {
            type: keyData[0],
            publicKey: new Uint8Array(b64ToBuf(keyData[1]))
          };
        }
        throw new Error("Missing secret or public key");
      } else if (keyData[0] === CURVE25519XSALSA20POLY1305) {
        if (keyData[2]) {
          const key = import_tweetnacl.default.box.keyPair.fromSecretKey(b64ToBuf(keyData[2]));
          const res = {
            type: keyData[0],
            publicKey: key.publicKey
          };
          Object.defineProperty(res, "secretKey", { value: key.secretKey });
          return res;
        } else if (keyData[1]) {
          return {
            type: keyData[0],
            publicKey: new Uint8Array(b64ToBuf(keyData[1]))
          };
        }
        throw new Error("Missing secret or public key");
      } else if (keyData[0] === XSALSA20POLY1305) {
        if (!keyData[2]) {
          throw new Error("Secret key missing");
        }
        const res = {
          type: keyData[0]
        };
        Object.defineProperty(res, "secretKey", { value: new Uint8Array(b64ToBuf(keyData[2])) });
        return res;
      }
      throw new Error("Unsupported key type");
    };
    keyId = (inKey) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      const serializedKey = serializeKey(key, !key.publicKey);
      return blake32Hash(serializedKey);
    };
    sign = (inKey, data) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === SNULL) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        return key.secretKey + ";" + blake32Hash(data);
      }
      if (key.type !== EDWARDS25519SHA512BATCH) {
        throw new Error("Unsupported algorithm");
      }
      if (!key.secretKey) {
        throw new Error("Secret key missing");
      }
      const messageUint8 = strToBuf(data);
      const signature = import_tweetnacl.default.sign.detached(messageUint8, key.secretKey);
      const base64Signature = bytesOrObjectToB64(signature);
      return base64Signature;
    };
    verifySignature = (inKey, data, signature) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === SNULL) {
        if (!key.publicKey) {
          throw new Error("Public key missing");
        }
        if (key.publicKey + ";" + blake32Hash(data) !== signature) {
          throw new Error("Invalid signature");
        }
        return;
      }
      if (key.type !== EDWARDS25519SHA512BATCH) {
        throw new Error("Unsupported algorithm");
      }
      if (!key.publicKey) {
        throw new Error("Public key missing");
      }
      const decodedSignature = b64ToBuf(signature);
      const messageUint8 = strToBuf(data);
      const result = import_tweetnacl.default.sign.detached.verify(messageUint8, decodedSignature, key.publicKey);
      if (!result) {
        throw new Error("Invalid signature");
      }
    };
    encrypt = (inKey, data, ad) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === ENULL) {
        if (!key.publicKey) {
          throw new Error("Public key missing");
        }
        return `${key.publicKey};${data};${ad !== null && ad !== void 0 ? ad : ""}`;
      }
      if (key.type === XSALSA20POLY1305) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.secretbox.nonceLength);
        let encryptionNonce;
        if (ad) {
          encryptionNonce = new Uint8Array(nonce);
          const adHash = import_tweetnacl.default.hash(strToBuf(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            encryptionNonce[i2] ^= adHash[i2];
          }
        } else {
          encryptionNonce = nonce;
        }
        const messageUint8 = strToBuf(data);
        const box = import_tweetnacl.default.secretbox(messageUint8, encryptionNonce, key.secretKey);
        const fullMessage = new Uint8Array(nonce.length + box.length);
        fullMessage.set(nonce);
        fullMessage.set(box, nonce.length);
        const base64FullMessage = bytesOrObjectToB64(fullMessage);
        return base64FullMessage;
      } else if (key.type === CURVE25519XSALSA20POLY1305) {
        if (!key.publicKey) {
          throw new Error("Public key missing");
        }
        const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
        let encryptionNonce;
        if (ad) {
          encryptionNonce = new Uint8Array(nonce);
          const adHash = import_tweetnacl.default.hash(strToBuf(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            encryptionNonce[i2] ^= adHash[i2];
          }
        } else {
          encryptionNonce = nonce;
        }
        const messageUint8 = strToBuf(data);
        const ephemeralKey = import_tweetnacl.default.box.keyPair();
        const box = import_tweetnacl.default.box(messageUint8, encryptionNonce, key.publicKey, ephemeralKey.secretKey);
        crypto.getRandomValues(ephemeralKey.secretKey);
        ephemeralKey.secretKey.fill(0);
        const fullMessage = new Uint8Array(import_tweetnacl.default.box.publicKeyLength + nonce.length + box.length);
        fullMessage.set(ephemeralKey.publicKey);
        fullMessage.set(nonce, import_tweetnacl.default.box.publicKeyLength);
        fullMessage.set(box, import_tweetnacl.default.box.publicKeyLength + nonce.length);
        const base64FullMessage = bytesOrObjectToB64(fullMessage);
        return base64FullMessage;
      }
      throw new Error("Unsupported algorithm");
    };
    decrypt = (inKey, data, ad) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === ENULL) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        if (!data.startsWith(key.secretKey + ";") || !data.endsWith(";" + (ad !== null && ad !== void 0 ? ad : ""))) {
          throw new Error("Additional data mismatch");
        }
        return data.slice(String(key.secretKey).length + 1, data.length - 1 - (ad !== null && ad !== void 0 ? ad : "").length);
      }
      if (key.type === XSALSA20POLY1305) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        const messageWithNonceAsUint8Array = b64ToBuf(data);
        const nonce = messageWithNonceAsUint8Array.slice(0, import_tweetnacl.default.secretbox.nonceLength);
        const message = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.secretbox.nonceLength, messageWithNonceAsUint8Array.length);
        if (ad) {
          const adHash = import_tweetnacl.default.hash(strToBuf(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            nonce[i2] ^= adHash[i2];
          }
        }
        const decrypted = import_tweetnacl.default.secretbox.open(message, nonce, key.secretKey);
        if (!decrypted) {
          throw new Error("Could not decrypt message");
        }
        return bufToStr(decrypted);
      } else if (key.type === CURVE25519XSALSA20POLY1305) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        const messageWithNonceAsUint8Array = b64ToBuf(data);
        const ephemeralPublicKey = messageWithNonceAsUint8Array.slice(0, import_tweetnacl.default.box.publicKeyLength);
        const nonce = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.box.publicKeyLength, import_tweetnacl.default.box.publicKeyLength + import_tweetnacl.default.box.nonceLength);
        const message = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.box.publicKeyLength + import_tweetnacl.default.box.nonceLength);
        if (ad) {
          const adHash = import_tweetnacl.default.hash(strToBuf(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            nonce[i2] ^= adHash[i2];
          }
        }
        const decrypted = import_tweetnacl.default.box.open(message, nonce, ephemeralPublicKey, key.secretKey);
        if (!decrypted) {
          throw new Error("Could not decrypt message");
        }
        return bufToStr(decrypted);
      }
      throw new Error("Unsupported algorithm");
    };
  }
});
var require_assertError = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assertError.js"(exports2, module2) {
    "use strict";
    module2.exports = class AssertError extends Error {
      name = "AssertError";
      constructor(message, ctor) {
        super(message || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, ctor);
        }
      }
    };
  }
});
var require_stringify = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/stringify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(...args) {
      try {
        return JSON.stringify(...args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
  }
});
var require_assert = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assert.js"(exports2, module2) {
    "use strict";
    var AssertError = require_assertError();
    var Stringify = require_stringify();
    var assert22 = module2.exports = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
      });
      throw new AssertError(msgs.join(" "), assert22);
    };
  }
});
var require_reach = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reach.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var internals = {};
    module2.exports = function(obj, chain, options3) {
      if (chain === false || chain === null || chain === void 0) {
        return obj;
      }
      options3 = options3 || {};
      if (typeof options3 === "string") {
        options3 = { separator: options3 };
      }
      const isChainArray = Array.isArray(chain);
      Assert(!isChainArray || !options3.separator, "Separator option is not valid for array-based chain");
      const path12 = isChainArray ? chain : chain.split(options3.separator || ".");
      let ref = obj;
      for (let i2 = 0; i2 < path12.length; ++i2) {
        let key = path12[i2];
        const type = options3.iterables && internals.iterables(ref);
        if (Array.isArray(ref) || type === "set") {
          const number2 = Number(key);
          if (Number.isInteger(number2)) {
            key = number2 < 0 ? ref.length + number2 : number2;
          }
        }
        if (!ref || typeof ref === "function" && options3.functions === false || // Defaults to true
        !type && ref[key] === void 0) {
          Assert(!options3.strict || i2 + 1 === path12.length, "Missing segment", key, "in reach path ", chain);
          Assert(typeof ref === "object" || options3.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options3.default;
          break;
        }
        if (!type) {
          ref = ref[key];
        } else if (type === "set") {
          ref = [...ref][key];
        } else {
          ref = ref.get(key);
        }
      }
      return ref;
    };
    internals.iterables = function(ref) {
      if (ref instanceof Set) {
        return "set";
      }
      if (ref instanceof Map) {
        return "map";
      }
    };
  }
});
var require_types = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/types.js"(exports2, module2) {
    "use strict";
    var internals = {};
    exports2 = module2.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      // $lab:coverage:ignore$
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      url: URL.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      ["[object Error]", exports2.error],
      ["[object Map]", exports2.map],
      ["[object Promise]", exports2.promise],
      ["[object Set]", exports2.set],
      ["[object URL]", exports2.url],
      ["[object WeakMap]", exports2.weakMap],
      ["[object WeakSet]", exports2.weakSet]
    ]);
    exports2.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports2.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports2.buffer;
      }
      if (obj instanceof Date) {
        return exports2.date;
      }
      if (obj instanceof RegExp) {
        return exports2.regex;
      }
      if (obj instanceof Error) {
        return exports2.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports2.generic;
    };
  }
});
var require_utils = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/utils.js"(exports2) {
    "use strict";
    exports2.keys = function(obj, options3 = {}) {
      return options3.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
  }
});
var require_clone = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/clone.js"(exports2, module2) {
    "use strict";
    var Reach = require_reach();
    var Types = require_types();
    var Utils = require_utils();
    var internals = {
      needsProtoHack: /* @__PURE__ */ new Set([Types.set, Types.map, Types.weakSet, Types.weakMap]),
      structuredCloneExists: typeof structuredClone === "function"
    };
    module2.exports = internals.clone = function(obj, options3 = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      let clone2 = internals.clone;
      let seen = _seen;
      if (options3.shallow) {
        if (options3.shallow !== true) {
          return internals.cloneWithShallow(obj, options3);
        }
        clone2 = (value) => value;
      } else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
          return lookup;
        }
      } else {
        seen = /* @__PURE__ */ new Map();
      }
      const baseProto = Types.getInternalProto(obj);
      switch (baseProto) {
        case Types.buffer:
          return Buffer?.from(obj);
        case Types.date:
          return new Date(obj.getTime());
        case Types.regex:
        case Types.url:
          return new baseProto.constructor(obj);
      }
      const newObj = internals.base(obj, baseProto, options3);
      if (newObj === obj) {
        return obj;
      }
      if (seen) {
        seen.set(obj, newObj);
      }
      if (baseProto === Types.set) {
        for (const value of obj) {
          newObj.add(clone2(value, options3, seen));
        }
      } else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
          newObj.set(key, clone2(value, options3, seen));
        }
      }
      const keys = Utils.keys(obj, options3);
      for (const key of keys) {
        if (key === "__proto__") {
          continue;
        }
        if (baseProto === Types.array && key === "length") {
          newObj.length = obj.length;
          continue;
        }
        if (internals.structuredCloneExists && baseProto === Types.error && key === "stack") {
          continue;
        }
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, key, descriptor);
          } else if (descriptor.enumerable) {
            newObj[key] = clone2(obj[key], options3, seen);
          } else {
            Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone2(obj[key], options3, seen) });
          }
        } else {
          Object.defineProperty(newObj, key, {
            enumerable: true,
            writable: true,
            configurable: true,
            value: clone2(obj[key], options3, seen)
          });
        }
      }
      return newObj;
    };
    internals.cloneWithShallow = function(source, options3) {
      const keys = options3.shallow;
      options3 = Object.assign({}, options3);
      options3.shallow = false;
      const seen = /* @__PURE__ */ new Map();
      for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === "object" || typeof ref === "function") {
          seen.set(ref, ref);
        }
      }
      return internals.clone(source, options3, seen);
    };
    internals.base = function(obj, baseProto, options3) {
      if (options3.prototype === false) {
        if (internals.needsProtoHack.has(baseProto)) {
          return new baseProto.constructor();
        }
        return baseProto === Types.array ? [] : {};
      }
      const proto3 = Object.getPrototypeOf(obj);
      if (proto3 && proto3.isImmutable) {
        return obj;
      }
      if (baseProto === Types.array) {
        const newObj = [];
        if (proto3 !== baseProto) {
          Object.setPrototypeOf(newObj, proto3);
        }
        return newObj;
      } else if (baseProto === Types.error && internals.structuredCloneExists && (proto3 === baseProto || Error.isPrototypeOf(proto3.constructor))) {
        const err = structuredClone(obj);
        if (Object.getPrototypeOf(err) !== proto3) {
          Object.setPrototypeOf(err, proto3);
        }
        return err;
      }
      if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto3.constructor();
        if (proto3 !== baseProto) {
          Object.setPrototypeOf(newObj, proto3);
        }
        return newObj;
      }
      return Object.create(proto3);
    };
  }
});
var require_merge = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/merge.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Utils = require_utils();
    var internals = {};
    module2.exports = internals.merge = function(target, source, options3) {
      Assert(target && typeof target === "object", "Invalid target value: must be an object");
      Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      options3 = Object.assign({ nullOverride: true, mergeArrays: true }, options3);
      if (Array.isArray(source)) {
        Assert(Array.isArray(target), "Cannot merge array onto an object");
        if (!options3.mergeArrays) {
          target.length = 0;
        }
        for (let i2 = 0; i2 < source.length; ++i2) {
          target.push(Clone(source[i2], { symbols: options3.symbols }));
        }
        return target;
      }
      const keys = Utils.keys(source, options3);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (target[key] === value) {
            continue;
          }
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
          value instanceof RegExp) {
            target[key] = Clone(value, { symbols: options3.symbols });
          } else {
            internals.merge(target[key], value, options3);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (options3.nullOverride) {
            target[key] = value;
          }
        }
      }
      return target;
    };
  }
});
var require_applyToDefaults = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/applyToDefaults.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Merge = require_merge();
    var Reach = require_reach();
    var internals = {};
    module2.exports = function(defaults, source, options3 = {}) {
      Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
      Assert(typeof options3 === "object", "Invalid options: must be an object");
      if (!source) {
        return null;
      }
      if (options3.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options3);
      }
      const copy2 = Clone(defaults);
      if (source === true) {
        return copy2;
      }
      const nullOverride = options3.nullOverride !== void 0 ? options3.nullOverride : false;
      return Merge(copy2, source, { nullOverride, mergeArrays: false });
    };
    internals.applyToDefaultsWithShallow = function(defaults, source, options3) {
      const keys = options3.shallow;
      Assert(Array.isArray(keys), "Invalid keys");
      const seen = /* @__PURE__ */ new Map();
      const merge3 = source === true ? null : /* @__PURE__ */ new Set();
      for (let key of keys) {
        key = Array.isArray(key) ? key : key.split(".");
        const ref = Reach(defaults, key);
        if (ref && typeof ref === "object") {
          seen.set(ref, merge3 && Reach(source, key) || ref);
        } else if (merge3) {
          merge3.add(key);
        }
      }
      const copy2 = Clone(defaults, {}, seen);
      if (!merge3) {
        return copy2;
      }
      for (const key of merge3) {
        internals.reachCopy(copy2, source, key);
      }
      const nullOverride = options3.nullOverride !== void 0 ? options3.nullOverride : false;
      return Merge(copy2, source, { nullOverride, mergeArrays: false });
    };
    internals.reachCopy = function(dst, src4, path12) {
      for (const segment of path12) {
        if (!(segment in src4)) {
          return;
        }
        const val = src4[segment];
        if (typeof val !== "object" || val === null) {
          return;
        }
        src4 = val;
      }
      const value = src4;
      let ref = dst;
      for (let i2 = 0; i2 < path12.length - 1; ++i2) {
        const segment = path12[i2];
        if (typeof ref[segment] !== "object") {
          ref[segment] = {};
        }
        ref = ref[segment];
      }
      ref[path12[path12.length - 1]] = value;
    };
  }
});
var require_bench = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/bench.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = internals.Bench = class {
      constructor() {
        this.ts = 0;
        this.reset();
      }
      reset() {
        this.ts = internals.Bench.now();
      }
      elapsed() {
        return internals.Bench.now() - this.ts;
      }
      static now() {
        const ts = process.hrtime();
        return ts[0] * 1e3 + ts[1] / 1e6;
      }
    };
  }
});
var require_ignore = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/ignore.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});
var require_block = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/block.js"(exports2, module2) {
    "use strict";
    var Ignore = require_ignore();
    module2.exports = function() {
      return new Promise(Ignore);
    };
  }
});
var require_deepEqual = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/deepEqual.js"(exports2, module2) {
    "use strict";
    var Types = require_types();
    var internals = {
      mismatched: null
    };
    module2.exports = function(obj, ref, options3) {
      options3 = Object.assign({ prototype: true }, options3);
      return !!internals.isDeepEqual(obj, ref, options3, []);
    };
    internals.isDeepEqual = function(obj, ref, options3, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (obj === null || ref === null) {
        return false;
      }
      if (type === "function") {
        if (!options3.deepFunction || obj.toString() !== ref.toString()) {
          return false;
        }
      } else if (type !== "object") {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options3.prototype);
      switch (instanceType) {
        case Types.buffer:
          return Buffer && Buffer.prototype.equals.call(obj, ref);
        // $lab:coverage:ignore$
        case Types.promise:
          return obj === ref;
        case Types.regex:
        case Types.url:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i2 = seen.length - 1; i2 >= 0; --i2) {
        if (seen[i2].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options3, seen);
      } finally {
        seen.pop();
      }
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return Types.getInternalProto(obj);
      }
      const type = Types.getInternalProto(obj);
      if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options3, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === Types.array) {
        if (options3.part) {
          for (const objValue of obj) {
            for (const refValue of ref) {
              if (isDeepEqual(objValue, refValue, options3, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i2 = 0; i2 < obj.length; ++i2) {
            if (!isDeepEqual(obj[i2], ref[i2], options3, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(Set.prototype.values.call(ref));
          for (const objEntry of Set.prototype.values.call(obj)) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options3, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of Map.prototype.entries.call(obj)) {
          if (value === void 0 && !Map.prototype.has.call(ref, key)) {
            return false;
          }
          if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options3, seen)) {
            return false;
          }
        }
      } else if (instanceType === Types.error) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options3, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options3.part && objKeys.length !== keys(ref).length && !options3.skip) {
        return false;
      }
      let skipped = 0;
      for (const key of objKeys) {
        if (options3.skip && options3.skip.includes(key)) {
          if (ref[key] === void 0) {
            ++skipped;
          }
          continue;
        }
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options3, seen)) {
          return false;
        }
      }
      if (!options3.part && objKeys.length - skipped !== keys(ref).length) {
        return false;
      }
      if (options3.symbols !== false) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (const key of objSymbols) {
          if (!options3.skip?.includes(key)) {
            if (hasOwnEnumerableProperty(obj, key)) {
              if (!hasOwnEnumerableProperty(ref, key)) {
                return false;
              }
              if (!isDeepEqual(obj[key], ref[key], options3, seen)) {
                return false;
              }
            } else if (hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
  }
});
var require_escapeRegex = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeRegex.js"(exports2, module2) {
    "use strict";
    module2.exports = function(string3) {
      return string3.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }
});
var require_contain = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/contain.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var EscapeRegex = require_escapeRegex();
    var Utils = require_utils();
    var internals = {};
    module2.exports = function(ref, values, options3 = {}) {
      if (typeof values !== "object") {
        values = [values];
      }
      Assert(!Array.isArray(values) || values.length, "Values array cannot be empty");
      if (typeof ref === "string") {
        return internals.string(ref, values, options3);
      }
      if (Array.isArray(ref)) {
        return internals.array(ref, values, options3);
      }
      Assert(typeof ref === "object", "Reference must be string or an object");
      return internals.object(ref, values, options3);
    };
    internals.array = function(ref, values, options3) {
      if (!Array.isArray(values)) {
        values = [values];
      }
      if (!ref.length) {
        return false;
      }
      if (options3.only && options3.once && ref.length !== values.length) {
        return false;
      }
      let compare;
      const map = /* @__PURE__ */ new Map();
      for (const value of values) {
        if (!options3.deep || !value || typeof value !== "object") {
          const existing = map.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map.set(value, { allowed: 1, hits: 0 });
          }
        } else {
          compare = compare ?? internals.compare(options3);
          let found = false;
          for (const [key, existing] of map.entries()) {
            if (compare(key, value)) {
              ++existing.allowed;
              found = true;
              break;
            }
          }
          if (!found) {
            map.set(value, { allowed: 1, hits: 0 });
          }
        }
      }
      let hits = 0;
      for (const item of ref) {
        let match;
        if (!options3.deep || !item || typeof item !== "object") {
          match = map.get(item);
        } else {
          compare = compare ?? internals.compare(options3);
          for (const [key, existing] of map.entries()) {
            if (compare(key, item)) {
              match = existing;
              break;
            }
          }
        }
        if (match) {
          ++match.hits;
          ++hits;
          if (options3.once && match.hits > match.allowed) {
            return false;
          }
        }
      }
      if (options3.only && hits !== ref.length) {
        return false;
      }
      for (const match of map.values()) {
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options3.part) {
          return false;
        }
      }
      return !!hits;
    };
    internals.object = function(ref, values, options3) {
      Assert(options3.once === void 0, "Cannot use option once with object");
      const keys = Utils.keys(ref, options3);
      if (!keys.length) {
        return false;
      }
      if (Array.isArray(values)) {
        return internals.array(keys, values, options3);
      }
      const symbols2 = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
      const targets = [...Object.keys(values), ...symbols2];
      const compare = internals.compare(options3);
      const set = new Set(targets);
      for (const key of keys) {
        if (!set.has(key)) {
          if (options3.only) {
            return false;
          }
          continue;
        }
        if (!compare(values[key], ref[key])) {
          return false;
        }
        set.delete(key);
      }
      if (set.size) {
        return options3.part ? set.size < targets.length : false;
      }
      return true;
    };
    internals.string = function(ref, values, options3) {
      if (ref === "") {
        return values.length === 1 && values[0] === "" || // '' contains ''
        !options3.once && !values.some((v2) => v2 !== "");
      }
      const map = /* @__PURE__ */ new Map();
      const patterns = [];
      for (const value of values) {
        Assert(typeof value === "string", "Cannot compare string reference to non-string value");
        if (value) {
          const existing = map.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map.set(value, { allowed: 1, hits: 0 });
            patterns.push(EscapeRegex(value));
          }
        } else if (options3.once || options3.only) {
          return false;
        }
      }
      if (!patterns.length) {
        return true;
      }
      const regex = new RegExp(`(${patterns.join("|")})`, "g");
      const leftovers = ref.replace(regex, ($0, $1) => {
        ++map.get($1).hits;
        return "";
      });
      if (options3.only && leftovers) {
        return false;
      }
      let any = false;
      for (const match of map.values()) {
        if (match.hits) {
          any = true;
        }
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options3.part) {
          return false;
        }
        if (options3.once) {
          return false;
        }
      }
      return !!any;
    };
    internals.compare = function(options3) {
      if (!options3.deep) {
        return internals.shallow;
      }
      const hasOnly = options3.only !== void 0;
      const hasPart = options3.part !== void 0;
      const flags8 = {
        prototype: hasOnly ? options3.only : hasPart ? !options3.part : false,
        part: hasOnly ? !options3.only : hasPart ? options3.part : false
      };
      return (a, b) => DeepEqual(a, b, flags8);
    };
    internals.shallow = function(a, b) {
      return a === b;
    };
  }
});
var require_escapeHeaderAttribute = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    module2.exports = function(attribute) {
      Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
      return attribute.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
    };
  }
});
var require_escapeHtml = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHtml.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i2 = 0; i2 < input.length; ++i2) {
        const charCode = input.charCodeAt(i2);
        if (internals.isSafe(charCode)) {
          escaped += input[i2];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml.get(charCode);
      if (namedEscape) {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = charCode.toString(16).padStart(2, "0");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return internals.safeCharCodes.has(charCode);
    };
    internals.namedHtml = /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [34, "&quot;"],
      [160, "&nbsp;"],
      [162, "&cent;"],
      [163, "&pound;"],
      [164, "&curren;"],
      [169, "&copy;"],
      [174, "&reg;"]
    ]);
    internals.safeCharCodes = function() {
      const safe = /* @__PURE__ */ new Set();
      for (let i2 = 32; i2 < 123; ++i2) {
        if (i2 >= 97 || // a-z
        i2 >= 65 && i2 <= 90 || // A-Z
        i2 >= 48 && i2 <= 57 || // 0-9
        i2 === 32 || // space
        i2 === 46 || // .
        i2 === 44 || // ,
        i2 === 45 || // -
        i2 === 58 || // :
        i2 === 95) {
          safe.add(i2);
        }
      }
      return safe;
    }();
  }
});
var require_escapeJson = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeJson.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(input) {
      if (!input) {
        return "";
      }
      return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
    };
    internals.escape = function(char) {
      return internals.replacements.get(char);
    };
    internals.replacements = /* @__PURE__ */ new Map([
      ["<", "\\u003c"],
      [">", "\\u003e"],
      ["&", "\\u0026"],
      ["\u2028", "\\u2028"],
      ["\u2029", "\\u2029"]
    ]);
  }
});
var require_flatten = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/flatten.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = internals.flatten = function(array2, target) {
      const result = target || [];
      for (const entry of array2) {
        if (Array.isArray(entry)) {
          internals.flatten(entry, result);
        } else {
          result.push(entry);
        }
      }
      return result;
    };
  }
});
var require_intersect = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/intersect.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(array1, array2, options3 = {}) {
      if (!array1 || !array2) {
        return options3.first ? null : [];
      }
      const common2 = [];
      const hash32 = Array.isArray(array1) ? new Set(array1) : array1;
      const found = /* @__PURE__ */ new Set();
      for (const value of array2) {
        if (internals.has(hash32, value) && !found.has(value)) {
          if (options3.first) {
            return value;
          }
          common2.push(value);
          found.add(value);
        }
      }
      return options3.first ? null : common2;
    };
    internals.has = function(ref, key) {
      if (typeof ref.has === "function") {
        return ref.has(key);
      }
      return ref[key] !== void 0;
    };
  }
});
var require_isPromise = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/isPromise.js"(exports2, module2) {
    "use strict";
    module2.exports = function(promise) {
      return typeof promise?.then === "function";
    };
  }
});
var require_once = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/once.js"(exports2, module2) {
    "use strict";
    var internals = {
      wrapped: Symbol("wrapped")
    };
    module2.exports = function(method) {
      if (method[internals.wrapped]) {
        return method;
      }
      let once = false;
      const wrappedFn = function(...args) {
        if (!once) {
          once = true;
          method(...args);
        }
      };
      wrappedFn[internals.wrapped] = true;
      return wrappedFn;
    };
  }
});
var require_reachTemplate = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reachTemplate.js"(exports2, module2) {
    "use strict";
    var Reach = require_reach();
    module2.exports = function(obj, template, options3) {
      return template.replace(/{([^{}]+)}/g, ($0, chain) => {
        const value = Reach(obj, chain, options3);
        return value ?? "";
      });
    };
  }
});
var require_wait = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/wait.js"(exports2, module2) {
    "use strict";
    var internals = {
      maxTimer: 2 ** 31 - 1
      // ~25 days
    };
    module2.exports = function(timeout, returnValue, options3) {
      if (typeof timeout === "bigint") {
        timeout = Number(timeout);
      }
      if (timeout >= Number.MAX_SAFE_INTEGER) {
        timeout = Infinity;
      }
      if (typeof timeout !== "number" && timeout !== void 0) {
        throw new TypeError("Timeout must be a number or bigint");
      }
      return new Promise((resolve8) => {
        const _setTimeout = options3 ? options3.setTimeout : setTimeout;
        const activate = () => {
          const time3 = Math.min(timeout, internals.maxTimer);
          timeout -= time3;
          _setTimeout(() => timeout > 0 ? activate() : resolve8(returnValue), time3);
        };
        if (timeout !== Infinity) {
          activate();
        }
      });
    };
  }
});
var require_lib = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/index.js"(exports2) {
    "use strict";
    exports2.applyToDefaults = require_applyToDefaults();
    exports2.assert = require_assert();
    exports2.AssertError = require_assertError();
    exports2.Bench = require_bench();
    exports2.block = require_block();
    exports2.clone = require_clone();
    exports2.contain = require_contain();
    exports2.deepEqual = require_deepEqual();
    exports2.escapeHeaderAttribute = require_escapeHeaderAttribute();
    exports2.escapeHtml = require_escapeHtml();
    exports2.escapeJson = require_escapeJson();
    exports2.escapeRegex = require_escapeRegex();
    exports2.flatten = require_flatten();
    exports2.ignore = require_ignore();
    exports2.intersect = require_intersect();
    exports2.isPromise = require_isPromise();
    exports2.merge = require_merge();
    exports2.once = require_once();
    exports2.reach = require_reach();
    exports2.reachTemplate = require_reachTemplate();
    exports2.stringify = require_stringify();
    exports2.wait = require_wait();
  }
});
var require_package = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/package.json"(exports2, module2) {
    module2.exports = {
      name: "@hapi/validate",
      description: "Object schema validation",
      version: "2.0.1",
      repository: "git://github.com/hapijs/validate",
      main: "lib/index.js",
      files: [
        "lib/**/*"
      ],
      eslintConfig: {
        extends: [
          "plugin:@hapi/module"
        ]
      },
      dependencies: {
        "@hapi/hoek": "^11.0.2",
        "@hapi/topo": "^6.0.1"
      },
      devDependencies: {
        "@hapi/bourne": "^3.0.0",
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "*",
        "@hapi/lab": "^25.1.2"
      },
      scripts: {
        test: "lab -t 100 -a @hapi/code -L",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});
var require_schemas = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/schemas.js"(exports2) {
    "use strict";
    var Joi2 = require_lib3();
    var internals = {};
    internals.wrap = Joi2.string().min(1).max(2).allow(false);
    exports2.preferences = Joi2.object({
      allowUnknown: Joi2.boolean(),
      abortEarly: Joi2.boolean(),
      context: Joi2.object(),
      convert: Joi2.boolean(),
      dateFormat: Joi2.valid("date", "iso", "string", "time", "utc"),
      errors: {
        escapeHtml: Joi2.boolean(),
        label: Joi2.valid("path", "key", false),
        language: [
          Joi2.string(),
          Joi2.object().ref()
        ],
        render: Joi2.boolean(),
        stack: Joi2.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap
        }
      },
      messages: Joi2.object(),
      noDefaults: Joi2.boolean(),
      nonEnumerables: Joi2.boolean(),
      presence: Joi2.valid("required", "optional", "forbidden"),
      skipFunctions: Joi2.boolean(),
      stripUnknown: Joi2.object({
        arrays: Joi2.boolean(),
        objects: Joi2.boolean()
      }).or("arrays", "objects").allow(true, false)
    }).strict();
  }
});
var require_ref = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/ref.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      symbol: Symbol("ref"),
      // Used to internally identify references (shared with other joi versions)
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports2.create = function(key, options3 = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options3, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "separator"]);
      Assert(!options3.prefix || typeof options3.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options3);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options3.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref);
    };
    exports2.in = function(key, options3 = {}) {
      return exports2.create(key, Object.assign({}, options3, { in: true }));
    };
    exports2.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options3) {
        Assert(typeof options3 === "object", "Invalid reference construction");
        Common.assertOptions(options3, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "separator",
          "type",
          // Copied
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        Assert([false, void 0].includes(options3.separator) || typeof options3.separator === "string" && options3.separator.length === 1, "Invalid separator");
        Assert(!options3.adjust || typeof options3.adjust === "function", "options.adjust must be a function");
        Assert(!options3.map || Array.isArray(options3.map), "options.map must be an array");
        Assert(!options3.map || !options3.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options3);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local, options3 = {}) {
        Assert(!this.in || options3.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options3);
        }
        if (this.type === "local") {
          return this._resolve(local, state, options3);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options3);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options3);
        }
        Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options3);
      }
      _resolve(target, state, options3) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options3.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [...state.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return { key: key.slice(local.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i2 = 2;
      while (key[i2] === separator) {
        ++i2;
      }
      return [i2 - 1, i2];
    };
    exports2.toSibling = 0;
    exports2.toParent = 1;
    exports2.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports2.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports2.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
      }
      clone() {
        const copy2 = new exports2.Manager();
        copy2.refs = Clone(this.refs);
        return copy2;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});
var require_template = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/template.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var EscapeHtml = require_escapeHtml();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module2.exports = exports2 = internals.Template = class {
      constructor(source, options3) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        this._settings = Clone(options3);
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
          processed.push(dynamic);
          const rest2 = part.slice(end + ender.length);
          if (rest2) {
            processed.push(internals.decode(rest2));
          }
        }
        this._template = processed;
      }
      static date(date3, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date3);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      render(value, state, prefs, local, options3 = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = part.ref.resolve(value, state, prefs, local, options3);
            const string3 = internals.stringify(rendered, prefs, options3.errors);
            const result = part.raw || options3.errors?.escapeHtml === false ? string3 : EscapeHtml(string3);
            parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const ref = Ref.create(content, this._settings);
        return { ref, raw, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string3) {
      return string3.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string3) {
      return string3.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string3) {
      const parts = [];
      let current = "";
      for (let i2 = 0; i2 < string3.length; ++i2) {
        const char = string3[i2];
        if (char === "{") {
          let next = "";
          while (i2 + 1 < string3.length && string3[i2 + 1] === "{") {
            next += "{";
            ++i2;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, prefs, options3) {
      const type = typeof value;
      if (value === null) {
        return "null";
      }
      if (value === void 0) {
        return "";
      }
      if (type === "string") {
        return value;
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      let partial2 = "";
      for (const item of value) {
        partial2 = partial2 + (partial2.length ? ", " : "") + internals.stringify(item, prefs, options3);
      }
      return internals.wrap(partial2, prefs.errors.wrap.array);
    };
  }
});
var require_messages = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/messages.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Template = require_template();
    exports2.compile = function(messages, target) {
      if (typeof messages === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        Assert(!target, "Cannot set single message template");
        return messages;
      }
      Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code2 in messages) {
        const message = messages[code2];
        if (code2 === "root" || Template.isTemplate(message)) {
          target[code2] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code2] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code2);
        const language = code2;
        target[language] = target[language] || {};
        for (code2 in message) {
          const localized = message[code2];
          if (code2 === "root" || Template.isTemplate(localized)) {
            target[language][code2] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code2, "in", language);
          target[language][code2] = new Template(localized);
        }
      }
      return target;
    };
    exports2.merge = function(base4, extended) {
      if (!base4) {
        return exports2.compile(extended);
      }
      if (!extended) {
        return base4;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base4);
      for (let code2 in extended) {
        const message = extended[code2];
        if (code2 === "root" || Template.isTemplate(message)) {
          target[code2] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code2] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code2);
        const language = code2;
        target[language] = target[language] || {};
        for (code2 in message) {
          const localized = message[code2];
          if (code2 === "root" || Template.isTemplate(localized)) {
            target[language][code2] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code2, "in", language);
          target[language][code2] = new Template(localized);
        }
      }
      return target;
    };
  }
});
var require_common = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/common.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var AssertError = require_assertError();
    var Pkg = require_package();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports2.version = Pkg.version;
    exports2.defaults = {
      abortEarly: true,
      allowUnknown: false,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false
    };
    exports2.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      // Used to internally identify any-based types (shared with other joi versions)
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports2.assertOptions = function(options3, keys, name = "Options") {
      Assert(options3 && typeof options3 === "object" && !Array.isArray(options3), "Options must be of type object");
      const unknownKeys = Object.keys(options3).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports2.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports2.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports2.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports2.isIsoDate = function(date3) {
      return internals.isoDate.test(date3);
    };
    exports2.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports2.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports2.symbols.ref] || obj[exports2.symbols.template];
    };
    exports2.isSchema = function(schema, options3 = {}) {
      const any = schema && schema[exports2.symbols.any];
      if (!any) {
        return false;
      }
      return true;
    };
    exports2.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports2.preferences = function(target, source) {
      Messages = Messages || require_messages();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports2.symbols.prefs];
      return merged;
    };
    exports2.tryWithPath = function(fn, key, options3 = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options3.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports2.validateArg = function(value, label, { assert: assert22, message }) {
      if (exports2.isSchema(assert22)) {
        const result = assert22.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert22(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports2.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});
var require_compile = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/compile.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports2.schema = function(Joi2, config2, options3 = {}) {
      Common.assertOptions(options3, ["appendPath", "override"]);
      try {
        return internals.schema(Joi2, config2, options3);
      } catch (err) {
        if (options3.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi2, config2, options3) {
      Assert(config2 !== void 0, "Invalid undefined schema");
      if (Array.isArray(config2)) {
        Assert(config2.length, "Invalid empty array schema");
        if (config2.length === 1) {
          config2 = config2[0];
        }
      }
      const valid = (base4, ...values) => {
        if (options3.override !== false) {
          return base4.valid(Joi2.override, ...values);
        }
        return base4.valid(...values);
      };
      if (internals.simple(config2)) {
        return valid(Joi2, config2);
      }
      if (typeof config2 === "function") {
        return Joi2.custom(config2);
      }
      Assert(typeof config2 === "object", "Invalid schema content:", typeof config2);
      if (Common.isResolvable(config2)) {
        return valid(Joi2, config2);
      }
      if (Common.isSchema(config2)) {
        return config2;
      }
      if (Array.isArray(config2)) {
        for (const item of config2) {
          if (!internals.simple(item)) {
            return Joi2.alternatives().try(...config2);
          }
        }
        return valid(Joi2, ...config2);
      }
      if (config2 instanceof RegExp) {
        return Joi2.string().regex(config2);
      }
      if (config2 instanceof Date) {
        return valid(Joi2.date(), config2);
      }
      Assert(Object.getPrototypeOf(config2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi2.object().keys(config2);
    };
    exports2.ref = function(id, options3) {
      return Ref.isRef(id) ? id : Ref.create(id, options3);
    };
    exports2.compile = function(root, schema) {
      const any = schema && schema[Common.symbols.any];
      if (any) {
        Assert(any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
        return schema;
      }
      return exports2.schema(root, schema, { appendPath: true });
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports2.when = function(schema, condition, options3) {
      if (options3 === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options3 = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options3)) {
        options3 = { switch: options3 };
      }
      Common.assertOptions(options3, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        Assert(options3.is === void 0, '"is" can not be used with a schema condition');
        Assert(options3.not === void 0, '"not" can not be used with a schema condition');
        Assert(options3.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema, { is: condition, then: options3.then, otherwise: options3.otherwise, break: options3.break });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options3.not === void 0 || options3.is === void 0, 'Cannot combine "is" with "not"');
      if (options3.switch === void 0) {
        let rule2 = options3;
        if (options3.not !== void 0) {
          rule2 = { is: options3.not, then: options3.otherwise, otherwise: options3.then, break: options3.break };
        }
        let is = rule2.is !== void 0 ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options3.is !== void 0 && !Ref.isRef(options3.is) && !Common.isSchema(options3.is)) {
          is = is.required();
        }
        return internals.condition(schema, { ref: exports2.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      Assert(Array.isArray(options3.switch), '"switch" must be an array');
      Assert(options3.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options3.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options3.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports2.ref(condition),
        switch: [],
        break: options3.break
      };
      for (let i2 = 0; i2 < options3.switch.length; ++i2) {
        const test = options3.switch[i2];
        const last = i2 === options3.switch.length - 1;
        Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema.$_compile(test.is),
          then: schema.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          Assert(options3.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options3.otherwise !== void 0 ? options3.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});
var require_annotate = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/annotate.js"(exports2) {
    "use strict";
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports2.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = Clone(this._original);
      for (let i2 = this.details.length - 1; i2 >= 0; --i2) {
        const pos = i2 + 1;
        const error = this.details[i2];
        const path12 = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path12[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path12.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i2 = 0; i2 < this.details.length; ++i2) {
        const pos = i2 + 1;
        message = `${message}
[${pos}] ${this.details[i2].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = (key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i2 = 0; i2 < value.length; ++i2) {
                if (annotations.errors[i2]) {
                  annotated.push(`_$idx$_${annotations.errors[i2].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i2]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});
var require_errors = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/errors.js"(exports2) {
    "use strict";
    var Annotate = require_annotate();
    var Common = require_common();
    var Template = require_template();
    exports2.Report = class {
      constructor(code2, value, local, flags8, messages, state, prefs) {
        this.code = code2;
        this.flags = flags8;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.local = local || {};
        this.local.label = exports2.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code2 = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code2}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages) {
        return exports2.template(this.value, messages, this.code, this.state, this.prefs);
      }
    };
    exports2.path = function(path12) {
      let label = "";
      for (const segment of path12) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports2.template = function(value, messages, code2, state, prefs) {
      if (Template.isTemplate(messages)) {
        return code2 !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang] && messages[lang][code2] !== void 0) {
        return messages[lang][code2];
      }
      return messages[code2];
    };
    exports2.label = function(flags8, state, prefs, messages) {
      if (!prefs.errors.label) {
        return "";
      }
      let path12 = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path12 = state.path.slice(-1);
      }
      const normalized = exports2.path(path12);
      if (normalized) {
        return normalized;
      }
      return exports2.template(null, prefs.messages, "root", state, prefs) || exports2.template(null, messages, "root", state, prefs) || "value";
    };
    exports2.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports2.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports2.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports2.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports2.details = function(errors, options3 = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options3.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v2) => typeof v2 !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [...new Set(messages)];
      }
      return { message: messages.join(". "), details };
    };
    exports2.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports2.ValidationError;
      }
    };
    exports2.ValidationError.prototype.isJoi = true;
    exports2.ValidationError.prototype.name = "ValidationError";
    exports2.ValidationError.prototype.annotate = Annotate.error;
  }
});
var require_extend = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/extend.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    exports2.type = function(from6, options3) {
      const base4 = Object.getPrototypeOf(from6);
      const prototype = Clone(base4);
      const schema = from6._assign(Object.create(prototype));
      const def = Object.assign({}, options3);
      delete def.base;
      prototype._definition = def;
      const parent = base4._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          Assert(schema.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = { method: def.coerce };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
      }
      def.coerce = def.coerce || parent.coerce;
      def.validate = def.validate || parent.validate;
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
          const method = rule.method;
          if (method) {
            Assert(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          Assert(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = { name: arg };
              }
              Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      if (def.overrides) {
        prototype._super = base4;
        schema.$_super = {};
        for (const override in def.overrides) {
          Assert(base4[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base4[override];
          schema.$_super[override] = base4[override].bind(schema);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      def.rebuild = def.rebuild || parent.rebuild;
      return schema;
    };
  }
});
var require_modify = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/modify.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports2.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone2 = new internals.Ids();
        clone2._byId = new Map(this._byId);
        clone2._byKey = new Map(this._byKey);
        clone2._schemaChain = this._schemaChain;
        return clone2;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      reach(path12, behind = []) {
        const current = path12[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path12].join("."));
        const forward = path12.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema, { key } = {}) {
        if (!schema || !Common.isSchema(schema)) {
          return;
        }
        if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema, id });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    exports2.schema = function(schema, options3) {
      let obj;
      for (const name in schema._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema._flags[name], { source: "flags", name }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj._flags[name] = result;
        }
      }
      for (let i2 = 0; i2 < schema._rules.length; ++i2) {
        const rule = schema._rules[i2];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          const clone2 = Object.assign({}, rule);
          clone2.args = result;
          obj._rules[i2] = clone2;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone2);
          }
        }
      }
      for (const name in schema.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options3, _path, _key) {
      const path12 = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone2;
      if (Array.isArray(item)) {
        for (let i2 = 0; i2 < item.length; ++i2) {
          const key = source.name === "keys" && item[i2].key;
          const result = internals.scan(item[i2], source, options3, [i2, ...path12], key);
          if (result !== void 0) {
            clone2 = clone2 || item.slice();
            clone2[i2] = result;
          }
        }
        return clone2;
      }
      if (options3.schema !== false && Common.isSchema(item) || options3.ref !== false && Ref.isRef(item)) {
        const result = options3.each(item, { ...source, path: path12, key: _key });
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options3, [key, ...path12], _key);
        if (result !== void 0) {
          clone2 = clone2 || Object.assign({}, item);
          clone2[key] = result;
        }
      }
      return clone2;
    };
  }
});
var require_state = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/state.js"(exports2, module2) {
    "use strict";
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      value: Symbol("value")
    };
    module2.exports = internals.State = class {
      constructor(path12, ancestors, state) {
        this.path = path12;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
      }
      localize(path12, ancestors = null, schema = null) {
        const state = new internals.State(path12, ancestors, this);
        if (schema && state.schemas) {
          state.schemas = [internals.schemas(schema), ...state.schemas];
        }
        return state;
      }
      nest(schema) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
      }
    };
    internals.schemas = function(schema) {
      if (Common.isSchema(schema)) {
        return { schema };
      }
      return schema;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path12, value, reason) {
        if (!path12.length) {
          return;
        }
        if (reason === "strip" && typeof path12[path12.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i2 = 0; i2 < path12.length; ++i2) {
          const segment = path12[i2];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path12) {
        const node = this.node(path12);
        if (node) {
          return node[internals.value];
        }
      }
      node(path12) {
        if (!this._values) {
          return;
        }
        return Reach(this._values, path12, { iterables: true });
      }
      override(path12, node) {
        if (!this._values) {
          return;
        }
        const parents = path12.slice(0, -1);
        const own = path12[path12.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});
var require_validator = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/validator.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Errors = require_errors();
    var State = require_state();
    var internals = {
      result: Symbol("result")
    };
    exports2.entry = function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      return outcome;
    };
    internals.entry = function(value, schema, prefs) {
      const links = schema._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = { links };
      const schemas = schema._ids._schemaChain ? [{ schema }] : null;
      const state = new State([], [], { mainstay, schemas });
      const result = exports2.validate(value, schema, state, prefs);
      const error = Errors.process(result.errors, value, prefs);
      return { value: result.value, error, mainstay };
    };
    exports2.validate = function(value, schema, state, prefs, overrides = {}) {
      if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
      }
      if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
      }
      const createError = (code2, local, localState) => schema.$_createError(code2, value, local, localState || state, prefs);
      const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        message: (messages, local) => schema.$_createError("custom", value, local, state, prefs, { messages })
      };
      const def = schema._definition;
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty4 = schema._flags.empty;
      if (empty4 && empty4.$_match(internals.trim(value, schema), state.nest(empty4), Common.defaults)) {
        value = void 0;
      }
      const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema.$_createError("any.required", value, null, state, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state, prefs)], helpers);
      }
      const errors = [];
      if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            value = match.value;
          }
          return internals.finalize(value, null, helpers);
        }
        if (schema._flags.only) {
          const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base4 = def.validate(value, helpers);
        if (base4) {
          value = base4.value;
          if (base4.errors) {
            if (!Array.isArray(base4.errors)) {
              errors.push(base4.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base4.errors.length) {
              errors.push(...base4.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema, state } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema._flags.error) {
        if (typeof schema._flags.error === "function") {
          errors = schema._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          for (const error of errors) {
            Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [schema._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        value = defaulted;
      }
      if (schema._flags.cast && value !== void 0) {
        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          value = casted;
        }
      }
      const result = { value, errors: errors.length ? errors : null };
      if (schema._flags.result) {
        result.value = schema._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state.shadow(value, schema._flags.result);
      }
      return result;
    };
    internals.prefs = function(schema, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
        return schema._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema._preferences);
      if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      const source = schema._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});
var require_values = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/values.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Common = require_common();
    var internals = {};
    module2.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [...source._values, ...source._refs]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [...remove._values, ...remove._refs]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return { value };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return { value: found };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (DeepEqual(item, value)) {
              return { value: item };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, { in: true });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return { value: item, ref };
                }
              } else {
                if (DeepEqual(item, value)) {
                  return { value: item, ref };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options3) {
        if (options3 && options3.display) {
          const values = [];
          for (const item of [...this._values, ...this._refs]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
      }
      concat(source) {
        Assert(!source._override, "Cannot concat override set of values");
        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from6) {
      const map = /* @__PURE__ */ new Map();
      if (from6) {
        for (const value of from6) {
          if (typeof value === "string") {
            map.set(value.toLowerCase(), value);
          }
        }
      }
      return map;
    };
  }
});
var require_base = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/base.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var DeepEqual = require_deepEqual();
    var Merge = require_merge();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Messages = require_messages();
    var Modify = require_modify();
    var Ref = require_ref();
    var Validator = require_validator();
    var Values = require_values();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          // Runtime state (not cloned)
          whens: {}
          // Runtime cache of generated whens
        };
      }
      // Rules
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      cast(to) {
        Assert(to === false || typeof to === "string", "Invalid to value");
        Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options3) {
        return this._default("default", value, options3);
      }
      empty(schema) {
        const obj = this.clone();
        if (schema !== void 0) {
          schema = obj.$_compile(schema, { override: false });
        }
        return obj.$_setFlag("empty", schema, { clone: false });
      }
      error(err) {
        Assert(err, "Missing error");
        Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      failover(value, options3) {
        return this._default("failover", value, options3);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        Assert(typeof id === "string", "id must be a non-empty string");
        Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      only(mode = true) {
        Assert(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        Assert(prefs, "Missing preferences");
        Assert(prefs.context === void 0, "Cannot override context");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled2 = true) {
        return this.$_setFlag("result", enabled2 ? "raw" : void 0);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled2) {
        const obj = this.clone();
        const convert = enabled2 === void 0 ? false : !enabled2;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
      }
      strip(enabled2 = true) {
        return this.$_setFlag("result", enabled2 ? "strip" : void 0);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, { clone: false });
        return obj;
      }
      when(condition, options3) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options3);
        if (!["any", "link"].includes(obj.type)) {
          const conditions = when.is ? [when] : when.switch;
          for (const item of conditions) {
            Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then?.type);
            Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise?.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      // Helpers
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags8 = Object.assign({}, source._flags);
          delete flags8.empty;
          Merge(obj._flags, flags8);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags8 = Object.assign({}, source._flags);
          delete flags8.empty;
          Merge(obj._flags, flags8);
        } else {
          Merge(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        return obj.$_mutateRebuild();
      }
      validate(value, options3) {
        return Validator.entry(value, this, options3);
      }
      validateAsync(value, options3) {
        const result = this.validate(value, options3);
        if (result.error) {
          throw result.error;
        }
        return result.value;
      }
      // Extensions
      $_addRule(options3) {
        if (typeof options3 === "string") {
          options3 = { name: options3 };
        }
        Assert(options3 && typeof options3 === "object", "Invalid options");
        Assert(options3.name && typeof options3.name === "string", "Invalid rule name");
        for (const key in options3) {
          Assert(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options3);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        Assert(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error = Common.validateArg(arg, key, resolver);
                  Assert(!error, error, "or reference");
                }
              }
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name);
          obj._singleRules.set(rule.name, rule);
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema, options3) {
        return Compile.schema(this.$_root, schema, options3);
      }
      $_createError(code2, value, local, state, prefs, options3 = {}) {
        const flags8 = options3.flags !== false ? this._flags : {};
        const messages = options3.messages ? Messages.merge(this._definition.messages, options3.messages) : this._definition.messages;
        return new Errors.Report(code2, value, local, flags8, messages, state, prefs);
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options3) {
        Common.assertOptions(options3, ["each", "once", "ref", "schema"]);
        return Modify.schema(this, options3) || this;
      }
      $_mutateRebuild() {
        this._refs.reset();
        this._ids.reset();
        const each = (item, { source, name, path: path12, key }) => {
          const family = this._definition[source][name]?.register;
          if (family !== false) {
            this.$_mutateRegister(item, { family, key });
          }
        };
        this.$_modify({ each });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        return this;
      }
      $_mutateRegister(schema, { family, key } = {}) {
        this._refs.register(schema, family);
        this._ids.register(schema, { key });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path12) {
        return this._ids.reach(path12);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options3 = {}) {
        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
          value = void 0;
        }
        if (DeepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options3.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      // Internals
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids?.clone();
        target._invalids = this._invalids?.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _default(flag, value, options3 = {}) {
        Common.assertOptions(options3, "literal");
        Assert(value !== void 0, "Missing", flag, "value");
        Assert(typeof value === "function" || !options3.literal, "Only function value supports literal option");
        if (typeof value === "function" && options3.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _extend(options3) {
        Assert(!options3.base, "Cannot extend type with another base");
        return Extend.type(this, options3);
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return { schema: this };
        }
        const whens = [];
        const ids = [];
        for (let i2 = 0; i2 < this.$_terms.whens.length; ++i2) {
          const when = this.$_terms.whens[i2];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i2}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [when] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i2}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        if (!id) {
          return { schema: this };
        }
        if (this.$_temp.whens[id]) {
          return { schema: this.$_temp.whens[id], id };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
      }
      _ruleRemove(name) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        this._singleRules.delete(name);
        const filtered = [];
        for (let i2 = 0; i2 < this._rules.length; ++i2) {
          const test = this._rules[i2];
          if (test.name === name) {
            continue;
          }
          filtered.push(test);
        }
        this._rules = filtered;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          Assert(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module2.exports = new internals.Base();
  }
});
var require_any = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/any.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Base = require_base();
    var Common = require_common();
    module2.exports = Base._extend({
      type: "any",
      flags: {
        only: { default: false }
      },
      terms: {
        alterations: { init: null },
        examples: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
      },
      rules: {
        custom: {
          method(method, description) {
            Assert(typeof method === "function", "Method must be a function");
            Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({ name: "custom", args: { method, description } });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", { error: err });
            }
          },
          args: ["method", "description"],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({ messages });
          }
        },
        shared: {
          method(schema) {
            Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema);
            obj.$_mutateRegister(schema);
            return obj;
          }
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": "{{#label}} must be one of {{#valids}}",
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});
var require_alternatives = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/alternatives.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {};
    module2.exports = Any._extend({
      type: "alternatives",
      flags: {
        match: { default: "any" }
        // 'any', 'one', 'all'
      },
      terms: {
        matches: { init: [], register: Ref.toSibling }
      },
      args(schema, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema.try(...schemas[0]);
          }
        }
        return schema.try(...schemas);
      },
      validate(value, helpers) {
        const { schema, error, state, prefs } = helpers;
        if (schema._flags.match) {
          let hits = 0;
          let matched;
          for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
            const item = schema.$_terms.matches[i2];
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              ++hits;
              matched = result.value;
            } else {
              localState.restore();
            }
          }
          if (!hits) {
            return { errors: error("alternatives.any") };
          }
          if (schema._flags.match === "one") {
            return hits === 1 ? { value: matched } : { errors: error("alternatives.one") };
          }
          return hits === schema.$_terms.matches.length ? { value } : { errors: error("alternatives.all") };
        }
        const errors = [];
        for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
          const item = schema.$_terms.matches[i2];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              return result;
            }
            localState.restore();
            errors.push({ schema: item.schema, reports: result.errors });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [item] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i2}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options3) {
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            Assert(options3.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options3);
            const conditions = match.is ? [match] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, { clone: false });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            Assert(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema of schemas) {
              obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      rebuild(schema) {
        const each = (item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema.$_setFlag("_arrayItems", true, { clone: false });
          }
        };
        schema.$_modify({ each });
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error, state }) {
      if (!failures.length) {
        return { errors: error("alternatives.any") };
      }
      if (failures.length === 1) {
        return { errors: failures[0].reports };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({ type: schema.type, report });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code2] = report.code.split(".");
        if (code2 !== "base") {
          complex.push({ type: schema.type, report });
          continue;
        }
        valids.add(type);
      }
      if (!complex.length) {
        return { errors: error("alternatives.types", { types: [...valids] }) };
      }
      if (complex.length === 1) {
        return { errors: complex[0].report };
      }
      return internals.unmatched(failures, error);
    };
    internals.unmatched = function(failures, error) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
    };
  }
});
var require_array = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/array.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Reach = require_reach();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var internals = {};
    module2.exports = Any._extend({
      type: "array",
      flags: {
        single: { default: false },
        sparse: { default: false }
      },
      terms: {
        items: { init: [] },
        ordered: { init: [] },
        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
      },
      coerce: {
        from: "object",
        method(value, { schema, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema, error }) {
        if (!Array.isArray(value)) {
          if (schema._flags.single) {
            const single = [value];
            single[Common.symbols.arraySingle] = true;
            return { value: single };
          }
          return { errors: error("array.base") };
        }
        if (!schema.$_getRule("items")) {
          return;
        }
        return { value: value.slice() };
      },
      rules: {
        has: {
          method(schema) {
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "has", args: { schema } });
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { state, prefs, error }, { schema: has2 }) {
            const ancestors = [value, ...state.ancestors];
            for (let i2 = 0; i2 < value.length; ++i2) {
              const localState = state.localize([...state.path, i2], ancestors, has2);
              if (has2.$_match(value[i2], localState, prefs)) {
                return value;
              }
            }
            return error("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, { append: true });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema, error, state, prefs, errorsArray }) {
            const requireds = schema.$_terms._requireds.slice();
            const ordereds = schema.$_terms.ordered.slice();
            const inclusions = [...schema.$_terms._inclusions, ...requireds];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i2 = 0; i2 < il; ++i2) {
              const item = value[i2];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i2 : new Number(i2);
              const path12 = [...state.path, key];
              if (!schema._flags.sparse && item === void 0) {
                errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [value, ...state.ancestors];
              for (const exclusion of schema.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path12, ancestors, exclusion), prefs, { presence: "ignore" })) {
                  continue;
                }
                errors.push(error("array.excludes", { pos: i2, value: item }, state.localize(path12)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path12, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i2] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema.$_terms.items.length) {
                  errors.push(error("array.orderedLength", { pos: i2, limit: schema.$_terms.ordered.length }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path12, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  value[i2] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema._flags.sparse && res.value === void 0) {
                    errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path12, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                      errored = true;
                    } else {
                      value[i2] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i2);
                    --i2;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms._inclusions.length && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i2);
                  --i2;
                  --il;
                  continue;
                }
                errors.push(error("array.includes", { pos: i2, value: item }, state.localize(path12)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
            }
            return errors.length ? errors : value;
          },
          priority: true
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, { append: true });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled2) {
            const value = enabled2 === void 0 ? true : !!enabled2;
            Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["by", "order"]);
            const settings = {
              order: options3.order || "ascending"
            };
            if (options3.by) {
              settings.by = Compile.ref(options3.by, { ancestor: 0 });
              Assert(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({ name: "sort", args: { options: settings } });
          },
          validate(value, { error, state, prefs, schema }, { options: options3 }) {
            const { value: sorted, errors } = internals.sort(schema, value, options3, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i2 = 0; i2 < value.length; ++i2) {
              if (value[i2] !== sorted[i2]) {
                return error("array.sort", { order: options3.order, by: options3.by ? options3.by.key : "value" });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled2) {
            const value = enabled2 === void 0 ? true : !!enabled2;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, { clone: false });
          }
        },
        unique: {
          method(comparator, options3 = {}) {
            Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options3, ["ignoreUndefined", "separator"]);
            const rule = { name: "unique", args: { options: options3, comparator } };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options3.separator, ".");
                rule.path = separator ? comparator.split(separator) : [comparator];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error, schema }, { comparator: raw, options: options3 }, { comparator, path: path12 }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || DeepEqual;
            const ignoreUndefined = options3.ignoreUndefined;
            for (let i2 = 0; i2 < value.length; ++i2) {
              const item = path12 ? Reach(value[i2], path12) : value[i2];
              const records = comparator ? found.custom : found[typeof item];
              Assert(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([...state.path, i2], [value, ...state.ancestors]);
                    const context = {
                      pos: i2,
                      value: value[i2],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path12) {
                      context.path = raw;
                    }
                    return error("array.unique", context, localState);
                  }
                }
                records.set(item, i2);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i2,
                    value: value[i2],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path12) {
                    context.path = raw;
                  }
                  const localState = state.localize([...state.path, i2], [value, ...state.ancestors]);
                  return error("array.unique", context, localState);
                }
                records[item] = i2;
              }
            }
            return value;
          },
          args: ["comparator", "options"],
          multi: true
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema) {
        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];
        for (const type of schema.$_terms.items) {
          internals.validateSingle(type, schema);
          if (type._flags.presence === "required") {
            schema.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema.$_terms._exclusions.push(type);
          } else {
            schema.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema.$_terms.ordered) {
          internals.validateSingle(type, schema);
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
      let unknownMisses = 0;
      for (let i2 = 0; i2 < requireds.length; ++i2) {
        ++unknownMisses;
      }
      errors.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
    };
    internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fastSplice = function(arr, i2) {
      let pos = i2;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, { clone: false });
      }
    };
    internals.sort = function(schema, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = (a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema.$_createError("array.sort.unsupported", value, { type }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      };
      try {
        return { value: value.slice().sort(sort) };
      } catch (err) {
        return { errors: err };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});
var require_boolean = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/boolean.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Values = require_values();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module2.exports = Any._extend({
      type: "boolean",
      flags: {
        sensitive: { default: false }
      },
      terms: {
        falsy: {
          init: null
        },
        truthy: {
          init: null
        }
      },
      coerce(value, { schema }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema.$_terms.truthy?.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy?.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }
        return { value };
      },
      validate(value, { error }) {
        if (typeof value !== "boolean") {
          return { value, errors: error("boolean.base") };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              Assert(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              Assert(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled2 = true) {
            return this.$_setFlag("sensitive", enabled2);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});
var require_date = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/date.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Template = require_template();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module2.exports = Any._extend({
      type: "date",
      coerce: {
        from: ["number", "string"],
        method(value, { schema }) {
          return { value: internals.parse(value, schema._flags.format) || value };
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format32 = schema._flags.format;
        if (!prefs.convert || !format32 || typeof value !== "string") {
          return { value, errors: error("date.base") };
        }
        return { value, errors: error("date.format", { format: format32 }) };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date: date3 }, { name, operator, args }) {
            const to = date3 === "now" ? Date.now() : date3.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, { limit: args.date, value });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date3) => {
                return date3 === "now" ? date3 : internals.parse(date3);
              },
              assert: (date3) => date3 !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format32) {
            Assert(["iso", "javascript", "unix"].includes(format32), "Unknown date format", format32);
            return this.$_setFlag("format", format32);
          }
        },
        greater: {
          method(date3) {
            return this.$_addRule({ name: "greater", method: "compare", args: { date: date3 }, operator: ">" });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date3) {
            return this.$_addRule({ name: "less", method: "compare", args: { date: date3 }, operator: "<" });
          }
        },
        max: {
          method(date3) {
            return this.$_addRule({ name: "max", method: "compare", args: { date: date3 }, operator: "<=" });
          }
        },
        min: {
          method(date3) {
            return this.$_addRule({ name: "min", method: "compare", args: { date: date3 }, operator: ">=" });
          }
        },
        timestamp: {
          method(type = "javascript") {
            Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": "{{#label}} must be in {{#format}} format",
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}"
      }
    });
    internals.parse = function(value, format32) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format32 === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format32) {
        if (format32 === "javascript") {
          return internals.date(1 * value);
        }
        if (format32 === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date3 = new Date(value);
      if (!isNaN(date3.getTime())) {
        return date3;
      }
      return null;
    };
  }
});
var require_lib2 = __commonJS({
  "node_modules/.deno/@hapi+topo@6.0.2/node_modules/@hapi/topo/lib/index.js"(exports2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var internals = {};
    exports2.Sorter = class {
      constructor() {
        this._items = [];
        this.nodes = [];
      }
      add(nodes, options3) {
        options3 = options3 ?? {};
        const before = [].concat(options3.before ?? []);
        const after = [].concat(options3.after ?? []);
        const group = options3.group ?? "?";
        const sort = options3.sort ?? 0;
        assert22(!before.includes(group), `Item cannot come before itself: ${group}`);
        assert22(!before.includes("?"), "Item cannot come before unassociated items");
        assert22(!after.includes(group), `Item cannot come after itself: ${group}`);
        assert22(!after.includes("?"), "Item cannot come after unassociated items");
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (const node of nodes) {
          const item = {
            seq: this._items.length,
            sort,
            before,
            after,
            group,
            node
          };
          this._items.push(item);
        }
        if (!options3.manual) {
          const valid = this._sort();
          assert22(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
        }
        return this.nodes;
      }
      merge(others) {
        if (!Array.isArray(others)) {
          others = [others];
        }
        for (const other of others) {
          if (other) {
            for (const item of other._items) {
              this._items.push(Object.assign({}, item));
            }
          }
        }
        this._items.sort(internals.mergeSort);
        for (let i2 = 0; i2 < this._items.length; ++i2) {
          this._items[i2].seq = i2;
        }
        const valid = this._sort();
        assert22(valid, "merge created a dependencies error");
        return this.nodes;
      }
      sort() {
        const valid = this._sort();
        assert22(valid, "sort created a dependencies error");
        return this.nodes;
      }
      _sort() {
        const graph = {};
        const graphAfters = /* @__PURE__ */ Object.create(null);
        const groups = /* @__PURE__ */ Object.create(null);
        for (const item of this._items) {
          const seq = item.seq;
          const group = item.group;
          groups[group] = groups[group] ?? [];
          groups[group].push(seq);
          graph[seq] = item.before;
          for (const after of item.after) {
            graphAfters[after] = graphAfters[after] ?? [];
            graphAfters[after].push(seq);
          }
        }
        for (const node in graph) {
          const expandedGroups = [];
          for (const graphNodeItem in graph[node]) {
            const group = graph[node][graphNodeItem];
            groups[group] = groups[group] ?? [];
            expandedGroups.push(...groups[group]);
          }
          graph[node] = expandedGroups;
        }
        for (const group in graphAfters) {
          if (groups[group]) {
            for (const node of groups[group]) {
              graph[node].push(...graphAfters[group]);
            }
          }
        }
        const ancestors = {};
        for (const node in graph) {
          const children = graph[node];
          for (const child of children) {
            ancestors[child] = ancestors[child] ?? [];
            ancestors[child].push(node);
          }
        }
        const visited = {};
        const sorted = [];
        for (let i2 = 0; i2 < this._items.length; ++i2) {
          let next = i2;
          if (ancestors[i2]) {
            next = null;
            for (let j = 0; j < this._items.length; ++j) {
              if (visited[j] === true) {
                continue;
              }
              if (!ancestors[j]) {
                ancestors[j] = [];
              }
              const shouldSeeCount = ancestors[j].length;
              let seenCount = 0;
              for (let k = 0; k < shouldSeeCount; ++k) {
                if (visited[ancestors[j][k]]) {
                  ++seenCount;
                }
              }
              if (seenCount === shouldSeeCount) {
                next = j;
                break;
              }
            }
          }
          if (next !== null) {
            visited[next] = true;
            sorted.push(next);
          }
        }
        if (sorted.length !== this._items.length) {
          return false;
        }
        const seqIndex = {};
        for (const item of this._items) {
          seqIndex[item.seq] = item;
        }
        this._items = [];
        this.nodes = [];
        for (const value of sorted) {
          const sortedItem = seqIndex[value];
          this.nodes.push(sortedItem.node);
          this._items.push(sortedItem);
        }
        return true;
      }
    };
    internals.mergeSort = (a, b) => {
      return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
    };
  }
});
var require_keys = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/keys.js"(exports2, module2) {
    "use strict";
    var ApplyToDefaults = require_applyToDefaults();
    var Assert = require_assert();
    var Clone = require_clone();
    var Topo = require_lib2();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      renameDefaults: {
        alias: false,
        // Keep old value in place
        multiple: false,
        // Allow renaming multiple keys into the same target
        override: false
        // Overrides an existing key
      }
    };
    module2.exports = Any._extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: { default: false }
      },
      terms: {
        dependencies: { init: null },
        keys: { init: null },
        patterns: { init: null },
        renames: { init: null }
      },
      args(schema, keys) {
        return schema.keys(keys);
      },
      validate(value, { schema, error, state, prefs }) {
        if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
          return { value, errors: error("object.base", { type: schema.$_property("typeof") }) };
        }
        if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
          return { value, errors };
        }
        if (!schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns && !schema.$_terms.dependencies) {
          return { value, errors };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema.$_terms.keys) {
          const ancestors = [value, ...state.ancestors];
          for (const child of schema.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([...state.path, key], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema._flags._hasPatternMatch) {
          const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema.$_terms.dependencies) {
          for (const dep of schema.$_terms.dependencies) {
            if (dep.key && dep.key.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
            if (failed) {
              const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
        return { value, errors };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema) {
            if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
              return this;
            }
            return this.keys(schema);
          }
        },
        assert: {
          method(subject, schema, message) {
            subject = Compile.ref(subject);
            Assert(message === void 0 || typeof message === "string", "Message must be a string");
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { error, prefs, state }, { subject, schema, message }) {
            const about = subject.resolve(value, state, prefs);
            const path12 = subject.absolute(state);
            if (schema.$_match(about, state.localize(path12, [value, ...state.ancestors], schema), prefs)) {
              return value;
            }
            return error("object.assert", { subject, message });
          },
          args: ["subject", "schema", "message"],
          multi: true
        },
        instance: {
          method(constructor, name) {
            Assert(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({ name: "instance", args: { constructor, name } });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", { type: name, value });
          },
          args: ["constructor", "name"]
        },
        keys: {
          method(schema) {
            Assert(schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
            Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema) {
                Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema, options3 = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, { appendPath: true });
            }
            Assert(schema !== void 0, "Invalid rule");
            Common.assertOptions(options3, ["fallthrough", "matches"]);
            if (isRegExp) {
              Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config2 = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
            if (options3.matches) {
              config2.matches = this.$_compile(options3.matches);
              if (config2.matches.type !== "array") {
                config2.matches = config2.matches.$_root.array().items(config2.matches);
              }
              obj.$_mutateRegister(config2.matches);
              obj.$_setFlag("_hasPatternMatch", true, { clone: false });
            }
            if (options3.fallthrough) {
              config2.fallthrough = true;
            }
            obj.$_terms.patterns.push(config2);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", { value });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", { value });
          }
        },
        rename: {
          method(from6, to, options3 = {}) {
            Assert(typeof from6 === "string" || from6 instanceof RegExp, "Rename missing the from argument");
            Assert(typeof to === "string", "Invalid rename to argument");
            Assert(to !== from6, "Cannot rename key to same name:", from6);
            Common.assertOptions(options3, ["alias", "ignoreUndefined", "override", "multiple"]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              Assert(rename.from !== from6, "Cannot rename the same key multiple times");
            }
            obj.$_terms.renames.push({
              from: from6,
              to,
              options: ApplyToDefaults(internals.renameDefaults, options3)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({ name: "schema", args: { type } });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", { type });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "with", key, peers, options3);
          }
        },
        without: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "without", key, peers, options3);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options3) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options3);
        }
      },
      rebuild(schema) {
        if (schema.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
          }
          schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#present}} without its required peers {{#missing}}",
        "object.assert": "{{#label}} is invalid because it failed to pass the assertion test",
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": "{{#label}} must have {{#limit}} keys",
        "object.max": "{{#label}} must have less than or equal to {{#limit}} keys",
        "object.min": "{{#label}} must have at least {{#limit}} keys",
        "object.missing": "{{#label}} must contain at least one of {{#peers}}",
        "object.nand": "{{:#main}} must not exist simultaneously with {{#peers}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peers}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#main}} missing required peer {{:#peer}}",
        "object.without": "{{:#main}} conflict with forbidden peer {{:#peer}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peers}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, { shallow: true });
        }
        const clone3 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone3, value);
        return clone3;
      }
      const clone2 = function(...args) {
        return value.apply(this, args);
      };
      clone2.prototype = Clone(value.prototype);
      Object.defineProperty(clone2, "name", { value: value.name, writable: false });
      Object.defineProperty(clone2, "length", { value: value.length, writable: false });
      Object.assign(clone2, value);
      return clone2;
    };
    internals.dependency = function(schema, rel, key, peers, options3) {
      Assert(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options3) {
        options3 = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options3, ["separator"]);
      peers = [].concat(peers);
      const separator = Common.default(options3.separator, ".");
      const paths = [];
      for (const peer of peers) {
        Assert(typeof peer === "string", rel, "peers must be a string or a reference");
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
      }
      if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
      }
      const obj = schema.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
      return obj;
    };
    internals.dependencies = {
      and(schema, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count3 = dep.peers.length;
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count3 && present.length !== count3) {
          return {
            code: "object.and",
            context: {
              present,
              missing
            }
          };
        }
      },
      nand(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            peers: values
          }
        };
      },
      or(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths
          }
        };
      },
      oxor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = { peers: dep.paths };
        context.present = present;
        return { code: "object.oxor", context };
      },
      with(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                peer: peer.key
              }
            };
          }
        }
      },
      without(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                peer: peer.key
              }
            };
          }
        }
      },
      xor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = { peers: dep.paths };
        if (present.length === 0) {
          return { code: "object.missing", context };
        }
        context.present = present;
        return { code: "object.xor", context };
      }
    };
    internals.rename = function(schema, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from6 in value) {
            if (value[from6] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from6 === rename.to) {
              continue;
            }
            const match = rename.from.exec(from6);
            if (!match) {
              continue;
            }
            matches.push({ from: from6, to: rename.to, match });
          }
        }
        for (const match of matches) {
          const from6 = match.from;
          const to = match.to;
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema.$_createError("object.rename.multiple", value, { from: from6, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema.$_createError("object.rename.override", value, { from: from6, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from6] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from6];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from6];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
      if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [value, ...state.ancestors];
        for (const key of unprocessed) {
          const item = value[key];
          const path12 = [...state.path, key];
          for (let i2 = 0; i2 < schema.$_terms.patterns.length; ++i2) {
            const pattern = schema.$_terms.patterns[i2];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i2}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path12, ancestors, { schema: pattern.rule, key });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i2].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i2 = 0; i2 < matches.length; ++i2) {
            const match = matches[i2];
            if (!match) {
              continue;
            }
            const stpm = schema.$_terms.patterns[i2].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, { override: false });
              details.matches = match;
              const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([...state.path, unprocessedKey], []);
          const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
          if (prefs.abortEarly) {
            return { value, errors: report };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < result.length; ++i2) {
          keys.set(result[i2].key, i2);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});
var require_function = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/function.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Keys = require_keys();
    module2.exports = Keys._extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "arity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", { n });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", { value });
          }
        },
        minArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({ name: "minArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", { n });
          }
        },
        maxArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "maxArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", { n });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});
var require_link = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/link.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var internals = {};
    module2.exports = Any._extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: { init: null, register: false }
      },
      args(schema, ref) {
        return schema.ref(ref);
      },
      validate(value, { schema, state, prefs }) {
        Assert(schema.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema, value, state, prefs) {
        return internals.generate(schema, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            Assert(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [{ ref }];
            return obj;
          }
        },
        relative: {
          method(enabled2 = true) {
            return this.$_setFlag("relative", enabled2);
          }
        }
      },
      overrides: {
        concat(source) {
          Assert(this.$_terms.link, "Uninitialized link schema");
          Assert(Common.isSchema(source), "Invalid schema object");
          Assert(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({ concat: source });
          return obj.$_mutateRebuild();
        }
      }
    });
    internals.generate = function(schema, value, state, prefs) {
      let linked = state.mainstay.links.get(schema);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema.$_terms.link[0].ref;
      const { perspective, path: path12 } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
      try {
        linked = path12.length ? perspective.$_reach(path12) : perspective;
      } catch (ignoreErr) {
        internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
      if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema, key } of state.schemas) {
          const id = schema._flags.id || key;
          if (id === ref.path[0]) {
            return { perspective: schema, path: ref.path.slice(1) };
          }
          if (schema.$_terms.shared) {
            for (const shared of schema.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return { perspective: shared, path: ref.path.slice(1) };
              }
            }
          }
        }
        return { perspective: null, path: null };
      }
      if (ref.ancestor === "root") {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
      }
      return { perspective: state.schemas[ref.ancestor]?.schema, path: ref.path };
    };
    internals.assert = function(condition, message, ref, schema, state, prefs) {
      if (condition) {
        return;
      }
      Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});
var require_number = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/number.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
    };
    module2.exports = Any._extend({
      type: "number",
      flags: {
        unsafe: { default: false }
      },
      coerce: {
        from: "string",
        method(value, { schema, error }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = { value: parseFloat(value) };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema._flags.unsafe) {
            if (value.match(/e/i)) {
              const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
              if (constructed !== internals.normalizeExponent(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            } else {
              const string3 = result.value.toString();
              if (string3.match(/e/i)) {
                return result;
              }
              if (string3 !== internals.normalizeDecimal(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return { value, errors: error("number.infinity") };
        }
        if (!Common.isNumber(value)) {
          return { value, errors: error("number.base") };
        }
        const result = { value };
        if (prefs.convert) {
          const rule = schema.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
          }
        },
        multiple: {
          method(base4) {
            return this.$_addRule({ name: "multiple", args: { base: base4 } });
          },
          validate(value, helpers, { base: base4 }, options3) {
            if (value % base4 === 0) {
              return value;
            }
            return helpers.error("number.multiple", { multiple: options3.args.base, value });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            }
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            Assert(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({ name: "precision", args: { limit } });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", { limit, value });
          },
          convert: true
        },
        sign: {
          method(sign2) {
            Assert(["negative", "positive"].includes(sign2), "Invalid sign", sign2);
            return this.$_addRule({ name: "sign", args: { sign: sign2 } });
          },
          validate(value, helpers, { sign: sign2 }) {
            if (sign2 === "negative" && value < 0 || sign2 === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign2}`);
          }
        },
        unsafe: {
          method(enabled2 = true) {
            Assert(typeof enabled2 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled2);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.normalizeExponent = function(str) {
      return str.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0+$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([1-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});
var require_object = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/object.js"(exports2, module2) {
    "use strict";
    var Keys = require_keys();
    module2.exports = Keys._extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});
var require_string = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/string.js"(exports2, module2) {
    "use strict";
    var Url = __require2("url");
    var Assert = require_assert();
    var EscapeRegex = require_escapeRegex();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      base64Regex: {
        // paddingRequired
        true: {
          // urlSafe
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: /^[a-f0-9]+$/i,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5"
      },
      guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]),
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"],
      domainControlRx: /[\x00-\x20@\:\/]/,
      // Control + space + separators
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      finalSegmentAdditionalRx: /[^0-9]/
      // Domain segment which is additionally not all-numeric
    };
    module2.exports = Any._extend({
      type: "string",
      flags: {
        insensitive: { default: false },
        truncate: { default: false }
      },
      terms: {
        replacements: { init: null }
      },
      coerce: {
        from: "string",
        method(value, { schema, state, prefs }) {
          const normalize22 = schema.$_getRule("normalize");
          if (normalize22) {
            value = value.normalize(normalize22.args.form);
          }
          const casing = schema.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema.$_terms.replacements) {
            for (const replacement of schema.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema._flags.truncate) {
            const rule = schema.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return { value };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "string") {
          return { value, errors: error("string.base") };
        }
        if (value === "") {
          return { value, errors: error("string.empty") };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["paddingRequired", "urlSafe"]);
            options3 = { urlSafe: false, paddingRequired: true, ...options3 };
            Assert(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            Assert(typeof options3.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({ name: "base64", args: { options: options3 } });
          },
          validate(value, helpers, { options: options3 }) {
            const regex = internals.base64Regex[options3.paddingRequired][options3.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
            return this.$_addRule({ name: "case", args: { direction } });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i2 = value.length;
            let sum = 0;
            let mul = 1;
            while (i2--) {
              const char = value.charAt(i2) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["paddingRequired"]);
            options3 = { paddingRequired: true, ...options3 };
            Assert(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({ name: "dataUri", args: { options: options3 } });
          },
          validate(value, helpers, { options: options3 }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options3.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        guid: {
          alias: "uuid",
          method(options3 = {}) {
            Common.assertOptions(options3, ["version", "separator"]);
            let versionNumbers = "";
            if (options3.version) {
              const versions = [].concat(options3.version);
              Assert(versions.length >= 1, "version must have at least 1 valid version specified");
              const set = /* @__PURE__ */ new Set();
              for (let i2 = 0; i2 < versions.length; ++i2) {
                const version4 = versions[i2];
                Assert(typeof version4 === "string", "version at position " + i2 + " must be a string");
                const versionNumber = internals.guidVersions[version4.toLowerCase()];
                Assert(versionNumber, "version at position " + i2 + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                Assert(!set.has(versionNumber), "version at position " + i2 + " must not be a duplicate");
                versionNumbers += versionNumber;
                set.add(versionNumber);
              }
            }
            Assert(internals.guidSeparators.has(options3.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options3.separator === void 0 ? "[:-]?" : options3.separator === true ? "[:-]" : options3.separator === false ? "[]?" : `\\${options3.separator}`;
            const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
            return this.$_addRule({ name: "guid", args: { options: options3 }, regex });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["byteAligned"]);
            options3 = { byteAligned: false, ...options3 };
            Assert(typeof options3.byteAligned === "boolean", "byteAligned must be boolean");
            return this.$_addRule({ name: "hex", args: { options: options3 } });
          },
          validate(value, helpers, { options: options3 }) {
            if (!internals.hexRegex.test(value)) {
              return helpers.error("string.hex");
            }
            if (options3.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (internals.isDomainValid(value) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length4 = encoding ? Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length4, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, { limit: args.limit, value, encoding });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: ["limit", "encoding"]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: ["limit", "encoding"]
        },
        normalize: {
          method(form = "NFC") {
            Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({ name: "normalize", args: { form } });
          },
          validate(value, { error }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error("string.normalize", { value, form });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options3 = {}) {
            Assert(regex instanceof RegExp, "regex must be a RegExp");
            Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options3 === "string") {
              options3 = { name: options3 };
            }
            Common.assertOptions(options3, ["invert", "name"]);
            const errorCode = ["string.pattern", options3.invert ? ".invert" : "", options3.name ? ".name" : ".base"].join("");
            return this.$_addRule({ name: "pattern", args: { regex, options: options3 }, errorCode });
          },
          validate(value, helpers, { regex, options: options3 }, { errorCode }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options3.invert) {
              return value;
            }
            return helpers.error(errorCode, { name: options3.name, regex, value });
          },
          args: ["regex", "options"],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(EscapeRegex(pattern), "g");
            }
            Assert(pattern instanceof RegExp, "pattern must be a RegExp");
            Assert(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({ pattern, replacement });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled2 = true) {
            Assert(typeof enabled2 === "boolean", "enabled must be a boolean");
            return this.$_addRule({ name: "trim", args: { enabled: enabled2 } });
          },
          validate(value, helpers, { enabled: enabled2 }) {
            if (!enabled2 || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled2 = true) {
            Assert(typeof enabled2 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled2);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:.} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:.} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:.} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:.} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      const date3 = new Date(value);
      if (isNaN(date3.getTime())) {
        return null;
      }
      return date3.toISOString();
    };
    internals.length = function(schema, name, limit, operator, encoding) {
      Assert(!encoding || Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
    };
    internals.rfc3986 = function() {
      const rfc3986 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc3986.ipv4 = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4 + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc3986.v4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc3986.v6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc3986.ipv6 = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc3986.ipvfuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      return rfc3986;
    };
    internals.ipRegex = function() {
      const versions = ["ipv4", "ipv6", "ipvfuture"];
      const rfc3986 = internals.rfc3986();
      const parts = versions.map((version4) => {
        const cidrpart = `\\/${version4 === "ipv4" ? rfc3986.v4Cidr : rfc3986.v6Cidr}`;
        return `${rfc3986[version4]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      return new RegExp(`^${raw}$`);
    }();
    internals.isDomainValid = function(domain) {
      if (domain.length > 256) {
        return false;
      }
      domain = domain.normalize("NFC");
      if (internals.domainControlRx.test(domain)) {
        return false;
      }
      domain = internals.punycode(domain);
      const segments = domain.split(".");
      for (let i2 = 0; i2 < segments.length; ++i2) {
        const segment = segments[i2];
        if (!segment.length) {
          return false;
        }
        if (segment.length > 63) {
          return false;
        }
        if (!internals.domainSegmentRx.test(segment)) {
          return false;
        }
        const isFinalSegment = i2 === segments.length - 1;
        if (isFinalSegment && !internals.finalSegmentAdditionalRx.test(segment)) {
          return false;
        }
      }
      return true;
    };
    internals.punycode = function(domain) {
      try {
        return new Url.URL(`http://${domain}`).host;
      } catch (err) {
        return domain;
      }
    };
  }
});
var require_symbol = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/symbol.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module2.exports = Any._extend({
      type: "symbol",
      terms: {
        map: { init: new internals.Map() }
      },
      coerce: {
        method(value, { schema, error }) {
          const lookup = schema.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema._flags.only || typeof value === "symbol") {
            return { value };
          }
          return { value, errors: error("symbol.map", { map: schema.$_terms.map }) };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "symbol") {
          return { value, errors: error("symbol.base") };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols2 = [];
            for (const entry of iterable) {
              Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              Assert(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols2.push(value);
            }
            return obj.valid(...symbols2);
          }
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});
var require_binary = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/binary.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    module2.exports = Any._extend({
      type: "binary",
      coerce: {
        from: "string",
        method(value, { schema }) {
          try {
            return { value: Buffer.from(value, schema._flags.encoding) };
          } catch (ignoreErr) {
          }
        }
      },
      validate(value, { error }) {
        if (!Buffer.isBuffer(value)) {
          return { value, errors: error("binary.base") };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});
var require_lib3 = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/index.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      types: {
        alternatives: require_alternatives(),
        any: require_any(),
        array: require_array(),
        boolean: require_boolean(),
        date: require_date(),
        function: require_function(),
        link: require_link(),
        number: require_number(),
        object: require_object(),
        string: require_string(),
        symbol: require_symbol()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      assert(value, schema, ...args) {
        internals.assert(value, schema, true, args);
      },
      attempt(value, schema, ...args) {
        return internals.assert(value, schema, false, args);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema, options3) {
        return Compile.compile(this, schema, options3);
      },
      isError: Errors.ValidationError.isError,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      }
    };
    internals.assert = function(value, schema, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options3 = message ? args[1] : args[0];
      const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options3 || {}));
      let error = result.error;
      if (!error) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
      if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
      }
      error.message = message ? `${message} ${display}` : display;
      throw error;
    };
    internals.generate = function(root, schema, args) {
      Assert(root, "Must be invoked on a Joi instance.");
      schema.$_root = root;
      if (!schema._definition.args || !args.length) {
        return schema;
      }
      return schema._definition.args(schema, ...args);
    };
    module2.exports = internals.root();
  }
});
var require_symbols = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/symbols.js"(exports2) {
    "use strict";
    exports2.injection = Symbol("injection");
  }
});
var require_request = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/request.js"(exports2, module2) {
    "use strict";
    var Events2 = __require2("events");
    var Stream = __require2("stream");
    var Url = __require2("url");
    var Symbols = require_symbols();
    var internals = {};
    exports2 = module2.exports = internals.Request = class extends Stream.Readable {
      constructor(options3) {
        super({
          emitClose: !!options3.simulate?.close,
          autoDestroy: true
          // This is the default in node 14+
        });
        let url = options3.url;
        if (typeof url === "object") {
          url = Url.format(url);
        }
        const uri = Url.parse(url);
        this.url = uri.path;
        this.httpVersion = "1.1";
        this.method = options3.method ? options3.method.toUpperCase() : "GET";
        this.headers = {};
        const headers = options3.headers ?? {};
        const fields = Object.keys(headers);
        fields.forEach((field) => {
          this.headers[field.toLowerCase()] = headers[field];
        });
        this.headers["user-agent"] = this.headers["user-agent"] ?? "shot";
        const hostHeaderFromUri = function() {
          if (uri.port) {
            return uri.host;
          }
          if (uri.protocol) {
            return uri.hostname + (uri.protocol === "https:" ? ":443" : ":80");
          }
          return null;
        };
        this.headers.host = this.headers.host ?? hostHeaderFromUri() ?? options3.authority ?? "localhost:80";
        this.socket = this.connection = new internals.MockSocket(options3);
        let payload = options3.payload ?? null;
        if (payload && typeof payload !== "string" && !(payload instanceof Stream) && !Buffer.isBuffer(payload)) {
          payload = JSON.stringify(payload);
          this.headers["content-type"] = this.headers["content-type"] || "application/json";
        }
        if (payload && !(payload instanceof Stream) && !this.headers.hasOwnProperty("content-length")) {
          this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
        }
        this._shot = {
          payload,
          isDone: false,
          simulate: options3.simulate ?? {}
        };
        return this;
      }
      prepare(next) {
        if (this._shot.payload instanceof Stream === false) {
          return next();
        }
        const chunks = [];
        this._shot.payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
        this._shot.payload.on("end", () => {
          const payload = Buffer.concat(chunks);
          this.headers["content-length"] = this.headers["content-length"] || payload.length;
          this._shot.payload = payload;
          return next();
        });
      }
      _read(size) {
        setImmediate(() => {
          if (this._shot.isDone) {
            if (this._shot.simulate.end !== false) {
              this.push(null);
            }
            return;
          }
          this._shot.isDone = true;
          if (this._shot.payload) {
            if (this._shot.simulate.split) {
              this.push(this._shot.payload.slice(0, 1));
              this.push(this._shot.payload.slice(1));
            } else {
              this.push(this._shot.payload);
            }
          }
          if (this._shot.simulate.error) {
            this.destroy(new Error("Simulated"));
          } else if (this._shot.simulate.end !== false) {
            this.push(null);
          } else if (this._shot.simulate.close) {
            this.emit("close");
          }
        });
      }
    };
    internals.Request.prototype[Symbols.injection] = true;
    internals.MockSocket = class MockSocket extends Events2.EventEmitter {
      constructor({ remoteAddress }) {
        super();
        this.remoteAddress = remoteAddress ?? "127.0.0.1";
      }
      // Net.Socket APIs used by hapi
      end() {
      }
      setTimeout() {
      }
    };
  }
});
var require_response = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/response.js"(exports2, module2) {
    "use strict";
    var Http = __require2("http");
    var Stream = __require2("stream");
    var Hoek = require_lib();
    var Symbols = require_symbols();
    var internals = {};
    exports2 = module2.exports = internals.Response = class extends Http.ServerResponse {
      constructor(req, onEnd) {
        super({ method: req.method, httpVersionMajor: 1, httpVersionMinor: 1 });
        this._shot = { headers: null, trailers: {}, payloadChunks: [] };
        this.assignSocket(internals.nullSocket());
        this.socket.on("error", Hoek.ignore);
        if (req._shot.simulate.close) {
          req.once("close", () => {
            process.nextTick(() => this.destroy());
          });
        }
        const finalize = (aborted2) => {
          const res = internals.payload(this);
          res.raw.req = req;
          if (aborted2) {
            res.aborted = aborted2;
            if (!this.headersSent) {
              res.statusCode = 499;
            }
          }
          this.removeListener("close", abort);
          process.nextTick(() => onEnd(res));
        };
        const abort = () => finalize(true);
        this.once("finish", finalize);
        this.on("close", abort);
      }
      writeHead(...args) {
        const headers = args[args.length - 1];
        if (typeof headers === "object" && headers !== null) {
          const headerNames = Object.keys(headers);
          for (let i2 = 0; i2 < headerNames.length; ++i2) {
            const name = headerNames[i2];
            try {
              this.setHeader(name, headers[name]);
              break;
            } catch (ignoreErr) {
            }
          }
        }
        const result = super.writeHead(...args);
        this._shot.headers = this.getHeaders();
        ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
          const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
          const field = this._header.match(regex);
          if (field) {
            this._shot.headers[name.toLowerCase()] = field[1];
          }
        });
        return result;
      }
      write(data, encoding, callback) {
        super.write(data, encoding, callback);
        this._shot.payloadChunks.push(Buffer.from(data, encoding));
        return true;
      }
      end(data, encoding, callback) {
        if (data) {
          this.write(data, encoding);
        }
        super.end(callback);
        this.emit("finish");
      }
      addTrailers(trailers) {
        for (const key in trailers) {
          this._shot.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
        }
      }
    };
    internals.Response.prototype[Symbols.injection] = true;
    internals.payload = function(response) {
      const res = {
        raw: {
          res: response
        },
        headers: response._shot.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {}
      };
      const rawBuffer = Buffer.concat(response._shot.payloadChunks);
      res.rawPayload = rawBuffer;
      res.payload = rawBuffer.toString();
      res.trailers = response._shot.trailers;
      return res;
    };
    internals.nullSocket = function() {
      return new Stream.Writable({
        write(chunk, encoding, callback) {
          setImmediate(callback);
        }
      });
    };
  }
});
var require_lib4 = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Validate = require_lib3();
    var Request2 = require_request();
    var Response2 = require_response();
    var Symbols = require_symbols();
    var internals = {};
    internals.options = Validate.object().keys({
      url: Validate.alternatives([
        Validate.string(),
        Validate.object().keys({
          protocol: Validate.string(),
          hostname: Validate.string(),
          port: Validate.any(),
          pathname: Validate.string().required(),
          query: Validate.any()
        })
      ]).required(),
      headers: Validate.object(),
      payload: Validate.any(),
      simulate: {
        end: Validate.boolean(),
        split: Validate.boolean(),
        error: Validate.boolean(),
        close: Validate.boolean()
      },
      authority: Validate.string(),
      remoteAddress: Validate.string(),
      method: Validate.string(),
      validate: Validate.boolean()
    });
    exports2.inject = async function(dispatchFunc, options3) {
      options3 = typeof options3 === "string" ? { url: options3 } : options3;
      if (options3?.validate !== false) {
        Hoek.assert(typeof dispatchFunc === "function", "Invalid or missing dispatch function");
        Validate.assert(options3 ?? null, internals.options, "Invalid options:");
      }
      return new Promise((resolve8) => {
        const req = new Request2(options3);
        const res = new Response2(req, resolve8);
        req.prepare(() => dispatchFunc(req, res));
      });
    };
    exports2.isInjection = function(obj) {
      return !!obj[Symbols.injection];
    };
  }
});
var require_lib5 = __commonJS({
  "node_modules/.deno/@hapi+teamwork@6.0.1/node_modules/@hapi/teamwork/lib/index.js"(exports2) {
    "use strict";
    var internals = {};
    exports2.Team = class {
      #meetings = null;
      #count = null;
      #notes = null;
      #done = false;
      #strict = false;
      constructor(options3) {
        this._init(options3);
      }
      static _notes(instance) {
        return instance.#notes;
      }
      _init(options3 = {}) {
        this.work = new Promise((resolve8, reject) => {
          this._resolve = resolve8;
          this._reject = reject;
        });
        const meetings = options3.meetings ?? 1;
        const strict = !!options3.strict;
        if (!Number.isInteger(meetings) || meetings <= 0) {
          if (meetings === 0 && !strict) {
            return this._finalize(null, null);
          }
          throw new Error("Invalid meetings value");
        }
        this.#meetings = meetings;
        this.#count = meetings;
        this.#notes = [];
        this.#done = false;
        this.#strict = strict;
      }
      _finalize(err, note) {
        this.#done = true;
        this.#notes = null;
        if (err) {
          this._reject(err);
        } else {
          this._resolve(note);
        }
      }
      attend(note) {
        if (this.#done) {
          if (this.#strict) {
            throw new Error("Unscheduled meeting");
          }
          return;
        }
        if (note instanceof Error) {
          return this._finalize(note);
        }
        this.#notes.push(note);
        if (--this.#count) {
          return;
        }
        this._finalize(null, this.#meetings === 1 ? this.#notes[0] : this.#notes);
      }
      async regroup(options3) {
        try {
          await this.work;
        } catch {
        }
        this._init(options3);
      }
    };
    exports2.Events = class {
      #iterators = /* @__PURE__ */ new Set();
      static _iterators(instance) {
        return instance.#iterators;
      }
      static isIterator(iterator) {
        return iterator instanceof internals.EventsIterator;
      }
      iterator() {
        const iterator = new internals.EventsIterator(this);
        this.#iterators.add(iterator);
        return iterator;
      }
      emit(value) {
        for (const iterator of this.#iterators) {
          iterator._queue({ value, done: false });
        }
      }
      end() {
        for (const iterator of this.#iterators) {
          iterator._queue({ done: true });
        }
      }
      _remove(iterator) {
        this.#iterators.delete(iterator);
      }
    };
    internals.EventsIterator = class {
      #events;
      #pending = null;
      #queue = [];
      constructor(events) {
        this.#events = events;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      next() {
        if (this.#queue.length) {
          return Promise.resolve(this.#queue.shift());
        }
        if (!this.#events) {
          return { done: true };
        }
        this.#pending = new exports2.Team();
        return this.#pending.work;
      }
      return() {
        this._cleanup();
        return { done: true };
      }
      _cleanup() {
        this.#events?._remove(this);
        this.#events = null;
      }
      _queue(item) {
        if (item.done) {
          this._cleanup();
        }
        if (this.#pending) {
          this.#pending.attend(item);
          this.#pending = null;
        } else {
          this.#queue.push(item);
        }
      }
    };
  }
});
var require_lib6 = __commonJS({
  "node_modules/.deno/@hapi+boom@10.0.1/node_modules/@hapi/boom/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {
      codes: /* @__PURE__ */ new Map([
        [100, "Continue"],
        [101, "Switching Protocols"],
        [102, "Processing"],
        [200, "OK"],
        [201, "Created"],
        [202, "Accepted"],
        [203, "Non-Authoritative Information"],
        [204, "No Content"],
        [205, "Reset Content"],
        [206, "Partial Content"],
        [207, "Multi-Status"],
        [300, "Multiple Choices"],
        [301, "Moved Permanently"],
        [302, "Moved Temporarily"],
        [303, "See Other"],
        [304, "Not Modified"],
        [305, "Use Proxy"],
        [307, "Temporary Redirect"],
        [400, "Bad Request"],
        [401, "Unauthorized"],
        [402, "Payment Required"],
        [403, "Forbidden"],
        [404, "Not Found"],
        [405, "Method Not Allowed"],
        [406, "Not Acceptable"],
        [407, "Proxy Authentication Required"],
        [408, "Request Time-out"],
        [409, "Conflict"],
        [410, "Gone"],
        [411, "Length Required"],
        [412, "Precondition Failed"],
        [413, "Request Entity Too Large"],
        [414, "Request-URI Too Large"],
        [415, "Unsupported Media Type"],
        [416, "Requested Range Not Satisfiable"],
        [417, "Expectation Failed"],
        [418, "I'm a teapot"],
        [422, "Unprocessable Entity"],
        [423, "Locked"],
        [424, "Failed Dependency"],
        [425, "Too Early"],
        [426, "Upgrade Required"],
        [428, "Precondition Required"],
        [429, "Too Many Requests"],
        [431, "Request Header Fields Too Large"],
        [451, "Unavailable For Legal Reasons"],
        [500, "Internal Server Error"],
        [501, "Not Implemented"],
        [502, "Bad Gateway"],
        [503, "Service Unavailable"],
        [504, "Gateway Time-out"],
        [505, "HTTP Version Not Supported"],
        [506, "Variant Also Negotiates"],
        [507, "Insufficient Storage"],
        [509, "Bandwidth Limit Exceeded"],
        [510, "Not Extended"],
        [511, "Network Authentication Required"]
      ])
    };
    exports2.Boom = class extends Error {
      constructor(messageOrError, options3 = {}) {
        if (messageOrError instanceof Error) {
          return exports2.boomify(Hoek.clone(messageOrError), options3);
        }
        const { statusCode = 500, data = null, ctor = exports2.Boom } = options3;
        const error = new Error(messageOrError ? messageOrError : void 0);
        Error.captureStackTrace(error, ctor);
        error.data = data;
        const boom = internals.initialize(error, statusCode);
        Object.defineProperty(boom, "typeof", { value: ctor });
        if (options3.decorate) {
          Object.assign(boom, options3.decorate);
        }
        return boom;
      }
      static [Symbol.hasInstance](instance) {
        if (this === exports2.Boom) {
          return exports2.isBoom(instance);
        }
        return this.prototype.isPrototypeOf(instance);
      }
    };
    exports2.isBoom = function(err, statusCode) {
      return err instanceof Error && !!err.isBoom && (!statusCode || err.output.statusCode === statusCode);
    };
    exports2.boomify = function(err, options3) {
      Hoek.assert(err instanceof Error, "Cannot wrap non-Error object");
      options3 = options3 || {};
      if (options3.data !== void 0) {
        err.data = options3.data;
      }
      if (options3.decorate) {
        Object.assign(err, options3.decorate);
      }
      if (!err.isBoom) {
        return internals.initialize(err, options3.statusCode ?? 500, options3.message);
      }
      if (options3.override === false || // Defaults to true
      !options3.statusCode && !options3.message) {
        return err;
      }
      return internals.initialize(err, options3.statusCode ?? err.output.statusCode, options3.message);
    };
    exports2.badRequest = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 400, data, ctor: exports2.badRequest });
    };
    exports2.unauthorized = function(message, scheme, attributes) {
      const err = new exports2.Boom(message, { statusCode: 401, ctor: exports2.unauthorized });
      if (!scheme) {
        return err;
      }
      if (typeof scheme !== "string") {
        err.output.headers["WWW-Authenticate"] = scheme.join(", ");
        return err;
      }
      let wwwAuthenticate = `${scheme}`;
      if (attributes || message) {
        err.output.payload.attributes = {};
      }
      if (attributes) {
        if (typeof attributes === "string") {
          wwwAuthenticate += " " + Hoek.escapeHeaderAttribute(attributes);
          err.output.payload.attributes = attributes;
        } else {
          wwwAuthenticate += " " + Object.keys(attributes).map((name) => {
            const value = attributes[name] ?? "";
            err.output.payload.attributes[name] = value;
            return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
          }).join(", ");
        }
      }
      if (message) {
        if (attributes) {
          wwwAuthenticate += ",";
        }
        wwwAuthenticate += ` error="${Hoek.escapeHeaderAttribute(message)}"`;
        err.output.payload.attributes.error = message;
      } else {
        err.isMissing = true;
      }
      err.output.headers["WWW-Authenticate"] = wwwAuthenticate;
      return err;
    };
    exports2.paymentRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 402, data, ctor: exports2.paymentRequired });
    };
    exports2.forbidden = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 403, data, ctor: exports2.forbidden });
    };
    exports2.notFound = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 404, data, ctor: exports2.notFound });
    };
    exports2.methodNotAllowed = function(messageOrError, data, allow) {
      const err = new exports2.Boom(messageOrError, { statusCode: 405, data, ctor: exports2.methodNotAllowed });
      if (typeof allow === "string") {
        allow = [allow];
      }
      if (Array.isArray(allow)) {
        err.output.headers.Allow = allow.join(", ");
      }
      return err;
    };
    exports2.notAcceptable = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 406, data, ctor: exports2.notAcceptable });
    };
    exports2.proxyAuthRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 407, data, ctor: exports2.proxyAuthRequired });
    };
    exports2.clientTimeout = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 408, data, ctor: exports2.clientTimeout });
    };
    exports2.conflict = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 409, data, ctor: exports2.conflict });
    };
    exports2.resourceGone = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 410, data, ctor: exports2.resourceGone });
    };
    exports2.lengthRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 411, data, ctor: exports2.lengthRequired });
    };
    exports2.preconditionFailed = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 412, data, ctor: exports2.preconditionFailed });
    };
    exports2.entityTooLarge = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 413, data, ctor: exports2.entityTooLarge });
    };
    exports2.uriTooLong = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 414, data, ctor: exports2.uriTooLong });
    };
    exports2.unsupportedMediaType = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 415, data, ctor: exports2.unsupportedMediaType });
    };
    exports2.rangeNotSatisfiable = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 416, data, ctor: exports2.rangeNotSatisfiable });
    };
    exports2.expectationFailed = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 417, data, ctor: exports2.expectationFailed });
    };
    exports2.teapot = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 418, data, ctor: exports2.teapot });
    };
    exports2.badData = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 422, data, ctor: exports2.badData });
    };
    exports2.locked = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 423, data, ctor: exports2.locked });
    };
    exports2.failedDependency = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 424, data, ctor: exports2.failedDependency });
    };
    exports2.tooEarly = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 425, data, ctor: exports2.tooEarly });
    };
    exports2.preconditionRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 428, data, ctor: exports2.preconditionRequired });
    };
    exports2.tooManyRequests = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 429, data, ctor: exports2.tooManyRequests });
    };
    exports2.illegal = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, { statusCode: 451, data, ctor: exports2.illegal });
    };
    exports2.internal = function(message, data, statusCode = 500) {
      return internals.serverError(message, data, statusCode, exports2.internal);
    };
    exports2.notImplemented = function(message, data) {
      return internals.serverError(message, data, 501, exports2.notImplemented);
    };
    exports2.badGateway = function(message, data) {
      return internals.serverError(message, data, 502, exports2.badGateway);
    };
    exports2.serverUnavailable = function(message, data) {
      return internals.serverError(message, data, 503, exports2.serverUnavailable);
    };
    exports2.gatewayTimeout = function(message, data) {
      return internals.serverError(message, data, 504, exports2.gatewayTimeout);
    };
    exports2.badImplementation = function(message, data) {
      const err = internals.serverError(message, data, 500, exports2.badImplementation);
      err.isDeveloperError = true;
      return err;
    };
    internals.initialize = function(err, statusCode, message) {
      const numberCode = parseInt(statusCode, 10);
      Hoek.assert(!isNaN(numberCode) && numberCode >= 400, "First argument must be a number (400+):", statusCode);
      err.isBoom = true;
      err.isServer = numberCode >= 500;
      if (!err.hasOwnProperty("data")) {
        err.data = null;
      }
      err.output = {
        statusCode: numberCode,
        payload: {},
        headers: {}
      };
      Object.defineProperty(err, "reformat", { value: internals.reformat, configurable: true });
      if (!message && !err.message) {
        err.reformat();
        message = err.output.payload.error;
      }
      if (message) {
        const props = Object.getOwnPropertyDescriptor(err, "message") || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), "message");
        Hoek.assert(!props || props.configurable && !props.get, "The error is not compatible with boom");
        err.message = message + (err.message ? ": " + err.message : "");
        err.output.payload.message = err.message;
      }
      err.reformat();
      return err;
    };
    internals.reformat = function(debug = false) {
      this.output.payload.statusCode = this.output.statusCode;
      this.output.payload.error = internals.codes.get(this.output.statusCode) || "Unknown";
      if (this.output.statusCode === 500 && debug !== true) {
        this.output.payload.message = "An internal server error occurred";
      } else if (this.message) {
        this.output.payload.message = this.message;
      }
    };
    internals.serverError = function(messageOrError, data, statusCode, ctor) {
      if (data instanceof Error && !data.isBoom) {
        return exports2.boomify(data, { statusCode, message: messageOrError });
      }
      return new exports2.Boom(messageOrError, { statusCode, data, ctor });
    };
  }
});
var require_lib7 = __commonJS({
  "node_modules/.deno/@hapi+bounce@3.0.2/node_modules/@hapi/bounce/lib/index.js"(exports2) {
    "use strict";
    var Assert = __require2("assert");
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var internals = {
      system: [
        // JavaScript
        EvalError,
        RangeError,
        ReferenceError,
        SyntaxError,
        TypeError,
        URIError,
        // Node
        Assert.AssertionError,
        // Hoek
        Hoek.AssertError
      ]
    };
    exports2.rethrow = function(err, types, options3 = {}) {
      return internals.catch(err, types, options3, true);
    };
    exports2.ignore = function(err, types, options3 = {}) {
      return internals.catch(err, types, options3, false);
    };
    internals.catch = function(err, types, options3, match) {
      if (internals.match(err, types) !== match) {
        return;
      }
      if (options3.override) {
        err = options3.override;
      }
      if (options3.decorate) {
        Object.assign(err, options3.decorate);
      }
      if (options3.return) {
        return err;
      }
      throw err;
    };
    exports2.background = async function(operation, action = "rethrow", types = "system", options3 = {}) {
      try {
        if (typeof operation === "function") {
          await operation();
        } else {
          await operation;
        }
      } catch (err) {
        return exports2[action](err, types, options3);
      }
    };
    exports2.isBoom = function(err) {
      return Boom5.isBoom(err);
    };
    exports2.isError = function(err) {
      return err instanceof Error;
    };
    exports2.isSystem = function(err) {
      if (!err) {
        return false;
      }
      if (err.isBoom) {
        return false;
      }
      for (const system of internals.system) {
        if (err instanceof system) {
          return true;
        }
      }
      return false;
    };
    internals.rules = {
      system: exports2.isSystem,
      boom: exports2.isBoom
    };
    internals.match = function(err, types) {
      if (!types) {
        return true;
      }
      types = Array.isArray(types) ? types : [types];
      for (const type of types) {
        if (typeof type === "string") {
          if (internals.rules[type](err)) {
            return true;
          }
        } else if (typeof type === "object") {
          if (Hoek.contain(err, type, { deep: true, part: true })) {
            return true;
          }
        } else if (err instanceof type) {
          return true;
        }
      }
      return false;
    };
  }
});
var require_lib8 = __commonJS({
  "node_modules/.deno/@hapi+somever@4.1.1/node_modules/@hapi/somever/lib/index.js"(exports2) {
    "use strict";
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {
      maxLength: 256,
      wildcards: ["x", "X", "*"],
      any: Symbol("any")
    };
    internals.versionRx = /^\s*[vV]?(\d+|[xX*])(?:\.(\d+|[xX*])(?:\.(\d+|[xX*])(?:\-?([^+]+))?(?:\+(.+))?)?)?\s*$/;
    internals.strict = {
      tokenRx: /^[-\dA-Za-z]+(?:\.[-\dA-Za-z]+)*$/,
      numberRx: /^((?:0)|(?:[1-9]\d*))$/
    };
    exports2.version = function(version4, options3) {
      return new internals.Version(version4, options3);
    };
    exports2.range = function(range) {
      return new internals.Range(range);
    };
    exports2.match = function(version4, range, options3) {
      try {
        return exports2.range(range).match(version4, options3);
      } catch (err) {
        Bounce.rethrow(err, "system");
        return false;
      }
    };
    exports2.compare = function(a, b, options3 = {}) {
      let aFirst = -1;
      let bFirst = 1;
      a = exports2.version(a, options3);
      b = exports2.version(b, options3);
      if (options3.range && !options3.includePrerelease && a.prerelease.length && (a.major !== b.major || a.minor !== b.minor || a.patch !== b.patch || !b.prerelease.length)) {
        aFirst = -2;
        bFirst = 2;
      }
      for (let i2 = 0; i2 < 3; ++i2) {
        const av = a.dots[i2];
        const bv = b.dots[i2];
        if (av === bv || av === internals.any || // Wildcard is equal to everything
        bv === internals.any) {
          continue;
        }
        return av - bv < 0 ? aFirst : bFirst;
      }
      if (!a.prerelease.length && !b.prerelease.length) {
        return 0;
      } else if (!b.prerelease.length) {
        return options3.includePrerelease && b.patch === internals.any ? 0 : aFirst;
      } else if (!a.prerelease.length) {
        return options3.includePrerelease && a.patch === internals.any ? 0 : bFirst;
      }
      for (let i2 = 0; ; ++i2) {
        const ai = a.prerelease[i2];
        const bi = b.prerelease[i2];
        if (ai === void 0 && bi === void 0) {
          return 0;
        }
        if (ai === bi) {
          continue;
        }
        if (ai === void 0) {
          return aFirst;
        }
        if (bi === void 0) {
          return bFirst;
        }
        const an = Number.isFinite(ai);
        const bn = Number.isFinite(bi);
        if (an !== bn) {
          return an ? aFirst : bFirst;
        }
        return ai < bi ? aFirst : bFirst;
      }
    };
    internals.Version = class {
      constructor(version4, options3 = {}) {
        Hoek.assert(version4, "Missing version argument");
        if (version4 instanceof internals.Version) {
          return version4;
        }
        if (typeof version4 === "object") {
          this._copy(version4);
        } else {
          this._parse(version4, options3);
        }
        this.format();
      }
      _copy(version4) {
        this.major = version4.major === void 0 ? internals.any : version4.major;
        this.minor = version4.minor === void 0 ? internals.any : version4.minor;
        this.patch = version4.patch === void 0 ? internals.any : version4.patch;
        this.prerelease = version4.prerelease ?? [];
        this.build = version4.build ?? [];
      }
      _parse(version4, options3) {
        Hoek.assert(typeof version4 === "string", "Version argument must be a string");
        Hoek.assert(version4.length <= internals.maxLength, "Version string too long");
        const match = version4.match(internals.versionRx);
        if (!match) {
          throw new Error(`Invalid version string format: ${version4}`);
        }
        this.major = internals.Version._number(match[1], "major", options3);
        this.minor = internals.Version._number(match[2] || "x", "minor", options3);
        this.patch = internals.Version._number(match[3] || "x", "patch", options3);
        this.prerelease = internals.Version._sub(match[4], "prerelease", options3);
        this.build = internals.Version._sub(match[5], "build", options3);
      }
      static _number(string3, source, options3) {
        if (internals.wildcards.includes(string3)) {
          return internals.any;
        }
        if (options3.strict) {
          Hoek.assert(string3.match(internals.strict.numberRx), "Value must be 0 or a number without a leading zero:", source);
        }
        const value = parseInt(string3, 10);
        Hoek.assert(value <= Number.MAX_SAFE_INTEGER, "Value must be positive and less than max safe integer:", source);
        return value;
      }
      static _sub(string3, source, options3) {
        if (!string3) {
          return [];
        }
        if (options3.strict) {
          Hoek.assert(string3.match(internals.strict.tokenRx), "Value can only contain dot-separated hyphens, digits, a-z or A-Z:", source);
        }
        const subs = [];
        const parts = string3.split(".");
        for (const part of parts) {
          if (!part) {
            throw new Error(`Invalid empty ${source} segment`);
          }
          subs.push(part.match(/^\d+$/) ? internals.Version._number(part, source, { strict: options3.strict }) : part);
        }
        return subs;
      }
      format() {
        this.version = `${internals.dot(this.major)}.${internals.dot(this.minor)}.${internals.dot(this.patch)}${internals.token(this.prerelease, "-")}${internals.token(this.build, "+")}`;
        this.dots = [this.major, this.minor, this.patch];
        this.wildcard = this.major === internals.any && this.minor === internals.any && this.patch === internals.any && !this.prerelease.length;
      }
      toString() {
        return this.version;
      }
      compare(to, options3) {
        return internals.Version.compare(this, to, options3);
      }
      static compare(a, b, options3 = {}) {
        return exports2.compare(a, b, options3);
      }
    };
    internals.dot = (v2) => {
      return v2 === internals.any ? "x" : v2;
    };
    internals.token = (v2, prefix) => {
      if (!v2.length) {
        return "";
      }
      return `${prefix}${v2.join(".")}`;
    };
    internals.Range = class {
      constructor(range, options3) {
        this._settings = Object.assign({}, options3);
        this._anything = false;
        this._or = [];
        this._active = null;
        if (range !== void 0) {
          this.pattern(range);
        }
        this._another();
      }
      _another() {
        if (!this._active || this._active.rules.length) {
          this._active = { rules: [] };
          this._or.push(this._active);
        }
        return this;
      }
      _rule(operator, version4) {
        version4 = exports2.version(version4, this._settings);
        const compare = internals.operator(operator);
        this._active.rules.push({ compare, version: version4, operator });
        return this;
      }
      get or() {
        return this._another();
      }
      equal(version4) {
        return this._rule("=", version4);
      }
      above(version4) {
        return this._rule(">", version4);
      }
      below(version4) {
        return this._rule("<", version4);
      }
      between(from6, to) {
        this._rule(">=", from6);
        this._rule("<=", to);
        return this;
      }
      minor(version4) {
        version4 = exports2.version(version4, this._settings);
        if (version4.major === internals.any) {
          this._rule("=", version4);
          return this;
        }
        this._rule(">=", version4);
        if (version4.minor === internals.any) {
          this._rule("<", { major: version4.major + 1, minor: 0, patch: 0, prerelease: [0] });
        } else {
          this._rule("<", { major: version4.major, minor: version4.minor + 1, patch: 0, prerelease: [0] });
        }
        return this;
      }
      compatible(version4) {
        version4 = exports2.version(version4, this._settings);
        if (version4.major === internals.any) {
          this._rule("=", version4);
          return this;
        }
        this._rule(">=", version4);
        if (version4.major === 0 && version4.minor !== internals.any) {
          if (version4.minor === 0) {
            this._rule("<", { major: 0, minor: 0, patch: version4.patch + 1, prerelease: [0] });
          } else {
            this._rule("<", { major: 0, minor: version4.minor + 1, patch: 0, prerelease: [0] });
          }
        } else {
          this._rule("<", { major: version4.major + 1, minor: 0, patch: 0, prerelease: [0] });
        }
        return this;
      }
      pattern(range) {
        try {
          this._pattern(range);
          return this;
        } catch (err) {
          throw new Error(`Invalid range: "${range}" because: ${err.message}`);
        }
      }
      _pattern(range) {
        if (range === "") {
          this._anything = true;
          return;
        }
        const normalized = internals.normalize(range);
        const ors = normalized.split(/\s*\|\|\s*/);
        for (const condition of ors) {
          if (!condition) {
            this._anything = true;
            return;
          }
          this._another();
          const ands = condition.split(/\s+/);
          for (const and of ands) {
            const hyphen = and.indexOf("@");
            if (hyphen !== -1) {
              const from6 = and.slice(0, hyphen);
              const to = and.slice(hyphen + 1);
              this.between(from6, to);
              continue;
            }
            const parts = and.match(/^(\^|~|<\=|>\=|<|>|\=)?(.+)$/);
            const operator = parts[1];
            const version4 = exports2.version(parts[2], this._settings);
            if (version4.wildcard) {
              this._anything = true;
              return;
            }
            if (operator === "~") {
              this.minor(version4);
              continue;
            }
            if (operator === "^") {
              this.compatible(version4);
              continue;
            }
            if (operator) {
              this._rule(operator, version4);
              continue;
            }
            this.equal(version4);
          }
        }
      }
      match(version4, options3 = {}) {
        version4 = exports2.version(version4, this._settings);
        if (this._anything) {
          return !!options3.includePrerelease || !version4.prerelease.length;
        }
        for (const { rules } of this._or) {
          if (!rules.length) {
            continue;
          }
          let matches = 0;
          let excludes = 0;
          for (const rule of rules) {
            const compare = version4.compare(rule.version, Object.assign(this._settings, options3, { range: true }));
            const exclude = Math.abs(compare) === 2;
            if (rule.compare.includes(compare / (exclude ? 2 : 1))) {
              ++matches;
              if (exclude) {
                ++excludes;
              }
            } else {
              break;
            }
          }
          if (matches === rules.length && excludes < matches) {
            return true;
          }
        }
        return false;
      }
      toString() {
        if (this._anything) {
          return "*";
        }
        let string3 = "";
        for (const { rules } of this._or) {
          if (!rules.length) {
            continue;
          }
          const conditions = [];
          for (const rule of rules) {
            conditions.push(`${rule.operator !== "=" ? rule.operator : ""}${rule.version.version}`);
          }
          string3 += (string3 ? "||" : "") + conditions.join(" ");
        }
        return string3;
      }
    };
    internals.operator = function(compare) {
      switch (compare) {
        case "=":
          return [0];
        case ">":
          return [1];
        case ">=":
          return [0, 1];
        case "<":
          return [-1];
        case "<=":
          return [0, -1];
      }
    };
    internals.normalize = function(range) {
      return range.replace(/ \- /g, "@").replace(/~>/g, "~").replace(/(\^|~|<\=|>\=|<|>|\=)\s*([^\s]+)/g, ($0, $1, $2) => `${$1}${$2}`);
    };
  }
});
var require_config = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/config.js"(exports2) {
    "use strict";
    var Os = __require2("os");
    var Somever = require_lib8();
    var Validate = require_lib3();
    var internals = {};
    exports2.symbol = Symbol("hapi-response");
    exports2.apply = function(type, options3, ...message) {
      const result = internals[type].validate(options3);
      if (result.error) {
        throw new Error(`Invalid ${type} options ${message.length ? "(" + message.join(" ") + ")" : ""} ${result.error.annotate()}`);
      }
      return result.value;
    };
    exports2.enable = function(options3) {
      const settings = options3 ? Object.assign({}, options3) : {};
      if (settings.security === true) {
        settings.security = {};
      }
      if (settings.cors === true) {
        settings.cors = {};
      }
      return settings;
    };
    exports2.versionMatch = (version4, range) => Somever.match(version4, range, { includePrerelease: true });
    internals.access = Validate.object({
      entity: Validate.valid("user", "app", "any"),
      scope: [false, Validate.array().items(Validate.string()).single().min(1)]
    });
    internals.auth = Validate.alternatives([
      Validate.string(),
      internals.access.keys({
        mode: Validate.valid("required", "optional", "try"),
        strategy: Validate.string(),
        strategies: Validate.array().items(Validate.string()).min(1),
        access: Validate.array().items(internals.access.min(1)).single().min(1),
        payload: [
          Validate.valid("required", "optional"),
          Validate.boolean()
        ]
      }).without("strategy", "strategies").without("access", ["scope", "entity"])
    ]);
    internals.event = Validate.object({
      method: Validate.array().items(Validate.function()).single(),
      options: Validate.object({
        before: Validate.array().items(Validate.string()).single(),
        after: Validate.array().items(Validate.string()).single(),
        bind: Validate.any(),
        sandbox: Validate.valid("server", "plugin"),
        timeout: Validate.number().integer().min(1)
      }).default({})
    });
    internals.exts = Validate.array().items(internals.event.keys({ type: Validate.string().required() })).single();
    internals.failAction = Validate.alternatives([
      Validate.valid("error", "log", "ignore"),
      Validate.function()
    ]).default("error");
    internals.routeBase = Validate.object({
      app: Validate.object().allow(null),
      auth: internals.auth.allow(false),
      bind: Validate.object().allow(null),
      cache: Validate.object({
        expiresIn: Validate.number(),
        expiresAt: Validate.string(),
        privacy: Validate.valid("default", "public", "private"),
        statuses: Validate.array().items(Validate.number().integer().min(200)).min(1).single().default([200, 204]),
        otherwise: Validate.string().default("no-cache")
      }).allow(false).default(),
      compression: Validate.object().pattern(/.+/, Validate.object()).default(),
      cors: Validate.object({
        origin: Validate.array().min(1).allow("ignore").default(["*"]),
        maxAge: Validate.number().default(86400),
        headers: Validate.array().items(Validate.string()).default(["Accept", "Authorization", "Content-Type", "If-None-Match"]),
        additionalHeaders: Validate.array().items(Validate.string()).default([]),
        exposedHeaders: Validate.array().items(Validate.string()).default(["WWW-Authenticate", "Server-Authorization"]),
        additionalExposedHeaders: Validate.array().items(Validate.string()).default([]),
        credentials: Validate.boolean().when("origin", { is: "ignore", then: false }).default(false),
        preflightStatusCode: Validate.valid(200, 204).default(200)
      }).allow(false, true).default(false),
      ext: Validate.object({
        onPreAuth: Validate.array().items(internals.event).single(),
        onCredentials: Validate.array().items(internals.event).single(),
        onPostAuth: Validate.array().items(internals.event).single(),
        onPreHandler: Validate.array().items(internals.event).single(),
        onPostHandler: Validate.array().items(internals.event).single(),
        onPreResponse: Validate.array().items(internals.event).single(),
        onPostResponse: Validate.array().items(internals.event).single()
      }).default({}),
      files: Validate.object({
        relativeTo: Validate.string().pattern(/^([\/\.])|([A-Za-z]:\\)|(\\\\)/).default(".")
      }).default(),
      json: Validate.object({
        replacer: Validate.alternatives(Validate.function(), Validate.array()).allow(null).default(null),
        space: Validate.number().allow(null).default(null),
        suffix: Validate.string().allow(null).default(null),
        escape: Validate.boolean().default(false)
      }).default(),
      log: Validate.object({
        collect: Validate.boolean().default(false)
      }).default(),
      payload: Validate.object({
        output: Validate.valid("data", "stream", "file").default("data"),
        parse: Validate.boolean().allow("gunzip").default(true),
        multipart: Validate.object({
          output: Validate.valid("data", "stream", "file", "annotated").required()
        }).default(false).allow(true, false),
        allow: Validate.array().items(Validate.string()).single(),
        override: Validate.string(),
        protoAction: Validate.valid("error", "remove", "ignore").default("error"),
        maxBytes: Validate.number().integer().positive().default(1024 * 1024),
        maxParts: Validate.number().integer().positive().default(1e3),
        uploads: Validate.string().default(Os.tmpdir()),
        failAction: internals.failAction,
        timeout: Validate.number().integer().positive().allow(false).default(10 * 1e3),
        defaultContentType: Validate.string().default("application/json"),
        compression: Validate.object().pattern(/.+/, Validate.object()).default()
      }).default(),
      plugins: Validate.object(),
      response: Validate.object({
        disconnectStatusCode: Validate.number().integer().min(400).default(499),
        emptyStatusCode: Validate.valid(200, 204).default(204),
        failAction: internals.failAction,
        modify: Validate.boolean(),
        options: Validate.object(),
        ranges: Validate.boolean().default(true),
        sample: Validate.number().min(0).max(100).when("modify", { then: Validate.forbidden() }),
        schema: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false),
        status: Validate.object().pattern(/\d\d\d/, Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false))
      }).default(),
      security: Validate.object({
        hsts: Validate.alternatives([
          Validate.object({
            maxAge: Validate.number(),
            includeSubdomains: Validate.boolean(),
            includeSubDomains: Validate.boolean(),
            preload: Validate.boolean()
          }),
          Validate.boolean(),
          Validate.number()
        ]).default(15768e3),
        xframe: Validate.alternatives([
          Validate.boolean(),
          Validate.valid("sameorigin", "deny"),
          Validate.object({
            rule: Validate.valid("sameorigin", "deny", "allow-from"),
            source: Validate.string()
          })
        ]).default("deny"),
        xss: Validate.valid("enabled", "disabled", false).default("disabled"),
        noOpen: Validate.boolean().default(true),
        noSniff: Validate.boolean().default(true),
        referrer: Validate.alternatives([
          Validate.boolean().valid(false),
          Validate.valid(
            "",
            "no-referrer",
            "no-referrer-when-downgrade",
            "unsafe-url",
            "same-origin",
            "origin",
            "strict-origin",
            "origin-when-cross-origin",
            "strict-origin-when-cross-origin"
          )
        ]).default(false)
      }).allow(null, false, true).default(false),
      state: Validate.object({
        parse: Validate.boolean().default(true),
        failAction: internals.failAction
      }).default(),
      timeout: Validate.object({
        socket: Validate.number().integer().positive().allow(false),
        server: Validate.number().integer().positive().allow(false).default(false)
      }).default(),
      validate: Validate.object({
        headers: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
        params: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
        query: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        payload: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        state: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        failAction: internals.failAction,
        errorFields: Validate.object(),
        options: Validate.object().default(),
        validator: Validate.object()
      }).default()
    });
    internals.server = Validate.object({
      address: Validate.string().hostname(),
      app: Validate.object().allow(null),
      autoListen: Validate.boolean(),
      cache: Validate.allow(null),
      // Validated elsewhere
      compression: Validate.object({
        minBytes: Validate.number().min(1).integer().default(1024)
      }).allow(false).default(),
      debug: Validate.object({
        request: Validate.array().items(Validate.string()).single().allow(false).default(["implementation"]),
        log: Validate.array().items(Validate.string()).single().allow(false)
      }).allow(false).default(),
      host: Validate.string().hostname().allow(null),
      info: Validate.object({
        remote: Validate.boolean().default(false)
      }).default({}),
      listener: Validate.any(),
      load: Validate.object({
        sampleInterval: Validate.number().integer().min(0).default(0)
      }).unknown().default(),
      mime: Validate.object().empty(null).default(),
      operations: Validate.object({
        cleanStop: Validate.boolean().default(true)
      }).default(),
      plugins: Validate.object(),
      port: Validate.alternatives([
        Validate.number().integer().min(0),
        // TCP port
        Validate.string().pattern(/\//),
        // Unix domain socket
        Validate.string().pattern(/^\\\\\.\\pipe\\/)
        // Windows named pipe
      ]).allow(null),
      query: Validate.object({
        parser: Validate.function()
      }).default(),
      router: Validate.object({
        isCaseSensitive: Validate.boolean().default(true),
        stripTrailingSlash: Validate.boolean().default(false)
      }).default(),
      routes: internals.routeBase.default(),
      state: Validate.object(),
      // Cookie defaults
      tls: Validate.alternatives([
        Validate.object().allow(null),
        Validate.boolean()
      ]),
      uri: Validate.string().pattern(/[^/]$/)
    });
    internals.vhost = Validate.alternatives([
      Validate.string().hostname(),
      Validate.array().items(Validate.string().hostname()).min(1)
    ]);
    internals.handler = Validate.alternatives([
      Validate.function(),
      Validate.object().length(1)
    ]);
    internals.route = Validate.object({
      method: Validate.string().pattern(/^[a-zA-Z0-9!#\$%&'\*\+\-\.^_`\|~]+$/).required(),
      path: Validate.string().required(),
      rules: Validate.object(),
      vhost: internals.vhost,
      // Validated in route construction
      handler: Validate.any(),
      options: Validate.any(),
      config: Validate.any()
      // Backwards compatibility
    }).without("config", "options");
    internals.pre = [
      Validate.function(),
      Validate.object({
        method: Validate.alternatives(Validate.string(), Validate.function()).required(),
        assign: Validate.string(),
        mode: Validate.valid("serial", "parallel"),
        failAction: internals.failAction
      })
    ];
    internals.routeConfig = internals.routeBase.keys({
      description: Validate.string(),
      id: Validate.string(),
      isInternal: Validate.boolean(),
      notes: [
        Validate.string(),
        Validate.array().items(Validate.string())
      ],
      pre: Validate.array().items(...internals.pre.concat(Validate.array().items(...internals.pre).min(1))),
      tags: [
        Validate.string(),
        Validate.array().items(Validate.string())
      ]
    });
    internals.cacheConfig = Validate.alternatives([
      Validate.function(),
      Validate.object({
        name: Validate.string().invalid("_default"),
        shared: Validate.boolean(),
        provider: [
          Validate.function(),
          {
            constructor: Validate.function().required(),
            options: Validate.object({
              partition: Validate.string().default("hapi-cache")
            }).unknown().default({})
          }
        ],
        engine: Validate.object()
      }).xor("provider", "engine")
    ]);
    internals.cache = Validate.array().items(internals.cacheConfig).min(1).single();
    internals.cachePolicy = Validate.object({
      cache: Validate.string().allow(null).allow(""),
      segment: Validate.string(),
      shared: Validate.boolean()
    }).unknown();
    internals.method = Validate.object({
      bind: Validate.object().allow(null),
      generateKey: Validate.function(),
      cache: internals.cachePolicy
    });
    internals.methodObject = Validate.object({
      name: Validate.string().required(),
      method: Validate.function().required(),
      options: Validate.object()
    });
    internals.register = Validate.object({
      once: true,
      routes: Validate.object({
        prefix: Validate.string().pattern(/^\/.+/),
        vhost: internals.vhost
      }).default({})
    });
    internals.semver = Validate.string();
    internals.plugin = internals.register.keys({
      options: Validate.any(),
      plugin: Validate.object({
        register: Validate.function().required(),
        name: Validate.string().when("pkg.name", { is: Validate.exist(), otherwise: Validate.required() }),
        version: Validate.string(),
        multiple: Validate.boolean().default(false),
        dependencies: [
          Validate.array().items(Validate.string()).single(),
          Validate.object().pattern(/.+/, internals.semver)
        ],
        once: true,
        requirements: Validate.object({
          hapi: Validate.string(),
          node: Validate.string()
        }).default(),
        pkg: Validate.object({
          name: Validate.string(),
          version: Validate.string().default("0.0.0")
        }).unknown().default({})
      }).unknown()
    }).without("once", "options").unknown();
    internals.rules = Validate.object({
      validate: Validate.object({
        schema: Validate.alternatives(Validate.object(), Validate.array()).required(),
        options: Validate.object().default({ allowUnknown: true })
      })
    });
  }
});
var require_decode = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/decode.js"(exports2) {
    "use strict";
    var internals = {};
    exports2.decode = function(string3) {
      let percentPos = string3.indexOf("%");
      if (percentPos === -1) {
        return string3;
      }
      let decoded = "";
      let last = 0;
      let codepoint = 0;
      let startOfOctets = percentPos;
      let state = internals.utf8.accept;
      while (percentPos > -1 && percentPos < string3.length) {
        const high = internals.resolveHex(string3[percentPos + 1], 4);
        const low = internals.resolveHex(string3[percentPos + 2], 0);
        const byte = high | low;
        const type = internals.utf8.data[byte];
        state = internals.utf8.data[256 + state + type];
        codepoint = codepoint << 6 | byte & internals.utf8.data[364 + type];
        if (state === internals.utf8.accept) {
          decoded += string3.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
          codepoint = 0;
          last = percentPos + 3;
          percentPos = string3.indexOf("%", last);
          startOfOctets = percentPos;
          continue;
        }
        if (state === internals.utf8.reject) {
          return null;
        }
        percentPos += 3;
        if (percentPos >= string3.length || string3[percentPos] !== "%") {
          return null;
        }
      }
      return decoded + string3.slice(last);
    };
    internals.resolveHex = function(char, shift) {
      const i2 = internals.hex[char];
      return i2 === void 0 ? 255 : i2 << shift;
    };
    internals.hex = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    internals.utf8 = {
      accept: 12,
      reject: 0,
      data: [
        // Maps bytes to character to a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // Maps a state to a new state when adding a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // Maps the current transition to a mask that needs to apply to the byte
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ]
    };
  }
});
var require_regex = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/regex.js"(exports2) {
    "use strict";
    exports2.generate = function() {
      const empty4 = "(?:^\\/$)";
      const legalChars = "[\\w\\!\\$&'\\(\\)\\*\\+\\,;\\=\\:@\\-\\.~]";
      const encoded = "%[A-F0-9]{2}";
      const literalChar = "(?:" + legalChars + "|" + encoded + ")";
      const literal = literalChar + "+";
      const literalOptional = literalChar + "*";
      const midParam = "(?:\\{\\w+(?:\\*[1-9]\\d*)?\\})";
      const endParam = "(?:\\/(?:\\{\\w+(?:(?:\\*(?:[1-9]\\d*)?)|(?:\\?))?\\})?)?";
      const partialParam = "(?:\\{\\w+\\??\\})";
      const mixedParam = "(?:(?:" + literal + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + "(?:" + literal + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + literal + ")";
      const segmentContent = "(?:" + literal + "|" + midParam + "|" + mixedParam + ")";
      const segment = "\\/" + segmentContent;
      const segments = "(?:" + segment + ")*";
      const path12 = "(?:^" + segments + endParam + "$)";
      const parseParam = "(" + literal + ")|(?:\\{(\\w+)(?:(\\*)(\\d+)?)?(\\?)?\\})";
      const expressions = {
        parseParam: new RegExp(parseParam, "g"),
        validatePath: new RegExp(empty4 + "|" + path12),
        validatePathEncoded: /%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g
      };
      return expressions;
    };
  }
});
var require_segment = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/segment.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {};
    exports2 = module2.exports = internals.Segment = function() {
      this._edge = null;
      this._fulls = null;
      this._literals = null;
      this._param = null;
      this._mixed = null;
      this._wildcard = null;
    };
    internals.Segment.prototype.add = function(segments, record) {
      const current = segments[0];
      const remaining = segments.slice(1);
      const isEdge = !remaining.length;
      const literals = [];
      let isLiteral = true;
      for (let i2 = 0; i2 < segments.length && isLiteral; ++i2) {
        isLiteral = segments[i2].literal !== void 0;
        literals.push(segments[i2].literal);
      }
      if (isLiteral) {
        this._fulls = this._fulls ?? /* @__PURE__ */ new Map();
        let literal = "/" + literals.join("/");
        if (!record.settings.isCaseSensitive) {
          literal = literal.toLowerCase();
        }
        Hoek.assert(!this._fulls.has(literal), "New route", record.path, "conflicts with existing", this._fulls.get(literal)?.record.path);
        this._fulls.set(literal, { segment: current, record });
      } else if (current.literal !== void 0) {
        this._literals = this._literals ?? /* @__PURE__ */ new Map();
        const currentLiteral = record.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase();
        if (!this._literals.has(currentLiteral)) {
          this._literals.set(currentLiteral, new internals.Segment());
        }
        this._literals.get(currentLiteral).add(remaining, record);
      } else if (current.wildcard) {
        Hoek.assert(!this._wildcard, "New route", record.path, "conflicts with existing", this._wildcard?.record.path);
        Hoek.assert(!this._param || !this._param._wildcard, "New route", record.path, "conflicts with existing", this._param?._wildcard?.record.path);
        this._wildcard = { segment: current, record };
      } else if (current.mixed) {
        this._mixed = this._mixed ?? [];
        let mixed = this._mixedLookup(current);
        if (!mixed) {
          mixed = { segment: current, node: new internals.Segment() };
          this._mixed.push(mixed);
          this._mixed.sort(internals.mixed);
        }
        if (isEdge) {
          Hoek.assert(!mixed.node._edge, "New route", record.path, "conflicts with existing", mixed.node._edge?.record.path);
          mixed.node._edge = { segment: current, record };
        } else {
          mixed.node.add(remaining, record);
        }
      } else {
        this._param = this._param ?? new internals.Segment();
        if (isEdge) {
          Hoek.assert(!this._param._edge, "New route", record.path, "conflicts with existing", this._param._edge?.record.path);
          this._param._edge = { segment: current, record };
        } else {
          Hoek.assert(!this._wildcard || !remaining[0].wildcard, "New route", record.path, "conflicts with existing", this._wildcard?.record.path);
          this._param.add(remaining, record);
        }
      }
    };
    internals.Segment.prototype._mixedLookup = function(segment) {
      for (let i2 = 0; i2 < this._mixed.length; ++i2) {
        if (internals.mixed({ segment }, this._mixed[i2]) === 0) {
          return this._mixed[i2];
        }
      }
      return null;
    };
    internals.mixed = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      const as = a.segment;
      const bs = b.segment;
      if (as.length !== bs.length) {
        return as.length > bs.length ? aFirst : bFirst;
      }
      if (as.first !== bs.first) {
        return as.first ? bFirst : aFirst;
      }
      for (let i2 = 0; i2 < as.segments.length; ++i2) {
        const am = as.segments[i2];
        const bm = bs.segments[i2];
        if (am === bm) {
          continue;
        }
        if (am.length === bm.length) {
          return am > bm ? bFirst : aFirst;
        }
        return am.length < bm.length ? bFirst : aFirst;
      }
      return 0;
    };
    internals.Segment.prototype.lookup = function(path12, segments, options3) {
      let match = null;
      if (this._fulls) {
        match = this._fulls.get(options3.isCaseSensitive ? path12 : path12.toLowerCase());
        if (match) {
          return { record: match.record, array: [] };
        }
      }
      const current = segments[0];
      const nextPath = path12.slice(current.length + 1);
      const remainder = segments.length > 1 ? segments.slice(1) : null;
      if (this._literals) {
        const literal = options3.isCaseSensitive ? current : current.toLowerCase();
        match = this._literals.get(literal);
        if (match) {
          const record = internals.deeper(match, nextPath, remainder, [], options3);
          if (record) {
            return record;
          }
        }
      }
      if (this._mixed) {
        for (let i2 = 0; i2 < this._mixed.length; ++i2) {
          match = this._mixed[i2];
          const params = current.match(match.segment.mixed);
          if (params) {
            const array2 = [];
            for (let j = 1; j < params.length; ++j) {
              array2.push(params[j]);
            }
            const record = internals.deeper(match.node, nextPath, remainder, array2, options3);
            if (record) {
              return record;
            }
          }
        }
      }
      if (this._param) {
        if (current || this._param._edge?.segment.empty) {
          const record = internals.deeper(this._param, nextPath, remainder, [current], options3);
          if (record) {
            return record;
          }
        }
      }
      if (this._wildcard) {
        return { record: this._wildcard.record, array: [path12.slice(1)] };
      }
      return null;
    };
    internals.deeper = function(match, path12, segments, array2, options3) {
      if (!segments) {
        if (match._edge) {
          return { record: match._edge.record, array: array2 };
        }
        if (match._wildcard) {
          return { record: match._wildcard.record, array: array2 };
        }
      } else {
        const result = match.lookup(path12, segments, options3);
        if (result) {
          return { record: result.record, array: array2.concat(result.array) };
        }
      }
      return null;
    };
  }
});
var require_lib9 = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/index.js"(exports2) {
    "use strict";
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var Decode = require_decode();
    var Regex = require_regex();
    var Segment = require_segment();
    var internals = {
      pathRegex: Regex.generate(),
      defaults: {
        isCaseSensitive: true
      }
    };
    exports2.Router = internals.Router = function(options3) {
      this.settings = Hoek.applyToDefaults(internals.defaults, options3 || {});
      this.routes = /* @__PURE__ */ new Map();
      this.ids = /* @__PURE__ */ new Map();
      this.vhosts = null;
      this.specials = {
        badRequest: null,
        notFound: null,
        options: null
      };
    };
    internals.Router.prototype.add = function(config2, route2) {
      const method = config2.method.toLowerCase();
      const vhost = config2.vhost || "*";
      if (vhost !== "*") {
        this.vhosts = this.vhosts ?? /* @__PURE__ */ new Map();
        if (!this.vhosts.has(vhost)) {
          this.vhosts.set(vhost, /* @__PURE__ */ new Map());
        }
      }
      const table = vhost === "*" ? this.routes : this.vhosts.get(vhost);
      if (!table.has(method)) {
        table.set(method, { routes: [], router: new Segment() });
      }
      const analysis = config2.analysis ?? this.analyze(config2.path);
      const record = {
        path: config2.path,
        route: route2 || config2.path,
        segments: analysis.segments,
        params: analysis.params,
        fingerprint: analysis.fingerprint,
        settings: this.settings
      };
      const map = table.get(method);
      map.router.add(analysis.segments, record);
      map.routes.push(record);
      map.routes.sort(internals.sort);
      const last = record.segments[record.segments.length - 1];
      if (last.empty) {
        map.router.add(analysis.segments.slice(0, -1), record);
      }
      if (config2.id) {
        Hoek.assert(!this.ids.has(config2.id), "Route id", config2.id, "for path", config2.path, "conflicts with existing path", this.ids.has(config2.id) && this.ids.get(config2.id).path);
        this.ids.set(config2.id, record);
      }
      return record;
    };
    internals.Router.prototype.special = function(type, route2) {
      Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, "Unknown special route type:", type);
      this.specials[type] = { route: route2 };
    };
    internals.Router.prototype.route = function(method, path12, hostname2) {
      const segments = path12.length === 1 ? [""] : path12.split("/").slice(1);
      const vhost = this.vhosts && hostname2 && this.vhosts.get(hostname2);
      const route2 = vhost && this._lookup(path12, segments, vhost, method) || this._lookup(path12, segments, this.routes, method) || method === "head" && vhost && this._lookup(path12, segments, vhost, "get") || method === "head" && this._lookup(path12, segments, this.routes, "get") || method === "options" && this.specials.options || vhost && this._lookup(path12, segments, vhost, "*") || this._lookup(path12, segments, this.routes, "*") || this.specials.notFound || Boom5.notFound();
      return route2;
    };
    internals.Router.prototype._lookup = function(path12, segments, table, method) {
      const set = table.get(method);
      if (!set) {
        return null;
      }
      const match = set.router.lookup(path12, segments, this.settings);
      if (!match) {
        return null;
      }
      const assignments = {};
      const array2 = [];
      for (let i2 = 0; i2 < match.array.length; ++i2) {
        const name = match.record.params[i2];
        const value = Decode.decode(match.array[i2]);
        if (value === null) {
          return this.specials.badRequest ?? Boom5.badRequest("Invalid request path");
        }
        if (assignments[name] !== void 0) {
          assignments[name] = assignments[name] + "/" + value;
        } else {
          assignments[name] = value;
        }
        if (i2 + 1 === match.array.length || // Only include the last segment of a multi-segment param
        name !== match.record.params[i2 + 1]) {
          array2.push(assignments[name]);
        }
      }
      return { params: assignments, paramsArray: array2, route: match.record.route };
    };
    internals.Router.prototype.normalize = function(path12) {
      if (path12 && path12.indexOf("%") !== -1) {
        const uppercase2 = path12.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, (encoded) => encoded.toUpperCase());
        const decoded = uppercase2.replace(/%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g, (encoded) => String.fromCharCode(parseInt(encoded.substring(1), 16)));
        path12 = decoded;
      }
      if (path12 && (path12.indexOf("/.") !== -1 || path12[0] === ".")) {
        const hasLeadingSlash = path12[0] === "/";
        const segments = path12.split("/");
        const normalized = [];
        let segment;
        for (let i2 = 0; i2 < segments.length; ++i2) {
          segment = segments[i2];
          if (segment === "..") {
            normalized.pop();
          } else if (segment !== ".") {
            normalized.push(segment);
          }
        }
        if (segment === "." || segment === "..") {
          normalized.push("");
        }
        path12 = normalized.join("/");
        if (path12[0] !== "/" && hasLeadingSlash) {
          path12 = "/" + path12;
        }
      }
      return path12;
    };
    internals.Router.prototype.analyze = function(path12) {
      Hoek.assert(internals.pathRegex.validatePath.test(path12), "Invalid path:", path12);
      Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path12), "Path cannot contain encoded non-reserved path characters:", path12);
      const pathParts = path12.split("/");
      const segments = [];
      const params = [];
      const fingers = [];
      for (let i2 = 1; i2 < pathParts.length; ++i2) {
        let segment = pathParts[i2];
        if (segment.indexOf("{") === -1) {
          segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();
          fingers.push(segment);
          segments.push({ literal: segment });
          continue;
        }
        const parts = internals.parseParams(segment);
        if (parts.length === 1) {
          const item = parts[0];
          Hoek.assert(params.indexOf(item.name) === -1, "Cannot repeat the same parameter name:", item.name, "in:", path12);
          params.push(item.name);
          if (item.wildcard) {
            if (item.count) {
              for (let j = 0; j < item.count; ++j) {
                fingers.push("?");
                segments.push({});
                if (j) {
                  params.push(item.name);
                }
              }
            } else {
              fingers.push("#");
              segments.push({ wildcard: true });
            }
          } else {
            fingers.push("?");
            segments.push({ empty: item.empty });
          }
        } else {
          const seg = {
            length: parts.length,
            first: typeof parts[0] !== "string",
            segments: []
          };
          let finger = "";
          let regex = "^";
          for (let j = 0; j < parts.length; ++j) {
            const part = parts[j];
            if (typeof part === "string") {
              finger = finger + part;
              regex = regex + Hoek.escapeRegex(part);
              seg.segments.push(part);
            } else {
              Hoek.assert(params.indexOf(part.name) === -1, "Cannot repeat the same parameter name:", part.name, "in:", path12);
              params.push(part.name);
              finger = finger + "?";
              regex = regex + "(." + (part.empty ? "*" : "+") + ")";
            }
          }
          seg.mixed = new RegExp(regex + "$", !this.settings.isCaseSensitive ? "i" : "");
          fingers.push(finger);
          segments.push(seg);
        }
      }
      return {
        segments,
        fingerprint: "/" + fingers.join("/"),
        params
      };
    };
    internals.parseParams = function(segment) {
      const parts = [];
      segment.replace(internals.pathRegex.parseParam, ($0, literal, name, wildcard, count3, empty4) => {
        if (literal) {
          parts.push(literal);
        } else {
          parts.push({
            name,
            wildcard: !!wildcard,
            count: count3 && parseInt(count3, 10),
            empty: !!empty4
          });
        }
        return "";
      });
      return parts;
    };
    internals.Router.prototype.table = function(host) {
      const result = [];
      const collect = (table) => {
        if (!table) {
          return;
        }
        for (const map of table.values()) {
          for (const record of map.routes) {
            result.push(record.route);
          }
        }
      };
      if (this.vhosts) {
        const vhosts = host ? [].concat(host) : [...this.vhosts.keys()];
        for (const vhost of vhosts) {
          collect(this.vhosts.get(vhost));
        }
      }
      collect(this.routes);
      return result;
    };
    internals.sort = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      const as = a.segments;
      const bs = b.segments;
      if (as.length !== bs.length) {
        return as.length > bs.length ? bFirst : aFirst;
      }
      for (let i2 = 0; ; ++i2) {
        if (as[i2].literal) {
          if (bs[i2].literal) {
            if (as[i2].literal === bs[i2].literal) {
              continue;
            }
            return as[i2].literal > bs[i2].literal ? bFirst : aFirst;
          }
          return aFirst;
        }
        if (bs[i2].literal) {
          return bFirst;
        }
        return as[i2].wildcard ? bFirst : aFirst;
      }
    };
  }
});
var require_client = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/client.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var Boom5 = require_lib6();
    var internals = {
      validate: Symbol("validate")
    };
    internals.defaults = {
      partition: "catbox"
    };
    module2.exports = class {
      constructor(engine, options3) {
        Hoek.assert(engine, "Missing catbox client engine");
        Hoek.assert(typeof engine === "object" && typeof engine.start === "function" || typeof engine === "function", "engine must be an engine object or engine prototype (function)");
        Hoek.assert(typeof engine === "function" || !options3, "Can only specify options with function engine config");
        const settings = Object.assign({}, internals.defaults, options3);
        Hoek.assert(settings.partition.match(/^[\w\-]+$/), "Invalid partition name:" + settings.partition);
        this.connection = typeof engine === "object" ? engine : new engine(settings);
      }
      async start() {
        await this.connection.start();
      }
      async stop() {
        await this.connection.stop();
      }
      isReady() {
        return this.connection.isReady();
      }
      validateSegmentName(name) {
        return this.connection.validateSegmentName(name);
      }
      async get(key) {
        this[internals.validate](key, null);
        if (key === null) {
          return null;
        }
        const result = await this.connection.get(key);
        if (!result || result.item === void 0 || result.item === null) {
          return null;
        }
        const now = Date.now();
        const expires = result.stored + result.ttl;
        const ttl = expires - now;
        if (ttl <= 0) {
          return null;
        }
        const cached2 = {
          item: result.item,
          stored: result.stored,
          ttl
        };
        return cached2;
      }
      async set(key, value, ttl) {
        this[internals.validate](key);
        if (ttl <= 0) {
          return;
        }
        await this.connection.set(key, value, ttl);
      }
      async drop(key) {
        this[internals.validate](key);
        await this.connection.drop(key);
      }
      [internals.validate](key, allow = {}) {
        if (!this.isReady()) {
          throw Boom5.internal("Disconnected");
        }
        const isValidKey2 = key && typeof key.id === "string" && key.segment && typeof key.segment === "string";
        if (!isValidKey2 && key !== allow) {
          throw Boom5.internal("Invalid key");
        }
      }
    };
  }
});
var require_lib10 = __commonJS({
  "node_modules/.deno/@hapi+podium@5.0.2/node_modules/@hapi/podium/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Teamwork = require_lib5();
    var Validate = require_lib3();
    var internals = {
      schema: {
        base: Validate.object({
          name: Validate.string().required(),
          clone: Validate.boolean(),
          tags: Validate.boolean(),
          spread: Validate.boolean(),
          channels: Validate.array().items(Validate.string()).single().unique().min(1).cast("set")
        })
      }
    };
    internals.schema.event = internals.schema.base.keys({
      shared: Validate.boolean()
    });
    internals.schema.listener = internals.schema.base.keys({
      listener: Validate.func().required(),
      context: Validate.object(),
      count: Validate.number().integer().min(1),
      filter: {
        tags: Validate.array().items(Validate.string()).single().unique().min(1).required(),
        all: Validate.boolean()
      }
    });
    exports2.validate = function(events) {
      const normalized = [];
      events = [].concat(events);
      for (let event of events) {
        if (typeof event === "string") {
          event = { name: event };
        }
        normalized.push(Validate.attempt(event, internals.schema.event, "Invalid event options"));
      }
      return normalized;
    };
    exports2.Podium = class {
      /** @type {Map<string,internals.EventListener>} */
      #listeners = /* @__PURE__ */ new Map();
      constructor(events, options3) {
        if (events) {
          this.registerEvent(events, options3);
        }
      }
      registerEvent(events, options3) {
        events = [].concat(events);
        for (let event of events) {
          if (typeof event === "string") {
            event = { name: event };
          }
          if (options3?.validate !== false) {
            event = Validate.attempt(event, internals.schema.event, "Invalid event options");
          }
          const name = event.name;
          if (this.#listeners.has(name)) {
            Hoek.assert(event.shared, `Event ${name} exists`);
            continue;
          }
          this.#listeners.set(name, new internals.EventListener(event));
        }
      }
      emit(criteria, data) {
        let thrownErr;
        this.#emitToEachListener(criteria, data, ([err]) => {
          thrownErr = thrownErr ?? err;
        });
        if (thrownErr) {
          throw thrownErr;
        }
      }
      async gauge(criteria, data) {
        const promises = [];
        this.#emitToEachListener(criteria, data, ([err, result]) => {
          promises.push(err ? Promise.reject(err) : result);
        });
        return await Promise.allSettled(promises);
      }
      #emitToEachListener(criteria, data, fn) {
        criteria = internals.criteria(criteria);
        const name = criteria.name;
        Hoek.assert(name, "Criteria missing event name");
        const event = this.#listeners.get(name);
        Hoek.assert(event, `Unknown event ${name}`);
        if (!event.handlers) {
          return;
        }
        Hoek.assert(!criteria.channel || typeof criteria.channel === "string", "Invalid channel name");
        Hoek.assert(!criteria.channel || !event.flags.channels || event.flags.channels.has(criteria.channel), `Unknown ${criteria.channel} channel`);
        Hoek.assert(!event.flags.spread || Array.isArray(data) || typeof data === "function", "Data must be an array for spread event");
        if (typeof criteria.tags === "string") {
          criteria = { ...criteria };
          criteria.tags = { [criteria.tags]: true };
        }
        if (criteria.tags && Array.isArray(criteria.tags)) {
          const tags = {};
          for (const tag3 of criteria.tags) {
            tags[tag3] = true;
          }
          criteria = { ...criteria };
          criteria.tags = tags;
        }
        let generated = false;
        for (const handler of event.handlers) {
          if (handler.channels && !(criteria.channel && handler.channels.has(criteria.channel))) {
            continue;
          }
          if (handler.filter) {
            if (!criteria.tags) {
              continue;
            }
            const match = Hoek.intersect(criteria.tags, handler.filter.tags, { first: !handler.filter.all });
            if (!match || handler.filter.all && match.length !== handler.filter.tags.length) {
              continue;
            }
          }
          if (handler.count) {
            --handler.count;
            if (handler.count < 1) {
              event.removeListener(handler.listener);
            }
          }
          if (!generated && typeof data === "function") {
            data = data();
            generated = true;
          }
          const update = event.flagged("clone", handler) ? Hoek.clone(data) : data;
          const args = event.flagged("spread", handler) && Array.isArray(update) ? update.slice(0) : [update];
          if (event.flagged("tags", handler) && criteria.tags) {
            args.push(criteria.tags);
          }
          try {
            if (handler.context) {
              fn([null, handler.listener.apply(handler.context, args)]);
            } else {
              fn([null, handler.listener(...args)]);
            }
          } catch (err) {
            fn([err, null]);
          }
        }
      }
      addListener(criteria, listener, context) {
        criteria = internals.criteria(criteria);
        criteria.listener = listener;
        criteria.context = context;
        if (criteria.filter && (typeof criteria.filter === "string" || Array.isArray(criteria.filter))) {
          criteria = { ...criteria };
          criteria.filter = { tags: criteria.filter };
        }
        criteria = Validate.attempt(criteria, internals.schema.listener, "Invalid event listener options");
        const name = criteria.name;
        const event = this.#listeners.get(name);
        Hoek.assert(event, `Unknown event ${name}`);
        event.addHandler(criteria);
        return this;
      }
      on(criteria, listener, context) {
        return this.addListener(criteria, listener, context);
      }
      once(criteria, listener, context) {
        criteria = { ...internals.criteria(criteria), count: 1 };
        if (listener) {
          return this.addListener(criteria, listener, context);
        }
        return new Promise((resolve8) => {
          this.addListener(criteria, (...args) => resolve8(args));
        });
      }
      few(criteria) {
        Hoek.assert(typeof criteria === "object", "Criteria must be an object");
        Hoek.assert(criteria.count, "Criteria must include a count limit");
        const team = new Teamwork.Team({ meetings: criteria.count });
        this.addListener(criteria, (...args) => team.attend(args));
        return team.work;
      }
      removeListener(name, listener) {
        Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
        Hoek.assert(typeof listener === "function", "Listener must be a function");
        this.#listeners.get(name).removeListener(listener);
        return this;
      }
      off(name, listener) {
        return this.removeListener(name, listener);
      }
      removeAllListeners(name) {
        Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
        this.#listeners.get(name).handlers = null;
        return this;
      }
      hasListeners(name) {
        Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
        return !!this.#listeners.get(name).handlers;
      }
    };
    internals.EventListener = class {
      constructor(flags8) {
        this.flags = flags8;
        this.handlers = null;
      }
      addHandler(handler) {
        Hoek.assert(!handler.channels || !this.flags.channels || Hoek.intersect(this.flags.channels, handler.channels).length === handler.channels.size, `Unknown event channels ${handler.channels && [...handler.channels].join(", ")}`);
        this.handlers = this.handlers ? [...this.handlers, handler] : [handler];
      }
      removeListener(listener) {
        const filtered = this.handlers?.filter((item) => item.listener !== listener);
        this.handlers = filtered?.length ? filtered : null;
      }
      flagged(name, handler) {
        return handler[name] ?? this.flags[name] ?? false;
      }
    };
    internals.criteria = function(criteria) {
      if (typeof criteria === "string") {
        return { name: criteria };
      }
      return criteria;
    };
  }
});
var require_pending = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/pending.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = class {
      id = null;
      timeout = null;
      count = 1;
      rule = null;
      resolve = null;
      reject = null;
      constructor(id, rule) {
        this.id = id;
        this.rule = rule;
        this.promise = new Promise((resolve8, reject) => {
          this.resolve = resolve8;
          this.reject = reject;
        });
      }
      join() {
        ++this.count;
        return this.promise;
      }
      send(err, value, cached2, report) {
        clearTimeout(this.timeout);
        if (err && !cached2) {
          this.reject(err);
          return;
        }
        if (!this.rule.getDecoratedValue) {
          this.resolve(value);
          return;
        }
        if (err) {
          report.error = err;
        }
        this.resolve({ value, cached: cached2, report });
      }
      setTimeout(fn, timeoutMs) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(fn, timeoutMs);
      }
    };
  }
});
var require_policy = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/policy.js"(exports2, module2) {
    "use strict";
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Validate = require_lib3();
    var Pending = require_pending();
    var internals = {
      day: 24 * 60 * 60 * 1e3,
      events: Podium.validate([
        { name: "error", channels: ["generate", "persist"] }
      ])
    };
    internals.schema = Validate.object({
      expiresIn: Validate.number().integer().min(1),
      expiresAt: Validate.string().regex(/^\d\d?\:\d\d$/),
      staleIn: [
        Validate.number().integer().min(1).when("expiresAt", { is: Validate.required(), then: Validate.number().max(864e5 - 1) }),
        // One day - 1 (max is inclusive)
        Validate.func()
      ],
      staleTimeout: Validate.number().integer().min(1),
      generateFunc: Validate.func(),
      generateTimeout: Validate.number().integer().min(1).allow(false),
      generateOnReadError: Validate.boolean(),
      generateIgnoreWriteError: Validate.boolean(),
      dropOnError: Validate.boolean(),
      pendingGenerateTimeout: Validate.number().integer().min(1),
      getDecoratedValue: Validate.boolean().default(false),
      // Ignored external keys (hapi)
      privacy: Validate.any(),
      cache: Validate.any(),
      segment: Validate.any(),
      shared: Validate.any()
    }).without("expiresIn", "expiresAt").with("staleIn", "generateFunc").with("generateOnReadError", "generateFunc").with("generateIgnoreWriteError", "generateFunc").with("dropOnError", "generateFunc").and("generateFunc", "generateTimeout").and("staleIn", "staleTimeout");
    exports2 = module2.exports = internals.Policy = class {
      rule = null;
      stats = {
        sets: 0,
        gets: 0,
        hits: 0,
        stales: 0,
        generates: 0,
        errors: 0
      };
      _events = null;
      _cache = null;
      _segment = null;
      _pendings = /* @__PURE__ */ new Map();
      // id -> Pending
      _pendingGenerateCall = /* @__PURE__ */ new Map();
      // id -> timer
      constructor(options3, cache3, segment) {
        this._cache = cache3;
        this.rules(options3);
        if (cache3) {
          const nameErr = cache3.validateSegmentName(segment);
          Hoek.assert(nameErr === null, "Invalid segment name: " + segment + (nameErr ? " (" + nameErr.message + ")" : ""));
          this._segment = segment;
        }
      }
      get client() {
        return this._cache;
      }
      get events() {
        if (!this._events) {
          this._events = new Podium.Podium(internals.events, { validate: false });
        }
        return this._events;
      }
      _error(source, error) {
        if (!this._events) {
          return;
        }
        this._events.emit({ name: "error", channel: source }, { source, error });
      }
      rules(options3) {
        this.rule = internals.Policy.compile(options3, !!this._cache);
      }
      async get(key) {
        ++this.stats.gets;
        if (!key || typeof key === "string") {
          key = { id: key, string: true };
        }
        let pending = this._pendings.get(key.id);
        if (pending !== void 0) {
          return pending.join();
        }
        pending = new Pending(key.id, this.rule);
        this._pendings.set(key.id, pending);
        try {
          await this._get(pending, key);
        } catch (err) {
          this._send(key, err);
        }
        return pending.promise;
      }
      async _get(pending, key) {
        const report = {};
        const timer2 = new Hoek.Bench();
        if (this._cache) {
          try {
            var cached2 = await this._cache.get({ segment: this._segment, id: key.id });
          } catch (err) {
            report.error = err;
            ++this.stats.errors;
            this._error("persist", err);
          }
        }
        report.msec = timer2.elapsed();
        if (cached2) {
          report.stored = cached2.stored;
          report.ttl = cached2.ttl;
          const staleIn = typeof this.rule.staleIn === "function" ? this.rule.staleIn(cached2.stored, cached2.ttl) : this.rule.staleIn;
          cached2.isStale = staleIn ? Date.now() - cached2.stored >= staleIn : false;
          report.isStale = cached2.isStale;
          if (cached2.isStale) {
            ++this.stats.stales;
          }
        }
        if (!this.rule.generateFunc || report.error && !this.rule.generateOnReadError) {
          this._send(key, report.error, cached2 ? cached2.item : null, cached2, report);
          return;
        }
        if (cached2 && !cached2.isStale) {
          this._send(key, null, cached2.item, cached2, report);
          return;
        }
        return Promise.race([
          pending.promise,
          this._generate(pending, key, cached2, report)
        ]);
      }
      _generate(pending, key, cached2, report) {
        if (cached2) {
          cached2.ttl = cached2.ttl - this.rule.staleTimeout;
        }
        if (cached2 && cached2.ttl > 0) {
          pending.setTimeout(() => this._send(key, null, cached2.item, cached2, report), this.rule.staleTimeout);
        } else if (this.rule.generateTimeout) {
          pending.setTimeout(() => this._send(key, Boom5.serverUnavailable(), null, null, report), this.rule.generateTimeout);
        }
        if (this._pendingGenerateCall.has(key.id)) {
          return;
        }
        ++this.stats.generates;
        if (this.rule.pendingGenerateTimeout) {
          const timeout = setTimeout(() => this._pendingGenerateCall.delete(key.id), this.rule.pendingGenerateTimeout);
          this._pendingGenerateCall.set(key.id, timeout);
        }
        return this._callGenerateFunc(key, cached2, report);
      }
      async _callGenerateFunc(key, cached2, report) {
        const flags8 = {};
        try {
          var value = await this.rule.generateFunc(key.string ? key.id : key, flags8);
        } catch (err) {
          var generateError = err;
          this._error("generate", err);
        }
        const pendingTimeout = this._pendingGenerateCall.get(key.id);
        if (pendingTimeout) {
          clearTimeout(pendingTimeout);
          this._pendingGenerateCall.delete(key.id);
        }
        try {
          if (flags8.ttl === 0 || // null or undefined means use policy
          generateError && this.rule.dropOnError) {
            await this.drop(key.id);
          } else if (!generateError) {
            await this.set(key.id, value, flags8.ttl);
          }
        } catch (err) {
          var persistError = err;
          this._error("persist", err);
        }
        const error = generateError || (this.rule.generateIgnoreWriteError ? null : persistError);
        if (cached2 && error && !this.rule.dropOnError) {
          this._send(key, error, cached2.item, cached2, report);
          return;
        }
        this._send(key, error, value, null, report);
      }
      _send(key, err, value, cached2, report) {
        const pending = this._pendings.get(key.id);
        if (!pending) {
          return;
        }
        this._pendings.delete(key.id);
        pending.send(err, value, cached2, report);
        if (report?.isStale !== void 0) {
          this.stats.hits = this.stats.hits + pending.count;
        }
      }
      async set(key, value, ttl) {
        ++this.stats.sets;
        if (!this._cache) {
          return;
        }
        try {
          await this._cache.set({ segment: this._segment, id: internals.id(key) }, value, ttl || internals.Policy.ttl(this.rule));
        } catch (err) {
          ++this.stats.errors;
          throw err;
        }
      }
      async drop(key) {
        if (!this._cache) {
          return;
        }
        try {
          await this._cache.drop({ segment: this._segment, id: internals.id(key) });
          return;
        } catch (err) {
          ++this.stats.errors;
          throw err;
        }
      }
      ttl(created) {
        return internals.Policy.ttl(this.rule, created);
      }
      isReady() {
        if (!this._cache) {
          return false;
        }
        return this._cache.connection.isReady();
      }
      static compile(options3, serverSide) {
        const rule = {};
        if (!options3 || !Object.keys(options3).length) {
          return rule;
        }
        options3 = Validate.attempt(options3, internals.schema, "Invalid cache policy configuration");
        const hasExpiresIn = options3.expiresIn !== void 0 && options3.expiresIn !== null;
        const hasExpiresAt = options3.expiresAt !== void 0 && options3.expiresAt !== null;
        Hoek.assert(!hasExpiresIn || !options3.staleIn || typeof options3.staleIn === "function" || options3.staleIn < options3.expiresIn, "staleIn must be less than expiresIn");
        Hoek.assert(!options3.staleIn || serverSide, "Cannot use stale options without server-side caching");
        Hoek.assert(!options3.staleTimeout || !hasExpiresIn || options3.staleTimeout < options3.expiresIn, "staleTimeout must be less than expiresIn");
        Hoek.assert(!options3.staleTimeout || !hasExpiresIn || typeof options3.staleIn === "function" || options3.staleTimeout < options3.expiresIn - options3.staleIn, "staleTimeout must be less than the delta between expiresIn and staleIn");
        Hoek.assert(!options3.staleTimeout || !options3.pendingGenerateTimeout || options3.staleTimeout < options3.pendingGenerateTimeout, "pendingGenerateTimeout must be greater than staleTimeout if specified");
        if (hasExpiresAt) {
          const time3 = /^(\d\d?):(\d\d)$/.exec(options3.expiresAt);
          rule.expiresAt = {
            hours: parseInt(time3[1], 10),
            minutes: parseInt(time3[2], 10)
          };
        } else {
          rule.expiresIn = options3.expiresIn ?? 0;
        }
        if (options3.generateFunc) {
          rule.generateFunc = options3.generateFunc;
          rule.generateTimeout = options3.generateTimeout;
          if (options3.staleIn) {
            rule.staleIn = options3.staleIn;
            rule.staleTimeout = options3.staleTimeout;
          }
          rule.dropOnError = options3.dropOnError !== void 0 ? options3.dropOnError : true;
          rule.pendingGenerateTimeout = options3.pendingGenerateTimeout !== void 0 ? options3.pendingGenerateTimeout : 0;
        }
        rule.generateOnReadError = options3.generateOnReadError !== void 0 ? options3.generateOnReadError : true;
        rule.generateIgnoreWriteError = options3.generateIgnoreWriteError !== void 0 ? options3.generateIgnoreWriteError : true;
        rule.getDecoratedValue = options3.getDecoratedValue;
        return rule;
      }
      static ttl(rule, created, now) {
        now = now ?? Date.now();
        created = created ?? now;
        const age = now - created;
        if (age < 0) {
          return 0;
        }
        if (rule.expiresIn) {
          return Math.max(rule.expiresIn - age, 0);
        }
        if (rule.expiresAt) {
          if (age > internals.day) {
            return 0;
          }
          const expiresAt = new Date(created);
          expiresAt.setHours(rule.expiresAt.hours);
          expiresAt.setMinutes(rule.expiresAt.minutes);
          expiresAt.setSeconds(0);
          expiresAt.setMilliseconds(0);
          let expires = expiresAt.getTime();
          if (expires <= created) {
            expires = expires + internals.day;
          }
          if (now >= expires) {
            return 0;
          }
          return expires - now;
        }
        return 0;
      }
    };
    internals.id = function(key) {
      return key && typeof key === "object" ? key.id : key;
    };
  }
});
var require_lib11 = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/index.js"(exports2) {
    "use strict";
    var Client = require_client();
    var Policy = require_policy();
    exports2.Client = Client;
    exports2.Policy = exports2.policy = Policy;
  }
});
var require_lib12 = __commonJS({
  "node_modules/.deno/@hapi+catbox-memory@6.0.2/node_modules/@hapi/catbox-memory/lib/index.js"(exports2) {
    "use strict";
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var internals = {
      maxTimer: 2147483647,
      // 2 ^ 31 - 1
      entrySize: 144
      // Approximate cache entry size without value: 144 bytes
    };
    internals.defaults = {
      maxByteSize: 100 * 1024 * 1024,
      // 100MB
      minCleanupIntervalMsec: 1e3,
      cloneBuffersOnGet: false
    };
    exports2.Engine = class CatboxMemoryEngine {
      constructor(options3 = {}) {
        Hoek.assert(options3.maxByteSize === void 0 || options3.maxByteSize >= 0, "Invalid cache maxByteSize value");
        Hoek.assert(options3.allowMixedContent === void 0, "allowMixedContent no longer supported");
        Hoek.assert(options3.minCleanupIntervalMsec === void 0 || options3.minCleanupIntervalMsec < internals.maxTimer, "Invalid cache minCleanupIntervalMsec value");
        Hoek.assert(options3.cloneBuffersOnGet === void 0 || typeof options3.cloneBuffersOnGet === "boolean", "Invalid cloneBuffersOnGet value");
        this.settings = Hoek.applyToDefaults(internals.defaults, options3);
        this.cache = null;
        this._timer = null;
        this._timerDue = null;
      }
      start() {
        if (!this.cache) {
          this.cache = /* @__PURE__ */ new Map();
          this.byteSize = 0;
        }
      }
      _scheduleCleanup(msec) {
        const cleanup = () => {
          this._timer = null;
          this._timerDue = null;
          const now2 = Date.now();
          let next = Infinity;
          for (const [, segment] of this.cache) {
            for (const [id, envelope] of segment) {
              const ttl = envelope.stored + envelope.ttl - now2;
              if (ttl <= 0) {
                segment.delete(id);
                this.byteSize -= envelope.byteSize;
              } else {
                next = Math.min(next, ttl);
              }
            }
          }
          if (next !== Infinity) {
            this._scheduleCleanup(next);
          }
        };
        const now = Date.now();
        const timeout = Math.min(Math.max(this.settings.minCleanupIntervalMsec, msec), internals.maxTimer);
        if (this._timer) {
          if (this._timerDue - now < msec) {
            return;
          }
          clearTimeout(this._timer);
        }
        this._timerDue = now + timeout;
        this._timer = setTimeout(cleanup, timeout);
      }
      stop() {
        clearTimeout(this._timer);
        this._timer = null;
        this._timerDue = null;
        this.cache = null;
        this.byteSize = 0;
      }
      isReady() {
        return !!this.cache;
      }
      validateSegmentName(name) {
        if (!name) {
          throw new Boom5.Boom("Empty string");
        }
        if (name.indexOf("\0") !== -1) {
          throw new Boom5.Boom("Includes null character");
        }
        return null;
      }
      get(key) {
        if (!this.cache) {
          throw new Boom5.Boom("Connection not started");
        }
        const segment = this.cache.get(key.segment);
        if (!segment) {
          return null;
        }
        const envelope = segment.get(key.id);
        if (!envelope) {
          return null;
        }
        if (envelope.stored + envelope.ttl < Date.now()) {
          this.drop(key);
          return null;
        }
        let item = null;
        if (Buffer.isBuffer(envelope.item)) {
          item = envelope.item;
          if (this.settings.cloneBuffersOnGet) {
            const copy2 = Buffer.alloc(item.length);
            item.copy(copy2);
            item = copy2;
          }
        } else {
          try {
            item = JSON.parse(envelope.item);
          } catch (err) {
            throw new Boom5.Boom("Bad value content");
          }
        }
        const result = {
          item,
          stored: envelope.stored,
          ttl: envelope.ttl
        };
        return result;
      }
      set(key, value, ttl) {
        if (!this.cache) {
          throw new Boom5.Boom("Connection not started");
        }
        const envelope = new internals.MemoryCacheEntry(key, value, ttl);
        let segment = this.cache.get(key.segment);
        if (!segment) {
          segment = /* @__PURE__ */ new Map();
          this.cache.set(key.segment, segment);
        }
        const cachedItem = segment.get(key.id);
        if (cachedItem) {
          this.byteSize -= cachedItem.byteSize;
        }
        if (this.settings.maxByteSize && this.byteSize + envelope.byteSize > this.settings.maxByteSize) {
          throw new Boom5.Boom("Cache size limit reached");
        }
        this._scheduleCleanup(ttl);
        segment.set(key.id, envelope);
        this.byteSize += envelope.byteSize;
      }
      drop(key) {
        if (!this.cache) {
          throw new Boom5.Boom("Connection not started");
        }
        const segment = this.cache.get(key.segment);
        if (segment) {
          const item = segment.get(key.id);
          if (item) {
            this.byteSize -= item.byteSize;
            segment.delete(key.id);
          }
        }
      }
    };
    internals.MemoryCacheEntry = class {
      constructor(key, value, ttl) {
        let valueByteSize = 0;
        if (Buffer.isBuffer(value)) {
          this.item = Buffer.alloc(value.length);
          value.copy(this.item);
          valueByteSize = this.item.length;
        } else {
          this.item = JSON.stringify(value);
          valueByteSize = Buffer.byteLength(this.item);
        }
        this.stored = Date.now();
        this.ttl = ttl;
        this.byteSize = internals.entrySize + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);
        this.timeoutId = null;
      }
    };
  }
});
var require_lib13 = __commonJS({
  "node_modules/.deno/@hapi+heavy@8.0.1/node_modules/@hapi/heavy/lib/index.js"(exports2) {
    "use strict";
    var PerfHooks = __require2("perf_hooks");
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var internals = {};
    internals.schema = Validate.object({
      sampleInterval: Validate.number().min(0),
      maxHeapUsedBytes: Validate.number().min(0),
      maxEventLoopDelay: Validate.number().min(0),
      maxEventLoopUtilization: Validate.number().min(0),
      maxRssBytes: Validate.number().min(0)
    }).unknown();
    internals.defaults = {
      sampleInterval: 0,
      // Frequency of load sampling in milliseconds (zero is no sampling)
      maxHeapUsedBytes: 0,
      // Reject requests when V8 heap is over size in bytes (zero is no max)
      maxRssBytes: 0,
      // Reject requests when process RSS is over size in bytes (zero is no max)
      maxEventLoopDelay: 0,
      // Milliseconds of delay after which requests are rejected (zero is no max)
      maxEventLoopUtilization: 0
      // Max event loop utilization value after which requests are rejected (zero is no max)
    };
    exports2.Heavy = class Heavy {
      constructor(options3) {
        options3 = options3 || {};
        Validate.assert(options3, internals.schema, "Invalid load monitoring options");
        this.settings = Hoek.applyToDefaults(internals.defaults, options3);
        Hoek.assert(this.settings.sampleInterval || !this.settings.maxEventLoopDelay && !this.settings.maxHeapUsedBytes && !this.settings.maxRssBytes && !this.settings.maxEventLoopUtilization, "Load sample interval must be set to enable load limits");
        this._eventLoopTimer = null;
        this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization();
        this._loadBench = new Hoek.Bench();
        this.load = {
          eventLoopDelay: 0,
          eventLoopUtilization: 0,
          heapUsed: 0,
          rss: 0
        };
      }
      start() {
        if (!this.settings.sampleInterval) {
          return;
        }
        const loopSample = () => {
          this._loadBench.reset();
          const measure = () => {
            const mem = process.memoryUsage();
            this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization(this._eventLoopUtilization);
            this.load.eventLoopDelay = this._loadBench.elapsed() - this.settings.sampleInterval;
            this.load.eventLoopUtilization = this._eventLoopUtilization.utilization;
            this.load.heapUsed = mem.heapUsed;
            this.load.rss = mem.rss;
            loopSample();
          };
          this._eventLoopTimer = setTimeout(measure, this.settings.sampleInterval);
        };
        loopSample();
      }
      stop() {
        clearTimeout(this._eventLoopTimer);
        this._eventLoopTimer = null;
      }
      check() {
        if (!this.settings.sampleInterval) {
          return;
        }
        Hoek.assert(this._eventLoopTimer, "Cannot check load when sampler is not started");
        const elapsed = this._loadBench.elapsed();
        const load = this.load;
        if (elapsed > this.settings.sampleInterval) {
          this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization(this._eventLoopUtilization);
          load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this.settings.sampleInterval);
          load.eventLoopUtilization = this._eventLoopUtilization.utilization;
        }
        if (this.settings.maxEventLoopDelay && load.eventLoopDelay > this.settings.maxEventLoopDelay) {
          throw Boom5.serverUnavailable("Server under heavy load (event loop)", load);
        }
        if (this.settings.maxEventLoopUtilization && load.eventLoopUtilization > this.settings.maxEventLoopUtilization) {
          throw Boom5.serverUnavailable("Server under heavy load (event loop utilization)", load);
        }
        if (this.settings.maxHeapUsedBytes && load.heapUsed > this.settings.maxHeapUsedBytes) {
          throw Boom5.serverUnavailable("Server under heavy load (heap)", load);
        }
        if (this.settings.maxRssBytes && load.rss > this.settings.maxRssBytes) {
          throw Boom5.serverUnavailable("Server under heavy load (rss)", load);
        }
      }
    };
  }
});
var require_db = __commonJS({
  "node_modules/.deno/mime-db@1.54.0/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/ace+json": {
        source: "iana",
        compressible: true
      },
      "application/ace-groupcomm+cbor": {
        source: "iana"
      },
      "application/ace-trl+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/aif+cbor": {
        source: "iana"
      },
      "application/aif+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-cdni+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-cdnifilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-propmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-propmapparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-tips+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-tipsparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/appinstaller": {
        compressible: false,
        extensions: ["appinstaller"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/appx": {
        compressible: false,
        extensions: ["appx"]
      },
      "application/appxbundle": {
        compressible: false,
        extensions: ["appxbundle"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/automationml-aml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["aml"]
      },
      "application/automationml-amlx+zip": {
        source: "iana",
        compressible: false,
        extensions: ["amlx"]
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/bufr": {
        source: "iana"
      },
      "application/c2pa": {
        source: "iana"
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/ce+cbor": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/cid-edhoc+cbor-seq": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/city+json-seq": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-eap": {
        source: "iana"
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/concise-problem-details+cbor": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cose-x509": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwl": {
        source: "iana",
        extensions: ["cwl"]
      },
      "application/cwl+json": {
        source: "iana",
        compressible: true
      },
      "application/cwl+yaml": {
        source: "iana"
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana",
        extensions: ["dcm"]
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dpop+jwt": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/eat+cwt": {
        source: "iana"
      },
      "application/eat+jwt": {
        source: "iana"
      },
      "application/eat-bun+cbor": {
        source: "iana"
      },
      "application/eat-bun+json": {
        source: "iana",
        compressible: true
      },
      "application/eat-ucs+cbor": {
        source: "iana"
      },
      "application/eat-ucs+json": {
        source: "iana",
        compressible: true
      },
      "application/ecmascript": {
        source: "apache",
        compressible: true,
        extensions: ["ecma"]
      },
      "application/edhoc+cbor-seq": {
        source: "iana"
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.legacyesn+json": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/entity-statement+jwt": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geopose+json": {
        source: "iana",
        compressible: true
      },
      "application/geoxacml+json": {
        source: "iana",
        compressible: true
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gnap-binding-jws": {
        source: "iana"
      },
      "application/gnap-binding-jwsd": {
        source: "iana"
      },
      "application/gnap-binding-rotation-jws": {
        source: "iana"
      },
      "application/gnap-binding-rotation-jwsd": {
        source: "iana"
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/grib": {
        source: "iana"
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "iana",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "apache",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/jscontact+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jsonpath": {
        source: "iana"
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+jwt": {
        source: "iana"
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/linkset": {
        source: "iana"
      },
      "application/linkset+json": {
        source: "iana",
        compressible: true
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/logout+jwt": {
        source: "iana"
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4", "mpg4", "mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msix": {
        compressible: false,
        extensions: ["msix"]
      },
      "application/msixbundle": {
        compressible: false,
        extensions: ["msixbundle"]
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: true,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/ohttp-keys": {
        source: "iana"
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["sig", "asc"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/private-token-issuer-directory": {
        source: "iana"
      },
      "application/private-token-request": {
        source: "iana"
      },
      "application/private-token-response": {
        source: "iana"
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/provided-claims+jwt": {
        source: "iana"
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.implied-document+xml": {
        source: "iana",
        compressible: true
      },
      "application/prs.implied-executable": {
        source: "iana"
      },
      "application/prs.implied-object+json": {
        source: "iana",
        compressible: true
      },
      "application/prs.implied-object+json-seq": {
        source: "iana"
      },
      "application/prs.implied-object+yaml": {
        source: "iana"
      },
      "application/prs.implied-structure": {
        source: "iana"
      },
      "application/prs.mayfile": {
        source: "iana"
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.vcfbzip2": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsf"]
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "apache"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resolve-response+jwt": {
        source: "iana"
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-checklist": {
        source: "iana"
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-signed-tal": {
        source: "iana"
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "apache"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana",
        extensions: ["sql"]
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/sslkeylogfile": {
        source: "iana"
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/st2110-41": {
        source: "iana"
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/stratum": {
        source: "iana"
      },
      "application/swid+cbor": {
        source: "iana"
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tm+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/toc+cbor": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        source: "iana",
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/trust-chain+json": {
        source: "iana",
        compressible: true
      },
      "application/trust-mark+jwt": {
        source: "iana"
      },
      "application/trust-mark-delegation+jwt": {
        source: "iana"
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/uccs+cbor": {
        source: "iana"
      },
      "application/ujcs+json": {
        source: "iana",
        compressible: true
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vc": {
        source: "iana"
      },
      "application/vc+cose": {
        source: "iana"
      },
      "application/vc+jwt": {
        source: "iana"
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.1ob": {
        source: "iana"
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3a+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ach+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc8+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsa2x": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsa2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsv2x": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsv2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.crs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.current-location-discovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.pinapp-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.seal-group-doc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-network-qos-management-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-ue-config-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-unicast-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-user-profile-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.v2x": {
        source: "iana"
      },
      "application/vnd.3gpp.vae-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acm.addressxfer+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.acm.chatbot+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "apache",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "apache"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.parquet": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.apexlang": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "apache"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autodesk.fbx": {
        extensions: ["fbx"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.belightsoft.lhzd+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.belightsoft.lhzl+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bzip3": {
        source: "iana"
      },
      "application/vnd.c3voc.schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.cncf.helm.chart.content.v1.tar+gzip": {
        source: "iana"
      },
      "application/vnd.cncf.helm.chart.provenance.v1.prov": {
        source: "iana"
      },
      "application/vnd.cncf.helm.config.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datalog": {
        source: "iana"
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.dcmp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dcmp"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.eln+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.erofs": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "apache",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.fdsn.stationxml+xml": {
        source: "iana",
        charset: "XML-BASED",
        compressible: true
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.freelog.comic": {
        source: "iana"
      },
      "application/vnd.frogans.fnc": {
        source: "apache",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "apache",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.ga4gh.passport+jwt": {
        source: "iana"
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.genozip": {
        source: "iana"
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.catmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.ebuild": {
        source: "iana"
      },
      "application/vnd.gentoo.eclass": {
        source: "iana"
      },
      "application/vnd.gentoo.gpkg": {
        source: "iana"
      },
      "application/vnd.gentoo.manifest": {
        source: "iana"
      },
      "application/vnd.gentoo.pkgmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.xpak": {
        source: "iana"
      },
      "application/vnd.geo+json": {
        source: "apache",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.pinboard": {
        source: "iana"
      },
      "application/vnd.geogebra.slides": {
        source: "iana",
        extensions: ["ggs"]
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.gnu.taler.exchange+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gnu.taler.merchant+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.google-apps.audio": {},
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.drawing": {
        compressible: false,
        extensions: ["gdraw"]
      },
      "application/vnd.google-apps.drive-sdk": {
        compressible: false
      },
      "application/vnd.google-apps.file": {},
      "application/vnd.google-apps.folder": {
        compressible: false
      },
      "application/vnd.google-apps.form": {
        compressible: false,
        extensions: ["gform"]
      },
      "application/vnd.google-apps.fusiontable": {},
      "application/vnd.google-apps.jam": {
        compressible: false,
        extensions: ["gjam"]
      },
      "application/vnd.google-apps.mail-layout": {},
      "application/vnd.google-apps.map": {
        compressible: false,
        extensions: ["gmap"]
      },
      "application/vnd.google-apps.photo": {},
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.script": {
        compressible: false,
        extensions: ["gscript"]
      },
      "application/vnd.google-apps.shortcut": {},
      "application/vnd.google-apps.site": {
        compressible: false,
        extensions: ["gsite"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-apps.unknown": {},
      "application/vnd.google-apps.video": {},
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdcf"]
      },
      "application/vnd.gpxsee.map+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.hsl": {
        source: "iana"
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "apache"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "apache",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "apache"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.ipfs.ipns-record": {
        source: "iana"
      },
      "application/vnd.ipld.car": {
        source: "iana"
      },
      "application/vnd.ipld.dag-cbor": {
        source: "iana"
      },
      "application/vnd.ipld.dag-json": {
        source: "iana"
      },
      "application/vnd.ipld.raw": {
        source: "iana"
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kdl": {
        source: "iana"
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.keyman.kmp+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.keyman.kmx": {
        source: "iana"
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.ldev.productlicensing": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.mdl": {
        source: "iana"
      },
      "application/vnd.mdl-mbsdf": {
        source: "iana"
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.medicalholodeck.recordxr": {
        source: "iana"
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mermaid": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.modl": {
        source: "iana"
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-visio.viewer": {
        extensions: ["vdx"]
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msgpack": {
        source: "iana"
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nato.bindingdataobject+cbor": {
        source: "iana"
      },
      "application/vnd.nato.bindingdataobject+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nato.bindingdataobject+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bdo"]
      },
      "application/vnd.nato.openxmlformats-package.iepd+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "apache",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oai.workflows": {
        source: "iana"
      },
      "application/vnd.oai.workflows+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oai.workflows+yaml": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.base": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "apache",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-master-template": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.onvif.metadata": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openvpi.dspx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.procrate.brushset": {
        extensions: ["brushset"]
      },
      "application/vnd.procreate.brush": {
        extensions: ["brush"]
      },
      "application/vnd.procreate.dream": {
        extensions: ["drm"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.pt.mundusmundi": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtm"]
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.relpipe": {
        source: "iana"
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sketchometry": {
        source: "iana"
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.smintio.portals.archive": {
        source: "iana"
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sybyl.mol2": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uic.osdm+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml", "uo"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veraison.tsm-report+cbor": {
        source: "iana"
      },
      "application/vnd.veraison.tsm-report+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vocalshaper.vsp4": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.wasmflow.wafl": {
        source: "iana"
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordlift": {
        source: "iana"
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xarin.cpj": {
        source: "iana"
      },
      "application/vnd.xecrets-encrypted": {
        source: "iana"
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/voucher-jws+json": {
        source: "iana",
        compressible: true
      },
      "application/vp": {
        source: "iana"
      },
      "application/vp+cose": {
        source: "iana"
      },
      "application/vp+jwt": {
        source: "iana"
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blender": {
        extensions: ["blend"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-compressed": {
        extensions: ["rar"]
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-ipynb+json": {
        compressible: true,
        extensions: ["ipynb"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zip-compressed": {
        extensions: ["zip"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yaml": {
        source: "iana"
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+cbor": {
        source: "iana"
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-sid+json": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zip+dotlottie": {
        extensions: ["lottie"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana",
        extensions: ["adts", "aac"]
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flac": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/matroska": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/midi-clip": {
        source: "iana"
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a", "m4b"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "apache"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        source: "iana",
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp", "dib"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/dpx": {
        source: "iana",
        extensions: ["dpx"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/j2c": {
        source: "iana"
      },
      "image/jaii": {
        source: "iana",
        extensions: ["jaii"]
      },
      "image/jais": {
        source: "iana",
        extensions: ["jais"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpg", "jpeg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm", "jpgm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxl": {
        source: "iana",
        extensions: ["jxl"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false,
        extensions: ["jfif"]
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif", "btf"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.clip": {
        source: "iana"
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "iana",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-adobe-dng": {
        extensions: ["dng"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-emf": {
        source: "iana"
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-wmf": {
        source: "iana"
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/bhttp": {
        source: "iana"
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/mls": {
        source: "iana"
      },
      "message/news": {
        source: "apache"
      },
      "message/ohttp-req": {
        source: "iana"
      },
      "message/ohttp-res": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime", "mht", "mhtml"]
      },
      "message/s-http": {
        source: "apache"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "apache"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/jt": {
        source: "iana",
        extensions: ["jt"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/prc": {
        source: "iana",
        extensions: ["prc"]
      },
      "model/step": {
        source: "iana",
        extensions: ["step", "stp", "stpnc", "p21", "210"]
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/u3d": {
        source: "iana",
        extensions: ["u3d"]
      },
      "model/vnd.bary": {
        source: "iana",
        extensions: ["bary"]
      },
      "model/vnd.cld": {
        source: "iana",
        extensions: ["cld"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana",
        extensions: ["pyo", "pyox"]
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usda": {
        source: "iana",
        extensions: ["usda"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "apache"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/hl7v2": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["md", "markdown"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/prs.texi": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.exchangeable": {
        source: "iana"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "apache"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.vcf": {
        source: "iana"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vnd.zoo.kcl": {
        source: "iana"
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/wgsl": {
        source: "iana",
        extensions: ["wgsl"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/evc": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/h266": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/lottie+json": {
        source: "iana",
        compressible: true
      },
      "video/matroska": {
        source: "iana"
      },
      "video/matroska-3d": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts", "m2t", "m2ts", "mts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.planar": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "apache"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});
var require_lib14 = __commonJS({
  "node_modules/.deno/@hapi+mimos@7.0.1/node_modules/@hapi/mimos/lib/index.js"(exports2) {
    "use strict";
    var Path = __require2("path");
    var Hoek = require_lib();
    var MimeDb = require_db();
    var internals = {
      compressibleRx: /^text\/|\+json$|\+text$|\+xml$/
    };
    exports2.MimosEntry = class {
      constructor(type, mime) {
        this.type = type;
        this.source = "mime-db";
        this.extensions = [];
        this.compressible = void 0;
        Object.assign(this, mime);
        if (this.compressible === void 0) {
          this.compressible = internals.compressibleRx.test(type);
        }
      }
    };
    internals.insertEntry = function(type, entry, db3) {
      db3.byType.set(type, entry);
      for (const ext of entry.extensions) {
        db3.byExtension.set(ext, entry);
        if (ext.length > db3.maxExtLength) {
          db3.maxExtLength = ext.length;
        }
      }
    };
    internals.compile = function(mimedb) {
      const db3 = {
        byType: /* @__PURE__ */ new Map(),
        byExtension: /* @__PURE__ */ new Map(),
        maxExtLength: 0
      };
      for (const type in mimedb) {
        const entry = new exports2.MimosEntry(type, mimedb[type]);
        internals.insertEntry(type, entry, db3);
      }
      return db3;
    };
    internals.getTypePart = function(fulltype) {
      const splitAt = fulltype.indexOf(";");
      return splitAt === -1 ? fulltype : fulltype.slice(0, splitAt);
    };
    internals.applyPredicate = function(mime) {
      if (mime.predicate) {
        return mime.predicate(Hoek.clone(mime));
      }
      return mime;
    };
    exports2.Mimos = class Mimos {
      #db = internals.base;
      constructor(options3 = {}) {
        if (options3.override) {
          Hoek.assert(typeof options3.override === "object", "overrides option must be an object");
          this.#db = {
            ...this.#db,
            byType: new Map(this.#db.byType),
            byExtension: new Map(this.#db.byExtension)
          };
          for (const type in options3.override) {
            const override = options3.override[type];
            Hoek.assert(!override.predicate || typeof override.predicate === "function", "predicate option must be a function");
            const from6 = this.#db.byType.get(type);
            const baseEntry = from6 ? Hoek.applyToDefaults(from6, override) : override;
            const entry = new exports2.MimosEntry(type, baseEntry);
            internals.insertEntry(type, entry, this.#db);
          }
        }
      }
      path(path12) {
        const extension = Path.extname(path12).slice(1).toLowerCase();
        const mime = this.#db.byExtension.get(extension) ?? {};
        return internals.applyPredicate(mime);
      }
      type(type) {
        type = internals.getTypePart(type);
        let mime = this.#db.byType.get(type);
        if (!mime) {
          type = type.trim().toLowerCase();
          mime = this.#db.byType.get(type);
        }
        if (!mime) {
          mime = new exports2.MimosEntry(type, {
            source: "mimos"
          });
          internals.insertEntry(type, mime, this.#db);
          return mime;
        }
        return internals.applyPredicate(mime);
      }
    };
    internals.base = internals.compile(MimeDb);
  }
});
var require_lib15 = __commonJS({
  "node_modules/.deno/@hapi+bourne@3.0.0/node_modules/@hapi/bourne/lib/index.js"(exports2) {
    "use strict";
    var internals = {
      suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
    };
    exports2.parse = function(text, ...args) {
      const firstOptions = typeof args[0] === "object" && args[0];
      const reviver = args.length > 1 || !firstOptions ? args[0] : void 0;
      const options3 = args.length > 1 && args[1] || firstOptions || {};
      const obj = JSON.parse(text, reviver);
      if (options3.protoAction === "ignore") {
        return obj;
      }
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (!text.match(internals.suspectRx)) {
        return obj;
      }
      exports2.scan(obj, options3);
      return obj;
    };
    exports2.scan = function(obj, options3 = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (options3.protoAction !== "remove") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(node[key]);
            }
          }
        }
      }
    };
    exports2.safeParse = function(text, reviver) {
      try {
        return exports2.parse(text, reviver);
      } catch (ignoreError) {
        return null;
      }
    };
  }
});
var require_lib16 = __commonJS({
  "node_modules/.deno/@hapi+cryptiles@6.0.1/node_modules/@hapi/cryptiles/lib/index.js"(exports2) {
    "use strict";
    var Crypto = __require2("crypto");
    var Boom5 = require_lib6();
    var internals = {};
    exports2.randomString = function(size) {
      const buffer = exports2.randomBits((size + 1) * 6);
      const string3 = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      return string3.slice(0, size);
    };
    exports2.randomAlphanumString = function(size) {
      let result = "";
      while (result.length < size) {
        const buffer = exports2.randomBits((size + 1) * 6);
        result += buffer.toString("base64").replace(/[^a-zA-Z0-9]/g, "");
      }
      return result.slice(0, size);
    };
    exports2.randomDigits = function(size) {
      const digits = [];
      let buffer = internals.random(size * 2);
      let pos = 0;
      while (digits.length < size) {
        if (pos >= buffer.length) {
          buffer = internals.random(size * 2);
          pos = 0;
        }
        if (buffer[pos] < 250) {
          digits.push(buffer[pos] % 10);
        }
        ++pos;
      }
      return digits.join("");
    };
    exports2.randomBits = function(bits) {
      if (!bits || bits < 0) {
        throw Boom5.internal("Invalid random bits count");
      }
      const bytes = Math.ceil(bits / 8);
      return internals.random(bytes);
    };
    exports2.fixedTimeComparison = function(a, b) {
      try {
        return Crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
      } catch (err) {
        return false;
      }
    };
    internals.random = function(bytes) {
      try {
        return Crypto.randomBytes(bytes);
      } catch (err) {
        throw Boom5.internal("Failed generating random bits: " + err.message);
      }
    };
  }
});
var require_decoder = __commonJS({
  "node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/decoder.js"(exports2) {
    "use strict";
    var Stream = __require2("stream");
    var internals = {
      decodeChars: [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        62,
        -1,
        -1,
        -1,
        63,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        -1,
        -1,
        -1,
        -1,
        -1
      ]
    };
    exports2.decode = function(buffer) {
      const decodeChars = internals.decodeChars;
      const len = buffer.length;
      const allocated = Math.ceil(len / 4) * 3;
      const result = Buffer.alloc(allocated);
      let c1;
      let c2;
      let c3;
      let c4;
      let j = 0;
      for (let i2 = 0; i2 < len; ) {
        do {
          c1 = decodeChars[buffer[i2++] & 255];
        } while (i2 < len && c1 === -1);
        if (c1 === -1) {
          break;
        }
        do {
          c2 = decodeChars[buffer[i2++] & 255];
        } while (i2 < len && c2 === -1);
        if (c2 === -1) {
          break;
        }
        result[j++] = c1 << 2 | (c2 & 48) >> 4;
        do {
          c3 = buffer[i2++] & 255;
          if (c3 === 61) {
            return result.slice(0, j);
          }
          c3 = decodeChars[c3];
        } while (i2 < len && c3 === -1);
        if (c3 === -1) {
          break;
        }
        result[j++] = (c2 & 15) << 4 | (c3 & 60) >> 2;
        do {
          c4 = buffer[i2++] & 255;
          if (c4 === 61) {
            return result.slice(0, j);
          }
          c4 = decodeChars[c4];
        } while (i2 < len && c4 === -1);
        if (c4 !== -1) {
          result[j++] = (c3 & 3) << 6 | c4;
        }
      }
      return j === allocated ? result : result.slice(0, j);
    };
    exports2.Decoder = class Decoder extends Stream.Transform {
      constructor() {
        super();
        this._reminder = null;
      }
      _transform(chunk, encoding, callback) {
        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 4;
        if (remaining) {
          this._reminder = part.slice(part.length - remaining);
          part = part.slice(0, part.length - remaining);
        } else {
          this._reminder = null;
        }
        this.push(exports2.decode(part));
        return callback();
      }
      _flush(callback) {
        if (this._reminder) {
          this.push(exports2.decode(this._reminder));
        }
        return callback();
      }
    };
  }
});
var require_encoder = __commonJS({
  "node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/encoder.js"(exports2) {
    "use strict";
    var Stream = __require2("stream");
    exports2.encode = function(buffer) {
      return Buffer.from(buffer.toString("base64"));
    };
    exports2.Encoder = class Encoder extends Stream.Transform {
      constructor() {
        super();
        this._reminder = null;
      }
      _transform(chunk, encoding, callback) {
        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 3;
        if (remaining) {
          this._reminder = part.slice(part.length - remaining);
          part = part.slice(0, part.length - remaining);
        } else {
          this._reminder = null;
        }
        this.push(exports2.encode(part));
        return callback();
      }
      _flush(callback) {
        if (this._reminder) {
          this.push(exports2.encode(this._reminder));
        }
        return callback();
      }
    };
  }
});
var require_lib17 = __commonJS({
  "node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Decoder4 = require_decoder();
    var Encoder4 = require_encoder();
    exports2.decode = Decoder4.decode;
    exports2.encode = Encoder4.encode;
    exports2.Decoder = Decoder4.Decoder;
    exports2.Encoder = Encoder4.Encoder;
    exports2.base64urlEncode = function(value, encoding) {
      Hoek.assert(typeof value === "string" || Buffer.isBuffer(value), "value must be string or buffer");
      const buf2 = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || "binary");
      return buf2.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    };
    exports2.base64urlDecode = function(value, encoding) {
      if (typeof value !== "string") {
        throw new Error("Value not a string");
      }
      if (!/^[\w\-]*$/.test(value)) {
        throw new Error("Invalid character");
      }
      const buf2 = Buffer.from(value, "base64");
      return encoding === "buffer" ? buf2 : buf2.toString(encoding || "binary");
    };
  }
});
var require_lib18 = __commonJS({
  "node_modules/.deno/@hapi+iron@7.0.1/node_modules/@hapi/iron/lib/index.js"(exports2) {
    "use strict";
    var Crypto = __require2("crypto");
    var B64 = require_lib17();
    var Boom5 = require_lib6();
    var Bourne = require_lib15();
    var Cryptiles = require_lib16();
    var Hoek = require_lib();
    var internals = {};
    exports2.defaults = {
      encryption: {
        saltBits: 256,
        algorithm: "aes-256-cbc",
        iterations: 1,
        minPasswordlength: 32
      },
      integrity: {
        saltBits: 256,
        algorithm: "sha256",
        iterations: 1,
        minPasswordlength: 32
      },
      ttl: 0,
      // Milliseconds, 0 means forever
      timestampSkewSec: 60,
      // Seconds of permitted clock skew for incoming expirations
      localtimeOffsetMsec: 0
      // Local clock time offset express in a number of milliseconds (positive or negative)
    };
    exports2.algorithms = {
      "aes-128-ctr": { keyBits: 128, ivBits: 128 },
      "aes-256-cbc": { keyBits: 256, ivBits: 128 },
      "sha256": { keyBits: 256 }
    };
    exports2.macFormatVersion = "2";
    exports2.macPrefix = "Fe26." + exports2.macFormatVersion;
    exports2.generateKey = async function(password, options3) {
      if (!password) {
        throw new Boom5.Boom("Empty password");
      }
      if (!options3 || typeof options3 !== "object") {
        throw new Boom5.Boom("Bad options");
      }
      const algorithm = exports2.algorithms[options3.algorithm];
      if (!algorithm) {
        throw new Boom5.Boom("Unknown algorithm: " + options3.algorithm);
      }
      const result = {};
      if (Buffer.isBuffer(password)) {
        if (password.length < algorithm.keyBits / 8) {
          throw new Boom5.Boom("Key buffer (password) too small");
        }
        result.key = password;
        result.salt = "";
      } else {
        if (password.length < options3.minPasswordlength) {
          throw new Boom5.Boom("Password string too short (min " + options3.minPasswordlength + " characters required)");
        }
        let salt = options3.salt;
        if (!salt) {
          if (!options3.saltBits) {
            throw new Boom5.Boom("Missing salt and saltBits options");
          }
          const randomSalt = Cryptiles.randomBits(options3.saltBits);
          salt = randomSalt.toString("hex");
        }
        const derivedKey = await internals.pbkdf2(password, salt, options3.iterations, algorithm.keyBits / 8, "sha1");
        result.key = derivedKey;
        result.salt = salt;
      }
      if (options3.iv) {
        result.iv = options3.iv;
      } else if (algorithm.ivBits) {
        result.iv = Cryptiles.randomBits(algorithm.ivBits);
      }
      return result;
    };
    exports2.encrypt = async function(password, options3, data) {
      const key = await exports2.generateKey(password, options3);
      const cipher = Crypto.createCipheriv(options3.algorithm, key.key, key.iv);
      const encrypted = Buffer.concat([cipher.update(data, "utf8"), cipher.final()]);
      return { encrypted, key };
    };
    exports2.decrypt = async function(password, options3, data) {
      const key = await exports2.generateKey(password, options3);
      const decipher = Crypto.createDecipheriv(options3.algorithm, key.key, key.iv);
      let dec = decipher.update(data, null, "utf8");
      dec = dec + decipher.final("utf8");
      return dec;
    };
    exports2.hmacWithPassword = async function(password, options3, data) {
      const key = await exports2.generateKey(password, options3);
      const hmac = Crypto.createHmac(options3.algorithm, key.key).update(data);
      const digest = hmac.digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      return {
        digest,
        salt: key.salt
      };
    };
    internals.normalizePassword = function(password) {
      if (password && typeof password === "object" && !Buffer.isBuffer(password)) {
        return {
          id: password.id,
          encryption: password.secret ?? password.encryption,
          integrity: password.secret ?? password.integrity
        };
      }
      return {
        encryption: password,
        integrity: password
      };
    };
    exports2.seal = async function(object2, password, options3) {
      options3 = Object.assign({}, options3);
      const now = Date.now() + (options3.localtimeOffsetMsec ?? 0);
      const objectString = internals.stringify(object2);
      let passwordId = "";
      password = internals.normalizePassword(password);
      if (password.id) {
        if (!/^\w+$/.test(password.id)) {
          throw new Boom5.Boom("Invalid password id");
        }
        passwordId = password.id;
      }
      const { encrypted, key } = await exports2.encrypt(password.encryption, options3.encryption, objectString);
      const encryptedB64 = B64.base64urlEncode(encrypted);
      const iv = B64.base64urlEncode(key.iv);
      const expiration = options3.ttl ? now + options3.ttl : "";
      const macBaseString = exports2.macPrefix + "*" + passwordId + "*" + key.salt + "*" + iv + "*" + encryptedB64 + "*" + expiration;
      const mac = await exports2.hmacWithPassword(password.integrity, options3.integrity, macBaseString);
      const sealed = macBaseString + "*" + mac.salt + "*" + mac.digest;
      return sealed;
    };
    exports2.unseal = async function(sealed, password, options3) {
      options3 = Object.assign({}, options3);
      const now = Date.now() + (options3.localtimeOffsetMsec ?? 0);
      const parts = sealed.split("*");
      if (parts.length !== 8) {
        throw new Boom5.Boom("Incorrect number of sealed components");
      }
      const macPrefix = parts[0];
      const passwordId = parts[1];
      const encryptionSalt = parts[2];
      const encryptionIv = parts[3];
      const encryptedB64 = parts[4];
      const expiration = parts[5];
      const hmacSalt = parts[6];
      const hmac = parts[7];
      const macBaseString = macPrefix + "*" + passwordId + "*" + encryptionSalt + "*" + encryptionIv + "*" + encryptedB64 + "*" + expiration;
      if (macPrefix !== exports2.macPrefix) {
        throw new Boom5.Boom("Wrong mac prefix");
      }
      if (expiration) {
        if (!expiration.match(/^\d+$/)) {
          throw new Boom5.Boom("Invalid expiration");
        }
        const exp = parseInt(expiration, 10);
        if (exp <= now - options3.timestampSkewSec * 1e3) {
          throw new Boom5.Boom("Expired seal");
        }
      }
      if (!password) {
        throw new Boom5.Boom("Empty password");
      }
      if (typeof password === "object" && !Buffer.isBuffer(password)) {
        password = password[passwordId || "default"];
        if (!password) {
          throw new Boom5.Boom("Cannot find password: " + passwordId);
        }
      }
      password = internals.normalizePassword(password);
      const macOptions = Hoek.clone(options3.integrity);
      macOptions.salt = hmacSalt;
      const mac = await exports2.hmacWithPassword(password.integrity, macOptions, macBaseString);
      if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw new Boom5.Boom("Bad hmac value");
      }
      try {
        var encrypted = B64.base64urlDecode(encryptedB64, "buffer");
      } catch (err) {
        throw Boom5.boomify(err);
      }
      const decryptOptions = Hoek.clone(options3.encryption);
      decryptOptions.salt = encryptionSalt;
      try {
        decryptOptions.iv = B64.base64urlDecode(encryptionIv, "buffer");
      } catch (err) {
        throw Boom5.boomify(err);
      }
      const decrypted = await exports2.decrypt(password.encryption, decryptOptions, encrypted);
      try {
        return Bourne.parse(decrypted);
      } catch (err) {
        throw new Boom5.Boom("Failed parsing sealed object JSON: " + err.message);
      }
    };
    internals.stringify = function(object2) {
      try {
        return JSON.stringify(object2);
      } catch (err) {
        throw new Boom5.Boom("Failed to stringify object: " + err.message);
      }
    };
    internals.pbkdf2 = function(...args) {
      return new Promise((resolve8, reject) => {
        const next = (err, result) => {
          if (err) {
            return reject(Boom5.boomify(err));
          }
          resolve8(result);
        };
        args.push(next);
        Crypto.pbkdf2(...args);
      });
    };
  }
});
var require_lib19 = __commonJS({
  "node_modules/.deno/@hapi+statehood@8.2.0/node_modules/@hapi/statehood/lib/index.js"(exports2) {
    "use strict";
    var Querystring = __require2("querystring");
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Bourne = require_lib15();
    var Cryptiles = require_lib16();
    var Hoek = require_lib();
    var Iron = require_lib18();
    var Validate = require_lib3();
    var internals = {
      macPrefix: "hapi.signed.cookie.1"
    };
    internals.schema = Validate.object({
      strictHeader: Validate.boolean(),
      ignoreErrors: Validate.boolean(),
      isSecure: Validate.boolean(),
      isHttpOnly: Validate.boolean(),
      isPartitioned: Validate.boolean(),
      isSameSite: Validate.valid("Strict", "Lax", "None", false),
      path: Validate.string().allow(null),
      domain: Validate.string().allow(null),
      ttl: Validate.number().allow(null),
      encoding: Validate.string().valid("base64json", "base64", "form", "iron", "none"),
      sign: Validate.object({
        password: [Validate.string(), Validate.binary(), Validate.object()],
        integrity: Validate.object()
      }),
      iron: Validate.object(),
      password: [Validate.string(), Validate.binary(), Validate.object()],
      contextualize: Validate.function(),
      // Used by hapi
      clearInvalid: Validate.boolean(),
      autoValue: Validate.any(),
      passThrough: Validate.boolean()
    });
    internals.defaults = {
      strictHeader: true,
      // Require an RFC 6265 compliant header format
      ignoreErrors: false,
      isSecure: true,
      isHttpOnly: true,
      isPartitioned: false,
      isSameSite: "Strict",
      path: null,
      domain: null,
      ttl: null,
      // MSecs, 0 means remove
      encoding: "none"
      // options: 'base64json', 'base64', 'form', 'iron', 'none'
    };
    internals.validateRx = {
      nameRx: {
        strict: /^[^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+$/,
        loose: /^[^=\s]*$/
      },
      valueRx: {
        strict: /^[^\x00-\x20\"\,\;\\\x7F]*$/,
        loose: /^(?:"([^\"]*)")|(?:[^\;]*)$/
      },
      domainRx: /^\.?[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d]))(?:\.[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d])))*$/,
      domainLabelLenRx: /^\.?[a-z\d\-]{1,63}(?:\.[a-z\d\-]{1,63})*$/,
      pathRx: /^\/[^\x00-\x1F\;]*$/
    };
    internals.pairsRx = /\s*([^=\s]*)\s*=\s*([^\;]*)(?:(?:;\s*)|$)/g;
    exports2.Definitions = class {
      constructor(options3) {
        this.settings = Hoek.applyToDefaults(internals.defaults, options3 ?? {});
        Validate.assert(this.settings, internals.schema, "Invalid state definition defaults");
        this.cookies = {};
        this.names = [];
      }
      add(name, options3) {
        Hoek.assert(name && typeof name === "string", "Invalid name");
        Hoek.assert(!this.cookies[name], "State already defined:", name);
        const settings = Hoek.applyToDefaults(this.settings, options3 ?? {}, { nullOverride: true });
        Validate.assert(settings, internals.schema, "Invalid state definition: " + name);
        this.cookies[name] = settings;
        this.names.push(name);
      }
      async parse(cookies) {
        const state = {};
        const names = [];
        const verify = internals.parsePairs(cookies, (name, value) => {
          if (name === "__proto__") {
            throw Boom5.badRequest("Invalid cookie header");
          }
          if (state[name]) {
            if (!Array.isArray(state[name])) {
              state[name] = [state[name]];
            }
            state[name].push(value);
          } else {
            state[name] = value;
            names.push(name);
          }
        });
        const failed = [];
        if (verify !== null) {
          if (!this.settings.ignoreErrors) {
            throw Boom5.badRequest("Invalid cookie header");
          }
          failed.push({ settings: this.settings, reason: `Header contains unexpected syntax: ${verify}` });
        }
        const errored = [];
        const record = (reason, name, value, definition) => {
          const details = {
            name,
            value,
            settings: definition,
            reason: typeof reason === "string" ? reason : reason.message
          };
          failed.push(details);
          if (!definition.ignoreErrors) {
            errored.push(details);
          }
        };
        const parsed = {};
        for (const name of names) {
          const value = state[name];
          const definition = this.cookies[name] ?? this.settings;
          if (definition.strictHeader) {
            const reason = internals.validate(name, state);
            if (reason) {
              record(reason, name, value, definition);
              continue;
            }
          }
          if (definition.encoding === "none") {
            parsed[name] = value;
            continue;
          }
          if (!Array.isArray(value)) {
            try {
              const unsigned = await internals.unsign(name, value, definition);
              const result = await internals.decode(unsigned, definition);
              parsed[name] = result;
            } catch (err) {
              Bounce.rethrow(err, "system");
              record(err, name, value, definition);
            }
            continue;
          }
          const arrayResult = [];
          for (const arrayValue of value) {
            try {
              const unsigned = await internals.unsign(name, arrayValue, definition);
              const result = await internals.decode(unsigned, definition);
              arrayResult.push(result);
            } catch (err) {
              Bounce.rethrow(err, "system");
              record(err, name, value, definition);
            }
          }
          parsed[name] = arrayResult;
        }
        if (errored.length) {
          const error = Boom5.badRequest("Invalid cookie value", errored);
          error.states = parsed;
          error.failed = failed;
          throw error;
        }
        return { states: parsed, failed };
      }
      async format(cookies, context) {
        if (!cookies || Array.isArray(cookies) && !cookies.length) {
          return [];
        }
        if (!Array.isArray(cookies)) {
          cookies = [cookies];
        }
        const header = [];
        for (let i2 = 0; i2 < cookies.length; ++i2) {
          const cookie = cookies[i2];
          const base4 = this.cookies[cookie.name] ?? this.settings;
          let definition = cookie.options ? Hoek.applyToDefaults(base4, cookie.options, { nullOverride: true }) : base4;
          if (definition.contextualize) {
            if (definition === base4) {
              definition = Hoek.clone(definition);
            }
            await definition.contextualize(definition, context);
          }
          const nameRx = definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose;
          if (!nameRx.test(cookie.name)) {
            throw Boom5.badImplementation("Invalid cookie name: " + cookie.name);
          }
          const value = await exports2.prepareValue(cookie.name, cookie.value, definition);
          const valueRx = definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose;
          if (value && (typeof value !== "string" || !value.match(valueRx))) {
            throw Boom5.badImplementation("Invalid cookie value: " + cookie.value);
          }
          let segment = cookie.name + "=" + (value || "");
          if (definition.ttl !== null && definition.ttl !== void 0) {
            const expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);
            segment = segment + "; Max-Age=" + Math.floor(definition.ttl / 1e3) + "; Expires=" + expires.toUTCString();
          }
          if (definition.isSecure) {
            segment = segment + "; Secure";
          }
          if (definition.isHttpOnly) {
            segment = segment + "; HttpOnly";
          }
          if (definition.isSameSite) {
            segment = `${segment}; SameSite=${definition.isSameSite}`;
          }
          if (definition.isPartitioned) {
            if (!definition.isSecure) {
              throw Boom5.badImplementation("Partitioned cookies must be secure");
            }
            if (definition.isSameSite !== "None") {
              throw Boom5.badImplementation("Partitioned cookies must have SameSite=None");
            }
            segment = `${segment}; Partitioned`;
          }
          if (definition.domain) {
            const domain = definition.domain.toLowerCase();
            if (!domain.match(internals.validateRx.domainLabelLenRx)) {
              throw Boom5.badImplementation("Cookie domain too long: " + definition.domain);
            }
            if (!domain.match(internals.validateRx.domainRx)) {
              throw Boom5.badImplementation("Invalid cookie domain: " + definition.domain);
            }
            segment = segment + "; Domain=" + domain;
          }
          if (definition.path) {
            if (!definition.path.match(internals.validateRx.pathRx)) {
              throw Boom5.badImplementation("Invalid cookie path: " + definition.path);
            }
            segment = segment + "; Path=" + definition.path;
          }
          header.push(segment);
        }
        return header;
      }
      passThrough(header, fallback) {
        if (!this.names.length) {
          return header;
        }
        const exclude = [];
        for (let i2 = 0; i2 < this.names.length; ++i2) {
          const name = this.names[i2];
          const definition = this.cookies[name];
          const passCookie = definition.passThrough !== void 0 ? definition.passThrough : fallback;
          if (!passCookie) {
            exclude.push(name);
          }
        }
        return exports2.exclude(header, exclude);
      }
    };
    internals.parsePairs = function(cookies, eachPairFn) {
      let index = 0;
      while (index < cookies.length) {
        const eqIndex = cookies.indexOf("=", index);
        if (eqIndex === -1) {
          return cookies.slice(index);
        }
        const semiIndex = cookies.indexOf(";", eqIndex);
        const endOfValueIndex = semiIndex !== -1 ? semiIndex : cookies.length;
        const name = cookies.slice(index, eqIndex).trim();
        const value = cookies.slice(eqIndex + 1, endOfValueIndex).trim();
        const unquotedValue = value.startsWith('"') && value.endsWith('"') && value !== '"' ? value.slice(1, -1) : (
          // E.g. '"abc"' -> 'abc'
          value
        );
        eachPairFn(name, unquotedValue);
        index = endOfValueIndex + 1;
      }
      return null;
    };
    internals.validate = function(name, state) {
      if (!name.match(internals.validateRx.nameRx.strict)) {
        return "Invalid cookie name";
      }
      const values = [].concat(state[name]);
      for (let i2 = 0; i2 < values.length; ++i2) {
        if (!values[i2].match(internals.validateRx.valueRx.strict)) {
          return "Invalid cookie value";
        }
      }
      return null;
    };
    internals.unsign = async function(name, value, definition) {
      if (!definition.sign) {
        return value;
      }
      const pos = value.lastIndexOf(".");
      if (pos === -1) {
        throw Boom5.badRequest("Missing signature separator");
      }
      const unsigned = value.slice(0, pos);
      const sig = value.slice(pos + 1);
      if (!sig) {
        throw Boom5.badRequest("Missing signature");
      }
      const sigParts = sig.split("*");
      if (sigParts.length !== 2) {
        throw Boom5.badRequest("Invalid signature format");
      }
      const hmacSalt = sigParts[0];
      const hmac = sigParts[1];
      const macOptions = Hoek.clone(definition.sign.integrity ?? Iron.defaults.integrity);
      macOptions.salt = hmacSalt;
      const mac = await Iron.hmacWithPassword(definition.sign.password, macOptions, [internals.macPrefix, name, unsigned].join("\n"));
      if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw Boom5.badRequest("Invalid hmac value");
      }
      return unsigned;
    };
    internals.decode = async function(value, definition) {
      if (!value && definition.encoding === "form") {
        return {};
      }
      Hoek.assert(typeof value === "string", "Invalid string");
      if (definition.encoding === "iron") {
        return await Iron.unseal(value, definition.password, definition.iron ?? Iron.defaults);
      }
      if (definition.encoding === "base64json") {
        const decoded = Buffer.from(value, "base64").toString("binary");
        try {
          return Bourne.parse(decoded);
        } catch (err) {
          throw Boom5.badRequest("Invalid JSON payload");
        }
      }
      if (definition.encoding === "base64") {
        return Buffer.from(value, "base64").toString("binary");
      }
      return Querystring.parse(value);
    };
    exports2.prepareValue = async function(name, value, options3) {
      Hoek.assert(options3 && typeof options3 === "object", "Missing or invalid options");
      try {
        const encoded = await internals.encode(value, options3);
        const signed = await internals.sign(name, encoded, options3.sign);
        return signed;
      } catch (err) {
        throw Boom5.badImplementation("Failed to encode cookie (" + name + ") value: " + err.message);
      }
    };
    internals.encode = function(value, options3) {
      if (value === void 0 || options3.encoding === "none") {
        return value;
      }
      if (options3.encoding === "iron") {
        return Iron.seal(value, options3.password, options3.iron ?? Iron.defaults);
      }
      if (options3.encoding === "base64") {
        return Buffer.from(value, "binary").toString("base64");
      }
      if (options3.encoding === "base64json") {
        const stringified = JSON.stringify(value);
        return Buffer.from(stringified, "binary").toString("base64");
      }
      return Querystring.stringify(value);
    };
    internals.sign = async function(name, value, options3) {
      if (value === void 0 || !options3) {
        return value;
      }
      const mac = await Iron.hmacWithPassword(options3.password, options3.integrity ?? Iron.defaults.integrity, [internals.macPrefix, name, value].join("\n"));
      const signed = value + "." + mac.salt + "*" + mac.digest;
      return signed;
    };
    exports2.exclude = function(cookies, excludes) {
      let result = "";
      const verify = cookies.replace(internals.pairsRx, ($0, $1, $2) => {
        if (excludes.indexOf($1) === -1) {
          result = result + (result ? ";" : "") + $1 + "=" + $2;
        }
        return "";
      });
      return verify === "" ? result : Boom5.badRequest("Invalid cookie header");
    };
  }
});
var require_lib20 = __commonJS({
  "node_modules/.deno/@hapi+content@6.0.0/node_modules/@hapi/content/lib/index.js"(exports2) {
    "use strict";
    var Boom5 = require_lib6();
    var internals = {};
    internals.contentTypeRegex = /^([^\/\s]+\/[^\s;]+)(.*)?$/;
    internals.charsetParamRegex = /;\s*charset=(?:"([^"]+)"|([^;"\s]+))/i;
    internals.boundaryParamRegex = /;\s*boundary=(?:"([^"]+)"|([^;"\s]+))/i;
    exports2.type = function(header) {
      if (!header) {
        throw Boom5.badRequest("Invalid content-type header");
      }
      const match = header.match(internals.contentTypeRegex);
      if (!match) {
        throw Boom5.badRequest("Invalid content-type header");
      }
      const result = {
        mime: match[1].toLowerCase()
      };
      const params = match[2];
      if (params) {
        const param = params.match(internals.charsetParamRegex);
        if (param) {
          result.charset = (param[1] || param[2]).toLowerCase();
        }
      }
      if (result.mime.indexOf("multipart/") === 0) {
        if (params) {
          const param = params.match(internals.boundaryParamRegex);
          if (param) {
            result.boundary = param[1] || param[2];
          }
        }
        if (!result.boundary) {
          throw Boom5.badRequest("Invalid content-type header: multipart missing boundary");
        }
      }
      return result;
    };
    internals.contentDispositionRegex = /^\s*form-data\s*(?:;\s*(.+))?$/i;
    internals.contentDispositionParamRegex = /([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;'"\s]+\'[\w-]*\'[^;\s]+)|(?:\"([^"]*)\")|([^;\s]*))(?:\s*(?:;\s*)|$)/g;
    exports2.disposition = function(header) {
      if (!header) {
        throw Boom5.badRequest("Missing content-disposition header");
      }
      const match = header.match(internals.contentDispositionRegex);
      if (!match) {
        throw Boom5.badRequest("Invalid content-disposition header format");
      }
      const parameters = match[1];
      if (!parameters) {
        throw Boom5.badRequest("Invalid content-disposition header missing parameters");
      }
      const result = {};
      parameters.replace(internals.contentDispositionParamRegex, ($0, $1, $2, $3, $4, $5) => {
        if ($1 === "__proto__") {
          throw Boom5.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
        let value;
        if ($2) {
          if (!$3) {
            throw Boom5.badRequest("Invalid content-disposition header format includes invalid parameters");
          }
          try {
            value = decodeURIComponent($3.split("'")[2]);
          } catch (err) {
            throw Boom5.badRequest("Invalid content-disposition header format includes invalid parameters");
          }
        } else {
          value = $4 || $5 || "";
        }
        if ($1 === "name" && value === "__proto__") {
          throw Boom5.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
        result[$1] = value;
      });
      if (!result.name) {
        throw Boom5.badRequest("Invalid content-disposition header missing name parameter");
      }
      return result;
    };
  }
});
var require_lib21 = __commonJS({
  "node_modules/.deno/@hapi+file@3.0.0/node_modules/@hapi/file/lib/index.js"(exports2) {
    "use strict";
    var Crypto = __require2("crypto");
    var Path = __require2("path");
    exports2.uniqueFilename = function(path12, extension) {
      if (extension) {
        extension = extension[0] !== "." ? "." + extension : extension;
      } else {
        extension = "";
      }
      path12 = Path.resolve(path12);
      const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString("hex")].join("-") + extension;
      return Path.join(path12, name);
    };
  }
});
var require_lib22 = __commonJS({
  "node_modules/.deno/@hapi+vise@5.0.1/node_modules/@hapi/vise/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    exports2.Vise = class Vise {
      constructor(chunks) {
        this.length = 0;
        this._chunks = [];
        this._offset = 0;
        if (chunks) {
          chunks = [].concat(chunks);
          for (let i2 = 0; i2 < chunks.length; ++i2) {
            this.push(chunks[i2]);
          }
        }
      }
      push(chunk) {
        Hoek.assert(Buffer.isBuffer(chunk), "Chunk must be a buffer");
        const item = {
          data: chunk,
          length: chunk.length,
          offset: this.length + this._offset,
          index: this._chunks.length
        };
        this._chunks.push(item);
        this.length += chunk.length;
      }
      shift(length4) {
        if (!length4) {
          return [];
        }
        const prevOffset = this._offset;
        const item = this.#chunkAt(length4);
        let dropTo = this._chunks.length;
        this._offset = 0;
        if (item) {
          dropTo = item.chunk.index;
          this._offset = item.offset;
        }
        const chunks = [];
        for (let i2 = 0; i2 < dropTo; ++i2) {
          const chunk = this._chunks.shift();
          if (i2 === 0 && prevOffset) {
            chunks.push(chunk.data.slice(prevOffset));
          } else {
            chunks.push(chunk.data);
          }
        }
        if (this._offset) {
          chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));
        }
        this.length = 0;
        for (let i2 = 0; i2 < this._chunks.length; ++i2) {
          const chunk = this._chunks[i2];
          chunk.offset = this.length, chunk.index = i2;
          this.length += chunk.length;
        }
        this.length -= this._offset;
        return chunks;
      }
      readUInt8(pos) {
        const item = this.#chunkAt(pos);
        return item ? item.chunk.data[item.offset] : void 0;
      }
      at(pos) {
        return this.readUInt8(pos);
      }
      #chunkAt(pos) {
        if (pos < 0) {
          return null;
        }
        pos = pos + this._offset;
        for (let i2 = 0; i2 < this._chunks.length; ++i2) {
          const chunk = this._chunks[i2];
          const offset = pos - chunk.offset;
          if (offset < chunk.length) {
            return { chunk, offset };
          }
        }
        return null;
      }
      chunks() {
        const chunks = [];
        for (let i2 = 0; i2 < this._chunks.length; ++i2) {
          const chunk = this._chunks[i2];
          if (i2 === 0 && this._offset) {
            chunks.push(chunk.data.slice(this._offset));
          } else {
            chunks.push(chunk.data);
          }
        }
        return chunks;
      }
      startsWith(value, pos, length4) {
        pos = pos ?? 0;
        length4 = length4 ? Math.min(value.length, length4) : value.length;
        if (pos + length4 > this.length) {
          return false;
        }
        const start = this.#chunkAt(pos);
        if (!start) {
          return false;
        }
        let j = start.chunk.index;
        for (let i2 = 0; j < this._chunks.length && i2 < length4; ++j) {
          const chunk = this._chunks[j];
          let k = j === start.chunk.index ? start.offset : 0;
          for (; k < chunk.length && i2 < length4; ++k, ++i2) {
            if (chunk.data[k] !== value[i2]) {
              return false;
            }
          }
        }
        return true;
      }
    };
  }
});
var require_lib23 = __commonJS({
  "node_modules/.deno/@hapi+nigel@5.0.1/node_modules/@hapi/nigel/lib/index.js"(exports2) {
    "use strict";
    var Stream = __require2("stream");
    var Hoek = require_lib();
    var { Vise } = require_lib22();
    var internals = {};
    exports2.compile = function(needle) {
      Hoek.assert(needle?.length, "Missing needle");
      Hoek.assert(Buffer.isBuffer(needle), "Needle must be a buffer");
      const profile = {
        value: needle,
        lastPos: needle.length - 1,
        last: needle[needle.length - 1],
        length: needle.length,
        badCharShift: Buffer.alloc(256)
        // Lookup table of how many characters can be skipped for each match
      };
      for (let i2 = 0; i2 < 256; ++i2) {
        profile.badCharShift[i2] = profile.length;
      }
      const last = profile.length - 1;
      for (let i2 = 0; i2 < last; ++i2) {
        profile.badCharShift[profile.value[i2]] = last - i2;
      }
      return profile;
    };
    exports2.horspool = function(haystack, needle, start) {
      Hoek.assert(haystack, "Missing haystack");
      needle = needle.badCharShift ? needle : exports2.compile(needle);
      start = start ?? 0;
      for (let i2 = start; i2 <= haystack.length - needle.length; ) {
        const lastChar = haystack.readUInt8(i2 + needle.lastPos);
        if (lastChar === needle.last && internals.startsWith(haystack, needle, i2)) {
          return i2;
        }
        i2 += needle.badCharShift[lastChar];
      }
      return -1;
    };
    internals.startsWith = function(haystack, needle, pos) {
      if (haystack.startsWith) {
        return haystack.startsWith(needle.value, pos, needle.lastPos);
      }
      for (let i2 = 0; i2 < needle.lastPos; ++i2) {
        if (needle.value[i2] !== haystack.readUInt8(pos + i2)) {
          return false;
        }
      }
      return true;
    };
    exports2.all = function(haystack, needle, start) {
      needle = exports2.compile(needle);
      start = start ?? 0;
      const matches = [];
      for (let i2 = start; i2 !== -1 && i2 < haystack.length; ) {
        i2 = exports2.horspool(haystack, needle, i2);
        if (i2 !== -1) {
          matches.push(i2);
          i2 += needle.length;
        }
      }
      return matches;
    };
    internals._indexOf = function(haystack, needle) {
      Hoek.assert(haystack, "Missing haystack");
      for (let i2 = 0; i2 <= haystack.length - needle.length; ++i2) {
        if (haystack.startsWith(needle.value, i2)) {
          return i2;
        }
      }
      return -1;
    };
    exports2.Stream = class extends Stream.Writable {
      constructor(needle) {
        super();
        this.needle(needle);
        this._haystack = new Vise();
        this._indexOf = this._needle.length > 2 ? exports2.horspool : internals._indexOf;
        this.on("finish", () => {
          const chunks = this._haystack.chunks();
          for (let i2 = 0; i2 < chunks.length; ++i2) {
            this.emit("haystack", chunks[i2]);
          }
        });
      }
      needle(needle) {
        this._needle = exports2.compile(needle);
      }
      _write(chunk, encoding, next) {
        this._haystack.push(chunk);
        let match = this._indexOf(this._haystack, this._needle);
        if (match === -1 && chunk.length >= this._needle.length) {
          this._flush(this._haystack.length - chunk.length);
        }
        while (match !== -1) {
          this._flush(match);
          this._haystack.shift(this._needle.length);
          this.emit("needle");
          match = this._indexOf(this._haystack, this._needle);
        }
        if (this._haystack.length) {
          const notChecked = this._haystack.length - this._needle.length + 1;
          let i2 = notChecked;
          for (; i2 < this._haystack.length; ++i2) {
            if (this._haystack.startsWith(this._needle.value, i2, this._haystack.length - i2)) {
              break;
            }
          }
          this._flush(i2);
        }
        return next();
      }
      _flush(pos) {
        const chunks = this._haystack.shift(pos);
        for (let i2 = 0; i2 < chunks.length; ++i2) {
          this.emit("haystack", chunks[i2]);
        }
      }
      flush() {
        const chunks = this._haystack.shift(this._haystack.length);
        for (let i2 = 0; i2 < chunks.length; ++i2) {
          this.emit("haystack", chunks[i2]);
        }
      }
    };
  }
});
var require_lib24 = __commonJS({
  "node_modules/.deno/@hapi+pez@6.1.0/node_modules/@hapi/pez/lib/index.js"(exports2) {
    "use strict";
    var Stream = __require2("stream");
    var B64 = require_lib17();
    var Boom5 = require_lib6();
    var Content = require_lib20();
    var Hoek = require_lib();
    var Nigel = require_lib23();
    var internals = {};
    internals.state = {
      preamble: 0,
      // Until the first boundary is received
      boundary: 1,
      // After a boundary, waiting for first line with optional linear-whitespace
      header: 2,
      // Receiving part headers
      payload: 3,
      // Receiving part payload
      epilogue: 4
    };
    internals.defaults = {
      maxBytes: Infinity,
      maxParts: Infinity
    };
    exports2.Dispenser = class extends Stream.Writable {
      constructor(options3) {
        super({ autoDestroy: false });
        Hoek.assert(options3 !== null && typeof options3 === "object", "options must be an object");
        const settings = Hoek.applyToDefaults(internals.defaults, options3);
        this._boundary = settings.boundary;
        this._state = internals.state.preamble;
        this._held = "";
        this._stream = null;
        this._headers = {};
        this._name = "";
        this._pendingHeader = "";
        this._error = null;
        this._bytesCount = 0;
        this._partsCount = 0;
        this._maxBytes = settings.maxBytes;
        this._maxParts = settings.maxParts;
        this._parts = new Nigel.Stream(Buffer.from("--" + settings.boundary));
        this._lines = new Nigel.Stream(Buffer.from("\r\n"));
        this._parts.on("needle", () => this.#onPartEnd());
        this._parts.on("haystack", (chunk) => this.#onPart(chunk));
        this._lines.on("needle", () => this.#onLineEnd());
        this._lines.on("haystack", (chunk) => this.#onLine(chunk));
        this.once("finish", () => this._parts.end());
        this._parts.once("close", () => this._lines.end());
        let piper = null;
        let finish = (err) => {
          if (piper) {
            piper.removeListener("data", onReqData);
            piper.removeListener("error", finish);
            piper.removeListener("aborted", onReqAborted);
          }
          if (err) {
            return this.#abort(err);
          }
          this.#emit("close");
        };
        finish = Hoek.once(finish);
        this._lines.once("close", () => {
          if (this._state === internals.state.epilogue) {
            if (this._held) {
              this.#emit("epilogue", this._held);
              this._held = "";
            }
          } else if (this._state === internals.state.boundary) {
            if (!this._held) {
              this.#abort(Boom5.badRequest("Missing end boundary"));
            } else if (this._held !== "--") {
              this.#abort(Boom5.badRequest("Only white space allowed after boundary at end"));
            }
          } else {
            this.#abort(Boom5.badRequest("Incomplete multipart payload"));
          }
          setImmediate(finish);
        });
        const onReqAborted = () => {
          finish(Boom5.badRequest("Client request aborted"));
        };
        const onReqData = (data) => {
          this._bytesCount += Buffer.byteLength(data);
          if (this._bytesCount > this._maxBytes) {
            finish(Boom5.entityTooLarge("Maximum size exceeded"));
          }
        };
        this.once("pipe", (req) => {
          piper = req;
          req.on("data", onReqData);
          req.once("error", finish);
          req.once("aborted", onReqAborted);
        });
      }
      _write(buffer, encoding, next) {
        if (this._error) {
          return next();
        }
        this._parts.write(buffer);
        return next();
      }
      #emit(...args) {
        if (this._error) {
          return;
        }
        this.emit(...args);
      }
      #abort(err) {
        this.#emit("error", err);
        this._error = err;
      }
      #onPartEnd() {
        this._lines.flush();
        if (this._state === internals.state.preamble) {
          if (this._held) {
            const last = this._held.length - 1;
            if (this._held[last] !== "\n" || this._held[last - 1] !== "\r") {
              return this.#abort(Boom5.badRequest("Preamble missing CRLF terminator"));
            }
            this.#emit("preamble", this._held.slice(0, -2));
            this._held = "";
          }
          this._parts.needle(Buffer.from("\r\n--" + this._boundary));
        } else {
          this._partsCount++;
          if (this._partsCount > this._maxParts) {
            return this.#abort(Boom5.badRequest("Maximum parts exceeded"));
          }
        }
        this._state = internals.state.boundary;
        if (this._stream) {
          this._stream.end();
          this._stream = null;
        } else if (this._name) {
          this.#emit("field", this._name, this._held);
          this._name = "";
          this._held = "";
        }
      }
      #onPart(chunk) {
        if (this._state === internals.state.preamble) {
          this._held = this._held + chunk.toString();
        } else if (this._state === internals.state.payload) {
          if (this._stream) {
            this._stream.write(chunk);
          } else {
            this._held = this._held + chunk.toString();
          }
        } else {
          this._lines.write(chunk);
        }
      }
      #onLineEnd() {
        if (this._state === internals.state.boundary) {
          if (this._held) {
            this._held = this._held.replace(/[\t ]/g, "");
            if (this._held) {
              if (this._held === "--") {
                this._state = internals.state.epilogue;
                this._held = "";
                return;
              }
              return this.#abort(Boom5.badRequest("Only white space allowed after boundary"));
            }
          }
          this._state = internals.state.header;
          return;
        }
        if (this._state === internals.state.header) {
          if (this._held) {
            if (this._held[0] === " " || this._held[0] === "	") {
              if (!this._pendingHeader) {
                return this.#abort(Boom5.badRequest("Invalid header continuation without valid declaration on previous line"));
              }
              this._pendingHeader = this._pendingHeader + " " + this._held.slice(1);
              this._held = "";
              return;
            }
            this.#flushHeader();
            this._pendingHeader = this._held;
            this._held = "";
            return;
          }
          this.#flushHeader();
          this._state = internals.state.payload;
          let disposition;
          try {
            disposition = Content.disposition(this._headers["content-disposition"]);
          } catch (err) {
            return this.#abort(err);
          }
          if (disposition.filename !== void 0) {
            const stream = new Stream.PassThrough();
            const transferEncoding = this._headers["content-transfer-encoding"];
            if (transferEncoding && transferEncoding.toLowerCase() === "base64") {
              this._stream = new B64.Decoder();
              this._stream.pipe(stream);
            } else {
              this._stream = stream;
            }
            stream.name = disposition.name;
            stream.filename = disposition.filename;
            stream.headers = this._headers;
            this._headers = {};
            this.#emit("part", stream);
          } else {
            this._name = disposition.name;
          }
          this._lines.flush();
          return;
        }
        this._held = this._held + "\r\n";
      }
      #onLine(chunk) {
        if (this._stream) {
          this._stream.write(chunk);
        } else {
          this._held = this._held + chunk.toString();
        }
      }
      #flushHeader() {
        if (!this._pendingHeader) {
          return;
        }
        const sep = this._pendingHeader.indexOf(":");
        if (sep === -1) {
          return this.#abort(Boom5.badRequest("Invalid header missing colon separator"));
        }
        if (!sep) {
          return this.#abort(Boom5.badRequest("Invalid header missing field name"));
        }
        const name = this._pendingHeader.slice(0, sep).toLowerCase();
        if (name === "__proto__") {
          return this.#abort(Boom5.badRequest("Invalid header"));
        }
        this._headers[name] = this._pendingHeader.slice(sep + 1).trim();
        this._pendingHeader = "";
      }
    };
  }
});
var require_payload = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/payload.js"(exports2, module2) {
    "use strict";
    var Stream = __require2("stream");
    var internals = {};
    module2.exports = internals.Payload = class extends Stream.Readable {
      constructor(payload, encoding) {
        super();
        const data = [].concat(payload || "");
        let size = 0;
        for (let i2 = 0; i2 < data.length; ++i2) {
          const chunk = data[i2];
          size = size + chunk.length;
          data[i2] = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        this._data = Buffer.concat(data, size);
        this._position = 0;
        this._encoding = encoding || "utf8";
      }
      _read(size) {
        const chunk = this._data.slice(this._position, this._position + size);
        this.push(chunk, this._encoding);
        this._position = this._position + chunk.length;
        if (this._position >= this._data.length) {
          this.push(null);
        }
      }
    };
  }
});
var require_recorder = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/recorder.js"(exports2, module2) {
    "use strict";
    var Stream = __require2("stream");
    var Boom5 = require_lib6();
    var internals = {};
    module2.exports = internals.Recorder = class extends Stream.Writable {
      constructor(options3) {
        super();
        this.settings = options3;
        this.buffers = [];
        this.length = 0;
      }
      _write(chunk, encoding, next) {
        if (this.settings.maxBytes && this.length + chunk.length > this.settings.maxBytes) {
          return this.emit("error", Boom5.entityTooLarge("Payload content length greater than maximum allowed: " + this.settings.maxBytes));
        }
        this.length = this.length + chunk.length;
        this.buffers.push(chunk);
        next();
      }
      collect() {
        const buffer = this.buffers.length === 0 ? Buffer.alloc(0) : this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length);
        return buffer;
      }
    };
  }
});
var require_tap = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/tap.js"(exports2, module2) {
    "use strict";
    var Stream = __require2("stream");
    var Payload = require_payload();
    var internals = {};
    module2.exports = internals.Tap = class extends Stream.Transform {
      constructor() {
        super();
        this.buffers = [];
      }
      _transform(chunk, encoding, next) {
        this.buffers.push(chunk);
        next(null, chunk);
      }
      collect() {
        return new Payload(this.buffers);
      }
    };
  }
});
var require_lib25 = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/index.js"(exports2, module2) {
    "use strict";
    var Events2 = __require2("events");
    var Http = __require2("http");
    var Https = __require2("https");
    var Stream = __require2("stream");
    var Url = __require2("url");
    var Zlib = __require2("zlib");
    var Boom5 = require_lib6();
    var Bourne = require_lib15();
    var Hoek = require_lib();
    var Payload = require_payload();
    var Recorder = require_recorder();
    var Tap = require_tap();
    var internals = {
      jsonRegex: /^application\/([a-z0-9.]*[+-]json|json)$/,
      shallowOptions: ["agent", "agents", "beforeRedirect", "payload", "redirected"],
      httpOptions: ["secureProtocol", "ciphers", "lookup", "family", "hints"]
    };
    internals.Client = class {
      constructor(options3 = {}) {
        Hoek.assert(!options3.agents || options3.agents.https && options3.agents.http && options3.agents.httpsAllowUnauthorized, 'Option agents must include "http", "https", and "httpsAllowUnauthorized"');
        this._defaults = Hoek.clone(options3, { shallow: internals.shallowOptions });
        this.agents = this._defaults.agents || {
          https: new Https.Agent({ maxSockets: Infinity }),
          http: new Http.Agent({ maxSockets: Infinity }),
          httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })
        };
        if (this._defaults.events) {
          this.events = new Events2.EventEmitter();
        }
      }
      defaults(options3) {
        Hoek.assert(options3 && typeof options3 === "object", "options must be provided to defaults");
        options3 = Hoek.applyToDefaults(this._defaults, options3, { shallow: internals.shallowOptions });
        return new internals.Client(options3);
      }
      request(method, url, options3 = {}) {
        try {
          options3 = Hoek.applyToDefaults(this._defaults, options3, { shallow: internals.shallowOptions });
          Hoek.assert(options3.payload === void 0 || typeof options3.payload === "string" || typeof options3.payload === "object", "options.payload must be a string, a Buffer, a Stream, or an Object");
          Hoek.assert(internals.isNullOrUndefined(options3.agent) || typeof options3.rejectUnauthorized !== "boolean", "options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set");
          Hoek.assert(internals.isNullOrUndefined(options3.beforeRedirect) || typeof options3.beforeRedirect === "function", "options.beforeRedirect must be a function");
          Hoek.assert(internals.isNullOrUndefined(options3.redirected) || typeof options3.redirected === "function", "options.redirected must be a function");
          Hoek.assert(options3.gunzip === void 0 || typeof options3.gunzip === "boolean" || options3.gunzip === "force", 'options.gunzip must be a boolean or "force"');
        } catch (err) {
          return Promise.reject(err);
        }
        if (options3.baseUrl) {
          url = internals.resolveUrl(options3.baseUrl, url);
          delete options3.baseUrl;
        }
        const relay = {};
        const req = this._request(method, url, options3, relay);
        const promise = new Promise((resolve8, reject) => {
          relay.callback = (err, res) => {
            if (err) {
              reject(err);
              return;
            }
            resolve8(res);
            return;
          };
        });
        promise.req = req;
        return promise;
      }
      _request(method, url, options3, relay, _trace) {
        const uri = {};
        if (options3.socketPath) {
          uri.socketPath = options3.socketPath;
          const parsedUri = new Url.URL(url, `unix://${options3.socketPath}`);
          internals.applyUrlToOptions(uri, {
            host: "",
            // host must be empty according to https://tools.ietf.org/html/rfc2616#section-14.23
            protocol: "http:",
            hash: parsedUri.hash,
            search: parsedUri.search,
            searchParams: parsedUri.searchParams,
            pathname: parsedUri.pathname,
            href: parsedUri.href
          });
        } else {
          uri.setHost = false;
          const parsedUri = new Url.URL(url);
          internals.applyUrlToOptions(uri, parsedUri);
        }
        uri.method = method.toUpperCase();
        uri.headers = /* @__PURE__ */ Object.create(null);
        const usedHeaders = /* @__PURE__ */ new Set();
        if (options3.headers) {
          for (const [key, value] of Object.entries(options3.headers)) {
            if (value !== void 0) {
              uri.headers[key] = value;
              usedHeaders.add(key.toLowerCase());
            }
          }
        }
        if (!usedHeaders.has("host")) {
          uri.headers.host = uri.host;
        }
        if (options3.payload && typeof options3.payload === "object" && !(options3.payload instanceof Stream) && !Buffer.isBuffer(options3.payload)) {
          options3.payload = JSON.stringify(options3.payload);
          if (!usedHeaders.has("content-type")) {
            uri.headers["content-type"] = "application/json";
          }
        }
        if (options3.gunzip && !usedHeaders.has("accept-encoding")) {
          uri.headers["accept-encoding"] = "gzip";
        }
        const payloadSupported = uri.method !== "GET" && uri.method !== "HEAD" && !internals.isNullOrUndefined(options3.payload);
        if (payloadSupported && (typeof options3.payload === "string" || Buffer.isBuffer(options3.payload)) && !usedHeaders.has("content-length")) {
          uri.headers["content-length"] = Buffer.isBuffer(options3.payload) ? options3.payload.length : Buffer.byteLength(options3.payload);
        }
        let redirects = options3.hasOwnProperty("redirects") ? options3.redirects : false;
        _trace = _trace ?? [];
        _trace.push({ method: uri.method, url });
        const client = uri.protocol === "https:" ? Https : Http;
        for (const option of internals.httpOptions) {
          if (options3[option] !== void 0) {
            uri[option] = options3[option];
          }
        }
        if (options3.rejectUnauthorized !== void 0 && uri.protocol === "https:") {
          uri.agent = options3.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
        } else if (options3.agent || options3.agent === false) {
          uri.agent = options3.agent;
        } else {
          uri.agent = uri.protocol === "https:" ? this.agents.https : this.agents.http;
        }
        this._emit("preRequest", uri, options3);
        const start = Date.now();
        const req = client.request(uri);
        this._emit("request", req);
        let shadow = null;
        let timeoutId;
        const onError = (err) => {
          err.trace = _trace;
          return finishOnce(Boom5.badGateway("Client request error", err));
        };
        const onAbort = () => {
          if (!req.socket) {
            const error = new Error("socket hang up");
            error.code = "ECONNRESET";
            finishOnce(error);
          }
        };
        req.once("error", onError);
        const onResponse = (res) => {
          const statusCode = res.statusCode;
          const redirectMethod = internals.redirectMethod(statusCode, uri.method, options3);
          if (redirects === false || !redirectMethod) {
            return finishOnce(null, res);
          }
          res.destroy();
          if (redirects === 0) {
            return finishOnce(Boom5.badGateway("Maximum redirections reached", _trace));
          }
          let location = res.headers.location;
          if (!location) {
            return finishOnce(Boom5.badGateway("Received redirection without location", _trace));
          }
          if (!/^https?:/i.test(location)) {
            location = Url.resolve(uri.href, location);
          }
          const redirectOptions = Hoek.clone(options3, { shallow: internals.shallowOptions });
          redirectOptions.payload = shadow ?? options3.payload;
          redirectOptions.redirects = --redirects;
          if (timeoutId) {
            clearTimeout(timeoutId);
            const elapsed = Date.now() - start;
            redirectOptions.timeout = (redirectOptions.timeout - elapsed).toString();
          }
          if (redirectOptions.headers) {
            const parsedLocation = new URL(location);
            if (uri.hostname !== parsedLocation.hostname) {
              for (const header of Object.keys(redirectOptions.headers)) {
                const lowerHeader = header.toLowerCase();
                if (lowerHeader === "authorization" || lowerHeader === "cookie") {
                  delete redirectOptions.headers[header];
                }
              }
            }
          }
          const followRedirect = (err) => {
            if (err) {
              err.trace = _trace;
              return finishOnce(Boom5.badGateway("Invalid redirect", err));
            }
            const redirectReq = this._request(redirectMethod, location, redirectOptions, { callback: finishOnce }, _trace);
            if (options3.redirected) {
              options3.redirected(statusCode, location, redirectReq);
            }
          };
          if (!options3.beforeRedirect) {
            return followRedirect();
          }
          return options3.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, followRedirect);
        };
        const finish = (err, res) => {
          if (err) {
            req.abort();
          }
          req.removeListener("response", onResponse);
          req.removeListener("error", onError);
          req.removeListener("abort", onAbort);
          req.on("error", Hoek.ignore);
          clearTimeout(timeoutId);
          this._emit("response", err, { req, res, start, uri });
          return relay.callback(err, res);
        };
        const finishOnce = Hoek.once(finish);
        req.once("response", onResponse);
        if (options3.timeout) {
          timeoutId = setTimeout(() => finishOnce(Boom5.gatewayTimeout("Client request timeout")), options3.timeout);
        }
        req.on("abort", onAbort);
        if (payloadSupported) {
          if (options3.payload instanceof Stream) {
            let stream = options3.payload;
            if (redirects) {
              const collector = new Tap();
              collector.once("finish", () => {
                shadow = collector.collect();
              });
              stream = options3.payload.pipe(collector);
            }
            internals.deferPipeUntilSocketConnects(req, stream);
            return req;
          }
          req.write(options3.payload);
        }
        req.end();
        return req;
      }
      _emit(...args) {
        if (this.events) {
          this.events.emit(...args);
        }
      }
      read(res, options3 = {}) {
        return new Promise((resolve8, reject) => {
          this._read(res, options3, (err, payload) => {
            if (err) {
              reject(err);
              return;
            }
            resolve8(payload);
            return;
          });
        });
      }
      _read(res, options3, callback) {
        options3 = Hoek.applyToDefaults(this._defaults, options3, { shallow: internals.shallowOptions });
        let clientTimeoutId = null;
        const finish = (err, buffer) => {
          clearTimeout(clientTimeoutId);
          reader.removeListener("error", onReaderError);
          reader.removeListener("finish", onReaderFinish);
          res.removeListener("error", onResError);
          res.removeListener("close", onResAborted);
          res.removeListener("aborted", onResAborted);
          res.on("error", Hoek.ignore);
          if (err) {
            return callback(err);
          }
          if (!options3.json) {
            return callback(null, buffer);
          }
          if (options3.json === "force") {
            return internals.tryParseBuffer(buffer, callback);
          }
          const contentType = res.headers?.["content-type"] ?? "";
          const mime = contentType.split(";")[0].trim().toLowerCase();
          if (!internals.jsonRegex.test(mime)) {
            if (options3.json === "strict") {
              return callback(Boom5.notAcceptable("The content-type is not JSON compatible"));
            }
            return callback(null, buffer);
          }
          return internals.tryParseBuffer(buffer, callback);
        };
        const finishOnce = Hoek.once(finish);
        const clientTimeout = options3.timeout;
        if (clientTimeout && clientTimeout > 0) {
          clientTimeoutId = setTimeout(() => finishOnce(Boom5.clientTimeout()), clientTimeout);
        }
        const onResError = (err) => {
          return finishOnce(err.isBoom ? err : Boom5.internal("Payload stream error", err));
        };
        const onResAborted = () => {
          if (!res.complete) {
            finishOnce(Boom5.internal("Payload stream closed prematurely"));
          }
        };
        res.once("error", onResError);
        res.once("close", onResAborted);
        res.once("aborted", onResAborted);
        const reader = new Recorder({ maxBytes: options3.maxBytes });
        const onReaderError = (err) => {
          if (res.destroy) {
            res.destroy();
          }
          return finishOnce(err);
        };
        reader.once("error", onReaderError);
        const onReaderFinish = () => {
          return finishOnce(null, reader.collect());
        };
        reader.once("finish", onReaderFinish);
        if (options3.gunzip) {
          const contentEncoding = options3.gunzip === "force" ? "gzip" : res.headers?.["content-encoding"] ?? "";
          if (/^(x-)?gzip(\s*,\s*identity)?$/.test(contentEncoding)) {
            const gunzip = Zlib.createGunzip();
            gunzip.once("error", onReaderError);
            res.pipe(gunzip).pipe(reader);
            return;
          }
        }
        res.pipe(reader);
      }
      toReadableStream(payload, encoding) {
        return new Payload(payload, encoding);
      }
      parseCacheControl(field) {
        const regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;
        const header = {};
        const error = field.replace(regex, ($0, $1, $2, $3) => {
          const value = $2 || $3;
          header[$1] = value ? value.toLowerCase() : true;
          return "";
        });
        if (header["max-age"]) {
          try {
            const maxAge2 = parseInt(header["max-age"], 10);
            if (isNaN(maxAge2)) {
              return null;
            }
            header["max-age"] = maxAge2;
          } catch (err) {
          }
        }
        return error ? null : header;
      }
      // Shortcuts
      get(uri, options3) {
        return this._shortcut("GET", uri, options3);
      }
      post(uri, options3) {
        return this._shortcut("POST", uri, options3);
      }
      patch(uri, options3) {
        return this._shortcut("PATCH", uri, options3);
      }
      put(uri, options3) {
        return this._shortcut("PUT", uri, options3);
      }
      delete(uri, options3) {
        return this._shortcut("DELETE", uri, options3);
      }
      async _shortcut(method, uri, options3 = {}) {
        const res = await this.request(method, uri, options3);
        let payload;
        try {
          payload = await this.read(res, options3);
        } catch (err) {
          err.data = err.data ?? {};
          err.data.res = res;
          throw err;
        }
        if (res.statusCode < 400) {
          return { res, payload };
        }
        const data = {
          isResponseError: true,
          headers: res.headers,
          res,
          payload
        };
        throw new Boom5.Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, { statusCode: res.statusCode, data });
      }
    };
    internals.resolveUrl = function(baseUrl, path12) {
      if (!path12) {
        return baseUrl;
      }
      const url = new Url.URL(path12, baseUrl);
      return Url.format(url);
    };
    internals.deferPipeUntilSocketConnects = function(req, stream) {
      const onSocket = (socket) => {
        if (!socket.connecting) {
          return onSocketConnect();
        }
        socket.once("connect", onSocketConnect);
      };
      const onSocketConnect = () => {
        stream.pipe(req);
        stream.removeListener("error", onStreamError);
      };
      const onStreamError = (err) => {
        req.emit("error", err);
      };
      req.once("socket", onSocket);
      stream.on("error", onStreamError);
    };
    internals.redirectMethod = function(code2, method, options3) {
      switch (code2) {
        case 301:
        case 302:
          return options3.redirectMethod || method;
        case 303:
          if (options3.redirect303) {
            return "GET";
          }
          break;
        case 307:
        case 308:
          return method;
      }
      return null;
    };
    internals.tryParseBuffer = function(buffer, next) {
      if (buffer.length === 0) {
        return next(null, null);
      }
      let payload;
      try {
        payload = Bourne.parse(buffer.toString());
      } catch (err) {
        return next(Boom5.badGateway(err.message, { payload: buffer }));
      }
      return next(null, payload);
    };
    internals.applyUrlToOptions = (options3, url) => {
      options3.host = url.host;
      options3.origin = url.origin;
      options3.searchParams = url.searchParams;
      options3.protocol = url.protocol;
      options3.hostname = typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname;
      options3.hash = url.hash;
      options3.search = url.search;
      options3.pathname = url.pathname;
      options3.path = `${url.pathname}${url.search}`;
      options3.href = url.href;
      if (url.port !== "") {
        options3.port = Number(url.port);
      }
      if (url.username || url.password) {
        options3.auth = `${url.username}:${url.password}`;
        options3.username = url.username;
        options3.password = url.password;
      }
      return options3;
    };
    internals.isNullOrUndefined = (val) => [null, void 0].includes(val);
    module2.exports = new internals.Client();
  }
});
var require_lib26 = __commonJS({
  "node_modules/.deno/@hapi+subtext@8.1.1/node_modules/@hapi/subtext/lib/index.js"(exports2) {
    "use strict";
    var Fs = __require2("fs");
    var Fsp = __require2("fs/promises");
    var Os = __require2("os");
    var Querystring = __require2("querystring");
    var Stream = __require2("stream");
    var Zlib = __require2("zlib");
    var Boom5 = require_lib6();
    var Bourne = require_lib15();
    var Content = require_lib20();
    var File2 = require_lib21();
    var Hoek = require_lib();
    var Pez = require_lib24();
    var Wreck = require_lib25();
    var internals = {
      kSubtext: Symbol("subtext"),
      decoders: {
        gzip: (options3) => Zlib.createGunzip(options3),
        deflate: (options3) => Zlib.createInflate(options3)
      }
    };
    exports2.parse = async function(req, tap, options3) {
      Hoek.assert(options3, "Missing options");
      Hoek.assert(options3.parse !== void 0, "Missing parse option setting");
      Hoek.assert(options3.output !== void 0, "Missing output option setting");
      const contentLength = req.headers["content-length"];
      if (options3.maxBytes !== void 0 && contentLength && parseInt(contentLength, 10) > options3.maxBytes) {
        throw Boom5.entityTooLarge("Payload content length greater than maximum allowed: " + options3.maxBytes);
      }
      const contentType = Content.type(options3.override || req.headers["content-type"] || options3.defaultContentType || "application/octet-stream");
      try {
        if (options3.allow && options3.allow.indexOf(contentType.mime) === -1) {
          throw Boom5.unsupportedMediaType();
        }
        const parsed = { mime: contentType.mime };
        if (options3.parse === true) {
          parsed.payload = await internals.parse(req, tap, options3, contentType);
          return parsed;
        }
        parsed.payload = await internals.raw(req, tap, options3);
        return parsed;
      } catch (err) {
        err.mime = contentType.mime;
        throw err;
      }
    };
    internals.parse = async function(req, tap, options3, contentType) {
      const output = options3.output;
      let source = internals.decoder(req, options3);
      if (tap) {
        [source] = internals.pipe(source, tap);
      }
      if (contentType.mime === "multipart/form-data") {
        if (options3.multipart === false) {
          throw Boom5.unsupportedMediaType();
        }
        return await internals.multipart(req, options3, source, contentType);
      }
      if (output === "stream") {
        return source;
      }
      if (output === "file") {
        const file = await internals.writeFile(req, options3, source);
        return file.item;
      }
      const payload = await Wreck.read(source, { timeout: options3.timeout, maxBytes: options3.maxBytes });
      return internals.object(options3, payload, contentType.mime);
    };
    internals.decoder = function(source, options3) {
      const contentEncoding = source.headers["content-encoding"];
      const decoders = options3.decoders ?? internals.decoders;
      if (!decoders.hasOwnProperty(contentEncoding)) {
        return source;
      }
      const decoderOptions = options3.compression?.[contentEncoding] ?? null;
      const stream = decoders[contentEncoding](decoderOptions);
      const orig = stream.emit;
      stream.emit = (event, ...args) => {
        if (event === "error") {
          args = [Boom5.badRequest("Invalid compressed payload", args[0])];
        }
        return orig.call(stream, event, ...args);
      };
      [source] = internals.pipe(source, stream);
      return source;
    };
    internals.raw = async function(req, tap, options3) {
      const output = options3.output;
      let source = req;
      if (options3.parse === "gunzip") {
        source = internals.decoder(source, options3);
      }
      if (tap) {
        [source] = internals.pipe(source, tap);
      }
      if (output === "stream") {
        return source;
      }
      if (output === "file") {
        const file = await internals.writeFile(req, options3, source);
        return file.item;
      }
      return await Wreck.read(source, { timeout: options3.timeout, maxBytes: options3.maxBytes });
    };
    internals.object = function(options3, payload, mime) {
      if (mime === "application/octet-stream") {
        return payload.length ? payload : null;
      }
      if (mime.match(/^text\/.+$/)) {
        return payload.toString("utf8");
      }
      if (/^application\/(?:.+\+)?json$/.test(mime)) {
        if (!payload.length) {
          return null;
        }
        try {
          return Bourne.parse(payload.toString("utf8"), { protoAction: options3.protoAction });
        } catch (err) {
          const error2 = Boom5.badRequest("Invalid request payload JSON format", err);
          error2.raw = payload;
          throw error2;
        }
      }
      if (mime === "application/x-www-form-urlencoded") {
        const parse11 = options3.querystring ?? Querystring.parse;
        return payload.length ? parse11(payload.toString("utf8")) : {};
      }
      const error = Boom5.unsupportedMediaType();
      error.raw = payload;
      throw error;
    };
    internals.multipart = function(req, options3, source, contentType) {
      return new Promise((resolve8, reject) => {
        const clientTimeout = options3.timeout;
        const clientTimeoutId = clientTimeout ? setTimeout(() => reject(Boom5.clientTimeout()), clientTimeout) : null;
        const dispenserOptions = Hoek.applyToDefaults(contentType, {
          maxBytes: options3.maxBytes,
          maxParts: options3.maxParts
        });
        const dispenser = new Pez.Dispenser(dispenserOptions);
        const data = {};
        const pendingFiles = [];
        const onError = (err) => {
          const cleanup = internals.cleanupFiles(pendingFiles);
          cleanup.catch(Hoek.ignore);
          reject(Boom5.badRequest("Invalid multipart payload format", err));
        };
        dispenser.once("error", onError);
        const set = (name, value) => {
          if (!data.hasOwnProperty(name)) {
            data[name] = value;
          } else if (Array.isArray(data[name])) {
            data[name].push(value);
          } else {
            data[name] = [data[name], value];
          }
        };
        const finalize = async () => {
          clearTimeout(clientTimeoutId);
          dispenser.removeListener("error", onError);
          dispenser.removeListener("part", onPart);
          dispenser.removeListener("field", onField);
          dispenser.removeListener("close", onClose);
          try {
            const files = await Promise.all(pendingFiles);
            for (const { item, name } of files) {
              set(name, item);
            }
          } catch (err) {
            reject(err);
            return;
          }
          resolve8(data);
        };
        const output = typeof options3.multipart === "object" ? options3.multipart.output : options3.output;
        const onPart = (part) => {
          if (output === "file") {
            pendingFiles.push(internals.writeFile(req, options3, part));
          } else {
            internals.part(part, output, set, options3);
          }
        };
        dispenser.on("part", onPart);
        const onField = (name, value) => set(name, value);
        dispenser.on("field", onField);
        const onClose = () => finalize();
        dispenser.once("close", onClose);
        source.pipe(dispenser);
      });
    };
    internals.writeFile = function(req, options3, stream) {
      const promise = new Promise((resolve8, reject) => {
        const path12 = File2.uniqueFilename(options3.uploads ?? Os.tmpdir());
        const file = Fs.createWriteStream(path12, { flags: "wx" });
        const counter = new internals.Counter(options3);
        const finalize = (err) => {
          req.removeListener("aborted", onAbort);
          file.removeListener("close", finalize);
          file.removeListener("error", finalize);
          if (err) {
            unpipeStreamToCounter();
            unpipeCounterToFile();
            file.close();
            Fs.unlink(path12, () => reject(err));
            return;
          }
          const result = {
            item: {
              path: path12,
              bytes: counter.bytes
            }
          };
          if (stream.name) {
            result.name = stream.name;
            result.item.filename = stream.filename;
            result.item.headers = stream.headers;
          }
          resolve8(result);
        };
        file.once("close", finalize);
        file.once("error", finalize);
        const onAbort = () => finalize(Boom5.badRequest("Client connection aborted"));
        req.once("aborted", onAbort);
        const [, unpipeStreamToCounter] = internals.pipe(stream, counter);
        const [, unpipeCounterToFile] = internals.pipe(counter, file);
      });
      promise.catch(Hoek.ignore);
      return promise;
    };
    internals.cleanupFiles = async (pendingFiles) => {
      const results = await Promise.allSettled(pendingFiles);
      await Promise.all(results.map(async (result) => {
        if (result.value) {
          await Fsp.unlink(result.value.item.path);
        }
      }));
    };
    internals.part = async function(part, output, set, options3) {
      const payload = await Wreck.read(part);
      if (output === "stream") {
        const item = Wreck.toReadableStream(payload);
        item.hapi = {
          filename: part.filename,
          headers: part.headers
        };
        return set(part.name, item);
      }
      const ct = part.headers["content-type"] || "";
      const mime = ct.split(";")[0].trim().toLowerCase();
      const annotate = (value) => set(part.name, output === "annotated" ? { filename: part.filename, headers: part.headers, payload: value } : value);
      if (!mime) {
        return annotate(payload);
      }
      if (!payload.length) {
        return annotate({});
      }
      try {
        const object2 = internals.object(options3, payload, mime);
        annotate(object2);
      } catch (err) {
        annotate(payload);
      }
    };
    internals.pipe = function(from6, to) {
      const forwardError = (err) => {
        unpipe();
        to.emit("error", err);
      };
      const unpipe = () => {
        from6.removeListener("error", forwardError);
        return from6.unpipe(to);
      };
      from6.once("error", forwardError);
      return [from6.pipe(to), unpipe];
    };
    internals.Counter = class extends Stream.Transform {
      constructor(options3) {
        super();
        this.bytes = 0;
        this._maxBytes = options3.maxBytes;
      }
      _transform(chunk, encoding, next) {
        this.bytes = this.bytes + chunk.length;
        if (this._maxBytes !== void 0 && this.bytes > this._maxBytes) {
          return next(Boom5.entityTooLarge("Payload content length greater than maximum allowed: " + this._maxBytes));
        }
        return next(null, chunk);
      }
    };
  }
});
var require_ext = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/ext.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var Topo = require_lib2();
    var internals = {};
    exports2 = module2.exports = internals.Ext = class {
      type = null;
      nodes = null;
      #core = null;
      #routes = [];
      #topo = new Topo.Sorter();
      constructor(type, core) {
        this.#core = core;
        this.type = type;
      }
      add(event) {
        const methods = [].concat(event.method);
        for (const method of methods) {
          const settings = {
            before: event.options.before,
            after: event.options.after,
            group: event.realm.plugin,
            sort: this.#core.extensionsSeq++
          };
          const node = {
            func: method,
            // Request: function (request, h), Server: function (server)
            bind: event.options.bind,
            server: event.server,
            // Server event
            realm: event.realm,
            timeout: event.options.timeout
          };
          this.#topo.add(node, settings);
        }
        this.nodes = this.#topo.nodes;
        for (const route2 of this.#routes) {
          route2.rebuild(event);
        }
      }
      merge(others) {
        const merge3 = [];
        for (const other of others) {
          merge3.push(other.#topo);
        }
        this.#topo.merge(merge3);
        this.nodes = this.#topo.nodes.length ? this.#topo.nodes : null;
      }
      subscribe(route2) {
        this.#routes.push(route2);
      }
      static combine(route2, type) {
        const ext = new internals.Ext(type, route2._core);
        const events = route2.settings.ext[type];
        if (events) {
          for (let event of events) {
            event = Object.assign({}, event);
            Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for route extension");
            event.realm = route2.realm;
            ext.add(event);
          }
        }
        const server = route2._core.extensions.route[type];
        const realm = route2.realm._extensions[type];
        ext.merge([server, realm]);
        server.subscribe(route2);
        realm.subscribe(route2);
        return ext;
      }
    };
  }
});
var require_handler = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/handler.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {};
    exports2.execute = async function(request) {
      if (request._route._prerequisites) {
        for (const set of request._route._prerequisites) {
          const pres = [];
          for (const item of set) {
            pres.push(internals.handler(request, item.method, item));
          }
          const responses = await Promise.all(pres);
          for (const response of responses) {
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      const result = await internals.handler(request, request.route.settings.handler);
      if (result._takeover || typeof result === "symbol") {
        return result;
      }
      request._setResponse(result);
    };
    internals.handler = async function(request, method, pre) {
      const bind = request.route.settings.bind;
      const realm = request.route.realm;
      let response = await request._core.toolkit.execute(method, request, { bind, realm, continue: "null" });
      if (!pre) {
        if (response.isBoom) {
          request._log(["handler", "error"], response);
          throw response;
        }
        return response;
      }
      if (response.isBoom) {
        response.assign = pre.assign;
        response = await request._core.toolkit.failAction(request, pre.failAction, response, { tags: ["pre", "error"], retain: true });
      }
      if (typeof response === "symbol") {
        return response;
      }
      if (pre.assign) {
        request.pre[pre.assign] = response.isBoom ? response : response.source;
        request.preResponses[pre.assign] = response;
      }
      if (response._takeover) {
        return response;
      }
    };
    exports2.defaults = function(method, handler, core) {
      let defaults = null;
      if (typeof handler === "object") {
        const type = Object.keys(handler)[0];
        const serverHandler = core.decorations.handler.get(type);
        Hoek.assert(serverHandler, "Unknown handler:", type);
        if (serverHandler.defaults) {
          defaults = typeof serverHandler.defaults === "function" ? serverHandler.defaults(method) : serverHandler.defaults;
        }
      }
      return defaults ?? {};
    };
    exports2.configure = function(handler, route2) {
      if (typeof handler === "object") {
        const type = Object.keys(handler)[0];
        const serverHandler = route2._core.decorations.handler.get(type);
        Hoek.assert(serverHandler, "Unknown handler:", type);
        return serverHandler(route2.public, handler[type]);
      }
      return handler;
    };
    exports2.prerequisitesConfig = function(config2) {
      if (!config2) {
        return null;
      }
      const prerequisites = [];
      for (let pres of config2) {
        pres = [].concat(pres);
        const set = [];
        for (let pre of pres) {
          if (typeof pre !== "object") {
            pre = { method: pre };
          }
          const item = {
            method: pre.method,
            assign: pre.assign,
            failAction: pre.failAction ?? "error"
          };
          set.push(item);
        }
        prerequisites.push(set);
      }
      return prerequisites.length ? prerequisites : null;
    };
  }
});
var require_headers = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/headers.js"(exports2) {
    "use strict";
    var Stream = __require2("stream");
    var Boom5 = require_lib6();
    var internals = {};
    exports2.cache = function(response) {
      const request = response.request;
      if (response.headers["cache-control"]) {
        return;
      }
      const settings = request.route.settings.cache;
      const policy = settings && request._route._cache && (settings._statuses.has(response.statusCode) || response.statusCode === 304 && settings._statuses.has(200));
      if (policy || response.settings.ttl) {
        const ttl = response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl();
        const privacy = request.auth.isAuthenticated || response.headers["set-cookie"] ? "private" : settings.privacy ?? "default";
        response._header("cache-control", "max-age=" + Math.floor(ttl / 1e3) + ", must-revalidate" + (privacy !== "default" ? ", " + privacy : ""));
      } else if (settings) {
        response._header("cache-control", settings.otherwise);
      }
    };
    exports2.content = async function(response) {
      const request = response.request;
      if (response._isPayloadSupported() || request.method === "head") {
        await response._marshal();
        if (typeof response._payload.size === "function") {
          response._header("content-length", response._payload.size(), { override: false });
        }
        if (!response._isPayloadSupported()) {
          response._close();
          response._payload = new internals.Empty();
        }
        exports2.type(response);
      } else {
        response._close();
        response._payload = new internals.Empty();
        delete response.headers["content-length"];
      }
    };
    exports2.state = async function(response) {
      const request = response.request;
      const states = [];
      for (const stateName in request._states) {
        states.push(request._states[stateName]);
      }
      try {
        for (const name in request._core.states.cookies) {
          const autoValue = request._core.states.cookies[name].autoValue;
          if (!autoValue || name in request._states || name in request.state) {
            continue;
          }
          if (typeof autoValue !== "function") {
            states.push({ name, value: autoValue });
            continue;
          }
          const value = await autoValue(request);
          states.push({ name, value });
        }
        if (!states.length) {
          return;
        }
        let header = await request._core.states.format(states, request);
        const existing = response.headers["set-cookie"];
        if (existing) {
          header = (Array.isArray(existing) ? existing : [existing]).concat(header);
        }
        response._header("set-cookie", header);
      } catch (err) {
        const error = Boom5.boomify(err);
        request._log(["state", "response", "error"], error);
        request._states = {};
        throw error;
      }
    };
    exports2.type = function(response) {
      const type = response.contentType;
      if (type !== null && type !== response.headers["content-type"]) {
        response.type(type);
      }
    };
    exports2.entity = function(response) {
      const request = response.request;
      if (!request._entity) {
        return;
      }
      if (request._entity.etag && !response.headers.etag) {
        response.etag(request._entity.etag, { vary: request._entity.vary });
      }
      if (request._entity.modified && !response.headers["last-modified"]) {
        response.header("last-modified", request._entity.modified);
      }
    };
    exports2.unmodified = function(response) {
      const request = response.request;
      if (response.statusCode === 304) {
        return;
      }
      const entity = {
        etag: response.headers.etag,
        vary: response.settings.varyEtag,
        modified: response.headers["last-modified"]
      };
      const etag = request._core.Response.unmodified(request, entity);
      if (etag) {
        response.code(304);
        if (etag !== true) {
          response.headers.etag = etag;
        }
      }
    };
    internals.Empty = class extends Stream.Readable {
      _read() {
        this.push(null);
      }
      writeToStream(stream) {
        stream.end();
      }
    };
  }
});
var require_security = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/security.js"(exports2) {
    "use strict";
    exports2.route = function(settings) {
      if (!settings) {
        return null;
      }
      const security = settings;
      if (security.hsts) {
        if (security.hsts === true) {
          security._hsts = "max-age=15768000";
        } else if (typeof security.hsts === "number") {
          security._hsts = "max-age=" + security.hsts;
        } else {
          security._hsts = "max-age=" + (security.hsts.maxAge ?? 15768e3);
          if (security.hsts.includeSubdomains || security.hsts.includeSubDomains) {
            security._hsts = security._hsts + "; includeSubDomains";
          }
          if (security.hsts.preload) {
            security._hsts = security._hsts + "; preload";
          }
        }
      }
      if (security.xframe) {
        if (security.xframe === true) {
          security._xframe = "DENY";
        } else if (typeof security.xframe === "string") {
          security._xframe = security.xframe.toUpperCase();
        } else if (security.xframe.rule === "allow-from") {
          if (!security.xframe.source) {
            security._xframe = "SAMEORIGIN";
          } else {
            security._xframe = "ALLOW-FROM " + security.xframe.source;
          }
        } else {
          security._xframe = security.xframe.rule.toUpperCase();
        }
      }
      return security;
    };
    exports2.headers = function(response) {
      const security = response.request.route.settings.security;
      if (security._hsts) {
        response._header("strict-transport-security", security._hsts, { override: false });
      }
      if (security._xframe) {
        response._header("x-frame-options", security._xframe, { override: false });
      }
      if (security.xss === "enabled") {
        response._header("x-xss-protection", "1; mode=block", { override: false });
      } else if (security.xss === "disabled") {
        response._header("x-xss-protection", "0", { override: false });
      }
      if (security.noOpen) {
        response._header("x-download-options", "noopen", { override: false });
      }
      if (security.noSniff) {
        response._header("x-content-type-options", "nosniff", { override: false });
      }
      if (security.referrer !== false) {
        response._header("referrer-policy", security.referrer, { override: false });
      }
    };
  }
});
var require_streams = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/streams.js"(exports2) {
    "use strict";
    var Stream = __require2("stream");
    var Boom5 = require_lib6();
    var Teamwork = require_lib5();
    var internals = {
      team: Symbol("team")
    };
    exports2.isStream = function(stream) {
      const isReadableStream = stream instanceof Stream.Readable;
      if (!isReadableStream && typeof stream?.pipe === "function") {
        throw Boom5.badImplementation("Cannot reply with a stream-like object that is not an instance of Stream.Readable");
      }
      if (!isReadableStream) {
        return false;
      }
      if (stream.readableObjectMode) {
        throw Boom5.badImplementation("Cannot reply with stream in object mode");
      }
      return true;
    };
    exports2.drain = function(stream) {
      const team = new Teamwork.Team();
      stream[internals.team] = team;
      stream.on("readable", internals.read);
      stream.on("error", internals.end);
      stream.on("end", internals.end);
      stream.on("close", internals.end);
      return team.work;
    };
    internals.read = function() {
      while (this.read()) {
      }
    };
    internals.end = function() {
      this.removeListener("readable", internals.read);
      this.removeListener("error", internals.end);
      this.removeListener("end", internals.end);
      this.removeListener("close", internals.end);
      this[internals.team].attend();
    };
  }
});
var require_validation = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/validation.js"(exports2) {
    "use strict";
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var internals = {};
    exports2.validator = function(validator) {
      Hoek.assert(validator, "Missing validator");
      Hoek.assert(typeof validator.compile === "function", "Invalid validator compile method");
      return validator;
    };
    exports2.compile = function(rule, validator, realm, core) {
      validator = validator ?? internals.validator(realm, core);
      if (rule === false) {
        return Validate.object({}).allow(null);
      }
      if (typeof rule === "function") {
        return rule;
      }
      if (!rule || // false tested above
      rule === true) {
        return null;
      }
      if (typeof rule.validate === "function") {
        return rule;
      }
      Hoek.assert(validator, "Cannot set uncompiled validation rules without configuring a validator");
      return validator.compile(rule);
    };
    internals.validator = function(realm, core) {
      while (realm) {
        if (realm.validator) {
          return realm.validator;
        }
        realm = realm.parent;
      }
      return core.validator;
    };
    exports2.headers = function(request) {
      return internals.input("headers", request);
    };
    exports2.params = function(request) {
      return internals.input("params", request);
    };
    exports2.payload = function(request) {
      if (request.method === "get" || request.method === "head") {
        return;
      }
      return internals.input("payload", request);
    };
    exports2.query = function(request) {
      return internals.input("query", request);
    };
    exports2.state = function(request) {
      return internals.input("state", request);
    };
    internals.input = async function(source, request) {
      const localOptions = {
        context: {
          headers: request.headers,
          params: request.params,
          query: request.query,
          payload: request.payload,
          state: request.state,
          auth: request.auth,
          app: {
            route: request.route.settings.app,
            request: request.app
          }
        }
      };
      delete localOptions.context[source];
      Hoek.merge(localOptions, request.route.settings.validate.options);
      try {
        const schema = request.route.settings.validate[source];
        const bind = request.route.settings.bind;
        var value = await (typeof schema !== "function" ? internals.validate(request[source], schema, localOptions) : schema.call(bind, request[source], localOptions));
        return;
      } catch (err) {
        var validationError = err;
      } finally {
        request.orig[source] = request[source];
        if (value !== void 0) {
          request[source] = value;
        }
      }
      if (request.route.settings.validate.failAction === "ignore") {
        return;
      }
      const defaultError = validationError.isBoom ? validationError : Boom5.badRequest(`Invalid request ${source} input`);
      const detailedError = Boom5.boomify(validationError, { statusCode: 400, override: false, data: { defaultError } });
      detailedError.output.payload.validation = { source, keys: [] };
      if (validationError.details) {
        for (const details of validationError.details) {
          const path12 = details.path;
          detailedError.output.payload.validation.keys.push(Hoek.escapeHtml(path12.join(".")));
        }
      }
      if (request.route.settings.validate.errorFields) {
        for (const field in request.route.settings.validate.errorFields) {
          detailedError.output.payload[field] = request.route.settings.validate.errorFields[field];
        }
      }
      return request._core.toolkit.failAction(request, request.route.settings.validate.failAction, defaultError, { details: detailedError, tags: ["validation", "error", source] });
    };
    exports2.response = async function(request) {
      if (request.route.settings.response.sample) {
        const currentSample = Math.ceil(Math.random() * 100);
        if (currentSample > request.route.settings.response.sample) {
          return;
        }
      }
      const response = request.response;
      const statusCode = response.isBoom ? response.output.statusCode : response.statusCode;
      const statusSchema = request.route.settings.response.status[statusCode];
      if (statusCode >= 400 && !statusSchema) {
        return;
      }
      const schema = statusSchema !== void 0 ? statusSchema : request.route.settings.response.schema;
      if (schema === null) {
        return;
      }
      if (!response.isBoom && request.response.variety !== "plain") {
        throw Boom5.badImplementation("Cannot validate non-object response");
      }
      const localOptions = {
        context: {
          headers: request.headers,
          params: request.params,
          query: request.query,
          payload: request.payload,
          state: request.state,
          auth: request.auth,
          app: {
            route: request.route.settings.app,
            request: request.app
          }
        }
      };
      const source = response.isBoom ? response.output.payload : response.source;
      Hoek.merge(localOptions, request.route.settings.response.options);
      try {
        let value;
        if (typeof schema !== "function") {
          value = await internals.validate(source, schema, localOptions);
        } else {
          value = await schema(source, localOptions);
        }
        if (value !== void 0 && request.route.settings.response.modify) {
          if (response.isBoom) {
            response.output.payload = value;
          } else {
            response.source = value;
          }
        }
      } catch (err) {
        return request._core.toolkit.failAction(request, request.route.settings.response.failAction, err, { tags: ["validation", "response", "error"] });
      }
    };
    internals.validate = function(value, schema, options3) {
      if (typeof schema.validateAsync === "function") {
        return schema.validateAsync(value, options3);
      }
      return schema.validate(value, options3);
    };
  }
});
var require_route = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/route.js"(exports2, module2) {
    "use strict";
    var Assert = __require2("assert");
    var Bounce = require_lib7();
    var Catbox = require_lib11();
    var Hoek = require_lib();
    var Subtext = require_lib26();
    var Validate = require_lib3();
    var Auth = require_auth();
    var Config = require_config();
    var Cors = require_cors();
    var Ext = require_ext();
    var Handler = require_handler();
    var Headers2 = require_headers();
    var Security = require_security();
    var Streams = require_streams();
    var Validation = require_validation();
    var internals = {};
    exports2 = module2.exports = internals.Route = class {
      constructor(route2, server, options3 = {}) {
        const core = server._core;
        const realm = server.realm;
        Config.apply("route", route2, route2.method, route2.path);
        const method = route2.method.toLowerCase();
        Hoek.assert(method !== "head", "Cannot set HEAD route:", route2.path);
        const path12 = realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (route2.path !== "/" ? route2.path : "") : route2.path;
        Hoek.assert(path12 === "/" || path12[path12.length - 1] !== "/" || !core.settings.router.stripTrailingSlash, "Path cannot end with a trailing slash when configured to strip:", route2.method, route2.path);
        const vhost = realm.modifiers.route.vhost ?? route2.vhost;
        this.method = method;
        this.path = path12;
        let config2 = route2.options ?? route2.config ?? {};
        if (typeof config2 === "function") {
          config2 = config2.call(realm.settings.bind, server);
        }
        config2 = Config.enable(config2);
        this._assert(method !== "get" || !config2.payload, "Cannot set payload settings on HEAD or GET request");
        this._assert(method !== "get" || !config2.validate?.payload, "Cannot validate HEAD or GET request payload");
        this._assert(!route2.rules || !config2.rules, "Route rules can only appear once");
        const rules = route2.rules ?? config2.rules;
        const rulesConfig = internals.rules(rules, { method, path: path12, vhost }, server);
        delete config2.rules;
        this._assert(route2.handler || config2.handler, "Missing or undefined handler");
        this._assert(!!route2.handler ^ !!config2.handler, "Handler must only appear once");
        const handler = Config.apply("handler", route2.handler ?? config2.handler);
        delete config2.handler;
        const handlerDefaults = Handler.defaults(method, handler, core);
        const settings = internals.config([core.settings.routes, handlerDefaults, realm.settings, rulesConfig, config2]);
        this.settings = Config.apply("routeConfig", settings, method, path12);
        this._core = core;
        this.realm = realm;
        this.settings.vhost = vhost;
        this.settings.plugins = this.settings.plugins ?? {};
        this.settings.app = this.settings.app ?? {};
        this._special = !!options3.special;
        this._analysis = this._core.router.analyze(this.path);
        this.params = this._analysis.params;
        this.fingerprint = this._analysis.fingerprint;
        this.public = {
          method: this.method,
          path: this.path,
          vhost,
          realm,
          settings: this.settings,
          fingerprint: this.fingerprint,
          auth: {
            access: (request) => Auth.testAccess(request, this.public)
          }
        };
        this._setupValidation();
        if (this.method === "get") {
          this.settings.payload = null;
        } else {
          this.settings.payload.decoders = this._core.compression.decoders;
        }
        this._assert(!this.settings.validate.payload || this.settings.payload.parse, "Route payload must be set to 'parse' when payload validation enabled");
        this._assert(!this.settings.validate.state || this.settings.state.parse, "Route state must be set to 'parse' when state validation enabled");
        this.settings.auth = this._special ? false : this._core.auth._setupRoute(this.settings.auth, path12);
        if (this.method === "get" && typeof this.settings.cache === "object" && (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {
          this.settings.cache._statuses = new Set(this.settings.cache.statuses);
          this._cache = new Catbox.Policy({ expiresIn: this.settings.cache.expiresIn, expiresAt: this.settings.cache.expiresAt });
        }
        this.settings.cors = Cors.route(this.settings.cors);
        this.settings.security = Security.route(this.settings.security);
        this.settings.handler = Handler.configure(handler, this);
        this._prerequisites = Handler.prerequisitesConfig(this.settings.pre);
        this._extensions = {
          onPreResponse: Ext.combine(this, "onPreResponse"),
          onPostResponse: Ext.combine(this, "onPostResponse")
        };
        if (this._special) {
          this._cycle = [internals.drain, Handler.execute];
          this.rebuild();
          return;
        }
        this._extensions.onPreAuth = Ext.combine(this, "onPreAuth");
        this._extensions.onCredentials = Ext.combine(this, "onCredentials");
        this._extensions.onPostAuth = Ext.combine(this, "onPostAuth");
        this._extensions.onPreHandler = Ext.combine(this, "onPreHandler");
        this._extensions.onPostHandler = Ext.combine(this, "onPostHandler");
        this.rebuild();
      }
      _setupValidation() {
        const validation = this.settings.validate;
        if (this.method === "get") {
          validation.payload = null;
        }
        this._assert(!validation.params || this.params.length, "Cannot set path parameters validations without path parameters");
        for (const type of ["headers", "params", "query", "payload", "state"]) {
          validation[type] = Validation.compile(validation[type], this.settings.validate.validator, this.realm, this._core);
        }
        if (this.settings.response.schema !== void 0 || this.settings.response.status) {
          this.settings.response._validate = true;
          const rule = this.settings.response.schema;
          this.settings.response.status = this.settings.response.status ?? {};
          const statuses = Object.keys(this.settings.response.status);
          if (rule === true && !statuses.length) {
            this.settings.response._validate = false;
          } else {
            this.settings.response.schema = Validation.compile(rule, this.settings.validate.validator, this.realm, this._core);
            for (const code2 of statuses) {
              this.settings.response.status[code2] = Validation.compile(this.settings.response.status[code2], this.settings.validate.validator, this.realm, this._core);
            }
          }
        }
      }
      rebuild(event) {
        if (event) {
          this._extensions[event.type].add(event);
        }
        if (this._special) {
          this._postCycle = this._extensions.onPreResponse.nodes ? [this._extensions.onPreResponse] : [];
          this._buildMarshalCycle();
          return;
        }
        this._cycle = [];
        if (this.settings.state.parse) {
          this._cycle.push(internals.state);
        }
        if (this._extensions.onPreAuth.nodes) {
          this._cycle.push(this._extensions.onPreAuth);
        }
        if (this._core.auth._enabled(this, "authenticate")) {
          this._cycle.push(Auth.authenticate);
        }
        if (this.method !== "get") {
          this._cycle.push(internals.payload);
          if (this._core.auth._enabled(this, "payload")) {
            this._cycle.push(Auth.payload);
          }
        }
        if (this._core.auth._enabled(this, "authenticate") && this._extensions.onCredentials.nodes) {
          this._cycle.push(this._extensions.onCredentials);
        }
        if (this._core.auth._enabled(this, "access")) {
          this._cycle.push(Auth.access);
        }
        if (this._extensions.onPostAuth.nodes) {
          this._cycle.push(this._extensions.onPostAuth);
        }
        if (this.settings.validate.headers) {
          this._cycle.push(Validation.headers);
        }
        if (this.settings.validate.params) {
          this._cycle.push(Validation.params);
        }
        if (this.settings.validate.query) {
          this._cycle.push(Validation.query);
        }
        if (this.settings.validate.payload) {
          this._cycle.push(Validation.payload);
        }
        if (this.settings.validate.state) {
          this._cycle.push(Validation.state);
        }
        if (this._extensions.onPreHandler.nodes) {
          this._cycle.push(this._extensions.onPreHandler);
        }
        this._cycle.push(Handler.execute);
        if (this._extensions.onPostHandler.nodes) {
          this._cycle.push(this._extensions.onPostHandler);
        }
        this._postCycle = [];
        if (this.settings.response._validate && this.settings.response.sample !== 0) {
          this._postCycle.push(Validation.response);
        }
        if (this._extensions.onPreResponse.nodes) {
          this._postCycle.push(this._extensions.onPreResponse);
        }
        this._buildMarshalCycle();
      }
      _buildMarshalCycle() {
        this._marshalCycle = [Headers2.type];
        if (this.settings.cors) {
          this._marshalCycle.push(Cors.headers);
        }
        if (this.settings.security) {
          this._marshalCycle.push(Security.headers);
        }
        this._marshalCycle.push(Headers2.entity);
        if (this.method === "get" || this.method === "*") {
          this._marshalCycle.push(Headers2.unmodified);
        }
        this._marshalCycle.push(Headers2.cache);
        this._marshalCycle.push(Headers2.state);
        this._marshalCycle.push(Headers2.content);
        if (this._core.auth._enabled(this, "response")) {
          this._marshalCycle.push(Auth.response);
        }
      }
      _assert(condition, message) {
        if (condition) {
          return;
        }
        if (this.method[0] !== "_") {
          message = `${message}: ${this.method.toUpperCase()} ${this.path}`;
        }
        throw new Assert.AssertionError({
          message,
          actual: false,
          expected: true,
          operator: "==",
          stackStartFunction: this._assert
        });
      }
    };
    internals.state = async function(request) {
      request.state = {};
      const req = request.raw.req;
      const cookies = req.headers.cookie;
      if (!cookies) {
        return;
      }
      try {
        var result = await request._core.states.parse(cookies);
      } catch (err) {
        Bounce.rethrow(err, "system");
        var parseError = err;
      }
      const { states, failed = [] } = result ?? parseError;
      request.state = states ?? {};
      for (const item of failed) {
        if (item.settings.clearInvalid) {
          request._clearState(item.name);
        }
      }
      if (!parseError) {
        return;
      }
      parseError.header = cookies;
      return request._core.toolkit.failAction(request, request.route.settings.state.failAction, parseError, { tags: ["state", "error"] });
    };
    internals.payload = async function(request) {
      if (request.method === "get" || request.method === "head") {
        return;
      }
      if (request.payload !== void 0) {
        return internals.drain(request);
      }
      if (request._expectContinue) {
        request._expectContinue = false;
        request.raw.res.writeContinue();
      }
      try {
        const { payload, mime } = await Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload);
        request._isPayloadPending = !!payload?._readableState;
        request.mime = mime;
        request.payload = payload;
      } catch (err) {
        Bounce.rethrow(err, "system");
        await internals.drain(request);
        request.mime = err.mime;
        request.payload = null;
        return request._core.toolkit.failAction(request, request.route.settings.payload.failAction, err, { tags: ["payload", "error"] });
      }
    };
    internals.drain = async function(request) {
      if (request._expectContinue) {
        request._isPayloadPending = false;
        request._expectContinue = false;
      }
      if (request._isPayloadPending) {
        await Streams.drain(request.raw.req);
        request._isPayloadPending = false;
      }
    };
    internals.config = function(chain) {
      if (!chain.length) {
        return {};
      }
      let config2 = chain[0];
      for (const item of chain) {
        config2 = Hoek.applyToDefaults(config2, item, { shallow: ["bind", "validate.headers", "validate.payload", "validate.params", "validate.query", "validate.state"] });
      }
      return config2;
    };
    internals.rules = function(rules, info, server) {
      const configs = [];
      let realm = server.realm;
      while (realm) {
        if (realm._rules) {
          const source = !realm._rules.settings.validate ? rules : Validate.attempt(rules, realm._rules.settings.validate.schema, realm._rules.settings.validate.options);
          const config2 = realm._rules.processor(source, info);
          if (config2) {
            configs.unshift(config2);
          }
        }
        realm = realm.parent;
      }
      return internals.config(configs);
    };
  }
});
var require_cors = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/cors.js"(exports2) {
    "use strict";
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var Route = null;
    var internals = {};
    exports2.route = function(options3) {
      if (!options3) {
        return false;
      }
      const settings = Hoek.clone(options3);
      settings._headers = settings.headers.concat(settings.additionalHeaders);
      settings._headersString = settings._headers.join(",");
      for (let i2 = 0; i2 < settings._headers.length; ++i2) {
        settings._headers[i2] = settings._headers[i2].toLowerCase();
      }
      if (settings._headers.indexOf("origin") === -1) {
        settings._headers.push("origin");
      }
      settings._exposedHeaders = settings.exposedHeaders.concat(settings.additionalExposedHeaders).join(",");
      if (settings.origin === "ignore") {
        settings._origin = false;
      } else if (settings.origin.indexOf("*") !== -1) {
        Hoek.assert(settings.origin.length === 1, "Cannot specify cors.origin * together with other values");
        settings._origin = true;
      } else {
        settings._origin = {
          qualified: [],
          wildcards: []
        };
        for (const origin of settings.origin) {
          if (origin.indexOf("*") !== -1) {
            settings._origin.wildcards.push(new RegExp("^" + Hoek.escapeRegex(origin).replace(/\\\*/g, ".*").replace(/\\\?/g, ".") + "$"));
          } else {
            settings._origin.qualified.push(origin);
          }
        }
      }
      return settings;
    };
    exports2.options = function(route2, server) {
      if (route2.method === "options" || !route2.settings.cors) {
        return;
      }
      exports2.handler(server);
    };
    exports2.handler = function(server) {
      Route = Route || require_route();
      if (server._core.router.specials.options) {
        return;
      }
      const definition = {
        method: "_special",
        path: "/{p*}",
        handler: internals.handler,
        options: {
          cors: false
        }
      };
      const route2 = new Route(definition, server, { special: true });
      server._core.router.special("options", route2);
    };
    internals.handler = function(request, h2) {
      const method = request.headers["access-control-request-method"];
      if (!method) {
        throw Boom5.notFound("CORS error: Missing Access-Control-Request-Method header");
      }
      const route2 = request.server.match(method, request.path, request.info.hostname);
      if (!route2) {
        throw Boom5.notFound();
      }
      const settings = route2.settings.cors;
      if (!settings) {
        return { message: "CORS is disabled for this route" };
      }
      const origin = request.headers.origin;
      if (!origin && settings._origin !== false) {
        throw Boom5.notFound("CORS error: Missing Origin header");
      }
      if (!exports2.matchOrigin(origin, settings)) {
        return { message: "CORS error: Origin not allowed" };
      }
      let headers = request.headers["access-control-request-headers"];
      if (headers) {
        headers = headers.toLowerCase().split(/\s*,\s*/);
        if (Hoek.intersect(headers, settings._headers).length !== headers.length) {
          return { message: "CORS error: Some headers are not allowed" };
        }
      }
      const response = h2.response();
      response.code(settings.preflightStatusCode);
      response._header("access-control-allow-origin", settings._origin ? origin : "*");
      response._header("access-control-allow-methods", method);
      response._header("access-control-allow-headers", settings._headersString);
      response._header("access-control-max-age", settings.maxAge);
      if (settings.credentials) {
        response._header("access-control-allow-credentials", "true");
      }
      if (settings._exposedHeaders) {
        response._header("access-control-expose-headers", settings._exposedHeaders);
      }
      return response;
    };
    exports2.headers = function(response) {
      const request = response.request;
      const settings = request.route.settings.cors;
      if (settings._origin !== false) {
        response.vary("origin");
      }
      if (request.info.cors && !request.info.cors.isOriginMatch || // After route lookup
      !exports2.matchOrigin(request.headers.origin, request.route.settings.cors)) {
        return;
      }
      response._header("access-control-allow-origin", settings._origin ? request.headers.origin : "*");
      if (settings.credentials) {
        response._header("access-control-allow-credentials", "true");
      }
      if (settings._exposedHeaders) {
        response._header("access-control-expose-headers", settings._exposedHeaders, { append: true });
      }
    };
    exports2.matchOrigin = function(origin, settings) {
      if (settings._origin === true || settings._origin === false) {
        return true;
      }
      if (!origin) {
        return false;
      }
      if (settings._origin.qualified.indexOf(origin) !== -1) {
        return true;
      }
      for (const wildcard of settings._origin.wildcards) {
        if (origin.match(wildcard)) {
          return true;
        }
      }
      return false;
    };
  }
});
var require_toolkit = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/toolkit.js"(exports2) {
    "use strict";
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {};
    exports2.reserved = [
      "abandon",
      "authenticated",
      "close",
      "context",
      "continue",
      "entity",
      "redirect",
      "realm",
      "request",
      "response",
      "state",
      "unauthenticated",
      "unstate"
    ];
    exports2.symbols = {
      abandon: Symbol("abandon"),
      close: Symbol("close"),
      continue: Symbol("continue")
    };
    exports2.Manager = class {
      constructor() {
        this._toolkit = internals.toolkit();
      }
      async execute(method, request, options3) {
        const h2 = new this._toolkit(request, options3);
        const bind = options3.bind ?? null;
        try {
          let operation;
          if (bind) {
            operation = method.call(bind, request, h2);
          } else if (options3.args) {
            operation = method(request, h2, ...options3.args);
          } else {
            operation = method(request, h2);
          }
          var response = await exports2.timed(operation, options3);
        } catch (err) {
          if (Bounce.isSystem(err)) {
            response = Boom5.badImplementation(err);
          } else if (!Bounce.isError(err)) {
            response = Boom5.badImplementation("Cannot throw non-error object", err);
          } else {
            response = Boom5.boomify(err);
          }
        }
        if (options3.ignoreResponse) {
          return response;
        }
        if (response === void 0) {
          response = Boom5.badImplementation(`${method.name} method did not return a value, a promise, or throw an error`);
        }
        if (options3.continue && response === exports2.symbols.continue) {
          if (options3.continue === "undefined") {
            return;
          }
          response = null;
        }
        if (options3.auth && response instanceof internals.Auth) {
          return response;
        }
        if (typeof response !== "symbol") {
          response = request._core.Response.wrap(response, request);
          if (!response.isBoom && response._state === "init") {
            await response._prepare();
          }
        }
        return response;
      }
      decorate(name, method) {
        this._toolkit.prototype[name] = method;
      }
      async failAction(request, failAction, err, options3) {
        const retain = options3.retain ? err : void 0;
        if (failAction === "ignore") {
          return retain;
        }
        if (failAction === "log") {
          request._log(options3.tags, err);
          return retain;
        }
        if (failAction === "error") {
          throw err;
        }
        return await this.execute(failAction, request, { realm: request.route.realm, args: [options3.details ?? err] });
      }
    };
    exports2.timed = async function(method, options3) {
      if (!options3.timeout) {
        return method;
      }
      const timer2 = new Promise((resolve8, reject) => {
        const handler = () => {
          reject(Boom5.internal(`${options3.name} timed out`));
        };
        setTimeout(handler, options3.timeout);
      });
      return await Promise.race([timer2, method]);
    };
    internals.toolkit = function() {
      const Toolkit = class {
        constructor(request, options3) {
          this.context = options3.bind;
          this.realm = options3.realm;
          this.request = request;
          this._auth = options3.auth;
        }
        response(result) {
          Hoek.assert(!result || typeof result !== "object" || typeof result.then !== "function", "Cannot wrap a promise");
          Hoek.assert(result instanceof Error === false, "Cannot wrap an error");
          Hoek.assert(typeof result !== "symbol", "Cannot wrap a symbol");
          return this.request._core.Response.wrap(result, this.request);
        }
        redirect(location) {
          return this.response("").redirect(location);
        }
        entity(options3) {
          Hoek.assert(options3, "Entity method missing required options");
          Hoek.assert(options3.etag || options3.modified, "Entity methods missing required options key");
          this.request._entity = options3;
          const entity = this.request._core.Response.entity(options3.etag, options3);
          if (this.request._core.Response.unmodified(this.request, entity)) {
            return this.response().code(304).takeover();
          }
        }
        state(name, value, options3) {
          this.request._setState(name, value, options3);
        }
        unstate(name, options3) {
          this.request._clearState(name, options3);
        }
        authenticated(data) {
          Hoek.assert(this._auth, "Method not supported outside of authentication");
          Hoek.assert(data?.credentials, "Authentication data missing credentials information");
          return new internals.Auth(null, data);
        }
        unauthenticated(error, data) {
          Hoek.assert(this._auth, "Method not supported outside of authentication");
          Hoek.assert(!data || data.credentials, "Authentication data missing credentials information");
          return new internals.Auth(error, data);
        }
      };
      Toolkit.prototype.abandon = exports2.symbols.abandon;
      Toolkit.prototype.close = exports2.symbols.close;
      Toolkit.prototype.continue = exports2.symbols.continue;
      return Toolkit;
    };
    internals.Auth = class {
      constructor(error, data) {
        this.isAuth = true;
        this.error = error;
        this.data = data;
      }
    };
  }
});
var require_lib27 = __commonJS({
  "node_modules/.deno/@hapi+ammo@6.0.1/node_modules/@hapi/ammo/lib/index.js"(exports2) {
    "use strict";
    var Stream = __require2("stream");
    var Hoek = require_lib();
    var internals = {};
    internals.headerRx = /^bytes=[\s,]*((?:(?:\d+\-\d*)|(?:\-\d+))(?:\s*,\s*(?:(?:\d+\-\d*)|(?:\-\d+)))*)$/i;
    exports2.header = function(header, length4) {
      const parts = internals.headerRx.exec(header);
      if (!parts) {
        return null;
      }
      const lastPos = length4 - 1;
      const result = [];
      const ranges = parts[1].match(/\d*\-\d*/g);
      for (let range of ranges) {
        let from6;
        let to;
        range = range.split("-");
        if (range[0]) {
          from6 = parseInt(range[0], 10);
        }
        if (range[1]) {
          to = parseInt(range[1], 10);
          if (from6 !== void 0) {
            if (to > lastPos) {
              to = lastPos;
            }
          } else {
            from6 = length4 - to;
            to = lastPos;
          }
        } else {
          to = lastPos;
        }
        if (from6 > to) {
          return null;
        }
        result.push(new internals.Range(from6, to));
      }
      if (result.length === 1) {
        return result;
      }
      result.sort((a, b) => a.from - b.from);
      const consolidated = [];
      for (let i2 = result.length - 1; i2 > 0; --i2) {
        const current = result[i2];
        const before = result[i2 - 1];
        if (current.from <= before.to + 1) {
          before.to = current.to;
        } else {
          consolidated.unshift(current);
        }
      }
      consolidated.unshift(result[0]);
      return consolidated;
    };
    internals.Range = class {
      constructor(from6, to) {
        this.from = from6;
        this.to = to;
      }
    };
    exports2.Clip = class extends Stream.Transform {
      constructor(range) {
        if (!(range instanceof internals.Range)) {
          Hoek.assert(typeof range === "object", 'Expected "range" object');
          const from6 = range.from ?? 0;
          Hoek.assert(typeof from6 === "number", '"range.from" must be a number');
          Hoek.assert(from6 === parseInt(from6, 10) && from6 >= 0, '"range.from" must be a positive integer');
          const to = range.to ?? 0;
          Hoek.assert(typeof to === "number", '"range.to" must be a number');
          Hoek.assert(to === parseInt(to, 10) && to >= 0, '"range.to" must be a positive integer');
          Hoek.assert(to >= from6, '"range.to" must be greater than or equal to "range.from"');
          range = new internals.Range(from6, to);
        }
        super();
        this._range = range;
        this._next = 0;
        this._pipes = /* @__PURE__ */ new Set();
        this.on("pipe", (pipe2) => this._pipes.add(pipe2));
        this.on("unpipe", (pipe2) => this._pipes.delete(pipe2));
      }
      _transform(chunk, encoding, done) {
        try {
          internals.processChunk(this, chunk);
        } catch (err) {
          return done(err);
        }
        return done();
      }
      _flush(done) {
        this._pipes.clear();
        done();
      }
    };
    internals.processChunk = function(stream, chunk) {
      const pos = stream._next;
      stream._next = stream._next + chunk.length;
      if (stream._next <= stream._range.from) {
        return;
      }
      if (pos > stream._range.to) {
        for (const pipe2 of stream._pipes) {
          pipe2.unpipe(stream);
        }
        stream._pipes.clear();
        stream.end();
        return;
      }
      const from6 = Math.max(0, stream._range.from - pos);
      const to = Math.min(chunk.length, stream._range.to - pos + 1);
      stream.push(chunk.slice(from6, to));
    };
  }
});
var require_transmit = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/transmit.js"(exports2) {
    "use strict";
    var Http = __require2("http");
    var Ammo = require_lib27();
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Teamwork = require_lib5();
    var Config = require_config();
    var internals = {};
    exports2.send = async function(request) {
      const response = request.response;
      try {
        if (response.isBoom) {
          await internals.fail(request, response);
          return;
        }
        await internals.marshal(response);
        await internals.transmit(response);
      } catch (err) {
        Bounce.rethrow(err, "system");
        request._setResponse(err);
        return internals.fail(request, err);
      }
    };
    internals.marshal = async function(response) {
      for (const func of response.request._route._marshalCycle) {
        await func(response);
      }
    };
    internals.fail = async function(request, boom) {
      const response = internals.error(request, boom);
      request.response = response;
      try {
        await internals.marshal(response);
      } catch (err) {
        Bounce.rethrow(err, "system");
        const minimal = {
          statusCode: response.statusCode,
          error: Http.STATUS_CODES[response.statusCode],
          message: boom.message
        };
        response._payload = new request._core.Response.Payload(JSON.stringify(minimal), {});
      }
      return internals.transmit(response);
    };
    internals.error = function(request, boom) {
      const error = boom.output;
      const response = new request._core.Response(error.payload, request, { error: boom });
      response.code(error.statusCode);
      response.headers = Hoek.clone(error.headers);
      return response;
    };
    internals.transmit = function(response) {
      const request = response.request;
      const length4 = internals.length(response);
      const encoding = request._core.compression.encoding(response, length4);
      const ranger = encoding ? null : internals.range(response, length4);
      const compressor = internals.encoding(response, encoding);
      const isInjection = request.isInjected;
      if (!(isInjection || request._core.started) || request._isPayloadPending && !request.raw.req._readableState.ended) {
        response._header("connection", "close");
      }
      internals.writeHead(response);
      if (isInjection) {
        request.raw.res[Config.symbol] = { request };
        if (response.variety === "plain") {
          request.raw.res[Config.symbol].result = response._isPayloadSupported() ? response.source : null;
        }
      }
      const stream = internals.chain([response._payload, response._tap(), compressor, ranger]);
      return internals.pipe(request, stream);
    };
    internals.length = function(response) {
      const request = response.request;
      const header = response.headers["content-length"];
      if (header === void 0) {
        return null;
      }
      let length4 = header;
      if (typeof length4 === "string") {
        length4 = parseInt(header, 10);
        if (!isFinite(length4)) {
          delete response.headers["content-length"];
          return null;
        }
      }
      if (length4 === 0 && !response._statusCode && response.statusCode === 200 && request.route.settings.response.emptyStatusCode !== 200) {
        response.code(204);
        delete response.headers["content-length"];
      }
      return length4;
    };
    internals.range = function(response, length4) {
      const request = response.request;
      if (!length4 || !request.route.settings.response.ranges || request.method !== "get" || response.statusCode !== 200) {
        return null;
      }
      response._header("accept-ranges", "bytes");
      if (!request.headers.range) {
        return null;
      }
      if (request.headers["if-range"] && request.headers["if-range"] !== response.headers.etag) {
        return null;
      }
      const ranges = Ammo.header(request.headers.range, length4);
      if (!ranges) {
        const error = Boom5.rangeNotSatisfiable();
        error.output.headers["content-range"] = "bytes */" + length4;
        throw error;
      }
      if (ranges.length !== 1) {
        return null;
      }
      const range = ranges[0];
      response.code(206);
      response.bytes(range.to - range.from + 1);
      response._header("content-range", "bytes " + range.from + "-" + range.to + "/" + length4);
      return new Ammo.Clip(range);
    };
    internals.encoding = function(response, encoding) {
      const request = response.request;
      const header = response.headers["content-encoding"] || encoding;
      if (header && response.headers.etag && response.settings.varyEtag) {
        response.headers.etag = response.headers.etag.slice(0, -1) + "-" + header + '"';
      }
      if (!encoding || response.statusCode === 206 || !response._isPayloadSupported()) {
        return null;
      }
      delete response.headers["content-length"];
      response._header("content-encoding", encoding);
      const compressor = request._core.compression.encoder(request, encoding);
      if (response.variety === "stream" && typeof response._payload.setCompressor === "function") {
        response._payload.setCompressor(compressor);
      }
      return compressor;
    };
    internals.pipe = function(request, stream) {
      const team = new Teamwork.Team();
      const env = { stream, request, team };
      if (request._closed) {
        internals.end(env, "aborted");
        return team.work;
      }
      const aborted2 = internals.end.bind(null, env, "aborted");
      const close = internals.end.bind(null, env, "close");
      const end = internals.end.bind(null, env, null);
      request.raw.req.on("aborted", aborted2);
      request.raw.res.on("close", close);
      request.raw.res.on("error", end);
      request.raw.res.on("finish", end);
      if (stream.writeToStream) {
        stream.writeToStream(request.raw.res);
      } else {
        stream.on("error", end);
        stream.on("close", aborted2);
        stream.pipe(request.raw.res);
      }
      return team.work;
    };
    internals.end = function(env, event, err) {
      const { request, stream, team } = env;
      if (!team) {
        return;
      }
      env.team = null;
      if (request.raw.res.writableEnded) {
        request.info.responded = Date.now();
        team.attend();
        return;
      }
      if (err) {
        request.raw.res.destroy();
        request._core.Response.drain(stream);
      }
      const origResponse = request.response;
      const error = err ? Boom5.boomify(err) : new Boom5.Boom(`Request ${event}`, { statusCode: request.route.settings.response.disconnectStatusCode, data: origResponse });
      request._setResponse(error);
      if (request.raw.res[Config.symbol]) {
        request.raw.res[Config.symbol].error = event ? error : new Boom5.Boom(`Response error`, { statusCode: request.route.settings.response.disconnectStatusCode, data: origResponse });
      }
      if (event) {
        request._log(["response", "error", event]);
      } else {
        request._log(["response", "error"], err);
      }
      request.raw.res.end();
      team.attend();
    };
    internals.writeHead = function(response) {
      const res = response.request.raw.res;
      const headers = Object.keys(response.headers);
      let i2 = 0;
      try {
        for (; i2 < headers.length; ++i2) {
          const header = headers[i2];
          const value = response.headers[header];
          if (value !== void 0) {
            res.setHeader(header, value);
          }
        }
      } catch (err) {
        for (--i2; i2 >= 0; --i2) {
          res.removeHeader(headers[i2]);
        }
        throw Boom5.boomify(err);
      }
      if (response.settings.message) {
        res.statusMessage = response.settings.message;
      }
      try {
        res.writeHead(response.statusCode);
      } catch (err) {
        throw Boom5.boomify(err);
      }
    };
    internals.chain = function(sources) {
      let from6 = sources[0];
      for (let i2 = 1; i2 < sources.length; ++i2) {
        const to = sources[i2];
        if (to) {
          from6.on("close", internals.destroyPipe.bind(from6, to));
          from6.on("error", internals.errorPipe.bind(from6, to));
          from6 = from6.pipe(to);
        }
      }
      return from6;
    };
    internals.destroyPipe = function(to) {
      if (!this.readableEnded && !this.errored) {
        to.destroy();
      }
    };
    internals.errorPipe = function(to, err) {
      to.emit("error", err);
    };
  }
});
var require_request2 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/request.js"(exports2, module2) {
    "use strict";
    var Querystring = __require2("querystring");
    var Url = __require2("url");
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Cors = require_cors();
    var Toolkit = require_toolkit();
    var Transmit = require_transmit();
    var internals = {
      events: Podium.validate(["finish", { name: "peek", spread: true }, "disconnect"]),
      reserved: ["server", "url", "query", "path", "method", "mime", "setUrl", "setMethod", "headers", "id", "app", "plugins", "route", "auth", "pre", "preResponses", "info", "isInjected", "orig", "params", "paramsArray", "payload", "state", "response", "raw", "domain", "log", "logs", "generateResponse"]
    };
    exports2 = module2.exports = internals.Request = class {
      constructor(server, req, res, options3) {
        this._allowInternals = !!options3.allowInternals;
        this._closed = false;
        this._core = server._core;
        this._entity = null;
        this._eventContext = { request: this };
        this._events = null;
        this._expectContinue = !!options3.expectContinue;
        this._isInjected = !!options3.isInjected;
        this._isPayloadPending = !!(req.headers["content-length"] || req.headers["transfer-encoding"]);
        this._isReplied = false;
        this._route = this._core.router.specials.notFound.route;
        this._serverTimeoutId = null;
        this._states = {};
        this._url = null;
        this._urlError = null;
        this.app = options3.app ? Object.assign({}, options3.app) : {};
        this.headers = req.headers;
        this.logs = [];
        this.method = req.method.toLowerCase();
        this.mime = null;
        this.orig = {};
        this.params = null;
        this.paramsArray = null;
        this.path = null;
        this.payload = void 0;
        this.plugins = options3.plugins ? Object.assign({}, options3.plugins) : {};
        this.pre = {};
        this.preResponses = {};
        this.raw = { req, res };
        this.response = null;
        this.route = this._route.public;
        this.query = null;
        this.server = server;
        this.state = null;
        this.info = new internals.Info(this);
        this.auth = {
          isAuthenticated: false,
          isAuthorized: false,
          isInjected: options3.auth ? true : false,
          [internals.Request.symbols.authPayload]: options3.auth?.payload ?? true,
          credentials: options3.auth?.credentials ?? null,
          // Special keys: 'app', 'user', 'scope'
          artifacts: options3.auth?.artifacts ?? null,
          // Scheme-specific artifacts
          strategy: options3.auth?.strategy ?? null,
          mode: null,
          error: null
        };
        this._initializeUrl();
      }
      static generate(server, req, res, options3) {
        const request = new server._core.Request(server, req, res, options3);
        if (server._core.decorations.requestApply) {
          for (const [property, assignment] of server._core.decorations.requestApply.entries()) {
            request[property] = assignment(request);
          }
        }
        request._listen();
        return request;
      }
      get events() {
        if (!this._events) {
          this._events = new Podium.Podium(internals.events);
        }
        return this._events;
      }
      get isInjected() {
        return this._isInjected;
      }
      get url() {
        if (this._urlError) {
          return null;
        }
        if (this._url) {
          return this._url;
        }
        return this._parseUrl(this.raw.req.url, this._core.settings.router);
      }
      _initializeUrl() {
        try {
          this._setUrl(this.raw.req.url, this._core.settings.router.stripTrailingSlash, { fast: true });
        } catch (err) {
          this.path = this.raw.req.url;
          this.query = {};
          this._urlError = Boom5.boomify(err, { statusCode: 400, override: false });
        }
      }
      setUrl(url, stripTrailingSlash) {
        Hoek.assert(this.params === null, "Cannot change request URL after routing");
        if (url instanceof Url.URL) {
          url = url.href;
        }
        Hoek.assert(typeof url === "string", "Url must be a string or URL object");
        this._setUrl(url, stripTrailingSlash, { fast: false });
      }
      _setUrl(source, stripTrailingSlash, { fast }) {
        const url = this._parseUrl(source, { stripTrailingSlash, _fast: fast });
        this.query = this._parseQuery(url.searchParams);
        this.path = url.pathname;
      }
      _parseUrl(source, options3) {
        if (source[0] === "/") {
          if (options3._fast) {
            const url = {
              pathname: source,
              searchParams: ""
            };
            const q = source.indexOf("?");
            const h2 = source.indexOf("#");
            if (q !== -1 && (h2 === -1 || q < h2)) {
              url.pathname = source.slice(0, q);
              const query = h2 === -1 ? source.slice(q + 1) : source.slice(q + 1, h2);
              url.searchParams = Querystring.parse(query);
            } else {
              url.pathname = h2 === -1 ? source : source.slice(0, h2);
            }
            this._normalizePath(url, options3);
            return url;
          }
          this._url = new Url.URL(`${this._core.info.protocol}://${this.info.host || `${this._core.info.host}:${this._core.info.port}`}${source}`);
        } else {
          this._url = new Url.URL(source);
          this.info.hostname = this._url.hostname;
          this.info.host = this._url.host;
        }
        this._normalizePath(this._url, options3);
        this._urlError = null;
        return this._url;
      }
      _normalizePath(url, options3) {
        let path12 = this._core.router.normalize(url.pathname);
        if (options3.stripTrailingSlash && path12.length > 1 && path12[path12.length - 1] === "/") {
          path12 = path12.slice(0, -1);
        }
        url.pathname = path12;
      }
      _parseQuery(searchParams) {
        let query = /* @__PURE__ */ Object.create(null);
        if (searchParams instanceof Url.URLSearchParams) {
          for (let [key, value] of searchParams) {
            const entry = query[key];
            if (entry !== void 0) {
              value = [].concat(entry, value);
            }
            query[key] = value;
          }
        } else {
          query = Object.assign(query, searchParams);
        }
        const parser2 = this._core.settings.query.parser;
        if (parser2) {
          query = parser2(query);
          if (!query || typeof query !== "object") {
            throw Boom5.badImplementation("Parsed query must be an object");
          }
        }
        return query;
      }
      setMethod(method) {
        Hoek.assert(this.params === null, "Cannot change request method after routing");
        Hoek.assert(method && typeof method === "string", "Missing method");
        this.method = method.toLowerCase();
      }
      active() {
        return !!this._eventContext.request;
      }
      async _execute() {
        this.info.acceptEncoding = this._core.compression.accept(this);
        try {
          await this._onRequest();
        } catch (err) {
          Bounce.rethrow(err, "system");
          return this._reply(err);
        }
        this._lookup();
        this._setTimeouts();
        await this._lifecycle();
        this._reply();
      }
      async _onRequest() {
        if (this._core.extensions.route.onRequest.nodes) {
          const response = await this._invoke(this._core.extensions.route.onRequest);
          if (response) {
            if (!internals.skip(response)) {
              throw Boom5.badImplementation("onRequest extension methods must return an error, a takeover response, or a continue signal");
            }
            throw response;
          }
        }
        if (this._urlError) {
          throw this._urlError;
        }
      }
      _listen() {
        if (this._isPayloadPending) {
          this.raw.req.on("end", internals.event.bind(this.raw.req, this._eventContext, "end"));
        }
        this.raw.res.on("close", internals.event.bind(this.raw.res, this._eventContext, "close"));
        this.raw.req.on("error", internals.event.bind(this.raw.req, this._eventContext, "error"));
        this.raw.req.on("aborted", internals.event.bind(this.raw.req, this._eventContext, "abort"));
        this.raw.res.once("close", internals.closed.bind(this.raw.res, this));
      }
      _lookup() {
        const match = this._core.router.route(this.method, this.path, this.info.hostname);
        if (!match.route.settings.isInternal || this._allowInternals) {
          this._route = match.route;
          this.route = this._route.public;
        }
        this.params = match.params ?? {};
        this.paramsArray = match.paramsArray ?? [];
        if (this.route.settings.cors) {
          this.info.cors = {
            isOriginMatch: Cors.matchOrigin(this.headers.origin, this.route.settings.cors)
          };
        }
      }
      _setTimeouts() {
        if (this.raw.req.socket && this.route.settings.timeout.socket !== void 0) {
          this.raw.req.socket.setTimeout(this.route.settings.timeout.socket || 0);
        }
        let serverTimeout = this.route.settings.timeout.server;
        if (!serverTimeout) {
          return;
        }
        const elapsed = Date.now() - this.info.received;
        serverTimeout = Math.floor(serverTimeout - elapsed);
        if (serverTimeout <= 0) {
          internals.timeoutReply(this, serverTimeout);
          return;
        }
        this._serverTimeoutId = setTimeout(internals.timeoutReply, serverTimeout, this, serverTimeout);
      }
      async _lifecycle() {
        for (const func of this._route._cycle) {
          if (this._isReplied) {
            return;
          }
          try {
            var response = await (typeof func === "function" ? func(this) : this._invoke(func));
          } catch (err) {
            Bounce.rethrow(err, "system");
            response = this._core.Response.wrap(err, this);
          }
          if (!response || response === Toolkit.symbols.continue) {
            continue;
          }
          if (!internals.skip(response)) {
            response = Boom5.badImplementation("Lifecycle methods called before the handler can only return an error, a takeover response, or a continue signal");
          }
          this._setResponse(response);
          return;
        }
      }
      async _invoke(event, options3 = {}) {
        for (const ext of event.nodes) {
          const realm = ext.realm;
          const bind = ext.bind ?? realm.settings.bind;
          const response = await this._core.toolkit.execute(ext.func, this, { bind, realm, timeout: ext.timeout, name: event.type, ignoreResponse: options3.ignoreResponse });
          if (options3.ignoreResponse) {
            if (Boom5.isBoom(response)) {
              this._log(["ext", "error"], response);
            }
            continue;
          }
          if (response === Toolkit.symbols.continue) {
            continue;
          }
          if (internals.skip(response) || this.response === null) {
            return response;
          }
          this._setResponse(response);
        }
      }
      async _reply(exit3) {
        if (this._isReplied) {
          return;
        }
        this._isReplied = true;
        if (this._serverTimeoutId) {
          clearTimeout(this._serverTimeoutId);
        }
        if (exit3) {
          this._setResponse(this._core.Response.wrap(exit3, this));
        }
        if (!this._eventContext.request) {
          this._finalize();
          return;
        }
        if (typeof this.response === "symbol") {
          this._abort();
          return;
        }
        await this._postCycle();
        if (!this._eventContext.request || typeof this.response === "symbol") {
          this._abort();
          return;
        }
        await Transmit.send(this);
        this._finalize();
      }
      async _postCycle() {
        for (const func of this._route._postCycle) {
          if (!this._eventContext.request) {
            return;
          }
          try {
            var response = await (typeof func === "function" ? func(this) : this._invoke(func));
          } catch (err) {
            Bounce.rethrow(err, "system");
            response = this._core.Response.wrap(err, this);
          }
          if (response && response !== Toolkit.symbols.continue) {
            this._setResponse(response);
          }
        }
      }
      _abort() {
        if (this.response === Toolkit.symbols.close) {
          this.raw.res.end();
        }
        this._finalize();
      }
      _finalize() {
        this._eventContext.request = null;
        if (this.response._close) {
          if (this.response.statusCode === 500 && this.response._error) {
            const tags = this.response._error.isDeveloperError ? ["internal", "implementation", "error"] : ["internal", "error"];
            this._log(tags, this.response._error, "error");
          }
          this.response._close();
        }
        this.info.completed = Date.now();
        this._core.events.emit("response", this);
        if (this._route._extensions.onPostResponse.nodes) {
          this._invoke(this._route._extensions.onPostResponse, { ignoreResponse: true });
        }
      }
      _setResponse(response) {
        if (this.response && !this.response.isBoom && this.response !== response && this.response.source !== response.source) {
          this.response._close?.();
        }
        if (this.info.completed) {
          response._close?.();
          return;
        }
        this.response = response;
      }
      _setState(name, value, options3) {
        const state = { name, value };
        if (options3) {
          Hoek.assert(!options3.autoValue, "Cannot set autoValue directly in a response");
          state.options = Hoek.clone(options3);
        }
        this._states[name] = state;
      }
      _clearState(name, options3 = {}) {
        const state = { name };
        state.options = Hoek.clone(options3);
        state.options.ttl = 0;
        this._states[name] = state;
      }
      _tap() {
        if (!this._events) {
          return null;
        }
        if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
          return new this._core.Response.Peek(this._events);
        }
        return null;
      }
      log(tags, data) {
        return this._log(tags, data, "app");
      }
      _log(tags, data, channel = "internal") {
        if (!this._core.events.hasListeners("request") && !this.route.settings.log.collect) {
          return;
        }
        if (!Array.isArray(tags)) {
          tags = [tags];
        }
        const timestamp = Date.now();
        const field = data instanceof Error ? "error" : "data";
        let event = [this, { request: this.info.id, timestamp, tags, [field]: data, channel }];
        if (typeof data === "function") {
          event = () => [this, { request: this.info.id, timestamp, tags, data: data(), channel }];
        }
        if (this.route.settings.log.collect) {
          if (typeof data === "function") {
            event = event();
          }
          this.logs.push(event[1]);
        }
        this._core.events.emit({ name: "request", channel, tags }, event);
      }
      generateResponse(source, options3) {
        return new this._core.Response(source, this, options3);
      }
    };
    internals.Request.reserved = internals.reserved;
    internals.Request.symbols = {
      authPayload: Symbol("auth.payload")
    };
    internals.Info = class {
      constructor(request) {
        this._request = request;
        const req = request.raw.req;
        const host = req.headers.host ? req.headers.host.trim() : "";
        const received = Date.now();
        this.received = received;
        this.referrer = req.headers.referrer || req.headers.referer || "";
        this.host = host;
        this.hostname = host.split(":")[0];
        this.id = `${received}:${request._core.info.id}:${request._core._counter()}`;
        this._remoteAddress = null;
        this._remotePort = null;
        this.acceptEncoding = null;
        this.cors = null;
        this.responded = 0;
        this.completed = 0;
        if (request._core.settings.info.remote) {
          this.remoteAddress;
          this.remotePort;
        }
      }
      get remoteAddress() {
        if (!this._remoteAddress) {
          const ipv6Prefix = "::ffff:";
          const socketAddress = this._request.raw.req.socket.remoteAddress;
          if (socketAddress && socketAddress.startsWith(ipv6Prefix) && socketAddress.includes(".", ipv6Prefix.length)) {
            this._remoteAddress = socketAddress.slice(ipv6Prefix.length);
          } else {
            this._remoteAddress = socketAddress;
          }
        }
        return this._remoteAddress;
      }
      get remotePort() {
        if (this._remotePort === null) {
          this._remotePort = this._request.raw.req.socket.remotePort || "";
        }
        return this._remotePort;
      }
      toJSON() {
        return {
          acceptEncoding: this.acceptEncoding,
          completed: this.completed,
          cors: this.cors,
          host: this.host,
          hostname: this.hostname,
          id: this.id,
          received: this.received,
          referrer: this.referrer,
          remoteAddress: this.remoteAddress,
          remotePort: this.remotePort,
          responded: this.responded
        };
      }
    };
    internals.closed = function(request) {
      request._closed = true;
    };
    internals.event = function({ request }, event, err) {
      if (!request) {
        return;
      }
      request._isPayloadPending = false;
      if (event === "close" && request.raw.res.writableEnded) {
        return;
      }
      if (event === "end") {
        return;
      }
      request._log(err ? ["request", "error"] : ["request", "error", event], err);
      if (event === "error") {
        return;
      }
      request._eventContext.request = null;
      if (event === "abort") {
        request._reply(new Boom5.Boom("Request aborted", { statusCode: request.route.settings.response.disconnectStatusCode, data: request.response }));
        if (request._events) {
          request._events.emit("disconnect");
        }
      }
    };
    internals.timeoutReply = function(request, timeout) {
      const elapsed = Date.now() - request.info.received;
      request._log(["request", "server", "timeout", "error"], { timeout, elapsed });
      request._reply(Boom5.serverUnavailable());
    };
    internals.skip = function(response) {
      return response.isBoom || response._takeover || typeof response === "symbol";
    };
  }
});
var require_auth = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/auth.js"(exports2, module2) {
    "use strict";
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Config = require_config();
    var Request2 = require_request2();
    var internals = {
      missing: Symbol("missing")
    };
    exports2 = module2.exports = internals.Auth = class {
      #core = null;
      #schemes = {};
      #strategies = {};
      api = {};
      // Do not reassign api or settings, as they are referenced in public()
      settings = {
        default: null
        // Strategy used as default if route has no auth settings
      };
      constructor(core) {
        this.#core = core;
      }
      public(server) {
        return {
          api: this.api,
          settings: this.settings,
          scheme: this.scheme.bind(this),
          strategy: this._strategy.bind(this, server),
          default: this.default.bind(this),
          test: this.test.bind(this),
          verify: this.verify.bind(this),
          lookup: this.lookup.bind(this)
        };
      }
      scheme(name, scheme) {
        Hoek.assert(name, "Authentication scheme must have a name");
        Hoek.assert(!this.#schemes[name], "Authentication scheme name already exists:", name);
        Hoek.assert(typeof scheme === "function", "scheme must be a function:", name);
        this.#schemes[name] = scheme;
      }
      _strategy(server, name, scheme, options3 = {}) {
        Hoek.assert(name, "Authentication strategy must have a name");
        Hoek.assert(typeof options3 === "object", "options must be an object");
        Hoek.assert(!this.#strategies[name], "Authentication strategy name already exists");
        Hoek.assert(scheme, "Authentication strategy", name, "missing scheme");
        Hoek.assert(this.#schemes[scheme], "Authentication strategy", name, "uses unknown scheme:", scheme);
        server = server._clone();
        const strategy = this.#schemes[scheme](server, options3);
        Hoek.assert(strategy.authenticate, "Invalid scheme:", name, "missing authenticate() method");
        Hoek.assert(typeof strategy.authenticate === "function", "Invalid scheme:", name, "invalid authenticate() method");
        Hoek.assert(!strategy.payload || typeof strategy.payload === "function", "Invalid scheme:", name, "invalid payload() method");
        Hoek.assert(!strategy.response || typeof strategy.response === "function", "Invalid scheme:", name, "invalid response() method");
        strategy.options = strategy.options ?? {};
        Hoek.assert(strategy.payload || !strategy.options.payload, "Cannot require payload validation without a payload method");
        this.#strategies[name] = {
          methods: strategy,
          realm: server.realm
        };
        if (strategy.api) {
          this.api[name] = strategy.api;
        }
      }
      default(options3) {
        Hoek.assert(!this.settings.default, "Cannot set default strategy more than once");
        options3 = Config.apply("auth", options3, "default strategy");
        this.settings.default = this._setupRoute(Hoek.clone(options3));
        const routes = this.#core.router.table();
        for (const route2 of routes) {
          route2.rebuild();
        }
      }
      async test(name, request) {
        Hoek.assert(name, "Missing authentication strategy name");
        const strategy = this.#strategies[name];
        Hoek.assert(strategy, "Unknown authentication strategy:", name);
        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });
        if (!response.isAuth) {
          throw response;
        }
        if (response.error) {
          throw response.error;
        }
        return response.data;
      }
      async verify(request) {
        const auth = request.auth;
        if (auth.error) {
          throw auth.error;
        }
        if (!auth.isAuthenticated) {
          return;
        }
        const strategy = this.#strategies[auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", auth.strategy);
        if (!strategy.methods.verify) {
          return;
        }
        const bind = strategy.methods;
        await strategy.methods.verify.call(bind, auth);
      }
      static testAccess(request, route2) {
        const auth = request._core.auth;
        try {
          return auth._access(request, route2);
        } catch (err) {
          Bounce.rethrow(err, "system");
          return false;
        }
      }
      _setupRoute(options3, path12) {
        if (!options3) {
          return options3;
        }
        if (typeof options3 === "string") {
          options3 = { strategies: [options3] };
        } else if (options3.strategy) {
          options3.strategies = [options3.strategy];
          delete options3.strategy;
        }
        if (path12 && !options3.strategies) {
          Hoek.assert(this.settings.default, "Route missing authentication strategy and no default defined:", path12);
          options3 = Hoek.applyToDefaults(this.settings.default, options3);
        }
        path12 = path12 ?? "default strategy";
        Hoek.assert(options3.strategies?.length, "Missing authentication strategy:", path12);
        options3.mode = options3.mode ?? "required";
        if (options3.entity !== void 0 || // Backwards compatibility with <= 11.x.x
        options3.scope !== void 0) {
          options3.access = [{ entity: options3.entity, scope: options3.scope }];
          delete options3.entity;
          delete options3.scope;
        }
        if (options3.access) {
          for (const access of options3.access) {
            access.scope = internals.setupScope(access);
          }
        }
        if (options3.payload === true) {
          options3.payload = "required";
        }
        let hasAuthenticatePayload = false;
        for (const name of options3.strategies) {
          const strategy = this.#strategies[name];
          Hoek.assert(strategy, "Unknown authentication strategy", name, "in", path12);
          Hoek.assert(strategy.methods.payload || options3.payload !== "required", "Payload validation can only be required when all strategies support it in", path12);
          hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;
          Hoek.assert(!strategy.methods.options.payload || options3.payload === void 0 || options3.payload === "required", "Cannot set authentication payload to", options3.payload, "when a strategy requires payload validation in", path12);
        }
        Hoek.assert(!options3.payload || hasAuthenticatePayload, "Payload authentication requires at least one strategy with payload support in", path12);
        return options3;
      }
      lookup(route2) {
        if (route2.settings.auth === false) {
          return false;
        }
        return route2.settings.auth || this.settings.default;
      }
      _enabled(route2, type) {
        const config2 = this.lookup(route2);
        if (!config2) {
          return false;
        }
        if (type === "authenticate") {
          return true;
        }
        if (type === "access") {
          return !!config2.access;
        }
        for (const name of config2.strategies) {
          const strategy = this.#strategies[name];
          if (strategy.methods[type]) {
            return true;
          }
        }
        return false;
      }
      static authenticate(request) {
        const auth = request._core.auth;
        return auth._authenticate(request);
      }
      async _authenticate(request) {
        const config2 = this.lookup(request.route);
        const errors = [];
        request.auth.mode = config2.mode;
        if (request.auth.credentials) {
          internals.validate(null, { credentials: request.auth.credentials, artifacts: request.auth.artifacts }, request.auth.strategy, config2, request, errors);
          return;
        }
        for (const name of config2.strategies) {
          const strategy = this.#strategies[name];
          const bind = strategy.methods;
          const realm = strategy.realm;
          const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });
          const message = response.isAuth ? internals.validate(response.error, response.data, name, config2, request, errors) : internals.validate(response, null, name, config2, request, errors);
          if (!message) {
            return;
          }
          if (message !== internals.missing) {
            return message;
          }
        }
        const err = Boom5.unauthorized("Missing authentication", errors);
        if (config2.mode === "required") {
          throw err;
        }
        request.auth.isAuthenticated = false;
        request.auth.credentials = null;
        request.auth.error = err;
        request._log(["auth", "unauthenticated"]);
      }
      static access(request) {
        const auth = request._core.auth;
        request.auth.isAuthorized = auth._access(request);
      }
      _access(request, route2) {
        const config2 = this.lookup(route2 || request.route);
        if (!config2?.access) {
          return true;
        }
        const credentials = request.auth.credentials;
        if (!credentials) {
          if (config2.mode !== "required") {
            return false;
          }
          throw Boom5.forbidden("Request is unauthenticated");
        }
        const requestEntity = credentials.user ? "user" : "app";
        const scopeErrors = [];
        for (const access of config2.access) {
          const entity = access.entity;
          if (entity && entity !== "any" && entity !== requestEntity) {
            continue;
          }
          let scope = access.scope;
          if (scope) {
            if (!credentials.scope) {
              scopeErrors.push(scope);
              continue;
            }
            scope = internals.expandScope(request, scope);
            if (!internals.validateScope(credentials, scope, "required") || !internals.validateScope(credentials, scope, "selection") || !internals.validateScope(credentials, scope, "forbidden")) {
              scopeErrors.push(scope);
              continue;
            }
          }
          return true;
        }
        if (scopeErrors.length) {
          request._log(["auth", "scope", "error"]);
          throw Boom5.forbidden("Insufficient scope", { got: credentials.scope, need: scopeErrors });
        }
        if (requestEntity === "app") {
          request._log(["auth", "entity", "user", "error"]);
          throw Boom5.forbidden("Application credentials cannot be used on a user endpoint");
        }
        request._log(["auth", "entity", "app", "error"]);
        throw Boom5.forbidden("User credentials cannot be used on an application endpoint");
      }
      static async payload(request) {
        if (!request.auth.isAuthenticated || !request.auth[Request2.symbols.authPayload]) {
          return;
        }
        const auth = request._core.auth;
        const strategy = auth.#strategies[request.auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
        if (!strategy.methods.payload) {
          return;
        }
        const config2 = auth.lookup(request.route);
        const setting = config2.payload ?? (strategy.methods.options.payload ? "required" : false);
        if (!setting) {
          return;
        }
        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.payload, request, { bind, realm });
        if (response.isBoom && response.isMissing) {
          return setting === "optional" ? void 0 : Boom5.unauthorized("Missing payload authentication");
        }
        return response;
      }
      static async response(response) {
        const request = response.request;
        const auth = request._core.auth;
        if (!request.auth.isAuthenticated) {
          return;
        }
        const strategy = auth.#strategies[request.auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
        if (!strategy.methods.response) {
          return;
        }
        const bind = strategy.methods;
        const realm = strategy.realm;
        const error = await request._core.toolkit.execute(strategy.methods.response, request, { bind, realm, continue: "undefined" });
        if (error) {
          throw error;
        }
      }
    };
    internals.setupScope = function(access) {
      if (!access.scope) {
        return false;
      }
      if (!Array.isArray(access.scope)) {
        return access.scope;
      }
      const scope = {};
      for (const value of access.scope) {
        const prefix = value[0];
        const type = prefix === "+" ? "required" : prefix === "!" ? "forbidden" : "selection";
        const clean = type === "selection" ? value : value.slice(1);
        scope[type] = scope[type] ?? [];
        scope[type].push(clean);
        if (!scope._hasParameters?.[type] && /{([^}]+)}/.test(clean)) {
          scope._hasParameters = scope._hasParameters ?? {};
          scope._hasParameters[type] = true;
        }
      }
      return scope;
    };
    internals.validate = function(err, result, name, config2, request, errors) {
      result = result ?? {};
      request.auth.isAuthenticated = !err;
      if (err) {
        if (err instanceof Error === false) {
          request._log(["auth", "unauthenticated", "response", name], { statusCode: err.statusCode });
          return err;
        }
        if (err.isMissing) {
          request._log(["auth", "unauthenticated", "missing", name], err);
          errors.push(err.output.headers["WWW-Authenticate"]);
          return internals.missing;
        }
      }
      request.auth.strategy = name;
      request.auth.credentials = result.credentials;
      request.auth.artifacts = result.artifacts;
      if (!err) {
        return;
      }
      request.auth.error = err;
      if (config2.mode === "try") {
        request._log(["auth", "unauthenticated", "try", name], err);
        return;
      }
      request._log(["auth", "unauthenticated", "error", name], err);
      throw err;
    };
    internals.expandScope = function(request, scope) {
      if (!scope._hasParameters) {
        return scope;
      }
      const expanded = {
        required: internals.expandScopeType(request, scope, "required"),
        selection: internals.expandScopeType(request, scope, "selection"),
        forbidden: internals.expandScopeType(request, scope, "forbidden")
      };
      return expanded;
    };
    internals.expandScopeType = function(request, scope, type) {
      if (!scope._hasParameters[type]) {
        return scope[type];
      }
      const expanded = [];
      const context = {
        params: request.params,
        query: request.query,
        payload: request.payload,
        credentials: request.auth.credentials
      };
      for (const template of scope[type]) {
        expanded.push(Hoek.reachTemplate(context, template));
      }
      return expanded;
    };
    internals.validateScope = function(credentials, scope, type) {
      if (!scope[type]) {
        return true;
      }
      const count3 = typeof credentials.scope === "string" ? scope[type].indexOf(credentials.scope) !== -1 ? 1 : 0 : Hoek.intersect(scope[type], credentials.scope).length;
      if (type === "forbidden") {
        return count3 === 0;
      }
      if (type === "required") {
        return count3 === scope.required.length;
      }
      return !!count3;
    };
  }
});
var require_header = __commonJS({
  "node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/header.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Boom5 = require_lib6();
    var internals = {};
    exports2.selection = function(header, preferences, options3) {
      const selections = exports2.selections(header, preferences, options3);
      return selections.length ? selections[0] : "";
    };
    exports2.selections = function(header, preferences, options3) {
      Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
      return internals.parse(header || "", preferences, options3);
    };
    internals.parse = function(raw, preferences, options3) {
      const header = raw.replace(/[ \t]/g, "");
      const lowers = /* @__PURE__ */ new Map();
      if (preferences) {
        let pos = 0;
        for (const preference of preferences) {
          const lower = preference.toLowerCase();
          lowers.set(lower, { orig: preference, pos: pos++ });
          if (options3.prefixMatch) {
            const parts2 = lower.split("-");
            while (parts2.pop(), parts2.length > 0) {
              const joined = parts2.join("-");
              if (!lowers.has(joined)) {
                lowers.set(joined, { orig: preference, pos: pos++ });
              }
            }
          }
        }
      }
      const parts = header.split(",");
      const selections = [];
      const map = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < parts.length; ++i2) {
        const part = parts[i2];
        if (!part) {
          continue;
        }
        const params = part.split(";");
        if (params.length > 2) {
          throw Boom5.badRequest(`Invalid ${options3.type} header`);
        }
        let token = params[0].toLowerCase();
        if (!token) {
          throw Boom5.badRequest(`Invalid ${options3.type} header`);
        }
        if (options3.equivalents?.has(token)) {
          token = options3.equivalents.get(token);
        }
        const selection = {
          token,
          pos: i2,
          q: 1
        };
        if (preferences && lowers.has(token)) {
          selection.pref = lowers.get(token).pos;
        }
        map.add(selection.token);
        if (params.length === 2) {
          const q = params[1];
          const [key, value] = q.split("=");
          if (!value || key !== "q" && key !== "Q") {
            throw Boom5.badRequest(`Invalid ${options3.type} header`);
          }
          const score = parseFloat(value);
          if (score === 0) {
            continue;
          }
          if (Number.isFinite(score) && score <= 1 && score >= 1e-3) {
            selection.q = score;
          }
        }
        selections.push(selection);
      }
      selections.sort(internals.sort);
      const values = selections.map((selection) => selection.token);
      if (options3.default && !map.has(options3.default)) {
        values.push(options3.default);
      }
      if (!preferences?.length) {
        return values;
      }
      const preferred = [];
      for (const selection of values) {
        if (selection === "*") {
          for (const [preference, value] of lowers) {
            if (!map.has(preference)) {
              preferred.push(value.orig);
            }
          }
        } else {
          const lower = selection.toLowerCase();
          if (lowers.has(lower)) {
            preferred.push(lowers.get(lower).orig);
          }
        }
      }
      return preferred;
    };
    internals.sort = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      if (b.q !== a.q) {
        return b.q - a.q;
      }
      if (b.pref !== a.pref) {
        if (a.pref === void 0) {
          return bFirst;
        }
        if (b.pref === void 0) {
          return aFirst;
        }
        return a.pref - b.pref;
      }
      return a.pos - b.pos;
    };
  }
});
var require_media = __commonJS({
  "node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/media.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Boom5 = require_lib6();
    var internals = {};
    exports2.selection = function(header, preferences) {
      const selections = exports2.selections(header, preferences);
      return selections.length ? selections[0] : "";
    };
    exports2.selections = function(header, preferences) {
      Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
      return internals.parse(header, preferences);
    };
    internals.validMediaRx = /^(?:\*\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/[\w\!#\$%&'\*\+\-\.\^`\|~]+)$/;
    internals.parse = function(raw, preferences) {
      const { header, quoted } = internals.normalize(raw);
      const parts = header.split(",");
      const selections = [];
      const map = {};
      for (let i2 = 0; i2 < parts.length; ++i2) {
        const part = parts[i2];
        if (!part) {
          continue;
        }
        const pairs = part.split(";");
        const token = pairs.shift().toLowerCase();
        if (!internals.validMediaRx.test(token)) {
          continue;
        }
        const selection = {
          token,
          params: {},
          exts: {},
          pos: i2
        };
        let target = "params";
        for (const pair of pairs) {
          const kv = pair.split("=");
          if (kv.length !== 2 || !kv[1]) {
            throw Boom5.badRequest(`Invalid accept header`);
          }
          const key = kv[0];
          let value = kv[1];
          if (key === "q" || key === "Q") {
            target = "exts";
            value = parseFloat(value);
            if (!Number.isFinite(value) || value > 1 || value < 1e-3 && value !== 0) {
              value = 1;
            }
            selection.q = value;
          } else {
            if (value[0] === '"') {
              value = `"${quoted[value]}"`;
            }
            selection[target][kv[0]] = value;
          }
        }
        const params = Object.keys(selection.params);
        selection.original = [""].concat(params.map((key) => `${key}=${selection.params[key]}`)).join(";");
        selection.specificity = params.length;
        if (selection.q === void 0) {
          selection.q = 1;
        }
        const tparts = selection.token.split("/");
        selection.type = tparts[0];
        selection.subtype = tparts[1];
        map[selection.token] = selection;
        if (selection.q) {
          selections.push(selection);
        }
      }
      selections.sort(internals.sort);
      return internals.preferences(map, selections, preferences);
    };
    internals.normalize = function(raw) {
      raw = raw || "*/*";
      const normalized = {
        header: raw,
        quoted: {}
      };
      if (raw.includes('"')) {
        let i2 = 0;
        normalized.header = raw.replace(/="([^"]*)"/g, ($0, $1) => {
          const key = '"' + ++i2;
          normalized.quoted[key] = $1;
          return "=" + key;
        });
      }
      normalized.header = normalized.header.replace(/[ \t]/g, "");
      return normalized;
    };
    internals.sort = function(a, b) {
      if (b.q !== a.q) {
        return b.q - a.q;
      }
      if (a.type !== b.type) {
        return internals.innerSort(a, b, "type");
      }
      if (a.subtype !== b.subtype) {
        return internals.innerSort(a, b, "subtype");
      }
      if (a.specificity !== b.specificity) {
        return b.specificity - a.specificity;
      }
      return a.pos - b.pos;
    };
    internals.innerSort = function(a, b, key) {
      const aFirst = -1;
      const bFirst = 1;
      if (a[key] === "*") {
        return bFirst;
      }
      if (b[key] === "*") {
        return aFirst;
      }
      return a[key] < b[key] ? aFirst : bFirst;
    };
    internals.preferences = function(map, selections, preferences) {
      if (!preferences?.length) {
        return selections.map((selection) => selection.token + selection.original);
      }
      const lowers = /* @__PURE__ */ Object.create(null);
      const flat = /* @__PURE__ */ Object.create(null);
      let any = false;
      for (const preference of preferences) {
        const lower = preference.toLowerCase();
        flat[lower] = preference;
        const parts = lower.split("/");
        const type = parts[0];
        const subtype = parts[1];
        if (type === "*") {
          Hoek.assert(subtype === "*", "Invalid media type preference contains wildcard type with a subtype");
          any = true;
          continue;
        }
        lowers[type] = lowers[type] ?? /* @__PURE__ */ Object.create(null);
        lowers[type][subtype] = preference;
      }
      const preferred = [];
      for (const selection of selections) {
        const token = selection.token;
        const { type, subtype } = map[token];
        const subtypes = lowers[type];
        if (type === "*") {
          for (const preference of Object.keys(flat)) {
            if (!map[preference]) {
              preferred.push(flat[preference]);
            }
          }
          if (any) {
            preferred.push("*/*");
          }
          continue;
        }
        if (any) {
          preferred.push((flat[token] || token) + selection.original);
          continue;
        }
        if (subtype !== "*") {
          const pref = flat[token];
          if (pref || subtypes && subtypes["*"]) {
            preferred.push((pref || token) + selection.original);
          }
          continue;
        }
        if (subtypes) {
          for (const psub of Object.keys(subtypes)) {
            if (!map[`${type}/${psub}`]) {
              preferred.push(subtypes[psub]);
            }
          }
        }
      }
      return preferred;
    };
  }
});
var require_lib28 = __commonJS({
  "node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/index.js"(exports2) {
    "use strict";
    var Header = require_header();
    var Media = require_media();
    var internals = {
      options: {
        charset: {
          type: "accept-charset"
        },
        encoding: {
          type: "accept-encoding",
          default: "identity",
          equivalents: /* @__PURE__ */ new Map([
            ["x-compress", "compress"],
            ["x-gzip", "gzip"]
          ])
        },
        language: {
          type: "accept-language",
          prefixMatch: true
        }
      }
    };
    for (const type in internals.options) {
      exports2[type] = (header, preferences) => Header.selection(header, preferences, internals.options[type]);
      exports2[`${type}s`] = (header, preferences) => Header.selections(header, preferences, internals.options[type]);
    }
    exports2.mediaType = (header, preferences) => Media.selection(header, preferences);
    exports2.mediaTypes = (header, preferences) => Media.selections(header, preferences);
    exports2.parseAll = function(requestHeaders) {
      return {
        charsets: exports2.charsets(requestHeaders["accept-charset"]),
        encodings: exports2.encodings(requestHeaders["accept-encoding"]),
        languages: exports2.languages(requestHeaders["accept-language"]),
        mediaTypes: exports2.mediaTypes(requestHeaders.accept)
      };
    };
  }
});
var require_compression = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/compression.js"(exports2, module2) {
    "use strict";
    var Zlib = __require2("zlib");
    var Accept = require_lib28();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {
      common: ["gzip, deflate", "deflate, gzip", "gzip", "deflate", "gzip, deflate, br"]
    };
    exports2 = module2.exports = internals.Compression = class {
      decoders = {
        gzip: (options3) => Zlib.createGunzip(options3),
        deflate: (options3) => Zlib.createInflate(options3)
      };
      encodings = ["identity", "gzip", "deflate"];
      encoders = {
        identity: null,
        gzip: (options3) => Zlib.createGzip(options3),
        deflate: (options3) => Zlib.createDeflate(options3)
      };
      #common = null;
      constructor() {
        this._updateCommons();
      }
      _updateCommons() {
        this.#common = /* @__PURE__ */ new Map();
        for (const header of internals.common) {
          this.#common.set(header, Accept.encoding(header, this.encodings));
        }
      }
      addEncoder(encoding, encoder3) {
        Hoek.assert(this.encoders[encoding] === void 0, `Cannot override existing encoder for ${encoding}`);
        Hoek.assert(typeof encoder3 === "function", `Invalid encoder function for ${encoding}`);
        this.encoders[encoding] = encoder3;
        this.encodings.unshift(encoding);
        this._updateCommons();
      }
      addDecoder(encoding, decoder) {
        Hoek.assert(this.decoders[encoding] === void 0, `Cannot override existing decoder for ${encoding}`);
        Hoek.assert(typeof decoder === "function", `Invalid decoder function for ${encoding}`);
        this.decoders[encoding] = decoder;
      }
      accept(request) {
        const header = request.headers["accept-encoding"];
        if (!header) {
          return "identity";
        }
        const common2 = this.#common.get(header);
        if (common2) {
          return common2;
        }
        try {
          return Accept.encoding(header, this.encodings);
        } catch (err) {
          Bounce.rethrow(err, "system");
          err.header = header;
          request._log(["accept-encoding", "error"], err);
          return "identity";
        }
      }
      encoding(response, length4) {
        if (response.settings.compressed) {
          response.headers["content-encoding"] = response.settings.compressed;
          return null;
        }
        const request = response.request;
        if (!request._core.settings.compression || length4 !== null && length4 < request._core.settings.compression.minBytes) {
          return null;
        }
        const mime = request._core.mime.type(response.headers["content-type"] || "application/octet-stream");
        if (!mime.compressible) {
          return null;
        }
        response.vary("accept-encoding");
        if (response.headers["content-encoding"]) {
          return null;
        }
        return request.info.acceptEncoding === "identity" ? null : request.info.acceptEncoding;
      }
      encoder(request, encoding) {
        const encoder3 = this.encoders[encoding];
        Hoek.assert(encoder3 !== void 0, `Unknown encoding ${encoding}`);
        return encoder3(request.route.settings.compression[encoding]);
      }
    };
  }
});
var require_methods = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/methods.js"(exports2, module2) {
    "use strict";
    var Boom5 = require_lib6();
    var Hoek = require_lib();
    var Config = require_config();
    var internals = {
      methodNameRx: /^[_$a-zA-Z][$\w]*(?:\.[_$a-zA-Z][$\w]*)*$/
    };
    exports2 = module2.exports = internals.Methods = class {
      methods = {};
      #core = null;
      constructor(core) {
        this.#core = core;
      }
      add(name, method, options3, realm) {
        if (typeof name !== "object") {
          return this._add(name, method, options3, realm);
        }
        const items = [].concat(name);
        for (let item of items) {
          item = Config.apply("methodObject", item);
          this._add(item.name, item.method, item.options ?? {}, realm);
        }
      }
      _add(name, method, options3, realm) {
        Hoek.assert(typeof method === "function", "method must be a function");
        Hoek.assert(typeof name === "string", "name must be a string");
        Hoek.assert(name.match(internals.methodNameRx), "Invalid name:", name);
        Hoek.assert(!Hoek.reach(this.methods, name, { functions: false }), "Server method function name already exists:", name);
        options3 = Config.apply("method", options3, name);
        const settings = Hoek.clone(options3, { shallow: ["bind"] });
        settings.generateKey = settings.generateKey ?? internals.generateKey;
        const bind = settings.bind ?? realm.settings.bind ?? null;
        const bound = !bind ? method : (...args) => method.apply(bind, args);
        if (!settings.cache) {
          return this._assign(name, bound);
        }
        Hoek.assert(!settings.cache.generateFunc, "Cannot set generateFunc with method caching:", name);
        Hoek.assert(settings.cache.generateTimeout !== void 0, "Method caching requires a timeout value in generateTimeout:", name);
        settings.cache.generateFunc = (id, flags8) => bound(...id.args, flags8);
        const cache3 = this.#core._cachePolicy(settings.cache, "#" + name);
        const func = function(...args) {
          const key = settings.generateKey.apply(bind, args);
          if (typeof key !== "string") {
            return Promise.reject(Boom5.badImplementation("Invalid method key when invoking: " + name, { name, args }));
          }
          return cache3.get({ id: key, args });
        };
        func.cache = {
          drop: function(...args) {
            const key = settings.generateKey.apply(bind, args);
            if (typeof key !== "string") {
              return Promise.reject(Boom5.badImplementation("Invalid method key when invoking: " + name, { name, args }));
            }
            return cache3.drop(key);
          },
          stats: cache3.stats
        };
        this._assign(name, func, func);
      }
      _assign(name, method) {
        const path12 = name.split(".");
        let ref = this.methods;
        for (let i2 = 0; i2 < path12.length; ++i2) {
          if (!ref[path12[i2]]) {
            ref[path12[i2]] = i2 + 1 === path12.length ? method : {};
          }
          ref = ref[path12[i2]];
        }
      }
    };
    internals.supportedArgs = ["string", "number", "boolean"];
    internals.generateKey = function(...args) {
      let key = "";
      for (let i2 = 0; i2 < args.length; ++i2) {
        const arg = args[i2];
        if (!internals.supportedArgs.includes(typeof arg)) {
          return null;
        }
        key = key + (i2 ? ":" : "") + encodeURIComponent(arg.toString());
      }
      return key;
    };
  }
});
var require_response2 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/response.js"(exports2, module2) {
    "use strict";
    var Stream = __require2("stream");
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Streams = require_streams();
    var internals = {
      events: Podium.validate(["finish", { name: "peek", spread: true }]),
      hopByHop: {
        connection: true,
        "keep-alive": true,
        "proxy-authenticate": true,
        "proxy-authorization": true,
        "te": true,
        "trailer": true,
        "transfer-encoding": true,
        "upgrade": true
      },
      reserved: [
        "app",
        "headers",
        "plugins",
        "request",
        "source",
        "statusCode",
        "variety",
        "settings",
        "events",
        "code",
        "message",
        "header",
        "vary",
        "etag",
        "type",
        "contentType",
        "bytes",
        "location",
        "created",
        "compressed",
        "replacer",
        "space",
        "suffix",
        "escape",
        "passThrough",
        "redirect",
        "temporary",
        "permanent",
        "rewritable",
        "encoding",
        "charset",
        "ttl",
        "state",
        "unstate",
        "takeover"
      ]
    };
    exports2 = module2.exports = internals.Response = class {
      constructor(source, request, options3 = {}) {
        this.app = {};
        this.headers = {};
        this.plugins = {};
        this.request = request;
        this.source = null;
        this.statusCode = null;
        this.variety = null;
        this.settings = {
          charset: "utf-8",
          // '-' required by IANA
          compressed: null,
          encoding: "utf8",
          message: null,
          passThrough: true,
          stringify: null,
          // JSON.stringify options
          ttl: null,
          varyEtag: false
        };
        this._events = null;
        this._payload = null;
        this._error = options3.error ?? null;
        this._contentType = null;
        this._takeover = false;
        this._statusCode = false;
        this._state = this._error ? "prepare" : "init";
        this._processors = {
          marshal: options3.marshal,
          prepare: options3.prepare,
          close: options3.close
        };
        this._setSource(source, options3.variety);
      }
      static wrap(result, request) {
        if (result instanceof request._core.Response || typeof result === "symbol") {
          return result;
        }
        if (result instanceof Error) {
          return Boom5.boomify(result);
        }
        return new request._core.Response(result, request);
      }
      _setSource(source, variety) {
        this.variety = variety ?? "plain";
        if (source === null || source === void 0) {
          source = null;
        } else if (Buffer.isBuffer(source)) {
          this.variety = "buffer";
          this._contentType = "application/octet-stream";
        } else if (Streams.isStream(source)) {
          this.variety = "stream";
          this._contentType = "application/octet-stream";
        }
        this.source = source;
        if (this.variety === "plain" && this.source !== null) {
          this._contentType = typeof this.source === "string" ? "text/html" : "application/json";
        }
      }
      get events() {
        if (!this._events) {
          this._events = new Podium.Podium(internals.events);
        }
        return this._events;
      }
      code(statusCode) {
        Hoek.assert(Number.isSafeInteger(statusCode), "Status code must be an integer");
        this.statusCode = statusCode;
        this._statusCode = true;
        return this;
      }
      message(httpMessage) {
        this.settings.message = httpMessage;
        return this;
      }
      header(key, value, options3) {
        key = key.toLowerCase();
        if (key === "vary") {
          return this.vary(value);
        }
        return this._header(key, value, options3);
      }
      _header(key, value, options3 = {}) {
        const append = options3.append ?? false;
        const separator = options3.separator || ",";
        const override = options3.override !== false;
        const duplicate = options3.duplicate !== false;
        if (!append && override || !this.headers[key]) {
          this.headers[key] = value;
        } else if (override) {
          if (key === "set-cookie") {
            this.headers[key] = [].concat(this.headers[key], value);
          } else {
            const existing = this.headers[key];
            if (!duplicate) {
              const values = existing.split(separator);
              for (const v2 of values) {
                if (v2 === value) {
                  return this;
                }
              }
            }
            this.headers[key] = existing + separator + value;
          }
        }
        return this;
      }
      vary(value) {
        if (value === "*") {
          this.headers.vary = "*";
        } else if (!this.headers.vary) {
          this.headers.vary = value;
        } else if (this.headers.vary !== "*") {
          this._header("vary", value, { append: true, duplicate: false });
        }
        return this;
      }
      etag(tag3, options3) {
        const entity = this.request._core.Response.entity(tag3, options3);
        this._header("etag", entity.etag);
        this.settings.varyEtag = entity.vary;
        return this;
      }
      static entity(tag3, options3 = {}) {
        Hoek.assert(tag3 !== "*", "ETag cannot be *");
        return {
          etag: (options3.weak ? "W/" : "") + '"' + tag3 + '"',
          vary: options3.vary !== false && !options3.weak,
          // vary defaults to true
          modified: options3.modified
        };
      }
      static unmodified(request, entity) {
        if (request.method !== "get" && request.method !== "head") {
          return false;
        }
        if (entity.etag && request.headers["if-none-match"]) {
          const ifNoneMatch = request.headers["if-none-match"].split(/\s*,\s*/);
          for (const etag of ifNoneMatch) {
            if (etag === entity.etag) {
              return true;
            }
            if (!entity.vary) {
              continue;
            }
            if (etag === `W/${entity.etag}`) {
              return etag;
            }
            const etagBase = entity.etag.slice(0, -1);
            const encoders = request._core.compression.encodings;
            for (const encoder3 of encoders) {
              if (etag === etagBase + `-${encoder3}"`) {
                return true;
              }
            }
          }
          return false;
        }
        if (!entity.modified) {
          return false;
        }
        const ifModifiedSinceHeader = request.headers["if-modified-since"];
        if (!ifModifiedSinceHeader) {
          return false;
        }
        const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
        if (!ifModifiedSince) {
          return false;
        }
        const lastModified = internals.parseDate(entity.modified);
        if (!lastModified) {
          return false;
        }
        return ifModifiedSince >= lastModified;
      }
      type(type) {
        this._header("content-type", type);
        return this;
      }
      get contentType() {
        let type = this.headers["content-type"];
        if (type) {
          type = type.trim();
          if (this.settings.charset && type.match(/^(?:text\/)|(?:application\/(?:json)|(?:javascript))/) && !type.match(/; *charset=/)) {
            const semi = type[type.length - 1] === ";";
            return type + (semi ? " " : "; ") + "charset=" + this.settings.charset;
          }
          return type;
        }
        if (this._contentType) {
          const charset = this.settings.charset && this._contentType !== "application/octet-stream" ? "; charset=" + this.settings.charset : "";
          return this._contentType + charset;
        }
        return null;
      }
      bytes(bytes) {
        this._header("content-length", bytes);
        return this;
      }
      location(uri) {
        this._header("location", uri);
        return this;
      }
      created(location) {
        Hoek.assert(this.request.method === "post" || this.request.method === "put" || this.request.method === "patch", "Cannot return 201 status codes for " + this.request.method.toUpperCase());
        this.statusCode = 201;
        this.location(location);
        return this;
      }
      compressed(encoding) {
        Hoek.assert(encoding && typeof encoding === "string", "Invalid content-encoding");
        this.settings.compressed = encoding;
        return this;
      }
      replacer(method) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.replacer = method;
        return this;
      }
      spaces(count3) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.space = count3;
        return this;
      }
      suffix(suffix) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.suffix = suffix;
        return this;
      }
      escape(escape) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.escape = escape;
        return this;
      }
      passThrough(enabled2) {
        this.settings.passThrough = enabled2 !== false;
        return this;
      }
      redirect(location) {
        this.statusCode = 302;
        this.location(location);
        return this;
      }
      temporary(isTemporary) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setTemporary(isTemporary !== false);
        return this;
      }
      permanent(isPermanent) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setTemporary(isPermanent === false);
        return this;
      }
      rewritable(isRewritable) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setRewritable(isRewritable !== false);
        return this;
      }
      _isTemporary() {
        return this.statusCode === 302 || this.statusCode === 307;
      }
      _isRewritable() {
        return this.statusCode === 301 || this.statusCode === 302;
      }
      _setTemporary(isTemporary) {
        if (isTemporary) {
          if (this._isRewritable()) {
            this.statusCode = 302;
          } else {
            this.statusCode = 307;
          }
        } else {
          if (this._isRewritable()) {
            this.statusCode = 301;
          } else {
            this.statusCode = 308;
          }
        }
      }
      _setRewritable(isRewritable) {
        if (isRewritable) {
          if (this._isTemporary()) {
            this.statusCode = 302;
          } else {
            this.statusCode = 301;
          }
        } else {
          if (this._isTemporary()) {
            this.statusCode = 307;
          } else {
            this.statusCode = 308;
          }
        }
      }
      encoding(encoding) {
        this.settings.encoding = encoding;
        return this;
      }
      charset(charset) {
        this.settings.charset = charset ?? null;
        return this;
      }
      ttl(ttl) {
        this.settings.ttl = ttl;
        return this;
      }
      state(name, value, options3) {
        this.request._setState(name, value, options3);
        return this;
      }
      unstate(name, options3) {
        this.request._clearState(name, options3);
        return this;
      }
      takeover() {
        this._takeover = true;
        return this;
      }
      _prepare() {
        Hoek.assert(this._state === "init");
        this._state = "prepare";
        this._passThrough();
        if (!this._processors.prepare) {
          return this;
        }
        try {
          return this._processors.prepare(this);
        } catch (err) {
          throw Boom5.boomify(err);
        }
      }
      _passThrough() {
        if (this.variety === "stream" && this.settings.passThrough) {
          if (this.source.statusCode && !this.statusCode) {
            this.statusCode = this.source.statusCode;
          }
          if (this.source.headers) {
            let headerKeys = Object.keys(this.source.headers);
            if (headerKeys.length) {
              const localHeaders = this.headers;
              this.headers = {};
              const connection = this.source.headers.connection;
              const byHop = {};
              if (connection) {
                connection.split(/\s*,\s*/).forEach((header) => {
                  byHop[header] = true;
                });
              }
              for (const key of headerKeys) {
                const lower = key.toLowerCase();
                if (!internals.hopByHop[lower] && !byHop[lower]) {
                  this.header(lower, Hoek.clone(this.source.headers[key]));
                }
              }
              headerKeys = Object.keys(localHeaders);
              for (const key of headerKeys) {
                this.header(key, localHeaders[key], { append: key === "set-cookie" });
              }
            }
          }
        }
        this.statusCode = this.statusCode ?? 200;
      }
      async _marshal() {
        Hoek.assert(this._state === "prepare");
        this._state = "marshall";
        let source = this.source;
        if (this._processors.marshal) {
          try {
            source = await this._processors.marshal(this);
          } catch (err) {
            throw Boom5.boomify(err);
          }
        }
        if (Streams.isStream(source)) {
          this._payload = source;
          return;
        }
        const jsonify = this.variety === "plain" && source !== null && typeof source !== "string";
        if (!jsonify && this.settings.stringify) {
          throw Boom5.badImplementation("Cannot set formatting options on non object response");
        }
        let payload = source;
        if (jsonify) {
          const options3 = this.settings.stringify ?? {};
          const space = options3.space ?? this.request.route.settings.json.space;
          const replacer = options3.replacer ?? this.request.route.settings.json.replacer;
          const suffix = options3.suffix ?? this.request.route.settings.json.suffix ?? "";
          const escape = this.request.route.settings.json.escape;
          try {
            if (replacer || space) {
              payload = JSON.stringify(payload, replacer, space);
            } else {
              payload = JSON.stringify(payload);
            }
          } catch (err) {
            throw Boom5.boomify(err);
          }
          if (suffix) {
            payload = payload + suffix;
          }
          if (escape) {
            payload = Hoek.escapeJson(payload);
          }
        }
        this._payload = new internals.Response.Payload(payload, this.settings);
      }
      _tap() {
        if (!this._events) {
          return null;
        }
        if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
          return new internals.Response.Peek(this._events);
        }
        return null;
      }
      _close() {
        if (this._state === "close") {
          return;
        }
        this._state = "close";
        if (this._processors.close) {
          try {
            this._processors.close(this);
          } catch (err) {
            Bounce.rethrow(err, "system");
            this.request._log(["response", "cleanup", "error"], err);
          }
        }
        const stream = this._payload || this.source;
        if (Streams.isStream(stream)) {
          internals.Response.drain(stream);
        }
      }
      _isPayloadSupported() {
        return this.request.method !== "head" && this.statusCode !== 304 && this.statusCode !== 204;
      }
      static drain(stream) {
        stream.destroy();
      }
    };
    internals.Response.reserved = internals.reserved;
    internals.parseDate = function(string3) {
      try {
        return Date.parse(string3);
      } catch (errIgnore) {
      }
    };
    internals.Response.Payload = class extends Stream.Readable {
      constructor(payload, options3) {
        super();
        this._data = payload;
        this._encoding = options3.encoding;
      }
      _read(size) {
        if (this._data) {
          this.push(this._data, this._encoding);
        }
        this.push(null);
      }
      size() {
        if (!this._data) {
          return 0;
        }
        return Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding);
      }
      writeToStream(stream) {
        if (this._data) {
          stream.write(this._data, this._encoding);
        }
        stream.end();
      }
    };
    internals.Response.Peek = class extends Stream.Transform {
      constructor(podium) {
        super();
        this._podium = podium;
        this.on("finish", () => podium.emit("finish"));
      }
      _transform(chunk, encoding, callback) {
        this._podium.emit("peek", [chunk, encoding]);
        this.push(chunk, encoding);
        callback();
      }
    };
  }
});
var require_core = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/core.js"(exports2, module2) {
    "use strict";
    var Http = __require2("http");
    var Https = __require2("https");
    var Os = __require2("os");
    var Path = __require2("path");
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Call = require_lib9();
    var Catbox = require_lib11();
    var { Engine: CatboxMemory } = require_lib12();
    var { Heavy } = require_lib13();
    var Hoek = require_lib();
    var { Mimos } = require_lib14();
    var Podium = require_lib10();
    var Statehood = require_lib19();
    var Auth = require_auth();
    var Compression = require_compression();
    var Config = require_config();
    var Cors = require_cors();
    var Ext = require_ext();
    var Methods = require_methods();
    var Request2 = require_request2();
    var Response2 = require_response2();
    var Route = require_route();
    var Toolkit = require_toolkit();
    var Validation = require_validation();
    var internals = {
      counter: {
        min: 1e4,
        max: 99999
      },
      events: [
        { name: "cachePolicy", spread: true },
        { name: "log", channels: ["app", "internal"], tags: true },
        { name: "request", channels: ["app", "internal", "error"], tags: true, spread: true },
        "response",
        "route",
        "start",
        "closing",
        "stop"
      ],
      badRequestResponse: Buffer.from("HTTP/1.1 400 Bad Request\r\n\r\n", "ascii")
    };
    exports2 = module2.exports = internals.Core = class {
      actives = /* @__PURE__ */ new WeakMap();
      // Active requests being processed
      app = {};
      auth = new Auth(this);
      caches = /* @__PURE__ */ new Map();
      // Cache clients
      compression = new Compression();
      controlled = null;
      // Other servers linked to the phases of this server
      dependencies = [];
      // Plugin dependencies
      events = new Podium.Podium(internals.events);
      heavy = null;
      info = null;
      instances = /* @__PURE__ */ new Set();
      listener = null;
      methods = new Methods(this);
      // Server methods
      mime = null;
      onConnection = null;
      // Used to remove event listener on stop
      phase = "stopped";
      // 'stopped', 'initializing', 'initialized', 'starting', 'started', 'stopping', 'invalid'
      plugins = {};
      // Exposed plugin properties by name
      registrations = {};
      // Tracks plugin for dependency validation { name -> { version } }
      registring = 0;
      // > 0 while register() is waiting for plugin callbacks
      Request = class extends Request2 {
      };
      Response = class extends Response2 {
      };
      requestCounter = { value: internals.counter.min, min: internals.counter.min, max: internals.counter.max };
      root = null;
      router = null;
      settings = null;
      sockets = null;
      // Track open sockets for graceful shutdown
      started = false;
      states = null;
      toolkit = new Toolkit.Manager();
      type = null;
      validator = null;
      extensionsSeq = 0;
      // Used to keep absolute order of extensions based on the order added across locations
      extensions = {
        server: {
          onPreStart: new Ext("onPreStart", this),
          onPostStart: new Ext("onPostStart", this),
          onPreStop: new Ext("onPreStop", this),
          onPostStop: new Ext("onPostStop", this)
        },
        route: {
          onRequest: new Ext("onRequest", this),
          onPreAuth: new Ext("onPreAuth", this),
          onCredentials: new Ext("onCredentials", this),
          onPostAuth: new Ext("onPostAuth", this),
          onPreHandler: new Ext("onPreHandler", this),
          onPostHandler: new Ext("onPostHandler", this),
          onPreResponse: new Ext("onPreResponse", this),
          onPostResponse: new Ext("onPostResponse", this)
        }
      };
      decorations = {
        handler: /* @__PURE__ */ new Map(),
        request: /* @__PURE__ */ new Map(),
        response: /* @__PURE__ */ new Map(),
        server: /* @__PURE__ */ new Map(),
        toolkit: /* @__PURE__ */ new Map(),
        requestApply: null,
        public: { handler: [], request: [], response: [], server: [], toolkit: [] }
      };
      constructor(options3) {
        const { settings, type } = internals.setup(options3);
        this.settings = settings;
        this.type = type;
        this.heavy = new Heavy(this.settings.load);
        this.mime = new Mimos(this.settings.mime);
        this.router = new Call.Router(this.settings.router);
        this.states = new Statehood.Definitions(this.settings.state);
        this._debug();
        this._initializeCache();
        if (this.settings.routes.validate.validator) {
          this.validator = Validation.validator(this.settings.routes.validate.validator);
        }
        this.listener = this._createListener();
        this._initializeListener();
        this.info = this._info();
      }
      _debug() {
        const debug = this.settings.debug;
        if (!debug) {
          return;
        }
        const method = (event) => {
          const data = event.error ?? event.data;
          console.error("Debug:", event.tags.join(", "), data ? "\n    " + (data.stack ?? (typeof data === "object" ? Hoek.stringify(data) : data)) : "");
        };
        if (debug.log) {
          const filter = debug.log.some((tag3) => tag3 === "*") ? void 0 : debug.log;
          this.events.on({ name: "log", filter }, method);
        }
        if (debug.request) {
          const filter = debug.request.some((tag3) => tag3 === "*") ? void 0 : debug.request;
          this.events.on({ name: "request", filter }, (request, event) => method(event));
        }
      }
      _initializeCache() {
        if (this.settings.cache) {
          this._createCache(this.settings.cache);
        }
        if (!this.caches.has("_default")) {
          this._createCache([{ provider: CatboxMemory }]);
        }
      }
      _info() {
        const now = Date.now();
        const protocol = this.type === "tcp" ? this.settings.tls ? "https" : "http" : this.type;
        const host = this.settings.host || Os.hostname() || "localhost";
        const port = this.settings.port;
        const info = {
          created: now,
          started: 0,
          host,
          port,
          protocol,
          id: Os.hostname() + ":" + process.pid + ":" + now.toString(36),
          uri: this.settings.uri ?? protocol + ":" + (this.type === "tcp" ? "//" + host + (port ? ":" + port : "") : port)
        };
        return info;
      }
      _counter() {
        const next = ++this.requestCounter.value;
        if (this.requestCounter.value > this.requestCounter.max) {
          this.requestCounter.value = this.requestCounter.min;
        }
        return next - 1;
      }
      _createCache(configs) {
        Hoek.assert(this.phase !== "initializing", "Cannot provision server cache while server is initializing");
        configs = Config.apply("cache", configs);
        const added = [];
        for (let config2 of configs) {
          if (typeof config2 === "function") {
            config2 = { provider: { constructor: config2 } };
          }
          const name = config2.name ?? "_default";
          Hoek.assert(!this.caches.has(name), "Cannot configure the same cache more than once: ", name === "_default" ? "default cache" : name);
          let client = null;
          if (config2.provider) {
            let provider = config2.provider;
            if (typeof provider === "function") {
              provider = { constructor: provider };
            }
            client = new Catbox.Client(provider.constructor, provider.options ?? { partition: "hapi-cache" });
          } else {
            client = new Catbox.Client(config2.engine);
          }
          this.caches.set(name, { client, segments: {}, shared: config2.shared ?? false });
          added.push(client);
        }
        return added;
      }
      registerServer(server) {
        if (!this.root) {
          this.root = server;
          this._defaultRoutes();
        }
        this.instances.add(server);
      }
      async _start() {
        if (this.phase === "initialized" || this.phase === "started") {
          this._validateDeps();
        }
        if (this.phase === "started") {
          return;
        }
        if (this.phase !== "stopped" && this.phase !== "initialized") {
          throw new Error("Cannot start server while it is in " + this.phase + " phase");
        }
        if (this.phase !== "initialized") {
          await this._initialize();
        }
        this.phase = "starting";
        this.started = true;
        this.info.started = Date.now();
        try {
          await this._listen();
        } catch (err) {
          this.started = false;
          this.phase = "invalid";
          throw err;
        }
        this.phase = "started";
        this.events.emit("start");
        try {
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.start()));
          }
          await this._invoke("onPostStart");
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _listen() {
        return new Promise((resolve8, reject) => {
          if (!this.settings.autoListen) {
            resolve8();
            return;
          }
          const onError = (err) => {
            reject(err);
            return;
          };
          this.listener.once("error", onError);
          const finalize = () => {
            this.listener.removeListener("error", onError);
            resolve8();
            return;
          };
          if (this.type !== "tcp") {
            this.listener.listen(this.settings.port, finalize);
          } else {
            const address = this.settings.address || this.settings.host || null;
            this.listener.listen(this.settings.port, address, finalize);
          }
        });
      }
      async _initialize() {
        if (this.registring) {
          throw new Error("Cannot start server before plugins finished registration");
        }
        if (this.phase === "initialized") {
          return;
        }
        if (this.phase !== "stopped") {
          throw new Error("Cannot initialize server while it is in " + this.phase + " phase");
        }
        this._validateDeps();
        this.phase = "initializing";
        try {
          const caches = [];
          this.caches.forEach((cache3) => caches.push(cache3.client.start()));
          await Promise.all(caches);
          await this._invoke("onPreStart");
          this.heavy.start();
          this.phase = "initialized";
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.initialize()));
          }
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _validateDeps() {
        for (const { deps, plugin: plugin2 } of this.dependencies) {
          for (const dep in deps) {
            const version4 = deps[dep];
            Hoek.assert(this.registrations[dep], "Plugin", plugin2, "missing dependency", dep);
            Hoek.assert(version4 === "*" || Config.versionMatch(this.registrations[dep].version, version4), "Plugin", plugin2, "requires", dep, "version", version4, "but found", this.registrations[dep].version);
          }
        }
      }
      async _stop(options3 = {}) {
        options3.timeout = options3.timeout ?? 5e3;
        if (["stopped", "initialized", "started", "invalid"].indexOf(this.phase) === -1) {
          throw new Error("Cannot stop server while in " + this.phase + " phase");
        }
        this.phase = "stopping";
        try {
          await this._invoke("onPreStop");
          if (this.started) {
            this.started = false;
            this.info.started = 0;
            await this._unlisten(options3.timeout);
          }
          const caches = [];
          this.caches.forEach((cache3) => caches.push(cache3.client.stop()));
          await Promise.all(caches);
          this.events.emit("stop");
          this.heavy.stop();
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.stop(options3)));
          }
          await this._invoke("onPostStop");
          this.phase = "stopped";
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _unlisten(timeout) {
        let timeoutId = null;
        if (this.settings.operations.cleanStop) {
          const destroy = () => {
            for (const connection of this.sockets) {
              connection.destroy();
            }
            this.sockets.clear();
          };
          timeoutId = setTimeout(destroy, timeout);
          for (const connection of this.sockets) {
            if (!this.actives.has(connection)) {
              connection.end();
            }
          }
        }
        return new Promise((resolve8) => {
          this.listener.close(() => {
            if (this.settings.operations.cleanStop) {
              this.listener.removeListener(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
              clearTimeout(timeoutId);
            }
            this._initializeListener();
            resolve8();
          });
          this.events.emit("closing");
        });
      }
      async _invoke(type) {
        const exts = this.extensions.server[type];
        if (!exts.nodes) {
          return;
        }
        for (const ext of exts.nodes) {
          const bind = ext.bind ?? ext.realm.settings.bind;
          const operation = ext.func.call(bind, ext.server, bind);
          await Toolkit.timed(operation, { timeout: ext.timeout, name: type });
        }
      }
      _defaultRoutes() {
        this.router.special("notFound", new Route({ method: "_special", path: "/{p*}", handler: internals.notFound }, this.root, { special: true }));
        this.router.special("badRequest", new Route({ method: "_special", path: "/{p*}", handler: internals.badRequest }, this.root, { special: true }));
        if (this.settings.routes.cors) {
          Cors.handler(this.root);
        }
      }
      _dispatch(options3 = {}) {
        return (req, res) => {
          const request = Request2.generate(this.root, req, res, options3);
          if (this.settings.operations.cleanStop && req.socket) {
            this.actives.set(req.socket, request);
            const env = { core: this, req };
            res.on("finish", internals.onFinish.bind(res, env));
          }
          if (this.settings.load.sampleInterval) {
            try {
              this.heavy.check();
            } catch (err) {
              Bounce.rethrow(err, "system");
              this._log(["load"], this.heavy.load);
              request._reply(err);
              return;
            }
          }
          request._execute();
        };
      }
      _createListener() {
        const listener = this.settings.listener ?? (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());
        listener.on("request", this._dispatch());
        listener.on("checkContinue", this._dispatch({ expectContinue: true }));
        listener.on("clientError", (err, socket) => {
          this._log(["connection", "client", "error"], err);
          if (socket.readable) {
            const request = this.settings.operations.cleanStop && this.actives.get(socket);
            if (request) {
              if (err.code === "HPE_INVALID_METHOD") {
                request.raw.res.once("close", () => {
                  if (socket.readable) {
                    socket.end(internals.badRequestResponse);
                  } else {
                    socket.destroy(err);
                  }
                });
                return;
              }
              const error = Boom5.badRequest();
              error.output.headers = { connection: "close" };
              request._reply(error);
            } else {
              socket.end(internals.badRequestResponse);
            }
          } else {
            socket.destroy(err);
          }
        });
        return listener;
      }
      _initializeListener() {
        this.listener.once("listening", () => {
          if (this.type === "tcp") {
            const address = this.listener.address();
            this.info.address = address.address;
            this.info.port = address.port;
            this.info.uri = this.settings.uri ?? this.info.protocol + "://" + this.info.host + ":" + this.info.port;
          }
          if (this.settings.operations.cleanStop) {
            this.sockets = /* @__PURE__ */ new Set();
            const self2 = this;
            const onClose = function() {
              self2.sockets.delete(this);
            };
            this.onConnection = (connection) => {
              this.sockets.add(connection);
              connection.on("close", onClose);
            };
            this.listener.on(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
          }
        });
      }
      _cachePolicy(options3, _segment, realm) {
        options3 = Config.apply("cachePolicy", options3);
        const plugin2 = realm?.plugin;
        const segment = options3.segment ?? _segment ?? (plugin2 ? `!${plugin2}` : "");
        Hoek.assert(segment, "Missing cache segment name");
        const cacheName = options3.cache ?? "_default";
        const cache3 = this.caches.get(cacheName);
        Hoek.assert(cache3, "Unknown cache", cacheName);
        Hoek.assert(!cache3.segments[segment] || cache3.shared || options3.shared, "Cannot provision the same cache segment more than once");
        cache3.segments[segment] = true;
        const policy = new Catbox.Policy(options3, cache3.client, segment);
        this.events.emit("cachePolicy", [policy, options3.cache, segment]);
        return policy;
      }
      log(tags, data) {
        return this._log(tags, data, "app");
      }
      _log(tags, data, channel = "internal") {
        if (!this.events.hasListeners("log")) {
          return;
        }
        if (!Array.isArray(tags)) {
          tags = [tags];
        }
        const timestamp = Date.now();
        const field = data instanceof Error ? "error" : "data";
        let event = { timestamp, tags, [field]: data, channel };
        if (typeof data === "function") {
          event = () => ({ timestamp, tags, data: data(), channel });
        }
        this.events.emit({ name: "log", tags, channel }, event);
      }
    };
    internals.setup = function(options3 = {}) {
      let settings = Hoek.clone(options3, { shallow: ["cache", "listener", "routes.bind"] });
      settings.app = settings.app ?? {};
      settings.routes = Config.enable(settings.routes);
      settings = Config.apply("server", settings);
      if (settings.port === void 0) {
        settings.port = 0;
      }
      const type = typeof settings.port === "string" ? "socket" : "tcp";
      if (type === "socket") {
        settings.port = settings.port.indexOf("/") !== -1 ? Path.resolve(settings.port) : settings.port.toLowerCase();
      }
      if (settings.autoListen === void 0) {
        settings.autoListen = true;
      }
      Hoek.assert(settings.autoListen || !settings.port, "Cannot specify port when autoListen is false");
      Hoek.assert(settings.autoListen || !settings.address, "Cannot specify address when autoListen is false");
      return { settings, type };
    };
    internals.notFound = function() {
      throw Boom5.notFound();
    };
    internals.badRequest = function() {
      throw Boom5.badRequest();
    };
    internals.onFinish = function(env) {
      const { core, req } = env;
      core.actives.delete(req.socket);
      if (!core.started) {
        req.socket.end();
      }
    };
  }
});
var require_package2 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/package.json"(exports2, module2) {
    module2.exports = {
      name: "@hapi/hapi",
      description: "HTTP Server framework",
      homepage: "https://hapi.dev",
      version: "21.4.3",
      repository: "git://github.com/hapijs/hapi",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      engines: {
        node: ">=14.15.0"
      },
      files: [
        "lib"
      ],
      keywords: [
        "framework",
        "http",
        "api",
        "web"
      ],
      eslintConfig: {
        extends: [
          "plugin:@hapi/module"
        ]
      },
      dependencies: {
        "@hapi/accept": "^6.0.3",
        "@hapi/ammo": "^6.0.1",
        "@hapi/boom": "^10.0.1",
        "@hapi/bounce": "^3.0.2",
        "@hapi/call": "^9.0.1",
        "@hapi/catbox": "^12.1.1",
        "@hapi/catbox-memory": "^6.0.2",
        "@hapi/heavy": "^8.0.1",
        "@hapi/hoek": "^11.0.7",
        "@hapi/mimos": "^7.0.1",
        "@hapi/podium": "^5.0.2",
        "@hapi/shot": "^6.0.2",
        "@hapi/somever": "^4.1.1",
        "@hapi/statehood": "^8.2.0",
        "@hapi/subtext": "^8.1.1",
        "@hapi/teamwork": "^6.0.0",
        "@hapi/topo": "^6.0.2",
        "@hapi/validate": "^2.0.1"
      },
      devDependencies: {
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "^6.0.0",
        "@hapi/inert": "^7.1.0",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@^15.0.0",
        "@hapi/lab": "^25.3.2",
        "@hapi/vision": "^7.0.3",
        "@hapi/wreck": "^18.1.0",
        "@types/node": "^18.19.122",
        handlebars: "^4.7.8",
        joi: "^17.13.3",
        "legacy-readable-stream": "npm:readable-stream@^1.0.34",
        typescript: "^4.9.5"
      },
      scripts: {
        test: "lab -a @hapi/code -t 100 -L -m 5000 -Y",
        "test-tap": "lab -a @hapi/code -r tap -o tests.tap -m 5000",
        "test-cov-html": "lab -a @hapi/code -r html -o coverage.html -m 5000"
      },
      license: "BSD-3-Clause"
    };
  }
});
var require_server = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/server.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var Shot = require_lib4();
    var Teamwork = require_lib5();
    var Config = require_config();
    var Core = require_core();
    var Cors = require_cors();
    var Ext = require_ext();
    var Package = require_package2();
    var Route = require_route();
    var Toolkit = require_toolkit();
    var Validation = require_validation();
    var internals = {};
    exports2 = module2.exports = function(options3) {
      const core = new Core(options3);
      return new internals.Server(core);
    };
    internals.Server = class {
      constructor(core, name, parent) {
        this._core = core;
        this.app = core.app;
        this.auth = core.auth.public(this);
        this.decorations = core.decorations.public;
        this.cache = internals.cache(this);
        this.events = core.events;
        this.info = core.info;
        this.listener = core.listener;
        this.load = core.heavy.load;
        this.methods = core.methods.methods;
        this.mime = core.mime;
        this.plugins = core.plugins;
        this.registrations = core.registrations;
        this.settings = core.settings;
        this.states = core.states;
        this.type = core.type;
        this.version = Package.version;
        this.realm = {
          _extensions: {
            onPreAuth: new Ext("onPreAuth", core),
            onCredentials: new Ext("onCredentials", core),
            onPostAuth: new Ext("onPostAuth", core),
            onPreHandler: new Ext("onPreHandler", core),
            onPostHandler: new Ext("onPostHandler", core),
            onPreResponse: new Ext("onPreResponse", core),
            onPostResponse: new Ext("onPostResponse", core)
          },
          modifiers: {
            route: {}
          },
          parent: parent ? parent.realm : null,
          plugin: name,
          pluginOptions: {},
          plugins: {},
          _rules: null,
          settings: {
            bind: void 0,
            files: {
              relativeTo: void 0
            }
          },
          validator: null
        };
        for (const [property, method] of core.decorations.server.entries()) {
          this[property] = method;
        }
        core.registerServer(this);
      }
      _clone(name) {
        return new internals.Server(this._core, name, this);
      }
      bind(context) {
        Hoek.assert(typeof context === "object", "bind must be an object");
        this.realm.settings.bind = context;
      }
      control(server) {
        Hoek.assert(server instanceof internals.Server, "Can only control Server objects");
        this._core.controlled = this._core.controlled ?? [];
        this._core.controlled.push(server);
      }
      decoder(encoding, decoder) {
        return this._core.compression.addDecoder(encoding, decoder);
      }
      decorate(type, property, method, options3 = {}) {
        Hoek.assert(this._core.decorations.public[type], "Unknown decoration type:", type);
        Hoek.assert(property, "Missing decoration property name");
        Hoek.assert(typeof property === "string" || typeof property === "symbol", "Decoration property must be a string or a symbol");
        const propertyName = property.toString();
        Hoek.assert(propertyName[0] !== "_", "Property name cannot begin with an underscore:", propertyName);
        const existing = this._core.decorations[type].get(property);
        if (options3.extend) {
          Hoek.assert(type !== "handler", "Cannot extend handler decoration:", propertyName);
          Hoek.assert(existing, `Cannot extend missing ${type} decoration: ${propertyName}`);
          Hoek.assert(typeof method === "function", `Extended ${type} decoration method must be a function: ${propertyName}`);
          method = method(existing);
        } else {
          Hoek.assert(existing === void 0, `${type[0].toUpperCase() + type.slice(1)} decoration already defined: ${propertyName}`);
        }
        if (type === "handler") {
          Hoek.assert(typeof method === "function", "Handler must be a function:", propertyName);
          Hoek.assert(!method.defaults || typeof method.defaults === "object" || typeof method.defaults === "function", "Handler defaults property must be an object or function");
          Hoek.assert(!options3.extend, "Cannot extend handler decoration:", propertyName);
        } else if (type === "request") {
          Hoek.assert(!this._core.Request.reserved.includes(property), "Cannot override the built-in request interface decoration:", propertyName);
          if (options3.apply) {
            this._core.decorations.requestApply = this._core.decorations.requestApply ?? /* @__PURE__ */ new Map();
            this._core.decorations.requestApply.set(property, method);
          } else {
            this._core.Request.prototype[property] = method;
          }
        } else if (type === "response") {
          Hoek.assert(!this._core.Response.reserved.includes(property), "Cannot override the built-in response interface decoration:", propertyName);
          this._core.Response.prototype[property] = method;
        } else if (type === "toolkit") {
          Hoek.assert(!Toolkit.reserved.includes(property), "Cannot override the built-in toolkit decoration:", propertyName);
          this._core.toolkit.decorate(property, method);
        } else {
          if (typeof property === "string") {
            Hoek.assert(!Object.getOwnPropertyNames(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
          } else {
            Hoek.assert(!Object.getOwnPropertySymbols(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
          }
          this._core.instances.forEach((server) => {
            server[property] = method;
          });
        }
        this._core.decorations[type].set(property, method);
        this._core.decorations.public[type].push(property);
      }
      dependency(dependencies, after) {
        Hoek.assert(this.realm.plugin, "Cannot call dependency() outside of a plugin");
        Hoek.assert(!after || typeof after === "function", "Invalid after method");
        if (typeof dependencies === "string") {
          dependencies = { [dependencies]: "*" };
        } else if (Array.isArray(dependencies)) {
          const map = {};
          for (const dependency of dependencies) {
            map[dependency] = "*";
          }
          dependencies = map;
        }
        this._core.dependencies.push({ plugin: this.realm.plugin, deps: dependencies });
        if (after) {
          this.ext("onPreStart", after, { after: Object.keys(dependencies) });
        }
      }
      encoder(encoding, encoder3) {
        return this._core.compression.addEncoder(encoding, encoder3);
      }
      event(event) {
        this._core.events.registerEvent(event);
      }
      expose(key, value, options3 = {}) {
        Hoek.assert(this.realm.plugin, "Cannot call expose() outside of a plugin");
        let plugin2 = this.realm.plugin;
        if (plugin2[0] === "@" && options3.scope !== true) {
          plugin2 = plugin2.replace(/^@([^/]+)\//, ($0, $1) => {
            return !options3.scope ? "" : `${$1}__`;
          });
        }
        this._core.plugins[plugin2] = this._core.plugins[plugin2] ?? {};
        if (typeof key === "string") {
          this._core.plugins[plugin2][key] = value;
        } else {
          Hoek.merge(this._core.plugins[plugin2], key);
        }
      }
      ext(events, method, options3) {
        let promise;
        if (typeof events === "string") {
          if (!method) {
            const team = new Teamwork.Team();
            method = (request, h2) => {
              team.attend(request);
              return h2.continue;
            };
            promise = team.work;
          }
          events = { type: events, method, options: options3 };
        }
        events = Config.apply("exts", events);
        for (const event of events) {
          this._ext(event);
        }
        return promise;
      }
      _ext(event) {
        event = Object.assign({}, event);
        event.realm = this.realm;
        const type = event.type;
        if (!this._core.extensions.server[type]) {
          if (event.options.sandbox === "plugin") {
            Hoek.assert(this.realm._extensions[type], "Unknown event type", type);
            return this.realm._extensions[type].add(event);
          }
          Hoek.assert(this._core.extensions.route[type], "Unknown event type", type);
          return this._core.extensions.route[type].add(event);
        }
        Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for server extension");
        Hoek.assert(type !== "onPreStart" || this._core.phase === "stopped", "Cannot add onPreStart (after) extension after the server was initialized");
        event.server = this;
        this._core.extensions.server[type].add(event);
      }
      async inject(options3) {
        let settings = options3;
        if (typeof settings === "string") {
          settings = { url: settings };
        }
        if (!settings.authority || settings.auth || settings.app || settings.plugins || settings.allowInternals !== void 0) {
          settings = Object.assign({}, settings);
          delete settings.auth;
          delete settings.app;
          delete settings.plugins;
          delete settings.allowInternals;
          settings.authority = settings.authority ?? this._core.info.host + ":" + this._core.info.port;
        }
        Hoek.assert(!options3.credentials, "options.credentials no longer supported (use options.auth)");
        if (options3.auth) {
          Hoek.assert(typeof options3.auth === "object", "options.auth must be an object");
          Hoek.assert(options3.auth.credentials, "options.auth.credentials is missing");
          Hoek.assert(options3.auth.strategy, "options.auth.strategy is missing");
        }
        const needle = this._core._dispatch({
          auth: options3.auth,
          allowInternals: options3.allowInternals,
          app: options3.app,
          plugins: options3.plugins,
          isInjected: true
        });
        const res = await Shot.inject(needle, settings);
        const custom = res.raw.res[Config.symbol];
        if (custom) {
          delete res.raw.res[Config.symbol];
          res.request = custom.request;
          if (custom.error) {
            throw custom.error;
          }
          if (custom.result !== void 0) {
            res.result = custom.result;
          }
        }
        if (res.result === void 0) {
          res.result = res.payload;
        }
        return res;
      }
      log(tags, data) {
        return this._core.log(tags, data);
      }
      lookup(id) {
        Hoek.assert(id && typeof id === "string", "Invalid route id:", id);
        const record = this._core.router.ids.get(id);
        if (!record) {
          return null;
        }
        return record.route.public;
      }
      match(method, path12, host) {
        Hoek.assert(method && typeof method === "string", "Invalid method:", method);
        Hoek.assert(path12 && typeof path12 === "string" && path12[0] === "/", "Invalid path:", path12);
        Hoek.assert(!host || typeof host === "string", "Invalid host:", host);
        const match = this._core.router.route(method.toLowerCase(), path12, host);
        Hoek.assert(match !== this._core.router.specials.badRequest, "Invalid path:", path12);
        if (match === this._core.router.specials.notFound) {
          return null;
        }
        return match.route.public;
      }
      method(name, method, options3 = {}) {
        return this._core.methods.add(name, method, options3, this.realm);
      }
      path(relativeTo) {
        Hoek.assert(relativeTo && typeof relativeTo === "string", "relativeTo must be a non-empty string");
        this.realm.settings.files.relativeTo = relativeTo;
      }
      async register(plugins, options3 = {}) {
        if (this.realm.modifiers.route.prefix || this.realm.modifiers.route.vhost) {
          options3 = Hoek.clone(options3);
          options3.routes = options3.routes ?? {};
          options3.routes.prefix = (this.realm.modifiers.route.prefix ?? "") + (options3.routes.prefix ?? "") || void 0;
          options3.routes.vhost = this.realm.modifiers.route.vhost ?? options3.routes.vhost;
        }
        options3 = Config.apply("register", options3);
        ++this._core.registring;
        try {
          const items = [].concat(plugins);
          for (let item of items) {
            if (!item.plugin) {
              item = {
                plugin: item
              };
            } else if (!item.plugin.register) {
              item = {
                options: item.options,
                once: item.once,
                routes: item.routes,
                plugin: item.plugin.plugin
              };
            } else if (typeof item === "function") {
              item = Object.assign({}, item);
            }
            item = Config.apply("plugin", item);
            const name = item.plugin.name ?? item.plugin.pkg.name;
            const clone2 = this._clone(name);
            clone2.realm.modifiers.route.prefix = item.routes.prefix ?? options3.routes.prefix;
            clone2.realm.modifiers.route.vhost = item.routes.vhost ?? options3.routes.vhost;
            clone2.realm.pluginOptions = item.options ?? {};
            const requirements = item.plugin.requirements;
            Hoek.assert(!requirements.node || Config.versionMatch(process.version, requirements.node), "Plugin", name, "requires node version", requirements.node, "but found", process.version);
            Hoek.assert(!requirements.hapi || Config.versionMatch(this.version, requirements.hapi), "Plugin", name, "requires hapi version", requirements.hapi, "but found", this.version);
            if (this._core.registrations[name]) {
              if (item.plugin.once || item.once || options3.once) {
                continue;
              }
              Hoek.assert(item.plugin.multiple, "Plugin", name, "already registered");
            } else {
              this._core.registrations[name] = {
                version: item.plugin.version ?? item.plugin.pkg.version,
                name,
                options: item.options
              };
            }
            if (item.plugin.dependencies) {
              clone2.dependency(item.plugin.dependencies);
            }
            await item.plugin.register(clone2, item.options ?? {});
          }
        } finally {
          --this._core.registring;
        }
        return this;
      }
      route(options3) {
        Hoek.assert(typeof options3 === "object", "Invalid route options");
        options3 = [].concat(options3);
        for (const config2 of options3) {
          if (Array.isArray(config2.method)) {
            for (const method of config2.method) {
              const settings = Object.assign({}, config2);
              settings.method = method;
              this._addRoute(settings, this);
            }
          } else {
            this._addRoute(config2, this);
          }
        }
      }
      _addRoute(config2, server) {
        const route2 = new Route(config2, server);
        const vhosts = [].concat(route2.settings.vhost ?? "*");
        for (const vhost of vhosts) {
          const record = this._core.router.add({ method: route2.method, path: route2.path, vhost, analysis: route2._analysis, id: route2.settings.id }, route2);
          route2.fingerprint = record.fingerprint;
          route2.params = record.params;
        }
        this.events.emit("route", route2.public);
        Cors.options(route2.public, server);
      }
      rules(processor, options3 = {}) {
        Hoek.assert(!this.realm._rules, "Server realm rules already defined");
        const settings = Config.apply("rules", options3);
        if (settings.validate) {
          const schema = settings.validate.schema;
          settings.validate.schema = Validation.compile(schema, null, this.realm, this._core);
        }
        this.realm._rules = { processor, settings };
      }
      state(name, options3) {
        this.states.add(name, options3);
      }
      table(host) {
        return this._core.router.table(host);
      }
      validator(validator) {
        Hoek.assert(!this.realm.validator, "Validator already set");
        this.realm.validator = Validation.validator(validator);
      }
      start() {
        return this._core._start();
      }
      initialize() {
        return this._core._initialize();
      }
      stop(options3) {
        return this._core._stop(options3);
      }
    };
    internals.cache = (plugin2) => {
      const policy = function(options3, _segment) {
        return this._core._cachePolicy(options3, _segment, plugin2.realm);
      };
      policy.provision = async (opts) => {
        const clients = plugin2._core._createCache(opts);
        if (["initialized", "starting", "started"].includes(plugin2._core.phase)) {
          await Promise.all(clients.map((client) => client.start()));
        }
      };
      return policy;
    };
  }
});
var require_lib29 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/index.js"(exports2) {
    "use strict";
    var Server3 = require_server();
    exports2.Server = Server3;
    exports2.server = Server3;
  }
});
var require_lru_cache = __commonJS({
  "node_modules/.deno/lru-cache@7.18.3/node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort(reason = new Error("This operation was aborted")) {
        this.signal.reason = this.signal.reason || reason;
        this.signal.aborted = true;
        this.signal.dispatchEvent({
          type: "abort",
          target: this.signal
        });
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.reason = void 0;
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(e2) {
        if (e2.type === "abort") {
          this.aborted = true;
          this.onabort(e2);
          this._listeners.forEach((f) => f(e2), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code2 = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code2)) {
        warn(code2, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code2 = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code2)) {
        const { prototype } = LRUCache;
        const { get: get22 } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code2, `${method} method`, `cache.${instead}()`, get22);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code2 = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code2)) {
        const { prototype } = LRUCache;
        const { get: get22 } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code2, `${field} property`, `cache.${instead}`, get22);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code2) => !warned.has(code2);
    var warn = (code2, what, instead, fn) => {
      warned.add(code2);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code2, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options3 = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          maxEntrySize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort
        } = options3;
        const { length: length4, maxAge: maxAge2, stale } = options3 instanceof _LRUCache ? {} : options3;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length4;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize or maxEntrySize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError(
                "maxSize must be a positive integer if specified"
              );
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError(
              "maxEntrySize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge2 || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code2 = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code2)) {
            warned.add(code2);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code2, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge2) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length4) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        this.statusTTL = (status, index) => {
          if (status) {
            status.ttl = this.ttls[index];
            status.start = this.starts[index];
            status.now = cachedNow || getNow();
            status.remainingTTL = status.now + status.ttl - status.start;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(_index) {
      }
      statusTTL(_status, _index) {
      }
      setItemTTL(_index, _ttl, _start) {
      }
      isStale(_index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v2, size, sizeCalculation) => {
          if (this.isBackgroundFetch(v2)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v2, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size, status) => {
          this.sizes[index] = size;
          if (this.maxSize) {
            const maxSize = this.maxSize - this.sizes[index];
            while (this.calculatedSize > maxSize) {
              this.evict(true);
            }
          }
          this.calculatedSize += this.sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.calculatedSize;
          }
        };
      }
      removeItemSize(_index) {
      }
      addItemSize(_index, _size2) {
      }
      requireSize(_k, _v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize or maxEntrySize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.tail; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.head) {
              break;
            } else {
              i2 = this.prev[i2];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.head; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.tail) {
              break;
            } else {
              i2 = this.next[i2];
            }
          }
        }
      }
      isValidIndex(index) {
        return index !== void 0 && this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i2 of this.indexes()) {
          if (this.valList[i2] !== void 0 && this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield [this.keyList[i2], this.valList[i2]];
          }
        }
      }
      *rentries() {
        for (const i2 of this.rindexes()) {
          if (this.valList[i2] !== void 0 && this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield [this.keyList[i2], this.valList[i2]];
          }
        }
      }
      *keys() {
        for (const i2 of this.indexes()) {
          if (this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.keyList[i2];
          }
        }
      }
      *rkeys() {
        for (const i2 of this.rindexes()) {
          if (this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.keyList[i2];
          }
        }
      }
      *values() {
        for (const i2 of this.indexes()) {
          if (this.valList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.valList[i2];
          }
        }
      }
      *rvalues() {
        for (const i2 of this.rindexes()) {
          if (this.valList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.valList[i2];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions) {
        for (const i2 of this.indexes()) {
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          if (fn(value, this.keyList[i2], this)) {
            return this.get(this.keyList[i2], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i2 of this.indexes()) {
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i2], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i2 of this.rindexes()) {
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i2], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i2 of this.rindexes({ allowStale: true })) {
          if (this.isStale(i2)) {
            this.delete(this.keyList[i2]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i2 of this.indexes({ allowStale: true })) {
          const key = this.keyList[i2];
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i2];
            const age = perf.now() - this.starts[i2];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i2];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(_v, _k, _reason) {
      }
      set(k, v2, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        status
      } = {}) {
        size = this.requireSize(k, v2, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v2;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size, status);
          if (status) {
            status.set = "add";
          }
          noUpdateTTL = false;
        } else {
          this.moveToTail(index);
          const oldVal = this.valList[index];
          if (v2 !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v2;
            this.addItemSize(index, size, status);
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0) status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        this.statusTTL(status, index);
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v2 = this.valList[head];
        if (this.isBackgroundFetch(v2)) {
          v2.__abortController.abort(new Error("evicted"));
        } else {
          this.dispose(v2, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v2, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            if (status) status.has = "hit";
            this.statusTTL(status, index);
            return true;
          } else if (status) {
            status.has = "stale";
            this.statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v2 = this.valList[index];
          return this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
        }
      }
      backgroundFetch(k, index, options3, context) {
        const v2 = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v2)) {
          return v2;
        }
        const ac = new AC();
        if (options3.signal) {
          options3.signal.addEventListener(
            "abort",
            () => ac.abort(options3.signal.reason)
          );
        }
        const fetchOpts = {
          signal: ac.signal,
          options: options3,
          context
        };
        const cb = (v3, updateCache = false) => {
          const { aborted: aborted2 } = ac.signal;
          const ignoreAbort = options3.ignoreFetchAbort && v3 !== void 0;
          if (options3.status) {
            if (aborted2 && !updateCache) {
              options3.status.fetchAborted = true;
              options3.status.fetchError = ac.signal.reason;
              if (ignoreAbort) options3.status.fetchAbortIgnored = true;
            } else {
              options3.status.fetchResolved = true;
            }
          }
          if (aborted2 && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          if (this.valList[index] === p) {
            if (v3 === void 0) {
              if (p.__staleWhileFetching) {
                this.valList[index] = p.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              if (options3.status) options3.status.fetchUpdated = true;
              this.set(k, v3, fetchOpts.options);
            }
          }
          return v3;
        };
        const eb = (er) => {
          if (options3.status) {
            options3.status.fetchRejected = true;
            options3.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted: aborted2 } = ac.signal;
          const allowStaleAborted = aborted2 && options3.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options3.allowStaleOnFetchRejection;
          const noDelete = allowStale || options3.noDeleteOnFetchRejection;
          if (this.valList[index] === p) {
            const del = !noDelete || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options3.status && p.__staleWhileFetching !== void 0) {
              options3.status.returnedStale = true;
            }
            return p.__staleWhileFetching;
          } else if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          this.fetchMethod(k, v2, fetchOpts).then((v3) => res(v3), rej);
          ac.signal.addEventListener("abort", () => {
            if (!options3.ignoreFetchAbort || options3.allowStaleOnFetchAbort) {
              res();
              if (options3.allowStaleOnFetchAbort) {
                res = (v3) => cb(v3, true);
              }
            }
          });
        };
        if (options3.status) options3.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v2;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, { ...fetchOpts.options, status: void 0 });
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        fetchContext = this.fetchContext,
        forceRefresh = false,
        status,
        signal
      } = {}) {
        if (!this.fetchMethod) {
          if (status) status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options3 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          if (status) status.fetch = "miss";
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          return p.__returned = p;
        } else {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            const stale = allowStale && v2.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale) status.returnedStale = true;
            }
            return stale ? v2.__staleWhileFetching : v2.__returned = v2;
          }
          const isStale = this.isStale(index);
          if (!forceRefresh && !isStale) {
            if (status) status.fetch = "hit";
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            this.statusTTL(status, index);
            return v2;
          }
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = hasStale && isStale ? "stale" : "refresh";
            if (staleVal && isStale) status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        status
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          this.statusTTL(status, index);
          if (this.isStale(index)) {
            if (status) status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status) status.returnedStale = allowStale;
              return allowStale ? value : void 0;
            } else {
              if (status) {
                status.returnedStale = allowStale && value.__staleWhileFetching !== void 0;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status) status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v2 = this.valList[index];
              if (this.isBackgroundFetch(v2)) {
                v2.__abortController.abort(new Error("deleted"));
              } else {
                this.dispose(v2, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v2, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.keyList[index];
            this.dispose(v2, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v2, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});
var require_etag = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/etag.js"(exports2) {
    "use strict";
    var Crypto = __require2("crypto");
    var Stream = __require2("stream");
    var Util = __require2("util");
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var LruCache = require_lru_cache();
    var internals = {
      pendings: /* @__PURE__ */ new Map(),
      streamEnd: Util.promisify(Stream.finished)
    };
    internals.computeHashed = async function(response, stat) {
      const etags = response.request.server.plugins.inert._etags;
      if (!etags) {
        return null;
      }
      const path12 = response.source.path;
      const cachekey = [path12, stat.ino, stat.size, stat.mtime.getTime()].join("-");
      const cachedEtag = etags.get(cachekey);
      if (cachedEtag) {
        return cachedEtag;
      }
      let promise = internals.pendings.get(cachekey);
      if (promise) {
        return await promise;
      }
      const compute = async () => {
        try {
          const hash32 = await internals.hashFile(response);
          etags.set(cachekey, hash32);
          return hash32;
        } finally {
          internals.pendings.delete(cachekey);
        }
      };
      internals.pendings.set(cachekey, promise = compute());
      return await promise;
    };
    internals.hashFile = async function(response) {
      const hash32 = Crypto.createHash("sha1");
      hash32.setEncoding("hex");
      const fileStream2 = response.source.file.createReadStream({ autoClose: false });
      fileStream2.pipe(hash32);
      try {
        await internals.streamEnd(fileStream2);
        return hash32.read();
      } catch (err) {
        Bounce.rethrow(err, "system");
        throw Boom5.boomify(err, { message: "Failed to hash file", data: { path: response.source.path } });
      }
    };
    internals.computeSimple = function(response, stat) {
      const size = stat.size.toString(16);
      const mtime = stat.mtime.getTime().toString(16);
      return size + "-" + mtime;
    };
    exports2.apply = async function(response, stat) {
      const etagMethod = response.source.settings.etagMethod;
      if (etagMethod === false) {
        return;
      }
      let etag;
      if (etagMethod === "simple") {
        etag = internals.computeSimple(response, stat);
      } else {
        etag = await internals.computeHashed(response, stat);
      }
      if (etag !== null) {
        response.etag(etag, { vary: true });
      }
    };
    exports2.Cache = LruCache;
  }
});
var require_fs = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/fs.js"(exports2) {
    "use strict";
    var Fs = __require2("fs");
    var Util = __require2("util");
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {
      methods: {
        promised: ["open", "close", "fstat", "readdir"],
        raw: ["createReadStream"]
      },
      notFound: /* @__PURE__ */ new Set(["ENOENT", "ENOTDIR"])
    };
    exports2.File = class {
      constructor(path12) {
        this.path = path12;
        this.fd = null;
      }
      async open(mode) {
        Hoek.assert(this.fd === null);
        try {
          this.fd = await exports2.open(this.path, mode);
        } catch (err) {
          const data = { path: this.path };
          if (this.path.indexOf("\0") !== -1 || internals.notFound.has(err.code)) {
            throw Boom5.notFound(null, data);
          }
          if (err.code === "EACCES" || err.code === "EPERM") {
            data.code = err.code;
            throw Boom5.forbidden(null, data);
          }
          throw Boom5.boomify(err, { message: "Failed to open file", data });
        }
      }
      close() {
        if (this.fd !== null) {
          Bounce.background(exports2.close(this.fd));
          this.fd = null;
        }
      }
      async stat() {
        Hoek.assert(this.fd !== null);
        try {
          const stat = await exports2.fstat(this.fd);
          if (stat.isDirectory()) {
            throw Boom5.forbidden(null, { code: "EISDIR", path: this.path });
          }
          return stat;
        } catch (err) {
          this.close(this.fd);
          Bounce.rethrow(err, ["boom", "system"]);
          throw Boom5.boomify(err, { message: "Failed to stat file", data: { path: this.path } });
        }
      }
      async openStat(mode) {
        await this.open(mode);
        return this.stat();
      }
      createReadStream(options3) {
        Hoek.assert(this.fd !== null);
        options3 = Object.assign({ fd: this.fd, start: 0 }, options3);
        const stream = exports2.createReadStream(this.path, options3);
        if (options3.autoClose !== false) {
          this.fd = null;
        }
        return stream;
      }
    };
    for (const method of internals.methods.raw) {
      exports2[method] = Fs[method].bind(Fs);
    }
    for (const method of internals.methods.promised) {
      exports2[method] = Util.promisify(Fs[method]);
    }
  }
});
var require_file = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/file.js"(exports2) {
    "use strict";
    var Path = __require2("path");
    var Ammo = require_lib27();
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var Etag = require_etag();
    var Fs = require_fs();
    var internals = {};
    internals.defaultMap = {
      gzip: ".gz"
    };
    internals.schema = Validate.alternatives([
      Validate.string(),
      Validate.func(),
      Validate.object({
        path: Validate.alternatives(Validate.string(), Validate.func()).required(),
        confine: Validate.alternatives(Validate.string(), Validate.boolean()).default(true),
        filename: Validate.string(),
        mode: Validate.string().valid("attachment", "inline").allow(false),
        lookupCompressed: Validate.boolean(),
        lookupMap: Validate.object().min(1).pattern(/.+/, Validate.string()),
        etagMethod: Validate.string().valid("hash", "simple").allow(false),
        start: Validate.number().integer().min(0).default(0),
        end: Validate.number().integer().min(Validate.ref("start"))
      }).with("filename", "mode")
    ]);
    exports2.handler = function(route2, options3) {
      let settings = Validate.attempt(options3, internals.schema, "Invalid file handler options (" + route2.path + ")");
      settings = typeof options3 !== "object" ? { path: options3, confine: "." } : settings;
      settings.confine = settings.confine === true ? "." : settings.confine;
      Hoek.assert(typeof settings.path !== "string" || settings.path[settings.path.length - 1] !== "/", "File path cannot end with a '/':", route2.path);
      const handler = (request) => {
        const path12 = typeof settings.path === "function" ? settings.path(request) : settings.path;
        return exports2.response(path12, settings, request);
      };
      return handler;
    };
    exports2.load = function(path12, request, options3) {
      const response = exports2.response(path12, options3, request, true);
      return internals.prepare(response);
    };
    exports2.response = function(path12, options3, request, _preloaded) {
      Hoek.assert(!options3.mode || ["attachment", "inline"].indexOf(options3.mode) !== -1, "options.mode must be either false, attachment, or inline");
      if (options3.confine) {
        const confineDir = Path.resolve(request.route.settings.files.relativeTo, options3.confine);
        path12 = Path.isAbsolute(path12) ? Path.normalize(path12) : Path.join(confineDir, path12);
        if (path12.lastIndexOf(confineDir, 0) !== 0) {
          path12 = null;
        }
      } else {
        path12 = Path.isAbsolute(path12) ? Path.normalize(path12) : Path.join(request.route.settings.files.relativeTo, path12);
      }
      const source = {
        path: path12,
        settings: options3,
        stat: null,
        file: null
      };
      const prepare = _preloaded ? null : internals.prepare;
      return request.generateResponse(source, { variety: "file", marshal: internals.marshal, prepare, close: internals.close });
    };
    internals.prepare = async function(response) {
      const { request, source } = response;
      const { settings, path: path12 } = source;
      if (path12 === null) {
        throw Boom5.forbidden(null, { code: "EACCES" });
      }
      const file = source.file = new Fs.File(path12);
      try {
        const stat = await file.openStat("r");
        const start = settings.start ?? 0;
        if (settings.end !== void 0) {
          response.bytes(settings.end - start + 1);
        } else {
          response.bytes(stat.size - start);
        }
        if (!response.headers["content-type"]) {
          response.type(request.server.mime.path(path12).type ?? "application/octet-stream");
        }
        response.header("last-modified", stat.mtime.toUTCString());
        if (settings.mode) {
          const fileName = settings.filename ?? Path.basename(path12);
          response.header("content-disposition", settings.mode + "; filename=" + encodeURIComponent(fileName));
        }
        await Etag.apply(response, stat);
        return response;
      } catch (err) {
        internals.close(response);
        throw err;
      }
    };
    internals.marshal = async function(response) {
      const { request, source } = response;
      const { settings } = source;
      if (settings.lookupCompressed && !settings.start && settings.end === void 0 && request.server.settings.compression !== false) {
        const lookupMap = settings.lookupMap ?? internals.defaultMap;
        const encoding = request.info.acceptEncoding;
        const extension = lookupMap.hasOwnProperty(encoding) ? lookupMap[encoding] : null;
        if (extension) {
          const precompressed = new Fs.File(`${source.path}${extension}`);
          try {
            var stat = await precompressed.openStat("r");
          } catch (err) {
            precompressed.close();
            Bounce.ignore(err, "boom");
          }
          if (stat) {
            source.file.close();
            source.file = precompressed;
            response.bytes(stat.size);
            response.header("content-encoding", encoding);
            response.vary("accept-encoding");
          }
        }
      }
      return internals.createStream(response);
    };
    internals.addContentRange = function(response) {
      const { request } = response;
      let range = null;
      if (request.route.settings.response.ranges) {
        const length4 = response.headers["content-length"];
        if (request.headers.range && length4) {
          if (!request.headers["if-range"] || request.headers["if-range"] === response.headers.etag) {
            const mime = request.server.mime.type(response.headers["content-type"] || "application/octet-stream");
            const encoding = request.server.settings.compression && mime.compressible && !response.headers["content-encoding"] ? request.info.acceptEncoding : null;
            if (encoding === "identity" || !encoding) {
              const ranges = Ammo.header(request.headers.range, length4);
              if (!ranges) {
                const error = Boom5.rangeNotSatisfiable();
                error.output.headers["content-range"] = "bytes */" + length4;
                throw error;
              }
              if (ranges.length === 1) {
                range = ranges[0];
                response.code(206);
                response.bytes(range.to - range.from + 1);
                response.header("content-range", "bytes " + range.from + "-" + range.to + "/" + length4);
              }
            }
          }
        }
        response.header("accept-ranges", "bytes");
      }
      return range;
    };
    internals.createStream = function(response) {
      const { settings, file } = response.source;
      Hoek.assert(file !== null);
      const range = internals.addContentRange(response);
      const options3 = {
        start: settings.start ?? 0,
        end: settings.end
      };
      if (range) {
        options3.end = range.to + options3.start;
        options3.start = range.from + options3.start;
      }
      return file.createReadStream(options3);
    };
    internals.close = function(response) {
      const { source } = response;
      if (source.file !== null) {
        source.file.close();
        source.file = null;
      }
    };
  }
});
var require_directory = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/directory.js"(exports2) {
    "use strict";
    var Path = __require2("path");
    var Boom5 = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var File2 = require_file();
    var Fs = require_fs();
    var internals = {};
    internals.schema = Validate.object({
      path: Validate.alternatives(Validate.array().items(Validate.string()).single(), Validate.func()).required(),
      index: Validate.alternatives(Validate.boolean(), Validate.array().items(Validate.string()).single()).default(true),
      listing: Validate.boolean(),
      showHidden: Validate.boolean(),
      redirectToSlash: Validate.boolean(),
      lookupCompressed: Validate.boolean(),
      lookupMap: Validate.object().min(1).pattern(/.+/, Validate.string()),
      etagMethod: Validate.string().valid("hash", "simple").allow(false),
      defaultExtension: Validate.string().alphanum()
    });
    internals.resolvePathOption = function(result) {
      if (result instanceof Error) {
        throw result;
      }
      if (typeof result === "string") {
        return [result];
      }
      if (Array.isArray(result)) {
        return result;
      }
      throw Boom5.internal("Invalid path function");
    };
    exports2.handler = function(route2, options3) {
      const settings = Validate.attempt(options3, internals.schema, "Invalid directory handler options (" + route2.path + ")");
      Hoek.assert(route2.path[route2.path.length - 1] === "}", "The route path for a directory handler must end with a parameter:", route2.path);
      const paramName = /\w+/.exec(route2.path.slice(route2.path.lastIndexOf("{")))[0];
      const basePath = route2.settings.files.relativeTo;
      const normalized = Array.isArray(settings.path) ? settings.path : null;
      const indexNames = settings.index === true ? ["index.html"] : settings.index || [];
      const handler = async (request, reply) => {
        const paths = normalized ?? internals.resolvePathOption(settings.path.call(null, request));
        const selection = request.params[paramName] ?? "";
        if (Path.isAbsolute(selection)) {
          throw Boom5.notFound(null, {});
        }
        if (selection && !settings.showHidden && internals.isFileHidden(selection)) {
          throw Boom5.notFound(null, {});
        }
        if (!selection && (request.server.settings.router.stripTrailingSlash || !request.path.endsWith("/"))) {
          request.path += "/";
        }
        const resource = request.path;
        const hasTrailingSlash = resource.endsWith("/");
        const fileOptions = {
          confine: null,
          lookupCompressed: settings.lookupCompressed,
          lookupMap: settings.lookupMap,
          etagMethod: settings.etagMethod
        };
        const each = async (baseDir) => {
          fileOptions.confine = baseDir;
          let path12 = selection;
          let error;
          try {
            return await File2.load(path12, request, fileOptions);
          } catch (err) {
            Bounce.ignore(err, "boom");
            error = err;
          }
          if (internals.isNotFound(error)) {
            if (!settings.defaultExtension) {
              throw error;
            }
            if (hasTrailingSlash) {
              path12 = path12.slice(0, -1);
            }
            return await File2.load(path12 + "." + settings.defaultExtension, request, fileOptions);
          }
          if (internals.isDirectory(error)) {
            if (settings.redirectToSlash !== false && // Defaults to true
            !request.server.settings.router.stripTrailingSlash && !hasTrailingSlash) {
              return reply.redirect(resource + "/");
            }
            for (const indexName of indexNames) {
              const indexFile = Path.join(path12, indexName);
              try {
                return await File2.load(indexFile, request, fileOptions);
              } catch (err) {
                Bounce.ignore(err, "boom");
                if (!internals.isNotFound(err)) {
                  throw Boom5.internal(indexName + " is a directory", err);
                }
              }
            }
            if (settings.listing) {
              return internals.generateListing(Path.join(basePath, baseDir, path12), resource, selection, hasTrailingSlash, settings, request);
            }
          }
          throw error;
        };
        for (let i2 = 0; i2 < paths.length; ++i2) {
          try {
            return await each(paths[i2]);
          } catch (err) {
            Bounce.ignore(err, "boom");
            if (!internals.isNotFound(err) || i2 === paths.length - 1) {
              throw err;
            }
          }
        }
        throw Boom5.notFound(null, {});
      };
      return handler;
    };
    internals.generateListing = async function(path12, resource, selection, hasTrailingSlash, settings, request) {
      let files;
      try {
        files = await Fs.readdir(path12);
      } catch (err) {
        Bounce.rethrow(err, "system");
        throw Boom5.internal("Error accessing directory", err);
      }
      resource = decodeURIComponent(resource);
      const display = Hoek.escapeHtml(resource);
      let html = "<html><head><title>" + display + "</title></head><body><h1>Directory: " + display + "</h1><ul>";
      if (selection) {
        const parent = resource.substring(0, resource.lastIndexOf("/", resource.length - (hasTrailingSlash ? 2 : 1))) + "/";
        html = html + '<li><a href="' + internals.pathEncode(parent) + '">Parent Directory</a></li>';
      }
      for (const file of files) {
        if (settings.showHidden || !internals.isFileHidden(file)) {
          html = html + '<li><a href="' + internals.pathEncode(resource + (!hasTrailingSlash ? "/" : "") + file) + '">' + Hoek.escapeHtml(file) + "</a></li>";
        }
      }
      html = html + "</ul></body></html>";
      return request.generateResponse(html);
    };
    internals.isFileHidden = function(path12) {
      return /(^|[\\\/])\.([^.\\\/]|\.[^\\\/])/.test(path12);
    };
    internals.pathEncode = function(path12) {
      return encodeURIComponent(path12).replace(/%2F/g, "/").replace(/%5C/g, "\\");
    };
    internals.isNotFound = function(boom) {
      return boom.output.statusCode === 404;
    };
    internals.isDirectory = function(boom) {
      return boom.output.statusCode === 403 && boom.data.code === "EISDIR";
    };
  }
});
var require_package3 = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/package.json"(exports2, module2) {
    module2.exports = {
      name: "@hapi/inert",
      description: "Static file and directory handlers plugin for hapi.js",
      version: "7.1.0",
      repository: "https://github.com/hapijs/inert.git",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      files: [
        "lib"
      ],
      keywords: [
        "file",
        "directory",
        "handler",
        "hapi",
        "plugin"
      ],
      eslintConfig: {
        extends: [
          "plugin:@hapi/module"
        ]
      },
      dependencies: {
        "@hapi/ammo": "^6.0.1",
        "@hapi/boom": "^10.0.1",
        "@hapi/bounce": "^3.0.1",
        "@hapi/hoek": "^11.0.2",
        "@hapi/validate": "^2.0.1",
        "lru-cache": "^7.14.1"
      },
      devDependencies: {
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "*",
        "@hapi/file": "^3.0.0",
        "@hapi/hapi": "^21.3.0",
        "@hapi/lab": "^25.1.2",
        "@types/node": "^14.18.37",
        joi: "^17.8.3",
        typescript: "^4.9.5"
      },
      scripts: {
        test: "lab -f -a @hapi/code -t 100 -L -Y",
        "test-cov-html": "lab -f -a @hapi/code -r html -o coverage.html"
      },
      license: "BSD-3-Clause"
    };
  }
});
var require_lib30 = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Validate = require_lib3();
    var Directory = require_directory();
    var Etag = require_etag();
    var File2 = require_file();
    var internals = {
      schema: Validate.object({
        etagsCacheMaxSize: Validate.number().integer().min(0).default(1e3)
      }).required()
    };
    internals.fileMethod = function(path12, responseOptions = {}) {
      if (typeof responseOptions.confine === "undefined" || responseOptions.confine === true) {
        responseOptions.confine = ".";
      }
      Hoek.assert(responseOptions.end === void 0 || +responseOptions.start <= +responseOptions.end, "options.start must be less than or equal to options.end");
      return this.response(File2.response(path12, responseOptions, this.request));
    };
    exports2.plugin = {
      pkg: require_package3(),
      once: true,
      requirements: {
        hapi: ">=20.0.0"
      },
      register(server, options3) {
        Hoek.assert(Object.keys(options3).length === 0, "Inert does not support registration options");
        const settings = Validate.attempt(server.settings.plugins?.inert ?? {}, internals.schema, 'Invalid "inert" server options');
        server.expose("_etags", settings.etagsCacheMaxSize > 0 ? new Etag.Cache({ max: settings.etagsCacheMaxSize }) : null);
        server.decorate("handler", "file", File2.handler);
        server.decorate("handler", "directory", Directory.handler);
        server.decorate("toolkit", "file", internals.fileMethod);
      }
    };
  }
});
var dashboard_server_exports = {};
__export(dashboard_server_exports, {
  default: () => dashboard_server_default,
  startDashboard: () => startDashboard
});
async function startDashboard(port) {
  const dashboardServer = new Hapi.Server({
    port,
    host: "localhost",
    routes: {
      files: {
        relativeTo: getDashboardPath()
      }
    }
  });
  await dashboardServer.register(import_inert.default);
  dashboardServer.route({
    method: "GET",
    path: "/assets/{path*}",
    handler: {
      directory: {
        path: "assets",
        redirectToSlash: false
      }
    }
  });
  dashboardServer.route({
    method: "GET",
    path: "/dashboard",
    handler: (_request, h2) => h2.file("index.html")
  });
  dashboardServer.route({
    method: "GET",
    path: "/dashboard/",
    handler: (_request, h2) => h2.file("index.html")
  });
  dashboardServer.route({
    method: "GET",
    path: "/{path*}",
    handler: {
      directory: {
        path: ".",
        index: ["index.html"]
      }
    }
  });
  await dashboardServer.start();
  console.log(`\u{1F4CA} Dashboard server running at: http://localhost:${port}`);
}
var Hapi;
var import_inert;
var getDashboardPath;
var dashboard_server_default;
var init_dashboard_server = __esm({
  "src/serve/dashboard-server.ts"() {
    "use strict";
    Hapi = __toESM(require_lib29());
    import_inert = __toESM(require_lib30());
    getDashboardPath = () => {
      return path8.resolve(import.meta.dirname || process2.cwd(), "dist-dashboard");
    };
    dashboard_server_default = startDashboard;
  }
});
function sbp(selector, ...data) {
  const domain = domainFromSelector(selector);
  const starSelector = `${domain}/*`;
  const selExists = !!selectors[selector];
  let sel = selector;
  if (!selExists) {
    if (selectors[starSelector]) {
      sel = starSelector;
    } else {
      throw new Error(`SBP: selector not registered: ${selector}`);
    }
  }
  for (const filters of [selectorFilters[selector], domainFilters[domain], globalFilters]) {
    if (filters) {
      for (const filter of filters) {
        if (filter(domain, selector, data) === false)
          return;
      }
    }
  }
  if (!selExists) {
    data.unshift(selector);
  }
  return selectors[sel].apply(domains[domain].state, data);
}
function domainFromSelector(selector) {
  const domainLookup = DOMAIN_REGEX.exec(selector);
  if (domainLookup === null) {
    throw new Error(`SBP: selector missing domain: ${selector}`);
  }
  return domainLookup[0];
}
var selectors;
var domains;
var globalFilters;
var domainFilters;
var selectorFilters;
var unsafeSelectors;
var DOMAIN_REGEX;
var SBP_BASE_SELECTORS;
var esm_default;
var init_esm3 = __esm({
  "node_modules/.deno/@sbp+sbp@2.4.1/node_modules/@sbp/sbp/dist/esm/index.js"() {
    selectors = /* @__PURE__ */ Object.create(null);
    domains = /* @__PURE__ */ Object.create(null);
    globalFilters = [];
    domainFilters = /* @__PURE__ */ Object.create(null);
    selectorFilters = /* @__PURE__ */ Object.create(null);
    unsafeSelectors = /* @__PURE__ */ Object.create(null);
    DOMAIN_REGEX = /^[^/]+/;
    SBP_BASE_SELECTORS = {
      "sbp/selectors/register": (sels) => {
        const registered = [];
        for (const selector in sels) {
          const domainName = domainFromSelector(selector);
          const domain = domainName in domains ? domains[domainName] : domains[domainName] = { state: /* @__PURE__ */ Object.create(null), locked: false };
          if (domain.locked) {
            (console.warn || console.log)(`[SBP WARN]: not registering selector on locked domain: '${selector}'`);
          } else if (selectors[selector]) {
            (console.warn || console.log)(`[SBP WARN]: not registering already registered selector: '${selector}'`);
          } else if (typeof sels[selector] === "function") {
            if (unsafeSelectors[selector]) {
              (console.warn || console.log)(`[SBP WARN]: registering unsafe selector: '${selector}' (remember to lock after overwriting)`);
            }
            const fn = selectors[selector] = sels[selector];
            registered.push(selector);
            if (selector === `${domainName}/_init`) {
              fn.call(domain.state);
            }
          }
        }
        return registered;
      },
      "sbp/selectors/unregister": (sels) => {
        var _a2;
        for (const selector of sels) {
          if (!unsafeSelectors[selector]) {
            throw new Error(`SBP: can't unregister locked selector: ${selector}`);
          }
          if ((_a2 = domains[domainFromSelector(selector)]) === null || _a2 === void 0 ? void 0 : _a2.locked) {
            throw new Error(`SBP: can't unregister selector on a locked domain: '${selector}'`);
          }
          delete selectors[selector];
        }
      },
      "sbp/selectors/overwrite": (sels) => {
        sbp("sbp/selectors/unregister", Object.keys(sels));
        return sbp("sbp/selectors/register", sels);
      },
      "sbp/selectors/unsafe": (sels) => {
        for (const selector of sels) {
          if (selectors[selector]) {
            throw new Error("unsafe must be called before registering selector");
          }
          unsafeSelectors[selector] = true;
        }
      },
      "sbp/selectors/lock": (sels) => {
        for (const selector of sels) {
          delete unsafeSelectors[selector];
        }
      },
      "sbp/selectors/fn": (sel) => {
        return selectors[sel];
      },
      "sbp/filters/global/add": (filter) => {
        globalFilters.push(filter);
      },
      "sbp/filters/domain/add": (domain, filter) => {
        if (!domainFilters[domain])
          domainFilters[domain] = [];
        domainFilters[domain].push(filter);
      },
      "sbp/filters/selector/add": (selector, filter) => {
        if (!selectorFilters[selector])
          selectorFilters[selector] = [];
        selectorFilters[selector].push(filter);
      },
      "sbp/domains/lock": (domainNames) => {
        if (!domainNames) {
          for (const name in domains) {
            domains[name].locked = true;
          }
        } else {
          for (const name of domainNames) {
            if (!domains[name]) {
              throw new Error(`SBP: cannot lock non-existent domain: ${name}`);
            }
            domains[name].locked = true;
          }
        }
      }
    };
    SBP_BASE_SELECTORS["sbp/selectors/register"](SBP_BASE_SELECTORS);
    esm_default = sbp;
  }
});
var _store;
var module_default;
var init_module = __esm({
  "node_modules/.deno/@sbp+okturtles.data@0.1.5/node_modules/@sbp/okturtles.data/dist/module.mjs"() {
    "use strict";
    init_esm3();
    _store = /* @__PURE__ */ new Map();
    module_default = esm_default("sbp/selectors/register", {
      "okTurtles.data/get": function(key) {
        return _store.get(key);
      },
      "okTurtles.data/set": function(key, data) {
        _store.set(key, data);
        return data;
      },
      "okTurtles.data/delete": function(key) {
        return _store.delete(key);
      },
      "okTurtles.data/add": function(key, data) {
        const array2 = _store.get(key);
        if (array2) {
          array2.push(data);
        } else {
          _store.set(key, [data]);
        }
      },
      "okTurtles.data/remove": function(key, data) {
        const array2 = _store.get(key);
        if (array2) {
          const aLen = array2.length;
          const filtered = array2.filter((v2) => v2 !== data);
          _store.set(key, filtered);
          return aLen - filtered.length;
        }
      },
      "okTurtles.data/apply": function(key, fn) {
        return fn(_store.get(key));
      }
    });
  }
});
var isEventQueueSbpEvent;
var esm_default2;
var init_esm4 = __esm({
  "node_modules/.deno/@sbp+okturtles.eventqueue@1.2.0/node_modules/@sbp/okturtles.eventqueue/dist/esm/index.js"() {
    init_esm3();
    isEventQueueSbpEvent = (e2) => {
      return Object.prototype.hasOwnProperty.call(e2, "sbpInvocation");
    };
    esm_default2 = esm_default("sbp/selectors/register", {
      "okTurtles.eventQueue/_init": function() {
        this.eventQueues = /* @__PURE__ */ Object.create(null);
      },
      "okTurtles.eventQueue/isWaiting": function(name) {
        var _a2;
        return !!((_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.length);
      },
      "okTurtles.eventQueue/queuedInvocations": function(name) {
        var _a2, _b;
        if (name == null) {
          return Object.fromEntries(Object.entries(this.eventQueues).map(([name2, events]) => [name2, events.map((event) => {
            if (isEventQueueSbpEvent(event)) {
              return event.sbpInvocation;
            } else {
              return event.fn;
            }
          })]));
        }
        return (_b = (_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.map((event) => {
          if (isEventQueueSbpEvent(event)) {
            return event.sbpInvocation;
          } else {
            return event.fn;
          }
        })) !== null && _b !== void 0 ? _b : [];
      },
      "okTurtles.eventQueue/queueEvent": async function(name, invocation) {
        if (!Object.prototype.hasOwnProperty.call(this.eventQueues, name)) {
          this.eventQueues[name] = [];
        }
        const events = this.eventQueues[name];
        let accept;
        const promise = new Promise((resolve8) => {
          accept = resolve8;
        });
        const thisEvent = typeof invocation === "function" ? {
          fn: invocation,
          promise
        } : {
          sbpInvocation: invocation,
          promise
        };
        events.push(thisEvent);
        while (events.length > 0) {
          const event = events[0];
          if (event === thisEvent) {
            try {
              if (typeof invocation === "function") {
                return await invocation();
              } else {
                return await esm_default(...invocation);
              }
            } finally {
              accept();
              events.shift();
            }
          } else {
            await event.promise;
          }
        }
      }
    });
  }
});
var listenKey;
var esm_default3;
var init_esm5 = __esm({
  "node_modules/.deno/@sbp+okturtles.events@1.0.0/node_modules/@sbp/okturtles.events/dist/esm/index.js"() {
    init_esm3();
    init_module();
    listenKey = (evt) => `events/${evt}/listeners`;
    esm_default3 = esm_default("sbp/selectors/register", {
      "okTurtles.events/_init": function() {
        this.errorHandler = (event, e2) => {
          console.error(`[okTurtles.events] Error at handler for ${event}`, e2);
        };
      },
      "okTurtles.events/on": function(event, handler) {
        esm_default("okTurtles.data/add", listenKey(event), handler);
        return () => esm_default("okTurtles.events/off", event, handler);
      },
      "okTurtles.events/once": function(event, handler) {
        const cbWithOff = (...args) => {
          handler(...args);
          esm_default("okTurtles.events/off", event, cbWithOff);
        };
        return esm_default("okTurtles.events/on", event, cbWithOff);
      },
      "okTurtles.events/emit": function(event, ...data) {
        var _a2;
        for (const listener of esm_default("okTurtles.data/get", listenKey(event)) || []) {
          try {
            listener(...data);
          } catch (e2) {
            (_a2 = this.errorHandler) === null || _a2 === void 0 ? void 0 : _a2.call(this, event, e2);
          }
        }
      },
      // almost identical to Vue.prototype.$off, except we require `event` argument
      "okTurtles.events/off": function(event, handler) {
        if (handler) {
          esm_default("okTurtles.data/remove", listenKey(event), handler);
        } else {
          esm_default("okTurtles.data/delete", listenKey(event));
        }
      },
      "okTurtles.events/setErrorHandler": function(errorHandler) {
        this.errorHandler = errorHandler;
      }
    });
  }
});
var require_color_name = __commonJS({
  "node_modules/.deno/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});
var require_conversions = __commonJS({
  "node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g2, b);
      const max = Math.max(r, g2, b);
      const delta = max - min;
      let h2;
      let s;
      if (max === min) {
        h2 = 0;
      } else if (r === max) {
        h2 = (g2 - b) / delta;
      } else if (g2 === max) {
        h2 = 2 + (b - r) / delta;
      } else if (b === max) {
        h2 = 4 + (r - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h2, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s;
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v2 = Math.max(r, g2, b);
      const diff = v2 - Math.min(r, g2, b);
      const diffc = function(c) {
        return (v2 - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h2 = 0;
        s = 0;
      } else {
        s = diff / v2;
        rdif = diffc(r);
        gdif = diffc(g2);
        bdif = diffc(b);
        if (r === v2) {
          h2 = bdif - gdif;
        } else if (g2 === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s * 100,
        v2 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g2 = rgb[1];
      let b = rgb[2];
      const h2 = convert.rgb.hsl(rgb)[0];
      const w4 = 1 / 255 * Math.min(r, Math.min(g2, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g2, b));
      return [h2, w4 * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g2, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m3 = (1 - g2 - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m3 * 100, y * 100, k * 100];
    };
    function comparativeDistance(x3, y) {
      return (x3[0] - y[0]) ** 2 + (x3[1] - y[1]) ** 2 + (x3[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g2 = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x3 = r * 0.4124 + g2 * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g2 * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g2 * 0.1192 + b * 0.9505;
      return [x3 * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x3 = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x3 /= 95.047;
      y /= 100;
      z /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x3 - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h2 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v2 = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h2, sv * 100, v2 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v2 = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f = h2 - Math.floor(h2);
      const p = 255 * v2 * (1 - s);
      const q = 255 * v2 * (1 - s * f);
      const t = 255 * v2 * (1 - s * (1 - f));
      v2 *= 255;
      switch (hi) {
        case 0:
          return [v2, t, p];
        case 1:
          return [q, v2, p];
        case 2:
          return [p, v2, t];
        case 3:
          return [p, q, v2];
        case 4:
          return [t, p, v2];
        case 5:
          return [v2, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const vmin = Math.max(v2, 0.01);
      let sl;
      let l;
      l = (2 - s) * v2;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h2, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h2);
      const v2 = 1 - bl;
      f = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v2 - wh);
      let r;
      let g2;
      let b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r = v2;
          g2 = n;
          b = wh;
          break;
        case 1:
          r = n;
          g2 = v2;
          b = wh;
          break;
        case 2:
          r = wh;
          g2 = v2;
          b = n;
          break;
        case 3:
          r = wh;
          g2 = n;
          b = v2;
          break;
        case 4:
          r = n;
          g2 = wh;
          b = v2;
          break;
        case 5:
          r = v2;
          g2 = wh;
          b = n;
          break;
      }
      return [r * 255, g2 * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g2 = 1 - Math.min(1, m3 * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g2 * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x3 = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g2;
      let b;
      r = x3 * 3.2406 + y * -1.5372 + z * -0.4986;
      g2 = x3 * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x3 * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g2 * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x3 = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x3 /= 95.047;
      y /= 100;
      z /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x3 - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x3;
      let y;
      let z;
      y = (l + 16) / 116;
      x3 = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x22 = x3 ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x3 = x22 > 8856e-6 ? x22 : (x3 - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x3 *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x3, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h2];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g2, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g2 = args[1];
      const b = args[2];
      if (r === g2 && g2 === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g2 = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g2, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g2, b];
    };
    convert.rgb.hex = function(args) {
      const integer2 = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string3 = integer2.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer2 = parseInt(colorString, 16);
      const r = integer2 >> 16 & 255;
      const g2 = integer2 >> 8 & 255;
      const b = integer2 & 255;
      return [r, g2, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g2), b);
      const min = Math.min(Math.min(r, g2), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g2 - b) / chroma % 6;
      } else if (max === g2) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g2) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const c = s * v2;
      let f = 0;
      if (c < 1) {
        f = (v2 - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      if (c === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v2 = hi % 1;
      const w4 = 1 - v2;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w4;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w4;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w4;
      }
      mg = (1 - c) * g2;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c + g2 * (1 - c);
      let f = 0;
      if (v2 > 0) {
        f = c / v2;
      }
      return [hcg[0], f * 100, v2 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const l = g2 * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c + g2 * (1 - c);
      return [hcg[0], (v2 - c) * 100, (1 - v2) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w4 = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v2 = 1 - b;
      const c = v2 - w4;
      let g2 = 0;
      if (c < 1) {
        g2 = (v2 - c) / (1 - c);
      }
      return [hwb[0], c * 100, g2 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray2) {
      return [0, 100, gray2[0]];
    };
    convert.gray.cmyk = function(gray2) {
      return [0, 0, 0, gray2[0]];
    };
    convert.gray.lab = function(gray2) {
      return [gray2[0], 0, 0];
    };
    convert.gray.hex = function(gray2) {
      const val = Math.round(gray2[0] / 100 * 255) & 255;
      const integer2 = (val << 16) + (val << 8) + val;
      const string3 = integer2.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});
var require_route2 = __commonJS({
  "node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from6, to) {
      return function(args) {
        return to(from6(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path12 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path12.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path12;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        const toModel = models[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});
var require_color_convert = __commonJS({
  "node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route2 = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route2(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});
var require_ansi_styles = __commonJS({
  "node_modules/.deno/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${code2 + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${38 + offset};5;${code2}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g2, b) => [r, g2, b];
    var setLazyProperty = (object2, property, get22) => {
      Object.defineProperty(object2, property, {
        get: () => {
          const value = get22();
          Object.defineProperty(object2, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});
var require_has_flag = __commonJS({
  "node_modules/.deno/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});
var require_supports_color = __commonJS({
  "node_modules/.deno/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = __require2("os");
    var tty = __require2("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version4 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version4 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});
var require_util2 = __commonJS({
  "node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string3, substring, replacer) => {
      let index = string3.indexOf(substring);
      if (index === -1) {
        return string3;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string3.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string3.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string3.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string3, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string3[index - 1] === "\r";
        returnValue += string3.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string3.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string3.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});
var require_templates = __commonJS({
  "node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u2 = c[0] === "u";
      const bracket = c[1] === "{";
      if (u2 && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u2 && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number2 = Number(chunk);
        if (!Number.isNaN(number2)) {
          results.push(number2);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m3, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk5, styles) {
      const enabled2 = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled2[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk5;
      for (const [styleName, styles2] of Object.entries(enabled2)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk5, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m3, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string3 = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string3 : buildStyle(chalk5, styles)(string3));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk5, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});
var require_source = __commonJS({
  "node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util2();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object2, options3 = {}) => {
      if (options3.level && !(Number.isInteger(options3.level) && options3.level >= 0 && options3.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object2.level = options3.level === void 0 ? colorLevel : options3.level;
    };
    var ChalkClass = class {
      constructor(options3) {
        return chalkFactory(options3);
      }
    };
    var chalkFactory = (options3) => {
      const chalk6 = {};
      applyOptions(chalk6, options3);
      chalk6.template = (...arguments_) => chalkTag(chalk6.template, ...arguments_);
      Object.setPrototypeOf(chalk6, Chalk.prototype);
      Object.setPrototypeOf(chalk6.template, chalk6);
      chalk6.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk6.template.Instance = ChalkClass;
      return chalk6.template;
    };
    function Chalk(options3) {
      return chalkFactory(options3);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto3 = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto3);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string3) => {
      if (self2.level <= 0 || !string3) {
        return self2._isEmpty ? "" : string3;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string3;
      }
      const { openAll, closeAll } = styler;
      if (string3.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string3 = stringReplaceAll(string3, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string3.indexOf("\n");
      if (lfIndex !== -1) {
        string3 = stringEncaseCRLFWithFirstIndex(string3, closeAll, openAll, lfIndex);
      }
      return openAll + string3 + closeAll;
    };
    var template;
    var chalkTag = (chalk6, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i2 = 1; i2 < firstString.length; i2++) {
        parts.push(
          String(arguments_[i2 - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i2])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk6, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk5 = Chalk();
    chalk5.supportsColor = stdoutColor;
    chalk5.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk5.stderr.supportsColor = stderrColor;
    module2.exports = chalk5;
  }
});
var SERVER_EXITING;
var SERVER_RUNNING;
var init_events = __esm({
  "src/serve/events.ts"() {
    "use strict";
    SERVER_EXITING = "server-exiting";
    SERVER_RUNNING = "server-running";
  }
});
var SERVER_INSTANCE;
var PUBSUB_INSTANCE;
var init_instance_keys = __esm({
  "src/serve/instance-keys.ts"() {
    "use strict";
    SERVER_INSTANCE = "@instance/server";
    PUBSUB_INSTANCE = "@instance/pubsub";
  }
});
var require_err_helpers = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js"(exports2, module2) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});
var require_err_proto = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js"(exports2, module2) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module2.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});
var require_err = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString2 } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString2.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});
var require_err_with_cause = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports2, module2) {
    "use strict";
    module2.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString2 } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString2.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});
var require_req = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path12 = req.path;
        _req.url = typeof path12 === "string" ? path12 : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});
var require_res = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});
var require_pino_std_serializers = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/index.js"(exports2, module2) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});
var require_caller = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/caller.js"(exports2, module2) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module2.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});
var require_validator2 = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
      } = opts;
      return function validate({ paths }) {
        paths.forEach((s) => {
          if (typeof s !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (/〇/.test(s)) throw Error();
            const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr)) throw Error();
            if (/\/\*/.test(expr)) throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e2) {
            throw Error(ERR_INVALID_PATH(s));
          }
        });
      };
    }
  }
});
var require_rx = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js"(exports2, module2) {
    "use strict";
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});
var require_parse = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = parse11;
    function parse11({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o2, strPath, ix) {
        var path12 = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path12 = path12.map((p) => {
          if (p[0] === "[") return p.substr(1, p.length - 2);
          else return p;
        });
        const star = path12.indexOf("*");
        if (star > -1) {
          const before = path12.slice(0, star);
          const beforeStr = before.join(".");
          const after = path12.slice(star + 1, path12.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o2[strPath] = {
            path: path12,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o2;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});
var require_redactor = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);
      redact.state = state;
      if (serialize === false) {
        redact.restore = (o2) => state.restore(o2);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path12) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path12];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path12)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0) existence += `o${delim}${path12} != null`;
        else existence += ` && o${delim}${path12} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path12}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path12} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});
var require_modifiers = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null || typeof target === "string") return;
      const length4 = keys.length;
      for (var i2 = 0; i2 < length4; i2++) {
        const k = keys[i2];
        target[k] = values[i2];
      }
    }
    function groupRedact(o2, path12, censor, isCensorFct, censorFctTakesPath) {
      const target = get22(o2, path12);
      if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path12.length;
      const pathWithKey = censorFctTakesPath ? [...path12] : void 0;
      const values = new Array(keysLength);
      for (var i2 = 0; i2 < keysLength; i2++) {
        const key = keys[i2];
        values[i2] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i2 = 0; i2 < instructions.length; i2++) {
        const { target, path: path12, value } = instructions[i2];
        let current = target;
        for (let i3 = path12.length - 1; i3 > 0; i3--) {
          current = current[path12[i3]];
        }
        current[path12[0]] = value;
      }
    }
    function nestedRedact(store, o2, path12, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get22(o2, path12);
      if (target == null) return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i2 = 0; i2 < keysLength; i2++) {
        const key = keys[i2];
        specialSet(store, target, key, path12, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has2(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o2, k, path12, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i2 = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n = o2[k];
      if (typeof n !== "object") return;
      while (n != null && ++i2 < afterPathLen) {
        depth += 1;
        k = afterPath[i2];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i2 !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i2;
              ov = iterateNthLevel(wcov, level - 1, k, path12, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, o2[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path12, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o2[originalKey]);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o2[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path12, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has2(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o2[originalKey]);
            store.push(rv);
            n[k] = nv;
          }
          n = n[k];
        }
        if (typeof n !== "object") break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get22(o2, p) {
      var i2 = -1;
      var l = p.length;
      var n = o2;
      while (n != null && ++i2 < l) {
        n = n[p[i2]];
      }
      return n;
    }
    function iterateNthLevel(wcov, level, k, path12, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path12, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k, path12, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path12 = [];
      do {
        path12.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path: path12, value, target };
    }
  }
});
var require_restorer = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js"(exports2, module2) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer() {
      return function compileRestore() {
        if (this.restore) {
          this.restore.state.secret = this.secret;
          return;
        }
        const { secret, wcLen } = this;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function(
          "o",
          restoreTmpl(resetters, paths, hasWildcards)
        ).bind(state);
        this.restore.state = state;
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path12) => {
        const { circle, escPath, leadingBracket } = secret[path12];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path12} = secret[${escPath}].val`;
        const clear2 = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear2}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});
var require_state2 = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(o2) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o2;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize !== false) builder.push({ serialize });
      if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});
var require_fast_redact = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/index.js"(exports2, module2) {
    "use strict";
    var validator = require_validator2();
    var parse11 = require_parse();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state2();
    var rx = require_rx();
    var validate = validator();
    var noop = (o2) => o2;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0) return serialize || noop;
      validate({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse11({ paths, censor });
      const compileRestore = restorer();
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});
var require_symbols2 = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/symbols.js"(exports2, module2) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var levelCompSym = Symbol("pino.levelComp");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});
var require_redaction = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/redaction.js"(exports2, module2) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols2();
    var { rx, validator } = fastRedact;
    var validate = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o2, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o2[ns] = null;
          return o2;
        }
        if (o2[ns] === null) {
          return o2;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o2[ns] = o2[ns] || [];
        if (ns !== wildcardFirstSym && o2[ns].length === 0) {
          o2[ns].push(...o2[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o2).forEach(function(k) {
            if (o2[k]) {
              o2[k].push(nextPath);
            }
          });
        }
        o2[ns].push(nextPath);
        return o2;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o2, k) => {
        if (shape[k] === null) {
          o2[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path12) => {
            return censor(value, [k, ...path12]);
          } : censor;
          o2[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o2;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      validate({ paths, censor });
      return { paths, censor };
    }
    module2.exports = redaction;
  }
});
var require_time = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/time.js"(exports2, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});
var require_quick_format_unescaped = __commonJS({
  "node_modules/.deno/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o2) {
      try {
        return JSON.stringify(o2);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module2.exports = format32;
    function format32(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0) return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i2 = 0; i2 < flen; ) {
        if (f.charCodeAt(i2) === 37 && i2 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i2 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += Number(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += Math.floor(Number(args[a]));
              lastPos = i2 + 2;
              i2++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0) break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              str += ss(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += String(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 37:
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += "%";
              lastPos = i2 + 2;
              i2++;
              a--;
              break;
          }
          ++a;
        }
        ++i2;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});
var require_atomic_sleep = __commonJS({
  "node_modules/.deno/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports2, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep;
    }
  }
});
var require_sonic_boom = __commonJS({
  "node_modules/.deno/sonic-boom@3.8.1/node_modules/sonic-boom/index.js"(exports2, module2) {
    "use strict";
    var fs2 = __require2("fs");
    var EventEmitter = __require2("events");
    var inherits = __require2("util").inherits;
    var path12 = __require2("path");
    var sleep = require_atomic_sleep();
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags8 = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs2.mkdirSync(path12.dirname(file), { recursive: true });
          const fd = fs2.openSync(file, flags8, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs2.mkdir(path12.dirname(file), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs2.open(file, flags8, mode, fileOpened);
        });
      } else {
        fs2.open(file, flags8, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, sync, append = true, mkdir: mkdir3, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir3 || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs2.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs2.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n2 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs2.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
    }
    function releaseWritingBuf(writingBuf, len, n) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
      }
      len = Math.max(len - n, 0);
      writingBuf = writingBuf.slice(n);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([data]);
        lens.push(data.length);
      } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          fs2.fsync(this.fd, (err) => {
            this._flushPending = false;
            cb(err);
          });
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file) {
        this.file = file;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs2.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf2 = "";
      while (this._bufs.length || buf2) {
        if (buf2.length <= 0) {
          buf2 = this._bufs[0];
        }
        try {
          const n = fs2.writeSync(this.fd, buf2, "utf8");
          const releasedBufObj = releaseWritingBuf(buf2, this._len, n);
          buf2 = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf2.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs2.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf2 = kEmptyBuffer;
      while (this._bufs.length || buf2.length) {
        if (buf2.length <= 0) {
          buf2 = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n = fs2.writeSync(this.fd, buf2);
          buf2 = buf2.subarray(n);
          this._len = Math.max(this._len - n, 0);
          if (buf2.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs2.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs2.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs2.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs2.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      fs2.fsync(sonic.fd, closeWrapped);
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs2.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module2.exports = SonicBoom;
  }
});
var require_on_exit_leak_free = __commonJS({
  "node_modules/.deno/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js"(exports2, module2) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry2;
    function ensureRegistry() {
      if (registry2 === void 0) {
        registry2 = new FinalizationRegistry(clear2);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry2 = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear2(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry2.register(obj, ref);
      refs[event].push(ref);
    }
    function register2(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry2 === void 0) {
        return;
      }
      registry2.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module2.exports = {
      register: register2,
      registerBeforeExit,
      unregister
    };
  }
});
var require_package4 = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/package.json"(exports2, module2) {
    module2.exports = {
      name: "thread-stream",
      version: "2.7.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^3.0.0",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        test: 'standard && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});
var require_wait2 = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/wait.js"(exports2, module2) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check2 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index);
            if (current === prior) {
              check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check2(1);
    }
    function waitDiff(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check2 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check2(1);
    }
    module2.exports = { wait, waitDiff };
  }
});
var require_indexes = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/indexes.js"(exports2, module2) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module2.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});
var require_thread_stream = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/index.js"(exports2, module2) {
    "use strict";
    var { version: version4 } = require_package4();
    var { EventEmitter } = __require2("events");
    var { Worker: Worker2 } = __require2("worker_threads");
    var { join: join10 } = __require2("path");
    var { pathToFileURL } = __require2("url");
    var { wait } = require_wait2();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = __require2("buffer");
    var assert22 = __require2("assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry2 = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker2(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join10(__dirname, "lib", "worker.js");
      const worker = new Worker2(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version4
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry2.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert22(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code2) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry2.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code2 !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker2(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length4 = Buffer.byteLength(data);
      stream[kImpl].data.write(data, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length4);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module2.exports = ThreadStream;
  }
});
var require_transport = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/transport.js"(exports2, module2) {
    "use strict";
    var { createRequire } = __require2("module");
    var getCallers = require_caller();
    var { join: join10, isAbsolute: isAbsolute6, sep } = __require2("path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, options: options3 = {}, worker = {}, caller = getCallers() } = fullOptions;
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join10(__dirname, "worker.js");
        options3.targets = targets.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-pipeline-worker"] || join10(__dirname, "worker-pipeline.js");
        options3.targets = pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      }
      if (levels) {
        options3.levels = levels;
      }
      if (dedupe) {
        options3.dedupe = dedupe;
      }
      return buildStream(fixTarget(target), options3, worker);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute6(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join10(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module2.exports = transport;
  }
});
var require_tools = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/tools.js"(exports2, module2) {
    "use strict";
    var format32 = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols2();
    var { isMainThread } = __require2("worker_threads");
    var transport = require_transport();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o2, ...n) {
        if (typeof o2 === "object") {
          let msg = o2;
          if (o2 !== null) {
            if (o2.method && o2.headers && o2.socket) {
              o2 = mapHttpRequest(o2);
            } else if (typeof o2.setHeader === "function") {
              o2 = mapHttpResponse(o2);
            }
          }
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o2, format32(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o2 === void 0 ? n.shift() : o2;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format32(msg, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i2 = 0; i2 < l && point >= 32; i2++) {
        point = str.charCodeAt(i2);
        if (point === 34 || point === 92) {
          result += str.slice(last, i2) + "\\";
          last = i2;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time3) {
      const stringify2 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time3;
      data = data + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
          if (value === void 0) continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions4) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions4, opts);
        opts.serializers = Object.assign({}, defaultOptions4.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions4.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled: enabled2, onChild } = opts;
        if (enabled2 === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify2 = stringifySafeFn || this[stringifySafeSym];
          return stringify2(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log2) {
      return {
        level,
        bindings,
        log: log2
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module2.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});
var require_constants = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/constants.js"(exports2, module2) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module2.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});
var require_levels = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/levels.js"(exports2, module2) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols2();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e2) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o2, k) => {
      o2[DEFAULT_LEVELS[k]] = k;
      return o2;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o2, k) => {
      o2[k] = '{"level":' + Number(k);
      return o2;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache3 = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache3[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache3;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel2) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel2];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o2, k) => {
        o2[customLevels[k]] = k;
        return o2;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});
var require_meta = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/meta.js"(exports2, module2) {
    "use strict";
    module2.exports = { version: "8.19.0" };
  }
});
var require_proto = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/proto.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = __require2("events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym
    } = require_symbols2();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify
    } = require_tools();
    var {
      version: version4
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version: version4,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options3) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options3 = options3 || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options3.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i2 = 0; i2 < parentSymbols.length; i2++) {
          const ks = parentSymbols[i2];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options3.serializers) {
          instance[serializersSym][bk] = options3.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options3.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options3.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options3.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log: log2 } = options3.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log2 || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options3.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options3.customLevels);
        instance.levels = mappings(options3.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options3.redact === "object" && options3.redact !== null || Array.isArray(options3.redact)) {
        instance.redact = options3.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options3.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options3.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options3.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(s);
    }
    function noop() {
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});
var require_safe_stable_stringify = __commonJS({
  "node_modules/.deno/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array2, comparator) {
      if (array2.length > 200 || comparator) {
        return array2.sort(comparator);
      }
      for (let i2 = 1; i2 < array2.length; i2++) {
        const currentValue = array2[i2];
        let position = i2;
        while (position !== 0 && array2[position - 1] > currentValue) {
          array2[position] = array2[position - 1];
          position--;
        }
        array2[position] = currentValue;
      }
      return array2;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array2, separator, maximumBreadth) {
      if (array2.length < maximumBreadth) {
        maximumBreadth = array2.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array2[0]}`;
      for (let i2 = 1; i2 < maximumBreadth; i2++) {
        res += `${separator}"${i2}":${whitespace}${array2[i2]}`;
      }
      return res;
    }
    function getCircularValueOption(options3) {
      if (hasOwnProperty.call(options3, "circularValue")) {
        const circularValue = options3.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options3) {
      let value;
      if (hasOwnProperty.call(options3, "deterministic")) {
        value = options3.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options3, key) {
      let value;
      if (hasOwnProperty.call(options3, key)) {
        value = options3[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options3, key) {
      let value;
      if (hasOwnProperty.call(options3, key)) {
        value = options3[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number2) {
      if (number2 === 1) {
        return "1 item";
      }
      return `${number2} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options3) {
      if (hasOwnProperty.call(options3, "strict")) {
        const value = options3.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options3) {
      options3 = { ...options3 };
      const fail = getStrictOption(options3);
      if (fail) {
        if (options3.bigint === void 0) {
          options3.bigint = false;
        }
        if (!("circularValue" in options3)) {
          options3.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options3);
      const bigint2 = getBooleanOption(options3, "bigint");
      const deterministic = getDeterministicOption(options3);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options3, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options3, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join10 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join10 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyFnReplacer(String(i2), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join10;
              }
              const tmp = stringifyFnReplacer(String(i2), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join10}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join10 = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join10;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join10;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join10 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join10 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyArrayReplacer(String(i2), value[i2], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join10;
              }
              const tmp = stringifyArrayReplacer(String(i2), value[i2], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join10}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join10 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join10;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join11 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyIndent(String(i2), value[i2], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join11;
              }
              const tmp = stringifyIndent(String(i2), value[i2], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join11}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join10 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join10, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join10;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join10;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join10;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifySimple(String(i2), value[i2], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i2), value[i2], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});
var require_multistream = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/multistream.js"(exports2, module2) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i2) => {
          streamLevels[i2] = opts.levels[i2];
        });
      }
      const res = {
        write,
        add,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone: clone2,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i2 = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i2, streams.length, opts.dedupe); i2 = adjustLoopVar(i2, opts.dedupe)) {
          dest = streams[i2];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone2(level) {
        const streams = new Array(this.streams.length);
        for (let i2 = 0; i2 < streams.length; i2++) {
          streams[i2] = {
            level,
            stream: this.streams[i2].stream
          };
        }
        return {
          write,
          add,
          minLevel: level,
          streams,
          clone: clone2,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a, b) {
      return a.level - b.level;
    }
    function initLoopVar(length4, dedupe) {
      return dedupe ? length4 - 1 : 0;
    }
    function adjustLoopVar(i2, dedupe) {
      return dedupe ? i2 - 1 : i2 + 1;
    }
    function checkLoopVar(i2, length4, dedupe) {
      return dedupe ? i2 >= 0 : i2 < length4;
    }
    module2.exports = multistream;
  }
});
var require_pino = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/pino.js"(exports2, module2) {
    "use strict";
    var os = __require2("os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time3 = require_time();
    var proto3 = require_proto();
    var symbols2 = require_symbols2();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify,
      normalizeDestFileDescriptor,
      noop
    } = require_tools();
    var { version: version4 } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols2;
    var { epochTime, nullTime } = time3;
    var { pid } = process;
    var hostname2 = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions4 = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname: hostname2 },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number2) {
          return { level: number2 };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize22 = createArgsNormalizer(defaultOptions4);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino2(...args) {
      const instance = {};
      const { opts, stream } = normalize22(instance, caller(), ...args);
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base: base4,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base4 !== null) {
        if (name === void 0) {
          chindings = coreChindings(base4);
        } else {
          chindings = coreChindings(Object.assign({}, base4, { name }));
        }
      }
      const time4 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time4().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time4,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto3());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module2.exports = pino2;
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module2.exports.transport = require_transport();
    module2.exports.multistream = require_multistream();
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time3);
    module2.exports.symbols = symbols2;
    module2.exports.version = version4;
    module2.exports.default = pino2;
    module2.exports.pino = pino2;
  }
});
function logMethod(args, method) {
  const stringIdx = typeof args[0] === "string" ? 0 : 1;
  if (args.length > 1) {
    for (let i2 = stringIdx + 1; i2 < args.length; ++i2) {
      args[stringIdx] += typeof args[i2] === "string" ? " %s" : " %o";
    }
  }
  method.apply(this, args);
}
var import_npm_pino;
var prettyPrint;
var logger2;
var logLevel;
var init_logger = __esm({
  "src/serve/logger.ts"() {
    "use strict";
    import_npm_pino = __toESM(require_pino());
    prettyPrint = process3.env.NODE_ENV === "development" || process3.env.CI || process3.env.CYPRESS_RECORD_KEY || process3.env.PRETTY;
    if (prettyPrint) {
      try {
        logger2 = (0, import_npm_pino.default)({
          hooks: { logMethod },
          transport: {
            target: "pino-pretty",
            options: {
              colorize: true
            }
          }
        });
      } catch (e2) {
        console.warn("pino-pretty transport unavailable, using basic logging", e2);
        logger2 = (0, import_npm_pino.default)({ hooks: { logMethod } });
      }
    } else {
      logger2 = (0, import_npm_pino.default)({ hooks: { logMethod } });
    }
    logLevel = process3.env.LOG_LEVEL || (prettyPrint ? "debug" : "info");
    if (Object.keys(logger2.levels.values).includes(logLevel)) {
      logger2.level = logLevel;
    } else {
      logger2.warn(`Unknown log level: ${logLevel}`);
    }
    globalThis.logger = logger2;
    console.debug = logger2.debug.bind(logger2);
    console.info = logger2.info.bind(logger2);
    console.log = logger2.info.bind(logger2);
    console.warn = logger2.warn.bind(logger2);
    console.error = logger2.error.bind(logger2);
  }
});
var isEventQueueSbpEvent2;
var esm_default4;
var init_esm6 = __esm({
  "node_modules/.deno/@sbp+okturtles.eventqueue@1.2.1/node_modules/@sbp/okturtles.eventqueue/dist/esm/index.mjs"() {
    init_esm3();
    isEventQueueSbpEvent2 = (e2) => {
      return Object.prototype.hasOwnProperty.call(e2, "sbpInvocation");
    };
    esm_default4 = esm_default("sbp/selectors/register", {
      "okTurtles.eventQueue/_init": function() {
        this.eventQueues = /* @__PURE__ */ Object.create(null);
      },
      "okTurtles.eventQueue/isWaiting": function(name) {
        var _a2;
        return !!((_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.length);
      },
      "okTurtles.eventQueue/queuedInvocations": function(name) {
        var _a2, _b;
        if (name == null) {
          return Object.fromEntries(Object.entries(this.eventQueues).map(([name2, events]) => [name2, events.map((event) => {
            if (isEventQueueSbpEvent2(event)) {
              return event.sbpInvocation;
            } else {
              return event.fn;
            }
          })]));
        }
        return (_b = (_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.map((event) => {
          if (isEventQueueSbpEvent2(event)) {
            return event.sbpInvocation;
          } else {
            return event.fn;
          }
        })) !== null && _b !== void 0 ? _b : [];
      },
      "okTurtles.eventQueue/queueEvent": async function(name, invocation) {
        if (!Object.prototype.hasOwnProperty.call(this.eventQueues, name)) {
          this.eventQueues[name] = [];
        }
        const events = this.eventQueues[name];
        let accept;
        const promise = new Promise((resolve8) => {
          accept = resolve8;
        });
        const thisEvent = typeof invocation === "function" ? {
          fn: invocation,
          promise
        } : {
          sbpInvocation: invocation,
          promise
        };
        events.push(thisEvent);
        while (events.length > 0) {
          const event = events[0];
          if (event === thisEvent) {
            try {
              if (typeof invocation === "function") {
                return await invocation();
              } else {
                return await esm_default(...invocation);
              }
            } finally {
              accept();
              events.shift();
            }
          } else {
            await event.promise;
          }
        }
      }
    });
  }
});
var _store2;
var esm_default5;
var init_esm7 = __esm({
  "node_modules/.deno/@sbp+okturtles.data@0.1.6/node_modules/@sbp/okturtles.data/dist/esm/index.mjs"() {
    init_esm3();
    _store2 = /* @__PURE__ */ new Map();
    esm_default5 = esm_default("sbp/selectors/register", {
      "okTurtles.data/get": function(key) {
        return _store2.get(key);
      },
      "okTurtles.data/set": function(key, data) {
        _store2.set(key, data);
        return data;
      },
      "okTurtles.data/delete": function(key) {
        return _store2.delete(key);
      },
      "okTurtles.data/add": function(key, data) {
        const array2 = _store2.get(key);
        if (array2) {
          array2.push(data);
        } else {
          _store2.set(key, [data]);
        }
      },
      "okTurtles.data/remove": function(key, data) {
        const array2 = _store2.get(key);
        if (array2) {
          const aLen = array2.length;
          const filtered = array2.filter((v2) => v2 !== data);
          _store2.set(key, filtered);
          return aLen - filtered.length;
        }
      },
      "okTurtles.data/apply": function(key, fn) {
        return fn(_store2.get(key));
      }
    });
  }
});
var listenKey2;
var esm_default6;
var init_esm8 = __esm({
  "node_modules/.deno/@sbp+okturtles.events@1.0.1/node_modules/@sbp/okturtles.events/dist/esm/index.mjs"() {
    init_esm3();
    init_esm7();
    listenKey2 = (evt) => `events/${evt}/listeners`;
    esm_default6 = esm_default("sbp/selectors/register", {
      "okTurtles.events/_init": function() {
        this.errorHandler = (event, e2) => {
          console.error(`[okTurtles.events] Error at handler for ${event}`, e2);
        };
      },
      "okTurtles.events/on": function(event, handler) {
        esm_default("okTurtles.data/add", listenKey2(event), handler);
        return () => esm_default("okTurtles.events/off", event, handler);
      },
      "okTurtles.events/once": function(event, handler) {
        const cbWithOff = (...args) => {
          handler(...args);
          esm_default("okTurtles.events/off", event, cbWithOff);
        };
        return esm_default("okTurtles.events/on", event, cbWithOff);
      },
      "okTurtles.events/emit": function(event, ...data) {
        var _a2;
        for (const listener of esm_default("okTurtles.data/get", listenKey2(event)) || []) {
          try {
            listener(...data);
          } catch (e2) {
            (_a2 = this.errorHandler) === null || _a2 === void 0 ? void 0 : _a2.call(this, event, e2);
          }
        }
      },
      // almost identical to Vue.prototype.$off, except we require `event` argument
      "okTurtles.events/off": function(event, handler) {
        if (handler) {
          esm_default("okTurtles.data/remove", listenKey2(event), handler);
        } else {
          esm_default("okTurtles.data/delete", listenKey2(event));
        }
      },
      "okTurtles.events/setErrorHandler": function(errorHandler) {
        this.errorHandler = errorHandler;
      }
    });
  }
});
function pick2(o2, props) {
  const x3 = /* @__PURE__ */ Object.create(null);
  for (const k of props) {
    if (has(o2, k)) {
      x3[k] = o2[k];
    }
  }
  return x3;
}
function omit2(o2, props) {
  const x3 = /* @__PURE__ */ Object.create(null);
  for (const k in o2) {
    if (!props.includes(k)) {
      x3[k] = o2[k];
    }
  }
  return x3;
}
function cloneDeep(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function isMergeableObject(val) {
  const nonNullObject = val && typeof val === "object";
  return nonNullObject && Object.prototype.toString.call(val) !== "[object RegExp]" && Object.prototype.toString.call(val) !== "[object Date]";
}
function merge2(obj, src4) {
  const res = obj;
  for (const key in src4) {
    const clone2 = isMergeableObject(src4[key]) ? cloneDeep(src4[key]) : void 0;
    let x3;
    if (clone2 && has(obj, key) && isMergeableObject(x3 = res[key])) {
      merge2(x3, clone2);
      continue;
    }
    Object.defineProperty(res, key, {
      configurable: true,
      enumerable: true,
      value: clone2 || src4[key],
      writable: true
    });
  }
  return res;
}
function delay(msec) {
  return new Promise((resolve8) => {
    setTimeout(resolve8, msec);
  });
}
function randomBytes(length4) {
  return crypto.getRandomValues(new Uint8Array(length4));
}
function randomHexString(length4) {
  return Array.from(randomBytes(length4), (byte) => (byte % 16).toString(16)).join("");
}
function randomIntFromRange(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function uniq(array2) {
  return Array.from(new Set(array2));
}
function intersection2(a1, ...arrays) {
  return uniq(a1).filter((v1) => arrays.every((v2) => v2.indexOf(v1) >= 0));
}
function difference(a1, ...arrays) {
  const a2 = Array.prototype.concat.apply([], arrays);
  return a1.filter((v2) => a2.indexOf(v2) === -1);
}
function debounce(func, wait, immediate) {
  let timeout, args, context, timestamp, result;
  if (wait == null)
    wait = 100;
  function later() {
    const last = performance.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = void 0;
      if (!immediate) {
        result = func.apply(context, args);
        args = void 0;
        context = void 0;
      }
    }
  }
  const debounced = function(...args_) {
    args = args_;
    context = this;
    timestamp = performance.now();
    const callNow = immediate && !timeout;
    if (!timeout)
      timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      args = void 0;
      context = void 0;
    }
    return result;
  };
  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      args = void 0;
      context = void 0;
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debounced;
}
var has;
var init_esm9 = __esm({
  "node_modules/.deno/turtledash@1.0.3/node_modules/turtledash/dist/esm/index.js"() {
    has = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  }
});
async function createCIDfromStream(data, multicode = multicodes2.RAW) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = await blake2b256stream.digest(uint8array);
  return CID3.create(1, multicode, digest).toString(base58btc3);
}
function createCID2(data, multicode = multicodes2.RAW) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = blake2b2562.digest(uint8array);
  return CID3.create(1, multicode, digest).toString(base58btc3);
}
function blake32Hash2(data) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = blake2b2562.digest(uint8array);
  return base58btc3.encode(digest.bytes);
}
var multicodes2;
var parseCID;
var maybeParseCID;
var b64ToBuf2;
var b64ToStr;
var strToBuf2;
var strToB64;
var getSubscriptionId;
var init_functions = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/functions.mjs"() {
    init_base583();
    init_blake2b2();
    init_blake2bstream();
    init_cid3();
    multicodes2 = {
      RAW: 0,
      JSON: 512,
      SHELTER_CONTRACT_MANIFEST: 5316096,
      SHELTER_CONTRACT_TEXT: 5316097,
      SHELTER_CONTRACT_DATA: 5316098,
      SHELTER_FILE_MANIFEST: 5316099,
      SHELTER_FILE_CHUNK: 5316100
    };
    parseCID = (cid) => {
      if (!cid || cid.length < 52 || cid.length > 64) {
        throw new RangeError("CID length too short or too long");
      }
      const parsed = CID3.parse(cid, base58btc3);
      if (parsed.version !== 1 || parsed.multihash.code !== blake2b2562.code || !Object.values(multicodes2).includes(parsed.code)) {
        throw new Error("Invalid CID");
      }
      return parsed;
    };
    maybeParseCID = (cid) => {
      try {
        return parseCID(cid);
      } catch {
        return null;
      }
    };
    b64ToBuf2 = (b64) => Buffer22.from(b64, "base64");
    b64ToStr = (b64) => b64ToBuf2(b64).toString("utf8");
    strToBuf2 = (str) => Buffer22.from(str, "utf8");
    strToB64 = (str) => strToBuf2(str).toString("base64");
    getSubscriptionId = async (subscriptionInfo) => {
      const textEncoder = new TextEncoder();
      const endpoint = textEncoder.encode(subscriptionInfo.endpoint);
      const p256dh = textEncoder.encode(subscriptionInfo.keys.p256dh);
      const auth = textEncoder.encode(subscriptionInfo.keys.auth);
      const canonicalForm = new ArrayBuffer(8 + (4 + endpoint.byteLength) + (2 + p256dh.byteLength) + (2 + auth.byteLength));
      const canonicalFormU8 = new Uint8Array(canonicalForm);
      const canonicalFormDV = new DataView(canonicalForm);
      let offset = 0;
      canonicalFormDV.setFloat64(offset, subscriptionInfo.expirationTime == null ? NaN : subscriptionInfo.expirationTime, false);
      offset += 8;
      canonicalFormDV.setUint32(offset, endpoint.byteLength, false);
      offset += 4;
      canonicalFormU8.set(endpoint, offset);
      offset += endpoint.byteLength;
      canonicalFormDV.setUint16(offset, p256dh.byteLength, false);
      offset += 2;
      canonicalFormU8.set(p256dh, offset);
      offset += p256dh.byteLength;
      canonicalFormDV.setUint16(offset, auth.byteLength, false);
      offset += 2;
      canonicalFormU8.set(auth, offset);
      const digest = await crypto.subtle.digest("SHA-384", canonicalForm);
      const id = Buffer22.from(digest.slice(0, 16));
      id[6] = 128 | id[6] & 15;
      id[8] = 128 | id[8] & 63;
      return [id.slice(0, 4), id.slice(4, 6), id.slice(6, 8), id.slice(8, 10), id.slice(10, 16)].map((p) => p.toString("hex")).join("-");
    };
  }
});
function createClient(url, options3 = {}) {
  const client = {
    customEventHandlers: options3.handlers || {},
    // The current number of connection attempts that failed.
    // Reset to 0 upon successful connection.
    // Used to compute how long to wait before the next reconnection attempt.
    failedConnectionAttempts: 0,
    isLocal: /\/\/(localhost|127\.0\.0\.1)([:?/]|$)/.test(url),
    // True if this client has never been connected yet.
    isNew: true,
    listeners: /* @__PURE__ */ Object.create(null),
    messageHandlers: { ...defaultMessageHandlers, ...options3.messageHandlers },
    nextConnectionAttemptDelayID: void 0,
    options: { ...defaultOptions, ...options3 },
    // Requested subscriptions for which we didn't receive a response yet.
    pendingSubscriptionSet: /* @__PURE__ */ new Set(),
    pendingUnsubscriptionSet: /* @__PURE__ */ new Set(),
    pingTimeoutID: void 0,
    shouldReconnect: true,
    // The underlying WebSocket object.
    // A new one is necessary for every connection or reconnection attempt.
    socket: null,
    subscriptionSet: /* @__PURE__ */ new Set(),
    kvFilter: /* @__PURE__ */ new Map(),
    connectionTimeoutID: void 0,
    url: url.replace(/^http/, "ws"),
    ...publicMethods
  };
  for (const name of Object.keys(defaultClientEventHandlers)) {
    client.listeners[name] = (event) => {
      try {
        defaultClientEventHandlers[name].call(client, event);
        client.customEventHandlers[name]?.call(client, event);
      } catch (error) {
        esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, error?.message);
      }
    };
  }
  if (typeof self === "object" && self instanceof EventTarget) {
    for (const name of globalEventNames) {
      globalEventMap.set(name, client.listeners[name]);
    }
  }
  if (!client.options.manual) {
    client.connect();
  }
  return client;
}
function createMessage(type, data, meta) {
  const message = { ...meta, type, data };
  let string3;
  const stringify = function() {
    if (!string3)
      string3 = JSON.stringify(this);
    return string3;
  };
  Object.defineProperties(message, {
    [Symbol.toPrimitive]: {
      value: stringify
    }
  });
  return message;
}
function createKvMessage(channelID, key, data) {
  return JSON.stringify({ type: NOTIFICATION_TYPE.KV, channelID, key, data });
}
function createPubMessage(channelID, data) {
  return JSON.stringify({ type: NOTIFICATION_TYPE.PUB, channelID, data });
}
function createRequest(type, data) {
  return JSON.stringify(Object.assign({ type }, data));
}
var NOTIFICATION_TYPE;
var REQUEST_TYPE;
var RESPONSE_TYPE;
var PUSH_SERVER_ACTION_TYPE;
var defaultOptions;
var PUBSUB_ERROR;
var PUBSUB_RECONNECTION_ATTEMPT;
var PUBSUB_RECONNECTION_FAILED;
var PUBSUB_RECONNECTION_SCHEDULED;
var PUBSUB_RECONNECTION_SUCCEEDED;
var PUBSUB_SUBSCRIPTION_SUCCEEDED;
var defaultClientEventHandlers;
var defaultMessageHandlers;
var globalEventNames;
var socketEventNames;
var globalEventMap;
var isDefinetelyOffline;
var messageParser;
var publicMethods;
var init_pubsub = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/pubsub/index.mjs"() {
    init_esm8();
    init_esm3();
    NOTIFICATION_TYPE = Object.freeze({
      ENTRY: "entry",
      DELETION: "deletion",
      KV: "kv",
      KV_FILTER: "kv_filter",
      PING: "ping",
      PONG: "pong",
      PUB: "pub",
      SUB: "sub",
      UNSUB: "unsub",
      VERSION_INFO: "version_info"
    });
    REQUEST_TYPE = Object.freeze({
      PUB: "pub",
      SUB: "sub",
      UNSUB: "unsub",
      PUSH_ACTION: "push_action",
      KV_FILTER: "kv_filter"
    });
    RESPONSE_TYPE = Object.freeze({
      ERROR: "error",
      OK: "ok"
    });
    PUSH_SERVER_ACTION_TYPE = Object.freeze({
      SEND_PUBLIC_KEY: "send-public-key",
      STORE_SUBSCRIPTION: "store-subscription",
      DELETE_SUBSCRIPTION: "delete-subscription",
      SEND_PUSH_NOTIFICATION: "send-push-notification"
    });
    defaultOptions = {
      logPingMessages: !process.env.CI,
      pingTimeout: 45e3,
      maxReconnectionDelay: 6e4,
      maxRetries: 10,
      minReconnectionDelay: 500,
      reconnectOnDisconnection: true,
      reconnectOnOnline: true,
      // Defaults to false to avoid reconnection attempts in case the server doesn't
      // respond because of a failed authentication.
      reconnectOnTimeout: false,
      reconnectionDelayGrowFactor: 2,
      timeout: 6e4
    };
    PUBSUB_ERROR = "pubsub-error";
    PUBSUB_RECONNECTION_ATTEMPT = "pubsub-reconnection-attempt";
    PUBSUB_RECONNECTION_FAILED = "pubsub-reconnection-failed";
    PUBSUB_RECONNECTION_SCHEDULED = "pubsub-reconnection-scheduled";
    PUBSUB_RECONNECTION_SUCCEEDED = "pubsub-reconnection-succeeded";
    PUBSUB_SUBSCRIPTION_SUCCEEDED = "pubsub-subscription-succeeded";
    defaultClientEventHandlers = {
      // Emitted when the connection is closed.
      close(event) {
        const client = this;
        console.debug("[pubsub] Event: close", event.code, event.reason);
        client.failedConnectionAttempts++;
        if (client.socket) {
          for (const name of socketEventNames) {
            client.socket.removeEventListener(name, client.listeners[name]);
          }
        }
        client.socket = null;
        client.clearAllTimers();
        if (client.shouldReconnect) {
          client.subscriptionSet.forEach((channelID) => {
            if (!client.pendingUnsubscriptionSet.has(channelID)) {
              client.pendingSubscriptionSet.add(channelID);
            }
          });
        }
        client.subscriptionSet.clear();
        client.pendingUnsubscriptionSet.clear();
        if (client.shouldReconnect && client.options.reconnectOnDisconnection) {
          if (client.failedConnectionAttempts > client.options.maxRetries) {
            esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_FAILED, client);
          } else {
            if (!isDefinetelyOffline() || client.isLocal) {
              client.scheduleConnectionAttempt();
            }
          }
        }
      },
      // Emitted when an error has occured.
      // The socket will be closed automatically by the engine if necessary.
      error(event) {
        const client = this;
        console.warn("[pubsub] Event: error", event);
        clearTimeout(client.pingTimeoutID);
      },
      // Emitted when a message is received.
      // The connection will be terminated if the message is malformed or has an
      // unexpected data type (e.g. binary instead of text).
      message(event) {
        const client = this;
        const { data } = event;
        if (typeof data !== "string") {
          esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, {
            message: `Wrong data type: ${typeof data}`
          });
          return client.destroy();
        }
        let msg = { type: "" };
        try {
          msg = messageParser(data);
        } catch (error) {
          esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, {
            message: `Malformed message: ${error?.message}`
          });
          return client.destroy();
        }
        const handler = client.messageHandlers[msg.type];
        if (handler) {
          handler.call(client, msg);
        } else {
          throw new Error(`Unhandled message type: ${msg.type}`);
        }
      },
      offline() {
        console.info("[pubsub] Event: offline");
        const client = this;
        client.clearAllTimers();
        client.failedConnectionAttempts = 0;
        client.socket?.close();
      },
      online() {
        console.info("[pubsub] Event: online");
        const client = this;
        if (client.options.reconnectOnOnline && client.shouldReconnect) {
          if (!client.socket) {
            client.failedConnectionAttempts = 0;
            client.scheduleConnectionAttempt();
          }
        }
      },
      // Emitted when the connection is established.
      open() {
        console.debug("[pubsub] Event: open");
        const client = this;
        const { options: options3 } = this;
        client.connectionTimeUsed = void 0;
        client.clearAllTimers();
        esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_SUCCEEDED, client);
        client.failedConnectionAttempts = -1;
        client.isNew = false;
        if (options3.pingTimeout > 0 && options3.pingTimeout < Infinity) {
          client.pingTimeoutID = setTimeout(() => {
            client.socket?.close();
          }, options3.pingTimeout);
        }
        client.pendingSubscriptionSet.forEach((channelID) => {
          const kvFilter = this.kvFilter.get(channelID);
          client.socket?.send(createRequest(REQUEST_TYPE.SUB, kvFilter ? { channelID, kvFilter } : { channelID }));
        });
      },
      "reconnection-attempt"() {
        console.info("[pubsub] Trying to reconnect...");
      },
      "reconnection-succeeded"() {
        console.info("[pubsub] Connection re-established");
      },
      "reconnection-failed"() {
        console.warn("[pubsub] Reconnection failed");
        const client = this;
        client.destroy();
      },
      "reconnection-scheduled"(event) {
        const { delay: delay2, nth } = event.detail;
        console.info(`[pubsub] Scheduled connection attempt ${nth} in ~${delay2} ms`);
      },
      "subscription-succeeded"(event) {
        const { channelID } = event.detail;
        console.debug(`[pubsub] Subscribed to channel ${channelID}`);
      }
    };
    defaultMessageHandlers = {
      [NOTIFICATION_TYPE.ENTRY](msg) {
        console.debug("[pubsub] Received ENTRY:", msg);
      },
      [NOTIFICATION_TYPE.PING]({ data }) {
        const client = this;
        if (client.options.logPingMessages) {
          console.debug(`[pubsub] Ping received in ${Date.now() - Number(data)} ms`);
        }
        client.socket?.send(createMessage(NOTIFICATION_TYPE.PONG, data));
        clearTimeout(client.pingTimeoutID);
        client.pingTimeoutID = setTimeout(() => {
          client.socket?.close();
        }, client.options.pingTimeout);
      },
      [NOTIFICATION_TYPE.PUB]({ channelID, data }) {
        console.log(`[pubsub] Received data from channel ${channelID}:`, data);
      },
      [NOTIFICATION_TYPE.KV]({ channelID, key, data }) {
        console.log(`[pubsub] Received KV update from channel ${channelID} ${key}:`, data);
      },
      [NOTIFICATION_TYPE.SUB](msg) {
        console.debug(`[pubsub] Ignoring ${msg.type} message:`, msg.data);
      },
      [NOTIFICATION_TYPE.UNSUB](msg) {
        console.debug(`[pubsub] Ignoring ${msg.type} message:`, msg.data);
      },
      [RESPONSE_TYPE.ERROR]({ data }) {
        const { type, channelID, reason } = data;
        console.warn(`[pubsub] Received ERROR response for ${type} request to ${channelID}`);
        const client = this;
        switch (type) {
          case REQUEST_TYPE.SUB: {
            console.warn(`[pubsub] Could not subscribe to ${channelID}: ${reason}`);
            client.pendingSubscriptionSet.delete(channelID);
            break;
          }
          case REQUEST_TYPE.UNSUB: {
            console.warn(`[pubsub] Could not unsubscribe from ${channelID}: ${reason}`);
            client.pendingUnsubscriptionSet.delete(channelID);
            break;
          }
          case REQUEST_TYPE.PUSH_ACTION: {
            const { actionType, message } = data;
            console.warn(`[pubsub] Received ERROR for PUSH_ACTION request with the action type '${actionType}' and the following message: ${message}`);
            break;
          }
          default: {
            console.error(`[pubsub] Malformed response: invalid request type ${type}`);
          }
        }
      },
      [RESPONSE_TYPE.OK]({ data: { type, channelID } }) {
        const client = this;
        switch (type) {
          case REQUEST_TYPE.SUB: {
            client.pendingSubscriptionSet.delete(channelID);
            client.subscriptionSet.add(channelID);
            esm_default("okTurtles.events/emit", PUBSUB_SUBSCRIPTION_SUCCEEDED, client, { channelID });
            break;
          }
          case REQUEST_TYPE.UNSUB: {
            console.debug(`[pubsub] Unsubscribed from ${channelID}`);
            client.pendingUnsubscriptionSet.delete(channelID);
            client.subscriptionSet.delete(channelID);
            client.kvFilter.delete(channelID);
            break;
          }
          case REQUEST_TYPE.KV_FILTER: {
            console.debug(`[pubsub] Set KV filter for ${channelID}`);
            break;
          }
          default: {
            console.error(`[pubsub] Malformed response: invalid request type ${type}`);
          }
        }
      }
    };
    globalEventNames = ["offline", "online"];
    socketEventNames = ["close", "error", "message", "open"];
    globalEventMap = /* @__PURE__ */ new Map();
    if (typeof self === "object" && self instanceof EventTarget) {
      for (const name of globalEventNames) {
        const handler = (ev) => {
          const h2 = globalEventMap.get(name);
          return h2?.(ev);
        };
        self.addEventListener(name, handler, false);
      }
    }
    isDefinetelyOffline = () => typeof navigator === "object" && navigator.onLine === false;
    messageParser = (data) => {
      const msg = JSON.parse(data);
      if (typeof msg !== "object" || msg === null) {
        throw new TypeError("Message is null or not an object");
      }
      const { type } = msg;
      if (typeof type !== "string" || type === "") {
        throw new TypeError("Message type must be a non-empty string");
      }
      return msg;
    };
    publicMethods = {
      clearAllTimers() {
        const client = this;
        clearTimeout(client.connectionTimeoutID);
        clearTimeout(client.nextConnectionAttemptDelayID);
        clearTimeout(client.pingTimeoutID);
        client.connectionTimeoutID = void 0;
        client.nextConnectionAttemptDelayID = void 0;
        client.pingTimeoutID = void 0;
      },
      // Performs a connection or reconnection attempt.
      connect() {
        const client = this;
        if (client.socket !== null) {
          throw new Error("connect() can only be called if there is no current socket.");
        }
        if (client.nextConnectionAttemptDelayID) {
          throw new Error("connect() must not be called during a reconnection delay.");
        }
        if (!client.shouldReconnect) {
          throw new Error("connect() should no longer be called on this instance.");
        }
        client.socket = new WebSocket(client.url);
        client.socket.send = function(data) {
          const send = WebSocket.prototype.send.bind(this);
          if (typeof data === "object" && typeof data[Symbol.toPrimitive] === "function") {
            return send(data[Symbol.toPrimitive]());
          }
          return send(data);
        };
        if (client.options.timeout) {
          const start = performance.now();
          client.connectionTimeoutID = setTimeout(() => {
            client.connectionTimeoutID = void 0;
            if (client.options.reconnectOnTimeout) {
              client.connectionTimeUsed = performance.now() - start;
            }
            client.socket?.close(4e3, "timeout");
          }, client.options.timeout);
        }
        for (const name of socketEventNames) {
          client.socket.addEventListener(name, client.listeners[name]);
        }
      },
      /**
       * Immediately close the socket, stop listening for events and clear any cache.
       *
       * This method is used in unit tests.
       * - In particular, no 'close' event handler will be called.
       * - Any incoming or outgoing buffered data will be discarded.
       * - Any pending messages will be discarded.
       */
      destroy() {
        const client = this;
        client.clearAllTimers();
        client.pendingSubscriptionSet.clear();
        client.pendingUnsubscriptionSet.clear();
        client.subscriptionSet.clear();
        if (typeof self === "object" && self instanceof EventTarget) {
          for (const name of globalEventNames) {
            globalEventMap.delete(name);
          }
        }
        if (client.socket) {
          for (const name of socketEventNames) {
            client.socket.removeEventListener(name, client.listeners[name]);
          }
          client.socket.close();
        }
        client.listeners = /* @__PURE__ */ Object.create(null);
        client.socket = null;
        client.shouldReconnect = false;
      },
      getNextRandomDelay() {
        const client = this;
        const { maxReconnectionDelay, minReconnectionDelay, reconnectionDelayGrowFactor } = client.options;
        const minDelay = minReconnectionDelay * reconnectionDelayGrowFactor ** client.failedConnectionAttempts;
        const maxDelay = minDelay * reconnectionDelayGrowFactor;
        const connectionTimeUsed = client.connectionTimeUsed;
        client.connectionTimeUsed = void 0;
        return Math.min(
          // See issue #1943: Have the connection time used 'eat into' the
          // reconnection time used
          Math.max(minReconnectionDelay, connectionTimeUsed ? maxReconnectionDelay - connectionTimeUsed : maxReconnectionDelay),
          Math.round(minDelay + (0, Math.random)() * (maxDelay - minDelay))
        );
      },
      // Schedules a connection attempt to happen after a delay computed according to
      // a randomized exponential backoff algorithm variant.
      scheduleConnectionAttempt() {
        const client = this;
        if (!client.shouldReconnect) {
          throw new Error("Cannot call `scheduleConnectionAttempt()` when `shouldReconnect` is false.");
        }
        if (client.nextConnectionAttemptDelayID) {
          return console.warn("[pubsub] A reconnection attempt is already scheduled.");
        }
        const delay2 = client.getNextRandomDelay();
        const nth = client.failedConnectionAttempts + 1;
        client.nextConnectionAttemptDelayID = setTimeout(() => {
          esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_ATTEMPT, client);
          client.nextConnectionAttemptDelayID = void 0;
          client.connect();
        }, delay2);
        esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_SCHEDULED, client, { delay: delay2, nth });
      },
      // Can be used to send ephemeral messages outside of any contract log.
      // Does nothing if the socket is not in the OPEN state.
      pub(channelID, data) {
        if (this.socket?.readyState === WebSocket.OPEN) {
          this.socket.send(createPubMessage(channelID, data));
        }
      },
      /**
       * Sends a SUB request to the server as soon as possible.
       *
       * - The given channel ID will be cached until we get a relevant server
       * response, allowing us to resend the same request if necessary.
       * - Any identical UNSUB request that has not been sent yet will be cancelled.
       * - Calling this method again before the server has responded has no effect.
       * @param channelID - The ID of the channel whose updates we want to subscribe to.
       */
      sub(channelID) {
        const client = this;
        const { socket } = this;
        if (!client.pendingSubscriptionSet.has(channelID)) {
          client.pendingSubscriptionSet.add(channelID);
          client.pendingUnsubscriptionSet.delete(channelID);
          if (socket?.readyState === WebSocket.OPEN) {
            const kvFilter = client.kvFilter.get(channelID);
            socket.send(createRequest(REQUEST_TYPE.SUB, kvFilter ? { channelID, kvFilter } : { channelID }));
          }
        }
      },
      /**
       * Sends a KV_FILTER request to the server as soon as possible.
       */
      setKvFilter(channelID, kvFilter) {
        const client = this;
        const { socket } = this;
        if (kvFilter) {
          client.kvFilter.set(channelID, kvFilter);
        } else {
          client.kvFilter.delete(channelID);
        }
        if (client.subscriptionSet.has(channelID)) {
          if (socket?.readyState === WebSocket.OPEN) {
            socket.send(createRequest(REQUEST_TYPE.KV_FILTER, kvFilter ? { channelID, kvFilter } : { channelID }));
          }
        }
      },
      /**
       * Sends an UNSUB request to the server as soon as possible.
       *
       * - The given channel ID will be cached until we get a relevant server
       * response, allowing us to resend the same request if necessary.
       * - Any identical SUB request that has not been sent yet will be cancelled.
       * - Calling this method again before the server has responded has no effect.
       * @param channelID - The ID of the channel whose updates we want to unsubscribe from.
       */
      unsub(channelID) {
        const client = this;
        const { socket } = this;
        if (!client.pendingUnsubscriptionSet.has(channelID)) {
          client.pendingSubscriptionSet.delete(channelID);
          client.pendingUnsubscriptionSet.add(channelID);
          if (socket?.readyState === WebSocket.OPEN) {
            socket.send(createRequest(REQUEST_TYPE.UNSUB, { channelID }));
          }
        }
      }
    };
    for (const name of Object.keys(defaultClientEventHandlers)) {
      if (name === "error" || !socketEventNames.includes(name)) {
        esm_default("okTurtles.events/on", `pubsub-${name}`, (target, detail) => {
          const ev = new CustomEvent(name, { detail });
          target.listeners[name].call(target, ev);
        });
      }
    }
  }
});
var ChelErrorGenerator;
var ChelErrorWarning;
var ChelErrorAlreadyProcessed;
var ChelErrorDBBadPreviousHEAD;
var ChelErrorDBConnection;
var ChelErrorUnexpected;
var ChelErrorKeyAlreadyExists;
var ChelErrorUnrecoverable;
var ChelErrorForkedChain;
var ChelErrorDecryptionError;
var ChelErrorDecryptionKeyNotFound;
var ChelErrorSignatureError;
var ChelErrorSignatureKeyUnauthorized;
var ChelErrorSignatureKeyNotFound;
var ChelErrorFetchServerTimeFailed;
var ChelErrorUnexpectedHttpResponseCode;
var ChelErrorResourceGone;
var init_errors = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/errors.mjs"() {
    ChelErrorGenerator = (name, base4 = Error) => class extends base4 {
      constructor(...params) {
        super(...params);
        this.name = name;
        if (params[1]?.cause !== this.cause) {
          Object.defineProperty(this, "cause", {
            configurable: true,
            writable: true,
            value: params[1]?.cause
          });
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    ChelErrorWarning = ChelErrorGenerator("ChelErrorWarning");
    ChelErrorAlreadyProcessed = ChelErrorGenerator("ChelErrorAlreadyProcessed");
    ChelErrorDBBadPreviousHEAD = ChelErrorGenerator("ChelErrorDBBadPreviousHEAD");
    ChelErrorDBConnection = ChelErrorGenerator("ChelErrorDBConnection");
    ChelErrorUnexpected = ChelErrorGenerator("ChelErrorUnexpected");
    ChelErrorKeyAlreadyExists = ChelErrorGenerator("ChelErrorKeyAlreadyExists");
    ChelErrorUnrecoverable = ChelErrorGenerator("ChelErrorUnrecoverable");
    ChelErrorForkedChain = ChelErrorGenerator("ChelErrorForkedChain");
    ChelErrorDecryptionError = ChelErrorGenerator("ChelErrorDecryptionError");
    ChelErrorDecryptionKeyNotFound = ChelErrorGenerator("ChelErrorDecryptionKeyNotFound", ChelErrorDecryptionError);
    ChelErrorSignatureError = ChelErrorGenerator("ChelErrorSignatureError");
    ChelErrorSignatureKeyUnauthorized = ChelErrorGenerator("ChelErrorSignatureKeyUnauthorized", ChelErrorSignatureError);
    ChelErrorSignatureKeyNotFound = ChelErrorGenerator("ChelErrorSignatureKeyNotFound", ChelErrorSignatureError);
    ChelErrorFetchServerTimeFailed = ChelErrorGenerator("ChelErrorFetchServerTimeFailed");
    ChelErrorUnexpectedHttpResponseCode = ChelErrorGenerator("ChelErrorUnexpectedHttpResponseCode");
    ChelErrorResourceGone = ChelErrorGenerator("ChelErrorResourceGone", ChelErrorUnexpectedHttpResponseCode);
  }
});
var CHELONIA_RESET;
var CONTRACT_IS_SYNCING;
var CONTRACTS_MODIFIED;
var EVENT_HANDLED;
var EVENT_PUBLISHED;
var EVENT_PUBLISHING_ERROR;
var CONTRACT_REGISTERED;
var CONTRACT_IS_PENDING_KEY_REQUESTS;
var CONTRACT_HAS_RECEIVED_KEYS;
var PERSISTENT_ACTION_FAILURE;
var PERSISTENT_ACTION_SUCCESS;
var PERSISTENT_ACTION_TOTAL_FAILURE;
var init_events2 = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/events.mjs"() {
    CHELONIA_RESET = "chelonia-reset";
    CONTRACT_IS_SYNCING = "contract-is-syncing";
    CONTRACTS_MODIFIED = "contracts-modified";
    EVENT_HANDLED = "event-handled";
    EVENT_PUBLISHED = "event-published";
    EVENT_PUBLISHING_ERROR = "event-publishing-error";
    CONTRACT_REGISTERED = "contract-registered";
    CONTRACT_IS_PENDING_KEY_REQUESTS = "contract-is-pending-key-requests";
    CONTRACT_HAS_RECEIVED_KEYS = "contract-has-received-keys";
    PERSISTENT_ACTION_FAILURE = "persistent-action-failure";
    PERSISTENT_ACTION_SUCCESS = "persistent-action-success";
    PERSISTENT_ACTION_TOTAL_FAILURE = "persistent-action-total_failure";
  }
});
var serdesTagSymbol;
var serdesSerializeSymbol;
var serdesDeserializeSymbol;
var rawResult;
var serializer;
var deserializerTable;
var deserializer;
var init_esm10 = __esm({
  "node_modules/.deno/@chelonia+serdes@1.0.0/node_modules/@chelonia/serdes/dist/esm/index.js"() {
    serdesTagSymbol = Symbol("tag");
    serdesSerializeSymbol = Symbol("serialize");
    serdesDeserializeSymbol = Symbol("deserialize");
    rawResult = (rawResultSet, obj) => {
      rawResultSet.add(obj);
      return obj;
    };
    serializer = (data) => {
      const rawResultSet = /* @__PURE__ */ new WeakSet();
      const verbatim = [];
      const transferables = /* @__PURE__ */ new Set();
      const revokables = /* @__PURE__ */ new Set();
      const result = JSON.parse(JSON.stringify(data, (_key, value) => {
        if (value && typeof value === "object" && rawResultSet.has(value))
          return value;
        if (value === void 0)
          return rawResult(rawResultSet, ["_", "_"]);
        if (!value)
          return value;
        if (Array.isArray(value) && value[0] === "_")
          return rawResult(rawResultSet, ["_", "_", ...value]);
        if (value instanceof Map) {
          return rawResult(rawResultSet, ["_", "Map", Array.from(value.entries())]);
        }
        if (value instanceof Set) {
          return rawResult(rawResultSet, ["_", "Set", Array.from(value.values())]);
        }
        if (value instanceof Blob || value instanceof File) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        if (value instanceof Error) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          if (value.cause) {
            value.cause = serializer(value.cause).data;
          }
          return rawResult(rawResultSet, ["_", "_err", rawResult(rawResultSet, ["_", "_ref", pos]), value.name]);
        }
        if (value instanceof MessagePort || value instanceof ReadableStream || value instanceof WritableStream || value instanceof ArrayBuffer) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          transferables.add(value);
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        if (ArrayBuffer.isView(value)) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          transferables.add(value.buffer);
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        if (typeof value === "function") {
          const mc = new MessageChannel();
          mc.port1.onmessage = async (ev) => {
            try {
              try {
                const result2 = await value(...deserializer(ev.data[1]));
                const { data: data2, transferables: transferables2 } = serializer(result2);
                ev.data[0].postMessage([true, data2], transferables2);
              } catch (e2) {
                const { data: data2, transferables: transferables2 } = serializer(e2);
                ev.data[0].postMessage([false, data2], transferables2);
              }
            } catch (e2) {
              console.error("Async error on onmessage handler", e2);
            }
          };
          transferables.add(mc.port2);
          revokables.add(mc.port1);
          return rawResult(rawResultSet, ["_", "_fn", mc.port2]);
        }
        const proto3 = Object.getPrototypeOf(value);
        if (proto3?.constructor?.[serdesTagSymbol] && proto3.constructor[serdesSerializeSymbol]) {
          return rawResult(rawResultSet, ["_", "_custom", proto3.constructor[serdesTagSymbol], proto3.constructor[serdesSerializeSymbol](value)]);
        }
        return value;
      }), (_key, value) => {
        if (Array.isArray(value) && value[0] === "_" && value[1] === "_ref") {
          return verbatim[value[2]];
        }
        return value;
      });
      return {
        data: result,
        transferables: Array.from(transferables),
        revokables: Array.from(revokables)
      };
    };
    deserializerTable = /* @__PURE__ */ Object.create(null);
    deserializer = (data) => {
      const rawResultSet = /* @__PURE__ */ new WeakSet();
      const verbatim = [];
      return JSON.parse(JSON.stringify(data, (_key, value) => {
        if (value && typeof value === "object" && !rawResultSet.has(value) && !Array.isArray(value) && Object.getPrototypeOf(value) !== Object.prototype) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        return value;
      }), (_key, value) => {
        if (Array.isArray(value) && value[0] === "_") {
          switch (value[1]) {
            case "_":
              if (value.length >= 3) {
                return value.slice(2);
              } else {
                return;
              }
            // Map input (reconstruct Map)
            case "Map":
              return new Map(value[2]);
            // Set input (reconstruct Set)
            case "Set":
              return new Set(value[2]);
            // Custom object type (reconstruct if possible, otherwise throw an error)
            case "_custom":
              if (deserializerTable[value[2]]) {
                return deserializerTable[value[2]](value[3]);
              } else {
                throw new Error("Invalid or unknown tag: " + value[2]);
              }
            // These are literal values, return them
            case "_ref":
              return verbatim[value[2]];
            case "_err": {
              if (value[2].name !== value[3]) {
                value[2].name = value[3];
              }
              if (value[2].cause) {
                value[2].cause = deserializer(value[2].cause);
              }
              return value[2];
            }
            // These were functions converted to a MessagePort. Convert them on this
            // end back into functions using that port.
            case "_fn": {
              const mp = value[2];
              return (...args) => {
                return new Promise((resolve8, reject) => {
                  const mc = new MessageChannel();
                  const { data: data2, transferables } = serializer(args);
                  mc.port1.onmessage = (ev) => {
                    if (ev.data[0]) {
                      resolve8(deserializer(ev.data[1]));
                    } else {
                      reject(deserializer(ev.data[1]));
                    }
                  };
                  mp.postMessage([mc.port2, data2], [mc.port2, ...transferables]);
                });
              };
            }
          }
        }
        return value;
      });
    };
    deserializer.register = (ctor) => {
      if (typeof ctor === "function" && typeof ctor[serdesTagSymbol] === "string" && typeof ctor[serdesDeserializeSymbol] === "function") {
        deserializerTable[ctor[serdesTagSymbol]] = ctor[serdesDeserializeSymbol].bind(ctor);
      }
    };
  }
});
var rootStateFn;
var proto;
var wrapper;
var isSignedData;
var signData;
var verifySignatureData;
var signedOutgoingData;
var signedOutgoingDataWithRawKey;
var signedIncomingData;
var signedDataKeyId;
var isRawSignedData;
var rawSignedIncomingData;
var init_signedData = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/signedData.mjs"() {
    init_esm2();
    init_esm3();
    init_esm9();
    init_errors();
    init_functions();
    rootStateFn = () => esm_default("chelonia/rootState");
    proto = Object.create(null, {
      _isSignedData: {
        value: true
      }
    });
    wrapper = (o2) => {
      return Object.setPrototypeOf(o2, proto);
    };
    isSignedData = (o2) => {
      return !!o2 && !!Object.getPrototypeOf(o2)?._isSignedData;
    };
    signData = function(stateOrContractID, sKeyId, data, extraFields, additionalKeys, additionalData) {
      const state = typeof stateOrContractID === "string" ? rootStateFn()[stateOrContractID] : stateOrContractID;
      if (!additionalData) {
        throw new ChelErrorSignatureError("Signature additional data must be provided");
      }
      const designatedKey = state?._vm?.authorizedKeys?.[sKeyId];
      if (!designatedKey?.purpose.includes("sig")) {
        throw new ChelErrorSignatureKeyNotFound(`Signing key ID ${sKeyId} is missing or is missing signing purpose`);
      }
      if (designatedKey._notAfterHeight != null) {
        const name = state._vm.authorizedKeys[sKeyId].name;
        const newKeyId = Object.values(state._vm?.authorizedKeys).find((v2) => v2._notAfterHeight == null && v2.name === name && v2.purpose.includes("sig"))?.id;
        if (!newKeyId) {
          throw new ChelErrorSignatureKeyNotFound(`Signing key ID ${sKeyId} has been revoked and no new key exists by the same name (${name})`);
        }
        sKeyId = newKeyId;
      }
      const key = additionalKeys[sKeyId];
      if (!key) {
        throw new ChelErrorSignatureKeyNotFound(`Missing signing key ${sKeyId}`);
      }
      const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
      const serializedData = JSON.stringify(data, (_, v2) => {
        if (v2 && has(v2, "serialize") && typeof v2.serialize === "function") {
          if (v2.serialize.length === 1) {
            return v2.serialize(additionalData);
          } else {
            return v2.serialize();
          }
        }
        return v2;
      });
      const payloadToSign = blake32Hash2(`${blake32Hash2(additionalData)}${blake32Hash2(serializedData)}`);
      return {
        ...extraFields,
        _signedData: [serializedData, keyId(deserializedKey), sign(deserializedKey, payloadToSign)]
      };
    };
    verifySignatureData = function(state, height, data, additionalData) {
      if (!state) {
        throw new ChelErrorSignatureError("Missing contract state");
      }
      if (!isRawSignedData(data)) {
        throw new ChelErrorSignatureError("Invalid message format");
      }
      if (!Number.isSafeInteger(height) || height < 0) {
        throw new ChelErrorSignatureError(`Height ${height} is invalid or out of range`);
      }
      const [serializedMessage, sKeyId, signature] = data._signedData;
      const designatedKey = state._vm?.authorizedKeys?.[sKeyId];
      if (!designatedKey || height > designatedKey._notAfterHeight || height < designatedKey._notBeforeHeight || !designatedKey.purpose.includes("sig")) {
        if (process.env.CI) {
          console.error(`Key ${sKeyId} is unauthorized or expired for the current contract`, {
            designatedKey,
            height,
            state: JSON.parse(JSON.stringify(esm_default("state/vuex/state")))
          });
          Promise.reject(new ChelErrorSignatureKeyUnauthorized(`Key ${sKeyId} is unauthorized or expired for the current contract`));
        }
        throw new ChelErrorSignatureKeyUnauthorized(`Key ${sKeyId} is unauthorized or expired for the current contract`);
      }
      const deserializedKey = designatedKey.data;
      const payloadToSign = blake32Hash2(`${blake32Hash2(additionalData)}${blake32Hash2(serializedMessage)}`);
      try {
        verifySignature(deserializedKey, payloadToSign, signature);
        const message = JSON.parse(serializedMessage);
        return [sKeyId, message];
      } catch (e2) {
        throw new ChelErrorSignatureError(e2?.message || e2);
      }
    };
    signedOutgoingData = (stateOrContractID, sKeyId, data, additionalKeys) => {
      if (!stateOrContractID || data === void 0 || !sKeyId) {
        throw new TypeError("Invalid invocation");
      }
      if (!additionalKeys) {
        additionalKeys = rootStateFn().secretKeys;
      }
      const extraFields = /* @__PURE__ */ Object.create(null);
      const boundStringValueFn = signData.bind(null, stateOrContractID, sKeyId, data, extraFields, additionalKeys);
      const serializefn = (additionalData) => boundStringValueFn(additionalData || "");
      return wrapper({
        get signingKeyId() {
          return sKeyId;
        },
        get serialize() {
          return serializefn;
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        },
        get recreate() {
          return (data2) => signedOutgoingData(stateOrContractID, sKeyId, data2, additionalKeys);
        },
        get get() {
          return (k) => extraFields[k];
        },
        get set() {
          return (k, v2) => {
            extraFields[k] = v2;
          };
        }
      });
    };
    signedOutgoingDataWithRawKey = (key, data) => {
      const sKeyId = keyId(key);
      const state = {
        _vm: {
          authorizedKeys: {
            [sKeyId]: {
              purpose: ["sig"],
              data: serializeKey(key, false),
              _notBeforeHeight: 0,
              _notAfterHeight: void 0
            }
          }
        }
      };
      const extraFields = /* @__PURE__ */ Object.create(null);
      const boundStringValueFn = signData.bind(null, state, sKeyId, data, extraFields, {
        [sKeyId]: key
      });
      const serializefn = (additionalData) => boundStringValueFn(additionalData || "");
      return wrapper({
        get signingKeyId() {
          return sKeyId;
        },
        get serialize() {
          return serializefn;
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        },
        get recreate() {
          return (data2) => signedOutgoingDataWithRawKey(key, data2);
        },
        get get() {
          return (k) => extraFields[k];
        },
        get set() {
          return (k, v2) => {
            extraFields[k] = v2;
          };
        }
      });
    };
    signedIncomingData = (contractID, state, data, height, additionalData, mapperFn) => {
      const stringValueFn = () => data;
      let verifySignedValue;
      const verifySignedValueFn = () => {
        if (verifySignedValue) {
          return verifySignedValue[1];
        }
        verifySignedValue = verifySignatureData(state || rootStateFn()[contractID], height, data, additionalData);
        if (mapperFn)
          verifySignedValue[1] = mapperFn(verifySignedValue[1]);
        return verifySignedValue[1];
      };
      return wrapper({
        get signingKeyId() {
          if (verifySignedValue)
            return verifySignedValue[0];
          return signedDataKeyId(data);
        },
        get serialize() {
          return stringValueFn;
        },
        get context() {
          return [contractID, data, height, additionalData];
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return verifySignedValueFn;
        },
        get toJSON() {
          return this.serialize;
        },
        get get() {
          return (k) => k !== "_signedData" ? data[k] : void 0;
        }
      });
    };
    signedDataKeyId = (data) => {
      if (!isRawSignedData(data)) {
        throw new ChelErrorSignatureError("Invalid message format");
      }
      return data._signedData[1];
    };
    isRawSignedData = (data) => {
      if (!data || typeof data !== "object" || !has(data, "_signedData") || !Array.isArray(data._signedData) || data._signedData.length !== 3 || data._signedData.map((v2) => typeof v2).filter((v2) => v2 !== "string").length !== 0) {
        return false;
      }
      return true;
    };
    rawSignedIncomingData = (data) => {
      if (!isRawSignedData(data)) {
        throw new ChelErrorSignatureError("Invalid message format");
      }
      const stringValueFn = () => data;
      let verifySignedValue;
      const verifySignedValueFn = () => {
        if (verifySignedValue) {
          return verifySignedValue[1];
        }
        verifySignedValue = [data._signedData[1], JSON.parse(data._signedData[0])];
        return verifySignedValue[1];
      };
      return wrapper({
        get signingKeyId() {
          if (verifySignedValue)
            return verifySignedValue[0];
          return signedDataKeyId(data);
        },
        get serialize() {
          return stringValueFn;
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return verifySignedValueFn;
        },
        get toJSON() {
          return this.serialize;
        },
        get get() {
          return (k) => k !== "_signedData" ? data[k] : void 0;
        }
      });
    };
  }
});
var rootStateFn2;
var proto2;
var wrapper2;
var isEncryptedData;
var encryptData;
var decryptData;
var encryptedOutgoingData;
var encryptedOutgoingDataWithRawKey;
var encryptedIncomingData;
var encryptedIncomingForeignData;
var encryptedDataKeyId;
var isRawEncryptedData;
var unwrapMaybeEncryptedData;
var maybeEncryptedIncomingData;
var init_encryptedData = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/encryptedData.mjs"() {
    init_esm2();
    init_esm3();
    init_esm9();
    init_errors();
    init_signedData();
    rootStateFn2 = () => esm_default("chelonia/rootState");
    proto2 = Object.create(null, {
      _isEncryptedData: {
        value: true
      }
    });
    wrapper2 = (o2) => {
      return Object.setPrototypeOf(o2, proto2);
    };
    isEncryptedData = (o2) => {
      return !!o2 && !!Object.getPrototypeOf(o2)?._isEncryptedData;
    };
    encryptData = function(stateOrContractID, eKeyId, data, additionalData) {
      const state = typeof stateOrContractID === "string" ? rootStateFn2()[stateOrContractID] : stateOrContractID;
      const designatedKey = state?._vm?.authorizedKeys?.[eKeyId];
      if (!designatedKey?.purpose.includes("enc")) {
        throw new Error(`Encryption key ID ${eKeyId} is missing or is missing encryption purpose`);
      }
      if (designatedKey._notAfterHeight != null) {
        const name = state._vm.authorizedKeys[eKeyId].name;
        const newKeyId = Object.values(state._vm?.authorizedKeys).find((v2) => v2._notAfterHeight == null && v2.name === name && v2.purpose.includes("enc"))?.id;
        if (!newKeyId) {
          throw new Error(`Encryption key ID ${eKeyId} has been revoked and no new key exists by the same name (${name})`);
        }
        eKeyId = newKeyId;
      }
      const key = state._vm?.authorizedKeys?.[eKeyId].data;
      if (!key) {
        throw new Error(`Missing encryption key ${eKeyId}`);
      }
      const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
      return [
        keyId(deserializedKey),
        encrypt(deserializedKey, JSON.stringify(data, (_, v2) => {
          if (v2 && has(v2, "serialize") && typeof v2.serialize === "function") {
            if (v2.serialize.length === 1) {
              return v2.serialize(additionalData);
            } else {
              return v2.serialize();
            }
          }
          return v2;
        }), additionalData)
      ];
    };
    decryptData = function(state, height, data, additionalKeys, additionalData, validatorFn) {
      if (!state) {
        throw new ChelErrorDecryptionError("Missing contract state");
      }
      if (typeof data.valueOf === "function")
        data = data.valueOf();
      if (!isRawEncryptedData(data)) {
        throw new ChelErrorDecryptionError("Invalid message format");
      }
      const [eKeyId, message] = data;
      const key = additionalKeys[eKeyId];
      if (!key) {
        throw new ChelErrorDecryptionKeyNotFound(`Key ${eKeyId} not found`, { cause: eKeyId });
      }
      const designatedKey = state._vm?.authorizedKeys?.[eKeyId];
      if (!designatedKey || height > designatedKey._notAfterHeight || height < designatedKey._notBeforeHeight || !designatedKey.purpose.includes("enc")) {
        throw new ChelErrorUnexpected(`Key ${eKeyId} is unauthorized or expired for the current contract`);
      }
      const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
      try {
        const result = JSON.parse(decrypt(deserializedKey, message, additionalData));
        if (typeof validatorFn === "function")
          validatorFn(result, eKeyId);
        return result;
      } catch (e2) {
        throw new ChelErrorDecryptionError(e2?.message || e2);
      }
    };
    encryptedOutgoingData = (stateOrContractID, eKeyId, data) => {
      if (!stateOrContractID || data === void 0 || !eKeyId) {
        throw new TypeError("Invalid invocation");
      }
      const boundStringValueFn = encryptData.bind(null, stateOrContractID, eKeyId, data);
      return wrapper2({
        get encryptionKeyId() {
          return eKeyId;
        },
        get serialize() {
          return (additionalData) => boundStringValueFn(additionalData || "");
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        }
      });
    };
    encryptedOutgoingDataWithRawKey = (key, data) => {
      if (data === void 0 || !key)
        throw new TypeError("Invalid invocation");
      const eKeyId = keyId(key);
      const state = {
        _vm: {
          authorizedKeys: {
            [eKeyId]: {
              purpose: ["enc"],
              data: serializeKey(key, false),
              _notBeforeHeight: 0,
              _notAfterHeight: void 0
            }
          }
        }
      };
      const boundStringValueFn = encryptData.bind(null, state, eKeyId, data);
      return wrapper2({
        get encryptionKeyId() {
          return eKeyId;
        },
        get serialize() {
          return (additionalData) => boundStringValueFn(additionalData || "");
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        }
      });
    };
    encryptedIncomingData = (contractID, state, data, height, additionalKeys, additionalData, validatorFn) => {
      let decryptedValue;
      const decryptedValueFn = () => {
        if (decryptedValue) {
          return decryptedValue;
        }
        if (!state || !additionalKeys) {
          const rootState = rootStateFn2();
          state = state || rootState[contractID];
          additionalKeys = additionalKeys ?? rootState.secretKeys;
        }
        decryptedValue = decryptData(state, height, data, additionalKeys, additionalData || "", validatorFn);
        if (isRawSignedData(decryptedValue)) {
          decryptedValue = signedIncomingData(contractID, state, decryptedValue, height, additionalData || "");
        }
        return decryptedValue;
      };
      return wrapper2({
        get encryptionKeyId() {
          return encryptedDataKeyId(data);
        },
        get serialize() {
          return () => data;
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return decryptedValueFn;
        },
        get toJSON() {
          return this.serialize;
        }
      });
    };
    encryptedIncomingForeignData = (contractID, _0, data, _1, additionalKeys, additionalData, validatorFn) => {
      let decryptedValue;
      const decryptedValueFn = () => {
        if (decryptedValue) {
          return decryptedValue;
        }
        const rootState = rootStateFn2();
        const state = rootState[contractID];
        decryptedValue = decryptData(state, NaN, data, additionalKeys ?? rootState.secretKeys, additionalData || "", validatorFn);
        if (isRawSignedData(decryptedValue)) {
          return signedIncomingData(contractID, state, decryptedValue, NaN, additionalData || "");
        }
        return decryptedValue;
      };
      return wrapper2({
        get encryptionKeyId() {
          return encryptedDataKeyId(data);
        },
        get serialize() {
          return () => data;
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return decryptedValueFn;
        },
        get toJSON() {
          return this.serialize;
        }
      });
    };
    encryptedDataKeyId = (data) => {
      if (!isRawEncryptedData(data)) {
        throw new ChelErrorDecryptionError("Invalid message format");
      }
      return data[0];
    };
    isRawEncryptedData = (data) => {
      if (!Array.isArray(data) || data.length !== 2 || data.map((v2) => typeof v2).filter((v2) => v2 !== "string").length !== 0) {
        return false;
      }
      return true;
    };
    unwrapMaybeEncryptedData = (data) => {
      if (data == null)
        return;
      if (isEncryptedData(data)) {
        try {
          return {
            encryptionKeyId: data.encryptionKeyId,
            data: data.valueOf()
          };
        } catch (e2) {
          console.warn("unwrapMaybeEncryptedData: Unable to decrypt", e2);
        }
      } else {
        return {
          encryptionKeyId: null,
          data
        };
      }
    };
    maybeEncryptedIncomingData = (contractID, state, data, height, additionalKeys, additionalData, validatorFn) => {
      if (isRawEncryptedData(data)) {
        return encryptedIncomingData(contractID, state, data, height, additionalKeys, additionalData, validatorFn);
      } else {
        validatorFn?.(data, "");
        return data;
      }
    };
  }
});
function messageToParams(head, message) {
  let mapping;
  return {
    direction: has(message, "recreate") ? "outgoing" : "incoming",
    // Lazy computation of mapping to prevent us from serializing outgoing
    // atomic operations
    get mapping() {
      if (!mapping) {
        const headJSON = JSON.stringify(head);
        const messageJSON = { ...message.serialize(headJSON), head: headJSON };
        const value = JSON.stringify(messageJSON);
        mapping = {
          key: createCID2(value, multicodes2.SHELTER_CONTRACT_DATA),
          value
        };
      }
      return mapping;
    },
    head,
    signedMessageData: message
  };
}
var decryptedAndVerifiedDeserializedMessage;
var SPMessage;
var keyOps;
var init_SPMessage = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/SPMessage.mjs"() {
    init_esm2();
    init_esm10();
    init_esm9();
    init_encryptedData();
    init_functions();
    init_signedData();
    decryptedAndVerifiedDeserializedMessage = (head, headJSON, contractID, parsedMessage, additionalKeys, state) => {
      const op = head.op;
      const height = head.height;
      const message = op === SPMessage.OP_ACTION_ENCRYPTED ? encryptedIncomingData(contractID, state, parsedMessage, height, additionalKeys, headJSON, void 0) : parsedMessage;
      if ([SPMessage.OP_KEY_ADD, SPMessage.OP_KEY_UPDATE].includes(op)) {
        return message.map((key) => {
          return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, (key2) => {
            if (key2.meta?.private?.content) {
              key2.meta.private.content = encryptedIncomingData(contractID, state, key2.meta.private.content, height, additionalKeys, headJSON, (value) => {
                const computedKeyId = keyId(value);
                if (computedKeyId !== key2.id) {
                  throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key2.id} but got ${computedKeyId}`);
                }
              });
            }
            if (key2.meta?.keyRequest?.reference) {
              try {
                key2.meta.keyRequest.reference = maybeEncryptedIncomingData(contractID, state, key2.meta.keyRequest.reference, height, additionalKeys, headJSON)?.valueOf();
              } catch {
                delete key2.meta.keyRequest.reference;
              }
            }
            if (key2.meta?.keyRequest?.contractID) {
              try {
                key2.meta.keyRequest.contractID = maybeEncryptedIncomingData(contractID, state, key2.meta.keyRequest.contractID, height, additionalKeys, headJSON)?.valueOf();
              } catch {
                delete key2.meta.keyRequest.contractID;
              }
            }
          });
        });
      }
      if (op === SPMessage.OP_CONTRACT) {
        message.keys = message.keys?.map((key) => {
          return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, (key2) => {
            if (!key2.meta?.private?.content)
              return;
            const decryptionFn = encryptedIncomingData;
            const decryptionContract = contractID;
            key2.meta.private.content = decryptionFn(decryptionContract, state, key2.meta.private.content, height, additionalKeys, headJSON, (value) => {
              const computedKeyId = keyId(value);
              if (computedKeyId !== key2.id) {
                throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key2.id} but got ${computedKeyId}`);
              }
            });
          });
        });
      }
      if (op === SPMessage.OP_KEY_SHARE) {
        return maybeEncryptedIncomingData(contractID, state, message, height, additionalKeys, headJSON, (message2) => {
          message2.keys?.forEach((key) => {
            if (!key.meta?.private?.content)
              return;
            const decryptionFn = message2.foreignContractID ? encryptedIncomingForeignData : encryptedIncomingData;
            const decryptionContract = message2.foreignContractID || contractID;
            key.meta.private.content = decryptionFn(decryptionContract, state, key.meta.private.content, height, additionalKeys, headJSON, (value) => {
              const computedKeyId = keyId(value);
              if (computedKeyId !== key.id) {
                throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key.id} but got ${computedKeyId}`);
              }
            });
          });
        });
      }
      if (op === SPMessage.OP_KEY_REQUEST) {
        return maybeEncryptedIncomingData(contractID, state, message, height, additionalKeys, headJSON, (msg) => {
          msg.replyWith = signedIncomingData(msg.contractID, void 0, msg.replyWith, msg.height, headJSON);
        });
      }
      if (op === SPMessage.OP_ACTION_UNENCRYPTED && isRawSignedData(message)) {
        return signedIncomingData(contractID, state, message, height, headJSON);
      }
      if (op === SPMessage.OP_ACTION_ENCRYPTED) {
        return message;
      }
      if (op === SPMessage.OP_KEY_DEL) {
        return message.map((key) => {
          return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, void 0);
        });
      }
      if (op === SPMessage.OP_KEY_REQUEST_SEEN) {
        return maybeEncryptedIncomingData(contractID, state, parsedMessage, height, additionalKeys, headJSON, void 0);
      }
      if (op === SPMessage.OP_ATOMIC) {
        return message.map(([opT, opV]) => [
          opT,
          decryptedAndVerifiedDeserializedMessage({ ...head, op: opT }, headJSON, contractID, opV, additionalKeys, state)
        ]);
      }
      return message;
    };
    SPMessage = class _SPMessage {
      // flow type annotations to make flow happy
      _mapping;
      _head;
      _message;
      _signedMessageData;
      _direction;
      _decryptedValue;
      _innerSigningKeyId;
      static OP_CONTRACT = "c";
      static OP_ACTION_ENCRYPTED = "ae";
      // e2e-encrypted action
      static OP_ACTION_UNENCRYPTED = "au";
      // publicly readable action
      static OP_KEY_ADD = "ka";
      // add this key to the list of keys allowed to write to this contract, or update an existing key
      static OP_KEY_DEL = "kd";
      // remove this key from authorized keys
      static OP_KEY_UPDATE = "ku";
      // update key in authorized keys
      static OP_PROTOCOL_UPGRADE = "pu";
      static OP_PROP_SET = "ps";
      // set a public key/value pair
      static OP_PROP_DEL = "pd";
      // delete a public key/value pair
      static OP_CONTRACT_AUTH = "ca";
      // authorize a contract
      static OP_CONTRACT_DEAUTH = "cd";
      // deauthorize a contract
      static OP_ATOMIC = "a";
      // atomic op
      static OP_KEY_SHARE = "ks";
      // key share
      static OP_KEY_REQUEST = "kr";
      // key request
      static OP_KEY_REQUEST_SEEN = "krs";
      // key request response
      // eslint-disable-next-line camelcase
      static createV1_0({
        contractID,
        previousHEAD = null,
        previousKeyOp = null,
        // Height will be automatically set to the correct value when sending
        // The reason to set it to Number.MAX_SAFE_INTEGER is so that we can
        // temporarily process outgoing messages with signature validation
        // still working
        height = Number.MAX_SAFE_INTEGER,
        op,
        manifest: manifest2
      }) {
        const head = {
          version: "1.0.0",
          previousHEAD,
          previousKeyOp,
          height,
          contractID,
          op: op[0],
          manifest: manifest2
        };
        return new this(messageToParams(head, op[1]));
      }
      // SPMessage.cloneWith could be used when make a SPMessage object having the same id()
      // https://github.com/okTurtles/group-income/issues/1503
      static cloneWith(targetHead, targetOp, sources) {
        const head = Object.assign({}, targetHead, sources);
        return new this(messageToParams(head, targetOp[1]));
      }
      static deserialize(value, additionalKeys, state, unwrapMaybeEncryptedDataFn = unwrapMaybeEncryptedData) {
        if (!value)
          throw new Error(`deserialize bad value: ${value}`);
        const { head: headJSON, ...parsedValue } = JSON.parse(value);
        const head = JSON.parse(headJSON);
        const contractID = head.op === _SPMessage.OP_CONTRACT ? createCID2(value, multicodes2.SHELTER_CONTRACT_DATA) : head.contractID;
        if (!state?._vm?.authorizedKeys && head.op === _SPMessage.OP_CONTRACT) {
          const value2 = rawSignedIncomingData(parsedValue);
          const authorizedKeys = Object.fromEntries(value2.valueOf()?.keys.map((wk) => {
            const k = unwrapMaybeEncryptedDataFn(wk);
            if (!k)
              return null;
            return [k.data.id, k.data];
          }).filter(Boolean));
          state = {
            _vm: {
              type: head.type,
              authorizedKeys
            }
          };
        }
        const signedMessageData = signedIncomingData(contractID, state, parsedValue, head.height, headJSON, (message) => decryptedAndVerifiedDeserializedMessage(head, headJSON, contractID, message, additionalKeys, state));
        return new this({
          direction: "incoming",
          mapping: { key: createCID2(value, multicodes2.SHELTER_CONTRACT_DATA), value },
          head,
          signedMessageData
        });
      }
      static deserializeHEAD(value) {
        if (!value)
          throw new Error(`deserialize bad value: ${value}`);
        let head, hash32;
        const result = {
          get head() {
            if (head === void 0) {
              head = JSON.parse(JSON.parse(value).head);
            }
            return head;
          },
          get hash() {
            if (!hash32) {
              hash32 = createCID2(value, multicodes2.SHELTER_CONTRACT_DATA);
            }
            return hash32;
          },
          get contractID() {
            return result.head?.contractID ?? result.hash;
          },
          // `description` is not a getter to prevent the value from being copied
          // if the object is cloned or serialized
          description() {
            const type = this.head.op;
            return `<op_${type}|${this.hash} of ${this.contractID}>`;
          },
          get isFirstMessage() {
            return !result.head?.contractID;
          }
        };
        return result;
      }
      constructor(params) {
        this._direction = params.direction;
        this._mapping = params.mapping;
        this._head = params.head;
        this._signedMessageData = params.signedMessageData;
        const type = this.opType();
        let atomicTopLevel = true;
        const validate = (type2, message) => {
          switch (type2) {
            case _SPMessage.OP_CONTRACT:
              if (!this.isFirstMessage() || !atomicTopLevel) {
                throw new Error("OP_CONTRACT: must be first message");
              }
              break;
            case _SPMessage.OP_ATOMIC:
              if (!atomicTopLevel) {
                throw new Error("OP_ATOMIC not allowed inside of OP_ATOMIC");
              }
              if (!Array.isArray(message)) {
                throw new TypeError("OP_ATOMIC must be of an array type");
              }
              atomicTopLevel = false;
              message.forEach(([t, m3]) => validate(t, m3));
              break;
            case _SPMessage.OP_KEY_ADD:
            case _SPMessage.OP_KEY_DEL:
            case _SPMessage.OP_KEY_UPDATE:
              if (!Array.isArray(message)) {
                throw new TypeError("OP_KEY_{ADD|DEL|UPDATE} must be of an array type");
              }
              break;
            case _SPMessage.OP_KEY_SHARE:
            case _SPMessage.OP_KEY_REQUEST:
            case _SPMessage.OP_KEY_REQUEST_SEEN:
            case _SPMessage.OP_ACTION_ENCRYPTED:
            case _SPMessage.OP_ACTION_UNENCRYPTED:
              break;
            default:
              throw new Error(`unsupported op: ${type2}`);
          }
        };
        Object.defineProperty(this, "_message", {
          get: /* @__PURE__ */ ((validated) => () => {
            const message = this._signedMessageData.valueOf();
            if (!validated) {
              validate(type, message);
              validated = true;
            }
            return message;
          })()
        });
      }
      decryptedValue() {
        if (this._decryptedValue)
          return this._decryptedValue;
        try {
          const value = this.message();
          const data = unwrapMaybeEncryptedData(value);
          if (data?.data) {
            if (isSignedData(data.data)) {
              this._innerSigningKeyId = data.data.signingKeyId;
              this._decryptedValue = data.data.valueOf();
            } else {
              this._decryptedValue = data.data;
            }
          }
          return this._decryptedValue;
        } catch {
          return void 0;
        }
      }
      innerSigningKeyId() {
        if (!this._decryptedValue) {
          this.decryptedValue();
        }
        return this._innerSigningKeyId;
      }
      head() {
        return this._head;
      }
      message() {
        return this._message;
      }
      op() {
        return [this.head().op, this.message()];
      }
      rawOp() {
        return [this.head().op, this._signedMessageData];
      }
      opType() {
        return this.head().op;
      }
      opValue() {
        return this.message();
      }
      signingKeyId() {
        return this._signedMessageData.signingKeyId;
      }
      manifest() {
        return this.head().manifest;
      }
      description() {
        const type = this.opType();
        let desc = `<op_${type}`;
        if (type === _SPMessage.OP_ACTION_UNENCRYPTED) {
          try {
            const value = this.opValue().valueOf();
            if (typeof value.action === "string") {
              desc += `|${value.action}`;
            }
          } catch (e2) {
            console.warn("Error on .description()", this.hash(), e2);
          }
        }
        return `${desc}|${this.hash()} of ${this.contractID()}>`;
      }
      isFirstMessage() {
        return !this.head().contractID;
      }
      contractID() {
        return this.head().contractID || this.hash();
      }
      serialize() {
        return this._mapping.value;
      }
      hash() {
        return this._mapping.key;
      }
      previousKeyOp() {
        return this._head.previousKeyOp;
      }
      height() {
        return this._head.height;
      }
      id() {
        throw new Error("SPMessage.id() was called but it has been removed");
      }
      direction() {
        return this._direction;
      }
      // `isKeyOp` is used to filter out non-key operations for providing an
      // abbreviated chain fo snapshot validation
      isKeyOp() {
        let value;
        return !!(keyOps.includes(this.opType()) || this.opType() === _SPMessage.OP_ATOMIC && Array.isArray(value = this.opValue()) && value.some(([opT]) => {
          return keyOps.includes(opT);
        }));
      }
      static get [serdesTagSymbol]() {
        return "SPMessage";
      }
      static [serdesSerializeSymbol](m3) {
        return [m3.serialize(), m3.direction(), m3.decryptedValue(), m3.innerSigningKeyId()];
      }
      static [serdesDeserializeSymbol]([serialized, direction, decryptedValue, innerSigningKeyId]) {
        const m3 = _SPMessage.deserialize(serialized);
        m3._direction = direction;
        m3._decryptedValue = decryptedValue;
        m3._innerSigningKeyId = innerSigningKeyId;
        return m3;
      }
    };
    keyOps = [
      SPMessage.OP_CONTRACT,
      SPMessage.OP_KEY_ADD,
      SPMessage.OP_KEY_DEL,
      SPMessage.OP_KEY_UPDATE
    ];
  }
});
var chelonia_utils_default;
var init_chelonia_utils = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/chelonia-utils.mjs"() {
    init_esm3();
    chelonia_utils_default = esm_default("sbp/selectors/register", {
      // This selector is a wrapper for the `chelonia/kv/set` selector that uses
      // the contract queue and allows referring to keys by name, with default key
      // names set to `csk` and `cek` for signatures and encryption, respectively.
      // For most 'simple' use cases, this selector is a better choice than
      // `chelonia/kv/set`. However, the `chelonia/kv/set` primitive is needed if
      // the queueing logic needs to be more advanced, the key to use requires
      // custom logic or _if the `onconflict` callback also needs to be queued_.
      "chelonia/kv/queuedSet": ({ contractID, key, data, onconflict, ifMatch, encryptionKeyName = "cek", signingKeyName = "csk" }) => {
        return esm_default("chelonia/queueInvocation", contractID, () => {
          return esm_default("chelonia/kv/set", contractID, key, data, {
            ifMatch,
            encryptionKeyId: esm_default("chelonia/contract/currentKeyIdByName", contractID, encryptionKeyName),
            signingKeyId: esm_default("chelonia/contract/currentKeyIdByName", contractID, signingKeyName),
            onconflict
          });
        });
      }
    });
  }
});
async function* g(a, s, r) {
  let d = new TextEncoder(), y = d.encode(`\r
--${a}`);
  if (Array.isArray(s) && s.length < 1) {
    await r.abort(Error("At least one part is required"));
    return;
  }
  let l = 0;
  for await (let e2 of s) {
    l++;
    let n, t;
    if (!e2.body && e2.parts) if (t = e2.headers.get("content-type"), !t) n = A(), t = `multipart/mixed; boundary="${n}"`;
    else if (!t.startsWith("multipart/") || !T.test(t)) {
      await r.abort(Error("Invalid multipart content type: " + t));
      return;
    } else {
      let o2 = t.match(m);
      (!o2 || !(n = o2[1] || o2[2])) && (n = A(), t = t.replace(T, `; boundary="${n}"`));
    }
    await u(y).pipeTo(r, i), yield;
    {
      let o2 = [""];
      if (t) {
        let p = false;
        e2.headers.forEach((f, c) => {
          c !== "content-type" ? o2.push(`${c}: ${f}`) : (p = true, o2.push(`${c}: ${t}`));
        }), p || o2.push(`content-type: ${t}`);
      } else e2.headers.forEach((p, f) => {
        o2.push(`${f}: ${p}`);
      });
      e2.parts || !e2.body ? o2.push("") : o2.push("", "");
      let B4 = d.encode(o2.join(`\r
`));
      o2.length = 0, await u(B4).pipeTo(r, i), yield;
    }
    if (e2.body) {
      if (e2.body instanceof ArrayBuffer || ArrayBuffer.isView(e2.body)) await u(e2.body).pipeTo(r, i);
      else if (e2.body instanceof Blob) await e2.body.stream().pipeTo(r, i);
      else if (e2.body instanceof ReadableStream) await e2.body.pipeTo(r, i);
      else {
        await r.abort(Error("Invalid body type"));
        return;
      }
      yield;
    } else if (e2.parts) {
      if (!n) {
        await r.abort(Error("Runtime exception: undefined part boundary"));
        return;
      }
      yield* g(n, e2.parts, r), yield;
    }
  }
  if (!l) {
    await r.abort(Error("At least one part is required"));
    return;
  }
  let b = d.encode(`\r
--${a}--`);
  await u(b).pipeTo(r, i);
}
var m;
var M;
var u;
var T;
var h;
var A;
var i;
var w;
var x;
var init_encodeMultipartMessage = __esm({
  "node_modules/.deno/@apeleghq+multipart-parser@1.0.18/node_modules/@apeleghq/multipart-parser/dist/encodeMultipartMessage.mjs"() {
    m = /;\s*boundary=(?:"([0-9a-zA-Z'()+_,\-./:=? ]{0,69}[0-9a-zA-Z'()+_,\-./:=?])"|([0-9a-zA-Z'+_\-.]{0,69}[0-9a-zA-Z'+_\-.]))/;
    M = (a) => new ReadableStream({ pull(r) {
      if (ArrayBuffer.isView(a)) r.enqueue(a.buffer.slice(a.byteOffset, a.byteOffset + a.byteLength));
      else if (a instanceof ArrayBuffer) r.enqueue(a);
      else throw new TypeError("Expected ArrayBuffer or an ArrayBuffer view.");
      r.close();
    } });
    u = M;
    T = /;\s*boundary=(?:"([^"]+)"|([^;",]+))/;
    h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_-.";
    A = () => {
      let a = new Uint8Array(24);
      return globalThis.crypto.getRandomValues(a), Array.from(a).map((s) => h[s % h.length]).join("");
    };
    i = { preventClose: true };
    w = (a, s) => {
      let r = new TransformStream(), d = g(a, s, r.writable), y = false, l = r.readable.getReader();
      return new ReadableStream({ start(e2) {
        (async () => {
          for (; ; ) try {
            let n = await l.read();
            if (n.done) {
              let t = new Uint8Array([13, 10]);
              e2.enqueue(t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)), e2.close();
              return;
            }
            e2.enqueue(n.value);
          } catch (n) {
            e2.error(n);
            return;
          }
        })().catch(() => {
        });
      }, async pull() {
        if (y) return;
        (await d.next()).done && (y = true, await r.writable.close());
      } });
    };
    x = w;
  }
});
var v;
var I;
var B;
var m2;
var o;
var R;
var S;
var init_decrypt = __esm({
  "node_modules/.deno/@apeleghq+rfc8188@1.0.8/node_modules/@apeleghq/rfc8188/dist/decrypt.mjs"() {
    v = async (n, T2, w4, L) => {
      let u2 = await globalThis.crypto.subtle.importKey("raw", T2, "HKDF", false, ["deriveKey", "deriveBits"]), d = await globalThis.crypto.subtle.deriveKey({ name: "HKDF", hash: "SHA-256", info: n.cek_info, salt: w4 }, u2, n.params, false, L), A2 = await globalThis.crypto.subtle.deriveBits({ name: "HKDF", hash: "SHA-256", info: n.nonce_info, salt: w4 }, u2, n.nonce_length << 3);
      return [d, function* () {
        let s = new ArrayBuffer(n.nonce_length), e2 = new DataView(s), y = new Uint8Array(s), i2 = new Uint8Array(A2), b = 4294967295, f = (n.nonce_length >> 2) - 1, l = new Array(f).fill(0);
        for (; ; ) {
          for (let a = 0; a <= b; a++) {
            e2.setUint32(e2.byteLength - 4, a, false);
            let t = new Uint8Array(n.nonce_length);
            for (let r = 0; r < t.length; r++) t[r] = i2[r] ^ y[r];
            yield t;
          }
          for (let a = 0; a < f; a++) {
            if (a === f - 1 && l[a] === b) throw new RangeError("Maximum number of segments exceeded");
            if (l[a] = (l[a] + 1) % (b + 1), e2.setUint32(e2.byteLength - 4 * (a + 2), l[a], false), l[a] !== 0) break;
          }
        }
      }()];
    };
    I = v;
    B = (n) => ArrayBuffer.isView(n) ? new Uint8Array(n.buffer).subarray(n.byteOffset, n.byteOffset + n.byteLength) : new Uint8Array(n);
    m2 = B;
    o = { salt: {}, recordSize: {}, keyIdLen: {}, keyId: {}, payload: {}, done: {} };
    R = (n, T2, w4, L) => {
      let u2 = new Uint8Array(16), d, A2, E3, s = 0, e2 = 0, y = new Uint8Array(256), i2 = o.salt, b = new TransformStream({ start: () => {
      }, transform: async (f, l) => {
        let a = m2(f), t = 0;
        for (; t < f.byteLength; ) switch (i2) {
          case o.salt: {
            let r = a.subarray(t, t + u2.byteLength - e2);
            if (u2.set(r, e2), e2 += r.byteLength, t += r.byteLength, e2 === u2.byteLength) {
              e2 = 0, i2 = o.recordSize;
              continue;
            }
            break;
          }
          case o.recordSize: {
            let r = a.subarray(t, t + 4 - e2), g2 = new ArrayBuffer(4), h2 = new Uint8Array(g2), c = new DataView(g2);
            if (h2.set(r, e2), s |= c.getUint32(0, false), e2 += r.byteLength, t += r.byteLength, e2 === 4) {
              if (s <= n.tag_length + 1 || s > (L == null ? 4294967295 : Math.min(4294967295, L))) throw new RangeError("Invalid record size: " + s);
              e2 = 0, i2 = o.keyIdLen;
              continue;
            }
            break;
          }
          case o.keyIdLen: {
            y[0] = a[t++], i2 = o.keyId;
            continue;
          }
          case o.keyId: {
            let r = a.subarray(t, t + y[0] - e2);
            if (y.set(r, 1 + e2), e2 += r.byteLength, t += r.byteLength, e2 === y[0]) {
              let g2 = await w4(y.subarray(1, 1 + y[0]));
              w4 = void 0;
              let h2 = await I(n, g2, u2, ["decrypt"]);
              A2 = h2[0], E3 = h2[1], d = new Uint8Array(s), e2 = 0, i2 = o.payload;
              continue;
            }
            break;
          }
          case o.payload: {
            let r = a.subarray(t, t + s - e2);
            if (d.set(r, e2), e2 += r.byteLength, t += r.byteLength, e2 === s) {
              let h2 = E3.next().value, c = m2(await globalThis.crypto.subtle.decrypt({ name: n.params.name, iv: h2, tagLength: n.tag_length << 3 }, A2, d.subarray(0, e2))), p = c.byteLength - 1;
              for (; p > 0 && c[p] === 0; p--) ;
              if (c[p] === 2) {
                if (t !== f.byteLength) throw new Error("Unexpected terminal padding delimiter");
                i2 = o.done;
              } else if (c[p] !== 1) throw new Error("Invalid padding delimiter");
              l.enqueue(c.buffer.slice(0, p)), c.fill(0), e2 = 0;
              continue;
            }
            break;
          }
          default:
            throw new Error("Invalid state");
        }
      }, flush: async (f) => {
        switch (i2) {
          case o.done:
            return;
          case o.payload: {
            if (e2 < 1 + n.tag_length) throw new Error("Unexpected end of data");
            let a = E3.next().value, t = m2(await globalThis.crypto.subtle.decrypt({ name: n.params.name, iv: a, tagLength: n.tag_length << 3 }, A2, d.subarray(0, e2))), r = t.byteLength - 1;
            for (; r > 0 && t[r] === 0; r--) ;
            if (t[r] !== 2) throw new Error("Unexpected non-terminal padding delimiter");
            f.enqueue(t.buffer.slice(0, r)), t.fill(0);
            return;
          }
          default:
            throw new Error("Invalid state");
        }
      } });
      return T2.pipeThrough(b), b.readable;
    };
    S = R;
  }
});
var e;
var init_encodings = __esm({
  "node_modules/.deno/@apeleghq+rfc8188@1.0.8/node_modules/@apeleghq/rfc8188/dist/encodings.mjs"() {
    e = { params: { name: "AES-GCM", length: 256 }, get cek_info() {
      return new Uint8Array([67, 111, 110, 116, 101, 110, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103, 58, 32, 97, 101, 115, 50, 53, 54, 103, 99, 109, 0]);
    }, get nonce_info() {
      return new Uint8Array([67, 111, 110, 116, 101, 110, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103, 58, 32, 110, 111, 110, 99, 101, 0]);
    }, block_size: 16, tag_length: 16, nonce_length: 12 };
  }
});
var R2;
var E;
var B2;
var w2;
var N;
var U;
var K;
var init_encrypt = __esm({
  "node_modules/.deno/@apeleghq+rfc8188@1.0.8/node_modules/@apeleghq/rfc8188/dist/encrypt.mjs"() {
    R2 = async (e2, b, f, i2) => {
      let A2 = await globalThis.crypto.subtle.importKey("raw", b, "HKDF", false, ["deriveKey", "deriveBits"]), y = await globalThis.crypto.subtle.deriveKey({ name: "HKDF", hash: "SHA-256", info: e2.cek_info, salt: f }, A2, e2.params, false, i2), u2 = await globalThis.crypto.subtle.deriveBits({ name: "HKDF", hash: "SHA-256", info: e2.nonce_info, salt: f }, A2, e2.nonce_length << 3);
      return [y, function* () {
        let L = new ArrayBuffer(e2.nonce_length), c = new DataView(L), h2 = new Uint8Array(L), a = new Uint8Array(u2), g2 = 4294967295, o2 = (e2.nonce_length >> 2) - 1, s = new Array(o2).fill(0);
        for (; ; ) {
          for (let t = 0; t <= g2; t++) {
            c.setUint32(c.byteLength - 4, t, false);
            let n = new Uint8Array(e2.nonce_length);
            for (let r = 0; r < n.length; r++) n[r] = a[r] ^ h2[r];
            yield n;
          }
          for (let t = 0; t < o2; t++) {
            if (t === o2 - 1 && s[t] === g2) throw new RangeError("Maximum number of segments exceeded");
            if (s[t] = (s[t] + 1) % (g2 + 1), c.setUint32(c.byteLength - 4 * (t + 2), s[t], false), s[t] !== 0) break;
          }
        }
      }()];
    };
    E = R2;
    B2 = (e2) => ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer).subarray(e2.byteOffset, e2.byteOffset + e2.byteLength) : new Uint8Array(e2);
    w2 = B2;
    N = () => {
      let e2 = new Uint8Array(16);
      return globalThis.crypto.getRandomValues(e2), e2;
    };
    U = async (e2, b, f, i2, A2, y) => {
      if (f <= e2.tag_length + 1 || f > 4294967295) throw new RangeError("Invalid record size: " + f);
      if (i2.byteLength > 255) throw new RangeError("Key ID too long");
      if (y && y.byteLength !== 16) throw new RangeError("Invald salt length: " + y.byteLength);
      let u2 = f - e2.tag_length - 1, l = y ? w2(y) : N(), [L, c] = await E(e2, A2, l, ["encrypt"]);
      A2 = void 0;
      let h2 = new Uint8Array(u2), a = 0, g2 = new TransformStream({ start: (o2) => {
        let s = l.byteLength + 4 + 1 + i2.byteLength, t = new ArrayBuffer(s);
        new Uint8Array(t, 0, l.byteLength).set(l);
        let r = new DataView(t, l.byteLength, 5);
        r.setUint32(0, f, false), r.setUint8(4, i2.byteLength);
        let d = new Uint8Array(t, l.byteLength + 4 + 1, i2.byteLength), m3 = w2(i2);
        d.set(m3), o2.enqueue(t);
      }, transform: async (o2, s) => {
        let t = w2(o2), n = 0;
        for (; n < o2.byteLength; ) {
          let r = t.subarray(n, n + u2 - a);
          if (h2.set(r, a), a += r.byteLength, n += r.byteLength, a === u2) {
            let m3 = c.next().value, p = new Uint8Array(u2 + 1);
            p.set(h2.subarray(0, a)), p[a] = 1;
            let T2 = await globalThis.crypto.subtle.encrypt({ name: e2.params.name, iv: m3, tagLength: e2.tag_length << 3 }, L, p);
            s.enqueue(T2), a = 0;
          }
        }
      }, flush: async (o2) => {
        let t = c.next().value, n = new Uint8Array(a + 1);
        n.set(h2.subarray(0, a)), n[a] = 2;
        let r = await globalThis.crypto.subtle.encrypt({ name: e2.params.name, iv: t, tagLength: e2.tag_length << 3 }, L, n);
        o2.enqueue(r), h2.fill(0), n.fill(0);
      } });
      return b.pipeThrough(g2), g2.readable;
    };
    K = U;
  }
});
var wm;
var Secret;
var init_Secret = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/Secret.mjs"() {
    init_esm10();
    wm = /* @__PURE__ */ new WeakMap();
    Secret = class {
      static [serdesDeserializeSymbol](secret) {
        return new this(secret);
      }
      static [serdesSerializeSymbol](secret) {
        return wm.get(secret);
      }
      static get [serdesTagSymbol]() {
        return "__chelonia_Secret";
      }
      constructor(value) {
        wm.set(this, value);
      }
      valueOf() {
        return wm.get(this);
      }
    };
  }
});
var INVITE_STATUS;
var init_constants = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/constants.mjs"() {
    INVITE_STATUS = {
      REVOKED: "revoked",
      VALID: "valid",
      USED: "used"
    };
  }
});
function eventsAfter2(contractID, { sinceHeight, limit, sinceHash, stream = true }) {
  if (!contractID) {
    throw new Error("Missing contract ID");
  }
  let lastUrl;
  const fetchEventsStreamReader = async () => {
    requestLimit = Math.min(limit ?? MAX_EVENTS_AFTER, remainingEvents);
    lastUrl = `${this.config.connectionURL}/eventsAfter/${contractID}/${sinceHeight}${Number.isInteger(requestLimit) ? `/${requestLimit}` : ""}`;
    const eventsResponse = await this.config.fetch(lastUrl, { signal });
    if (!eventsResponse.ok) {
      const msg = `${eventsResponse.status}: ${eventsResponse.statusText}`;
      if (eventsResponse.status === 404 || eventsResponse.status === 410) {
        throw new ChelErrorResourceGone(msg, { cause: eventsResponse.status });
      }
      throw new ChelErrorUnexpectedHttpResponseCode(msg, { cause: eventsResponse.status });
    }
    if (!eventsResponse.body)
      throw new Error("Missing body");
    latestHeight = parseInt(eventsResponse.headers.get("shelter-headinfo-height"), 10);
    if (!Number.isSafeInteger(latestHeight))
      throw new Error("Invalid latest height");
    requestCount++;
    return eventsResponse.body.getReader();
  };
  if (!Number.isSafeInteger(sinceHeight) || sinceHeight < 0) {
    throw new TypeError("Invalid since height value. Expected positive integer.");
  }
  const signal = this.abortController.signal;
  let requestCount = 0;
  let remainingEvents = limit ?? Number.POSITIVE_INFINITY;
  let eventsStreamReader;
  let latestHeight;
  let state = "fetch";
  let requestLimit;
  let count3;
  let buffer = "";
  let currentEvent;
  const s = new ReadableStream({
    // The pull function is called whenever the internal buffer of the stream
    // becomes empty and needs more data.
    async pull(controller) {
      try {
        for (; ; ) {
          switch (state) {
            // When in 'fetch' state, initiate a new fetch request to obtain a
            // stream reader for events.
            case "fetch": {
              eventsStreamReader = await fetchEventsStreamReader();
              state = "read-new-response";
              count3 = 0;
              break;
            }
            case "read-eos":
            // End of stream case
            case "read-new-response":
            // Just started reading a new response
            case "read": {
              const { done, value } = await eventsStreamReader.read();
              if (done) {
                if (remainingEvents === 0 || sinceHeight >= latestHeight) {
                  controller.close();
                  return;
                } else if (state === "read-new-response" || buffer) {
                  throw new Error("Invalid response: done too early");
                } else {
                  state = "fetch";
                  break;
                }
              }
              if (!value) {
                throw new Error("Invalid response: missing body");
              }
              buffer = buffer + Buffer3.from(value).toString().trim();
              if (!buffer)
                break;
              if (state === "read-new-response") {
                if (buffer[0] !== "[") {
                  throw new Error("Invalid response: no array start delimiter");
                }
                buffer = buffer.slice(1);
              } else if (state === "read-eos") {
                throw new Error("Invalid data at the end of response");
              }
              state = "events";
              break;
            }
            case "events": {
              const nextIdx = buffer.search(/(?<=\s*)[,\]]/);
              if (nextIdx < 0) {
                state = "read";
                break;
              }
              let enqueued = false;
              try {
                const eventValue = buffer.slice(0, nextIdx).trim();
                if (eventValue) {
                  if (count3 === requestLimit) {
                    throw new Error("Received too many events");
                  }
                  currentEvent = JSON.parse(b64ToStr(JSON.parse(eventValue))).message;
                  if (count3 === 0) {
                    const hash32 = SPMessage.deserializeHEAD(currentEvent).hash;
                    const height = SPMessage.deserializeHEAD(currentEvent).head.height;
                    if (height !== sinceHeight || sinceHash && sinceHash !== hash32) {
                      if (height === sinceHeight && sinceHash && sinceHash !== hash32) {
                        throw new ChelErrorForkedChain(`Forked chain: hash(${hash32}) !== since(${sinceHash})`);
                      } else {
                        throw new Error(`Unexpected data: hash(${hash32}) !== since(${sinceHash || ""}) or height(${height}) !== since(${sinceHeight})`);
                      }
                    }
                  }
                  if (count3++ !== 0 || requestCount !== 0) {
                    controller.enqueue(currentEvent);
                    enqueued = true;
                    remainingEvents--;
                  }
                }
                if (buffer[nextIdx] === "]") {
                  if (currentEvent) {
                    const deserialized = SPMessage.deserializeHEAD(currentEvent);
                    sinceHeight = deserialized.head.height;
                    sinceHash = deserialized.hash;
                    state = "read-eos";
                  } else {
                    state = "eod";
                  }
                  buffer = buffer.slice(nextIdx + 1).trim();
                } else if (currentEvent) {
                  buffer = buffer.slice(nextIdx + 1).trimStart();
                } else {
                  throw new Error("Missing end delimiter");
                }
                if (enqueued) {
                  return;
                }
              } catch (e2) {
                console.error("[chelonia] Error during event parsing", e2);
                throw e2;
              }
              break;
            }
            case "eod": {
              if (remainingEvents === 0 || sinceHeight >= latestHeight) {
                controller.close();
              } else {
                throw new Error("Unexpected end of data");
              }
              return;
            }
          }
        }
      } catch (e2) {
        console.error("[eventsAfter] Error", { lastUrl }, e2);
        eventsStreamReader?.cancel("Error during pull").catch((e22) => {
          console.error("Error canceling underlying event stream reader on error", e2, e22);
        });
        throw e2;
      }
    }
  });
  if (stream)
    return s;
  return collectEventStream(s);
}
function buildShelterAuthorizationHeader(contractID, state) {
  if (!state)
    state = esm_default(this.config.stateSelector)[contractID];
  const SAKid = findKeyIdByName(state, "#sak");
  if (!SAKid) {
    throw new Error(`Missing #sak in ${contractID}`);
  }
  const SAK = this.transientSecretKeys[SAKid];
  if (!SAK) {
    throw new Error(`Missing secret #sak (${SAKid}) in ${contractID}`);
  }
  const deserializedSAK = typeof SAK === "string" ? deserializeKey(SAK) : SAK;
  const nonceBytes = new Uint8Array(15);
  globalThis.crypto.getRandomValues(nonceBytes);
  const data = `${contractID} ${esm_default("chelonia/time")}.${Buffer3.from(nonceBytes).toString("base64")}`;
  return `shelter ${data}.${sign(deserializedSAK, data)}`;
}
function verifyShelterAuthorizationHeader(authorization, rootState) {
  const regex = /^shelter (([a-zA-Z0-9]+) ([0-9]+)\.([a-zA-Z0-9+/=]{20}))\.([a-zA-Z0-9+/=]+)$/i;
  if (authorization.length > 1024) {
    throw new Error("Authorization header too long");
  }
  const matches = authorization.match(regex);
  if (!matches) {
    throw new Error("Unable to parse shelter authorization header");
  }
  const [, data, contractID, timestamp, , signature] = matches;
  if (Math.abs(parseInt(timestamp) - Date.now()) > 6e4) {
    throw new Error("Invalid signature time range");
  }
  if (!rootState)
    rootState = esm_default("chelonia/rootState");
  if (!has(rootState, contractID)) {
    throw new Error(`Contract ${contractID} from shelter authorization header not found`);
  }
  const SAKid = findKeyIdByName(rootState[contractID], "#sak");
  if (!SAKid) {
    throw new Error(`Missing #sak in ${contractID}`);
  }
  const SAK = rootState[contractID]._vm.authorizedKeys[SAKid].data;
  if (!SAK) {
    throw new Error(`Missing secret #sak (${SAKid}) in ${contractID}`);
  }
  const deserializedSAK = deserializeKey(SAK);
  verifySignature(deserializedSAK, data, signature);
  return contractID;
}
var MAX_EVENTS_AFTER;
var copiedExistingData;
var findKeyIdByName;
var findForeignKeysByContractID;
var findRevokedKeyIdsByName;
var findSuitableSecretKeyId;
var findSuitablePublicKeyIds;
var validateActionPermissions;
var validateKeyPermissions;
var validateKeyAddPermissions;
var validateKeyDelPermissions;
var validateKeyUpdatePermissions;
var keyAdditionProcessor;
var subscribeToForeignKeyContracts;
var recreateEvent;
var getContractIDfromKeyId;
var clearObject;
var reactiveClearObject;
var checkCanBeGarbageCollected;
var collectEventStream;
var logEvtError;
var handleFetchResult2;
var init_utils2 = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/utils.mjs"() {
    init_esm2();
    init_esm3();
    init_esm9();
    init_SPMessage();
    init_Secret();
    init_constants();
    init_errors();
    init_events2();
    init_functions();
    init_signedData();
    MAX_EVENTS_AFTER = Number.parseInt(process.env.MAX_EVENTS_AFTER || "", 10) || Infinity;
    copiedExistingData = Symbol("copiedExistingData");
    findKeyIdByName = (state, name) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).find((k) => k.name === name && k._notAfterHeight == null)?.id;
    findForeignKeysByContractID = (state, contractID) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => k._notAfterHeight == null && k.foreignKey?.includes(contractID)).map((k) => k.id);
    findRevokedKeyIdsByName = (state, name) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys || {}).filter((k) => k.name === name && k._notAfterHeight != null).map((k) => k.id);
    findSuitableSecretKeyId = (state, permissions, purposes, ringLevel, allowedActions) => {
      return state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => {
        return k._notAfterHeight == null && k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY) && esm_default("chelonia/haveSecretKey", k.id) && (Array.isArray(permissions) ? permissions.reduce((acc, permission) => acc && (k.permissions === "*" || k.permissions.includes(permission)), true) : permissions === k.permissions) && purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true) && (Array.isArray(allowedActions) ? allowedActions.reduce((acc, action) => acc && (k.allowedActions === "*" || !!k.allowedActions?.includes(action)), true) : allowedActions ? allowedActions === k.allowedActions : true);
      }).sort((a, b) => b.ringLevel - a.ringLevel)[0]?.id;
    };
    findSuitablePublicKeyIds = (state, permissions, purposes, ringLevel) => {
      return state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => k._notAfterHeight == null && k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY) && (Array.isArray(permissions) ? permissions.reduce((acc, permission) => acc && (k.permissions === "*" || k.permissions.includes(permission)), true) : permissions === k.permissions) && purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true)).sort((a, b) => b.ringLevel - a.ringLevel).map((k) => k.id);
    };
    validateActionPermissions = (msg, signingKey, state, opT, opV) => {
      const data = isSignedData(opV) ? opV.valueOf() : opV;
      if (signingKey.allowedActions !== "*" && (!Array.isArray(signingKey.allowedActions) || !signingKey.allowedActions.includes(data.action))) {
        logEvtError(msg, `Signing key ${signingKey.id} is not allowed for action ${data.action}`);
        return false;
      }
      if (isSignedData(opV)) {
        const s = opV;
        const innerSigningKey = state._vm?.authorizedKeys?.[s.signingKeyId];
        if (!innerSigningKey && msg._direction === "outgoing")
          return true;
        if (!innerSigningKey || !Array.isArray(innerSigningKey.purpose) || !innerSigningKey.purpose.includes("sig") || innerSigningKey.permissions !== "*" && (!Array.isArray(innerSigningKey.permissions) || !innerSigningKey.permissions.includes(opT + "#inner"))) {
          logEvtError(msg, `Signing key ${s.signingKeyId} is missing permissions for operation ${opT}`);
          return false;
        }
        if (innerSigningKey.allowedActions !== "*" && (!Array.isArray(innerSigningKey.allowedActions) || !innerSigningKey.allowedActions.includes(data.action + "#inner"))) {
          logEvtError(msg, `Signing key ${innerSigningKey.id} is not allowed for action ${data.action}`);
          return false;
        }
      }
      return true;
    };
    validateKeyPermissions = (msg, config2, state, signingKeyId, opT, opV) => {
      const signingKey = state._vm?.authorizedKeys?.[signingKeyId];
      if (!signingKey || !Array.isArray(signingKey.purpose) || !signingKey.purpose.includes("sig") || signingKey.permissions !== "*" && (!Array.isArray(signingKey.permissions) || !signingKey.permissions.includes(opT))) {
        logEvtError(msg, `Signing key ${signingKeyId} is missing permissions for operation ${opT}`);
        return false;
      }
      if (opT === SPMessage.OP_ACTION_UNENCRYPTED && !validateActionPermissions(msg, signingKey, state, opT, opV)) {
        return false;
      }
      if (!config2.skipActionProcessing && opT === SPMessage.OP_ACTION_ENCRYPTED && !validateActionPermissions(msg, signingKey, state, opT, opV.valueOf())) {
        return false;
      }
      return true;
    };
    validateKeyAddPermissions = function(contractID, signingKey, state, v2, skipPrivateCheck) {
      const signingKeyPermissions = Array.isArray(signingKey.permissions) ? new Set(signingKey.permissions) : signingKey.permissions;
      const signingKeyAllowedActions = Array.isArray(signingKey.allowedActions) ? new Set(signingKey.allowedActions) : signingKey.allowedActions;
      if (!state._vm?.authorizedKeys?.[signingKey.id]) {
        throw new Error("Singing key for OP_KEY_ADD or OP_KEY_UPDATE must exist in _vm.authorizedKeys. contractID=" + contractID + " signingKeyId=" + signingKey.id);
      }
      const localSigningKey = state._vm.authorizedKeys[signingKey.id];
      v2.forEach((wk) => {
        const data = this.config.unwrapMaybeEncryptedData(wk);
        if (!data)
          return;
        const k = data.data;
        if (!skipPrivateCheck && signingKey._private && !data.encryptionKeyId) {
          throw new Error("Signing key is private but it tried adding a public key");
        }
        if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {
          throw new Error("Signing key has ringLevel " + localSigningKey.ringLevel + " but attempted to add or update a key with ringLevel " + k.ringLevel);
        }
        if (signingKeyPermissions !== "*") {
          if (!Array.isArray(k.permissions) || !k.permissions.reduce((acc, cv) => acc && signingKeyPermissions.has(cv), true)) {
            throw new Error("Unable to add or update a key with more permissions than the signing key. signingKey permissions: " + String(signingKey?.permissions) + "; key add permissions: " + String(k.permissions));
          }
        }
        if (signingKeyAllowedActions !== "*" && k.allowedActions) {
          if (!signingKeyAllowedActions || !Array.isArray(k.allowedActions) || !k.allowedActions.reduce((acc, cv) => acc && signingKeyAllowedActions.has(cv), true)) {
            throw new Error("Unable to add or update a key with more allowed actions than the signing key. signingKey allowed actions: " + String(signingKey?.allowedActions) + "; key add allowed actions: " + String(k.allowedActions));
          }
        }
      });
    };
    validateKeyDelPermissions = function(contractID, signingKey, state, v2) {
      if (!state._vm?.authorizedKeys?.[signingKey.id]) {
        throw new Error("Singing key for OP_KEY_DEL must exist in _vm.authorizedKeys. contractID=" + contractID + " signingKeyId=" + signingKey.id);
      }
      const localSigningKey = state._vm.authorizedKeys[signingKey.id];
      v2.forEach((wid) => {
        const data = this.config.unwrapMaybeEncryptedData(wid);
        if (!data)
          return;
        const id = data.data;
        const k = state._vm.authorizedKeys[id];
        if (!k) {
          throw new Error("Nonexisting key ID " + id);
        }
        if (signingKey._private) {
          throw new Error("Signing key is private");
        }
        if (!k._private !== !data.encryptionKeyId) {
          throw new Error("_private attribute must be preserved");
        }
        if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {
          throw new Error("Signing key has ringLevel " + localSigningKey.ringLevel + " but attempted to remove a key with ringLevel " + k.ringLevel);
        }
      });
    };
    validateKeyUpdatePermissions = function(contractID, signingKey, state, v2) {
      const updatedMap = /* @__PURE__ */ Object.create(null);
      const keys = v2.map((wuk) => {
        const data = this.config.unwrapMaybeEncryptedData(wuk);
        if (!data)
          return void 0;
        const uk = data.data;
        const existingKey = state._vm.authorizedKeys[uk.oldKeyId];
        if (!existingKey) {
          throw new ChelErrorWarning("Missing old key ID " + uk.oldKeyId);
        }
        if (!existingKey._private !== !data.encryptionKeyId) {
          throw new Error("_private attribute must be preserved");
        }
        if (uk.name !== existingKey.name) {
          throw new Error("Name cannot be updated");
        }
        if (!uk.id !== !uk.data) {
          throw new Error("Both or none of the id and data attributes must be provided. Old key ID: " + uk.oldKeyId);
        }
        if (uk.data && existingKey.meta?.private && !uk.meta?.private) {
          throw new Error("Missing private key. Old key ID: " + uk.oldKeyId);
        }
        if (uk.id && uk.id !== uk.oldKeyId) {
          updatedMap[uk.id] = uk.oldKeyId;
        }
        const updatedKey = omit2(existingKey, [
          "_notAfterHeight",
          "_notBeforeHeight"
        ]);
        if (uk.permissions) {
          updatedKey.permissions = uk.permissions;
        }
        if (uk.allowedActions) {
          updatedKey.allowedActions = uk.allowedActions;
        }
        if (uk.purpose) {
          updatedKey.purpose = uk.purpose;
        }
        if (uk.meta) {
          updatedKey.meta = uk.meta;
        } else if (updatedKey.meta) {
          Object.defineProperty(updatedKey.meta, copiedExistingData, { value: true });
        }
        if (uk.id) {
          updatedKey.id = uk.id;
        }
        if (uk.data) {
          updatedKey.data = uk.data;
        }
        return updatedKey;
      }).filter(Boolean);
      validateKeyAddPermissions.call(this, contractID, signingKey, state, keys, true);
      return [keys, updatedMap];
    };
    keyAdditionProcessor = function(_msg, hash32, keys, state, contractID, _signingKey, internalSideEffectStack) {
      const decryptedKeys = [];
      const keysToPersist = [];
      const storeSecretKey = (key, decryptedKey) => {
        const decryptedDeserializedKey = deserializeKey(decryptedKey);
        const transient = !!key.meta?.private?.transient;
        esm_default("chelonia/storeSecretKeys", new Secret([
          {
            key: decryptedDeserializedKey,
            // We always set this to true because this could be done from
            // an outgoing message
            transient: true
          }
        ]));
        if (!transient) {
          keysToPersist.push({ key: decryptedDeserializedKey, transient });
        }
      };
      for (const wkey of keys) {
        const data = this.config.unwrapMaybeEncryptedData(wkey);
        if (!data)
          continue;
        const key = data.data;
        let decryptedKey;
        if (key.meta?.private?.content && !has(key.meta, copiedExistingData)) {
          if (key.id && !esm_default("chelonia/haveSecretKey", key.id, !key.meta.private.transient)) {
            const decryptedKeyResult = this.config.unwrapMaybeEncryptedData(key.meta.private.content);
            if (decryptedKeyResult) {
              if (decryptedKeyResult.encryptionKeyId == null) {
                throw new Error("Expected encrypted data but got unencrypted data for key with ID: " + key.id);
              }
              decryptedKey = decryptedKeyResult.data;
              decryptedKeys.push([key.id, decryptedKey]);
              storeSecretKey(key, decryptedKey);
            }
          }
        }
        if (key.name === "#sak") {
          if (data.encryptionKeyId) {
            throw new Error("#sak may not be encrypted");
          }
          if (key.permissions && (!Array.isArray(key.permissions) || key.permissions.length !== 0)) {
            throw new Error("#sak may not have permissions");
          }
          if (!Array.isArray(key.purpose) || key.purpose.length !== 1 || key.purpose[0] !== "sak") {
            throw new Error("#sak must have exactly one purpose: 'sak'");
          }
          if (key.ringLevel !== 0) {
            throw new Error("#sak must have ringLevel 0");
          }
        }
        if (key.name.startsWith("#inviteKey-")) {
          if (!state._vm.invites)
            state._vm.invites = /* @__PURE__ */ Object.create(null);
          const inviteSecret = decryptedKey || (has(this.transientSecretKeys, key.id) ? serializeKey(this.transientSecretKeys[key.id], true) : void 0);
          state._vm.invites[key.id] = {
            status: INVITE_STATUS.VALID,
            initialQuantity: key.meta.quantity,
            quantity: key.meta.quantity,
            expires: key.meta.expires,
            inviteSecret,
            responses: []
          };
        }
        if (key.meta?.keyRequest?.contractID && findSuitableSecretKeyId(state, [SPMessage.OP_KEY_ADD], ["sig"])) {
          const data2 = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.contractID);
          if (data2 && internalSideEffectStack) {
            const keyRequestContractID = data2.data;
            const reference = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.reference);
            internalSideEffectStack.push(() => {
              esm_default("chelonia/private/queueEvent", keyRequestContractID, () => {
                const rootState = esm_default(this.config.stateSelector);
                const originatingContractState = rootState[contractID];
                if (esm_default("chelonia/contract/hasKeyShareBeenRespondedBy", originatingContractState, keyRequestContractID, reference)) {
                  return;
                }
                if (!has(rootState, keyRequestContractID)) {
                  this.config.reactiveSet(rootState, keyRequestContractID, /* @__PURE__ */ Object.create(null));
                }
                const targetState = rootState[keyRequestContractID];
                if (!targetState._volatile) {
                  this.config.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
                }
                if (!targetState._volatile.pendingKeyRequests) {
                  this.config.reactiveSet(rootState[keyRequestContractID]._volatile, "pendingKeyRequests", []);
                }
                if (targetState._volatile.pendingKeyRequests.some((pkr) => {
                  return pkr && pkr.contractID === contractID && pkr.hash === hash32;
                })) {
                  return;
                }
                targetState._volatile.pendingKeyRequests.push({
                  contractID,
                  name: key.name,
                  hash: hash32,
                  reference: reference?.data
                });
                this.setPostSyncOp(contractID, "pending-keys-for-" + keyRequestContractID, [
                  "okTurtles.events/emit",
                  CONTRACT_IS_PENDING_KEY_REQUESTS,
                  { contractID: keyRequestContractID }
                ]);
              }).catch((e2) => {
                console.error("Error while setting or updating pendingKeyRequests", { contractID, keyRequestContractID, reference }, e2);
              });
            });
          }
        }
      }
      if (keysToPersist.length) {
        internalSideEffectStack?.push(() => {
          esm_default("chelonia/storeSecretKeys", new Secret(keysToPersist));
        });
      }
      internalSideEffectStack?.push(() => subscribeToForeignKeyContracts.call(this, contractID, state));
    };
    subscribeToForeignKeyContracts = function(contractID, state) {
      try {
        Object.values(state._vm.authorizedKeys).filter((key) => !!key.foreignKey && findKeyIdByName(state, key.name) != null).forEach((key) => {
          const foreignKey = String(key.foreignKey);
          const fkUrl = new URL(foreignKey);
          const foreignContract = fkUrl.pathname;
          const foreignKeyName = fkUrl.searchParams.get("keyName");
          if (!foreignContract || !foreignKeyName) {
            console.warn("Invalid foreign key: missing contract or key name", {
              contractID,
              keyId: key.id
            });
            return;
          }
          const rootState = esm_default(this.config.stateSelector);
          const signingKey = findSuitableSecretKeyId(state, [SPMessage.OP_KEY_DEL], ["sig"], key.ringLevel);
          const canMirrorOperations = !!signingKey;
          if (!canMirrorOperations)
            return;
          if (Array.isArray(rootState?.[foreignContract]?._volatile?.watch)) {
            if (rootState[foreignContract]._volatile.watch.find((v2) => v2[0] === key.name && v2[1] === contractID)) {
              return;
            }
          }
          if (!has(state._vm, "pendingWatch")) {
            this.config.reactiveSet(state._vm, "pendingWatch", /* @__PURE__ */ Object.create(null));
          }
          if (!has(state._vm.pendingWatch, foreignContract)) {
            this.config.reactiveSet(state._vm.pendingWatch, foreignContract, []);
          }
          if (!state._vm.pendingWatch[foreignContract].find(([n]) => n === foreignKeyName)) {
            state._vm.pendingWatch[foreignContract].push([foreignKeyName, key.id]);
          }
          this.setPostSyncOp(contractID, `watchForeignKeys-${contractID}`, [
            "chelonia/private/watchForeignKeys",
            contractID
          ]);
        });
      } catch (e2) {
        console.warn("Error at subscribeToForeignKeyContracts: " + (e2.message || e2));
      }
    };
    recreateEvent = (entry, state, contractsState, disableAutoDedup) => {
      const { HEAD: previousHEAD, height: previousHeight, previousKeyOp } = contractsState || {};
      if (!previousHEAD) {
        throw new Error("recreateEvent: Giving up because the contract has been removed");
      }
      const head = entry.head();
      const [opT, rawOpV] = entry.rawOp();
      const recreateOperation = (opT2, rawOpV2) => {
        const opV = rawOpV2.valueOf();
        const recreateOperationInternal = (opT3, opV2) => {
          let newOpV2;
          if (opT3 === SPMessage.OP_KEY_ADD) {
            if (!Array.isArray(opV2))
              throw new Error("Invalid message format");
            newOpV2 = opV2.filter((k) => {
              const kId = k.valueOf().id;
              return !has(state._vm.authorizedKeys, kId) || state._vm.authorizedKeys[kId]._notAfterHeight != null;
            });
            if (newOpV2.length === 0) {
              console.info("Omitting empty OP_KEY_ADD", { head });
            } else if (newOpV2.length === opV2.length) {
              return opV2;
            }
          } else if (opT3 === SPMessage.OP_KEY_DEL) {
            if (!Array.isArray(opV2))
              throw new Error("Invalid message format");
            newOpV2 = opV2.filter((keyId2) => {
              const kId = Object(keyId2).valueOf();
              return has(state._vm.authorizedKeys, kId) && state._vm.authorizedKeys[kId]._notAfterHeight == null;
            });
            if (newOpV2.length === 0) {
              console.info("Omitting empty OP_KEY_DEL", { head });
            } else if (newOpV2.length === opV2.length) {
              return opV2;
            }
          } else if (opT3 === SPMessage.OP_KEY_UPDATE) {
            if (!Array.isArray(opV2))
              throw new Error("Invalid message format");
            newOpV2 = opV2.filter((k) => {
              const oKId = k.valueOf().oldKeyId;
              const nKId = k.valueOf().id;
              return nKId == null || has(state._vm.authorizedKeys, oKId) && state._vm.authorizedKeys[oKId]._notAfterHeight == null;
            });
            if (newOpV2.length === 0) {
              console.info("Omitting empty OP_KEY_UPDATE", { head });
            } else if (newOpV2.length === opV2.length) {
              return opV2;
            }
          } else if (opT3 === SPMessage.OP_ATOMIC) {
            if (!Array.isArray(opV2))
              throw new Error("Invalid message format");
            newOpV2 = opV2.map(([t, v2]) => [t, recreateOperationInternal(t, v2)]).filter(([, v2]) => !!v2);
            if (newOpV2.length === 0) {
              console.info("Omitting empty OP_ATOMIC", { head });
            } else if (newOpV2.length === opV2.length && newOpV2.reduce((acc, cv, i2) => acc && cv === opV2[i2], true)) {
              return opV2;
            } else {
              return newOpV2;
            }
          } else {
            return opV2;
          }
        };
        const newOpV = recreateOperationInternal(opT2, opV);
        if (newOpV === opV) {
          return rawOpV2;
        } else if (newOpV === void 0) {
          return;
        }
        if (typeof rawOpV2.recreate !== "function") {
          throw new Error("Unable to recreate operation");
        }
        return rawOpV2.recreate(newOpV);
      };
      const newRawOpV = disableAutoDedup ? rawOpV : recreateOperation(opT, rawOpV);
      if (!newRawOpV)
        return;
      const newOp = [opT, newRawOpV];
      entry = SPMessage.cloneWith(head, newOp, {
        previousKeyOp,
        previousHEAD,
        height: previousHeight + 1
      });
      return entry;
    };
    getContractIDfromKeyId = (contractID, signingKeyId, state) => {
      if (!signingKeyId)
        return;
      return signingKeyId && state._vm?.authorizedKeys?.[signingKeyId]?.foreignKey ? new URL(state._vm.authorizedKeys[signingKeyId].foreignKey).pathname : contractID;
    };
    clearObject = (o2) => {
      Object.keys(o2).forEach((k) => delete o2[k]);
    };
    reactiveClearObject = (o2, fn) => {
      Object.keys(o2).forEach((k) => fn(o2, k));
    };
    checkCanBeGarbageCollected = function(id) {
      const rootState = esm_default(this.config.stateSelector);
      return (
        // Check persistent references
        (!has(rootState.contracts, id) || !rootState.contracts[id] || !has(rootState.contracts[id], "references")) && // Check ephemeral references
        !has(this.ephemeralReferenceCount, id) && // Check foreign keys (i.e., that no keys from this contract are being watched)
        (!has(rootState, id) || !has(rootState[id], "_volatile") || !has(rootState[id]._volatile, "watch") || rootState[id]._volatile.watch.length === 0 || rootState[id]._volatile.watch.filter(([, cID]) => this.subscriptionSet.has(cID)).length === 0)
      );
    };
    collectEventStream = async (s) => {
      const reader = s.getReader();
      const r = [];
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done)
          break;
        r.push(value);
      }
      return r;
    };
    logEvtError = (msg, ...args) => {
      if (msg._direction === "outgoing") {
        console.warn(...args);
      } else {
        console.error(...args);
      }
    };
    handleFetchResult2 = (type) => {
      return function(r) {
        if (!r.ok) {
          const msg = `${r.status}: ${r.statusText}`;
          if (r.status === 404 || r.status === 410) {
            throw new ChelErrorResourceGone(msg, { cause: r.status });
          }
          throw new ChelErrorUnexpectedHttpResponseCode(msg, { cause: r.status });
        }
        return r[type]();
      };
    };
  }
});
var supportsRequestStreams;
var streamToUint8Array;
var ArrayBufferToUint8ArrayStream;
var computeChunkDescriptors;
var fileStream;
var aes256gcmHandlers;
var noneHandlers;
var cipherHandlers;
var files_default;
var init_files = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/files.mjs"() {
    init_encodeMultipartMessage();
    init_decrypt();
    init_encodings();
    init_encrypt();
    init_esm2();
    init_bytes3();
    init_esm3();
    init_esm9();
    init_functions();
    init_utils2();
    supportsRequestStreams = typeof window !== "object" || (() => {
      let duplexAccessed = false;
      const hasContentType = new Request("", {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("content-type");
      return duplexAccessed && !hasContentType;
    })();
    streamToUint8Array = async (s) => {
      const reader = s.getReader();
      const chunks = [];
      let length4 = 0;
      for (; ; ) {
        const result = await reader.read();
        if (result.done)
          break;
        chunks.push(coerce3(result.value));
        length4 += result.value.byteLength;
      }
      const body = new Uint8Array(length4);
      chunks.reduce((offset, chunk) => {
        body.set(chunk, offset);
        return offset + chunk.byteLength;
      }, 0);
      return body;
    };
    ArrayBufferToUint8ArrayStream = async function(connectionURL, s) {
      if (supportsRequestStreams === true) {
        await this.config.fetch(`${connectionURL}/streams-test`, {
          method: "POST",
          body: new ReadableStream({
            start(c) {
              c.enqueue(Buffer4.from("ok"));
              c.close();
            }
          }),
          duplex: "half"
        }).then((r) => {
          if (!r.ok)
            throw new Error("Unexpected response");
          supportsRequestStreams = 2;
        }).catch(() => {
          console.info("files: Disabling streams support because the streams test failed");
          supportsRequestStreams = false;
        });
      }
      if (!supportsRequestStreams) {
        return await streamToUint8Array(s);
      }
      return s.pipeThrough(
        // eslint-disable-next-line no-undef
        new TransformStream({
          transform(chunk, controller) {
            controller.enqueue(coerce3(chunk));
          }
        })
      );
    };
    computeChunkDescriptors = (inStream) => {
      let length4 = 0;
      const [lengthStream, cidStream] = inStream.tee();
      const lengthPromise = new Promise((resolve8, reject) => {
        lengthStream.pipeTo(new WritableStream({
          write(chunk) {
            length4 += chunk.byteLength;
          },
          close() {
            resolve8(length4);
          },
          abort(reason) {
            reject(reason);
          }
        }));
      });
      const cidPromise = createCIDfromStream(cidStream, multicodes2.SHELTER_FILE_CHUNK);
      return Promise.all([lengthPromise, cidPromise]);
    };
    fileStream = (chelonia, manifest2) => {
      const dataGenerator = async function* () {
        let readSize = 0;
        for (const chunk of manifest2.chunks) {
          if (!Array.isArray(chunk) || typeof chunk[0] !== "number" || typeof chunk[1] !== "string") {
            throw new Error("Invalid chunk descriptor");
          }
          const chunkResponse = await chelonia.config.fetch(`${chelonia.config.connectionURL}/file/${chunk[1]}`, {
            method: "GET",
            signal: chelonia.abortController.signal
          });
          if (!chunkResponse.ok) {
            throw new Error("Unable to retrieve manifest");
          }
          const chunkBinary = await chunkResponse.arrayBuffer();
          if (chunkBinary.byteLength !== chunk[0])
            throw new Error("mismatched chunk size");
          readSize += chunkBinary.byteLength;
          if (readSize > manifest2.size)
            throw new Error("read size exceeds declared size");
          if (createCID2(coerce3(chunkBinary), multicodes2.SHELTER_FILE_CHUNK) !== chunk[1]) {
            throw new Error("mismatched chunk hash");
          }
          yield chunkBinary;
        }
        if (readSize !== manifest2.size)
          throw new Error("mismatched size");
      };
      const dataIterator = dataGenerator();
      return new ReadableStream({
        async pull(controller) {
          try {
            const chunk = await dataIterator.next();
            if (chunk.done) {
              controller.close();
              return;
            }
            controller.enqueue(chunk.value);
          } catch (e2) {
            controller.error(e2);
          }
        }
      });
    };
    aes256gcmHandlers = {
      upload: (_chelonia, manifestOptions) => {
        const params = manifestOptions["cipher-params"];
        let IKM = params?.IKM;
        const recordSize = params?.rs ?? 1 << 16;
        if (!IKM) {
          IKM = new Uint8Array(33);
          self.crypto.getRandomValues(IKM);
        }
        const keyId2 = blake32Hash2("aes256gcm-keyId" + blake32Hash2(IKM)).slice(-8);
        const binaryKeyId = Buffer4.from(keyId2);
        return {
          cipherParams: {
            keyId: keyId2
          },
          streamHandler: async (stream) => {
            return await K(e, stream, recordSize, binaryKeyId, IKM);
          },
          downloadParams: {
            IKM: Buffer4.from(IKM).toString("base64"),
            rs: recordSize
          }
        };
      },
      download: (chelonia, downloadParams, manifest2) => {
        const IKMb64 = downloadParams.IKM;
        if (!IKMb64) {
          throw new Error("Missing IKM in downloadParams");
        }
        const IKM = Buffer4.from(IKMb64, "base64");
        const keyId2 = blake32Hash2("aes256gcm-keyId" + blake32Hash2(IKM)).slice(-8);
        if (!manifest2["cipher-params"] || !manifest2["cipher-params"].keyId) {
          throw new Error("Missing cipher-params");
        }
        if (keyId2 !== manifest2["cipher-params"].keyId) {
          throw new Error("Key ID mismatch");
        }
        const maxRecordSize = downloadParams.rs ?? 1 << 27;
        return {
          payloadHandler: async () => {
            const bytes = await streamToUint8Array(S(e, fileStream(chelonia, manifest2), (actualKeyId) => {
              if (Buffer4.from(actualKeyId).toString() !== keyId2) {
                throw new Error("Invalid key ID");
              }
              return IKM;
            }, maxRecordSize));
            return new Blob([bytes], { type: manifest2.type || "application/octet-stream" });
          }
        };
      }
    };
    noneHandlers = {
      upload: () => {
        return {
          cipherParams: void 0,
          streamHandler: (stream) => {
            return stream;
          },
          downloadParams: void 0
        };
      },
      download: (chelonia, _downloadParams, manifest2) => {
        return {
          payloadHandler: async () => {
            const bytes = await streamToUint8Array(fileStream(chelonia, manifest2));
            return new Blob([bytes], { type: manifest2.type || "application/octet-stream" });
          }
        };
      }
    };
    cipherHandlers = {
      aes256gcm: aes256gcmHandlers,
      none: noneHandlers
    };
    files_default = esm_default("sbp/selectors/register", {
      "chelonia/fileUpload": async function(chunks, manifestOptions, { billableContractID } = {}) {
        if (!Array.isArray(chunks))
          chunks = [chunks];
        const chunkDescriptors = [];
        const cipherHandler = await cipherHandlers[manifestOptions.cipher]?.upload?.(this, manifestOptions);
        if (!cipherHandler)
          throw new Error("Unsupported cipher");
        const cipherParams = cipherHandler.cipherParams;
        const transferParts = await Promise.all(chunks.map(async (chunk, i2) => {
          const stream2 = chunk.stream();
          const encryptedStream = await cipherHandler.streamHandler(stream2);
          const [body, s] = encryptedStream.tee();
          chunkDescriptors.push(computeChunkDescriptors(s));
          return {
            headers: new Headers([
              ["content-disposition", `form-data; name="${i2}"; filename="${i2}"`],
              ["content-type", "application/octet-stream"]
            ]),
            body
          };
        }));
        transferParts.push({
          headers: new Headers([
            ["content-disposition", 'form-data; name="manifest"; filename="manifest.json"'],
            ["content-type", "application/vnd.shelter.filemanifest"]
          ]),
          body: new ReadableStream({
            async start(controller) {
              const chunks2 = await Promise.all(chunkDescriptors);
              const manifest2 = {
                version: "1.0.0",
                // ?? undefined coerces null and undefined to undefined
                // This ensures that null or undefined values don't make it to the
                // JSON (otherwise, null values _would_ be stringified as 'null')
                type: manifestOptions.type ?? void 0,
                meta: manifestOptions.meta ?? void 0,
                cipher: manifestOptions.cipher,
                "cipher-params": cipherParams,
                size: chunks2.reduce((acc, [cv]) => acc + cv, 0),
                chunks: chunks2,
                "name-map": manifestOptions["name-map"] ?? void 0,
                alternatives: manifestOptions.alternatives ?? void 0
              };
              controller.enqueue(Buffer4.from(JSON.stringify(manifest2)));
              controller.close();
            }
          })
        });
        const boundary = typeof self.crypto?.randomUUID === "function" ? self.crypto.randomUUID() : new Array(36).fill("").map(() => "abcdefghijklmnopqrstuvwxyz"[(0, Math.random)() * 26 | 0]).join("");
        const stream = x(boundary, transferParts);
        const deletionToken = "deletionToken" + generateSalt();
        const deletionTokenHash = blake32Hash2(deletionToken);
        const uploadResponse = await this.config.fetch(`${this.config.connectionURL}/file`, {
          method: "POST",
          signal: this.abortController.signal,
          body: await ArrayBufferToUint8ArrayStream.call(this, this.config.connectionURL, stream),
          headers: new Headers([
            ...billableContractID ? [["authorization", buildShelterAuthorizationHeader.call(this, billableContractID)]] : [],
            ["content-type", `multipart/form-data; boundary=${boundary}`],
            ["shelter-deletion-token-digest", deletionTokenHash]
          ]),
          duplex: "half"
        });
        if (!uploadResponse.ok)
          throw new Error("Error uploading file");
        return {
          download: {
            manifestCid: await uploadResponse.text(),
            downloadParams: cipherHandler.downloadParams
          },
          delete: deletionToken
        };
      },
      "chelonia/fileDownload": async function(downloadOptions, manifestChecker) {
        const { manifestCid, downloadParams } = downloadOptions.valueOf();
        const manifestResponse = await this.config.fetch(`${this.config.connectionURL}/file/${manifestCid}`, {
          method: "GET",
          signal: this.abortController.signal
        });
        if (!manifestResponse.ok) {
          throw new Error("Unable to retrieve manifest");
        }
        const manifestBinary = await manifestResponse.arrayBuffer();
        if (createCID2(coerce3(manifestBinary), multicodes2.SHELTER_FILE_MANIFEST) !== manifestCid) {
          throw new Error("mismatched manifest hash");
        }
        const manifest2 = JSON.parse(Buffer4.from(manifestBinary).toString());
        if (typeof manifest2 !== "object")
          throw new Error("manifest format is invalid");
        if (manifest2.version !== "1.0.0")
          throw new Error("unsupported manifest version");
        if (!Array.isArray(manifest2.chunks))
          throw new Error("missing required field: chunks");
        if (manifestChecker) {
          const proceed = await manifestChecker?.(manifest2);
          if (!proceed)
            return false;
        }
        const cipherHandler = await cipherHandlers[manifest2.cipher]?.download?.(this, downloadParams, manifest2);
        if (!cipherHandler)
          throw new Error("Unsupported cipher");
        return cipherHandler.payloadHandler();
      },
      "chelonia/fileDelete": async function(manifestCid, credentials = {}) {
        if (!manifestCid) {
          throw new TypeError("A manifest CID must be provided");
        }
        if (!Array.isArray(manifestCid))
          manifestCid = [manifestCid];
        return await Promise.allSettled(manifestCid.map(async (cid) => {
          const hasCredential = has(credentials, cid);
          const hasToken = has(credentials[cid], "token") && credentials[cid].token;
          const hasBillableContractID = has(credentials[cid], "billableContractID") && credentials[cid].billableContractID;
          if (!hasCredential || hasToken === hasBillableContractID) {
            throw new TypeError(`Either a token or a billable contract ID must be provided for ${cid}`);
          }
          const response = await this.config.fetch(`${this.config.connectionURL}/deleteFile/${cid}`, {
            method: "POST",
            signal: this.abortController.signal,
            headers: new Headers([
              [
                "authorization",
                hasToken ? `bearer ${credentials[cid].token.valueOf()}` : buildShelterAuthorizationHeader.call(this, credentials[cid].billableContractID)
              ]
            ])
          });
          if (!response.ok) {
            throw new Error(`Unable to delete file ${cid}`);
          }
        }));
      }
    });
  }
});
var headPrefix2;
var getContractIdFromLogHead;
var getLogHead;
var checkKey2;
var parsePrefixableKey;
var prefixHandlers;
var dbPrimitiveSelectors;
var db_default;
var init_db = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/db.mjs"() {
    init_esm7();
    init_esm6();
    init_esm3();
    init_SPMessage();
    init_errors();
    headPrefix2 = "head=";
    getContractIdFromLogHead = (key) => {
      if (!key.startsWith(headPrefix2))
        return;
      return key.slice(headPrefix2.length);
    };
    getLogHead = (contractID) => `${headPrefix2}${contractID}`;
    checkKey2 = (key) => {
      if (/[\x00-\x1f\x7f\t\\/<>:"|?*]/.test(key)) {
        throw new Error(`bad key: ${JSON.stringify(key)}`);
      }
    };
    parsePrefixableKey = (key) => {
      const i2 = key.indexOf(":");
      if (i2 === -1) {
        return ["", key];
      }
      const prefix = key.slice(0, i2 + 1);
      if (prefix in prefixHandlers) {
        return [prefix, key.slice(prefix.length)];
      }
      throw new ChelErrorDBConnection(`Unknown prefix in '${key}'.`);
    };
    prefixHandlers = {
      // Decode buffers, but don't transform other values.
      "": (value) => Buffer5.isBuffer(value) ? value.toString("utf8") : value,
      "any:": (value) => value
      /*
      // 2025-03-24: Commented out because it's not used; currently, only `any:`
      // is used in the `/file` route.
      // Throw if the value if not a buffer.
      'blob:': value => {
        if (Buffer.isBuffer(value)) {
          return value
        }
        throw new ChelErrorDBConnection('Unexpected value: expected a buffer.')
      }
      */
    };
    esm_default("sbp/selectors/unsafe", ["chelonia.db/get", "chelonia.db/set", "chelonia.db/delete"]);
    dbPrimitiveSelectors = process.env.LIGHTWEIGHT_CLIENT === "true" ? {
      "chelonia.db/get": function(key) {
        const id = getContractIdFromLogHead(key);
        if (!id)
          return Promise.resolve();
        const state = esm_default("chelonia/rootState").contracts[id];
        const value = state?.HEAD ? JSON.stringify({
          HEAD: state.HEAD,
          height: state.height,
          previousKeyOp: state.previousKeyOp
        }) : void 0;
        return Promise.resolve(value);
      },
      "chelonia.db/set": function() {
        return Promise.resolve();
      },
      "chelonia.db/delete": function() {
        return Promise.resolve(true);
      }
    } : {
      // eslint-disable-next-line require-await
      "chelonia.db/get": async function(prefixableKey) {
        const [prefix, key] = parsePrefixableKey(prefixableKey);
        const value = esm_default("okTurtles.data/get", key);
        if (value === void 0) {
          return;
        }
        return prefixHandlers[prefix](value);
      },
      // eslint-disable-next-line require-await
      "chelonia.db/set": async function(key, value) {
        checkKey2(key);
        return esm_default("okTurtles.data/set", key, value);
      },
      // eslint-disable-next-line require-await
      "chelonia.db/delete": async function(key) {
        return esm_default("okTurtles.data/delete", key);
      }
    };
    db_default = esm_default("sbp/selectors/register", {
      ...dbPrimitiveSelectors,
      "chelonia/db/getEntryMeta": async (contractID, height) => {
        const entryMetaJson = await esm_default("chelonia.db/get", `_private_hidx=${contractID}#${height}`);
        if (!entryMetaJson)
          return;
        return JSON.parse(entryMetaJson);
      },
      "chelonia/db/setEntryMeta": async (contractID, height, entryMeta) => {
        const entryMetaJson = JSON.stringify(entryMeta);
        await esm_default("chelonia.db/set", `_private_hidx=${contractID}#${height}`, entryMetaJson);
      },
      "chelonia/db/latestHEADinfo": async (contractID) => {
        const r = await esm_default("chelonia.db/get", getLogHead(contractID));
        return r && JSON.parse(r);
      },
      "chelonia/db/deleteLatestHEADinfo": (contractID) => {
        return esm_default("chelonia.db/set", getLogHead(contractID), "");
      },
      "chelonia/db/getEntry": async function(hash32) {
        try {
          const value = await esm_default("chelonia.db/get", hash32);
          if (!value)
            throw new Error(`no entry for ${hash32}!`);
          return SPMessage.deserialize(value, this.transientSecretKeys, void 0, this.config.unwrapMaybeEncryptedData);
        } catch (e2) {
          throw new ChelErrorDBConnection(`${e2.name} during getEntry: ${e2.message}`);
        }
      },
      "chelonia/db/addEntry": function(entry) {
        return esm_default("okTurtles.eventQueue/queueEvent", `chelonia/db/${entry.contractID()}`, ["chelonia/private/db/addEntry", entry]);
      },
      // NEVER call this directly yourself! _always_ call 'chelonia/db/addEntry' instead
      "chelonia/private/db/addEntry": async function(entry) {
        try {
          const { previousHEAD: entryPreviousHEAD, previousKeyOp: entryPreviousKeyOp, height: entryHeight } = entry.head();
          const contractID = entry.contractID();
          if (await esm_default("chelonia.db/get", entry.hash())) {
            console.warn(`[chelonia.db] entry exists: ${entry.hash()}`);
            return entry.hash();
          }
          const HEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
          if (!entry.isFirstMessage()) {
            if (!HEADinfo) {
              throw new Error(`No latest HEAD for ${contractID} when attempting to process entry with previous HEAD ${entryPreviousHEAD} at height ${entryHeight}`);
            }
            const { HEAD: contractHEAD, previousKeyOp: contractPreviousKeyOp, height: contractHeight } = HEADinfo;
            if (entryPreviousHEAD !== contractHEAD) {
              console.warn(`[chelonia.db] bad previousHEAD: ${entryPreviousHEAD}! Expected: ${contractHEAD} for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`bad previousHEAD: ${entryPreviousHEAD}. Expected ${contractHEAD} for contractID: ${contractID}`);
            } else if (entryPreviousKeyOp !== contractPreviousKeyOp) {
              console.error(`[chelonia.db] bad previousKeyOp: ${entryPreviousKeyOp}! Expected: ${contractPreviousKeyOp} for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`bad previousKeyOp: ${entryPreviousKeyOp}. Expected ${contractPreviousKeyOp} for contractID: ${contractID}`);
            } else if (!Number.isSafeInteger(entryHeight) || entryHeight !== contractHeight + 1) {
              console.error(`[chelonia.db] bad height: ${entryHeight}! Expected: ${contractHeight + 1} for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`[chelonia.db] bad height: ${entryHeight}! Expected: ${contractHeight + 1} for contractID: ${contractID}`);
            }
          } else {
            if (HEADinfo) {
              console.error(`[chelonia.db] bad previousHEAD: ${entryPreviousHEAD}! Expected: <null> for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`bad previousHEAD: ${entryPreviousHEAD}. Expected <null> for contractID: ${contractID}`);
            } else if (entryHeight !== 0) {
              console.error(`[chelonia.db] bad height: ${entryHeight}! Expected: 0 for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`[chelonia.db] bad height: ${entryHeight}! Expected: 0 for contractID: ${contractID}`);
            }
          }
          await esm_default("chelonia.db/set", entry.hash(), entry.serialize());
          await esm_default("chelonia.db/set", getLogHead(contractID), JSON.stringify({
            HEAD: entry.hash(),
            previousKeyOp: entry.isKeyOp() ? entry.hash() : entry.previousKeyOp(),
            height: entry.height()
          }));
          console.debug(`[chelonia.db] HEAD for ${contractID} updated to:`, entry.hash());
          await esm_default("chelonia/db/setEntryMeta", contractID, entryHeight, {
            // The hash is used for reverse lookups (height to CID)
            hash: entry.hash(),
            // The date isn't currently used, but will be used for filtering messages
            date: (/* @__PURE__ */ new Date()).toISOString(),
            // isKeyOp is used for filtering messages (the actual filtering is
            // done more efficiently a separate index key, but `isKeyOp` allows
            // us to bootstrap this process without having to load the full message)
            // The separate index key bears the prefix `_private_keyop_idx_`.
            ...entry.isKeyOp() && { isKeyOp: true }
          });
          return entry.hash();
        } catch (e2) {
          if (e2.name.includes("ErrorDB")) {
            throw e2;
          }
          throw new ChelErrorDBConnection(`${e2.name} during addEntry: ${e2.message}`);
        }
      },
      "chelonia/db/lastEntry": async function(contractID) {
        try {
          const latestHEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
          if (!latestHEADinfo)
            throw new Error(`contract ${contractID} has no latest hash!`);
          return esm_default("chelonia/db/getEntry", latestHEADinfo.HEAD);
        } catch (e2) {
          throw new ChelErrorDBConnection(`${e2.name} during lastEntry: ${e2.message}`);
        }
      }
    });
  }
});
var missingDecryptionKeyIdsMap;
var getMsgMeta;
var keysToMap;
var keyRotationHelper;
var internals_default;
var eventsToReingest;
var reprocessDebounced;
var handleEvent;
var notImplemented;
var init_internals = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/internals.mjs"() {
    init_esm3();
    init_functions();
    init_esm9();
    init_SPMessage();
    init_Secret();
    init_constants();
    init_esm2();
    init_db();
    init_encryptedData();
    init_errors();
    init_events2();
    init_utils2();
    init_signedData();
    missingDecryptionKeyIdsMap = /* @__PURE__ */ new WeakMap();
    getMsgMeta = function(message, contractID, state, index) {
      const signingKeyId = message.signingKeyId();
      let innerSigningKeyId = null;
      const config2 = this.config;
      const result = {
        signingKeyId,
        get signingContractID() {
          return getContractIDfromKeyId(contractID, signingKeyId, state);
        },
        get innerSigningKeyId() {
          if (innerSigningKeyId === null) {
            const value = message.message();
            const data = config2.unwrapMaybeEncryptedData(value);
            if (data?.data && isSignedData(data.data)) {
              innerSigningKeyId = data.data.signingKeyId;
            } else {
              innerSigningKeyId = void 0;
            }
            return innerSigningKeyId;
          }
        },
        get innerSigningContractID() {
          return getContractIDfromKeyId(contractID, result.innerSigningKeyId, state);
        },
        index
      };
      return result;
    };
    keysToMap = function(keys_, height, authorizedKeys) {
      const keys = keys_.map((key) => {
        const data = this.config.unwrapMaybeEncryptedData(key);
        if (!data)
          return void 0;
        if (data.encryptionKeyId) {
          data.data._private = data.encryptionKeyId;
        }
        return data.data;
      }).filter(Boolean);
      const keysCopy = cloneDeep(keys);
      return Object.fromEntries(keysCopy.map((key) => {
        key._notBeforeHeight = height;
        if (authorizedKeys?.[key.id]) {
          if (authorizedKeys[key.id]._notAfterHeight == null) {
            throw new ChelErrorKeyAlreadyExists(`Cannot set existing unrevoked key: ${key.id}`);
          }
          key._notBeforeHeight = Math.min(height, authorizedKeys[key.id]._notBeforeHeight ?? 0);
        } else {
          key._notBeforeHeight = height;
        }
        delete key._notAfterHeight;
        return [key.id, key];
      }));
    };
    keyRotationHelper = (contractID, state, config2, updatedKeysMap, requiredPermissions, outputSelector, outputMapper, internalSideEffectStack) => {
      if (!internalSideEffectStack || !Array.isArray(state._volatile?.watch))
        return;
      const rootState = esm_default(config2.stateSelector);
      const watchMap = /* @__PURE__ */ Object.create(null);
      state._volatile.watch.forEach(([name, cID]) => {
        if (!updatedKeysMap[name] || watchMap[cID] === null) {
          return;
        }
        if (!watchMap[cID]) {
          if (!rootState.contracts[cID]?.type || !findSuitableSecretKeyId(rootState[cID], [SPMessage.OP_KEY_UPDATE], ["sig"])) {
            watchMap[cID] = null;
            return;
          }
          watchMap[cID] = [];
        }
        watchMap[cID].push(name);
      });
      Object.entries(watchMap).forEach(([cID, names]) => {
        if (!Array.isArray(names) || !names.length)
          return;
        const [keyNamesToUpdate, signingKeyId] = names.map((name) => {
          const foreignContractKey = rootState[cID]?._vm?.authorizedKeys?.[updatedKeysMap[name].oldKeyId];
          if (!foreignContractKey)
            return void 0;
          const signingKeyId2 = findSuitableSecretKeyId(rootState[cID], requiredPermissions, ["sig"], foreignContractKey.ringLevel);
          if (signingKeyId2) {
            return [
              [name, foreignContractKey.name],
              signingKeyId2,
              rootState[cID]._vm.authorizedKeys[signingKeyId2].ringLevel
            ];
          }
          return void 0;
        }).filter(Boolean).reduce((acc, [name, signingKeyId2, ringLevel]) => {
          acc[0].push(name);
          return ringLevel < acc[2] ? [acc[0], signingKeyId2, ringLevel] : acc;
        }, [[], void 0, Number.POSITIVE_INFINITY]);
        if (!signingKeyId)
          return;
        const contractName = rootState.contracts[cID]?.type;
        internalSideEffectStack?.push(() => {
          esm_default(outputSelector, {
            contractID: cID,
            contractName,
            data: keyNamesToUpdate.map(outputMapper).map((v2) => {
              return v2;
            }),
            signingKeyId
          }).catch((e2) => {
            console.warn(`Error mirroring key operation (${outputSelector}) from ${contractID} to ${cID}: ${e2?.message || e2}`);
          });
        });
      });
    };
    internals_default = esm_default("sbp/selectors/register", {
      //     DO NOT CALL ANY OF THESE YOURSELF!
      "chelonia/private/state": function() {
        return this.state;
      },
      "chelonia/private/invoke": function(instance, invocation) {
        if (this._instance !== instance) {
          console.info("['chelonia/private/invoke] Not proceeding with invocation as Chelonia was restarted", { invocation });
          return;
        }
        if (Array.isArray(invocation)) {
          return esm_default(...invocation);
        } else if (typeof invocation === "function") {
          return invocation();
        } else {
          throw new TypeError(`[chelonia/private/invoke] Expected invocation to be an array or a function. Saw ${typeof invocation} instead.`);
        }
      },
      "chelonia/private/queueEvent": function(queueName, invocation) {
        return esm_default("okTurtles.eventQueue/queueEvent", queueName, [
          "chelonia/private/invoke",
          this._instance,
          invocation
        ]);
      },
      "chelonia/private/verifyManifestSignature": function(contractName, manifestHash, manifest2) {
        if (!has(manifest2, "signature") || typeof manifest2.signature.keyId !== "string" || typeof manifest2.signature.value !== "string") {
          throw new Error(`Invalid or missing signature field for manifest ${manifestHash} (named ${contractName})`);
        }
        const rootState = esm_default(this.config.stateSelector);
        if (!has(rootState, "contractSigningKeys")) {
          this.config.reactiveSet(rootState, "contractSigningKeys", /* @__PURE__ */ Object.create(null));
        }
        const contractNameLookupKey = `name:${contractName}`;
        let signatureValidated = false;
        if (process.env.UNSAFE_TRUST_ALL_MANIFEST_SIGNING_KEYS !== "true" && has(rootState.contractSigningKeys, contractNameLookupKey)) {
          console.info(`[chelonia] verifying signature for ${manifestHash} with an existing key`);
          if (!has(rootState.contractSigningKeys[contractNameLookupKey], manifest2.signature.keyId)) {
            console.error(`The manifest with ${manifestHash} (named ${contractName}) claims to be signed with a key with ID ${manifest2.signature.keyId}, which is not trusted. The trusted key IDs for this name are:`, Object.keys(rootState.contractSigningKeys[contractNameLookupKey]));
            throw new Error(`Invalid or missing signature in manifest ${manifestHash} (named ${contractName}). It claims to be signed with a key with ID ${manifest2.signature.keyId}, which has not been authorized for this contract before.`);
          }
          const signingKey = rootState.contractSigningKeys[contractNameLookupKey][manifest2.signature.keyId];
          verifySignature(signingKey, manifest2.body + manifest2.head, manifest2.signature.value);
          console.info(`[chelonia] successful signature verification for ${manifestHash} (named ${contractName}) using the already-trusted key ${manifest2.signature.keyId}.`);
          signatureValidated = true;
        }
        const body = JSON.parse(manifest2.body);
        if (!signatureValidated) {
          console.info(`[chelonia] verifying signature for ${manifestHash} (named ${contractName}) for the first time`);
          if (!has(body, "signingKeys") || !Array.isArray(body.signingKeys)) {
            throw new Error(`Invalid manifest file ${manifestHash} (named ${contractName}). Its body doesn't contain a 'signingKeys' list'`);
          }
          let contractSigningKeys;
          try {
            contractSigningKeys = Object.fromEntries(body.signingKeys.map((serializedKey) => {
              return [keyId(serializedKey), serializedKey];
            }));
          } catch (e2) {
            console.error(`[chelonia] Error parsing the public keys list for ${manifestHash} (named ${contractName})`, e2);
            throw e2;
          }
          if (!has(contractSigningKeys, manifest2.signature.keyId)) {
            throw new Error(`Invalid or missing signature in manifest ${manifestHash} (named ${contractName}). It claims to be signed with a key with ID ${manifest2.signature.keyId}, which is not listed in its 'signingKeys' field.`);
          }
          verifySignature(contractSigningKeys[manifest2.signature.keyId], manifest2.body + manifest2.head, manifest2.signature.value);
          console.info(`[chelonia] successful signature verification for ${manifestHash} (named ${contractName}) using ${manifest2.signature.keyId}. The following key IDs will now be trusted for this contract name`, Object.keys(contractSigningKeys));
          signatureValidated = true;
          rootState.contractSigningKeys[contractNameLookupKey] = contractSigningKeys;
        }
        return body;
      },
      "chelonia/private/loadManifest": async function(contractName, manifestHash) {
        if (!contractName || typeof contractName !== "string") {
          throw new Error("Invalid or missing contract name");
        }
        if (this.manifestToContract[manifestHash]) {
          console.warn("[chelonia]: already loaded manifest", manifestHash);
          return;
        }
        const manifestSource = await esm_default("chelonia/out/fetchResource", manifestHash, {
          code: multicodes2.SHELTER_CONTRACT_MANIFEST
        });
        const manifest2 = JSON.parse(manifestSource);
        const body = esm_default("chelonia/private/verifyManifestSignature", contractName, manifestHash, manifest2);
        if (body.name !== contractName) {
          throw new Error(`Mismatched contract name. Expected ${contractName} but got ${body.name}`);
        }
        const contractInfo = this.config.contracts.defaults.preferSlim && body.contractSlim || body.contract;
        console.info(`[chelonia] loading contract '${contractInfo.file}'@'${body.version}' from manifest: ${manifestHash}`);
        const source = await esm_default("chelonia/out/fetchResource", contractInfo.hash, {
          code: multicodes2.SHELTER_CONTRACT_TEXT
        });
        const reduceAllow = (acc, v2) => {
          acc[v2] = true;
          return acc;
        };
        const allowedSels = [
          "okTurtles.events/on",
          "chelonia/defineContract",
          "chelonia/out/keyRequest"
        ].concat(this.config.contracts.defaults.allowedSelectors).reduce(reduceAllow, {});
        const allowedDoms = this.config.contracts.defaults.allowedDomains.reduce(reduceAllow, {});
        const contractSBP = (selector, ...args) => {
          const domain = domainFromSelector(selector);
          if (selector.startsWith(contractName + "/")) {
            selector = `${manifestHash}/${selector}`;
          }
          if (allowedSels[selector] || allowedDoms[domain]) {
            return esm_default(selector, ...args);
          } else {
            console.error("[chelonia] selector not on allowlist", {
              selector,
              allowedSels,
              allowedDoms
            });
            throw new Error(`[chelonia] selector not on allowlist: '${selector}'`);
          }
        };
        const saferEval = new Function(`
      return function (globals) {
        // almost a real sandbox
        // stops (() => this)().fetch
        // needs additional step of locking down Function constructor to stop:
        // new (()=>{}).constructor("console.log(typeof this.fetch)")()
        globals.self = globals
        globals.globalThis = globals
        with (new Proxy(globals, {
          get (o, p) { return o[p] },
          has (o, p) { /* console.log('has', p); */ return true }
        })) {
          (function () {
            'use strict'
            ${source}
          })()
        }
      }
    `)();
        this.defContractSBP = contractSBP;
        this.defContractManifest = manifestHash;
        saferEval({
          // pass in globals that we want access to by default in the sandbox
          // note: you can undefine these by setting them to undefined in exposedGlobals
          crypto: {
            getRandomValues: (v2) => globalThis.crypto.getRandomValues(v2)
          },
          ...typeof window === "object" && window && {
            alert: window.alert.bind(window),
            confirm: window.confirm.bind(window),
            prompt: window.prompt.bind(window)
          },
          isNaN,
          console,
          Object,
          Error,
          TypeError,
          RangeError,
          Math,
          Symbol,
          Date,
          Array,
          BigInt,
          Boolean,
          String,
          Number,
          Int8Array,
          Int16Array,
          Int32Array,
          Uint8Array,
          Uint16Array,
          Uint32Array,
          Float32Array,
          Float64Array,
          ArrayBuffer,
          JSON,
          RegExp,
          parseFloat,
          parseInt,
          Promise,
          Function,
          Map,
          WeakMap,
          ...this.config.contracts.defaults.exposedGlobals,
          require: (dep) => {
            return dep === "@sbp/sbp" ? contractSBP : this.config.contracts.defaults.modules[dep];
          },
          sbp: contractSBP,
          fetchServerTime: async (fallback = true) => {
            try {
              const response = await this.config.fetch(`${this.config.connectionURL}/time`, {
                signal: this.abortController.signal
              });
              return handleFetchResult2("text")(response);
            } catch (e2) {
              console.warn("[fetchServerTime] Error", e2);
              if (fallback) {
                return new Date(esm_default("chelonia/time")).toISOString();
              }
              throw new ChelErrorFetchServerTimeFailed("Can not fetch server time. Please check your internet connection.");
            }
          }
        });
        if (contractName !== this.defContract.name) {
          throw new Error(`Invalid contract name for manifest ${manifestHash}. Expected ${contractName} but got ${this.defContract.name}`);
        }
        this.defContractSelectors.forEach((s) => {
          allowedSels[s] = true;
        });
        this.manifestToContract[manifestHash] = {
          slim: contractInfo === body.contractSlim,
          info: contractInfo,
          contract: this.defContract
        };
      },
      // Warning: avoid using this unless you know what you're doing. Prefer using /remove.
      "chelonia/private/removeImmediately": function(contractID, params) {
        const state = esm_default(this.config.stateSelector);
        const contractName = state.contracts[contractID]?.type;
        if (!contractName) {
          console.error("[chelonia/private/removeImmediately] Missing contract name for contract", {
            contractID
          });
          return;
        }
        const manifestHash = this.config.contracts.manifests[contractName];
        if (manifestHash) {
          const destructor = `${manifestHash}/${contractName}/_cleanup`;
          if (esm_default("sbp/selectors/fn", destructor)) {
            try {
              esm_default(destructor, { contractID, resync: !!params?.resync, state: state[contractID] });
            } catch (e2) {
              console.error(`[chelonia/private/removeImmediately] Error at destructor for ${contractID}`, e2);
            }
          }
        }
        if (params?.resync) {
          Object.keys(state.contracts[contractID]).filter((k) => k !== "references").forEach((k) => this.config.reactiveDel(state.contracts[contractID], k));
          Object.keys(state[contractID]).filter((k) => k !== "_volatile").forEach((k) => this.config.reactiveDel(state[contractID], k));
          if (state[contractID]._volatile) {
            Object.keys(state[contractID]._volatile).filter((k) => k !== "watch").forEach((k) => this.config.reactiveDel(state[contractID]._volatile, k));
          }
        } else {
          delete this.ephemeralReferenceCount[contractID];
          if (params?.permanent) {
            this.config.reactiveSet(state.contracts, contractID, null);
          } else {
            this.config.reactiveDel(state.contracts, contractID);
          }
          this.config.reactiveDel(state, contractID);
        }
        this.subscriptionSet.delete(contractID);
        esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
          added: [],
          removed: [contractID],
          permanent: params?.permanent,
          resync: params?.resync
        });
      },
      // used by, e.g. 'chelonia/contract/wait'
      "chelonia/private/noop": function() {
      },
      "chelonia/private/out/sync": function(contractIDs, params) {
        const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
        const forcedSync = !!params?.force;
        return Promise.all(listOfIds.map((contractID) => {
          if (!forcedSync && this.subscriptionSet.has(contractID)) {
            const rootState = esm_default(this.config.stateSelector);
            if (!rootState[contractID]?._volatile?.dirty) {
              return esm_default("chelonia/private/queueEvent", contractID, ["chelonia/private/noop"]);
            }
          }
          return esm_default("chelonia/private/queueEvent", contractID, [
            "chelonia/private/in/syncContract",
            contractID,
            params
          ]).catch((err) => {
            console.error(`[chelonia] failed to sync ${contractID}:`, err);
            throw err;
          });
        }));
      },
      "chelonia/private/out/publishEvent": function(entry, { maxAttempts = 5, headers, billableContractID, bearer, disableAutoDedup } = {}, hooks) {
        const contractID = entry.contractID();
        const originalEntry = entry;
        return esm_default("chelonia/private/queueEvent", `publish:${contractID}`, async () => {
          let attempt = 1;
          let lastAttemptedHeight;
          await hooks?.prepublish?.(entry);
          const onreceivedHandler = (_contractID, message) => {
            if (entry.hash() === message.hash()) {
              esm_default("okTurtles.events/off", EVENT_HANDLED, onreceivedHandler);
              hooks.onprocessed(entry);
            }
          };
          if (typeof hooks?.onprocessed === "function") {
            esm_default("okTurtles.events/on", EVENT_HANDLED, onreceivedHandler);
          }
          while (true) {
            lastAttemptedHeight = entry.height();
            const newEntry = await esm_default("chelonia/private/queueEvent", contractID, async () => {
              const rootState = esm_default(this.config.stateSelector);
              const state = rootState[contractID];
              const isFirstMessage = entry.isFirstMessage();
              if (!state && !isFirstMessage) {
                console.info(`[chelonia] Not sending message as contract state has been removed: ${entry.description()}`);
                return;
              }
              if (hooks?.preSendCheck) {
                if (!await hooks.preSendCheck(entry, state)) {
                  console.info(`[chelonia] Not sending message as preSendCheck hook returned non-truish value: ${entry.description()}`);
                  return;
                }
              }
              await esm_default("chelonia/private/in/processMessage", entry, cloneDeep(state || {}));
              if (!isFirstMessage) {
                return recreateEvent(entry, state, rootState.contracts[contractID], disableAutoDedup);
              }
              return entry;
            });
            if (!newEntry)
              return;
            await hooks?.beforeRequest?.(newEntry, entry);
            entry = newEntry;
            const r = await this.config.fetch(`${this.config.connectionURL}/event`, {
              method: "POST",
              body: entry.serialize(),
              headers: {
                ...headers,
                ...bearer && {
                  Authorization: `Bearer ${bearer}`
                },
                ...billableContractID && {
                  Authorization: buildShelterAuthorizationHeader.call(this, billableContractID)
                },
                "Content-Type": "text/plain"
              },
              signal: this.abortController.signal
            });
            if (r.ok) {
              await hooks?.postpublish?.(entry);
              return entry;
            }
            try {
              if (r.status === 409) {
                if (attempt + 1 > maxAttempts) {
                  console.error(`[chelonia] failed to publish ${entry.description()} after ${attempt} attempts`, entry);
                  throw new Error(`publishEvent: ${r.status} - ${r.statusText}. attempt ${attempt}`);
                }
                const randDelay = randomIntFromRange(0, 1500);
                console.warn(`[chelonia] publish attempt ${attempt} of ${maxAttempts} failed. Waiting ${randDelay} msec before resending ${entry.description()}`);
                attempt += 1;
                await delay(randDelay);
                if (!entry.isFirstMessage() && entry.height() === lastAttemptedHeight) {
                  await esm_default("chelonia/private/out/sync", contractID, { force: true });
                }
              } else {
                const message = (await r.json())?.message;
                console.error(`[chelonia] ERROR: failed to publish ${entry.description()}: ${r.status} - ${r.statusText}: ${message}`, entry);
                throw new Error(`publishEvent: ${r.status} - ${r.statusText}: ${message}`);
              }
            } catch (e2) {
              esm_default("okTurtles.events/off", EVENT_HANDLED, onreceivedHandler);
              throw e2;
            }
          }
        }).then((entry2) => {
          esm_default("okTurtles.events/emit", EVENT_PUBLISHED, {
            contractID,
            message: entry2,
            originalMessage: originalEntry
          });
          return entry2;
        }).catch((e2) => {
          esm_default("okTurtles.events/emit", EVENT_PUBLISHING_ERROR, {
            contractID,
            message: entry,
            originalMessage: originalEntry,
            error: e2
          });
          throw e2;
        });
      },
      "chelonia/private/out/latestHEADinfo": function(contractID) {
        return this.config.fetch(`${this.config.connectionURL}/latestHEADinfo/${contractID}`, {
          cache: "no-store",
          signal: this.abortController.signal
        }).then(handleFetchResult2("json"));
      },
      "chelonia/private/postKeyShare": function(contractID, previousVolatileState, signingKey) {
        const cheloniaState = esm_default(this.config.stateSelector);
        const targetState = cheloniaState[contractID];
        if (!targetState)
          return;
        if (previousVolatileState && has(previousVolatileState, "watch")) {
          if (!targetState._volatile) {
            this.config.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
          }
          if (!targetState._volatile.watch) {
            this.config.reactiveSet(targetState._volatile, "watch", previousVolatileState.watch);
          } else if (targetState._volatile.watch !== previousVolatileState.watch) {
            previousVolatileState.watch.forEach((pWatch) => {
              if (!targetState._volatile.watch.some((tWatch) => {
                return tWatch[0] === pWatch[0] && tWatch[1] === pWatch[1];
              })) {
                targetState._volatile.watch.push(pWatch);
              }
            });
          }
        }
        if (!Array.isArray(targetState._volatile?.pendingKeyRequests))
          return;
        this.config.reactiveSet(targetState._volatile, "pendingKeyRequests", targetState._volatile.pendingKeyRequests.filter((pkr) => pkr?.name !== signingKey.name));
      },
      "chelonia/private/in/processMessage": async function(message, state, internalSideEffectStack, contractName) {
        const [opT, opV] = message.op();
        const hash32 = message.hash();
        const height = message.height();
        const contractID = message.contractID();
        const manifestHash = message.manifest();
        const signingKeyId = message.signingKeyId();
        const direction = message.direction();
        const config2 = this.config;
        const self2 = this;
        const opName = Object.entries(SPMessage).find(([, y]) => y === opT)?.[0];
        console.debug("PROCESSING OPCODE:", opName, "to", contractID);
        if (state?._volatile?.dirty) {
          console.debug("IGNORING OPCODE BECAUSE CONTRACT STATE IS MARKED AS DIRTY.", "OPCODE:", opName, "CONTRACT:", contractID);
          return;
        }
        if (!state._vm)
          state._vm = /* @__PURE__ */ Object.create(null);
        const opFns = {
          /*
            There are two types of "errors" that we need to consider:
            1. "Ignoring" errors
            2. "Failure" errors
            Example: OP_KEY_ADD
            1. IGNORING: an error is thrown because we wanted to add a key but the
            key we wanted to add is already there. This is not a hard error, it's an
            ignoring error. We don't care that the operation failed in this case because the intent was accomplished.
            2. FAILURE: an error is thrown while attempting to add a key that doesn't exist.
            Example: OP_ACTION_ENCRYPTED
            1. IGNORING: An error is thrown because we don't have the key to decrypt the action. We ignore it.
            2. FAILURE: An error is thrown by the process function during processing.
            Handling these in OP_ATOMIC
            • ALL errors of class "IGNORING" should be ignored. They should not
            impact our ability to process the rest of the operations in the OP_ATOMIC.
            No matter how many of these are thrown, it doesn't affect the rest of the operations.
            • ANY error of class "FAILURE" will call the rest of the operations to
            fail and the state to be reverted to prior to the OP_ATOMIC. No side-effects should be run. Because an intention failed.
          */
          async [SPMessage.OP_ATOMIC](v2) {
            for (let i2 = 0; i2 < v2.length; i2++) {
              const u2 = v2[i2];
              try {
                if (u2[0] === SPMessage.OP_ATOMIC)
                  throw new Error("Cannot nest OP_ATOMIC");
                if (!validateKeyPermissions(message, config2, state, signingKeyId, u2[0], u2[1])) {
                  throw new Error("Inside OP_ATOMIC: no matching signing key was defined");
                }
                await opFns[u2[0]](u2[1]);
              } catch (e_) {
                const e2 = e_;
                if (e2 && typeof e2 === "object") {
                  if (e2.name === "ChelErrorDecryptionKeyNotFound") {
                    console.warn(`[chelonia] [OP_ATOMIC] WARN '${e2.name}' in processMessage for ${message.description()}: ${e2.message}`, e2, message.serialize());
                    if (e2.cause) {
                      const missingDecryptionKeyIds = missingDecryptionKeyIdsMap.get(message);
                      if (missingDecryptionKeyIds) {
                        missingDecryptionKeyIds.add(e2.cause);
                      } else {
                        missingDecryptionKeyIdsMap.set(message, /* @__PURE__ */ new Set([e2.cause]));
                      }
                    }
                    continue;
                  } else {
                    logEvtError(message, `[chelonia] [OP_ATOMIC] ERROR '${e2.name}' in processMessage for ${message.description()}: ${e2.message || e2}`, e2, message.serialize());
                  }
                  console.warn(`[chelonia] [OP_ATOMIC] Error processing ${message.description()}: ${message.serialize()}. Any side effects will be skipped!`);
                  if (config2.strictProcessing) {
                    throw e2;
                  }
                  config2.hooks.processError?.(e2, message, getMsgMeta.call(self2, message, contractID, state));
                  if (e2.name === "ChelErrorWarning")
                    continue;
                } else {
                  logEvtError(message, "Inside OP_ATOMIC: Non-object or null error thrown", contractID, message, i2, e2);
                }
                throw e2;
              }
            }
          },
          [SPMessage.OP_CONTRACT](v2) {
            state._vm.type = v2.type;
            const keys = keysToMap.call(self2, v2.keys, height);
            state._vm.authorizedKeys = keys;
            keyAdditionProcessor.call(self2, message, hash32, v2.keys, state, contractID, signingKey, internalSideEffectStack);
          },
          [SPMessage.OP_ACTION_ENCRYPTED](v2) {
            if (config2.skipActionProcessing) {
              if (!config2.skipDecryptionAttempts) {
                console.log("OP_ACTION_ENCRYPTED: skipped action processing");
              }
              return;
            }
            return opFns[SPMessage.OP_ACTION_UNENCRYPTED](v2.valueOf());
          },
          async [SPMessage.OP_ACTION_UNENCRYPTED](v2) {
            if (!config2.skipActionProcessing) {
              let innerSigningKeyId;
              if (isSignedData(v2)) {
                innerSigningKeyId = v2.signingKeyId;
                v2 = v2.valueOf();
              }
              const { data, meta, action } = v2;
              if (!config2.whitelisted(action)) {
                throw new Error(`chelonia: action not whitelisted: '${action}'`);
              }
              await esm_default(`${manifestHash}/${action}/process`, {
                data,
                meta,
                hash: hash32,
                height,
                contractID,
                direction: message.direction(),
                signingKeyId,
                get signingContractID() {
                  return getContractIDfromKeyId(contractID, signingKeyId, state);
                },
                innerSigningKeyId,
                get innerSigningContractID() {
                  return getContractIDfromKeyId(contractID, innerSigningKeyId, state);
                }
              }, state);
            }
          },
          [SPMessage.OP_KEY_SHARE](wv) {
            const data = config2.unwrapMaybeEncryptedData(wv);
            if (!data)
              return;
            const v2 = data.data;
            for (const key of v2.keys) {
              if (key.id && key.meta?.private?.content) {
                if (!has(state._vm, "sharedKeyIds"))
                  state._vm.sharedKeyIds = [];
                if (!state._vm.sharedKeyIds.some((sK) => sK.id === key.id)) {
                  state._vm.sharedKeyIds.push({
                    id: key.id,
                    contractID: v2.contractID,
                    height,
                    keyRequestHash: v2.keyRequestHash,
                    keyRequestHeight: v2.keyRequestHeight
                  });
                }
              }
            }
            if (has(v2, "keyRequestHash") && state._vm.authorizedKeys[signingKeyId].meta?.keyRequest) {
              state._vm.authorizedKeys[signingKeyId].meta.keyRequest.responded = hash32;
            }
            internalSideEffectStack?.push(async () => {
              delete self2.postSyncOperations[contractID]?.["pending-keys-for-" + v2.contractID];
              const cheloniaState = esm_default(self2.config.stateSelector);
              const targetState = cheloniaState[v2.contractID];
              const missingDecryptionKeyIds = cheloniaState.contracts[v2.contractID]?.missingDecryptionKeyIds;
              let newestEncryptionKeyHeight = Number.POSITIVE_INFINITY;
              for (const key of v2.keys) {
                if (key.id && key.meta?.private?.content) {
                  const transient = direction === "outgoing" || key.meta.private.transient;
                  if (!esm_default("chelonia/haveSecretKey", key.id, !transient)) {
                    try {
                      const decrypted = key.meta.private.content.valueOf();
                      esm_default("chelonia/storeSecretKeys", new Secret([
                        {
                          key: deserializeKey(decrypted),
                          transient
                        }
                      ]));
                      if (missingDecryptionKeyIds?.includes(key.id)) {
                        newestEncryptionKeyHeight = Number.NEGATIVE_INFINITY;
                      } else if (
                        // Otherwise, we make an educated guess on whether a re-sync
                        // is needed based on the height.
                        targetState?._vm?.authorizedKeys?.[key.id]?._notBeforeHeight != null && Array.isArray(targetState._vm.authorizedKeys[key.id].purpose) && targetState._vm.authorizedKeys[key.id].purpose.includes("enc")
                      ) {
                        newestEncryptionKeyHeight = Math.min(newestEncryptionKeyHeight, targetState._vm.authorizedKeys[key.id]._notBeforeHeight);
                      }
                    } catch (e_) {
                      const e2 = e_;
                      if (e2?.name === "ChelErrorDecryptionKeyNotFound") {
                        console.warn(`OP_KEY_SHARE (${hash32} of ${contractID}) missing secret key: ${e2.message}`, e2);
                      } else {
                        console.error(`OP_KEY_SHARE (${hash32} of ${contractID}) error '${e2.message || e2}':`, e2);
                      }
                    }
                  }
                }
              }
              const mustResync = !!(newestEncryptionKeyHeight < cheloniaState.contracts[v2.contractID]?.height);
              if (mustResync) {
                if (!has(targetState, "_volatile")) {
                  config2.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
                }
                config2.reactiveSet(targetState._volatile, "dirty", true);
                if (!Object.keys(targetState).some((k) => k !== "_volatile")) {
                  return;
                }
                const keyDict = /* @__PURE__ */ Object.create(null);
                targetState._volatile?.watch?.forEach(([keyName, contractID2]) => {
                  if (!keyDict[keyName]) {
                    keyDict[keyName] = [contractID2];
                    return;
                  }
                  keyDict[keyName].push(contractID2);
                });
                const contractIdsToUpdate = Array.from(new Set(Object.entries(keyDict).flatMap(([keyName, contractIDs]) => {
                  const keyId2 = findKeyIdByName(targetState, keyName);
                  if (
                    // Does the key exist? (i.e., is it a current key)
                    keyId2 && // Is it an encryption key? (signing keys don't build up a
                    // potentially invalid state because the private key isn't
                    // required for validation; however, missing encryption keys
                    // prevent message processing)
                    targetState._vm.authorizedKeys[keyId2].purpose.includes("enc") && // Is this a newly set key? (avoid re-syncing contracts that
                    // haven't been affected by the `OP_KEY_SHARE`)
                    targetState._vm.authorizedKeys[keyId2]._notBeforeHeight >= newestEncryptionKeyHeight
                  ) {
                    return contractIDs;
                  }
                  return [];
                })));
                contractIdsToUpdate.forEach((contractID2) => {
                  const targetState2 = cheloniaState[contractID2];
                  if (!targetState2)
                    return;
                  if (!has(targetState2, "_volatile")) {
                    config2.reactiveSet(targetState2, "_volatile", /* @__PURE__ */ Object.create(null));
                  }
                  config2.reactiveSet(targetState2._volatile, "dirty", true);
                });
                if (self2.subscriptionSet.has(v2.contractID)) {
                  const resync = esm_default("chelonia/private/queueEvent", v2.contractID, [
                    "chelonia/private/in/syncContract",
                    v2.contractID
                  ]).then(() => {
                    esm_default("chelonia/private/out/sync", contractIdsToUpdate.filter((contractID2) => {
                      return self2.subscriptionSet.has(contractID2);
                    }), { force: true, resync: true }).catch((e2) => {
                      console.error("[chelonia] Error resyncing contracts with foreign key references after key rotation", e2);
                    });
                  }).catch((e2) => {
                    console.error(`[chelonia] Error during sync for ${v2.contractID} during OP_KEY_SHARE for ${contractID}`);
                    if (v2.contractID === contractID) {
                      throw e2;
                    }
                  });
                  if (v2.contractID !== contractID) {
                    await resync;
                  }
                }
              }
              const previousVolatileState = targetState?._volatile;
              esm_default("chelonia/private/queueEvent", v2.contractID, [
                "chelonia/private/postKeyShare",
                v2.contractID,
                mustResync ? previousVolatileState : null,
                signingKey
              ]).then(() => {
                esm_default("chelonia/private/queueEvent", contractID, () => {
                  esm_default("okTurtles.events/emit", CONTRACT_HAS_RECEIVED_KEYS, {
                    contractID: v2.contractID,
                    sharedWithContractID: contractID,
                    signingKeyId,
                    get signingKeyName() {
                      return state._vm?.authorizedKeys?.[signingKeyId]?.name;
                    }
                  });
                }).catch((e2) => {
                  console.error(`[chelonia] Error while emitting the CONTRACT_HAS_RECEIVED_KEYS event for ${contractID}`, e2);
                });
              });
            });
          },
          [SPMessage.OP_KEY_REQUEST](wv) {
            const data = config2.unwrapMaybeEncryptedData(wv);
            const v2 = data?.data || {
              contractID: "(private)",
              replyWith: { context: void 0 },
              request: "*"
            };
            const originatingContractID = v2.contractID;
            if (state._vm?.invites?.[signingKeyId]?.quantity != null) {
              if (state._vm.invites[signingKeyId].quantity > 0) {
                if (--state._vm.invites[signingKeyId].quantity <= 0) {
                  state._vm.invites[signingKeyId].status = INVITE_STATUS.USED;
                }
              } else {
                logEvtError(message, "Ignoring OP_KEY_REQUEST because it exceeds allowed quantity: " + originatingContractID);
                return;
              }
            }
            if (state._vm?.invites?.[signingKeyId]?.expires != null) {
              if (state._vm.invites[signingKeyId].expires < Date.now()) {
                logEvtError(message, "Ignoring OP_KEY_REQUEST because it expired at " + state._vm.invites[signingKeyId].expires + ": " + originatingContractID);
                return;
              }
            }
            if (config2.skipActionProcessing || direction === "outgoing") {
              return;
            }
            if (!has(v2.replyWith, "context")) {
              logEvtError(message, "Ignoring OP_KEY_REQUEST because it is missing the context attribute");
              return;
            }
            const context = v2.replyWith.context;
            if (data && (!Array.isArray(context) || context[0] !== originatingContractID)) {
              logEvtError(message, "Ignoring OP_KEY_REQUEST because it is signed by the wrong contract");
              return;
            }
            if (v2.request !== "*") {
              logEvtError(message, "Ignoring OP_KEY_REQUEST because it has an unsupported request attribute", v2.request);
              return;
            }
            if (!state._vm.pendingKeyshares)
              state._vm.pendingKeyshares = /* @__PURE__ */ Object.create(null);
            state._vm.pendingKeyshares[message.hash()] = context ? [
              // Full-encryption (i.e., KRS encryption) requires that this request
              // was encrypted and that the invite is marked as private
              !!data?.encryptionKeyId,
              message.height(),
              signingKeyId,
              context
            ] : [!!data?.encryptionKeyId, message.height(), signingKeyId];
            if (data) {
              internalSideEffectStack?.push(() => {
                self2.setPostSyncOp(contractID, "respondToAllKeyRequests-" + message.contractID(), [
                  "chelonia/private/respondToAllKeyRequests",
                  contractID
                ]);
              });
            }
          },
          [SPMessage.OP_KEY_REQUEST_SEEN](wv) {
            if (config2.skipActionProcessing) {
              return;
            }
            const data = config2.unwrapMaybeEncryptedData(wv);
            if (!data)
              return;
            const v2 = data.data;
            if (state._vm.pendingKeyshares && v2.keyRequestHash in state._vm.pendingKeyshares) {
              const hash4 = v2.keyRequestHash;
              const pending = state._vm.pendingKeyshares[hash4];
              delete state._vm.pendingKeyshares[hash4];
              if (pending.length !== 4)
                return;
              const keyId2 = pending[2];
              const originatingContractID = pending[3][0];
              if (Array.isArray(state._vm?.invites?.[keyId2]?.responses)) {
                state._vm?.invites?.[keyId2]?.responses.push(originatingContractID);
              }
              if (!has(state._vm, "keyshares"))
                state._vm.keyshares = /* @__PURE__ */ Object.create(null);
              const success = v2.success;
              state._vm.keyshares[hash4] = {
                contractID: originatingContractID,
                height,
                success,
                ...success && {
                  hash: v2.keyShareHash
                }
              };
            }
          },
          [SPMessage.OP_PROP_DEL]: notImplemented,
          [SPMessage.OP_PROP_SET](v2) {
            if (!state._vm.props)
              state._vm.props = {};
            state._vm.props[v2.key] = v2.value;
          },
          [SPMessage.OP_KEY_ADD](v2) {
            const keys = keysToMap.call(self2, v2, height, state._vm.authorizedKeys);
            const keysArray = Object.values(v2);
            keysArray.forEach((k) => {
              if (has(state._vm.authorizedKeys, k.id) && state._vm.authorizedKeys[k.id]._notAfterHeight == null) {
                throw new ChelErrorWarning("Cannot use OP_KEY_ADD on existing keys. Key ID: " + k.id);
              }
            });
            validateKeyAddPermissions.call(self2, contractID, signingKey, state, v2);
            state._vm.authorizedKeys = { ...state._vm.authorizedKeys, ...keys };
            keyAdditionProcessor.call(self2, message, hash32, v2, state, contractID, signingKey, internalSideEffectStack);
          },
          [SPMessage.OP_KEY_DEL](v2) {
            if (!state._vm.authorizedKeys)
              state._vm.authorizedKeys = /* @__PURE__ */ Object.create(null);
            if (!state._volatile)
              state._volatile = /* @__PURE__ */ Object.create(null);
            if (!state._volatile.pendingKeyRevocations) {
              state._volatile.pendingKeyRevocations = /* @__PURE__ */ Object.create(null);
            }
            validateKeyDelPermissions.call(self2, contractID, signingKey, state, v2);
            const keyIds = v2.map((k) => {
              const data = config2.unwrapMaybeEncryptedData(k);
              if (!data)
                return void 0;
              return data.data;
            }).filter((keyId2) => {
              if (!keyId2 || typeof keyId2 !== "string")
                return false;
              if (!has(state._vm.authorizedKeys, keyId2) || state._vm.authorizedKeys[keyId2]._notAfterHeight != null) {
                console.warn("Attempted to delete non-existent key from contract", {
                  contractID,
                  keyId: keyId2
                });
                return false;
              }
              return true;
            });
            keyIds.forEach((keyId2) => {
              const key = state._vm.authorizedKeys[keyId2];
              state._vm.authorizedKeys[keyId2]._notAfterHeight = height;
              if (has(state._volatile.pendingKeyRevocations, keyId2)) {
                delete state._volatile.pendingKeyRevocations[keyId2];
              }
              if (key.foreignKey) {
                const fkUrl = new URL(key.foreignKey);
                const foreignContract = fkUrl.pathname;
                const foreignKeyName = fkUrl.searchParams.get("keyName");
                if (!foreignContract || !foreignKeyName) {
                  throw new Error("Invalid foreign key: missing contract or key name");
                }
                internalSideEffectStack?.push(() => {
                  esm_default("chelonia/private/queueEvent", foreignContract, () => {
                    const rootState = esm_default(config2.stateSelector);
                    if (Array.isArray(rootState[foreignContract]?._volatile?.watch)) {
                      const oldWatch = rootState[foreignContract]._volatile.watch;
                      rootState[foreignContract]._volatile.watch = oldWatch.filter(([name, cID]) => name !== foreignKeyName || cID !== contractID);
                      if (oldWatch.length !== rootState[foreignContract]._volatile.watch.length) {
                        esm_default("chelonia/contract/release", foreignContract, { try: true }).catch((e2) => {
                          console.error(`[chelonia] Error at OP_KEY_DEL internalSideEffectStack while attempting to release foreign contract ${foreignContract}`, e2);
                        });
                      }
                    }
                  }).catch((e2) => {
                    console.error("Error stopping watching events after removing key", { contractID, foreignContract, foreignKeyName, fkUrl }, e2);
                  });
                });
                const pendingWatch = state._vm.pendingWatch?.[foreignContract];
                if (pendingWatch) {
                  state._vm.pendingWatch[foreignContract] = pendingWatch.filter(([, kId]) => kId !== keyId2);
                }
              }
              if (key.name.startsWith("#inviteKey-") && state._vm.invites[key.id]) {
                state._vm.invites[key.id].status = INVITE_STATUS.REVOKED;
              }
            });
            if (Array.isArray(state._volatile?.watch)) {
              const updatedKeysMap = /* @__PURE__ */ Object.create(null);
              keyIds.forEach((keyId2) => {
                updatedKeysMap[state._vm.authorizedKeys[keyId2].name] = {
                  name: state._vm.authorizedKeys[keyId2].name,
                  oldKeyId: keyId2
                };
              });
              keyRotationHelper(contractID, state, config2, updatedKeysMap, [SPMessage.OP_KEY_DEL], "chelonia/out/keyDel", (name) => updatedKeysMap[name[0]].oldKeyId, internalSideEffectStack);
            }
          },
          [SPMessage.OP_KEY_UPDATE](v2) {
            if (!state._volatile)
              state._volatile = /* @__PURE__ */ Object.create(null);
            if (!state._volatile.pendingKeyRevocations) {
              state._volatile.pendingKeyRevocations = /* @__PURE__ */ Object.create(null);
            }
            const [updatedKeys, updatedMap] = validateKeyUpdatePermissions.call(self2, contractID, signingKey, state, v2);
            const keysToDelete = Object.values(updatedMap);
            for (const keyId2 of keysToDelete) {
              if (has(state._volatile.pendingKeyRevocations, keyId2)) {
                delete state._volatile.pendingKeyRevocations[keyId2];
              }
              state._vm.authorizedKeys[keyId2]._notAfterHeight = height;
            }
            for (const key of updatedKeys) {
              if (!has(state._vm.authorizedKeys, key.id)) {
                key._notBeforeHeight = height;
                state._vm.authorizedKeys[key.id] = cloneDeep(key);
              }
            }
            keyAdditionProcessor.call(self2, message, hash32, updatedKeys, state, contractID, signingKey, internalSideEffectStack);
            if (Array.isArray(state._volatile?.watch)) {
              const updatedKeysMap = /* @__PURE__ */ Object.create(null);
              updatedKeys.forEach((key) => {
                if (key.data) {
                  updatedKeysMap[key.name] = cloneDeep(key);
                  updatedKeysMap[key.name].oldKeyId = updatedMap[key.id];
                }
              });
              keyRotationHelper(contractID, state, config2, updatedKeysMap, [SPMessage.OP_KEY_UPDATE], "chelonia/out/keyUpdate", (name) => ({
                name: name[1],
                oldKeyId: updatedKeysMap[name[0]].oldKeyId,
                id: updatedKeysMap[name[0]].id,
                data: updatedKeysMap[name[0]].data
              }), internalSideEffectStack);
            }
          },
          [SPMessage.OP_PROTOCOL_UPGRADE]: notImplemented
        };
        if (!this.config.skipActionProcessing && !this.manifestToContract[manifestHash]) {
          const rootState = esm_default(this.config.stateSelector);
          if (!contractName) {
            contractName = has(rootState.contracts, contractID) && rootState.contracts[contractID] && has(rootState.contracts[contractID], "type") ? rootState.contracts[contractID].type : opT === SPMessage.OP_CONTRACT ? opV.type : "";
          }
          if (!contractName) {
            throw new Error(`Unable to determine the name for a contract and refusing to load it (contract ID was ${contractID} and its manifest hash was ${manifestHash})`);
          }
          await esm_default("chelonia/private/loadManifest", contractName, manifestHash);
        }
        let processOp = true;
        if (config2.preOp) {
          processOp = config2.preOp(message, state) !== false && processOp;
        }
        let signingKey;
        {
          const stateForValidation = opT === SPMessage.OP_CONTRACT && !state?._vm?.authorizedKeys ? {
            _vm: {
              authorizedKeys: keysToMap.call(this, opV.keys, height)
            }
          } : state;
          if (!validateKeyPermissions(message, config2, stateForValidation, signingKeyId, opT, opV)) {
            throw new Error("No matching signing key was defined");
          }
          signingKey = stateForValidation._vm.authorizedKeys[signingKeyId];
        }
        if (config2[`preOp_${opT}`]) {
          processOp = config2[`preOp_${opT}`](message, state) !== false && processOp;
        }
        if (processOp) {
          await opFns[opT](opV);
          config2.postOp?.(message, state);
          config2[`postOp_${opT}`]?.(message, state);
        }
      },
      "chelonia/private/in/enqueueHandleEvent": function(contractID, event) {
        return esm_default("chelonia/private/queueEvent", contractID, async () => {
          await esm_default("chelonia/private/in/handleEvent", contractID, event);
          esm_default("chelonia/private/enqueuePostSyncOps", contractID);
        });
      },
      "chelonia/private/in/syncContract": async function(contractID, params) {
        const state = esm_default(this.config.stateSelector);
        if (state.contracts[contractID] === null) {
          throw new ChelErrorResourceGone("Cannot sync permanently deleted contract " + contractID);
        }
        try {
          this.currentSyncs[contractID] = { firstSync: !state.contracts[contractID]?.type };
          esm_default("okTurtles.events/emit", CONTRACT_IS_SYNCING, contractID, true);
          const currentVolatileState = state[contractID]?._volatile || /* @__PURE__ */ Object.create(null);
          if (currentVolatileState?.dirty || params?.resync) {
            delete currentVolatileState.dirty;
            currentVolatileState.resyncing = true;
            esm_default("chelonia/private/removeImmediately", contractID, { resync: true });
            this.config.reactiveSet(state, contractID, /* @__PURE__ */ Object.create(null));
            this.config.reactiveSet(state[contractID], "_volatile", currentVolatileState);
          }
          const { HEAD: latestHEAD } = await esm_default("chelonia/out/latestHEADInfo", contractID);
          console.debug(`[chelonia] syncContract: ${contractID} latestHash is: ${latestHEAD}`);
          const { HEAD: recentHEAD, height: recentHeight } = state.contracts[contractID] || {};
          const isSubscribed = this.subscriptionSet.has(contractID);
          if (!isSubscribed) {
            const entry = this.pending.find((entry2) => entry2?.contractID === contractID);
            if (!entry) {
              this.pending.push({ contractID });
            }
          }
          this.postSyncOperations[contractID] = this.postSyncOperations[contractID] ?? /* @__PURE__ */ Object.create(null);
          if (latestHEAD !== recentHEAD) {
            console.debug(`[chelonia] Synchronizing Contract ${contractID}: our recent was ${recentHEAD || "undefined"} but the latest is ${latestHEAD}`);
            const eventsStream = esm_default("chelonia/out/eventsAfter", contractID, {
              sinceHeight: recentHeight ?? 0,
              sinceHash: recentHEAD ?? contractID
            });
            let latestHashFound = false;
            const eventReader = eventsStream.getReader();
            for (let skip = has(state.contracts, contractID) && has(state.contracts[contractID], "HEAD"); ; skip = false) {
              const { done, value: event } = await eventReader.read();
              if (done) {
                if (!latestHashFound) {
                  throw new ChelErrorForkedChain(`expected hash ${latestHEAD} in list of events for contract ${contractID}`);
                }
                break;
              }
              if (!latestHashFound) {
                latestHashFound = SPMessage.deserializeHEAD(event).hash === latestHEAD;
              }
              if (skip)
                continue;
              await esm_default("chelonia/private/in/handleEvent", contractID, event);
            }
          } else if (!isSubscribed) {
            this.subscriptionSet.add(contractID);
            esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
              added: [contractID],
              removed: []
            });
            const entryIndex = this.pending.findIndex((entry) => entry?.contractID === contractID);
            if (entryIndex !== -1) {
              this.pending.splice(entryIndex, 1);
            }
            console.debug(`[chelonia] added already synchronized ${contractID} to subscription set`);
          } else {
            console.debug(`[chelonia] contract ${contractID} was already synchronized`);
          }
          esm_default("chelonia/private/enqueuePostSyncOps", contractID);
        } catch (e2) {
          console.error(`[chelonia] syncContract error: ${e2.message || e2}`, e2);
          this.config.hooks.syncContractError?.(e2, contractID);
          throw e2;
        } finally {
          if (state[contractID]?._volatile?.resyncing) {
            this.config.reactiveDel(state[contractID]._volatile, "resyncing");
          }
          delete this.currentSyncs[contractID];
          esm_default("okTurtles.events/emit", CONTRACT_IS_SYNCING, contractID, false);
        }
      },
      "chelonia/private/enqueuePostSyncOps": function(contractID) {
        if (!has(this.postSyncOperations, contractID))
          return;
        Object.entries(this.postSyncOperations[contractID]).forEach(([key, op]) => {
          delete this.postSyncOperations[contractID][key];
          esm_default("chelonia/private/queueEvent", contractID, op).catch((e2) => {
            console.error(`Post-sync operation for ${contractID} failed`, { contractID, op, error: e2 });
          });
        });
      },
      "chelonia/private/watchForeignKeys": function(externalContractID) {
        const state = esm_default(this.config.stateSelector);
        const externalContractState = state[externalContractID];
        const pendingWatch = externalContractState?._vm?.pendingWatch;
        if (!pendingWatch || !Object.keys(pendingWatch).length)
          return;
        const signingKey = findSuitableSecretKeyId(externalContractState, [SPMessage.OP_KEY_DEL], ["sig"]);
        const canMirrorOperations = !!signingKey;
        if (!canMirrorOperations) {
          console.info("[chelonia/private/watchForeignKeys]: Returning as operations cannot be mirrored", { externalContractID });
          return;
        }
        Object.entries(pendingWatch).forEach(([contractID, keys]) => {
          if (!Array.isArray(keys) || // Check that the keys exist and haven't been revoked
          !keys.reduce((acc, [, id]) => {
            return acc || has(externalContractState._vm.authorizedKeys, id);
          }, false)) {
            console.info("[chelonia/private/watchForeignKeys]: Skipping as none of the keys to watch exist", {
              externalContractID,
              contractID
            });
            return;
          }
          esm_default("chelonia/private/queueEvent", contractID, [
            "chelonia/private/in/syncContractAndWatchKeys",
            contractID,
            externalContractID
          ]).catch((e2) => {
            console.error(`Error at syncContractAndWatchKeys for contractID ${contractID} and externalContractID ${externalContractID}`, e2);
          });
        });
      },
      "chelonia/private/in/syncContractAndWatchKeys": async function(contractID, externalContractID) {
        const rootState = esm_default(this.config.stateSelector);
        const externalContractState = rootState[externalContractID];
        const pendingWatch = externalContractState?._vm?.pendingWatch?.[contractID]?.splice(0);
        if (!Array.isArray(pendingWatch) || // Check that the keys exist and haven't been revoked
        !pendingWatch.reduce((acc, [, id]) => {
          return acc || has(externalContractState._vm.authorizedKeys, id) && findKeyIdByName(externalContractState, externalContractState._vm.authorizedKeys[id].name) != null;
        }, false)) {
          console.info("[chelonia/private/syncContractAndWatchKeys]: Skipping as none of the keys to watch exist", {
            externalContractID,
            contractID
          });
          return;
        }
        if (!this.subscriptionSet.has(contractID)) {
          await esm_default("chelonia/private/in/syncContract", contractID);
        }
        const contractState = rootState[contractID];
        const keysToDelete = [];
        const keysToUpdate = [];
        pendingWatch.forEach(([keyName, externalId]) => {
          const keyId2 = findKeyIdByName(contractState, keyName);
          if (!keyId2) {
            keysToDelete.push(externalId);
            return;
          } else if (keyId2 !== externalId) {
            keysToUpdate.push(externalId);
          }
          if (!contractState._volatile) {
            this.config.reactiveSet(contractState, "_volatile", Object.create(null, {
              watch: {
                value: [[keyName, externalContractID]],
                configurable: true,
                enumerable: true,
                writable: true
              }
            }));
          } else {
            if (!contractState._volatile.watch) {
              this.config.reactiveSet(contractState._volatile, "watch", [
                [keyName, externalContractID]
              ]);
            }
            if (Array.isArray(contractState._volatile.watch) && !contractState._volatile.watch.find((v2) => v2[0] === keyName && v2[1] === externalContractID)) {
              contractState._volatile.watch.push([keyName, externalContractID]);
            }
          }
        });
        if (keysToDelete.length || keysToUpdate.length) {
          if (!externalContractState._volatile) {
            this.config.reactiveSet(externalContractState, "_volatile", /* @__PURE__ */ Object.create(null));
          }
          if (!externalContractState._volatile.pendingKeyRevocations) {
            this.config.reactiveSet(externalContractState._volatile, "pendingKeyRevocations", /* @__PURE__ */ Object.create(null));
          }
          keysToDelete.forEach((id) => this.config.reactiveSet(externalContractState._volatile.pendingKeyRevocations, id, "del"));
          keysToUpdate.forEach((id) => this.config.reactiveSet(externalContractState._volatile.pendingKeyRevocations, id, true));
          esm_default("chelonia/private/queueEvent", externalContractID, [
            "chelonia/private/deleteOrRotateRevokedKeys",
            externalContractID
          ]).catch((e2) => {
            console.error(`Error at deleteOrRotateRevokedKeys for contractID ${contractID} and externalContractID ${externalContractID}`, e2);
          });
        }
      },
      // The following function gets called when we start watching a contract for
      // foreign keys for the first time, and it ensures that, at the point the
      // watching starts, keys are in sync between the two contracts (later on,
      // this will be handled automatically for incoming OP_KEY_DEL and
      // OP_KEY_UPDATE).
      // For any given foreign key, there are three possible states:
      //   1. The key is in sync with the foreign contract. In this case, there's
      //      nothing left to do.
      //   2. The key has been rotated in the foreign contract (replaced by another
      //      key of the same name). We need to mirror this operation manually
      //      since watching only affects new messages we receive.
      //   3. The key has been removed in the foreign contract. We also need to
      //      mirror the operation.
      "chelonia/private/deleteOrRotateRevokedKeys": function(contractID) {
        const rootState = esm_default(this.config.stateSelector);
        const contractState = rootState[contractID];
        const pendingKeyRevocations = contractState?._volatile?.pendingKeyRevocations;
        if (!pendingKeyRevocations || Object.keys(pendingKeyRevocations).length === 0)
          return;
        const keysToUpdate = Object.entries(pendingKeyRevocations).filter(([, v2]) => v2 === true).map(([id]) => id);
        const [, keyUpdateSigningKeyId, keyUpdateArgs] = keysToUpdate.reduce((acc, keyId2) => {
          const key = contractState._vm?.authorizedKeys?.[keyId2];
          if (!key || !key.foreignKey)
            return acc;
          const foreignKey = String(key.foreignKey);
          const fkUrl = new URL(foreignKey);
          const foreignContractID = fkUrl.pathname;
          const foreignKeyName = fkUrl.searchParams.get("keyName");
          if (!foreignKeyName)
            throw new Error("Missing foreign key name");
          const foreignState = rootState[foreignContractID];
          if (!foreignState)
            return acc;
          const fKeyId = findKeyIdByName(foreignState, foreignKeyName);
          if (!fKeyId) {
            if (pendingKeyRevocations[keyId2] === true) {
              this.config.reactiveSet(pendingKeyRevocations, keyId2, "del");
            }
            return acc;
          }
          const [currentRingLevel, currentSigningKeyId, currentKeyArgs] = acc;
          const ringLevel = Math.min(currentRingLevel, key.ringLevel ?? Number.POSITIVE_INFINITY);
          if (ringLevel >= currentRingLevel) {
            currentKeyArgs.push({
              name: key.name,
              oldKeyId: keyId2,
              id: fKeyId,
              data: foreignState._vm.authorizedKeys[fKeyId].data
            });
            return [currentRingLevel, currentSigningKeyId, currentKeyArgs];
          } else if (Number.isFinite(ringLevel)) {
            const signingKeyId = findSuitableSecretKeyId(contractState, [SPMessage.OP_KEY_UPDATE], ["sig"], ringLevel);
            if (signingKeyId) {
              currentKeyArgs.push({
                name: key.name,
                oldKeyId: keyId2,
                id: fKeyId,
                data: foreignState._vm.authorizedKeys[fKeyId].data
              });
              return [ringLevel, signingKeyId, currentKeyArgs];
            }
          }
          return acc;
        }, [
          Number.POSITIVE_INFINITY,
          "",
          []
        ]);
        if (keyUpdateArgs.length !== 0) {
          const contractName = contractState._vm.type;
          esm_default("chelonia/out/keyUpdate", {
            contractID,
            contractName,
            data: keyUpdateArgs,
            signingKeyId: keyUpdateSigningKeyId
          }).catch((e2) => {
            console.error(`[chelonia/private/deleteOrRotateRevokedKeys] Error sending OP_KEY_UPDATE for ${contractID}`, e2.message);
          });
        }
        const keysToDelete = Object.entries(pendingKeyRevocations).filter(([, v2]) => v2 === "del").map(([id]) => id);
        const [, keyDelSigningKeyId, keyIdsToDelete] = keysToDelete.reduce((acc, keyId2) => {
          const [currentRingLevel, currentSigningKeyId, currentKeyIds] = acc;
          const ringLevel = Math.min(currentRingLevel, contractState._vm?.authorizedKeys?.[keyId2]?.ringLevel ?? Number.POSITIVE_INFINITY);
          if (ringLevel >= currentRingLevel) {
            currentKeyIds.push(keyId2);
            return [currentRingLevel, currentSigningKeyId, currentKeyIds];
          } else if (Number.isFinite(ringLevel)) {
            const signingKeyId = findSuitableSecretKeyId(contractState, [SPMessage.OP_KEY_DEL], ["sig"], ringLevel);
            if (signingKeyId) {
              currentKeyIds.push(keyId2);
              return [ringLevel, signingKeyId, currentKeyIds];
            }
          }
          return acc;
        }, [Number.POSITIVE_INFINITY, "", []]);
        if (keyIdsToDelete.length !== 0) {
          const contractName = contractState._vm.type;
          esm_default("chelonia/out/keyDel", {
            contractID,
            contractName,
            data: keyIdsToDelete,
            signingKeyId: keyDelSigningKeyId
          }).catch((e2) => {
            console.error(`[chelonia/private/deleteRevokedKeys] Error sending OP_KEY_DEL for ${contractID}`, e2.message);
          });
        }
      },
      "chelonia/private/respondToAllKeyRequests": function(contractID) {
        const state = esm_default(this.config.stateSelector);
        const contractState = state[contractID] ?? {};
        const pending = contractState?._vm?.pendingKeyshares;
        if (!pending)
          return;
        const signingKeyId = findSuitableSecretKeyId(contractState, [SPMessage.OP_ATOMIC, SPMessage.OP_KEY_REQUEST_SEEN, SPMessage.OP_KEY_SHARE], ["sig"]);
        if (!signingKeyId) {
          console.log("Unable to respond to key request because there is no suitable secret key with OP_KEY_REQUEST_SEEN permission");
          return;
        }
        Object.entries(pending).map(([hash32, entry]) => {
          if (!Array.isArray(entry) || entry.length !== 4) {
            return void 0;
          }
          const [, , , [originatingContractID]] = entry;
          return esm_default("chelonia/private/queueEvent", originatingContractID, [
            "chelonia/private/respondToKeyRequest",
            contractID,
            signingKeyId,
            hash32
          ]).catch((e2) => {
            console.error(`respondToAllKeyRequests: Error responding to key request ${hash32} from ${originatingContractID} to ${contractID}`, e2);
          });
        });
      },
      "chelonia/private/respondToKeyRequest": async function(contractID, signingKeyId, hash32) {
        const state = esm_default(this.config.stateSelector);
        const contractState = state[contractID];
        const entry = contractState?._vm?.pendingKeyshares?.[hash32];
        const instance = this._instance;
        if (!Array.isArray(entry) || entry.length !== 4) {
          return;
        }
        const [keyShareEncryption, height, , [originatingContractID, rv, originatingContractHeight, headJSON]] = entry;
        entry.pop();
        const krsEncryption = !!contractState._vm.authorizedKeys?.[signingKeyId]?._private;
        await esm_default("chelonia/private/in/syncContract", originatingContractID);
        if (instance !== this._instance)
          return;
        const originatingState = state[originatingContractID];
        const contractName = state.contracts[contractID].type;
        const originatingContractName = originatingState._vm.type;
        const v2 = signedIncomingData(originatingContractID, originatingState, rv, originatingContractHeight, headJSON).valueOf();
        const { encryptionKeyId } = v2;
        const responseKey = encryptedIncomingData(contractID, contractState, v2.responseKey, height, this.transientSecretKeys, headJSON).valueOf();
        const deserializedResponseKey = deserializeKey(responseKey);
        const responseKeyId = keyId(deserializedResponseKey);
        Promise.resolve().then(() => {
          if (instance !== this._instance)
            return;
          if (!has(originatingState._vm.authorizedKeys, responseKeyId) || originatingState._vm.authorizedKeys[responseKeyId]._notAfterHeight != null) {
            throw new Error(`Unable to respond to key request for ${originatingContractID}. Key ${responseKeyId} is not valid.`);
          }
          esm_default("chelonia/storeSecretKeys", new Secret([{ key: deserializedResponseKey }]));
          const keys = pick2(state.secretKeys, Object.entries(contractState._vm.authorizedKeys).filter(([, key]) => !!key.meta?.private?.shareable).map(([kId]) => kId));
          if (!keys || Object.keys(keys).length === 0) {
            console.info("respondToAllKeyRequests: no keys to share", {
              contractID,
              originatingContractID
            });
            return;
          }
          const keySharePayload = {
            contractID,
            keys: Object.entries(keys).map(([keyId2, key]) => ({
              id: keyId2,
              meta: {
                private: {
                  content: encryptedOutgoingData(originatingContractID, encryptionKeyId, key),
                  shareable: true
                }
              }
            })),
            keyRequestHash: hash32,
            keyRequestHeight: height
          };
          if (!contractState?._vm?.pendingKeyshares?.[hash32]) {
            return;
          }
          return keySharePayload;
        }).then((keySharePayload) => {
          if (instance !== this._instance || !keySharePayload)
            return;
          return esm_default("chelonia/out/keyShare", {
            contractID: originatingContractID,
            contractName: originatingContractName,
            data: keyShareEncryption ? encryptedOutgoingData(originatingContractID, findSuitablePublicKeyIds(originatingState, [SPMessage.OP_KEY_SHARE], ["enc"])?.[0] || "", keySharePayload) : keySharePayload,
            signingKeyId: responseKeyId
          }).then((msg) => {
            if (instance !== this._instance)
              return;
            const payload = { keyRequestHash: hash32, keyShareHash: msg.hash(), success: true };
            const connectionKeyPayload = {
              contractID: originatingContractID,
              keys: [
                {
                  id: responseKeyId,
                  meta: {
                    private: {
                      content: encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_REQUEST_SEEN], ["enc"])?.[0] || "", responseKey),
                      shareable: true
                    }
                  }
                }
              ]
            };
            esm_default("chelonia/out/atomic", {
              contractID,
              contractName,
              signingKeyId,
              data: [
                [
                  "chelonia/out/keyRequestResponse",
                  {
                    data: krsEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_REQUEST_SEEN], ["enc"])?.[0] || "", payload) : payload
                  }
                ],
                [
                  // Upon successful key share, we want to share deserializedResponseKey
                  // with ourselves
                  "chelonia/out/keyShare",
                  {
                    data: keyShareEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_SHARE], ["enc"])?.[0] || "", connectionKeyPayload) : connectionKeyPayload
                  }
                ]
              ]
            }).catch((e2) => {
              console.error("Error at respondToKeyRequest while sending keyRequestResponse", e2);
            });
          });
        }).catch((e2) => {
          console.error("Error at respondToKeyRequest", e2);
          const payload = { keyRequestHash: hash32, success: false };
          if (!contractState?._vm?.pendingKeyshares?.[hash32]) {
            return;
          }
          esm_default("chelonia/out/keyRequestResponse", {
            contractID,
            contractName,
            signingKeyId,
            data: krsEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_REQUEST_SEEN], ["enc"])?.[0] || "", payload) : payload
          }).catch((e3) => {
            console.error("Error at respondToKeyRequest while sending keyRequestResponse in error handler", e3);
          });
        });
      },
      "chelonia/private/in/handleEvent": async function(contractID, rawMessage) {
        const state = esm_default(this.config.stateSelector);
        const { preHandleEvent, postHandleEvent, handleEventError } = this.config.hooks;
        let processingErrored = false;
        let message;
        try {
          if (!this.config.acceptAllMessages && !this.pending.some((entry) => entry?.contractID === contractID) && !this.subscriptionSet.has(contractID)) {
            console.warn(`[chelonia] WARN: ignoring unexpected event for ${contractID}:`, rawMessage);
            return;
          }
          const contractStateCopy = state[contractID] ? cloneDeep(state[contractID]) : /* @__PURE__ */ Object.create(null);
          message = SPMessage.deserialize(rawMessage, this.transientSecretKeys, contractStateCopy, this.config.unwrapMaybeEncryptedData);
          if (message.contractID() !== contractID) {
            throw new Error(`[chelonia] Wrong contract ID. Expected ${contractID} but got ${message.contractID()}`);
          }
          if (!message.isFirstMessage() && (!has(state.contracts, contractID) || !has(state, contractID))) {
            throw new ChelErrorUnrecoverable("The event is not for a first message but the contract state is missing");
          }
          preHandleEvent?.(message);
          const proceed = handleEvent.checkMessageOrdering.call(this, message);
          if (proceed === false)
            return;
          if (state[contractID]?._volatile?.dirty) {
            console.info(`[chelonia] Ignoring message ${message.description()} as the contract is marked as dirty`);
            return;
          }
          const internalSideEffectStack = !this.config.skipSideEffects ? [] : void 0;
          missingDecryptionKeyIdsMap.delete(message);
          try {
            await handleEvent.processMutation.call(this, message, contractStateCopy, internalSideEffectStack);
          } catch (e_) {
            const e2 = e_;
            if (e2?.name === "ChelErrorDecryptionKeyNotFound") {
              console.warn(`[chelonia] WARN '${e2.name}' in processMutation for ${message.description()}: ${e2.message}`, e2, message.serialize());
              if (e2.cause) {
                const missingDecryptionKeyIds = missingDecryptionKeyIdsMap.get(message);
                if (missingDecryptionKeyIds) {
                  missingDecryptionKeyIds.add(e2.cause);
                } else {
                  missingDecryptionKeyIdsMap.set(message, /* @__PURE__ */ new Set([e2.cause]));
                }
              }
            } else {
              console.error(`[chelonia] ERROR '${e2.name}' in processMutation for ${message.description()}: ${e2.message || e2}`, e2, message.serialize());
            }
            console.warn(`[chelonia] Error processing ${message.description()}: ${message.serialize()}. Any side effects will be skipped!`);
            if (this.config.strictProcessing) {
              throw e2;
            }
            processingErrored = e2?.name !== "ChelErrorWarning";
            this.config.hooks.processError?.(e2, message, getMsgMeta.call(this, message, contractID, contractStateCopy));
            if (e2.name === "ChelErrorUnrecoverable" || e2.name === "ChelErrorForkedChain" || message.isFirstMessage()) {
              throw e2;
            }
          }
          if (!processingErrored) {
            if (Array.isArray(internalSideEffectStack) && internalSideEffectStack.length > 0) {
              await Promise.all(internalSideEffectStack.map((fn) => Promise.resolve(fn({ state: contractStateCopy, message })).catch((e_) => {
                const e2 = e_;
                console.error(`[chelonia] ERROR '${e2.name}' in internal side effect for ${message.description()}: ${e2.message}`, e2, { message: message.serialize() });
              })));
            }
            if (!this.config.skipActionProcessing && !this.config.skipSideEffects) {
              await handleEvent.processSideEffects.call(this, message, contractStateCopy)?.catch((e_) => {
                const e2 = e_;
                console.error(`[chelonia] ERROR '${e2.name}' in sideEffect for ${message.description()}: ${e2.message}`, e2, { message: message.serialize() });
                this.config.hooks.sideEffectError?.(e2, message);
              });
            }
          }
          try {
            const state2 = esm_default(this.config.stateSelector);
            await handleEvent.applyProcessResult.call(this, {
              message,
              state: state2,
              contractState: contractStateCopy,
              processingErrored,
              postHandleEvent
            });
          } catch (e_) {
            const e2 = e_;
            console.error(`[chelonia] ERROR '${e2.name}' for ${message.description()} marking the event as processed: ${e2.message}`, e2, { message: message.serialize() });
          }
        } catch (e_) {
          const e2 = e_;
          console.error(`[chelonia] ERROR in handleEvent: ${e2.message || e2}`, e2);
          try {
            handleEventError?.(e2, message);
          } catch (e22) {
            console.error("[chelonia] Ignoring user error in handleEventError hook:", e22);
          }
          throw e2;
        } finally {
          if (message) {
            missingDecryptionKeyIdsMap.delete(message);
          }
        }
      }
    });
    eventsToReingest = [];
    reprocessDebounced = debounce((contractID) => esm_default("chelonia/private/out/sync", contractID, { force: true }).catch((e2) => {
      console.error(`[chelonia] Error at reprocessDebounced for ${contractID}`, e2);
    }), 1e3);
    handleEvent = {
      checkMessageOrdering(message) {
        const contractID = message.contractID();
        const hash32 = message.hash();
        const height = message.height();
        const state = esm_default(this.config.stateSelector);
        const latestProcessedHeight = state.contracts[contractID]?.height;
        if (!Number.isSafeInteger(height)) {
          throw new ChelErrorDBBadPreviousHEAD(`Message ${hash32} in contract ${contractID} has an invalid height.`);
        }
        if (message.isFirstMessage() ? latestProcessedHeight != null : !(latestProcessedHeight < height)) {
          if (!this.config.strictOrdering) {
            return false;
          }
          throw new ChelErrorAlreadyProcessed(`Message ${hash32} with height ${height} in contract ${contractID} has already been processed. Current height: ${latestProcessedHeight}.`);
        }
        if (latestProcessedHeight + 1 < height) {
          if (this.config.strictOrdering) {
            throw new ChelErrorDBBadPreviousHEAD(`Unexpected message ${hash32} with height ${height} in contract ${contractID}: height is too high. Current height: ${latestProcessedHeight}.`);
          }
          if (eventsToReingest.length > 100) {
            throw new ChelErrorUnrecoverable("more than 100 different bad previousHEAD errors");
          }
          if (!eventsToReingest.includes(hash32)) {
            console.warn(`[chelonia] WARN bad previousHEAD for ${message.description()}, will attempt to re-sync contract to reingest message`);
            eventsToReingest.push(hash32);
            reprocessDebounced(contractID);
            return false;
          } else {
            console.error(`[chelonia] ERROR already attempted to reingest ${message.description()}, will not attempt again!`);
            throw new ChelErrorDBBadPreviousHEAD(`Already attempted to reingest ${hash32}`);
          }
        }
        const reprocessIdx = eventsToReingest.indexOf(hash32);
        if (reprocessIdx !== -1) {
          console.warn(`[chelonia] WARN: successfully reingested ${message.description()}`);
          eventsToReingest.splice(reprocessIdx, 1);
        }
      },
      async processMutation(message, state, internalSideEffectStack) {
        const contractID = message.contractID();
        if (message.isFirstMessage()) {
          if (Object.keys(state).some((k) => k !== "_volatile")) {
            throw new ChelErrorUnrecoverable(`state for ${contractID} is already set`);
          }
        }
        await esm_default("chelonia/private/in/processMessage", message, state, internalSideEffectStack);
      },
      processSideEffects(message, state) {
        const opT = message.opType();
        if (![
          SPMessage.OP_ATOMIC,
          SPMessage.OP_ACTION_ENCRYPTED,
          SPMessage.OP_ACTION_UNENCRYPTED
        ].includes(opT)) {
          return;
        }
        const contractID = message.contractID();
        const manifestHash = message.manifest();
        const hash32 = message.hash();
        const height = message.height();
        const signingKeyId = message.signingKeyId();
        const callSideEffect = async (field) => {
          const wv = this.config.unwrapMaybeEncryptedData(field);
          if (!wv)
            return;
          let v2 = wv.data;
          let innerSigningKeyId;
          if (isSignedData(v2)) {
            innerSigningKeyId = v2.signingKeyId;
            v2 = v2.valueOf();
          }
          const { action, data, meta } = v2;
          const mutation = {
            data,
            meta,
            hash: hash32,
            height,
            contractID,
            description: message.description(),
            direction: message.direction(),
            signingKeyId,
            get signingContractID() {
              return getContractIDfromKeyId(contractID, signingKeyId, state);
            },
            innerSigningKeyId,
            get innerSigningContractID() {
              return getContractIDfromKeyId(contractID, innerSigningKeyId, state);
            }
          };
          return await esm_default(`${manifestHash}/${action}/sideEffect`, mutation, state);
        };
        const msg = Object(message.message());
        if (opT !== SPMessage.OP_ATOMIC) {
          return callSideEffect(msg);
        }
        const reducer = (acc, [opT2, opV]) => {
          if ([SPMessage.OP_ACTION_ENCRYPTED, SPMessage.OP_ACTION_UNENCRYPTED].includes(opT2)) {
            acc.push(Object(opV));
          }
          return acc;
        };
        const actionsOpV = msg.reduce(reducer, []);
        return Promise.allSettled(actionsOpV.map((action) => callSideEffect(action))).then((results) => {
          const errors = results.filter((r) => r.status === "rejected").map((r) => r.reason);
          if (errors.length > 0) {
            console.error("Side-effect errors", contractID, errors);
            throw new AggregateError(errors, `Error at side effects for ${contractID}`);
          }
        });
      },
      async applyProcessResult({ message, state, contractState, processingErrored, postHandleEvent }) {
        const contractID = message.contractID();
        const hash32 = message.hash();
        const height = message.height();
        await esm_default("chelonia/db/addEntry", message);
        if (!processingErrored) {
          this.config.reactiveSet(state, contractID, contractState);
          try {
            postHandleEvent?.(message);
          } catch (e2) {
            console.error(`[chelonia] ERROR '${e2.name}' for ${message.description()} in event post-handling: ${e2.message}`, e2, { message: message.serialize() });
          }
        }
        if (message.isFirstMessage()) {
          const { type } = message.opValue();
          if (!has(state.contracts, contractID)) {
            this.config.reactiveSet(state.contracts, contractID, /* @__PURE__ */ Object.create(null));
          }
          this.config.reactiveSet(state.contracts[contractID], "type", type);
          console.debug(`contract ${type} registered for ${contractID}`);
        }
        if (message.isKeyOp()) {
          this.config.reactiveSet(state.contracts[contractID], "previousKeyOp", hash32);
        }
        this.config.reactiveSet(state.contracts[contractID], "HEAD", hash32);
        this.config.reactiveSet(state.contracts[contractID], "height", height);
        const missingDecryptionKeyIdsForMessage = missingDecryptionKeyIdsMap.get(message);
        if (missingDecryptionKeyIdsForMessage) {
          let missingDecryptionKeyIds = state.contracts[contractID].missingDecryptionKeyIds;
          if (!missingDecryptionKeyIds) {
            missingDecryptionKeyIds = [];
            this.config.reactiveSet(state.contracts[contractID], "missingDecryptionKeyIds", missingDecryptionKeyIds);
          }
          missingDecryptionKeyIdsForMessage.forEach((keyId2) => {
            if (missingDecryptionKeyIds.includes(keyId2))
              return;
            missingDecryptionKeyIds.push(keyId2);
          });
        }
        if (!this.subscriptionSet.has(contractID)) {
          const entry = this.pending.find((entry2) => entry2?.contractID === contractID);
          if (entry) {
            const index = this.pending.indexOf(entry);
            if (index !== -1) {
              this.pending.splice(index, 1);
            }
          }
          this.subscriptionSet.add(contractID);
          esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
            added: [contractID],
            removed: []
          });
        }
        if (!processingErrored) {
          esm_default("okTurtles.events/emit", hash32, contractID, message);
          esm_default("okTurtles.events/emit", EVENT_HANDLED, contractID, message);
        }
      }
    };
    notImplemented = (v2) => {
      throw new Error(`chelonia: action not implemented to handle: ${JSON.stringify(v2)}.`);
    };
  }
});
var wallBase;
var monotonicBase;
var resyncTimeout;
var watchdog;
var syncServerTime;
var time_sync_default;
var init_time_sync = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/time-sync.mjs"() {
    init_esm3();
    wallBase = Date.now();
    monotonicBase = performance.now();
    syncServerTime = async function() {
      const startTime = performance.now();
      const time3 = await this.config.fetch(`${this.config.connectionURL}/time`, {
        signal: this.abortController.signal
      });
      const requestTimeElapsed = performance.now();
      if (requestTimeElapsed - startTime > 8e3) {
        throw new Error("Error fetching server time: request took too long");
      }
      if (!time3.ok)
        throw new Error("Error fetching server time");
      const serverTime = new Date(await time3.text()).valueOf();
      if (Number.isNaN(serverTime))
        throw new Error("Unable to parse server time");
      const newMonotonicBase = performance.now();
      wallBase = serverTime + (requestTimeElapsed - startTime) / 2 + // Also take into account the time elapsed between `requestTimeElapsed`
      // and this line (which should be very little)
      (newMonotonicBase - requestTimeElapsed);
      monotonicBase = newMonotonicBase;
    };
    time_sync_default = esm_default("sbp/selectors/register", {
      "chelonia/private/startClockSync": function() {
        if (resyncTimeout !== void 0) {
          throw new Error("chelonia/private/startClockSync has already been called");
        }
        const resync = (delay2 = 3e5) => {
          if (resyncTimeout !== null)
            return;
          const timeout = setTimeout(() => {
            syncServerTime.call(this).then(() => {
              if (resyncTimeout === timeout)
                resyncTimeout = null;
              resync();
            }).catch((e2) => {
              if (resyncTimeout === timeout) {
                resyncTimeout = null;
                console.error("Error re-syncing server time; will re-attempt in 5s", e2);
                setTimeout(() => resync(0), 5e3);
              } else {
                console.error("Error re-syncing server time; another attempt is in progress", e2);
              }
            });
          }, delay2);
          resyncTimeout = timeout;
        };
        let wallLast = Date.now();
        let monotonicLast = performance.now();
        watchdog = setInterval(() => {
          const wallNow = Date.now();
          const monotonicNow = performance.now();
          const difference2 = Math.abs(Math.abs(wallNow - wallLast) - Math.abs(monotonicNow - monotonicLast));
          if (difference2 > 10) {
            if (resyncTimeout != null)
              clearTimeout(resyncTimeout);
            resyncTimeout = null;
            resync(0);
          }
          wallLast = wallNow;
          monotonicLast = monotonicNow;
        }, 1e4);
        resyncTimeout = null;
        resync(0);
      },
      "chelonia/private/stopClockSync": () => {
        if (resyncTimeout !== void 0) {
          if (watchdog != null)
            clearInterval(watchdog);
          if (resyncTimeout != null)
            clearTimeout(resyncTimeout);
          watchdog = void 0;
          resyncTimeout = void 0;
        }
      },
      // Get an estimate of the server's current time based on the time elapsed as
      // measured locally (using a monotonic clock), which is used as an offset, and
      // a previously retrieved server time. The time value is returned as a UNIX
      // _millisecond_ timestamp (milliseconds since 1 Jan 1970 00:00:00 UTC)
      "chelonia/time": function() {
        const monotonicNow = performance.now();
        const wallNow = wallBase - monotonicBase + monotonicNow;
        return Math.round(wallNow);
      }
    });
  }
});
function contractNameFromAction(action) {
  const regexResult = ACTION_REGEX.exec(action);
  const contractName = regexResult?.[2];
  if (!contractName)
    throw new Error(`Poorly named action '${action}': missing contract name.`);
  return contractName;
}
function outputEncryptedOrUnencryptedMessage({ contractID, innerSigningKeyId, encryptionKeyId, signingKeyId, data, meta }) {
  const state = esm_default(this.config.stateSelector)[contractID];
  const signedMessage = innerSigningKeyId ? state._vm.authorizedKeys[innerSigningKeyId] && state._vm.authorizedKeys[innerSigningKeyId]?._notAfterHeight == null ? signedOutgoingData(contractID, innerSigningKeyId, data, this.transientSecretKeys) : signedOutgoingDataWithRawKey(this.transientSecretKeys[innerSigningKeyId], data) : data;
  const payload = !encryptionKeyId ? signedMessage : encryptedOutgoingData(contractID, encryptionKeyId, signedMessage);
  const message = signedOutgoingData(contractID, signingKeyId, payload, this.transientSecretKeys);
  const rootState = esm_default(this.config.stateSelector);
  const height = String(rootState.contracts[contractID].height);
  const serializedData = { ...message.serialize((meta ?? "") + height), height };
  return serializedData;
}
function parseEncryptedOrUnencryptedMessage(ctx, { contractID, serializedData, meta }) {
  if (!serializedData) {
    throw new TypeError("[chelonia] parseEncryptedOrUnencryptedMessage: serializedData is required");
  }
  const state = esm_default(ctx.config.stateSelector)[contractID];
  const numericHeight = parseInt(serializedData.height);
  const rootState = esm_default(ctx.config.stateSelector);
  const currentHeight = rootState.contracts[contractID].height;
  if (!(numericHeight >= 0) || !(numericHeight <= currentHeight)) {
    throw new Error(`[chelonia] parseEncryptedOrUnencryptedMessage: Invalid height ${serializedData.height}; it must be between 0 and ${currentHeight}`);
  }
  const aad = (meta ?? "") + serializedData.height;
  const v2 = signedIncomingData(contractID, state, serializedData, numericHeight, aad, (message) => {
    return maybeEncryptedIncomingData(contractID, state, message, numericHeight, ctx.transientSecretKeys, aad, void 0);
  });
  let encryptionKeyId;
  let innerSigningKeyId;
  const unwrap2 = /* @__PURE__ */ (() => {
    let result2;
    return () => {
      if (!result2) {
        try {
          let unwrapped;
          unwrapped = v2.valueOf();
          if (isEncryptedData(unwrapped)) {
            encryptionKeyId = unwrapped.encryptionKeyId;
            unwrapped = unwrapped.valueOf();
            if (isSignedData(unwrapped)) {
              innerSigningKeyId = unwrapped.signingKeyId;
              unwrapped = unwrapped.valueOf();
            } else {
              innerSigningKeyId = null;
            }
          } else {
            encryptionKeyId = null;
            innerSigningKeyId = null;
          }
          result2 = [unwrapped];
        } catch (e2) {
          result2 = [void 0, e2];
        }
      }
      if (result2.length === 2) {
        throw result2[1];
      }
      return result2[0];
    };
  })();
  const result = {
    get contractID() {
      return contractID;
    },
    get innerSigningKeyId() {
      if (innerSigningKeyId === void 0) {
        try {
          unwrap2();
        } catch {
        }
      }
      return innerSigningKeyId;
    },
    get encryptionKeyId() {
      if (encryptionKeyId === void 0) {
        try {
          unwrap2();
        } catch {
        }
      }
      return encryptionKeyId;
    },
    get signingKeyId() {
      return v2.signingKeyId;
    },
    get data() {
      return unwrap2();
    },
    get signingContractID() {
      return getContractIDfromKeyId(contractID, result.signingKeyId, state);
    },
    get innerSigningContractID() {
      return getContractIDfromKeyId(contractID, result.innerSigningKeyId, state);
    }
  };
  return result;
}
async function outEncryptedOrUnencryptedAction(opType, params) {
  const { atomic, action, contractID, data, hooks, publishOptions } = params;
  const contractName = contractNameFromAction(action);
  const manifestHash = this.config.contracts.manifests[contractName];
  const { contract } = this.manifestToContract[manifestHash];
  const state = contract.state(contractID);
  const meta = await contract.metadata.create();
  const unencMessage = { action, data, meta };
  const signedMessage = params.innerSigningKeyId ? state._vm.authorizedKeys[params.innerSigningKeyId] && state._vm.authorizedKeys[params.innerSigningKeyId]?._notAfterHeight == null ? signedOutgoingData(contractID, params.innerSigningKeyId, unencMessage, this.transientSecretKeys) : signedOutgoingDataWithRawKey(this.transientSecretKeys[params.innerSigningKeyId], unencMessage) : unencMessage;
  if (opType === SPMessage.OP_ACTION_ENCRYPTED && !params.encryptionKeyId) {
    throw new Error("OP_ACTION_ENCRYPTED requires an encryption key ID be given");
  }
  if (params.encryptionKey) {
    if (params.encryptionKeyId !== keyId(params.encryptionKey)) {
      throw new Error("OP_ACTION_ENCRYPTED raw encryption key does not match encryptionKeyId");
    }
  }
  const payload = opType === SPMessage.OP_ACTION_UNENCRYPTED ? signedMessage : params.encryptionKey ? encryptedOutgoingDataWithRawKey(params.encryptionKey, signedMessage) : encryptedOutgoingData(contractID, params.encryptionKeyId, signedMessage);
  let message = SPMessage.createV1_0({
    contractID,
    op: [
      opType,
      signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
    ],
    manifest: manifestHash
  });
  if (!atomic) {
    message = await esm_default("chelonia/private/out/publishEvent", message, publishOptions, hooks);
  }
  return message;
}
function gettersProxy(state, getters) {
  const proxyGetters = new Proxy({}, {
    get(_target, prop) {
      return getters[prop](state, proxyGetters);
    }
  });
  return { getters: proxyGetters };
}
var ACTION_REGEX;
var chelonia_default;
var init_chelonia = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/chelonia.mjs"() {
    init_esm6();
    init_esm8();
    init_esm3();
    init_esm9();
    init_functions();
    init_pubsub();
    init_esm2();
    init_errors();
    init_events2();
    init_SPMessage();
    init_chelonia_utils();
    init_encryptedData();
    init_files();
    init_internals();
    init_signedData();
    init_time_sync();
    init_utils2();
    ACTION_REGEX = /^((([\w.]+)\/([^/]+))(?:\/(?:([^/]+)\/)?)?)\w*/;
    chelonia_default = esm_default("sbp/selectors/register", {
      // https://www.wordnik.com/words/chelonia
      // https://gitlab.okturtles.org/okturtles/group-income/-/wikis/E2E-Protocol/Framework.md#alt-names
      "chelonia/_init": function() {
        this.config = {
          // TODO: handle connecting to multiple servers for federation
          get connectionURL() {
            throw new Error("Invalid use of connectionURL before initialization");
          },
          // override!
          set connectionURL(value) {
            Object.defineProperty(this, "connectionURL", { value, writable: true });
          },
          stateSelector: "chelonia/private/state",
          // override to integrate with, for example, vuex
          contracts: {
            defaults: {
              modules: {},
              // '<module name>' => resolved module import
              exposedGlobals: {},
              allowedDomains: [],
              allowedSelectors: [],
              preferSlim: false
            },
            overrides: {},
            // override default values per-contract
            manifests: {}
            // override! contract names => manifest hashes
          },
          whitelisted: (action) => !!this.whitelistedActions[action],
          reactiveSet: (obj, key, value) => {
            obj[key] = value;
            return value;
          },
          // example: set to Vue.set
          fetch: (...args) => fetch(...args),
          reactiveDel: (obj, key) => {
            delete obj[key];
          },
          // acceptAllMessages disables checking whether we are expecting a message
          // or not for processing
          acceptAllMessages: false,
          skipActionProcessing: false,
          skipDecryptionAttempts: false,
          skipSideEffects: false,
          // Strict processing will treat all processing errors as unrecoverable
          // This is useful, e.g., in the server, to prevent invalid messages from
          // being added to the database
          strictProcessing: false,
          // Strict ordering will throw on past events with ChelErrorAlreadyProcessed
          // Similarly, future events will not be reingested and will throw
          // with ChelErrorDBBadPreviousHEAD
          strictOrdering: false,
          connectionOptions: {
            maxRetries: Infinity,
            // See https://github.com/okTurtles/group-income/issues/1183
            reconnectOnTimeout: true
            // can be enabled since we are not doing auth via web sockets
          },
          hooks: {
            preHandleEvent: null,
            // async (message: SPMessage) => {}
            postHandleEvent: null,
            // async (message: SPMessage) => {}
            processError: null,
            // (e: Error, message: SPMessage) => {}
            sideEffectError: null,
            // (e: Error, message: SPMessage) => {}
            handleEventError: null,
            // (e: Error, message: SPMessage) => {}
            syncContractError: null,
            // (e: Error, contractID: string) => {}
            pubsubError: null
            // (e:Error, socket: Socket)
          },
          unwrapMaybeEncryptedData
        };
        this._instance = /* @__PURE__ */ Object.create(null);
        this.abortController = new AbortController();
        this.state = {
          contracts: {},
          // contractIDs => { type, HEAD } (contracts we've subscribed to)
          pending: []
          // prevents processing unexpected data from a malicious server
        };
        this.manifestToContract = {};
        this.whitelistedActions = {};
        this.currentSyncs = /* @__PURE__ */ Object.create(null);
        this.postSyncOperations = /* @__PURE__ */ Object.create(null);
        this.sideEffectStacks = /* @__PURE__ */ Object.create(null);
        this.sideEffectStack = (contractID) => {
          let stack = this.sideEffectStacks[contractID];
          if (!stack) {
            this.sideEffectStacks[contractID] = stack = [];
          }
          return stack;
        };
        this.setPostSyncOp = (contractID, key, op) => {
          this.postSyncOperations[contractID] = this.postSyncOperations[contractID] || /* @__PURE__ */ Object.create(null);
          this.postSyncOperations[contractID][key] = op;
        };
        const secretKeyGetter = (o2, p) => {
          if (has(o2, p))
            return o2[p];
          const rootState = esm_default(this.config.stateSelector);
          if (rootState?.secretKeys && has(rootState.secretKeys, p)) {
            const key = deserializeKey(rootState.secretKeys[p]);
            o2[p] = key;
            return key;
          }
        };
        const secretKeyList = (o2) => {
          const rootState = esm_default(this.config.stateSelector);
          const stateKeys = Object.keys(rootState?.secretKeys || {});
          return Array.from(/* @__PURE__ */ new Set([...Object.keys(o2), ...stateKeys]));
        };
        this.transientSecretKeys = new Proxy(/* @__PURE__ */ Object.create(null), {
          get: secretKeyGetter,
          ownKeys: secretKeyList
        });
        this.ephemeralReferenceCount = /* @__PURE__ */ Object.create(null);
        this.subscriptionSet = /* @__PURE__ */ new Set();
        this.pending = [];
      },
      "chelonia/config": function() {
        return {
          ...cloneDeep(this.config),
          fetch: this.config.fetch,
          reactiveSet: this.config.reactiveSet,
          reactiveDel: this.config.reactiveDel
        };
      },
      "chelonia/configure": async function(config2) {
        merge2(this.config, config2);
        Object.assign(this.config.hooks, config2.hooks || {});
        if (config2.contracts) {
          Object.assign(this.config.contracts.defaults, config2.contracts.defaults || {});
          const manifests = this.config.contracts.manifests;
          console.debug("[chelonia] preloading manifests:", Object.keys(manifests));
          for (const contractName in manifests) {
            await esm_default("chelonia/private/loadManifest", contractName, manifests[contractName]);
          }
        }
        if (has(config2, "skipDecryptionAttempts")) {
          if (config2.skipDecryptionAttempts) {
            this.config.unwrapMaybeEncryptedData = (data) => {
              if (data == null)
                return;
              if (!isEncryptedData(data)) {
                return {
                  encryptionKeyId: null,
                  data
                };
              }
            };
          } else {
            this.config.unwrapMaybeEncryptedData = unwrapMaybeEncryptedData;
          }
        }
      },
      "chelonia/reset": async function(newState, postCleanupFn) {
        if (typeof newState === "function" && typeof postCleanupFn === "undefined") {
          postCleanupFn = newState;
          newState = void 0;
        }
        if (this.pubsub) {
          esm_default("chelonia/private/stopClockSync");
        }
        Object.keys(this.postSyncOperations).forEach((cID) => {
          esm_default("chelonia/private/enqueuePostSyncOps", cID);
        });
        await esm_default("chelonia/contract/waitPublish");
        await esm_default("chelonia/contract/wait");
        Object.keys(this.postSyncOperations).forEach((cID) => {
          esm_default("chelonia/private/enqueuePostSyncOps", cID);
        });
        await esm_default("chelonia/contract/waitPublish");
        await esm_default("chelonia/contract/wait");
        const result = await postCleanupFn?.();
        const rootState = esm_default(this.config.stateSelector);
        this._instance = /* @__PURE__ */ Object.create(null);
        this.abortController.abort();
        this.abortController = new AbortController();
        reactiveClearObject(rootState, this.config.reactiveDel);
        this.config.reactiveSet(rootState, "contracts", /* @__PURE__ */ Object.create(null));
        clearObject(this.ephemeralReferenceCount);
        this.pending.splice(0);
        clearObject(this.currentSyncs);
        clearObject(this.postSyncOperations);
        clearObject(this.sideEffectStacks);
        const removedContractIDs = Array.from(this.subscriptionSet);
        this.subscriptionSet.clear();
        esm_default("chelonia/clearTransientSecretKeys");
        esm_default("okTurtles.events/emit", CHELONIA_RESET);
        esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
          added: [],
          removed: removedContractIDs
        });
        if (this.pubsub) {
          esm_default("chelonia/private/startClockSync");
        }
        if (newState) {
          Object.entries(newState).forEach(([key, value]) => {
            this.config.reactiveSet(rootState, key, value);
          });
        }
        return result;
      },
      "chelonia/storeSecretKeys": function(wkeys) {
        const rootState = esm_default(this.config.stateSelector);
        if (!rootState.secretKeys) {
          this.config.reactiveSet(rootState, "secretKeys", /* @__PURE__ */ Object.create(null));
        }
        let keys = wkeys.valueOf();
        if (!keys)
          return;
        if (!Array.isArray(keys))
          keys = [keys];
        keys.forEach(({ key, transient }) => {
          if (!key)
            return;
          if (typeof key === "string") {
            key = deserializeKey(key);
          }
          const id = keyId(key);
          if (!has(this.transientSecretKeys, id)) {
            this.transientSecretKeys[id] = key;
          }
          if (transient)
            return;
          if (!has(rootState.secretKeys, id)) {
            this.config.reactiveSet(rootState.secretKeys, id, serializeKey(key, true));
          }
        });
      },
      "chelonia/clearTransientSecretKeys": function(ids) {
        if (Array.isArray(ids)) {
          ids.forEach((id) => {
            delete this.transientSecretKeys[id];
          });
        } else {
          Object.keys(this.transientSecretKeys).forEach((id) => {
            delete this.transientSecretKeys[id];
          });
        }
      },
      "chelonia/haveSecretKey": function(keyId2, persistent) {
        if (!persistent && has(this.transientSecretKeys, keyId2))
          return true;
        const rootState = esm_default(this.config.stateSelector);
        return !!rootState?.secretKeys && has(rootState.secretKeys, keyId2);
      },
      "chelonia/contract/isResyncing": function(contractIDOrState) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        return !!contractIDOrState?._volatile?.dirty || !!contractIDOrState?._volatile?.resyncing;
      },
      "chelonia/contract/hasKeyShareBeenRespondedBy": function(contractIDOrState, requestedToContractID, reference) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        const result = Object.values(contractIDOrState?._vm.authorizedKeys || {}).some((r) => {
          return r?.meta?.keyRequest?.responded && r.meta.keyRequest.contractID === requestedToContractID && (!reference || r.meta.keyRequest.reference === reference);
        });
        return result;
      },
      "chelonia/contract/waitingForKeyShareTo": function(contractIDOrState, requestingContractID, reference) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        const result = contractIDOrState._volatile?.pendingKeyRequests?.filter((r) => {
          return r && (!requestingContractID || r.contractID === requestingContractID) && (!reference || r.reference === reference);
        })?.map(({ name }) => name);
        if (!result?.length)
          return null;
        return result;
      },
      "chelonia/contract/successfulKeySharesByContractID": function(contractIDOrState, requestingContractID) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        const keyShares = Object.values(contractIDOrState._vm.keyshares || {});
        if (!keyShares?.length)
          return;
        const result = /* @__PURE__ */ Object.create(null);
        keyShares.forEach((kS) => {
          if (!kS.success)
            return;
          if (requestingContractID && kS.contractID !== requestingContractID)
            return;
          if (!result[kS.contractID])
            result[kS.contractID] = [];
          result[kS.contractID].push({ height: kS.height, hash: kS.hash });
        });
        Object.keys(result).forEach((cID) => {
          result[cID].sort((a, b) => {
            return b.height - a.height;
          });
        });
        return result;
      },
      "chelonia/contract/hasKeysToPerformOperation": function(contractIDOrState, operation) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        const op = operation !== "*" ? [operation] : operation;
        return !!findSuitableSecretKeyId(contractIDOrState, op, ["sig"]);
      },
      // Did sourceContractIDOrState receive an OP_KEY_SHARE to perform the given
      // operation on contractIDOrState?
      "chelonia/contract/receivedKeysToPerformOperation": function(sourceContractIDOrState, contractIDOrState, operation) {
        const rootState = esm_default(this.config.stateSelector);
        if (typeof sourceContractIDOrState === "string") {
          sourceContractIDOrState = rootState[sourceContractIDOrState];
        }
        if (typeof contractIDOrState === "string") {
          contractIDOrState = rootState[contractIDOrState];
        }
        const op = operation !== "*" ? [operation] : operation;
        const keyId2 = findSuitableSecretKeyId(contractIDOrState, op, ["sig"]);
        return sourceContractIDOrState?._vm?.sharedKeyIds?.some((sK) => sK.id === keyId2);
      },
      "chelonia/contract/currentKeyIdByName": function(contractIDOrState, name, requireSecretKey) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        const currentKeyId = findKeyIdByName(contractIDOrState, name);
        if (requireSecretKey && !esm_default("chelonia/haveSecretKey", currentKeyId)) {
          return;
        }
        return currentKeyId;
      },
      "chelonia/contract/foreignKeysByContractID": function(contractIDOrState, foreignContractID) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        return findForeignKeysByContractID(contractIDOrState, foreignContractID);
      },
      "chelonia/contract/historicalKeyIdsByName": function(contractIDOrState, name) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        const currentKeyId = findKeyIdByName(contractIDOrState, name);
        const revokedKeyIds = findRevokedKeyIdsByName(contractIDOrState, name);
        return currentKeyId ? [currentKeyId, ...revokedKeyIds] : revokedKeyIds;
      },
      "chelonia/contract/suitableSigningKey": function(contractIDOrState, permissions, purposes, ringLevel, allowedActions) {
        if (typeof contractIDOrState === "string") {
          const rootState = esm_default(this.config.stateSelector);
          contractIDOrState = rootState[contractIDOrState];
        }
        const keyId2 = findSuitableSecretKeyId(contractIDOrState, permissions, purposes, ringLevel, allowedActions);
        return keyId2;
      },
      "chelonia/contract/setPendingKeyRevocation": function(contractID, names) {
        const rootState = esm_default(this.config.stateSelector);
        const state = rootState[contractID];
        if (!state._volatile)
          this.config.reactiveSet(state, "_volatile", /* @__PURE__ */ Object.create(null));
        if (!state._volatile.pendingKeyRevocations) {
          this.config.reactiveSet(state._volatile, "pendingKeyRevocations", /* @__PURE__ */ Object.create(null));
        }
        for (const name of names) {
          const keyId2 = findKeyIdByName(state, name);
          if (keyId2) {
            this.config.reactiveSet(state._volatile.pendingKeyRevocations, keyId2, true);
          } else {
            console.warn("[setPendingKeyRevocation] Unable to find keyId for name", {
              contractID,
              name
            });
          }
        }
      },
      "chelonia/shelterAuthorizationHeader"(contractID) {
        return buildShelterAuthorizationHeader.call(this, contractID);
      },
      // The purpose of the 'chelonia/crypto/*' selectors is so that they can be called
      // from contracts without including the crypto code (i.e., importing crypto.js)
      // This function takes a function as a parameter that returns a string
      // It does not a string directly to prevent accidentally logging the value,
      // which is a secret
      "chelonia/crypto/keyId": (inKey) => {
        return keyId(inKey.valueOf());
      },
      // TODO: allow connecting to multiple servers at once
      "chelonia/connect": function(options3 = {}) {
        if (!this.config.connectionURL)
          throw new Error("config.connectionURL missing");
        if (!this.config.connectionOptions)
          throw new Error("config.connectionOptions missing");
        if (this.pubsub) {
          this.pubsub.destroy();
        }
        let pubsubURL = this.config.connectionURL;
        if (true) {
          pubsubURL += `?debugID=${randomHexString(6)}`;
        }
        if (this.pubsub) {
          esm_default("chelonia/private/stopClockSync");
        }
        esm_default("chelonia/private/startClockSync");
        this.pubsub = createClient(pubsubURL, {
          ...this.config.connectionOptions,
          handlers: {
            ...options3.handlers,
            // Every time we get a REQUEST_TYPE.SUB response, which happens for
            // 'new' subscriptions as well as every time the connection is reset
            "subscription-succeeded": function(event) {
              const { channelID } = event.detail;
              if (this.subscriptionSet.has(channelID)) {
                esm_default("chelonia/private/out/sync", channelID, { force: true }).catch((err) => {
                  console.warn(`[chelonia] Syncing contract ${channelID} failed: ${err.message}`);
                });
              }
              options3.handlers?.["subscription-succeeded"]?.call(this, event);
            }
          },
          // Map message handlers to transparently handle encryption and signatures
          messageHandlers: {
            ...Object.fromEntries(Object.entries(options3.messageHandlers || {}).map(([k, v2]) => {
              switch (k) {
                case NOTIFICATION_TYPE.PUB:
                  return [
                    k,
                    (msg) => {
                      if (!msg.channelID) {
                        console.info("[chelonia] Discarding pub event without channelID");
                        return;
                      }
                      if (!this.subscriptionSet.has(msg.channelID)) {
                        console.info(`[chelonia] Discarding pub event for ${msg.channelID} because it's not in the current subscriptionSet`);
                        return;
                      }
                      esm_default("chelonia/queueInvocation", msg.channelID, () => {
                        v2.call(this.pubsub, parseEncryptedOrUnencryptedMessage(this, {
                          contractID: msg.channelID,
                          serializedData: msg.data
                        }));
                      }).catch((e2) => {
                        console.error(`[chelonia] Error processing pub event for ${msg.channelID}`, e2);
                      });
                    }
                  ];
                case NOTIFICATION_TYPE.KV:
                  return [
                    k,
                    (msg) => {
                      if (!msg.channelID || !msg.key) {
                        console.info("[chelonia] Discarding kv event without channelID or key");
                        return;
                      }
                      if (!this.subscriptionSet.has(msg.channelID)) {
                        console.info(`[chelonia] Discarding kv event for ${msg.channelID} because it's not in the current subscriptionSet`);
                        return;
                      }
                      esm_default("chelonia/queueInvocation", msg.channelID, () => {
                        v2.call(this.pubsub, [
                          msg.key,
                          parseEncryptedOrUnencryptedMessage(this, {
                            contractID: msg.channelID,
                            meta: msg.key,
                            serializedData: JSON.parse(Buffer6.from(msg.data).toString())
                          })
                        ]);
                      }).catch((e2) => {
                        console.error(`[chelonia] Error processing kv event for ${msg.channelID} and key ${msg.key}`, msg, e2);
                      });
                    }
                  ];
                case NOTIFICATION_TYPE.DELETION:
                  return [
                    k,
                    (msg) => v2.call(this.pubsub, msg.data)
                  ];
                default:
                  return [k, v2];
              }
            })),
            [NOTIFICATION_TYPE.ENTRY](msg) {
              const { contractID } = SPMessage.deserializeHEAD(msg.data);
              esm_default("chelonia/private/in/enqueueHandleEvent", contractID, msg.data);
            }
          }
        });
        if (!this.contractsModifiedListener) {
          this.contractsModifiedListener = () => esm_default("chelonia/pubsub/update");
          esm_default("okTurtles.events/on", CONTRACTS_MODIFIED, this.contractsModifiedListener);
        }
        return this.pubsub;
      },
      // This selector is defined primarily for ingesting web push notifications,
      // although it can be used as a general-purpose API to process events received
      // from other external sources that are not managed by Chelonia itself (i.e. sources
      // other than the Chelonia-managed websocket connection and RESTful API).
      "chelonia/handleEvent": async function(event) {
        const { contractID } = SPMessage.deserializeHEAD(event);
        return await esm_default("chelonia/private/in/enqueueHandleEvent", contractID, event);
      },
      "chelonia/defineContract": function(contract) {
        if (!ACTION_REGEX.exec(contract.name))
          throw new Error(`bad contract name: ${contract.name}`);
        if (!contract.metadata)
          contract.metadata = { validate() {
          }, create: () => ({}) };
        if (!contract.getters)
          contract.getters = {};
        contract.state = (contractID) => esm_default(this.config.stateSelector)[contractID];
        contract.manifest = this.defContractManifest;
        contract.sbp = this.defContractSBP;
        this.defContractSelectors = [];
        this.defContract = contract;
        this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
          // expose getters for Vuex integration and other conveniences
          [`${contract.manifest}/${contract.name}/getters`]: () => contract.getters,
          // 2 ways to cause sideEffects to happen: by defining a sideEffect function in the
          // contract, or by calling /pushSideEffect w/async SBP call. Can also do both.
          [`${contract.manifest}/${contract.name}/pushSideEffect`]: (contractID, asyncSbpCall) => {
            const [sel] = asyncSbpCall;
            if (sel.startsWith(contract.name + "/")) {
              asyncSbpCall[0] = `${contract.manifest}/${sel}`;
            }
            this.sideEffectStack(contractID).push(asyncSbpCall);
          }
        }));
        for (const action in contract.actions) {
          contractNameFromAction(action);
          this.whitelistedActions[action] = true;
          this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
            [`${contract.manifest}/${action}/process`]: async (message, state) => {
              const { meta, data, contractID } = message;
              state = state || contract.state(contractID);
              const gProxy = gettersProxy(state, contract.getters);
              await contract.metadata.validate(meta, { state, ...gProxy, contractID });
              await contract.actions[action].validate(data, {
                state,
                ...gProxy,
                meta,
                message,
                contractID
              });
              this.sideEffectStacks[contractID] = [];
              await contract.actions[action].process(message, { state, ...gProxy });
            },
            // 'mutation' is an object that's similar to 'message', but not identical
            [`${contract.manifest}/${action}/sideEffect`]: async (mutation, state) => {
              if (contract.actions[action].sideEffect) {
                state = state || contract.state(mutation.contractID);
                if (!state) {
                  console.warn(`[${contract.manifest}/${action}/sideEffect]: Skipping side-effect since there is no contract state for contract ${mutation.contractID}`);
                  return;
                }
                const stateCopy = cloneDeep(state);
                const gProxy = gettersProxy(stateCopy, contract.getters);
                await contract.actions[action].sideEffect(mutation, { state: stateCopy, ...gProxy });
              }
              const sideEffects = this.sideEffectStack(mutation.contractID);
              while (sideEffects.length > 0) {
                const sideEffect = sideEffects.shift();
                try {
                  await contract.sbp(...sideEffect);
                } catch (e_) {
                  const e2 = e_;
                  console.error(`[chelonia] ERROR: '${e2.name}' ${e2.message}, for pushed sideEffect of ${mutation.description}:`, sideEffect);
                  this.sideEffectStacks[mutation.contractID] = [];
                  throw e2;
                }
              }
            }
          }));
        }
        for (const method in contract.methods) {
          this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
            [`${contract.manifest}/${method}`]: contract.methods[method]
          }));
        }
        esm_default("okTurtles.events/emit", CONTRACT_REGISTERED, contract);
      },
      "chelonia/queueInvocation": (contractID, sbpInvocation) => {
        return esm_default("chelonia/private/queueEvent", contractID, ["chelonia/private/noop"]).then(() => esm_default("chelonia/private/queueEvent", "public:" + contractID, sbpInvocation));
      },
      "chelonia/begin": async (...invocations) => {
        for (const invocation of invocations) {
          await esm_default(...invocation);
        }
      },
      // call this manually to resubscribe/unsubscribe from contracts as needed
      // if you are using a custom stateSelector and reload the state (e.g. upon login)
      "chelonia/pubsub/update": function() {
        const client = this.pubsub;
        const subscribedIDs = [...client.subscriptionSet];
        const currentIDs = Array.from(this.subscriptionSet);
        const leaveSubscribed = intersection2(subscribedIDs, currentIDs);
        const toUnsubscribe = difference(subscribedIDs, leaveSubscribed);
        const toSubscribe = difference(currentIDs, leaveSubscribed);
        try {
          for (const contractID of toUnsubscribe) {
            client.unsub(contractID);
          }
          for (const contractID of toSubscribe) {
            client.sub(contractID);
          }
        } catch (e2) {
          console.error(`[chelonia] pubsub/update: error ${e2.name}: ${e2.message}`, { toUnsubscribe, toSubscribe }, e2);
          this.config.hooks.pubsubError?.(e2, client);
        }
      },
      // resolves when all pending actions for these contractID(s) finish
      "chelonia/contract/wait": function(contractIDs) {
        const listOfIds = contractIDs ? typeof contractIDs === "string" ? [contractIDs] : contractIDs : Object.keys(esm_default(this.config.stateSelector).contracts);
        return Promise.all(listOfIds.flatMap((cID) => {
          return esm_default("chelonia/queueInvocation", cID, ["chelonia/private/noop"]);
        }));
      },
      // resolves when all pending *writes* for these contractID(s) finish
      "chelonia/contract/waitPublish": function(contractIDs) {
        const listOfIds = contractIDs ? typeof contractIDs === "string" ? [contractIDs] : contractIDs : Object.keys(esm_default(this.config.stateSelector).contracts);
        return Promise.all(listOfIds.flatMap((cID) => {
          return esm_default("chelonia/private/queueEvent", `publish:${cID}`, ["chelonia/private/noop"]);
        }));
      },
      // 'chelonia/contract' - selectors related to injecting remote data and monitoring contracts
      // TODO: add an optional parameter to "retain" the contract (see #828)
      // eslint-disable-next-line require-await
      "chelonia/contract/sync": async function(contractIDs, params) {
        const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
        listOfIds.forEach((id) => {
          if (checkCanBeGarbageCollected.call(this, id)) {
            if (process.env.CI) {
              Promise.reject(new Error("[chelonia] Missing reference count for contract " + id));
            }
            console.error("[chelonia] Missing reference count for contract " + id);
            throw new Error("Missing reference count for contract");
          }
        });
        return esm_default("chelonia/private/out/sync", listOfIds, { ...params, force: true });
      },
      "chelonia/contract/isSyncing": function(contractID, { firstSync = false } = {}) {
        const isSyncing = !!this.currentSyncs[contractID];
        return firstSync ? isSyncing && this.currentSyncs[contractID].firstSync : isSyncing;
      },
      "chelonia/contract/currentSyncs": function() {
        return Object.keys(this.currentSyncs);
      },
      // Because `/remove` is done asynchronously and a contract might be removed
      // much later than when the call to remove was made, an optional callback
      // can be passed to verify whether to proceed with removal. This is used as
      // part of the `/release` mechanism to prevent removing contracts that have
      // acquired new references since the call to `/remove`.
      "chelonia/contract/remove": function(contractIDs, { confirmRemovalCallback, permanent } = {}) {
        const rootState = esm_default(this.config.stateSelector);
        const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
        return Promise.all(listOfIds.map((contractID) => {
          if (!rootState?.contracts?.[contractID]) {
            return void 0;
          }
          return esm_default("chelonia/private/queueEvent", contractID, () => {
            if (confirmRemovalCallback && !confirmRemovalCallback(contractID)) {
              return;
            }
            const rootState2 = esm_default(this.config.stateSelector);
            const fkContractIDs = Array.from(new Set(Object.values(rootState2[contractID]?._vm?.authorizedKeys ?? {}).filter((k) => {
              return !!k.foreignKey;
            }).map((k) => {
              try {
                const fkUrl = new URL(k.foreignKey);
                return fkUrl.pathname;
              } catch {
                return void 0;
              }
            }).filter(Boolean)));
            esm_default("chelonia/private/removeImmediately", contractID, { permanent });
            if (fkContractIDs.length) {
              esm_default("chelonia/contract/release", fkContractIDs, { try: true }).catch((e2) => {
                console.error("[chelonia] Error attempting to release foreign key contracts", e2);
              });
            }
          });
        }));
      },
      "chelonia/contract/retain": async function(contractIDs, params) {
        const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
        const rootState = esm_default(this.config.stateSelector);
        if (listOfIds.length === 0)
          return Promise.resolve();
        const checkIfDeleted = (id) => {
          if (rootState.contracts[id] === null) {
            console.error("[chelonia/contract/retain] Called /retain on permanently deleted contract.", id);
            throw new ChelErrorResourceGone("Unable to retain permanently deleted contract " + id);
          }
        };
        if (!params?.ephemeral) {
          listOfIds.forEach((id) => {
            checkIfDeleted(id);
            if (!has(rootState.contracts, id)) {
              this.config.reactiveSet(rootState.contracts, id, /* @__PURE__ */ Object.create(null));
            }
            this.config.reactiveSet(rootState.contracts[id], "references", (rootState.contracts[id].references ?? 0) + 1);
          });
        } else {
          listOfIds.forEach((id) => {
            checkIfDeleted(id);
            if (!has(this.ephemeralReferenceCount, id)) {
              this.ephemeralReferenceCount[id] = 1;
            } else {
              this.ephemeralReferenceCount[id] = this.ephemeralReferenceCount[id] + 1;
            }
          });
        }
        return await esm_default("chelonia/private/out/sync", listOfIds);
      },
      // the `try` parameter does not affect (ephemeral or persistent) reference
      // counts, but rather removes a contract if the reference count is zero
      // and the contract isn't being monitored for foreign keys. This parameter
      // is meant mostly for internal chelonia use, so that removing or releasing
      // a contract can also remove other contracts that this first contract
      // was monitoring.
      "chelonia/contract/release": async function(contractIDs, params) {
        const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
        const rootState = esm_default(this.config.stateSelector);
        if (!params?.try) {
          if (!params?.ephemeral) {
            listOfIds.forEach((id) => {
              if (rootState.contracts[id] === null) {
                console.warn("[chelonia/contract/release] Called /release on permanently deleted contract. This has no effect.", id);
                return;
              }
              if (has(rootState.contracts, id) && has(rootState.contracts[id], "references")) {
                const current = rootState.contracts[id].references;
                if (current === 0) {
                  console.error("[chelonia/contract/release] Invalid negative reference count for", id);
                  if (process.env.CI) {
                    Promise.reject(new Error("Invalid negative reference count: " + id));
                  }
                  throw new Error("Invalid negative reference count");
                }
                if (current <= 1) {
                  this.config.reactiveDel(rootState.contracts[id], "references");
                } else {
                  this.config.reactiveSet(rootState.contracts[id], "references", current - 1);
                }
              } else {
                console.error("[chelonia/contract/release] Invalid negative reference count for", id);
                if (process.env.CI) {
                  Promise.reject(new Error("Invalid negative reference count: " + id));
                }
                throw new Error("Invalid negative reference count");
              }
            });
          } else {
            listOfIds.forEach((id) => {
              if (rootState.contracts[id] === null) {
                console.warn("[chelonia/contract/release] Called /release on permanently deleted contract. This has no effect.", id);
                return;
              }
              if (has(this.ephemeralReferenceCount, id)) {
                const current = this.ephemeralReferenceCount[id] ?? 0;
                if (current <= 1) {
                  delete this.ephemeralReferenceCount[id];
                } else {
                  this.ephemeralReferenceCount[id] = current - 1;
                }
              } else {
                console.error("[chelonia/contract/release] Invalid negative ephemeral reference count for", id);
                if (process.env.CI) {
                  Promise.reject(new Error("Invalid negative ephemeral reference count: " + id));
                }
                throw new Error("Invalid negative ephemeral reference count");
              }
            });
          }
        }
        const boundCheckCanBeGarbageCollected = checkCanBeGarbageCollected.bind(this);
        const idsToRemove = listOfIds.filter(boundCheckCanBeGarbageCollected);
        return idsToRemove.length ? await esm_default("chelonia/contract/remove", idsToRemove, {
          confirmRemovalCallback: boundCheckCanBeGarbageCollected
        }) : void 0;
      },
      "chelonia/contract/disconnect": async function(contractID, contractIDToDisconnect) {
        const state = esm_default(this.config.stateSelector);
        const contractState = state[contractID];
        const keyIds = Object.values(contractState._vm.authorizedKeys).filter((k) => {
          return k._notAfterHeight == null && k.meta?.keyRequest?.contractID === contractIDToDisconnect;
        }).map((k) => k.id);
        if (!keyIds.length)
          return;
        return await esm_default("chelonia/out/keyDel", {
          contractID,
          contractName: contractState._vm.type,
          data: keyIds,
          signingKeyId: findSuitableSecretKeyId(contractState, [SPMessage.OP_KEY_DEL], ["sig"])
        });
      },
      "chelonia/in/processMessage": function(messageOrRawMessage, state) {
        const stateCopy = cloneDeep(state);
        const message = typeof messageOrRawMessage === "string" ? SPMessage.deserialize(messageOrRawMessage, this.transientSecretKeys, stateCopy, this.config.unwrapMaybeEncryptedData) : messageOrRawMessage;
        return esm_default("chelonia/private/in/processMessage", message, stateCopy).then(() => stateCopy).catch((e2) => {
          console.warn(`chelonia/in/processMessage: reverting mutation ${message.description()}: ${message.serialize()}`, e2);
          return state;
        });
      },
      "chelonia/out/fetchResource": async function(cid, { code: code2 } = {}) {
        const parsedCID = parseCID(cid);
        if (code2 != null) {
          if (parsedCID.code !== code2) {
            throw new Error(`Invalid CID content type. Expected ${code2}, got ${parsedCID.code}`);
          }
        }
        const local = await esm_default("chelonia.db/get", cid);
        if (local != null)
          return local;
        const url = `${this.config.connectionURL}/file/${cid}`;
        const data = await this.config.fetch(url, { signal: this.abortController.signal }).then(handleFetchResult2("text"));
        const ourHash = createCID2(data, parsedCID.code);
        if (ourHash !== cid) {
          throw new Error(`expected hash ${cid}. Got: ${ourHash}`);
        }
        await esm_default("chelonia.db/set", cid, data);
        return data;
      },
      "chelonia/out/latestHEADInfo": function(contractID) {
        return this.config.fetch(`${this.config.connectionURL}/latestHEADinfo/${contractID}`, {
          cache: "no-store",
          signal: this.abortController.signal
        }).then(handleFetchResult2("json"));
      },
      "chelonia/out/deserializedHEAD": async function(hash32, { contractID } = {}) {
        const message = await esm_default("chelonia/out/fetchResource", hash32, {
          code: multicodes2.SHELTER_CONTRACT_DATA
        });
        const deserializedHEAD = SPMessage.deserializeHEAD(message);
        if (contractID && deserializedHEAD.contractID !== contractID) {
          throw new Error("chelonia/out/deserializedHEAD: Mismatched contract ID");
        }
        return deserializedHEAD;
      },
      "chelonia/out/eventsAfter": eventsAfter2,
      "chelonia/out/eventsBefore": function(contractID, { beforeHeight, limit, stream }) {
        if (limit <= 0) {
          console.error('[chelonia] invalid params error: "limit" needs to be positive integer');
        }
        const offset = Math.max(0, beforeHeight - limit + 1);
        const eventsAfterLimit = Math.min(beforeHeight + 1, limit);
        return esm_default("chelonia/out/eventsAfter", contractID, {
          sinceHeight: offset,
          limit: eventsAfterLimit,
          stream
        });
      },
      "chelonia/out/eventsBetween": function(contractID, { startHash, endHeight = Number.POSITIVE_INFINITY, offset = 0, limit = 0, stream = true }) {
        if (offset < 0) {
          console.error('[chelonia] invalid params error: "offset" needs to be positive integer or zero');
          return;
        }
        let reader;
        const s = new ReadableStream({
          start: async (controller) => {
            const deserializedHEAD = await esm_default("chelonia/out/deserializedHEAD", startHash, { contractID });
            const startOffset = Math.max(0, deserializedHEAD.head.height - offset);
            const ourLimit = limit ? Math.min(endHeight - startOffset + 1, limit) : endHeight - startOffset + 1;
            if (ourLimit < 1) {
              controller.close();
              return;
            }
            reader = esm_default("chelonia/out/eventsAfter", contractID, {
              sinceHeight: startOffset,
              limit: ourLimit
            }).getReader();
          },
          async pull(controller) {
            const { done, value } = await reader.read();
            if (done) {
              controller.close();
            } else {
              controller.enqueue(value);
            }
          }
        });
        if (stream)
          return s;
        return collectEventStream(s);
      },
      "chelonia/rootState": function() {
        return esm_default(this.config.stateSelector);
      },
      "chelonia/latestContractState": async function(contractID, options3 = { forceSync: false }) {
        const rootState = esm_default(this.config.stateSelector);
        if (rootState.contracts[contractID] === null) {
          throw new ChelErrorResourceGone("Permanently deleted contract " + contractID);
        }
        if (!options3.forceSync && rootState[contractID] && Object.keys(rootState[contractID]).some((x3) => x3 !== "_volatile")) {
          return cloneDeep(rootState[contractID]);
        }
        let state = /* @__PURE__ */ Object.create(null);
        let contractName = rootState.contracts[contractID]?.type;
        const eventsStream = esm_default("chelonia/out/eventsAfter", contractID, {
          sinceHeight: 0,
          sinceHash: contractID
        });
        const eventsStreamReader = eventsStream.getReader();
        if (rootState[contractID])
          state._volatile = rootState[contractID]._volatile;
        for (; ; ) {
          const { value: event, done } = await eventsStreamReader.read();
          if (done)
            return state;
          const stateCopy = cloneDeep(state);
          try {
            await esm_default("chelonia/private/in/processMessage", SPMessage.deserialize(event, this.transientSecretKeys, state, this.config.unwrapMaybeEncryptedData), state, void 0, contractName);
            if (!contractName && state._vm) {
              contractName = state._vm.type;
            }
          } catch (e2) {
            console.warn(`[chelonia] latestContractState: '${e2.name}': ${e2.message} processing:`, event, e2.stack);
            if (e2 instanceof ChelErrorUnrecoverable)
              throw e2;
            state = stateCopy;
          }
        }
      },
      "chelonia/contract/state": function(contractID, height) {
        const state = esm_default(this.config.stateSelector)[contractID];
        const stateCopy = state && cloneDeep(state);
        if (stateCopy?._vm && height != null) {
          Object.keys(stateCopy._vm.authorizedKeys).forEach((keyId2) => {
            if (stateCopy._vm.authorizedKeys[keyId2]._notBeforeHeight > height) {
              delete stateCopy._vm.authorizedKeys[keyId2];
            }
          });
        }
        return stateCopy;
      },
      "chelonia/contract/fullState": function(contractID) {
        const rootState = esm_default(this.config.stateSelector);
        if (Array.isArray(contractID)) {
          return Object.fromEntries(contractID.map((contractID2) => {
            return [
              contractID2,
              {
                contractState: rootState[contractID2],
                cheloniaState: rootState.contracts[contractID2]
              }
            ];
          }));
        }
        return {
          contractState: rootState[contractID],
          cheloniaState: rootState.contracts[contractID]
        };
      },
      // 'chelonia/out' - selectors that send data out to the server
      "chelonia/out/registerContract": async function(params) {
        const { contractName, keys, hooks, publishOptions, signingKeyId, actionSigningKeyId, actionEncryptionKeyId } = params;
        const manifestHash = this.config.contracts.manifests[contractName];
        const contractInfo = this.manifestToContract[manifestHash];
        if (!contractInfo)
          throw new Error(`contract not defined: ${contractName}`);
        const signingKey = this.transientSecretKeys[signingKeyId];
        if (!signingKey)
          throw new Error(`Signing key ${signingKeyId} is not defined`);
        const payload = {
          type: contractName,
          keys
        };
        const contractMsg = SPMessage.createV1_0({
          contractID: null,
          height: 0,
          op: [
            SPMessage.OP_CONTRACT,
            signedOutgoingDataWithRawKey(signingKey, payload)
          ],
          manifest: manifestHash
        });
        const contractID = contractMsg.hash();
        await esm_default("chelonia/private/out/publishEvent", contractMsg, params.namespaceRegistration ? {
          ...publishOptions,
          headers: {
            ...publishOptions?.headers,
            "shelter-namespace-registration": params.namespaceRegistration
          }
        } : publishOptions, hooks && {
          prepublish: hooks.prepublishContract,
          postpublish: hooks.postpublishContract
        });
        await esm_default("chelonia/private/out/sync", contractID);
        const msg = await esm_default(actionEncryptionKeyId ? "chelonia/out/actionEncrypted" : "chelonia/out/actionUnencrypted", {
          action: contractName,
          contractID,
          data: params.data,
          signingKeyId: actionSigningKeyId ?? signingKeyId,
          encryptionKeyId: actionEncryptionKeyId,
          hooks,
          publishOptions
        });
        return msg;
      },
      "chelonia/out/ownResources": async function(contractID) {
        if (!contractID) {
          throw new TypeError("A contract ID must be provided");
        }
        const response = await this.config.fetch(`${this.config.connectionURL}/ownResources`, {
          method: "GET",
          signal: this.abortController.signal,
          headers: new Headers([
            ["authorization", buildShelterAuthorizationHeader.call(this, contractID)]
          ])
        });
        if (!response.ok) {
          console.error("Unable to fetch own resources", contractID, response.status);
          throw new Error(`Unable to fetch own resources for ${contractID}: ${response.status}`);
        }
        return response.json();
      },
      "chelonia/out/deleteContract": async function(contractID, credentials = {}) {
        if (!contractID) {
          throw new TypeError("A contract ID must be provided");
        }
        if (!Array.isArray(contractID))
          contractID = [contractID];
        return await Promise.allSettled(contractID.map(async (cid) => {
          const hasCredential = has(credentials, cid);
          const hasToken = has(credentials[cid], "token") && credentials[cid].token;
          const hasBillableContractID = has(credentials[cid], "billableContractID") && credentials[cid].billableContractID;
          if (!hasCredential || hasToken === hasBillableContractID) {
            throw new TypeError(`Either a token or a billable contract ID must be provided for ${cid}`);
          }
          const response = await this.config.fetch(`${this.config.connectionURL}/deleteContract/${cid}`, {
            method: "POST",
            signal: this.abortController.signal,
            headers: new Headers([
              [
                "authorization",
                hasToken ? `bearer ${credentials[cid].token.valueOf()}` : buildShelterAuthorizationHeader.call(this, credentials[cid].billableContractID)
              ]
            ])
          });
          if (!response.ok) {
            if (response.status === 404 || response.status === 410) {
              console.warn("Contract appears to have been deleted already", cid, response.status);
              return;
            }
            console.error("Unable to delete contract", cid, response.status);
            throw new Error(`Unable to delete contract ${cid}: ${response.status}`);
          }
        }));
      },
      // all of these functions will do both the creation of the SPMessage
      // and the sending of it via 'chelonia/private/out/publishEvent'
      "chelonia/out/actionEncrypted": function(params) {
        return outEncryptedOrUnencryptedAction.call(this, SPMessage.OP_ACTION_ENCRYPTED, params);
      },
      "chelonia/out/actionUnencrypted": function(params) {
        return outEncryptedOrUnencryptedAction.call(this, SPMessage.OP_ACTION_UNENCRYPTED, params);
      },
      "chelonia/out/keyShare": async function(params) {
        const { atomic, originatingContractName, originatingContractID, contractName, contractID, data, hooks, publishOptions } = params;
        const originatingManifestHash = this.config.contracts.manifests[originatingContractName];
        const destinationManifestHash = this.config.contracts.manifests[contractName];
        const originatingContract = originatingContractID ? this.manifestToContract[originatingManifestHash]?.contract : void 0;
        const destinationContract = this.manifestToContract[destinationManifestHash]?.contract;
        if (originatingContractID && !originatingContract || !destinationContract) {
          throw new Error("Contract name not found");
        }
        const payload = data;
        if (!params.signingKeyId && !params.signingKey) {
          throw new TypeError("Either signingKeyId or signingKey must be specified");
        }
        let msg = SPMessage.createV1_0({
          contractID,
          op: [
            SPMessage.OP_KEY_SHARE,
            params.signingKeyId ? signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys) : signedOutgoingDataWithRawKey(params.signingKey, payload)
          ],
          manifest: destinationManifestHash
        });
        if (!atomic) {
          msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
        }
        return msg;
      },
      "chelonia/out/keyAdd": async function(params) {
        const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
        const manifestHash = this.config.contracts.manifests[contractName];
        const contract = this.manifestToContract[manifestHash]?.contract;
        if (!contract) {
          throw new Error("Contract name not found");
        }
        const state = contract.state(contractID);
        const payload = params.skipExistingKeyCheck ? data : data.filter((wk) => {
          const k = isEncryptedData(wk) ? wk.valueOf() : wk;
          if (has(state._vm.authorizedKeys, k.id)) {
            if (state._vm.authorizedKeys[k.id]._notAfterHeight == null) {
              return false;
            }
          }
          return true;
        });
        if (payload.length === 0)
          return;
        let msg = SPMessage.createV1_0({
          contractID,
          op: [
            SPMessage.OP_KEY_ADD,
            signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
          ],
          manifest: manifestHash
        });
        if (!atomic) {
          msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
        }
        return msg;
      },
      "chelonia/out/keyDel": async function(params) {
        const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
        const manifestHash = this.config.contracts.manifests[contractName];
        const contract = this.manifestToContract[manifestHash]?.contract;
        if (!contract) {
          throw new Error("Contract name not found");
        }
        const state = contract.state(contractID);
        const payload = data.map((keyId2) => {
          if (isEncryptedData(keyId2))
            return keyId2;
          if (!has(state._vm.authorizedKeys, keyId2) || state._vm.authorizedKeys[keyId2]._notAfterHeight != null) {
            return void 0;
          }
          if (state._vm.authorizedKeys[keyId2]._private) {
            return encryptedOutgoingData(contractID, state._vm.authorizedKeys[keyId2]._private, keyId2);
          } else {
            return keyId2;
          }
        }).filter(Boolean);
        let msg = SPMessage.createV1_0({
          contractID,
          op: [
            SPMessage.OP_KEY_DEL,
            signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
          ],
          manifest: manifestHash
        });
        if (!atomic) {
          msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
        }
        return msg;
      },
      "chelonia/out/keyUpdate": async function(params) {
        const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
        const manifestHash = this.config.contracts.manifests[contractName];
        const contract = this.manifestToContract[manifestHash]?.contract;
        if (!contract) {
          throw new Error("Contract name not found");
        }
        const state = contract.state(contractID);
        const payload = data.map((key) => {
          if (isEncryptedData(key))
            return key;
          const { oldKeyId } = key;
          if (state._vm.authorizedKeys[oldKeyId]._private) {
            return encryptedOutgoingData(contractID, state._vm.authorizedKeys[oldKeyId]._private, key);
          } else {
            return key;
          }
        });
        let msg = SPMessage.createV1_0({
          contractID,
          op: [
            SPMessage.OP_KEY_UPDATE,
            signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
          ],
          manifest: manifestHash
        });
        if (!atomic) {
          msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
        }
        return msg;
      },
      "chelonia/out/keyRequest": async function(params) {
        const { originatingContractID, originatingContractName, contractID, contractName, hooks, publishOptions, innerSigningKeyId, encryptionKeyId, innerEncryptionKeyId, encryptKeyRequestMetadata, reference } = params;
        const manifestHash = this.config.contracts.manifests[contractName];
        const originatingManifestHash = this.config.contracts.manifests[originatingContractName];
        const contract = this.manifestToContract[manifestHash]?.contract;
        const originatingContract = this.manifestToContract[originatingManifestHash]?.contract;
        if (!contract) {
          throw new Error("Contract name not found");
        }
        const rootState = esm_default(this.config.stateSelector);
        try {
          await esm_default("chelonia/contract/retain", contractID, { ephemeral: true });
          const state = contract.state(contractID);
          const originatingState = originatingContract.state(originatingContractID);
          const havePendingKeyRequest = Object.values(originatingState._vm.authorizedKeys).findIndex((k) => {
            return k._notAfterHeight == null && k.meta?.keyRequest?.contractID === contractID && state?._volatile?.pendingKeyRequests?.some((pkr) => pkr.name === k.name);
          }) !== -1;
          if (havePendingKeyRequest) {
            return;
          }
          const keyRequestReplyKey = keygen(EDWARDS25519SHA512BATCH);
          const keyRequestReplyKeyId = keyId(keyRequestReplyKey);
          const keyRequestReplyKeyP = serializeKey(keyRequestReplyKey, false);
          const keyRequestReplyKeyS = serializeKey(keyRequestReplyKey, true);
          const signingKeyId = findSuitableSecretKeyId(originatingState, [SPMessage.OP_KEY_ADD], ["sig"]);
          if (!signingKeyId) {
            throw new ChelErrorUnexpected(`Unable to send key request. Originating contract is missing a key with OP_KEY_ADD permission. contractID=${contractID} originatingContractID=${originatingContractID}`);
          }
          const keyAddOp = () => esm_default("chelonia/out/keyAdd", {
            contractID: originatingContractID,
            contractName: originatingContractName,
            data: [
              {
                id: keyRequestReplyKeyId,
                name: "#krrk-" + keyRequestReplyKeyId,
                purpose: ["sig"],
                ringLevel: Number.MAX_SAFE_INTEGER,
                permissions: params.permissions === "*" ? "*" : Array.isArray(params.permissions) ? [...params.permissions, SPMessage.OP_KEY_SHARE] : [SPMessage.OP_KEY_SHARE],
                allowedActions: params.allowedActions,
                meta: {
                  private: {
                    content: encryptedOutgoingData(originatingContractID, encryptionKeyId, keyRequestReplyKeyS),
                    shareable: false
                  },
                  keyRequest: {
                    ...reference && {
                      reference: encryptKeyRequestMetadata ? encryptedOutgoingData(originatingContractID, encryptionKeyId, reference) : reference
                    },
                    contractID: encryptKeyRequestMetadata ? encryptedOutgoingData(originatingContractID, encryptionKeyId, contractID) : contractID
                  }
                },
                data: keyRequestReplyKeyP
              }
            ],
            signingKeyId
          }).catch((e2) => {
            console.error(`[chelonia] Error sending OP_KEY_ADD for ${originatingContractID} during key request to ${contractID}`, e2);
            throw e2;
          });
          const payload = {
            contractID: originatingContractID,
            height: rootState.contracts[originatingContractID].height,
            replyWith: signedOutgoingData(originatingContractID, innerSigningKeyId, {
              encryptionKeyId,
              responseKey: encryptedOutgoingData(contractID, innerEncryptionKeyId, keyRequestReplyKeyS)
            }, this.transientSecretKeys),
            request: "*"
          };
          let msg = SPMessage.createV1_0({
            contractID,
            op: [
              SPMessage.OP_KEY_REQUEST,
              signedOutgoingData(contractID, params.signingKeyId, encryptKeyRequestMetadata ? encryptedOutgoingData(contractID, innerEncryptionKeyId, payload) : payload, this.transientSecretKeys)
            ],
            manifest: manifestHash
          });
          msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, {
            ...hooks,
            // We ensure that both messages are placed into the publish queue
            prepublish: (...args) => {
              return keyAddOp().then(() => hooks?.prepublish?.(...args));
            }
          });
          return msg;
        } finally {
          await esm_default("chelonia/contract/release", contractID, { ephemeral: true });
        }
      },
      "chelonia/out/keyRequestResponse": async function(params) {
        const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
        const manifestHash = this.config.contracts.manifests[contractName];
        const contract = this.manifestToContract[manifestHash]?.contract;
        if (!contract) {
          throw new Error("Contract name not found");
        }
        const payload = data;
        let message = SPMessage.createV1_0({
          contractID,
          op: [
            SPMessage.OP_KEY_REQUEST_SEEN,
            signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
          ],
          manifest: manifestHash
        });
        if (!atomic) {
          message = await esm_default("chelonia/private/out/publishEvent", message, publishOptions, hooks);
        }
        return message;
      },
      "chelonia/out/atomic": async function(params) {
        const { contractID, contractName, data, hooks, publishOptions } = params;
        const manifestHash = this.config.contracts.manifests[contractName];
        const contract = this.manifestToContract[manifestHash]?.contract;
        if (!contract) {
          throw new Error("Contract name not found");
        }
        const payload = (await Promise.all(data.map(([selector, opParams]) => {
          if (![
            "chelonia/out/actionEncrypted",
            "chelonia/out/actionUnencrypted",
            "chelonia/out/keyAdd",
            "chelonia/out/keyDel",
            "chelonia/out/keyUpdate",
            "chelonia/out/keyRequestResponse",
            "chelonia/out/keyShare"
          ].includes(selector)) {
            throw new Error("Selector not allowed in OP_ATOMIC: " + selector);
          }
          return esm_default(selector, {
            ...opParams,
            ...params,
            data: opParams.data,
            atomic: true
          });
        }))).flat().filter(Boolean).map((msg2) => {
          return [msg2.opType(), msg2.opValue()];
        });
        let msg = SPMessage.createV1_0({
          contractID,
          op: [
            SPMessage.OP_ATOMIC,
            signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
          ],
          manifest: manifestHash
        });
        msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
        return msg;
      },
      "chelonia/out/protocolUpgrade": async function() {
      },
      "chelonia/out/propSet": async function() {
      },
      "chelonia/out/propDel": async function() {
      },
      "chelonia/out/encryptedOrUnencryptedPubMessage": function({ contractID, innerSigningKeyId, encryptionKeyId, signingKeyId, data }) {
        const serializedData = outputEncryptedOrUnencryptedMessage.call(this, {
          contractID,
          innerSigningKeyId,
          encryptionKeyId,
          signingKeyId,
          data
        });
        this.pubsub.pub(contractID, serializedData);
      },
      // Note: This is a bare-bones function designed for precise control. In many
      // situations, the `chelonia/kv/queuedSet` selector (in chelonia-utils.js)
      // will be simpler and more appropriate to use.
      // In most situations, you want to use some queuing strategy (which this
      // selector doesn't provide) alongside writing to the KV store. Therefore, as
      // a general rule, you shouldn't be calling this selector directly unless
      // you're building a utility library or if you have very specific needs. In
      // this case, see if `chelonia/kv/queuedSet` covers your needs.
      // `data` is allowed to be falsy, in which case a fetch will occur first and
      // the `onconflict` handler will be called.
      "chelonia/kv/set": async function(contractID, key, data, { ifMatch, innerSigningKeyId, encryptionKeyId, signingKeyId, maxAttempts, onconflict }) {
        maxAttempts = maxAttempts ?? 3;
        const url = `${this.config.connectionURL}/kv/${encodeURIComponent(contractID)}/${encodeURIComponent(key)}`;
        const hasOnconflict = typeof onconflict === "function";
        let response;
        const resolveData = async () => {
          let currentValue;
          if (response.ok || response.status === 409 || response.status === 412) {
            const serializedDataText = await response.text();
            currentValue = serializedDataText ? parseEncryptedOrUnencryptedMessage(this, {
              contractID,
              serializedData: JSON.parse(serializedDataText),
              meta: key
            }) : void 0;
          } else if (response.status !== 404 && response.status !== 410) {
            throw new ChelErrorUnexpectedHttpResponseCode("[kv/set] Invalid response code: " + response.status);
          }
          const result = await onconflict({
            contractID,
            key,
            failedData: data,
            status: response.status,
            // If no x-cid or etag header was returned, `ifMatch` would likely be
            // returned as undefined, which will then use the `''` fallback value
            // when writing. This allows 404 / 410 responses to work even if no
            // etag is explicitly given
            etag: response.headers.get("x-cid") || response.headers.get("etag"),
            get currentData() {
              return currentValue?.data;
            },
            currentValue
          });
          if (!result)
            return false;
          data = result[0];
          ifMatch = result[1];
          return true;
        };
        for (; ; ) {
          if (data !== void 0) {
            const serializedData = outputEncryptedOrUnencryptedMessage.call(this, {
              contractID,
              innerSigningKeyId,
              encryptionKeyId,
              signingKeyId,
              data,
              meta: key
            });
            response = await this.config.fetch(url, {
              headers: new Headers([
                ["authorization", buildShelterAuthorizationHeader.call(this, contractID)],
                ["if-match", ifMatch || '""']
              ]),
              method: "POST",
              body: JSON.stringify(serializedData),
              signal: this.abortController.signal
            });
          } else {
            if (!hasOnconflict) {
              throw TypeError("onconflict required with empty data");
            }
            response = await this.config.fetch(url, {
              headers: new Headers([
                ["authorization", buildShelterAuthorizationHeader.call(this, contractID)]
              ]),
              signal: this.abortController.signal
            });
            if (await resolveData()) {
              continue;
            } else {
              break;
            }
          }
          if (!response.ok) {
            if (response.status === 409 || response.status === 412) {
              if (--maxAttempts <= 0) {
                throw new Error("kv/set conflict setting KV value");
              }
              await delay(randomIntFromRange(0, 1500));
              if (hasOnconflict) {
                if (await resolveData()) {
                  continue;
                } else {
                  break;
                }
              } else {
                throw new Error(`kv/set failed with status ${response.status} and no onconflict handler was provided`);
              }
            }
            throw new ChelErrorUnexpectedHttpResponseCode("kv/set invalid response status: " + response.status);
          }
          break;
        }
      },
      "chelonia/kv/get": async function(contractID, key) {
        const response = await this.config.fetch(`${this.config.connectionURL}/kv/${encodeURIComponent(contractID)}/${encodeURIComponent(key)}`, {
          headers: new Headers([
            ["authorization", buildShelterAuthorizationHeader.call(this, contractID)]
          ]),
          signal: this.abortController.signal
        });
        if (response.status === 404) {
          return null;
        }
        if (!response.ok) {
          throw new Error("Invalid response status: " + response.status);
        }
        const data = await response.json();
        return parseEncryptedOrUnencryptedMessage(this, {
          contractID,
          serializedData: data,
          meta: key
        });
      },
      // To set filters for a contract, call with `filter` set to an array of KV
      // keys to receive updates for over the WebSocket. An empty array means that
      // no KV updates will be sent.
      // Calling with a single argument (the contract ID) will remove filters,
      // meaning that KV updates will be sent for _any_ KV key.
      // The last call takes precedence, so, for example, calling with filter
      // set to `['foo', 'bar']` and then with `['baz']` means that KV updates will
      // be received for `baz` only, not for `foo`, `bar` or any other keys.
      "chelonia/kv/setFilter": function(contractID, filter) {
        this.pubsub.setKvFilter(contractID, filter);
      },
      "chelonia/parseEncryptedOrUnencryptedDetachedMessage": function({ contractID, serializedData, meta }) {
        return parseEncryptedOrUnencryptedMessage(this, {
          contractID,
          serializedData,
          meta
        });
      }
    });
    esm_default("sbp/domains/lock", ["chelonia"]);
  }
});
var timer;
var coerceToError;
var defaultOptions2;
var tag;
var PersistentAction;
var persistent_actions_default;
var init_persistent_actions = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/persistent-actions.mjs"() {
    init_esm8();
    init_esm3();
    init_events2();
    timer = Symbol("timer");
    coerceToError = (arg) => {
      if (arg && arg instanceof Error)
        return arg;
      console.warn(tag, "Please use Error objects when throwing or rejecting");
      return new Error((typeof arg === "string" ? arg : JSON.stringify(arg)) ?? "undefined");
    };
    defaultOptions2 = {
      maxAttempts: Number.POSITIVE_INFINITY,
      retrySeconds: 30
    };
    tag = "[chelonia.persistentActions]";
    PersistentAction = class {
      id;
      invocation;
      options;
      status;
      [timer];
      constructor(invocation, options3 = {}) {
        this.id = crypto.randomUUID();
        this.invocation = invocation;
        this.options = { ...defaultOptions2, ...options3 };
        this.status = {
          attempting: false,
          failedAttemptsSoFar: 0,
          lastError: "",
          nextRetry: "",
          resolved: false
        };
      }
      async attempt() {
        if (this.status.attempting || this.status.resolved)
          return;
        if (await this.trySBP(this.options.skipCondition))
          this.cancel();
        if (this.status.resolved)
          return;
        try {
          this.status.attempting = true;
          const result = await esm_default(...this.invocation);
          this.status.attempting = false;
          this.handleSuccess(result);
        } catch (error) {
          this.status.attempting = false;
          await this.handleError(coerceToError(error));
        }
      }
      cancel() {
        if (this[timer])
          clearTimeout(this[timer]);
        this.status.nextRetry = "";
        this.status.resolved = true;
      }
      async handleError(error) {
        const { id, options: options3, status } = this;
        status.failedAttemptsSoFar++;
        status.lastError = error.message;
        const anyAttemptLeft = options3.maxAttempts > status.failedAttemptsSoFar;
        if (!anyAttemptLeft)
          status.resolved = true;
        status.nextRetry = anyAttemptLeft && !status.resolved ? new Date(Date.now() + options3.retrySeconds * 1e3).toISOString() : "";
        esm_default("okTurtles.events/emit", PERSISTENT_ACTION_FAILURE, { error, id });
        await this.trySBP(options3.errorInvocation);
        if (!anyAttemptLeft) {
          esm_default("okTurtles.events/emit", PERSISTENT_ACTION_TOTAL_FAILURE, { error, id });
          await this.trySBP(options3.totalFailureInvocation);
        }
        if (status.nextRetry) {
          this[timer] = setTimeout(() => {
            this.attempt().catch((e2) => {
              console.error("Error attempting persistent action", id, e2);
            });
          }, this.options.retrySeconds * 1e3);
        }
      }
      handleSuccess(result) {
        const { id, status } = this;
        status.lastError = "";
        status.nextRetry = "";
        status.resolved = true;
        esm_default("okTurtles.events/emit", PERSISTENT_ACTION_SUCCESS, { id, result });
      }
      async trySBP(invocation) {
        try {
          return invocation ? await esm_default(...invocation) : void 0;
        } catch (error) {
          console.error(tag, coerceToError(error).message);
        }
      }
    };
    persistent_actions_default = esm_default("sbp/selectors/register", {
      "chelonia.persistentActions/_init"() {
        this.actionsByID = /* @__PURE__ */ Object.create(null);
        this.checkDatabaseKey = () => {
          if (!this.databaseKey)
            throw new TypeError(`${tag} No database key configured`);
        };
        esm_default("okTurtles.events/on", PERSISTENT_ACTION_SUCCESS, ({ id }) => {
          esm_default("chelonia.persistentActions/cancel", id);
        });
        esm_default("okTurtles.events/on", PERSISTENT_ACTION_TOTAL_FAILURE, ({ id }) => {
          esm_default("chelonia.persistentActions/cancel", id);
        });
      },
      // Cancels a specific action by its ID.
      // The action won't be retried again, but an async action cannot be aborted if its promise is stil attempting.
      async "chelonia.persistentActions/cancel"(id) {
        if (id in this.actionsByID) {
          this.actionsByID[id].cancel();
          delete this.actionsByID[id];
          return await esm_default("chelonia.persistentActions/save");
        }
      },
      // TODO: validation
      "chelonia.persistentActions/configure"({ databaseKey, options: options3 = {} }) {
        this.databaseKey = databaseKey;
        for (const key in options3) {
          if (key in defaultOptions2) {
            defaultOptions2[key] = options3[key];
          } else {
            throw new TypeError(`${tag} Unknown option: ${key}`);
          }
        }
      },
      "chelonia.persistentActions/enqueue"(...args) {
        const ids = [];
        for (const arg of args) {
          const action = Array.isArray(arg) ? new PersistentAction(arg) : new PersistentAction(arg.invocation, arg);
          this.actionsByID[action.id] = action;
          ids.push(action.id);
        }
        esm_default("chelonia.persistentActions/save").catch((e2) => {
          console.error("Error saving persistent actions", e2);
        });
        for (const id of ids) {
          this.actionsByID[id].attempt().catch((e2) => {
            console.error("Error attempting persistent action", id, e2);
          });
        }
        return ids;
      },
      // Forces retrying a given persisted action immediately, rather than waiting for the scheduled retry.
      // - 'status.failedAttemptsSoFar' will still be increased upon failure.
      // - Does nothing if a retry is already running.
      // - Does nothing if the action has already been resolved, rejected or cancelled.
      "chelonia.persistentActions/forceRetry"(id) {
        if (id in this.actionsByID) {
          return this.actionsByID[id].attempt();
        }
      },
      // Loads and tries every stored persistent action under the configured database key.
      async "chelonia.persistentActions/load"() {
        this.checkDatabaseKey();
        const storedActions = JSON.parse(await esm_default("chelonia.db/get", this.databaseKey) ?? "[]");
        for (const { id, invocation, options: options3 } of storedActions) {
          this.actionsByID[id] = new PersistentAction(invocation, options3);
          this.actionsByID[id].id = id;
        }
        return esm_default("chelonia.persistentActions/retryAll");
      },
      // Retry all existing persisted actions.
      // TODO: add some delay between actions so as not to spam the server,
      // or have a way to issue them all at once in a single network call.
      "chelonia.persistentActions/retryAll"() {
        return Promise.allSettled(Object.keys(this.actionsByID).map((id) => esm_default("chelonia.persistentActions/forceRetry", id)));
      },
      // Updates the database version of the attempting action list.
      "chelonia.persistentActions/save"() {
        this.checkDatabaseKey();
        return esm_default("chelonia.db/set", this.databaseKey, JSON.stringify(Object.values(this.actionsByID)));
      },
      "chelonia.persistentActions/status"() {
        return Object.values(this.actionsByID).map((action) => ({
          id: action.id,
          invocation: action.invocation,
          ...action.status
        }));
      },
      // Pauses every currently loaded action, and removes them from memory.
      // Note: persistent storage is not affected, so that these actions can be later loaded again and retried.
      "chelonia.persistentActions/unload"() {
        for (const id in this.actionsByID) {
          if (this.actionsByID[id][timer]) {
            clearTimeout(this.actionsByID[id][timer]);
          }
          delete this.actionsByID[id];
        }
      }
    });
  }
});
var SERVER;
var init_presets = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/presets.mjs"() {
    SERVER = {
      // We don't check the subscriptionSet in the server because we accpt new
      // contract registrations, and are also not subcribed to contracts the same
      // way clients are
      acceptAllMessages: true,
      // The server also doesn't process actions
      skipActionProcessing: true,
      // The previous setting implies this one, which we set to be on the safe side
      skipSideEffects: true,
      // Changes the behaviour of unwrapMaybeEncryptedData so that it never decrypts.
      // Mostly useful for the server, to avoid filling up the logs and for faster
      // execution.
      skipDecryptionAttempts: true,
      // If an error occurs during processing, the message is rejected rather than
      // ignored
      strictProcessing: true,
      // The server expects events to be received in order (no past or future events)
      strictOrdering: true
    };
  }
});
var import_boom;
var plugin;
var auth_default;
var init_auth = __esm({
  "src/serve/auth.ts"() {
    "use strict";
    init_utils2();
    import_boom = __toESM(require_lib6());
    plugin = {
      name: "chel-auth",
      register: function(server) {
        server.auth.scheme("chel-bearer", () => {
          return {
            authenticate: function(request, h2) {
              const { authorization } = request.headers;
              if (!authorization) {
                return h2.unauthenticated(import_boom.default.unauthorized(null, "bearer"));
              }
              const thisScheme = "bearer ";
              if (authorization.slice(0, thisScheme.length) !== thisScheme) {
                return h2.unauthenticated(import_boom.default.unauthorized(null, "bearer"));
              }
              const token = authorization.slice(thisScheme.length);
              return h2.authenticated({ credentials: { token } });
            }
          };
        });
        server.auth.scheme("chel-shelter", () => {
          return {
            authenticate: function(request, h2) {
              const { authorization } = request.headers;
              if (!authorization) {
                return h2.unauthenticated(import_boom.default.unauthorized(null, "shelter"));
              }
              const thisScheme = "shelter ";
              if (authorization.slice(0, thisScheme.length) !== thisScheme) {
                return h2.unauthenticated(import_boom.default.unauthorized(null, "shelter"));
              }
              try {
                const billableContractID = verifyShelterAuthorizationHeader(authorization);
                return h2.authenticated({ credentials: { billableContractID } });
              } catch (e2) {
                console.warn(e2, "Shelter authorization failed");
                return h2.unauthenticated(import_boom.default.unauthorized("Authentication failed", "shelter"));
              }
            }
          };
        });
        server.auth.strategy("chel-bearer", "chel-bearer");
        server.auth.strategy("chel-shelter", "chel-shelter");
      }
    };
    auth_default = plugin;
  }
});
var CREDITS_WORKER_TASK_TIME_INTERVAL;
var OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL;
var init_constants2 = __esm({
  "src/serve/constants.ts"() {
    "use strict";
    CREDITS_WORKER_TASK_TIME_INTERVAL = 3e5;
    OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL = 3e4;
  }
});
var require_lru_cache2 = __commonJS({
  "node_modules/.deno/lru-cache@7.14.0/node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e2 = { type, target: this };
          this.onabort(e2);
          this._listeners.forEach((f) => f(e2), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code2 = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code2)) {
        warn(code2, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code2 = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code2)) {
        const { prototype } = LRUCache;
        const { get: get22 } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code2, `${method} method`, `cache.${instead}()`, get22);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code2 = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code2)) {
        const { prototype } = LRUCache;
        const { get: get22 } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code2, `${field} property`, `cache.${instead}`, get22);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code2) => !warned.has(code2);
    var warn = (code2, what, instead, fn) => {
      warned.add(code2);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code2, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options3 = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          maxEntrySize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet
        } = options3;
        const { length: length4, maxAge: maxAge2, stale } = options3 instanceof _LRUCache ? {} : options3;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length4;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize or maxEntrySize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError(
                "maxSize must be a positive integer if specified"
              );
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError(
              "maxEntrySize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge2 || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code2 = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code2)) {
            warned.add(code2);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code2, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge2) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length4) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v2, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v2, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, size) {
      }
      requireSize(k, v2, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize or maxEntrySize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.tail; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.head) {
              break;
            } else {
              i2 = this.prev[i2];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.head; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.tail) {
              break;
            } else {
              i2 = this.next[i2];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i2 of this.indexes()) {
          yield [this.keyList[i2], this.valList[i2]];
        }
      }
      *rentries() {
        for (const i2 of this.rindexes()) {
          yield [this.keyList[i2], this.valList[i2]];
        }
      }
      *keys() {
        for (const i2 of this.indexes()) {
          yield this.keyList[i2];
        }
      }
      *rkeys() {
        for (const i2 of this.rindexes()) {
          yield this.keyList[i2];
        }
      }
      *values() {
        for (const i2 of this.indexes()) {
          yield this.valList[i2];
        }
      }
      *rvalues() {
        for (const i2 of this.rindexes()) {
          yield this.valList[i2];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i2 of this.indexes()) {
          if (fn(this.valList[i2], this.keyList[i2], this)) {
            return this.get(this.keyList[i2], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i2 of this.indexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i2 of this.rindexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i2 of this.rindexes({ allowStale: true })) {
          if (this.isStale(i2)) {
            this.delete(this.keyList[i2]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i2 of this.indexes({ allowStale: true })) {
          const key = this.keyList[i2];
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i2];
            const age = perf.now() - this.starts[i2];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i2];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v2, k, reason) {
      }
      set(k, v2, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v2, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v2;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v2 !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v2;
            this.addItemSize(index, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v2 = this.valList[head];
        if (this.isBackgroundFetch(v2)) {
          v2.__abortController.abort();
        } else {
          this.dispose(v2, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v2, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v2 = this.valList[index];
          return this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
        }
      }
      backgroundFetch(k, index, options3, context) {
        const v2 = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v2)) {
          return v2;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options: options3,
          context
        };
        const cb = (v3) => {
          if (!ac.signal.aborted) {
            this.set(k, v3, fetchOpts.options);
          }
          return v3;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options3.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v2, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v2;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = false
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet
          });
        }
        const options3 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          return p.__returned = p;
        } else {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            return allowStale && v2.__staleWhileFetching !== void 0 ? v2.__staleWhileFetching : v2.__returned = v2;
          }
          if (!forceRefresh && !this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v2;
          }
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v2 = this.valList[index];
              if (this.isBackgroundFetch(v2)) {
                v2.__abortController.abort();
              } else {
                this.dispose(v2, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v2, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v2, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v2, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});
var vapidPublicKey;
var vapidPrivateKey;
var vapid;
var initVapid;
var generateJwt;
var getVapidPublicKey;
var vapidAuthorization;
var init_vapid = __esm({
  "src/serve/vapid.ts"() {
    "use strict";
    init_esm3();
    if (!process4.env.VAPID_EMAIL) {
      console.warn('Missing VAPID identification. Please set VAPID_EMAIL to a value like "mailto:some@example".');
    }
    vapid = { VAPID_EMAIL: process4.env.VAPID_EMAIL || "mailto:test@example.com" };
    initVapid = async () => {
      const vapidKeyPair = await esm_default("chelonia.db/get", "_private_immutable_vapid_key").then(async (vapidKeyPair2) => {
        if (!vapidKeyPair2) {
          console.info("Generating new VAPID keypair...");
          const keyPair = await crypto.subtle.generateKey(
            {
              name: "ECDSA",
              namedCurve: "P-256"
              // Use P-256 curve
            },
            true,
            // Whether the key is extractable
            ["sign", "verify"]
            // Usages
          );
          const serializedKeyPair2 = await Promise.all([
            crypto.subtle.exportKey("jwk", keyPair.privateKey),
            crypto.subtle.exportKey("raw", keyPair.publicKey).then(
              (key) => Buffer7.from(key).toString("base64url")
            )
          ]);
          return esm_default("chelonia.db/set", "_private_immutable_vapid_key", JSON.stringify(serializedKeyPair2)).then(() => {
            console.info("Successfully saved newly generated VAPID keys");
            return [keyPair.privateKey, serializedKeyPair2[1]];
          });
        }
        const serializedKeyPair = JSON.parse(vapidKeyPair2);
        return [
          await crypto.subtle.importKey(
            "jwk",
            serializedKeyPair[0],
            { name: "ECDSA", namedCurve: "P-256" },
            false,
            ["sign"]
          ),
          serializedKeyPair[1]
        ];
      });
      vapidPrivateKey = vapidKeyPair[0];
      vapidPublicKey = vapidKeyPair[1];
    };
    generateJwt = async (endpoint) => {
      const now = Date.now() / 1e3 | 0;
      const audience = endpoint.origin;
      const header = Buffer7.from(JSON.stringify(
        Object.fromEntries([["typ", "JWT"], ["alg", "ES256"]])
      )).toString("base64url");
      const body = Buffer7.from(JSON.stringify(
        // We're expecting to use the JWT immediately. We set a 10-minute window
        // for using the JWT (5 minutes into the past, 5 minutes into the future)
        // to account for potential network delays and clock drift.
        Object.fromEntries([
          // token audience
          ["aud", audience],
          // 'expiry' / 'not after' value for the token
          ["exp", now + 300],
          // (optional) issuance time for the token
          ["iat", now],
          // 'not before' value for the JWT
          ["nbf", now - 300],
          // URI used for identifying ourselves. This can be used by the push
          // provider to get in touch in case of issues.
          ["sub", vapid.VAPID_EMAIL]
        ])
      )).toString("base64url");
      const signature = Buffer7.from(
        await crypto.subtle.sign(
          { name: "ECDSA", hash: "SHA-256" },
          vapidPrivateKey,
          Buffer7.from([header, body].join("."))
        )
      ).toString("base64url");
      return [header, body, signature].join(".");
    };
    getVapidPublicKey = () => vapidPublicKey;
    vapidAuthorization = async (endpoint) => {
      const jwt = await generateJwt(endpoint);
      return `vapid t=${jwt}, k=${vapidPublicKey}`;
    };
  }
});
var AUTHSALT;
var CONTRACTSALT;
var CS;
var SU;
var SALT_LENGTH_IN_OCTETS;
var init_zkppConstants = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/zkppConstants.mjs"() {
    AUTHSALT = "AUTHSALT";
    CONTRACTSALT = "CONTRACTSALT";
    CS = "CS";
    SU = "SU";
    SALT_LENGTH_IN_OCTETS = 24;
  }
});
var import_scrypt_async2;
var import_tweetnacl2;
var base64ToBase64url;
var base64urlToBase64;
var hashStringArray;
var hashRawStringArray;
var randomNonce;
var hash2;
var computeCAndHc;
var encryptContractSalt;
var encryptSaltUpdate;
var decryptSaltUpdate;
var boxKeyPair;
var saltAgreement;
var parseRegisterSalt;
var init_zkpp = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/zkpp.mjs"() {
    import_scrypt_async2 = __toESM(require_scrypt_async(), 1);
    import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
    init_zkppConstants();
    base64ToBase64url = (s) => s.replace(/\//g, "_").replace(/\+/g, "-").replace(/=*$/, "");
    base64urlToBase64 = (s) => s.replace(/_/g, "/").replace(/-/g, "+") + "=".repeat((4 - s.length % 4) % 4);
    hashStringArray = (...args) => {
      return import_tweetnacl2.default.hash(Buffer8.concat(args.map((s) => import_tweetnacl2.default.hash(Buffer8.from(s)))));
    };
    hashRawStringArray = (...args) => {
      return import_tweetnacl2.default.hash(Buffer8.concat(args.map((s) => Buffer8.from(s))));
    };
    randomNonce = () => {
      return base64ToBase64url(Buffer8.from(import_tweetnacl2.default.randomBytes(12)).toString("base64"));
    };
    hash2 = (v2) => {
      return base64ToBase64url(Buffer8.from(import_tweetnacl2.default.hash(Buffer8.from(v2))).toString("base64"));
    };
    computeCAndHc = (r, s, h2) => {
      const \u0127 = hashStringArray(r, s);
      const c = hashStringArray(h2, \u0127);
      const hc = import_tweetnacl2.default.hash(c);
      return [c, hc];
    };
    encryptContractSalt = (c, contractSalt) => {
      const encryptionKey = hashRawStringArray(CS, c).slice(0, import_tweetnacl2.default.secretbox.keyLength);
      const nonce = import_tweetnacl2.default.randomBytes(import_tweetnacl2.default.secretbox.nonceLength);
      const encryptedContractSalt = import_tweetnacl2.default.secretbox(Buffer8.from(contractSalt), nonce, encryptionKey);
      return base64ToBase64url(Buffer8.concat([nonce, encryptedContractSalt]).toString("base64"));
    };
    encryptSaltUpdate = (secret, recordId, record) => {
      const nonce = import_tweetnacl2.default.randomBytes(import_tweetnacl2.default.secretbox.nonceLength);
      const encryptionKey = hashRawStringArray(SU, secret, nonce, recordId).slice(0, import_tweetnacl2.default.secretbox.keyLength);
      const encryptedRecord = import_tweetnacl2.default.secretbox(Buffer8.from(record), nonce, encryptionKey);
      return base64ToBase64url(Buffer8.concat([nonce, encryptedRecord]).toString("base64"));
    };
    decryptSaltUpdate = (secret, recordId, encryptedRecordBox) => {
      const encryptedRecordBoxBuf = Buffer8.from(base64urlToBase64(encryptedRecordBox), "base64");
      const nonce = encryptedRecordBoxBuf.subarray(0, import_tweetnacl2.default.secretbox.nonceLength);
      const encryptionKey = hashRawStringArray(SU, secret, nonce, recordId).slice(0, import_tweetnacl2.default.secretbox.keyLength);
      const encryptedRecord = encryptedRecordBoxBuf.subarray(import_tweetnacl2.default.secretbox.nonceLength);
      const decrypted = import_tweetnacl2.default.secretbox.open(encryptedRecord, nonce, encryptionKey);
      if (!decrypted)
        throw new Error("Failed to decrypt salt update");
      return Buffer8.from(decrypted).toString();
    };
    boxKeyPair = () => {
      return import_tweetnacl2.default.box.keyPair();
    };
    saltAgreement = (publicKey, secretKey) => {
      const publicKeyBuf = Buffer8.from(base64urlToBase64(publicKey), "base64");
      const dhKey = import_tweetnacl2.default.box.before(publicKeyBuf, secretKey);
      if (!publicKeyBuf || publicKeyBuf.byteLength !== import_tweetnacl2.default.box.publicKeyLength) {
        return false;
      }
      const authSalt = Buffer8.from(hashStringArray(AUTHSALT, dhKey)).subarray(0, SALT_LENGTH_IN_OCTETS).toString("base64");
      const contractSalt = Buffer8.from(hashStringArray(CONTRACTSALT, dhKey)).subarray(0, SALT_LENGTH_IN_OCTETS).toString("base64");
      return [authSalt, contractSalt];
    };
    parseRegisterSalt = (publicKey, secretKey, encryptedHashedPassword) => {
      const saltAgreementRes = saltAgreement(publicKey, secretKey);
      if (!saltAgreementRes) {
        return false;
      }
      const [authSalt, contractSalt] = saltAgreementRes;
      const encryptionKey = import_tweetnacl2.default.hash(Buffer8.from(authSalt + contractSalt)).slice(0, import_tweetnacl2.default.secretbox.keyLength);
      const encryptedHashedPasswordBuf = Buffer8.from(base64urlToBase64(encryptedHashedPassword), "base64");
      const hashedPasswordBuf = import_tweetnacl2.default.secretbox.open(encryptedHashedPasswordBuf.subarray(import_tweetnacl2.default.box.nonceLength), encryptedHashedPasswordBuf.subarray(0, import_tweetnacl2.default.box.nonceLength), encryptionKey);
      if (!hashedPasswordBuf) {
        return false;
      }
      return [authSalt, contractSalt, hashedPasswordBuf, encryptionKey];
    };
  }
});
var import_npm_tweetnacl;
var nacl3;
var recordSecret;
var challengeSecret;
var registrationSecret;
var hashUpdateSecret;
var initZkpp;
var maxAge;
var computeZkppSaltRecordId;
var getZkppSaltRecord;
var setZkppSaltRecord;
var getChallenge;
var verifyChallenge;
var registrationKey;
var register;
var contractSaltVerifyC;
var getContractSalt;
var updateContractSalt;
var redeemSaltRegistrationToken;
var redeemSaltUpdateToken;
var init_zkppSalt = __esm({
  "src/serve/zkppSalt.ts"() {
    "use strict";
    init_zkpp();
    init_zkppConstants();
    init_esm3();
    import_npm_tweetnacl = __toESM(require_nacl_fast());
    nacl3 = import_npm_tweetnacl.default;
    initZkpp = async () => {
      const IKM = await esm_default("chelonia.db/get", "_private_immutable_zkpp_ikm").then((IKM2) => {
        if (!IKM2) {
          const secret = randomBytes2(33).toString("base64");
          return esm_default("chelonia.db/set", "_private_immutable_zkpp_ikm", secret).then(() => {
            return secret;
          });
        }
        return IKM2;
      });
      recordSecret = Buffer9.from(hashStringArray("private/recordSecret", IKM)).toString("base64");
      challengeSecret = Buffer9.from(hashStringArray("private/challengeSecret", IKM)).toString("base64");
      registrationSecret = Buffer9.from(hashStringArray("private/registrationSecret", IKM)).toString("base64");
      hashUpdateSecret = Buffer9.from(hashStringArray("private/hashUpdateSecret", IKM)).toString("base64");
    };
    maxAge = 30;
    computeZkppSaltRecordId = async (contractID) => {
      const recordId = `_private_rid_${contractID}`;
      const record = await esm_default("chelonia.db/get", recordId);
      if (!record) {
        return null;
      }
      const recordBuf = Buffer9.concat([Buffer9.from(contractID), Buffer9.from(record)]);
      return hash2(recordBuf);
    };
    getZkppSaltRecord = async (contractID) => {
      const recordId = `_private_rid_${contractID}`;
      const record = await esm_default("chelonia.db/get", recordId);
      if (record) {
        const encryptionKey = hashStringArray("REK", contractID, recordSecret).slice(0, nacl3.secretbox.keyLength);
        const recordBuf = Buffer9.from(base64urlToBase64(record), "base64");
        const nonce = recordBuf.slice(0, nacl3.secretbox.nonceLength);
        const recordCiphertext = recordBuf.slice(nacl3.secretbox.nonceLength);
        const recordPlaintext = nacl3.secretbox.open(recordCiphertext, nonce, encryptionKey);
        if (!recordPlaintext) {
          return null;
        }
        const recordString = Buffer9.from(recordPlaintext).toString("utf-8");
        try {
          const recordObj = JSON.parse(recordString);
          if (!Array.isArray(recordObj) || recordObj.length !== 3 && recordObj.length !== 4 || recordObj.slice(0, 3).some((r) => !r || typeof r !== "string") || recordObj[3] != null && typeof recordObj[3] !== "string") {
            console.error("Error validating encrypted JSON object " + recordId);
            return null;
          }
          const [hashedPassword, authSalt, contractSalt, cid] = recordObj;
          return {
            hashedPassword,
            authSalt,
            contractSalt,
            cid
          };
        } catch {
          console.error("Error parsing encrypted JSON object " + recordId);
        }
      }
      return null;
    };
    setZkppSaltRecord = async (contractID, hashedPassword, authSalt, contractSalt, cid) => {
      const recordId = `_private_rid_${contractID}`;
      const encryptionKey = hashStringArray("REK", contractID, recordSecret).slice(0, nacl3.secretbox.keyLength);
      const nonce = nacl3.randomBytes(nacl3.secretbox.nonceLength);
      const recordPlaintext = JSON.stringify([hashedPassword, authSalt, contractSalt, cid]);
      const recordCiphertext = nacl3.secretbox(Buffer9.from(recordPlaintext), nonce, encryptionKey);
      const recordBuf = Buffer9.concat([nonce, recordCiphertext]);
      const record = base64ToBase64url(recordBuf.toString("base64"));
      await esm_default("chelonia.db/set", recordId, record);
    };
    getChallenge = async (contract, b) => {
      const record = await getZkppSaltRecord(contract);
      if (!record) {
        console.debug("getChallenge: Error obtaining ZKPP salt record for contract ID " + contract);
        return false;
      }
      const { authSalt } = record;
      const s = randomNonce();
      const now = (Date.now() / 1e3 | 0).toString(16);
      const sig = [now, base64ToBase64url(Buffer9.from(hashStringArray(contract, b, s, now, challengeSecret)).toString("base64"))].join(",");
      return {
        authSalt,
        s,
        sig
      };
    };
    verifyChallenge = (contractID, r, s, userSig) => {
      if (!/^[a-fA-F0-9]{1,11},[a-zA-Z0-9_-]{86}(?:==)?$/.test(userSig)) {
        console.info(`wrong signature format for challenge for contract: ${contractID}`);
        return false;
      }
      const [then, mac] = userSig.split(",");
      const now = Date.now() / 1e3 | 0;
      const iThen = Number.parseInt(then, 16);
      if (!(iThen <= now) || !(iThen >= now - maxAge)) {
        return false;
      }
      const b = hash2(r);
      const sig = hashStringArray(contractID, b, s, then, challengeSecret);
      const macBuf = Buffer9.from(base64urlToBase64(mac), "base64");
      return sig.byteLength === macBuf.byteLength && timingSafeEqual(sig, macBuf);
    };
    registrationKey = (provisionalId, b) => {
      const encryptionKey = hashStringArray("REG", provisionalId, registrationSecret).slice(0, nacl3.secretbox.keyLength);
      const nonce = nacl3.randomBytes(nacl3.secretbox.nonceLength);
      const keyPair = boxKeyPair();
      const s = base64ToBase64url(Buffer9.concat([nonce, nacl3.secretbox(keyPair.secretKey, nonce, encryptionKey)]).toString("base64"));
      const now = (Date.now() / 1e3 | 0).toString(16);
      const sig = [now, base64ToBase64url(Buffer9.from(hashStringArray(provisionalId, b, s, now, challengeSecret)).toString("base64"))].join(",");
      return {
        s,
        p: base64ToBase64url(Buffer9.from(keyPair.publicKey).toString("base64")),
        sig
      };
    };
    register = (provisionalId, clientPublicKey, encryptedSecretKey, userSig, encryptedHashedPassword) => {
      if (!verifyChallenge(provisionalId, clientPublicKey, encryptedSecretKey, userSig)) {
        console.warn("register: Error validating challenge: " + JSON.stringify({ contract: provisionalId, clientPublicKey, userSig }));
        throw new Error("register: Invalid challenge");
      }
      const encryptedSecretKeyBuf = Buffer9.from(base64urlToBase64(encryptedSecretKey), "base64");
      const encryptionKey = hashStringArray("REG", provisionalId, registrationSecret).slice(0, nacl3.secretbox.keyLength);
      const secretKeyBuf = nacl3.secretbox.open(encryptedSecretKeyBuf.slice(nacl3.secretbox.nonceLength), encryptedSecretKeyBuf.slice(0, nacl3.secretbox.nonceLength), encryptionKey);
      if (!secretKeyBuf) {
        console.warn(`register: Error decrypting arguments for contract ID ${provisionalId} (${JSON.stringify({ clientPublicKey, userSig })})`);
        return false;
      }
      const parseRegisterSaltRes = parseRegisterSalt(clientPublicKey, secretKeyBuf, encryptedHashedPassword);
      if (!parseRegisterSaltRes) {
        console.warn(`register: Error parsing registration salt for contract ID ${provisionalId} (${JSON.stringify({ clientPublicKey, userSig })})`);
        return false;
      }
      const [authSalt, contractSalt, hashedPasswordBuf, sharedEncryptionKey] = parseRegisterSaltRes;
      const token = encryptSaltUpdate(
        hashUpdateSecret,
        provisionalId,
        JSON.stringify([Date.now(), Buffer9.from(hashedPasswordBuf).toString(), authSalt, contractSalt])
      );
      return encryptContractSalt(sharedEncryptionKey, token);
    };
    contractSaltVerifyC = (h2, r, s, userHc) => {
      const [c, hc] = computeCAndHc(r, s, h2);
      const userHcBuf = Buffer9.from(base64urlToBase64(userHc), "base64");
      if (hc.byteLength === userHcBuf.byteLength && timingSafeEqual(hc, userHcBuf)) {
        return c;
      }
      return false;
    };
    getContractSalt = async (contract, r, s, sig, hc) => {
      if (!verifyChallenge(contract, r, s, sig)) {
        console.debug("getContractSalt: Error validating challenge: " + JSON.stringify({ contract, r, s, sig }));
        throw new Error("getContractSalt: Bad challenge");
      }
      const record = await getZkppSaltRecord(contract);
      if (!record) {
        console.error("getContractSalt: Error obtaining ZKPP salt record for contract ID " + contract);
        return false;
      }
      const { hashedPassword, contractSalt, cid } = record;
      const c = contractSaltVerifyC(hashedPassword, r, s, hc);
      if (!c) {
        console.error(`getContractSalt: Error verifying challenge for contract ID ${contract} (${JSON.stringify({ r, s, hc })})`);
        throw new Error("getContractSalt: Bad challenge");
      }
      return encryptContractSalt(c, JSON.stringify([contractSalt, cid]));
    };
    updateContractSalt = async (contract, r, s, sig, hc, encryptedArgs) => {
      if (!verifyChallenge(contract, r, s, sig)) {
        console.warn("update: Error validating challenge: " + JSON.stringify({ contract, r, s, sig }));
        throw new Error("update: Bad challenge");
      }
      const record = await getZkppSaltRecord(contract);
      if (!record) {
        console.error("update: Error obtaining ZKPP salt record for contract ID " + contract);
        return false;
      }
      const { hashedPassword, contractSalt: oldContractSalt } = record;
      const c = contractSaltVerifyC(hashedPassword, r, s, hc);
      if (!c) {
        console.error(`update: Error verifying challenge for contract ID ${contract} (${JSON.stringify({ r, s, hc })})`);
        throw new Error("update: Bad challenge");
      }
      const encryptionKey = hashRawStringArray(SU, c).slice(0, nacl3.secretbox.keyLength);
      const encryptedArgsBuf = Buffer9.from(base64urlToBase64(encryptedArgs), "base64");
      const nonce = encryptedArgsBuf.slice(0, nacl3.secretbox.nonceLength);
      const encryptedArgsCiphertext = encryptedArgsBuf.slice(nacl3.secretbox.nonceLength);
      const args = nacl3.secretbox.open(encryptedArgsCiphertext, nonce, encryptionKey);
      if (!args) {
        console.error(`update: Error decrypting arguments for contract ID ${contract} (${JSON.stringify({ r, s, hc })})`);
        return false;
      }
      try {
        const hashedPassword2 = Buffer9.from(args).toString();
        const recordId = await computeZkppSaltRecordId(contract);
        if (!recordId) {
          console.error(`update: Error obtaining record ID for contract ID ${contract}`);
          return false;
        }
        const authSalt = Buffer9.from(hashStringArray(AUTHSALT, c)).slice(0, SALT_LENGTH_IN_OCTETS).toString("base64");
        const contractSalt = Buffer9.from(hashStringArray(CONTRACTSALT, c)).slice(0, SALT_LENGTH_IN_OCTETS).toString("base64");
        const token = encryptSaltUpdate(
          hashUpdateSecret,
          recordId,
          JSON.stringify([Date.now(), hashedPassword2, authSalt, contractSalt])
        );
        return encryptContractSalt(c, JSON.stringify([oldContractSalt, token]));
      } catch {
        console.error(`update: Error parsing encrypted arguments for contract ID ${contract} (${JSON.stringify({ r, s, hc })})`);
      }
      return false;
    };
    redeemSaltRegistrationToken = async (provisoryRegistrationKey, contract, token) => {
      const decryptedToken = decryptSaltUpdate(
        hashUpdateSecret,
        provisoryRegistrationKey,
        token
      );
      const [timestamp, hashedPassword, authSalt, contractSalt] = JSON.parse(decryptedToken);
      if (timestamp < Date.now() - 18e4) {
        throw new Error("ZKPP token expired");
      }
      await setZkppSaltRecord(contract, hashedPassword, authSalt, contractSalt);
    };
    redeemSaltUpdateToken = async (contract, token) => {
      const recordId = await computeZkppSaltRecordId(contract);
      if (!recordId) {
        throw new Error("Record ID not found");
      }
      const decryptedToken = decryptSaltUpdate(
        hashUpdateSecret,
        recordId,
        token
      );
      const [timestamp, hashedPassword, authSalt, contractSalt] = JSON.parse(decryptedToken);
      if (timestamp < Date.now() - 18e4) {
        throw new Error("ZKPP token expired");
      }
      return (cid) => {
        return setZkppSaltRecord(contract, hashedPassword, authSalt, contractSalt, cid);
      };
    };
  }
});
var requiredMethodNames;
var DatabaseBackend;
var init_DatabaseBackend = __esm({
  "src/serve/DatabaseBackend.ts"() {
    "use strict";
    requiredMethodNames = ["init", "clear", "readData", "writeData", "deleteData", "close"];
    DatabaseBackend = class _DatabaseBackend {
      constructor() {
        if (new.target === _DatabaseBackend) {
          throw new Error("Class DatabaseBackend cannot be instantiated directly.");
        }
        const bindMethod = (name) => {
          this[name] = this[name].bind(this);
        };
        for (const name of requiredMethodNames) {
          bindMethod(name);
        }
      }
    };
  }
});
var database_fs_exports2 = {};
__export(database_fs_exports2, {
  default: () => FsBackend
});
async function testCaseSensitivity(backend2) {
  const { readData: readData3, writeData: writeData3, deleteData } = backend2;
  const date3 = /* @__PURE__ */ new Date();
  const dateString = date3.toISOString();
  const originalKey = `_private_testCaseSensitivity_${date3.getTime()}_${(0, Math.random)().toFixed(8).slice(2)}`;
  const differentlyCasedKey = "_P" + originalKey.slice(2);
  await writeData3(originalKey, dateString);
  try {
    const valueOriginalCase = await readData3(originalKey);
    const valueDifferentCase = await readData3(differentlyCasedKey);
    if (valueOriginalCase?.toString() !== dateString) {
      console.error(`Unexpected value on case-sensitivity test; expected ${dateString}`);
      throw new Error("Unexpected value: original key does not have the correct value");
    }
    if (valueDifferentCase?.toString() === dateString) {
      const errStr = "Filesystem database backend only works on case-sensitive filesystems. This appears to be a case insensitive file system. Set SKIP_DB_FS_CASE_SENSITIVITY_CHECK=true to skip.";
      console.error(errStr);
      throw new Error(errStr);
    }
  } finally {
    await deleteData(originalKey);
  }
}
var splitAndGroup;
var FsBackend;
var init_database_fs2 = __esm({
  "src/serve/database-fs.ts"() {
    "use strict";
    init_db();
    init_DatabaseBackend();
    splitAndGroup = (input, chunkLength, depth) => input.slice(0, chunkLength * depth).split("").reduce((acc, cv, i2) => {
      acc[i2 / chunkLength | 0] = (acc[i2 / chunkLength | 0] || "") + cv;
      return acc;
    }, []);
    FsBackend = class extends DatabaseBackend {
      dataFolder = "";
      depth = 0;
      keyChunkLength = 2;
      constructor(options3 = {}) {
        super();
        this.dataFolder = resolve52(options3.dirname);
        if (options3.depth) this.depth = options3.depth;
        if (options3.keyChunkLength) this.keyChunkLength = options3.keyChunkLength;
      }
      // Maps a given key to a real path on the filesystem.
      mapKey(key) {
        if (basename42(normalize6(key)) !== key) throw new TypeError("Invalid key");
        if (!this.depth) return join6(this.dataFolder, key);
        const keyChunks = splitAndGroup(key, this.keyChunkLength, this.depth);
        return join6(this.dataFolder, ...keyChunks, key);
      }
      async init() {
        await mkdir(this.dataFolder, { mode: 488, recursive: true });
        if (process5.env.SKIP_DB_FS_CASE_SENSITIVITY_CHECK === void 0) {
          await testCaseSensitivity(this);
        }
      }
      async clear() {
        const names = await readdir(this.dataFolder);
        const paths = names.map((name) => join6(this.dataFolder, name));
        await Promise.all(
          paths.map((p) => rm(p, { recursive: true }))
        );
      }
      async readData(key) {
        checkKey2(key);
        return await readFile(this.mapKey(key)).catch((err) => {
          if (err.code !== "ENOENT") throw err;
        });
      }
      async writeData(key, value) {
        const path12 = this.mapKey(key);
        if (this.depth) await mkdir(dirname42(path12), { mode: 488, recursive: true });
        await writeFile(path12, value);
      }
      async deleteData(key) {
        await unlink(this.mapKey(key)).catch((e2) => {
          if (e2?.code === "ENOENT") {
            return;
          }
          throw e2;
        });
      }
      close() {
      }
    };
  }
});
var database_sqlite_exports2 = {};
__export(database_sqlite_exports2, {
  default: () => SqliteBackend
});
var SqliteBackend;
var init_database_sqlite2 = __esm({
  "src/serve/database-sqlite.ts"() {
    "use strict";
    init_DatabaseBackend();
    SqliteBackend = class extends DatabaseBackend {
      dataFolder = "";
      db = null;
      filename = "";
      readStatement = null;
      writeStatement = null;
      deleteStatement = null;
      constructor(options3 = {}) {
        super();
        const { filepath } = options3;
        const resolvedPath = resolve6(filepath);
        this.dataFolder = dirname52(resolvedPath);
        this.filename = basename52(resolvedPath);
      }
      run(sql) {
        this.db.prepare(sql).run();
      }
      async init() {
        const { dataFolder: dataFolder4, filename } = this;
        await mkdir2(dataFolder4, { mode: 488, recursive: true });
        if (this.db) {
          throw new Error(`The ${filename} SQLite database is already open.`);
        }
        this.db = new Database(join7(dataFolder4, filename));
        this.run("CREATE TABLE IF NOT EXISTS Data(key TEXT NOT NULL PRIMARY KEY, value TEXT NOT NULL)");
        console.info(`Connected to the ${filename} SQLite database.`);
        this.readStatement = this.db.prepare("SELECT value FROM Data WHERE key = ?");
        this.writeStatement = this.db.prepare("REPLACE INTO Data(key, value) VALUES(?, ?)");
        this.deleteStatement = this.db.prepare("DELETE FROM Data WHERE key = ?");
      }
      // Useful in test hooks.
      // deno-lint-ignore require-await
      async clear() {
        this.run("DELETE FROM Data");
      }
      // deno-lint-ignore require-await
      async readData(key) {
        const row = this.readStatement.get(key);
        return row?.value;
      }
      async writeData(key, value) {
        await this.writeStatement.run(key, value);
      }
      async deleteData(key) {
        await this.deleteStatement.run(key);
      }
      close() {
        this.db.close();
      }
    };
  }
});
var globImport_database_ts;
var init_ = __esm({
  'import("./database-*.ts") in src/serve/database-router.ts'() {
    globImport_database_ts = __glob({
      "./database-fs.ts": () => Promise.resolve().then(() => (init_database_fs2(), database_fs_exports2)),
      "./database-router.test.ts": () => Promise.resolve().then(() => (init_database_router_test(), database_router_test_exports)),
      "./database-router.ts": () => Promise.resolve().then(() => (init_database_router(), database_router_exports)),
      "./database-sqlite.ts": () => Promise.resolve().then(() => (init_database_sqlite2(), database_sqlite_exports2))
    });
  }
});
var database_router_exports = {};
__export(database_router_exports, {
  default: () => RouterBackend
});
var GI_PERSIST_ROUTER_CONFIG;
var GI_PERSIST_ROUTER_CONFIG_PATH;
var RouterBackend;
var init_database_router = __esm({
  "src/serve/database-router.ts"() {
    "use strict";
    init_DatabaseBackend();
    init_();
    ({
      GI_PERSIST_ROUTER_CONFIG: (
        // Tried first by the config lookup.
        // Define this if your config JSON comes as a string from an envar's contents.
        GI_PERSIST_ROUTER_CONFIG
      ),
      GI_PERSIST_ROUTER_CONFIG_PATH: (
        // Tried next.
        // Define this if your config comes from a JSON file.
        GI_PERSIST_ROUTER_CONFIG_PATH
      ) = "./database-router-config.json"
    } = process6.env);
    RouterBackend = class extends DatabaseBackend {
      backends;
      config;
      constructor(options3 = {}) {
        super();
        if (options3.config) this.config = options3.config;
      }
      lookupBackend(key) {
        const { backends: backends2, config: config2 } = this;
        const keyPrefixes = Object.keys(config2);
        for (let i2 = 0; i2 < keyPrefixes.length; i2++) {
          if (key.startsWith(keyPrefixes[i2])) {
            return backends2[keyPrefixes[i2]];
          }
        }
        return backends2["*"];
      }
      async readConfig() {
        if (GI_PERSIST_ROUTER_CONFIG) {
          console.info("[database-router] Reading config from envar GI_PERSIST_ROUTER_CONFIG");
        } else {
          console.info("[database-router] Reading config from path", GI_PERSIST_ROUTER_CONFIG_PATH);
        }
        const configString = GI_PERSIST_ROUTER_CONFIG || await readFile2(resolve7(GI_PERSIST_ROUTER_CONFIG_PATH), "utf8");
        const config2 = JSON.parse(configString);
        return Object.fromEntries(Object.entries(config2).sort((a, b) => b[0].length - a[0].length));
      }
      validateConfig(config2) {
        const errors = [];
        if (!config2["*"]) {
          errors.push({ msg: 'Missing key: "*" (fallback storage is required)' });
        }
        for (const entry of Object.entries(config2)) {
          const value = entry[1];
          if (typeof value?.name !== "string" || typeof value?.options !== "object") {
            errors.push({ msg: "entry value must be of type { name: string, options: Object }", entry });
            continue;
          }
          if (value.name === "router") {
            errors.push({ msg: "Router backends cannot be nested.", entry });
            continue;
          }
        }
        return errors;
      }
      async init() {
        if (!this.config) this.config = await this.readConfig();
        const errors = this.validateConfig(this.config);
        if (errors.length) {
          throw new Error(`[${this.constructor.name}] ${errors.length} error(s) found in your config.`, { cause: errors });
        }
        this.backends = /* @__PURE__ */ Object.create(null);
        const entries = Object.entries(this.config);
        await Promise.all(entries.map(async (entry) => {
          const [keyPrefix, { name, options: options3 }] = entry;
          const Ctor = (await globImport_database_ts(`./database-${name}.ts`)).default;
          const backend2 = new Ctor(options3);
          await backend2.init();
          this.backends[keyPrefix] = backend2;
        }));
      }
      async readData(key) {
        return await this.lookupBackend(key).readData(key);
      }
      async writeData(key, value) {
        return await this.lookupBackend(key).writeData(key, value);
      }
      async deleteData(key) {
        return await this.lookupBackend(key).deleteData(key);
      }
      async clear() {
        for (const backend2 of new Set(Object.values(this.backends))) {
          try {
            await backend2.clear();
          } catch (e2) {
            const prefix = Object.entries(this.backends).find(([, b]) => b === backend2)[0];
            console.error(e2, `Error clearing DB for prefix ${prefix}`);
          }
        }
      }
      async close() {
        for (const backend2 of new Set(Object.values(this.backends))) {
          try {
            await backend2.close();
          } catch (e2) {
            const prefix = Object.entries(this.backends).find(([, b]) => b === backend2)[0];
            console.error(e2, `Error closing DB for prefix ${prefix}`);
          }
        }
      }
    };
  }
});
var database_router_test_exports = {};
var CID4;
var randomKeyWithPrefix;
var validConfig;
var db2;
var init_database_router_test = __esm({
  "src/serve/database-router.test.ts"() {
    "use strict";
    init_esm9();
    init_database_router();
    CID4 = "Q";
    randomKeyWithPrefix = (prefix) => `${prefix}${globalThis.crypto.randomUUID().replaceAll("-", "")}`;
    validConfig = {
      [CID4]: {
        name: "sqlite",
        options: {
          filepath: "./test/temp/sqlite.db"
        }
      },
      "*": {
        name: "fs",
        options: {
          dirname: "./test/temp"
        }
      }
    };
    db2 = new RouterBackend({ config: validConfig });
    Deno.test({
      name: "DatabaseRouter::validateConfig",
      async fn(t) {
        await t.step("should accept a valid config", () => {
          const errors = db2.validateConfig(validConfig);
          if (errors.length !== 0) throw new Error(`Expected 0 errors but got ${errors.length}`);
        });
        await t.step("should reject configs missing a * key", () => {
          const config2 = omit2(validConfig, ["*"]);
          const errors = db2.validateConfig(config2);
          if (errors.length !== 1) throw new Error(`Expected 1 error but got ${errors.length}`);
        });
        await t.step("should reject config entries missing a name", () => {
          const config2 = cloneDeep(validConfig);
          delete config2["*"].name;
          const errors = db2.validateConfig(config2);
          if (errors.length !== 1) throw new Error(`Expected 1 error but got ${errors.length}`);
        });
      }
    });
    Deno.test({
      name: "DatabaseRouter::lookupBackend",
      async fn(t) {
        await db2.init();
        try {
          await t.step("should find the right backend for keys starting with configured prefixes", () => {
            for (const keyPrefix of Object.keys(db2.config)) {
              if (keyPrefix === "*") continue;
              const key = randomKeyWithPrefix(keyPrefix);
              const actual = db2.lookupBackend(key);
              const expected = db2.backends[keyPrefix];
              if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
            }
          });
          await t.step("should find the right backend for keys equal to configured prefixes", () => {
            for (const keyPrefix of Object.keys(db2.config)) {
              const key = keyPrefix;
              const actual = db2.lookupBackend(key);
              const expected = db2.backends[keyPrefix];
              if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
            }
          });
          await t.step("should return the fallback backend for keys not matching any configured prefix", () => {
            const key = "foo";
            const actual = db2.lookupBackend(key);
            const expected = db2.backends["*"];
            if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
          });
        } finally {
          await db2.clear();
        }
      }
    });
  }
});
var globImport_database_ts2;
var init_2 = __esm({
  'import("./database-*.ts") in src/serve/database.ts'() {
    globImport_database_ts2 = __glob({
      "./database-fs.ts": () => Promise.resolve().then(() => (init_database_fs2(), database_fs_exports2)),
      "./database-router.test.ts": () => Promise.resolve().then(() => (init_database_router_test(), database_router_test_exports)),
      "./database-router.ts": () => Promise.resolve().then(() => (init_database_router(), database_router_exports)),
      "./database-sqlite.ts": () => Promise.resolve().then(() => (init_database_sqlite2(), database_sqlite_exports2))
    });
  }
});
function namespaceKey(name) {
  return "name=" + name;
}
var import_boom2;
var import_npm_lru_cache;
var production;
var persistence;
var dbRootPath;
var options2;
var KEYOP_SEGMENT_LENGTH;
var dataFolder3;
var updateSize;
var database_default;
var initDB;
var appendToIndexFactory;
var appendToNamesIndex;
var removeFromIndexFactory;
var lookupUltimateOwner;
var init_database = __esm({
  "src/serve/database.ts"() {
    "use strict";
    init_chelonia();
    init_db();
    init_db();
    init_functions();
    import_boom2 = __toESM(require_lib6());
    init_esm3();
    import_npm_lru_cache = __toESM(require_lru_cache2());
    init_events();
    init_vapid();
    init_zkppSalt();
    init_2();
    production = process7.env.NODE_ENV === "production";
    persistence = process7.env.GI_PERSIST || (production ? "fs" : void 0);
    dbRootPath = process7.env.DB_PATH || "./data";
    options2 = {
      fs: {
        depth: 0,
        dirname: dbRootPath,
        keyChunkLength: 2
      },
      sqlite: {
        filepath: path9.join(dbRootPath, "groupincome.db")
      }
    };
    KEYOP_SEGMENT_LENGTH = 1e4;
    dataFolder3 = path9.resolve(options2.fs.dirname);
    if (!fs.existsSync(dataFolder3)) {
      fs.mkdirSync(dataFolder3, { mode: 488 });
    }
    updateSize = async (resourceID, sizeKey, size, skipIfDeleted) => {
      if (!Number.isSafeInteger(size)) {
        throw new TypeError(`Invalid given size ${size} for ${resourceID}`);
      }
      await esm_default("okTurtles.eventQueue/queueEvent", sizeKey, async () => {
        const storedSize = await esm_default("chelonia.db/get", sizeKey, { bypassCache: true });
        if (skipIfDeleted && storedSize == null) return;
        const existingSize = parseInt(storedSize ?? "0", 10);
        if (!(existingSize >= 0)) {
          throw new TypeError(`Invalid stored size ${existingSize} for ${resourceID}`);
        }
        const updatedSize = existingSize + size;
        if (!(updatedSize >= 0)) {
          throw new TypeError(`Invalid stored updated size ${updatedSize} for ${resourceID}`);
        }
        await esm_default("chelonia.db/set", sizeKey, updatedSize.toString(10));
      });
    };
    database_default = esm_default("sbp/selectors/register", {
      "backend/db/streamEntriesAfter": async function(contractID, height, requestedLimit, options3 = {}) {
        const limit = Math.min(requestedLimit ?? Number.POSITIVE_INFINITY, process7.env.MAX_EVENTS_BATCH_SIZE ? parseInt(process7.env.MAX_EVENTS_BATCH_SIZE) : 500);
        const latestHEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
        if (latestHEADinfo === "") {
          throw import_boom2.default.resourceGone(`contractID ${contractID} has been deleted!`);
        }
        if (!latestHEADinfo) {
          throw import_boom2.default.notFound(`contractID ${contractID} doesn't exist!`);
        }
        let counter = 0;
        let currentHeight = height;
        let currentHash, serverMeta;
        let prefix = "";
        const nextKeyOp = /* @__PURE__ */ (() => {
          let index;
          return async () => {
            if (!index) {
              index = (await esm_default("chelonia.db/get", `_private_keyop_idx_${contractID}_${currentHeight - currentHeight % KEYOP_SEGMENT_LENGTH}`))?.split("\0");
            }
            const value = index?.find((h2, i2) => {
              if (Number(h2) >= currentHeight) {
                index = index.slice(i2 + 1);
                return true;
              } else {
                return false;
              }
            });
            if (value != null) {
              const newHeight = Number(value);
              currentHeight = newHeight;
            } else {
              currentHeight = currentHeight - currentHeight % KEYOP_SEGMENT_LENGTH + KEYOP_SEGMENT_LENGTH;
              index = void 0;
              if (currentHeight > latestHEADinfo.height) {
                return false;
              } else {
                return null;
              }
            }
            return true;
          };
        })();
        const fetchMeta = async () => {
          if (currentHeight > latestHEADinfo.height) {
            return false;
          }
          const meta = await esm_default("chelonia/db/getEntryMeta", contractID, currentHeight);
          if (!meta) {
            return false;
          }
          const { hash: newCurrentHash, ...newServerMeta } = meta;
          currentHash = newCurrentHash;
          serverMeta = newServerMeta;
          return true;
        };
        const stream = Readable.from(async function* () {
          yield "[";
          await fetchMeta();
          while (serverMeta && counter < limit) {
            try {
              const entry = await esm_default("chelonia/db/getEntry", currentHash);
              if (!entry) break;
              const currentPrefix = prefix;
              prefix = ",";
              counter++;
              yield `${currentPrefix}"${strToB64(
                JSON.stringify({ serverMeta, message: entry.serialize() })
              )}"`;
              currentHeight++;
              currentHash = void 0;
              serverMeta = void 0;
              if (options3.keyOps) {
                while (await nextKeyOp() === null) ;
              }
              await fetchMeta();
            } catch (e2) {
              console.error(e2, "[backend] streamEntriesAfter: read()");
              break;
            }
          }
          yield "]";
        }(), { encoding: "utf-8", objectMode: false });
        stream.headers = {
          "shelter-headinfo-head": latestHEADinfo.HEAD,
          "shelter-headinfo-height": latestHEADinfo.height
        };
        return stream;
      },
      // =======================
      // wrapper methods to add / lookup names
      // =======================
      "backend/db/registerName": async function(name, value) {
        const exists = await esm_default("backend/db/lookupName", name);
        if (exists) {
          throw import_boom2.default.conflict("exists");
        }
        await esm_default("chelonia.db/set", namespaceKey(name), value);
        await esm_default("chelonia.db/set", `_private_cid2name_${value}`, name);
        await appendToNamesIndex(name);
        return { name, value };
      },
      "backend/db/lookupName": async function(name) {
        const value = await esm_default("chelonia.db/get", namespaceKey(name));
        return value;
      }
    });
    initDB = async ({ skipDbPreloading } = {}) => {
      if (persistence) {
        const Ctor = (await globImport_database_ts2(`./database-${persistence}.ts`)).default;
        const { init: init2, readData: readData3, writeData: writeData3, deleteData, close } = new Ctor(options2[persistence]);
        await init2();
        esm_default("okTurtles.events/once", SERVER_EXITING, () => {
          esm_default("okTurtles.eventQueue/queueEvent", SERVER_EXITING, async () => {
            try {
              await close();
            } catch (e2) {
              console.error(e2, `Error closing DB ${persistence}`);
            }
          });
        });
        const cache3 = new import_npm_lru_cache.default({
          max: Number(process7.env.GI_LRU_NUM_ITEMS) || 1e4
        });
        const prefixes = Object.keys(prefixHandlers);
        esm_default("sbp/selectors/overwrite", {
          "chelonia.db/get": async function(prefixableKey, { bypassCache } = {}) {
            if (!bypassCache) {
              const lookupValue = cache3.get(prefixableKey);
              if (lookupValue !== void 0) {
                return lookupValue;
              }
            }
            const [prefix, key] = parsePrefixableKey(prefixableKey);
            let value = await readData3(key);
            if (value === void 0) {
              return;
            }
            value = prefixHandlers[prefix](value);
            cache3.set(prefixableKey, value);
            return value;
          },
          "chelonia.db/set": async function(key, value) {
            if (process7.env.CHELONIA_ARCHIVE_MODE) throw new Error("Unable to write in archive mode");
            checkKey2(key);
            if (key.startsWith("_private_immutable")) {
              const existingValue = await readData3(key);
              if (existingValue !== void 0) {
                throw new Error("Cannot set already set immutable key");
              }
            }
            await writeData3(key, value);
            prefixes.forEach((prefix) => {
              cache3.delete(prefix + key);
            });
          },
          "chelonia.db/delete": async function(key) {
            if (process7.env.CHELONIA_ARCHIVE_MODE) throw new Error("Unable to write in archive mode");
            checkKey2(key);
            if (key.startsWith("_private_immutable")) {
              throw new Error("Cannot delete immutable key");
            }
            await deleteData(key);
            prefixes.forEach((prefix) => {
              cache3.delete(prefix + key);
            });
          }
        });
        esm_default("sbp/selectors/lock", ["chelonia.db/get", "chelonia.db/set", "chelonia.db/delete"]);
      }
      if (skipDbPreloading) return;
      if (persistence !== "fs" || options2.fs.dirname !== dbRootPath) {
        const HASH_LENGTH = 56;
        const keys = (await readdir2(dataFolder3)).filter((k) => {
          if (k.length !== HASH_LENGTH) return false;
          const parsed = maybeParseCID(k);
          return parsed && [
            multicodes2.SHELTER_CONTRACT_MANIFEST,
            multicodes2.SHELTER_CONTRACT_TEXT
          ].includes(parsed.code);
        });
        const numKeys2 = keys.length;
        let numVisitedKeys = 0;
        let numNewKeys = 0;
        const savedProgress = { value: 0, numKeys: 0 };
        console.info("[chelonia.db] Preloading...");
        for (const key of keys) {
          if (!persistence || !await esm_default("chelonia.db/get", key)) {
            const value = await readFile3(path9.join(dataFolder3, key), "utf8");
            await esm_default("chelonia.db/set", key, value);
            numNewKeys++;
          }
          numVisitedKeys++;
          const progress = numVisitedKeys === numKeys2 ? 100 : Math.floor(100 * numVisitedKeys / numKeys2);
          if (progress === 100 || progress - savedProgress.value >= 10 && numVisitedKeys - savedProgress.numKeys >= 10) {
            console.info(`[chelonia.db] Preloading... ${progress}% done`);
            savedProgress.numKeys = numVisitedKeys;
            savedProgress.value = progress;
          }
        }
        numNewKeys && console.info(`[chelonia.db] Preloaded ${numNewKeys} new entries`);
      }
      await Promise.all([initVapid(), initZkpp()]);
    };
    appendToIndexFactory = (key) => {
      return (value) => {
        return esm_default("okTurtles.eventQueue/queueEvent", key, async () => {
          const currentIndex = await esm_default("chelonia.db/get", key, { bypassCache: true });
          if (currentIndex) {
            if (
              // Check if the value is at the end
              currentIndex.endsWith("\0" + value) || // Check if the value is at the start
              currentIndex.startsWith(value + "\0") || // Check if the current index is exactly the value
              currentIndex === value
            ) {
              return;
            }
            await esm_default("chelonia.db/set", key, `${currentIndex}\0${value}`);
            return;
          }
          await esm_default("chelonia.db/set", key, value);
        });
      };
    };
    appendToNamesIndex = appendToIndexFactory("_private_names_index");
    removeFromIndexFactory = (key) => {
      return (values) => {
        return esm_default("okTurtles.eventQueue/queueEvent", key, async () => {
          let existingEntries = await esm_default("chelonia.db/get", key, { bypassCache: true });
          if (!existingEntries) return;
          if (!Array.isArray(values)) {
            values = [values];
          }
          for (const value of values) {
            if (existingEntries.endsWith("\0" + value)) {
              existingEntries = existingEntries.slice(0, -value.length - 1);
              continue;
            }
            if (existingEntries.startsWith(value + "\0")) {
              existingEntries = existingEntries.slice(value.length + 1);
              continue;
            }
            if (existingEntries === value) {
              existingEntries = void 0;
              break;
            }
            const entryIndex = existingEntries.indexOf("\0" + value + "\0");
            if (entryIndex === -1) continue;
            existingEntries = existingEntries.slice(0, entryIndex) + existingEntries.slice(entryIndex + value.length + 1);
          }
          if (existingEntries) {
            await esm_default("chelonia.db/set", key, existingEntries);
          } else {
            await esm_default("chelonia.db/delete", key);
          }
        });
      };
    };
    lookupUltimateOwner = async (resourceID) => {
      let ownerID = resourceID;
      for (let depth = 128; depth >= 0; depth--) {
        const newOwnerID = await esm_default("chelonia.db/get", `_private_owner_${ownerID}`, { bypassCache: true });
        if (!newOwnerID) break;
        if (!depth) {
          throw new Error("Exceeded max depth looking up owner for " + resourceID);
        }
        ownerID = newOwnerID;
      }
      return ownerID;
    };
  }
});
var BackendErrorNotFound;
var BackendErrorGone;
var BackendErrorBadData;
var init_errors2 = __esm({
  "src/serve/errors.ts"() {
    "use strict";
    init_errors();
    BackendErrorNotFound = ChelErrorGenerator("BackendErrorNotFound");
    BackendErrorGone = ChelErrorGenerator("BackendErrorGone");
    BackendErrorBadData = ChelErrorGenerator("BackendErrorBadData");
  }
});
var x2;
var init_encodings2 = __esm({
  "node_modules/.deno/@apeleghq+rfc8188@1.0.7/node_modules/@apeleghq/rfc8188/dist/encodings.mjs"() {
    x2 = { params: { name: "AES-GCM", length: 128 }, get cek_info() {
      return new Uint8Array([67, 111, 110, 116, 101, 110, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103, 58, 32, 97, 101, 115, 49, 50, 56, 103, 99, 109, 0]);
    }, get nonce_info() {
      return new Uint8Array([67, 111, 110, 116, 101, 110, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103, 58, 32, 110, 111, 110, 99, 101, 0]);
    }, block_size: 16, tag_length: 16, nonce_length: 12 };
  }
});
var R3;
var E2;
var B3;
var w3;
var N10;
var U2;
var K2;
var init_encrypt2 = __esm({
  "node_modules/.deno/@apeleghq+rfc8188@1.0.7/node_modules/@apeleghq/rfc8188/dist/encrypt.mjs"() {
    R3 = async (e2, b, f, i2) => {
      let A2 = await globalThis.crypto.subtle.importKey("raw", b, "HKDF", false, ["deriveKey", "deriveBits"]), y = await globalThis.crypto.subtle.deriveKey({ name: "HKDF", hash: "SHA-256", info: e2.cek_info, salt: f }, A2, e2.params, false, i2), u2 = await globalThis.crypto.subtle.deriveBits({ name: "HKDF", hash: "SHA-256", info: e2.nonce_info, salt: f }, A2, e2.nonce_length << 3);
      return [y, function* () {
        let L = new ArrayBuffer(e2.nonce_length), c = new DataView(L), h2 = new Uint8Array(L), a = new Uint8Array(u2), g2 = 4294967295, o2 = (e2.nonce_length >> 2) - 1, s = new Array(o2).fill(0);
        for (; ; ) {
          for (let t = 0; t <= g2; t++) {
            c.setUint32(c.byteLength - 4, t, false);
            let n = new Uint8Array(e2.nonce_length);
            for (let r = 0; r < n.length; r++) n[r] = a[r] ^ h2[r];
            yield n;
          }
          for (let t = 0; t < o2; t++) {
            if (t === o2 - 1 && s[t] === g2) throw new RangeError("Maximum number of segments exceeded");
            if (s[t] = (s[t] + 1) % (g2 + 1), c.setUint32(c.byteLength - 4 * (t + 2), s[t], false), s[t] !== 0) break;
          }
        }
      }()];
    };
    E2 = R3;
    B3 = (e2) => ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer).subarray(e2.byteOffset, e2.byteOffset + e2.byteLength) : new Uint8Array(e2);
    w3 = B3;
    N10 = () => {
      let e2 = new Uint8Array(16);
      return globalThis.crypto.getRandomValues(e2), e2;
    };
    U2 = async (e2, b, f, i2, A2, y) => {
      if (f <= e2.tag_length + 1 || f > 4294967295) throw new RangeError("Invalid record size: " + f);
      if (i2.byteLength > 255) throw new RangeError("Key ID too long");
      if (y && y.byteLength !== 16) throw new RangeError("Invald salt length: " + y.byteLength);
      let u2 = f - e2.tag_length - 1, l = y ? w3(y) : N10(), [L, c] = await E2(e2, A2, l, ["encrypt"]);
      A2 = void 0;
      let h2 = new Uint8Array(u2), a = 0, g2 = new TransformStream({ start: (o2) => {
        let s = l.byteLength + 4 + 1 + i2.byteLength, t = new ArrayBuffer(s);
        new Uint8Array(t, 0, l.byteLength).set(l);
        let r = new DataView(t, l.byteLength, 5);
        r.setUint32(0, f, false), r.setUint8(4, i2.byteLength);
        let d = new Uint8Array(t, l.byteLength + 4 + 1, i2.byteLength), m3 = w3(i2);
        d.set(m3), o2.enqueue(t);
      }, transform: async (o2, s) => {
        let t = w3(o2), n = 0;
        for (; n < o2.byteLength; ) {
          let r = t.subarray(n, n + u2 - a);
          if (h2.set(r, a), a += r.byteLength, n += r.byteLength, a === u2) {
            let m3 = c.next().value, p = new Uint8Array(u2 + 1);
            p.set(h2.subarray(0, a)), p[a] = 1;
            let T2 = await globalThis.crypto.subtle.encrypt({ name: e2.params.name, iv: m3, tagLength: e2.tag_length << 3 }, L, p);
            s.enqueue(T2), a = 0;
          }
        }
      }, flush: async (o2) => {
        let t = c.next().value, n = new Uint8Array(a + 1);
        n.set(h2.subarray(0, a)), n[a] = 2;
        let r = await globalThis.crypto.subtle.encrypt({ name: e2.params.name, iv: t, tagLength: e2.tag_length << 3 }, L, n);
        o2.enqueue(r), h2.fill(0), n.fill(0);
      } });
      return b.pipeThrough(g2), g2.readable;
    };
    K2 = U2;
  }
});
var rfc8291Ikm_default;
var init_rfc8291Ikm = __esm({
  "src/serve/rfc8291Ikm.ts"() {
    "use strict";
    rfc8291Ikm_default = async (uaPublic, salt) => {
      const [[asPrivateKey, asPublic], uaPublicKey] = await Promise.all([
        crypto.subtle.generateKey(
          {
            name: "ECDH",
            namedCurve: "P-256"
          },
          false,
          ["deriveKey"]
        ).then(async (asKeyPair) => {
          const asPublic2 = await crypto.subtle.exportKey(
            "raw",
            asKeyPair.publicKey
          );
          return [asKeyPair.privateKey, asPublic2];
        }),
        crypto.subtle.importKey(
          "raw",
          uaPublic,
          { name: "ECDH", namedCurve: "P-256" },
          false,
          []
        )
      ]);
      const ecdhSecret = await crypto.subtle.deriveKey(
        {
          name: "ECDH",
          public: uaPublicKey
        },
        asPrivateKey,
        {
          name: "HKDF",
          hash: "SHA-256"
        },
        false,
        ["deriveBits"]
      );
      const infoString = new Uint8Array([
        87,
        101,
        98,
        80,
        117,
        115,
        104,
        58,
        32,
        105,
        110,
        102,
        111,
        0
      ]);
      const info = new Uint8Array(infoString.byteLength + uaPublic.byteLength + asPublic.byteLength);
      info.set(infoString, 0);
      info.set(uaPublic, infoString.byteLength);
      info.set(
        new Uint8Array(asPublic),
        infoString.byteLength + uaPublic.byteLength
      );
      const IKM = await crypto.subtle.deriveBits(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt,
          info
        },
        ecdhSecret,
        32 << 3
      );
      return [asPublic, IKM];
    };
  }
});
var addSubscriptionToIndex;
var deleteSubscriptionFromIndex;
var saveSubscription;
var addChannelToSubscription;
var deleteChannelFromSubscription;
var removeSubscription;
var subscriptionInfoWrapper;
var encryptPayload;
var postEvent;
var pushServerActionhandlers;
var init_push = __esm({
  "src/serve/push.ts"() {
    "use strict";
    init_encodings2();
    init_encrypt2();
    init_functions();
    init_pubsub();
    init_esm3();
    init_database();
    init_instance_keys();
    init_rfc8291Ikm();
    init_vapid();
    addSubscriptionToIndex = appendToIndexFactory("_private_webpush_index");
    deleteSubscriptionFromIndex = removeFromIndexFactory("_private_webpush_index");
    saveSubscription = (server, subscriptionId) => {
      return esm_default("chelonia.db/set", `_private_webpush_${subscriptionId}`, JSON.stringify({
        settings: server.pushSubscriptions[subscriptionId].settings,
        subscriptionInfo: server.pushSubscriptions[subscriptionId],
        channelIDs: [...server.pushSubscriptions[subscriptionId].subscriptions]
      })).catch((e2) => {
        console.error(e2, "Error saving subscription", subscriptionId);
        throw e2;
      });
    };
    addChannelToSubscription = (server, subscriptionId, channelID) => {
      server.pushSubscriptions[subscriptionId].subscriptions.add(channelID);
      return saveSubscription(server, subscriptionId);
    };
    deleteChannelFromSubscription = (server, subscriptionId, channelID) => {
      server.pushSubscriptions[subscriptionId].subscriptions.delete(channelID);
      return saveSubscription(server, subscriptionId);
    };
    removeSubscription = async (subscriptionId) => {
      try {
        const server = esm_default("okTurtles.data/get", PUBSUB_INSTANCE);
        const subscription = server.pushSubscriptions[subscriptionId];
        if (subscription) {
          delete server.pushSubscriptions[subscriptionId];
          if (server.subscribersByChannelID) {
            subscription.subscriptions.forEach((channelID) => {
              server.subscribersByChannelID[channelID]?.delete(subscription);
            });
          }
        } else {
        }
        await esm_default("chelonia.db/delete", `_private_webpush_${subscriptionId}`);
        await deleteSubscriptionFromIndex(subscriptionId);
      } catch (e2) {
        console.error(e2, "Error removing subscription", subscriptionId);
      }
    };
    subscriptionInfoWrapper = (subscriptionId, subscriptionInfo, extra) => {
      subscriptionInfo.endpoint = new URL(subscriptionInfo.endpoint);
      Object.defineProperties(subscriptionInfo, {
        "id": {
          get() {
            return subscriptionId;
          }
        },
        // These encryption keys are used for encrypting push notification bodies
        // and are unrelated to VAPID, which is used for provenance.
        "encryptionKeys": {
          get: /* @__PURE__ */ (() => {
            let count3 = 0;
            let resultPromise;
            let salt;
            let uaPublic;
            return function() {
              if ((count3 | 0) === 0) {
                if (!salt) {
                  salt = Buffer10.from(this.keys.auth, "base64url");
                }
                if (!uaPublic) {
                  uaPublic = Buffer10.from(this.keys.p256dh, "base64url");
                }
                resultPromise = rfc8291Ikm_default(uaPublic, salt);
                count3 = 1;
              } else {
                count3++;
              }
              return resultPromise;
            };
          })()
        },
        "settings": {
          value: extra.settings || {}
        },
        "sockets": {
          value: /* @__PURE__ */ new Set()
        },
        "subscriptions": {
          value: new Set(extra.channelIDs)
        }
      });
      Object.freeze(subscriptionInfo);
      return subscriptionInfo;
    };
    encryptPayload = async (subscription, data) => {
      const readableStream = new Response(data).body;
      if (!readableStream) throw new Error("Failed to create readable stream");
      const [asPublic, IKM] = await subscription.encryptionKeys;
      return K2(x2, readableStream, 32768, asPublic.buffer, IKM.buffer).then(async (bodyStream) => {
        const chunks = [];
        const reader = bodyStream.getReader();
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(new Uint8Array(value));
        }
        return Buffer10.concat(chunks);
      });
    };
    postEvent = async (subscription, event) => {
      const authorization = await vapidAuthorization(subscription.endpoint);
      const body = event ? await encryptPayload(subscription, event) : void 0;
      const req = await fetch(subscription.endpoint, {
        method: "POST",
        headers: [
          ["authorization", authorization],
          ...body ? [
            ["content-encoding", "aes128gcm"],
            [
              "content-type",
              "application/octet-stream"
            ]
          ] : [],
          // ['push-receipt', ''],
          ["ttl", "60"]
        ],
        body
      });
      if (!req.ok) {
        const endpointHost = new URL(subscription.endpoint).host;
        console.info(
          await req.text().then((response) => ({ response })).catch((e2) => `ERR: ${e2?.message}`),
          `Error ${req.status} sending push notification to '${subscription.id}' via ${endpointHost}`
        );
        if ([401, 404, 410].includes(req.status)) {
          removeSubscription(subscription.id);
          throw new Error(`Error sending push: ${req.status}`);
        }
        if (req.status === 413) {
          throw new Error("Payload too large");
        }
      }
    };
    pushServerActionhandlers = {
      [PUSH_SERVER_ACTION_TYPE.SEND_PUBLIC_KEY]() {
        const socket = this;
        socket.send(createMessage(REQUEST_TYPE.PUSH_ACTION, { type: PUSH_SERVER_ACTION_TYPE.SEND_PUBLIC_KEY, data: getVapidPublicKey() }));
      },
      async [PUSH_SERVER_ACTION_TYPE.STORE_SUBSCRIPTION](payload) {
        const socket = this;
        const { server } = socket;
        const { applicationServerKey, settings, subscriptionInfo } = payload;
        if (applicationServerKey) {
          const ourVapidPublicKey = getVapidPublicKey();
          const theirVapidPublicKey = Buffer10.from(applicationServerKey, "base64").toString("base64url");
          if (ourVapidPublicKey !== theirVapidPublicKey) {
            socket.send(createMessage(REQUEST_TYPE.PUSH_ACTION, { type: PUSH_SERVER_ACTION_TYPE.SEND_PUBLIC_KEY, data: getVapidPublicKey() }));
            console.warn({ ourVapidPublicKey, theirVapidPublicKey }, "Refusing to store subscription because the associated public VAPID key does not match ours");
            return;
          }
        }
        let subscriptionId = null;
        let host = "";
        let subscriptionWrapper = null;
        try {
          subscriptionId = await getSubscriptionId(subscriptionInfo);
          subscriptionWrapper = server.pushSubscriptions[subscriptionId];
          if (!subscriptionWrapper) {
            console.debug(`saving new push subscription '${subscriptionId}':`, subscriptionInfo);
            server.pushSubscriptions[subscriptionId] = subscriptionInfoWrapper(subscriptionId, subscriptionInfo, { settings });
            subscriptionWrapper = server.pushSubscriptions[subscriptionId];
            host = subscriptionWrapper.endpoint.host;
            await addSubscriptionToIndex(subscriptionId);
            await saveSubscription(server, subscriptionId);
            await postEvent(subscriptionWrapper, JSON.stringify({ type: "initial" }));
          } else {
            host = subscriptionWrapper.endpoint.host;
            if (subscriptionWrapper.sockets.size === 0) {
              subscriptionWrapper.subscriptions.forEach((channelID) => {
                if (!server.subscribersByChannelID[channelID]) return;
                server.subscribersByChannelID[channelID].delete(subscriptionWrapper);
              });
            }
          }
          if (socket.pushSubscriptionId) {
            if (socket.pushSubscriptionId === subscriptionId) return;
            await removeSubscription(socket.pushSubscriptionId);
          }
          socket.pushSubscriptionId = subscriptionId;
          subscriptionWrapper.subscriptions.forEach((channelID) => {
            server.subscribersByChannelID[channelID]?.delete(subscriptionWrapper);
          });
          subscriptionWrapper.sockets.add(socket);
          socket.subscriptions?.forEach((channelID) => {
            subscriptionWrapper.subscriptions.add(channelID);
          });
          await saveSubscription(server, subscriptionId);
        } catch (e2) {
          console.error(e2, `[${socket.ip}] Failed to store subscription '${subscriptionId || "??"}' (${host}), removing it!`);
          subscriptionId && removeSubscription(subscriptionId);
          throw e2;
        }
      },
      [PUSH_SERVER_ACTION_TYPE.DELETE_SUBSCRIPTION]() {
        const socket = this;
        const { pushSubscriptionId: subscriptionId } = socket;
        if (subscriptionId) {
          return removeSubscription(subscriptionId);
        }
      }
    };
  }
});
var require_stream = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = __require2("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options3) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options3,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary2) {
        const data = !isBinary2 && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});
var require_constants2 = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});
var require_buffer_util = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    function concat2(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i2 = 0; i2 < list.length; i2++) {
        const buf2 = list[i2];
        target.set(buf2, offset);
        offset += buf2.length;
      }
      if (offset < totalLength) return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length4) {
      for (let i2 = 0; i2 < length4; i2++) {
        output[offset + i2] = source[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i2 = 0; i2 < buffer.length; i2++) {
        buffer[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer(buf2) {
      if (buf2.byteLength === buf2.buffer.byteLength) {
        return buf2.buffer;
      }
      return buf2.buffer.slice(buf2.byteOffset, buf2.byteOffset + buf2.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf2;
      if (data instanceof ArrayBuffer) {
        buf2 = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf2 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf2 = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf2;
    }
    try {
      const bufferUtil = __require2("bufferutil");
      module2.exports = {
        concat: concat2,
        mask(source, mask, output, offset, length4) {
          if (length4 < 48) _mask(source, mask, output, offset, length4);
          else bufferUtil.mask(source, mask, output, offset, length4);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        }
      };
    } catch (e2) {
      module2.exports = {
        concat: concat2,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});
var require_limiter = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});
var require_permessage_deflate = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = __require2("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options3, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options3 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});
var require_validation2 = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code2) {
      return code2 >= 1e3 && code2 <= 1014 && code2 !== 1004 && code2 !== 1005 && code2 !== 1006 || code2 >= 3e3 && code2 <= 4999;
    }
    function _isValidUTF8(buf2) {
      const len = buf2.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf2[i2] & 128) === 0) {
          i2++;
        } else if ((buf2[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf2[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2 + 2] & 192) !== 128 || buf2[i2] === 224 && (buf2[i2 + 1] & 224) === 128 || // Overlong
          buf2[i2] === 237 && (buf2[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf2[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2 + 2] & 192) !== 128 || (buf2[i2 + 3] & 192) !== 128 || buf2[i2] === 240 && (buf2[i2 + 1] & 240) === 128 || // Overlong
          buf2[i2] === 244 && buf2[i2 + 1] > 143 || buf2[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      const isValidUTF8 = __require2("utf-8-validate");
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf2) {
          return buf2.length < 150 ? _isValidUTF8(buf2) : isValidUTF8(buf2);
        },
        tokenChars
      };
    } catch (e2) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8,
        tokenChars
      };
    }
  }
});
var require_receiver = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = __require2("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat: concat2, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation2();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options3 = {}) {
        super();
        this._binaryType = options3.binaryType || BINARY_TYPES[0];
        this._extensions = options3.extensions || {};
        this._isServer = !!options3.isServer;
        this._maxPayload = options3.maxPayload | 0;
        this._skipUTF8Validation = !!options3.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf2 = this._buffers[0];
          this._buffers[0] = buf2.slice(n);
          return buf2.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf2 = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf2.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf2.buffer, buf2.byteOffset, n), offset);
            this._buffers[0] = buf2.slice(n);
          }
          n -= buf2.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf2 = this.consume(2);
        if ((buf2[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf2[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf2[0] & 128) === 128;
        this._opcode = buf2[0] & 15;
        this._payloadLength = buf2[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf2[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf2 = this.consume(8);
        const num = buf2.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf2.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf2) => {
          if (err) return cb(err);
          if (buf2.length) {
            this._messageLength += buf2.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf2);
          }
          const er = this.dataMessage();
          if (er) return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat2(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat2(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf2 = concat2(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf2)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf2, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code2 = data.readUInt16BE(0);
            if (!isValidStatusCode(code2)) {
              return error(
                RangeError,
                `invalid status code ${code2}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf2 = data.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf2)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code2, buf2);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});
var require_sender = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = __require2("net");
    var tls = __require2("tls");
    var { randomFillSync } = __require2("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants2();
    var { isValidStatusCode } = require_validation2();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options3) {
        let mask;
        let merge3 = false;
        let offset = 2;
        let skipMasking = false;
        if (options3.mask) {
          mask = options3.maskBuffer || maskBuffer;
          if (options3.generateMask) {
            options3.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options3.mask || skipMasking) && options3[kByteLength] !== void 0) {
            dataLength = options3[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge3 = options3.mask && options3.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge3 ? dataLength + offset : offset);
        target[0] = options3.fin ? options3.opcode | 128 : options3.opcode;
        if (options3.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options3.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge3) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code2, data, mask, cb) {
        let buf2;
        if (code2 === void 0) {
          buf2 = EMPTY_BUFFER;
        } else if (typeof code2 !== "number" || !isValidStatusCode(code2)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf2 = Buffer.allocUnsafe(2);
          buf2.writeUInt16BE(code2, 0);
        } else {
          const length4 = Buffer.byteLength(data);
          if (length4 > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf2 = Buffer.allocUnsafe(2 + length4);
          buf2.writeUInt16BE(code2, 0);
          if (typeof data === "string") {
            buf2.write(data, 2);
          } else {
            buf2.set(data, 2);
          }
        }
        const options3 = {
          [kByteLength]: buf2.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf2, false, options3, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf2, options3), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options3 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options3, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options3), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options3 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options3, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options3), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options3, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options3.binary ? 2 : 1;
        let rsv1 = options3.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options3.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options3.fin,
            generateMask: this._generateMask,
            mask: options3.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options3.fin,
              generateMask: this._generateMask,
              mask: options3.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options3, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options3), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options3[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options3.fin, (_, buf2) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function") cb(err);
            for (let i2 = 0; i2 < this._queue.length; i2++) {
              const params = this._queue[i2];
              const callback = params[params.length - 1];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= options3[kByteLength];
          this._deflating = false;
          options3.readOnly = false;
          this.sendFrame(_Sender.frame(buf2, options3), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});
var require_event_target = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options3 = {}) {
        super(type);
        this[kCode] = options3.code === void 0 ? 0 : options3.code;
        this[kReason] = options3.reason === void 0 ? "" : options3.reason;
        this[kWasClean] = options3.wasClean === void 0 ? false : options3.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options3 = {}) {
        super(type);
        this[kError] = options3.error === void 0 ? null : options3.error;
        this[kMessage] = options3.message === void 0 ? "" : options3.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options3 = {}) {
        super(type);
        this[kData] = options3.data === void 0 ? null : options3.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget2 = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, listener, options3 = {}) {
        let wrapper3;
        if (type === "message") {
          wrapper3 = function onMessage(data, isBinary2) {
            const event = new MessageEvent("message", {
              data: isBinary2 ? data : data.toString()
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "close") {
          wrapper3 = function onClose(code2, message) {
            const event = new CloseEvent("close", {
              code: code2,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "error") {
          wrapper3 = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "open") {
          wrapper3 = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else {
          return;
        }
        wrapper3[kForOnEventAttribute] = !!options3[kForOnEventAttribute];
        wrapper3[kListener] = listener;
        if (options3.once) {
          this.once(type, wrapper3);
        } else {
          this.on(type, wrapper3);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget: EventTarget2,
      MessageEvent
    };
  }
});
var require_extension = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse11(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code2 = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        code2 = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code2] === 1) {
            if (start === -1) start = i2;
          } else if (i2 !== 0 && (code2 === 32 || code2 === 9)) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code2 === 59 || code2 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            const name = header.slice(start, end);
            if (code2 === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code2] === 1) {
            if (start === -1) start = i2;
          } else if (code2 === 32 || code2 === 9) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code2 === 59 || code2 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            push(params, header.slice(start, end), true);
            if (code2 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code2 === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code2] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1) start = i2;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code2] === 1) {
              if (start === -1) start = i2;
            } else if (code2 === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code2 === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code2 === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code2] === 1) {
            if (start === -1) start = i2;
          } else if (start !== -1 && (code2 === 32 || code2 === 9)) {
            if (end === -1) end = i2;
          } else if (code2 === 59 || code2 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code2 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes || code2 === 32 || code2 === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i2;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format32(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v2) => v2 === true ? k : `${k}=${v2}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format: format32, parse: parse11 };
  }
});
var require_websocket = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require2("events");
    var https = __require2("https");
    var http = __require2("http");
    var net = __require2("net");
    var tls = __require2("tls");
    var { randomBytes: randomBytes3, createHash } = __require2("crypto");
    var { Readable: Readable2 } = __require2("stream");
    var { URL: URL2 } = __require2("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants2();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format: format32, parse: parse11 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket3 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options3) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options3 = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options3);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options3) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options3.maxPayload,
          skipUTF8Validation: options3.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options3.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code2, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code2, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options3, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options3 === "function") {
          cb = options3;
          options3 = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options3
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options3) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options3,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      let invalidURLMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
        invalidURLMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isUnixSocket && !parsedUrl.pathname) {
        invalidURLMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidURLMessage = "The URL contains a fragment identifier";
      }
      if (invalidURLMessage) {
        const err = new SyntaxError(invalidURLMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes3(16).toString("base64");
      const get22 = isSecure ? https.get : http.get;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format32({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalHost = parsedUrl.host;
          const headers = options3 && options3.headers;
          options3 = { ...options3, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options3.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (parsedUrl.host !== websocket._originalHost) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          delete opts.headers.host;
          opts.auth = void 0;
        }
        if (opts.auth && !options3.headers.authorization) {
          options3.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get22(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options3);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING) return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse11(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options3) {
      options3.path = options3.socketPath;
      return net.connect(options3);
    }
    function tlsConnect(options3) {
      options3.path = void 0;
      if (!options3.servername && options3.servername !== "") {
        options3.servername = net.isIP(options3.host) ? "" : options3.host;
      }
      return tls.connect(options3);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length4 = toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length4;
        else websocket._bufferedAmount += length4;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code2, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code2;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code2 === 1005) websocket.close();
      else websocket.close(code2, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary2) {
      this[kWebSocket].emit("message", data, isBinary2);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});
var require_subprotocol = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function parse11(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (i2; i2 < header.length; i2++) {
        const code2 = header.charCodeAt(i2);
        if (end === -1 && tokenChars[code2] === 1) {
          if (start === -1) start = i2;
        } else if (i2 !== 0 && (code2 === 32 || code2 === 9)) {
          if (end === -1 && start !== -1) end = i2;
        } else if (code2 === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1) end = i2;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i2);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse11 };
  }
});
var require_websocket_server = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require2("events");
    var http = __require2("http");
    var https = __require2("https");
    var net = __require2("net");
    var tls = __require2("tls");
    var { createHash } = __require2("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options3, callback) {
        super();
        options3 = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options3
        };
        if (options3.port == null && !options3.server && !options3.noServer || options3.port != null && (options3.server || options3.noServer) || options3.server && options3.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options3.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options3.port,
            options3.host,
            options3.backlog,
            callback
          );
        } else if (options3.server) {
          this._server = options3.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options3.perMessageDeflate === true) options3.perMessageDeflate = {};
        if (options3.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options3;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"] : false;
        const version4 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version4 !== 8 && version4 !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version4 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code2, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code2 || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code2, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code2];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code2} ${http.STATUS_CODES[code2]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
  }
});
var import_stream;
var import_receiver;
var import_sender;
var import_websocket;
var import_websocket_server;
var wrapper_default;
var init_wrapper = __esm({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/wrapper.mjs"() {
    import_stream = __toESM(require_stream(), 1);
    import_receiver = __toESM(require_receiver(), 1);
    import_sender = __toESM(require_sender(), 1);
    import_websocket = __toESM(require_websocket(), 1);
    import_websocket_server = __toESM(require_websocket_server(), 1);
    wrapper_default = import_websocket.default;
  }
});
function createErrorResponse(data) {
  return JSON.stringify({ type: ERROR, data });
}
function createPushErrorResponse(data) {
  return JSON.stringify({
    type: ERROR,
    data: {
      ...data,
      type: REQUEST_TYPE.PUSH_ACTION
    }
  });
}
function createNotification(type, data) {
  return JSON.stringify({ type, data });
}
function createOkResponse(data) {
  return JSON.stringify({ type: OK, data });
}
function createServer(httpServer, options3 = {}) {
  const server = new import_websocket_server.default({
    ...defaultOptions3,
    ...options3,
    ...{ clientTracking: true },
    server: httpServer
  });
  server.channels = /* @__PURE__ */ new Set();
  server.customServerEventHandlers = { ...options3.serverHandlers };
  server.customSocketEventHandlers = { ...options3.socketHandlers };
  server.customMessageHandlers = { ...options3.messageHandlers };
  server.pingIntervalID = void 0;
  server.subscribersByChannelID = /* @__PURE__ */ Object.create(null);
  server.pushSubscriptions = /* @__PURE__ */ Object.create(null);
  const handlers = Object.keys(defaultServerHandlers);
  handlers.forEach((name) => {
    server.on(name, (...args) => {
      try {
        ;
        defaultServerHandlers[name].apply(server, args);
        server.customServerEventHandlers[name]?.apply(server, args);
      } catch (error) {
        server.emit("error", error);
      }
    });
  });
  if (server.options.pingInterval > 0) {
    server.pingIntervalID = setInterval(() => {
      if (server.clients.size && server.options.logPingRounds) {
        log.debug("Pinging clients");
      }
      server.clients.forEach((client) => {
        if (client.endpoint) return;
        if (client.pinged && !client.activeSinceLastPing) {
          log(`Disconnecting irresponsive client ${client.id}`);
          return client.terminate();
        }
        if (client.readyState === wrapper_default.OPEN) {
          client.send(createMessage(PING, Date.now()), () => {
            client.activeSinceLastPing = false;
            client.pinged = true;
          });
        }
      });
    }, server.options.pingInterval);
  }
  return Object.assign(server, publicMethods2);
}
var import_npm_chalk;
var bold;
var PING;
var PONG;
var PUB;
var SUB;
var UNSUB;
var KV_FILTER;
var ERROR;
var OK;
var defaultOptions3;
var tag2;
var generateSocketID;
var log;
var defaultServerHandlers;
var defaultSocketEventHandlers;
var defaultMessageHandlers2;
var publicMethods2;
var init_pubsub2 = __esm({
  "src/serve/pubsub.ts"() {
    "use strict";
    init_pubsub();
    init_push();
    import_npm_chalk = __toESM(require_source());
    init_wrapper();
    ({ bold } = import_npm_chalk.default);
    ({ PING, PONG, PUB, SUB, UNSUB, KV_FILTER } = NOTIFICATION_TYPE);
    ({ ERROR, OK } = RESPONSE_TYPE);
    defaultOptions3 = {
      logPingRounds: process8.env.NODE_ENV !== "production" && !process8.env.CI,
      logPongMessages: false,
      maxPayload: 6 * 1024 * 1024,
      pingInterval: 3e4
    };
    tag2 = "[pubsub]";
    generateSocketID = /* @__PURE__ */ (() => {
      let counter = 0;
      return (debugID) => String(counter++) + (debugID ? "-" + debugID : "");
    })();
    log = logger.info.bind(logger, tag2);
    log.bold = (...args) => logger.debug(bold(tag2, ...args));
    log.debug = logger.debug.bind(logger, tag2);
    log.error = (error, ...args) => logger.error(error, bold.red(tag2, ...args));
    defaultServerHandlers = {
      close() {
        log("Server closed");
      },
      /**
       * Emitted when a connection handshake completes.
       *
       * @see https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection
       * @param {ws.WebSocket} socket - The client socket that connected.
       * @param {http.IncomingMessage} request - The underlying Node http GET request.
       */
      connection(socket, request) {
        const server = this;
        const url = request.url;
        const urlSearch = url?.includes("?") ? url.slice(url.lastIndexOf("?")) : "";
        const debugID = new URLSearchParams(urlSearch).get("debugID") || "";
        const send = socket.send.bind(socket);
        socket.id = generateSocketID(debugID);
        socket.activeSinceLastPing = true;
        socket.pinged = false;
        socket.server = server;
        socket.subscriptions = /* @__PURE__ */ new Set();
        socket.kvFilter = /* @__PURE__ */ new Map();
        socket.ip = request.headers["x-real-ip"] || request.headers["x-forwarded-for"]?.split(",")[0].trim() || request.socket.remoteAddress;
        socket.send = function(data) {
          if (typeof data === "object" && data !== null && typeof data[Symbol.toPrimitive] === "function") {
            return send(data[Symbol.toPrimitive]());
          }
          return send(data);
        };
        log.bold(`Socket ${socket.id} connected. Total: ${this.clients.size}`);
        ["close", "error", "message", "ping", "pong"].forEach((eventName) => {
          socket.on(eventName, (...args) => {
            if (eventName !== "message") {
              log.debug(`Event '${eventName}' on socket ${socket.id}`, ...args.map((arg) => String(arg)));
            }
            try {
              ;
              defaultSocketEventHandlers[eventName]?.call(socket, ...args);
              socket.server.customSocketEventHandlers[eventName]?.call(socket, ...args);
            } catch (error) {
              socket.server.emit("error", error);
              socket.terminate();
            }
          });
        });
      },
      error(error) {
        log.error(error, "Server error");
      },
      headers() {
      },
      listening() {
        log("Server listening");
      }
    };
    defaultSocketEventHandlers = {
      close() {
        const socket = this;
        const { server } = this;
        for (const channelID of socket.subscriptions) {
          server.subscribersByChannelID[channelID].delete(socket);
        }
        socket.subscriptions.clear();
      },
      message(data) {
        const socket = this;
        const { server } = this;
        const text = data.toString();
        let msg = { type: "" };
        try {
          msg = messageParser(text);
        } catch (error) {
          log.error(error, `Malformed message: ${error.message}`);
          server.rejectMessageAndTerminateSocket(msg, socket);
          return;
        }
        if (msg.type !== "pong" || server.options.logPongMessages) {
          log.debug(`Received '${msg.type}' on socket ${socket.id}`, text);
        }
        socket.activeSinceLastPing = true;
        const defaultHandler = defaultMessageHandlers2[msg.type];
        const customHandler = server.customMessageHandlers[msg.type];
        if (defaultHandler || customHandler) {
          try {
            ;
            defaultHandler?.call(socket, msg);
            customHandler?.call(socket, msg);
          } catch (error) {
            log.error(error, "onMessage");
            server.rejectMessageAndTerminateSocket(msg, socket);
          }
        } else {
          log.error(`Unhandled message type: ${msg.type}`);
          server.rejectMessageAndTerminateSocket(msg, socket);
        }
      }
    };
    defaultMessageHandlers2 = {
      [PONG]() {
        const socket = this;
        socket.activeSinceLastPing = true;
      },
      [PUB](msg) {
        const { server } = this;
        const subscribers = server.subscribersByChannelID[msg.channelID];
        server.broadcast(msg, { to: subscribers ?? [] });
      },
      [SUB]({ channelID, kvFilter }) {
        const socket = this;
        const { server } = this;
        if (!server.channels.has(channelID)) {
          socket.send(createErrorResponse(
            { type: SUB, channelID, reason: `Unknown channel id: ${channelID}` }
          ));
          return;
        }
        if (!socket.subscriptions.has(channelID)) {
          socket.subscriptions.add(channelID);
          if (Array.isArray(kvFilter)) {
            socket.kvFilter.set(channelID, new Set(kvFilter));
          }
          if (!server.subscribersByChannelID[channelID]) {
            server.subscribersByChannelID[channelID] = /* @__PURE__ */ new Set();
          }
          server.subscribersByChannelID[channelID].add(socket);
        } else {
          log.debug("Already subscribed to", channelID);
        }
        socket.send(createOkResponse({ type: SUB, channelID, kvFilter }));
      },
      [KV_FILTER]({ channelID, kvFilter }) {
        const socket = this;
        const { server } = this;
        if (!server.channels.has(channelID)) {
          socket.send(createErrorResponse(
            { type: SUB, channelID, reason: `Unknown channel id: ${channelID}` }
          ));
          return;
        }
        if (socket.subscriptions.has(channelID)) {
          if (Array.isArray(kvFilter)) {
            socket.kvFilter.set(channelID, new Set(kvFilter));
          } else {
            socket.kvFilter.delete(channelID);
          }
        } else {
          log.debug("[KV_FILTER] Not subscribed to", channelID);
        }
        socket.send(createOkResponse({ type: KV_FILTER, channelID, kvFilter }));
      },
      [UNSUB]({ channelID }) {
        const socket = this;
        const { server } = this;
        if (!server.channels.has(channelID)) {
          socket.send(createErrorResponse(
            { type: UNSUB, channelID, reason: `Unknown channel id: ${channelID}` }
          ));
        }
        if (socket.subscriptions.has(channelID)) {
          socket.subscriptions.delete(channelID);
          socket.kvFilter.delete(channelID);
          if (server.subscribersByChannelID[channelID]) {
            server.subscribersByChannelID[channelID].delete(socket);
          }
        }
        socket.send(createOkResponse({ type: UNSUB, channelID }));
      }
    };
    publicMethods2 = {
      /**
       * Broadcasts a message, ignoring clients which are not open.
       *
       * @param message
       * @param to - The intended recipients of the message. Defaults to every open client socket.
       * @param except - A recipient to exclude. Optional.
       */
      broadcast(message, { to, except, wsOnly } = {}) {
        const server = this;
        const msg = typeof message === "string" ? message : JSON.stringify(message);
        let shortMsg;
        const shortenPayload = () => {
          if (!shortMsg && (typeof message === "object" && message.type === NOTIFICATION_TYPE.ENTRY && message.data)) {
            delete message.data;
            shortMsg = JSON.stringify(message);
          }
          return shortMsg;
        };
        for (const client of to || server.clients) {
          if (!wsOnly && client.endpoint) {
            if (msg.length > 4096 - 86 - 17) {
              if (!shortenPayload()) {
                console.info("Skipping too large of a payload for", client.id);
                continue;
              }
            }
            postEvent(client, shortMsg || msg).catch((e2) => {
              if (e2?.message === "Payload too large") {
                if (shortMsg || !shortenPayload()) {
                  console.info("Skipping too large of a payload for", client.id);
                  return;
                }
                postEvent(client, shortMsg).catch((e3) => {
                  console.error(e3, "Error posting push notification");
                });
                return;
              }
              console.error(e2, "Error posting push notification");
            });
            continue;
          }
          if (client.readyState === wrapper_default.OPEN && client !== except) {
            client.send(msg);
          }
        }
      },
      // Enumerates the subscribers of a given channel.
      *enumerateSubscribers(channelID, kvKey) {
        const server = this;
        if (channelID in server.subscribersByChannelID) {
          const subscribers = server.subscribersByChannelID[channelID];
          if (!kvKey) {
            yield* subscribers;
          } else {
            for (const subscriber of subscribers) {
              const kvFilter = subscriber.kvFilter?.get(channelID);
              if (!kvFilter || kvFilter.has(kvKey)) yield subscriber;
            }
          }
        }
      },
      rejectMessageAndTerminateSocket(request, socket) {
        socket.send(createErrorResponse({ ...request }), () => socket.terminate());
      }
    };
  }
});
var require_parser = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/parser.js"(exports2) {
    "use strict";
    exports2.load = function(received, defaults, onto = {}) {
      var k, ref, v2;
      for (k in defaults) {
        v2 = defaults[k];
        onto[k] = (ref = received[k]) != null ? ref : v2;
      }
      return onto;
    };
    exports2.overwrite = function(received, defaults, onto = {}) {
      var k, v2;
      for (k in received) {
        v2 = received[k];
        if (defaults[k] !== void 0) {
          onto[k] = v2;
        }
      }
      return onto;
    };
  }
});
var require_DLList = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/DLList.js"(exports2, module2) {
    "use strict";
    var DLList;
    DLList = class DLList {
      constructor(incr, decr) {
        this.incr = incr;
        this.decr = decr;
        this._first = null;
        this._last = null;
        this.length = 0;
      }
      push(value) {
        var node;
        this.length++;
        if (typeof this.incr === "function") {
          this.incr();
        }
        node = {
          value,
          prev: this._last,
          next: null
        };
        if (this._last != null) {
          this._last.next = node;
          this._last = node;
        } else {
          this._first = this._last = node;
        }
        return void 0;
      }
      shift() {
        var value;
        if (this._first == null) {
          return;
        } else {
          this.length--;
          if (typeof this.decr === "function") {
            this.decr();
          }
        }
        value = this._first.value;
        if ((this._first = this._first.next) != null) {
          this._first.prev = null;
        } else {
          this._last = null;
        }
        return value;
      }
      first() {
        if (this._first != null) {
          return this._first.value;
        }
      }
      getArray() {
        var node, ref, results;
        node = this._first;
        results = [];
        while (node != null) {
          results.push((ref = node, node = node.next, ref.value));
        }
        return results;
      }
      forEachShift(cb) {
        var node;
        node = this.shift();
        while (node != null) {
          cb(node), node = this.shift();
        }
        return void 0;
      }
      debug() {
        var node, ref, ref1, ref2, results;
        node = this._first;
        results = [];
        while (node != null) {
          results.push((ref = node, node = node.next, {
            value: ref.value,
            prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
            next: (ref2 = ref.next) != null ? ref2.value : void 0
          }));
        }
        return results;
      }
    };
    module2.exports = DLList;
  }
});
var require_Events = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Events.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events2;
    Events2 = class Events {
      constructor(instance) {
        this.instance = instance;
        this._events = {};
        if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
          throw new Error("An Emitter already exists for this object");
        }
        this.instance.on = (name, cb) => {
          return this._addListener(name, "many", cb);
        };
        this.instance.once = (name, cb) => {
          return this._addListener(name, "once", cb);
        };
        this.instance.removeAllListeners = (name = null) => {
          if (name != null) {
            return delete this._events[name];
          } else {
            return this._events = {};
          }
        };
      }
      _addListener(name, status, cb) {
        var base4;
        if ((base4 = this._events)[name] == null) {
          base4[name] = [];
        }
        this._events[name].push({
          cb,
          status
        });
        return this.instance;
      }
      listenerCount(name) {
        if (this._events[name] != null) {
          return this._events[name].length;
        } else {
          return 0;
        }
      }
      trigger(name, ...args) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var e2, promises;
          try {
            if (name !== "debug") {
              _this.trigger("debug", `Event triggered: ${name}`, args);
            }
            if (_this._events[name] == null) {
              return;
            }
            _this._events[name] = _this._events[name].filter(function(listener) {
              return listener.status !== "none";
            });
            promises = _this._events[name].map(
              /* @__PURE__ */ function() {
                var _ref = _asyncToGenerator2(function* (listener) {
                  var e3, returned;
                  if (listener.status === "none") {
                    return;
                  }
                  if (listener.status === "once") {
                    listener.status = "none";
                  }
                  try {
                    returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
                    if (typeof (returned != null ? returned.then : void 0) === "function") {
                      return yield returned;
                    } else {
                      return returned;
                    }
                  } catch (error) {
                    e3 = error;
                    if (true) {
                      _this.trigger("error", e3);
                    }
                    return null;
                  }
                });
                return function(_x) {
                  return _ref.apply(this, arguments);
                };
              }()
            );
            return (yield Promise.all(promises)).find(function(x3) {
              return x3 != null;
            });
          } catch (error) {
            e2 = error;
            if (true) {
              _this.trigger("error", e2);
            }
            return null;
          }
        })();
      }
    };
    module2.exports = Events2;
  }
});
var require_Queues = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Queues.js"(exports2, module2) {
    "use strict";
    var DLList;
    var Events2;
    var Queues;
    DLList = require_DLList();
    Events2 = require_Events();
    Queues = class Queues {
      constructor(num_priorities) {
        var i2;
        this.Events = new Events2(this);
        this._length = 0;
        this._lists = function() {
          var j, ref, results;
          results = [];
          for (i2 = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i2 = 1 <= ref ? ++j : --j) {
            results.push(new DLList(() => {
              return this.incr();
            }, () => {
              return this.decr();
            }));
          }
          return results;
        }.call(this);
      }
      incr() {
        if (this._length++ === 0) {
          return this.Events.trigger("leftzero");
        }
      }
      decr() {
        if (--this._length === 0) {
          return this.Events.trigger("zero");
        }
      }
      push(job) {
        return this._lists[job.options.priority].push(job);
      }
      queued(priority) {
        if (priority != null) {
          return this._lists[priority].length;
        } else {
          return this._length;
        }
      }
      shiftAll(fn) {
        return this._lists.forEach(function(list) {
          return list.forEachShift(fn);
        });
      }
      getFirst(arr = this._lists) {
        var j, len, list;
        for (j = 0, len = arr.length; j < len; j++) {
          list = arr[j];
          if (list.length > 0) {
            return list;
          }
        }
        return [];
      }
      shiftLastFrom(priority) {
        return this.getFirst(this._lists.slice(priority).reverse()).shift();
      }
    };
    module2.exports = Queues;
  }
});
var require_BottleneckError = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/BottleneckError.js"(exports2, module2) {
    "use strict";
    var BottleneckError;
    BottleneckError = class BottleneckError extends Error {
    };
    module2.exports = BottleneckError;
  }
});
var require_Job = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Job.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var BottleneckError;
    var DEFAULT_PRIORITY;
    var Job;
    var NUM_PRIORITIES;
    var parser2;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser2 = require_parser();
    BottleneckError = require_BottleneckError();
    Job = class Job {
      constructor(task, args, options3, jobDefaults, rejectOnDrop, Events2, _states, Promise2) {
        this.task = task;
        this.args = args;
        this.rejectOnDrop = rejectOnDrop;
        this.Events = Events2;
        this._states = _states;
        this.Promise = Promise2;
        this.options = parser2.load(options3, jobDefaults);
        this.options.priority = this._sanitizePriority(this.options.priority);
        if (this.options.id === jobDefaults.id) {
          this.options.id = `${this.options.id}-${this._randomIndex()}`;
        }
        this.promise = new this.Promise((_resolve, _reject) => {
          this._resolve = _resolve;
          this._reject = _reject;
        });
        this.retryCount = 0;
      }
      _sanitizePriority(priority) {
        var sProperty;
        sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
        if (sProperty < 0) {
          return 0;
        } else if (sProperty > NUM_PRIORITIES - 1) {
          return NUM_PRIORITIES - 1;
        } else {
          return sProperty;
        }
      }
      _randomIndex() {
        return Math.random().toString(36).slice(2);
      }
      doDrop({
        error,
        message = "This job has been dropped by Bottleneck"
      } = {}) {
        if (this._states.remove(this.options.id)) {
          if (this.rejectOnDrop) {
            this._reject(error != null ? error : new BottleneckError(message));
          }
          this.Events.trigger("dropped", {
            args: this.args,
            options: this.options,
            task: this.task,
            promise: this.promise
          });
          return true;
        } else {
          return false;
        }
      }
      _assertStatus(expected) {
        var status;
        status = this._states.jobStatus(this.options.id);
        if (!(status === expected || expected === "DONE" && status === null)) {
          throw new BottleneckError(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
        }
      }
      doReceive() {
        this._states.start(this.options.id);
        return this.Events.trigger("received", {
          args: this.args,
          options: this.options
        });
      }
      doQueue(reachedHWM, blocked) {
        this._assertStatus("RECEIVED");
        this._states.next(this.options.id);
        return this.Events.trigger("queued", {
          args: this.args,
          options: this.options,
          reachedHWM,
          blocked
        });
      }
      doRun() {
        if (this.retryCount === 0) {
          this._assertStatus("QUEUED");
          this._states.next(this.options.id);
        } else {
          this._assertStatus("EXECUTING");
        }
        return this.Events.trigger("scheduled", {
          args: this.args,
          options: this.options
        });
      }
      doExecute(chained, clearGlobalState, run2, free) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var error, eventInfo, passed;
          if (_this.retryCount === 0) {
            _this._assertStatus("RUNNING");
            _this._states.next(_this.options.id);
          } else {
            _this._assertStatus("EXECUTING");
          }
          eventInfo = {
            args: _this.args,
            options: _this.options,
            retryCount: _this.retryCount
          };
          _this.Events.trigger("executing", eventInfo);
          try {
            passed = yield chained != null ? chained.schedule(_this.options, _this.task, ..._this.args) : _this.task(..._this.args);
            if (clearGlobalState()) {
              _this.doDone(eventInfo);
              yield free(_this.options, eventInfo);
              _this._assertStatus("DONE");
              return _this._resolve(passed);
            }
          } catch (error1) {
            error = error1;
            return _this._onFailure(error, eventInfo, clearGlobalState, run2, free);
          }
        })();
      }
      doExpire(clearGlobalState, run2, free) {
        var error, eventInfo;
        if (this._states.jobStatus(this.options.id === "RUNNING")) {
          this._states.next(this.options.id);
        }
        this._assertStatus("EXECUTING");
        eventInfo = {
          args: this.args,
          options: this.options,
          retryCount: this.retryCount
        };
        error = new BottleneckError(`This job timed out after ${this.options.expiration} ms.`);
        return this._onFailure(error, eventInfo, clearGlobalState, run2, free);
      }
      _onFailure(error, eventInfo, clearGlobalState, run2, free) {
        var _this2 = this;
        return _asyncToGenerator2(function* () {
          var retry, retryAfter;
          if (clearGlobalState()) {
            retry = yield _this2.Events.trigger("failed", error, eventInfo);
            if (retry != null) {
              retryAfter = ~~retry;
              _this2.Events.trigger("retry", `Retrying ${_this2.options.id} after ${retryAfter} ms`, eventInfo);
              _this2.retryCount++;
              return run2(retryAfter);
            } else {
              _this2.doDone(eventInfo);
              yield free(_this2.options, eventInfo);
              _this2._assertStatus("DONE");
              return _this2._reject(error);
            }
          }
        })();
      }
      doDone(eventInfo) {
        this._assertStatus("EXECUTING");
        this._states.next(this.options.id);
        return this.Events.trigger("done", eventInfo);
      }
    };
    module2.exports = Job;
  }
});
var require_LocalDatastore = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/LocalDatastore.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var BottleneckError;
    var LocalDatastore;
    var parser2;
    parser2 = require_parser();
    BottleneckError = require_BottleneckError();
    LocalDatastore = class LocalDatastore {
      constructor(instance, storeOptions, storeInstanceOptions) {
        this.instance = instance;
        this.storeOptions = storeOptions;
        this.clientId = this.instance._randomIndex();
        parser2.load(storeInstanceOptions, storeInstanceOptions, this);
        this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
        this._running = 0;
        this._done = 0;
        this._unblockTime = 0;
        this.ready = this.Promise.resolve();
        this.clients = {};
        this._startHeartbeat();
      }
      _startHeartbeat() {
        var base4;
        if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
          return typeof (base4 = this.heartbeat = setInterval(() => {
            var amount, incr, maximum, now, reservoir;
            now = Date.now();
            if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
              this._lastReservoirRefresh = now;
              this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
              this.instance._drainAll(this.computeCapacity());
            }
            if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
              var _this$storeOptions = this.storeOptions;
              amount = _this$storeOptions.reservoirIncreaseAmount;
              maximum = _this$storeOptions.reservoirIncreaseMaximum;
              reservoir = _this$storeOptions.reservoir;
              this._lastReservoirIncrease = now;
              incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
              if (incr > 0) {
                this.storeOptions.reservoir += incr;
                return this.instance._drainAll(this.computeCapacity());
              }
            }
          }, this.heartbeatInterval)).unref === "function" ? base4.unref() : void 0;
        } else {
          return clearInterval(this.heartbeat);
        }
      }
      __publish__(message) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          yield _this.yieldLoop();
          return _this.instance.Events.trigger("message", message.toString());
        })();
      }
      __disconnect__(flush) {
        var _this2 = this;
        return _asyncToGenerator2(function* () {
          yield _this2.yieldLoop();
          clearInterval(_this2.heartbeat);
          return _this2.Promise.resolve();
        })();
      }
      yieldLoop(t = 0) {
        return new this.Promise(function(resolve8, reject) {
          return setTimeout(resolve8, t);
        });
      }
      computePenalty() {
        var ref;
        return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5e3;
      }
      __updateSettings__(options3) {
        var _this3 = this;
        return _asyncToGenerator2(function* () {
          yield _this3.yieldLoop();
          parser2.overwrite(options3, options3, _this3.storeOptions);
          _this3._startHeartbeat();
          _this3.instance._drainAll(_this3.computeCapacity());
          return true;
        })();
      }
      __running__() {
        var _this4 = this;
        return _asyncToGenerator2(function* () {
          yield _this4.yieldLoop();
          return _this4._running;
        })();
      }
      __queued__() {
        var _this5 = this;
        return _asyncToGenerator2(function* () {
          yield _this5.yieldLoop();
          return _this5.instance.queued();
        })();
      }
      __done__() {
        var _this6 = this;
        return _asyncToGenerator2(function* () {
          yield _this6.yieldLoop();
          return _this6._done;
        })();
      }
      __groupCheck__(time3) {
        var _this7 = this;
        return _asyncToGenerator2(function* () {
          yield _this7.yieldLoop();
          return _this7._nextRequest + _this7.timeout < time3;
        })();
      }
      computeCapacity() {
        var maxConcurrent, reservoir;
        var _this$storeOptions2 = this.storeOptions;
        maxConcurrent = _this$storeOptions2.maxConcurrent;
        reservoir = _this$storeOptions2.reservoir;
        if (maxConcurrent != null && reservoir != null) {
          return Math.min(maxConcurrent - this._running, reservoir);
        } else if (maxConcurrent != null) {
          return maxConcurrent - this._running;
        } else if (reservoir != null) {
          return reservoir;
        } else {
          return null;
        }
      }
      conditionsCheck(weight) {
        var capacity;
        capacity = this.computeCapacity();
        return capacity == null || weight <= capacity;
      }
      __incrementReservoir__(incr) {
        var _this8 = this;
        return _asyncToGenerator2(function* () {
          var reservoir;
          yield _this8.yieldLoop();
          reservoir = _this8.storeOptions.reservoir += incr;
          _this8.instance._drainAll(_this8.computeCapacity());
          return reservoir;
        })();
      }
      __currentReservoir__() {
        var _this9 = this;
        return _asyncToGenerator2(function* () {
          yield _this9.yieldLoop();
          return _this9.storeOptions.reservoir;
        })();
      }
      isBlocked(now) {
        return this._unblockTime >= now;
      }
      check(weight, now) {
        return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
      }
      __check__(weight) {
        var _this10 = this;
        return _asyncToGenerator2(function* () {
          var now;
          yield _this10.yieldLoop();
          now = Date.now();
          return _this10.check(weight, now);
        })();
      }
      __register__(index, weight, expiration) {
        var _this11 = this;
        return _asyncToGenerator2(function* () {
          var now, wait;
          yield _this11.yieldLoop();
          now = Date.now();
          if (_this11.conditionsCheck(weight)) {
            _this11._running += weight;
            if (_this11.storeOptions.reservoir != null) {
              _this11.storeOptions.reservoir -= weight;
            }
            wait = Math.max(_this11._nextRequest - now, 0);
            _this11._nextRequest = now + wait + _this11.storeOptions.minTime;
            return {
              success: true,
              wait,
              reservoir: _this11.storeOptions.reservoir
            };
          } else {
            return {
              success: false
            };
          }
        })();
      }
      strategyIsBlock() {
        return this.storeOptions.strategy === 3;
      }
      __submit__(queueLength, weight) {
        var _this12 = this;
        return _asyncToGenerator2(function* () {
          var blocked, now, reachedHWM;
          yield _this12.yieldLoop();
          if (_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent) {
            throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this12.storeOptions.maxConcurrent}`);
          }
          now = Date.now();
          reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);
          blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));
          if (blocked) {
            _this12._unblockTime = now + _this12.computePenalty();
            _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;
            _this12.instance._dropAllQueued();
          }
          return {
            reachedHWM,
            blocked,
            strategy: _this12.storeOptions.strategy
          };
        })();
      }
      __free__(index, weight) {
        var _this13 = this;
        return _asyncToGenerator2(function* () {
          yield _this13.yieldLoop();
          _this13._running -= weight;
          _this13._done += weight;
          _this13.instance._drainAll(_this13.computeCapacity());
          return {
            running: _this13._running
          };
        })();
      }
    };
    module2.exports = LocalDatastore;
  }
});
var require_lua = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/lua.json"(exports2, module2) {
    module2.exports = {
      "blacklist_client.lua": "local blacklist = ARGV[num_static_argv + 1]\n\nif redis.call('zscore', client_last_seen_key, blacklist) then\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\nend\n\n\nreturn {}\n",
      "check.lua": "local weight = tonumber(ARGV[num_static_argv + 1])\n\nlocal capacity = process_tick(now, false)['capacity']\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\n\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\n",
      "conditions_check.lua": "local conditions_check = function (capacity, weight)\n  return capacity == nil or weight <= capacity\nend\n",
      "current_reservoir.lua": "return process_tick(now, false)['reservoir']\n",
      "done.lua": "process_tick(now, false)\n\nreturn tonumber(redis.call('hget', settings_key, 'done'))\n",
      "free.lua": "local index = ARGV[num_static_argv + 1]\n\nredis.call('zadd', job_expirations_key, 0, index)\n\nreturn process_tick(now, false)['running']\n",
      "get_time.lua": "redis.replicate_commands()\n\nlocal get_time = function ()\n  local time = redis.call('time')\n\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\nend\n",
      "group_check.lua": "return not (redis.call('exists', settings_key) == 1)\n",
      "heartbeat.lua": "process_tick(now, true)\n",
      "increment_reservoir.lua": "local incr = tonumber(ARGV[num_static_argv + 1])\n\nredis.call('hincrby', settings_key, 'reservoir', incr)\n\nlocal reservoir = process_tick(now, true)['reservoir']\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn reservoir\n",
      "init.lua": `local clear = tonumber(ARGV[num_static_argv + 1])
local limiter_version = ARGV[num_static_argv + 2]
local num_local_argv = num_static_argv + 2

if clear == 1 then
  redis.call('del', unpack(KEYS))
end

if redis.call('exists', settings_key) == 0 then
  -- Create
  local args = {'hmset', settings_key}

  for i = num_local_argv + 1, #ARGV do
    table.insert(args, ARGV[i])
  end

  redis.call(unpack(args))
  redis.call('hmset', settings_key,
    'nextRequest', now,
    'lastReservoirRefresh', now,
    'lastReservoirIncrease', now,
    'running', 0,
    'done', 0,
    'unblockTime', 0,
    'capacityPriorityCounter', 0
  )

else
  -- Apply migrations
  local settings = redis.call('hmget', settings_key,
    'id',
    'version'
  )
  local id = settings[1]
  local current_version = settings[2]

  if current_version ~= limiter_version then
    local version_digits = {}
    for k, v in string.gmatch(current_version, "([^.]+)") do
      table.insert(version_digits, tonumber(k))
    end

    -- 2.10.0
    if version_digits[2] < 10 then
      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')
      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')
      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')
      redis.call('hsetnx', settings_key, 'done', 0)
      redis.call('hset', settings_key, 'version', '2.10.0')
    end

    -- 2.11.1
    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then
      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then
        redis.call('hmset', settings_key,
          'lastReservoirRefresh', now,
          'version', '2.11.1'
        )
      end
    end

    -- 2.14.0
    if version_digits[2] < 14 then
      local old_running_key = 'b_'..id..'_running'
      local old_executing_key = 'b_'..id..'_executing'

      if redis.call('exists', old_running_key) == 1 then
        redis.call('rename', old_running_key, job_weights_key)
      end
      if redis.call('exists', old_executing_key) == 1 then
        redis.call('rename', old_executing_key, job_expirations_key)
      end
      redis.call('hset', settings_key, 'version', '2.14.0')
    end

    -- 2.15.2
    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then
      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)
      redis.call('hset', settings_key, 'version', '2.15.2')
    end

    -- 2.17.0
    if version_digits[2] < 17 then
      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)
      redis.call('hset', settings_key, 'version', '2.17.0')
    end

    -- 2.18.0
    if version_digits[2] < 18 then
      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')
      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')
      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')
      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)
      redis.call('hset', settings_key, 'version', '2.18.0')
    end

  end

  process_tick(now, false)
end

local groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))
refresh_expiration(0, 0, groupTimeout)

return {}
`,
      "process_tick.lua": "local process_tick = function (now, always_publish)\n\n  local compute_capacity = function (maxConcurrent, running, reservoir)\n    if maxConcurrent ~= nil and reservoir ~= nil then\n      return math.min((maxConcurrent - running), reservoir)\n    elseif maxConcurrent ~= nil then\n      return maxConcurrent - running\n    elseif reservoir ~= nil then\n      return reservoir\n    else\n      return nil\n    end\n  end\n\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'maxConcurrent',\n    'running',\n    'reservoir',\n    'reservoirRefreshInterval',\n    'reservoirRefreshAmount',\n    'lastReservoirRefresh',\n    'reservoirIncreaseInterval',\n    'reservoirIncreaseAmount',\n    'reservoirIncreaseMaximum',\n    'lastReservoirIncrease',\n    'capacityPriorityCounter',\n    'clientTimeout'\n  )\n  local id = settings[1]\n  local maxConcurrent = tonumber(settings[2])\n  local running = tonumber(settings[3])\n  local reservoir = tonumber(settings[4])\n  local reservoirRefreshInterval = tonumber(settings[5])\n  local reservoirRefreshAmount = tonumber(settings[6])\n  local lastReservoirRefresh = tonumber(settings[7])\n  local reservoirIncreaseInterval = tonumber(settings[8])\n  local reservoirIncreaseAmount = tonumber(settings[9])\n  local reservoirIncreaseMaximum = tonumber(settings[10])\n  local lastReservoirIncrease = tonumber(settings[11])\n  local capacityPriorityCounter = tonumber(settings[12])\n  local clientTimeout = tonumber(settings[13])\n\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  --\n  -- Process 'running' changes\n  --\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\n\n  if #expired > 0 then\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\n\n    local flush_batch = function (batch, acc)\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\n                      redis.call('hdel',  job_weights_key, unpack(batch))\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\n                      redis.call('hdel',  job_clients_key, unpack(batch))\n\n      -- Calculate sum of removed weights\n      for i = 1, #weights do\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\n      end\n\n      -- Calculate sum of removed weights by client\n      local client_weights = {}\n      for i = 1, #clients do\n        local removed = tonumber(weights[i]) or 0\n        if removed > 0 then\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\n        end\n      end\n    end\n\n    local acc = {\n      ['total'] = 0,\n      ['client_weights'] = {}\n    }\n    local batch_size = 1000\n\n    -- Compute changes to Zsets and apply changes to Hashes\n    for i = 1, #expired, batch_size do\n      local batch = {}\n      for j = i, math.min(i + batch_size - 1, #expired) do\n        table.insert(batch, expired[j])\n      end\n\n      flush_batch(batch, acc)\n    end\n\n    -- Apply changes to Zsets\n    if acc['total'] > 0 then\n      redis.call('hincrby', settings_key, 'done', acc['total'])\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\n    end\n\n    for client, weight in pairs(acc['client_weights']) do\n      redis.call('zincrby', client_running_key, -weight, client)\n    end\n  end\n\n  --\n  -- Process 'reservoir' changes\n  --\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\n    reservoir = reservoirRefreshAmount\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirRefresh', now\n    )\n  end\n\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\n    local incr = reservoirIncreaseAmount * num_intervals\n    if reservoirIncreaseMaximum ~= nil then\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\n    end\n    if incr > 0 then\n      reservoir = (reservoir or 0) + incr\n    end\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\n    )\n  end\n\n  --\n  -- Clear unresponsive clients\n  --\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\n  local unresponsive_lookup = {}\n  local terminated_clients = {}\n  for i = 1, #unresponsive do\n    unresponsive_lookup[unresponsive[i]] = true\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\n      table.insert(terminated_clients, unresponsive[i])\n    end\n  end\n  if #terminated_clients > 0 then\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\n  end\n\n  --\n  -- Broadcast capacity changes\n  --\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\n    -- always_publish or was not unlimited, now unlimited\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\n    -- capacity was increased\n    -- send the capacity message to the limiter having the lowest number of running jobs\n    -- the tiebreaker is the limiter having not registered a job in the longest time\n\n    local lowest_concurrency_value = nil\n    local lowest_concurrency_clients = {}\n    local lowest_concurrency_last_registered = {}\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\n\n    for i = 1, #client_concurrencies, 2 do\n      local client = client_concurrencies[i]\n      local concurrency = tonumber(client_concurrencies[i+1])\n\n      if (\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\n      ) and (\n        not unresponsive_lookup[client]\n      ) and (\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\n      ) then\n        lowest_concurrency_value = concurrency\n        table.insert(lowest_concurrency_clients, client)\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\n        table.insert(lowest_concurrency_last_registered, last_registered)\n      end\n    end\n\n    if #lowest_concurrency_clients > 0 then\n      local position = 1\n      local earliest = lowest_concurrency_last_registered[1]\n\n      for i,v in ipairs(lowest_concurrency_last_registered) do\n        if v < earliest then\n          position = i\n          earliest = v\n        end\n      end\n\n      local next_client = lowest_concurrency_clients[position]\n      redis.call('publish', 'b_'..id,\n        'capacity-priority:'..(final_capacity or '')..\n        ':'..next_client..\n        ':'..capacityPriorityCounter\n      )\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\n    else\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n    end\n  end\n\n  return {\n    ['capacity'] = final_capacity,\n    ['running'] = running,\n    ['reservoir'] = reservoir\n  }\nend\n",
      "queued.lua": "local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\n\nlocal sum = 0\nfor i = 1, #client_queued do\n  sum = sum + tonumber(client_queued[i])\nend\n\nreturn sum\n",
      "refresh_expiration.lua": "local refresh_expiration = function (now, nextRequest, groupTimeout)\n\n  if groupTimeout ~= nil then\n    local ttl = (nextRequest + groupTimeout) - now\n\n    for i = 1, #KEYS do\n      redis.call('pexpire', KEYS[i], ttl)\n    end\n  end\n\nend\n",
      "refs.lua": "local settings_key = KEYS[1]\nlocal job_weights_key = KEYS[2]\nlocal job_expirations_key = KEYS[3]\nlocal job_clients_key = KEYS[4]\nlocal client_running_key = KEYS[5]\nlocal client_num_queued_key = KEYS[6]\nlocal client_last_registered_key = KEYS[7]\nlocal client_last_seen_key = KEYS[8]\n\nlocal now = tonumber(ARGV[1])\nlocal client = ARGV[2]\n\nlocal num_static_argv = 2\n",
      "register.lua": "local index = ARGV[num_static_argv + 1]\nlocal weight = tonumber(ARGV[num_static_argv + 2])\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\n\nlocal state = process_tick(now, false)\nlocal capacity = state['capacity']\nlocal reservoir = state['reservoir']\n\nlocal settings = redis.call('hmget', settings_key,\n  'nextRequest',\n  'minTime',\n  'groupTimeout'\n)\nlocal nextRequest = tonumber(settings[1])\nlocal minTime = tonumber(settings[2])\nlocal groupTimeout = tonumber(settings[3])\n\nif conditions_check(capacity, weight) then\n\n  redis.call('hincrby', settings_key, 'running', weight)\n  redis.call('hset', job_weights_key, index, weight)\n  if expiration ~= nil then\n    redis.call('zadd', job_expirations_key, now + expiration, index)\n  end\n  redis.call('hset', job_clients_key, index, client)\n  redis.call('zincrby', client_running_key, weight, client)\n  redis.call('hincrby', client_num_queued_key, client, -1)\n  redis.call('zadd', client_last_registered_key, now, client)\n\n  local wait = math.max(nextRequest - now, 0)\n  local newNextRequest = now + wait + minTime\n\n  if reservoir == nil then\n    redis.call('hset', settings_key,\n      'nextRequest', newNextRequest\n    )\n  else\n    reservoir = reservoir - weight\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'nextRequest', newNextRequest\n    )\n  end\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\n\n  return {true, wait, reservoir}\n\nelse\n  return {false}\nend\n",
      "register_client.lua": "local queued = tonumber(ARGV[num_static_argv + 1])\n\n-- Could have been re-registered concurrently\nif not redis.call('zscore', client_last_seen_key, client) then\n  redis.call('zadd', client_running_key, 0, client)\n  redis.call('hset', client_num_queued_key, client, queued)\n  redis.call('zadd', client_last_registered_key, 0, client)\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n\nreturn {}\n",
      "running.lua": "return process_tick(now, false)['running']\n",
      "submit.lua": "local queueLength = tonumber(ARGV[num_static_argv + 1])\nlocal weight = tonumber(ARGV[num_static_argv + 2])\n\nlocal capacity = process_tick(now, false)['capacity']\n\nlocal settings = redis.call('hmget', settings_key,\n  'id',\n  'maxConcurrent',\n  'highWater',\n  'nextRequest',\n  'strategy',\n  'unblockTime',\n  'penalty',\n  'minTime',\n  'groupTimeout'\n)\nlocal id = settings[1]\nlocal maxConcurrent = tonumber(settings[2])\nlocal highWater = tonumber(settings[3])\nlocal nextRequest = tonumber(settings[4])\nlocal strategy = tonumber(settings[5])\nlocal unblockTime = tonumber(settings[6])\nlocal penalty = tonumber(settings[7])\nlocal minTime = tonumber(settings[8])\nlocal groupTimeout = tonumber(settings[9])\n\nif maxConcurrent ~= nil and weight > maxConcurrent then\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\nend\n\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\n  and not (\n    conditions_check(capacity, weight)\n    and nextRequest - now <= 0\n  )\n)\n\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\n\nif blocked then\n  local computedPenalty = penalty\n  if computedPenalty == nil then\n    if minTime == 0 then\n      computedPenalty = 5000\n    else\n      computedPenalty = 15 * minTime\n    end\n  end\n\n  local newNextRequest = now + computedPenalty + minTime\n\n  redis.call('hmset', settings_key,\n    'unblockTime', now + computedPenalty,\n    'nextRequest', newNextRequest\n  )\n\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\n  local queued_reset = {}\n  for i = 1, #clients_queued_reset do\n    table.insert(queued_reset, clients_queued_reset[i])\n    table.insert(queued_reset, 0)\n  end\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\n\n  redis.call('publish', 'b_'..id, 'blocked:')\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\nend\n\nif not blocked and not reachedHWM then\n  redis.call('hincrby', client_num_queued_key, client, 1)\nend\n\nreturn {reachedHWM, blocked, strategy}\n",
      "update_settings.lua": "local args = {'hmset', settings_key}\n\nfor i = num_static_argv + 1, #ARGV do\n  table.insert(args, ARGV[i])\nend\n\nredis.call(unpack(args))\n\nprocess_tick(now, true)\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n",
      "validate_client.lua": "if not redis.call('zscore', client_last_seen_key, client) then\n  return redis.error_reply('UNKNOWN_CLIENT')\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n",
      "validate_keys.lua": "if not (redis.call('exists', settings_key) == 1) then\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\nend\n"
    };
  }
});
var require_Scripts = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Scripts.js"(exports2) {
    "use strict";
    var headers;
    var lua;
    var templates;
    lua = require_lua();
    headers = {
      refs: lua["refs.lua"],
      validate_keys: lua["validate_keys.lua"],
      validate_client: lua["validate_client.lua"],
      refresh_expiration: lua["refresh_expiration.lua"],
      process_tick: lua["process_tick.lua"],
      conditions_check: lua["conditions_check.lua"],
      get_time: lua["get_time.lua"]
    };
    exports2.allKeys = function(id) {
      return [
        /*
        HASH
        */
        `b_${id}_settings`,
        /*
        HASH
        job index -> weight
        */
        `b_${id}_job_weights`,
        /*
        ZSET
        job index -> expiration
        */
        `b_${id}_job_expirations`,
        /*
        HASH
        job index -> client
        */
        `b_${id}_job_clients`,
        /*
        ZSET
        client -> sum running
        */
        `b_${id}_client_running`,
        /*
        HASH
        client -> num queued
        */
        `b_${id}_client_num_queued`,
        /*
        ZSET
        client -> last job registered
        */
        `b_${id}_client_last_registered`,
        /*
        ZSET
        client -> last seen
        */
        `b_${id}_client_last_seen`
      ];
    };
    templates = {
      init: {
        keys: exports2.allKeys,
        headers: ["process_tick"],
        refresh_expiration: true,
        code: lua["init.lua"]
      },
      group_check: {
        keys: exports2.allKeys,
        headers: [],
        refresh_expiration: false,
        code: lua["group_check.lua"]
      },
      register_client: {
        keys: exports2.allKeys,
        headers: ["validate_keys"],
        refresh_expiration: false,
        code: lua["register_client.lua"]
      },
      blacklist_client: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client"],
        refresh_expiration: false,
        code: lua["blacklist_client.lua"]
      },
      heartbeat: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick"],
        refresh_expiration: false,
        code: lua["heartbeat.lua"]
      },
      update_settings: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick"],
        refresh_expiration: true,
        code: lua["update_settings.lua"]
      },
      running: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick"],
        refresh_expiration: false,
        code: lua["running.lua"]
      },
      queued: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client"],
        refresh_expiration: false,
        code: lua["queued.lua"]
      },
      done: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick"],
        refresh_expiration: false,
        code: lua["done.lua"]
      },
      check: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick", "conditions_check"],
        refresh_expiration: false,
        code: lua["check.lua"]
      },
      submit: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick", "conditions_check"],
        refresh_expiration: true,
        code: lua["submit.lua"]
      },
      register: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick", "conditions_check"],
        refresh_expiration: true,
        code: lua["register.lua"]
      },
      free: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick"],
        refresh_expiration: true,
        code: lua["free.lua"]
      },
      current_reservoir: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick"],
        refresh_expiration: false,
        code: lua["current_reservoir.lua"]
      },
      increment_reservoir: {
        keys: exports2.allKeys,
        headers: ["validate_keys", "validate_client", "process_tick"],
        refresh_expiration: true,
        code: lua["increment_reservoir.lua"]
      }
    };
    exports2.names = Object.keys(templates);
    exports2.keys = function(name, id) {
      return templates[name].keys(id);
    };
    exports2.payload = function(name) {
      var template;
      template = templates[name];
      return Array.prototype.concat(headers.refs, template.headers.map(function(h2) {
        return headers[h2];
      }), template.refresh_expiration ? headers.refresh_expiration : "", template.code).join("\n");
    };
  }
});
var require_RedisConnection = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/RedisConnection.js"(exports, module) {
    "use strict";
    function asyncGeneratorStep(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events;
    var RedisConnection;
    var Scripts;
    var parser;
    parser = require_parser();
    Events = require_Events();
    Scripts = require_Scripts();
    RedisConnection = function() {
      class RedisConnection {
        constructor(options = {}) {
          parser.load(options, this.defaults, this);
          if (this.Redis == null) {
            this.Redis = eval("require")("redis");
          }
          if (this.Events == null) {
            this.Events = new Events(this);
          }
          this.terminated = false;
          if (this.client == null) {
            this.client = this.Redis.createClient(this.clientOptions);
          }
          this.subscriber = this.client.duplicate();
          this.limiters = {};
          this.shas = {};
          this.ready = this.Promise.all([this._setup(this.client, false), this._setup(this.subscriber, true)]).then(() => {
            return this._loadScripts();
          }).then(() => {
            return {
              client: this.client,
              subscriber: this.subscriber
            };
          });
        }
        _setup(client, sub) {
          client.setMaxListeners(0);
          return new this.Promise((resolve8, reject) => {
            client.on("error", (e2) => {
              return this.Events.trigger("error", e2);
            });
            if (sub) {
              client.on("message", (channel, message) => {
                var ref;
                return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;
              });
            }
            if (client.ready) {
              return resolve8();
            } else {
              return client.once("ready", resolve8);
            }
          });
        }
        _loadScript(name) {
          return new this.Promise((resolve8, reject) => {
            var payload;
            payload = Scripts.payload(name);
            return this.client.multi([["script", "load", payload]]).exec((err, replies) => {
              if (err != null) {
                return reject(err);
              }
              this.shas[name] = replies[0];
              return resolve8(replies[0]);
            });
          });
        }
        _loadScripts() {
          return this.Promise.all(Scripts.names.map((k) => {
            return this._loadScript(k);
          }));
        }
        __runCommand__(cmd) {
          var _this = this;
          return _asyncToGenerator(function* () {
            yield _this.ready;
            return new _this.Promise((resolve8, reject) => {
              return _this.client.multi([cmd]).exec_atomic(function(err, replies) {
                if (err != null) {
                  return reject(err);
                } else {
                  return resolve8(replies[0]);
                }
              });
            });
          })();
        }
        __addLimiter__(instance) {
          return this.Promise.all([instance.channel(), instance.channel_client()].map((channel) => {
            return new this.Promise((resolve8, reject) => {
              var handler;
              handler = (chan) => {
                if (chan === channel) {
                  this.subscriber.removeListener("subscribe", handler);
                  this.limiters[channel] = instance;
                  return resolve8();
                }
              };
              this.subscriber.on("subscribe", handler);
              return this.subscriber.subscribe(channel);
            });
          }));
        }
        __removeLimiter__(instance) {
          var _this2 = this;
          return this.Promise.all([instance.channel(), instance.channel_client()].map(
            /* @__PURE__ */ function() {
              var _ref = _asyncToGenerator(function* (channel) {
                if (!_this2.terminated) {
                  yield new _this2.Promise((resolve8, reject) => {
                    return _this2.subscriber.unsubscribe(channel, function(err, chan) {
                      if (err != null) {
                        return reject(err);
                      }
                      if (chan === channel) {
                        return resolve8();
                      }
                    });
                  });
                }
                return delete _this2.limiters[channel];
              });
              return function(_x) {
                return _ref.apply(this, arguments);
              };
            }()
          ));
        }
        __scriptArgs__(name, id, args, cb) {
          var keys;
          keys = Scripts.keys(name, id);
          return [this.shas[name], keys.length].concat(keys, args, cb);
        }
        __scriptFn__(name) {
          return this.client.evalsha.bind(this.client);
        }
        disconnect(flush = true) {
          var i2, k, len, ref;
          ref = Object.keys(this.limiters);
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            k = ref[i2];
            clearInterval(this.limiters[k]._store.heartbeat);
          }
          this.limiters = {};
          this.terminated = true;
          this.client.end(flush);
          this.subscriber.end(flush);
          return this.Promise.resolve();
        }
      }
      ;
      RedisConnection.prototype.datastore = "redis";
      RedisConnection.prototype.defaults = {
        Redis: null,
        clientOptions: {},
        client: null,
        Promise,
        Events: null
      };
      return RedisConnection;
    }.call(void 0);
    module.exports = RedisConnection;
  }
});
var require_IORedisConnection = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/IORedisConnection.js"(exports, module) {
    "use strict";
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events;
    var IORedisConnection;
    var Scripts;
    var parser;
    parser = require_parser();
    Events = require_Events();
    Scripts = require_Scripts();
    IORedisConnection = function() {
      class IORedisConnection {
        constructor(options = {}) {
          parser.load(options, this.defaults, this);
          if (this.Redis == null) {
            this.Redis = eval("require")("ioredis");
          }
          if (this.Events == null) {
            this.Events = new Events(this);
          }
          this.terminated = false;
          if (this.clusterNodes != null) {
            this.client = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);
            this.subscriber = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);
          } else if (this.client != null && this.client.duplicate == null) {
            this.subscriber = new this.Redis.Cluster(this.client.startupNodes, this.client.options);
          } else {
            if (this.client == null) {
              this.client = new this.Redis(this.clientOptions);
            }
            this.subscriber = this.client.duplicate();
          }
          this.limiters = {};
          this.ready = this.Promise.all([this._setup(this.client, false), this._setup(this.subscriber, true)]).then(() => {
            this._loadScripts();
            return {
              client: this.client,
              subscriber: this.subscriber
            };
          });
        }
        _setup(client, sub) {
          client.setMaxListeners(0);
          return new this.Promise((resolve8, reject) => {
            client.on("error", (e2) => {
              return this.Events.trigger("error", e2);
            });
            if (sub) {
              client.on("message", (channel, message) => {
                var ref;
                return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;
              });
            }
            if (client.status === "ready") {
              return resolve8();
            } else {
              return client.once("ready", resolve8);
            }
          });
        }
        _loadScripts() {
          return Scripts.names.forEach((name) => {
            return this.client.defineCommand(name, {
              lua: Scripts.payload(name)
            });
          });
        }
        __runCommand__(cmd) {
          var _this = this;
          return _asyncToGenerator(function* () {
            var _, deleted;
            yield _this.ready;
            var _ref = yield _this.client.pipeline([cmd]).exec();
            var _ref2 = _slicedToArray(_ref, 1);
            var _ref2$ = _slicedToArray(_ref2[0], 2);
            _ = _ref2$[0];
            deleted = _ref2$[1];
            return deleted;
          })();
        }
        __addLimiter__(instance) {
          return this.Promise.all([instance.channel(), instance.channel_client()].map((channel) => {
            return new this.Promise((resolve8, reject) => {
              return this.subscriber.subscribe(channel, () => {
                this.limiters[channel] = instance;
                return resolve8();
              });
            });
          }));
        }
        __removeLimiter__(instance) {
          var _this2 = this;
          return [instance.channel(), instance.channel_client()].forEach(
            /* @__PURE__ */ function() {
              var _ref3 = _asyncToGenerator(function* (channel) {
                if (!_this2.terminated) {
                  yield _this2.subscriber.unsubscribe(channel);
                }
                return delete _this2.limiters[channel];
              });
              return function(_x) {
                return _ref3.apply(this, arguments);
              };
            }()
          );
        }
        __scriptArgs__(name, id, args, cb) {
          var keys;
          keys = Scripts.keys(name, id);
          return [keys.length].concat(keys, args, cb);
        }
        __scriptFn__(name) {
          return this.client[name].bind(this.client);
        }
        disconnect(flush = true) {
          var i2, k, len, ref;
          ref = Object.keys(this.limiters);
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            k = ref[i2];
            clearInterval(this.limiters[k]._store.heartbeat);
          }
          this.limiters = {};
          this.terminated = true;
          if (flush) {
            return this.Promise.all([this.client.quit(), this.subscriber.quit()]);
          } else {
            this.client.disconnect();
            this.subscriber.disconnect();
            return this.Promise.resolve();
          }
        }
      }
      ;
      IORedisConnection.prototype.datastore = "ioredis";
      IORedisConnection.prototype.defaults = {
        Redis: null,
        clientOptions: {},
        clusterNodes: null,
        client: null,
        Promise,
        Events: null
      };
      return IORedisConnection;
    }.call(void 0);
    module.exports = IORedisConnection;
  }
});
var require_RedisDatastore = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/RedisDatastore.js"(exports2, module2) {
    "use strict";
    function _slicedToArray2(arr, i2) {
      return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _nonIterableRest2();
    }
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit2(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var BottleneckError;
    var IORedisConnection2;
    var RedisConnection2;
    var RedisDatastore;
    var parser2;
    parser2 = require_parser();
    BottleneckError = require_BottleneckError();
    RedisConnection2 = require_RedisConnection();
    IORedisConnection2 = require_IORedisConnection();
    RedisDatastore = class RedisDatastore {
      constructor(instance, storeOptions, storeInstanceOptions) {
        this.instance = instance;
        this.storeOptions = storeOptions;
        this.originalId = this.instance.id;
        this.clientId = this.instance._randomIndex();
        parser2.load(storeInstanceOptions, storeInstanceOptions, this);
        this.clients = {};
        this.capacityPriorityCounters = {};
        this.sharedConnection = this.connection != null;
        if (this.connection == null) {
          this.connection = this.instance.datastore === "redis" ? new RedisConnection2({
            Redis: this.Redis,
            clientOptions: this.clientOptions,
            Promise: this.Promise,
            Events: this.instance.Events
          }) : this.instance.datastore === "ioredis" ? new IORedisConnection2({
            Redis: this.Redis,
            clientOptions: this.clientOptions,
            clusterNodes: this.clusterNodes,
            Promise: this.Promise,
            Events: this.instance.Events
          }) : void 0;
        }
        this.instance.connection = this.connection;
        this.instance.datastore = this.connection.datastore;
        this.ready = this.connection.ready.then((clients) => {
          this.clients = clients;
          return this.runScript("init", this.prepareInitSettings(this.clearDatastore));
        }).then(() => {
          return this.connection.__addLimiter__(this.instance);
        }).then(() => {
          return this.runScript("register_client", [this.instance.queued()]);
        }).then(() => {
          var base4;
          if (typeof (base4 = this.heartbeat = setInterval(() => {
            return this.runScript("heartbeat", []).catch((e2) => {
              return this.instance.Events.trigger("error", e2);
            });
          }, this.heartbeatInterval)).unref === "function") {
            base4.unref();
          }
          return this.clients;
        });
      }
      __publish__(message) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var client;
          var _ref = yield _this.ready;
          client = _ref.client;
          return client.publish(_this.instance.channel(), `message:${message.toString()}`);
        })();
      }
      onMessage(channel, message) {
        var _this2 = this;
        return _asyncToGenerator2(function* () {
          var capacity, counter, data, drained, e2, newCapacity, pos, priorityClient, rawCapacity, type;
          try {
            pos = message.indexOf(":");
            var _ref2 = [message.slice(0, pos), message.slice(pos + 1)];
            type = _ref2[0];
            data = _ref2[1];
            if (type === "capacity") {
              return yield _this2.instance._drainAll(data.length > 0 ? ~~data : void 0);
            } else if (type === "capacity-priority") {
              var _data$split = data.split(":");
              var _data$split2 = _slicedToArray2(_data$split, 3);
              rawCapacity = _data$split2[0];
              priorityClient = _data$split2[1];
              counter = _data$split2[2];
              capacity = rawCapacity.length > 0 ? ~~rawCapacity : void 0;
              if (priorityClient === _this2.clientId) {
                drained = yield _this2.instance._drainAll(capacity);
                newCapacity = capacity != null ? capacity - (drained || 0) : "";
                return yield _this2.clients.client.publish(_this2.instance.channel(), `capacity-priority:${newCapacity}::${counter}`);
              } else if (priorityClient === "") {
                clearTimeout(_this2.capacityPriorityCounters[counter]);
                delete _this2.capacityPriorityCounters[counter];
                return _this2.instance._drainAll(capacity);
              } else {
                return _this2.capacityPriorityCounters[counter] = setTimeout(
                  /* @__PURE__ */ _asyncToGenerator2(function* () {
                    var e3;
                    try {
                      delete _this2.capacityPriorityCounters[counter];
                      yield _this2.runScript("blacklist_client", [priorityClient]);
                      return yield _this2.instance._drainAll(capacity);
                    } catch (error) {
                      e3 = error;
                      return _this2.instance.Events.trigger("error", e3);
                    }
                  }),
                  1e3
                );
              }
            } else if (type === "message") {
              return _this2.instance.Events.trigger("message", data);
            } else if (type === "blocked") {
              return yield _this2.instance._dropAllQueued();
            }
          } catch (error) {
            e2 = error;
            return _this2.instance.Events.trigger("error", e2);
          }
        })();
      }
      __disconnect__(flush) {
        clearInterval(this.heartbeat);
        if (this.sharedConnection) {
          return this.connection.__removeLimiter__(this.instance);
        } else {
          return this.connection.disconnect(flush);
        }
      }
      runScript(name, args) {
        var _this3 = this;
        return _asyncToGenerator2(function* () {
          if (!(name === "init" || name === "register_client")) {
            yield _this3.ready;
          }
          return new _this3.Promise((resolve8, reject) => {
            var all_args, arr;
            all_args = [Date.now(), _this3.clientId].concat(args);
            _this3.instance.Events.trigger("debug", `Calling Redis script: ${name}.lua`, all_args);
            arr = _this3.connection.__scriptArgs__(name, _this3.originalId, all_args, function(err, replies) {
              if (err != null) {
                return reject(err);
              }
              return resolve8(replies);
            });
            return _this3.connection.__scriptFn__(name)(...arr);
          }).catch((e2) => {
            if (e2.message === "SETTINGS_KEY_NOT_FOUND") {
              if (name === "heartbeat") {
                return _this3.Promise.resolve();
              } else {
                return _this3.runScript("init", _this3.prepareInitSettings(false)).then(() => {
                  return _this3.runScript(name, args);
                });
              }
            } else if (e2.message === "UNKNOWN_CLIENT") {
              return _this3.runScript("register_client", [_this3.instance.queued()]).then(() => {
                return _this3.runScript(name, args);
              });
            } else {
              return _this3.Promise.reject(e2);
            }
          });
        })();
      }
      prepareArray(arr) {
        var i2, len, results, x3;
        results = [];
        for (i2 = 0, len = arr.length; i2 < len; i2++) {
          x3 = arr[i2];
          results.push(x3 != null ? x3.toString() : "");
        }
        return results;
      }
      prepareObject(obj) {
        var arr, k, v2;
        arr = [];
        for (k in obj) {
          v2 = obj[k];
          arr.push(k, v2 != null ? v2.toString() : "");
        }
        return arr;
      }
      prepareInitSettings(clear2) {
        var args;
        args = this.prepareObject(Object.assign({}, this.storeOptions, {
          id: this.originalId,
          version: this.instance.version,
          groupTimeout: this.timeout,
          clientTimeout: this.clientTimeout
        }));
        args.unshift(clear2 ? 1 : 0, this.instance.version);
        return args;
      }
      convertBool(b) {
        return !!b;
      }
      __updateSettings__(options3) {
        var _this4 = this;
        return _asyncToGenerator2(function* () {
          yield _this4.runScript("update_settings", _this4.prepareObject(options3));
          return parser2.overwrite(options3, options3, _this4.storeOptions);
        })();
      }
      __running__() {
        return this.runScript("running", []);
      }
      __queued__() {
        return this.runScript("queued", []);
      }
      __done__() {
        return this.runScript("done", []);
      }
      __groupCheck__() {
        var _this5 = this;
        return _asyncToGenerator2(function* () {
          return _this5.convertBool(yield _this5.runScript("group_check", []));
        })();
      }
      __incrementReservoir__(incr) {
        return this.runScript("increment_reservoir", [incr]);
      }
      __currentReservoir__() {
        return this.runScript("current_reservoir", []);
      }
      __check__(weight) {
        var _this6 = this;
        return _asyncToGenerator2(function* () {
          return _this6.convertBool(yield _this6.runScript("check", _this6.prepareArray([weight])));
        })();
      }
      __register__(index, weight, expiration) {
        var _this7 = this;
        return _asyncToGenerator2(function* () {
          var reservoir, success, wait;
          var _ref4 = yield _this7.runScript("register", _this7.prepareArray([index, weight, expiration]));
          var _ref5 = _slicedToArray2(_ref4, 3);
          success = _ref5[0];
          wait = _ref5[1];
          reservoir = _ref5[2];
          return {
            success: _this7.convertBool(success),
            wait,
            reservoir
          };
        })();
      }
      __submit__(queueLength, weight) {
        var _this8 = this;
        return _asyncToGenerator2(function* () {
          var blocked, e2, maxConcurrent, overweight, reachedHWM, strategy;
          try {
            var _ref6 = yield _this8.runScript("submit", _this8.prepareArray([queueLength, weight]));
            var _ref7 = _slicedToArray2(_ref6, 3);
            reachedHWM = _ref7[0];
            blocked = _ref7[1];
            strategy = _ref7[2];
            return {
              reachedHWM: _this8.convertBool(reachedHWM),
              blocked: _this8.convertBool(blocked),
              strategy
            };
          } catch (error) {
            e2 = error;
            if (e2.message.indexOf("OVERWEIGHT") === 0) {
              var _e$message$split = e2.message.split(":");
              var _e$message$split2 = _slicedToArray2(_e$message$split, 3);
              overweight = _e$message$split2[0];
              weight = _e$message$split2[1];
              maxConcurrent = _e$message$split2[2];
              throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${maxConcurrent}`);
            } else {
              throw e2;
            }
          }
        })();
      }
      __free__(index, weight) {
        var _this9 = this;
        return _asyncToGenerator2(function* () {
          var running;
          running = yield _this9.runScript("free", _this9.prepareArray([index]));
          return {
            running
          };
        })();
      }
    };
    module2.exports = RedisDatastore;
  }
});
var require_States = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/States.js"(exports2, module2) {
    "use strict";
    var BottleneckError;
    var States;
    BottleneckError = require_BottleneckError();
    States = class States {
      constructor(status1) {
        this.status = status1;
        this._jobs = {};
        this.counts = this.status.map(function() {
          return 0;
        });
      }
      next(id) {
        var current, next;
        current = this._jobs[id];
        next = current + 1;
        if (current != null && next < this.status.length) {
          this.counts[current]--;
          this.counts[next]++;
          return this._jobs[id]++;
        } else if (current != null) {
          this.counts[current]--;
          return delete this._jobs[id];
        }
      }
      start(id) {
        var initial;
        initial = 0;
        this._jobs[id] = initial;
        return this.counts[initial]++;
      }
      remove(id) {
        var current;
        current = this._jobs[id];
        if (current != null) {
          this.counts[current]--;
          delete this._jobs[id];
        }
        return current != null;
      }
      jobStatus(id) {
        var ref;
        return (ref = this.status[this._jobs[id]]) != null ? ref : null;
      }
      statusJobs(status) {
        var k, pos, ref, results, v2;
        if (status != null) {
          pos = this.status.indexOf(status);
          if (pos < 0) {
            throw new BottleneckError(`status must be one of ${this.status.join(", ")}`);
          }
          ref = this._jobs;
          results = [];
          for (k in ref) {
            v2 = ref[k];
            if (v2 === pos) {
              results.push(k);
            }
          }
          return results;
        } else {
          return Object.keys(this._jobs);
        }
      }
      statusCounts() {
        return this.counts.reduce((acc, v2, i2) => {
          acc[this.status[i2]] = v2;
          return acc;
        }, {});
      }
    };
    module2.exports = States;
  }
});
var require_Sync = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Sync.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var DLList;
    var Sync;
    DLList = require_DLList();
    Sync = class Sync {
      constructor(name, Promise2) {
        this.schedule = this.schedule.bind(this);
        this.name = name;
        this.Promise = Promise2;
        this._running = 0;
        this._queue = new DLList();
      }
      isEmpty() {
        return this._queue.length === 0;
      }
      _tryToRun() {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var args, cb, error, reject, resolve8, returned, task;
          if (_this._running < 1 && _this._queue.length > 0) {
            _this._running++;
            var _this$_queue$shift = _this._queue.shift();
            task = _this$_queue$shift.task;
            args = _this$_queue$shift.args;
            resolve8 = _this$_queue$shift.resolve;
            reject = _this$_queue$shift.reject;
            cb = yield _asyncToGenerator2(function* () {
              try {
                returned = yield task(...args);
                return function() {
                  return resolve8(returned);
                };
              } catch (error1) {
                error = error1;
                return function() {
                  return reject(error);
                };
              }
            })();
            _this._running--;
            _this._tryToRun();
            return cb();
          }
        })();
      }
      schedule(task, ...args) {
        var promise, reject, resolve8;
        resolve8 = reject = null;
        promise = new this.Promise(function(_resolve, _reject) {
          resolve8 = _resolve;
          return reject = _reject;
        });
        this._queue.push({
          task,
          args,
          resolve: resolve8,
          reject
        });
        this._tryToRun();
        return promise;
      }
    };
    module2.exports = Sync;
  }
});
var require_version = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/version.json"(exports2, module2) {
    module2.exports = { version: "2.19.5" };
  }
});
var require_Group = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Group.js"(exports2, module2) {
    "use strict";
    function _slicedToArray2(arr, i2) {
      return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _nonIterableRest2();
    }
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit2(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events2;
    var Group;
    var IORedisConnection2;
    var RedisConnection2;
    var Scripts2;
    var parser2;
    parser2 = require_parser();
    Events2 = require_Events();
    RedisConnection2 = require_RedisConnection();
    IORedisConnection2 = require_IORedisConnection();
    Scripts2 = require_Scripts();
    Group = function() {
      class Group2 {
        constructor(limiterOptions = {}) {
          this.deleteKey = this.deleteKey.bind(this);
          this.limiterOptions = limiterOptions;
          parser2.load(this.limiterOptions, this.defaults, this);
          this.Events = new Events2(this);
          this.instances = {};
          this.Bottleneck = require_Bottleneck();
          this._startAutoCleanup();
          this.sharedConnection = this.connection != null;
          if (this.connection == null) {
            if (this.limiterOptions.datastore === "redis") {
              this.connection = new RedisConnection2(Object.assign({}, this.limiterOptions, {
                Events: this.Events
              }));
            } else if (this.limiterOptions.datastore === "ioredis") {
              this.connection = new IORedisConnection2(Object.assign({}, this.limiterOptions, {
                Events: this.Events
              }));
            }
          }
        }
        key(key = "") {
          var ref;
          return (ref = this.instances[key]) != null ? ref : (() => {
            var limiter;
            limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
              id: `${this.id}-${key}`,
              timeout: this.timeout,
              connection: this.connection
            }));
            this.Events.trigger("created", limiter, key);
            return limiter;
          })();
        }
        deleteKey(key = "") {
          var _this = this;
          return _asyncToGenerator2(function* () {
            var deleted, instance;
            instance = _this.instances[key];
            if (_this.connection) {
              deleted = yield _this.connection.__runCommand__(["del", ...Scripts2.allKeys(`${_this.id}-${key}`)]);
            }
            if (instance != null) {
              delete _this.instances[key];
              yield instance.disconnect();
            }
            return instance != null || deleted > 0;
          })();
        }
        limiters() {
          var k, ref, results, v2;
          ref = this.instances;
          results = [];
          for (k in ref) {
            v2 = ref[k];
            results.push({
              key: k,
              limiter: v2
            });
          }
          return results;
        }
        keys() {
          return Object.keys(this.instances);
        }
        clusterKeys() {
          var _this2 = this;
          return _asyncToGenerator2(function* () {
            var cursor, end, found, i2, k, keys, len, next, start;
            if (_this2.connection == null) {
              return _this2.Promise.resolve(_this2.keys());
            }
            keys = [];
            cursor = null;
            start = `b_${_this2.id}-`.length;
            end = "_settings".length;
            while (cursor !== 0) {
              var _ref = yield _this2.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${_this2.id}-*_settings`, "count", 1e4]);
              var _ref2 = _slicedToArray2(_ref, 2);
              next = _ref2[0];
              found = _ref2[1];
              cursor = ~~next;
              for (i2 = 0, len = found.length; i2 < len; i2++) {
                k = found[i2];
                keys.push(k.slice(start, -end));
              }
            }
            return keys;
          })();
        }
        _startAutoCleanup() {
          var _this3 = this;
          var base4;
          clearInterval(this.interval);
          return typeof (base4 = this.interval = setInterval(
            /* @__PURE__ */ _asyncToGenerator2(function* () {
              var e2, k, ref, results, time3, v2;
              time3 = Date.now();
              ref = _this3.instances;
              results = [];
              for (k in ref) {
                v2 = ref[k];
                try {
                  if (yield v2._store.__groupCheck__(time3)) {
                    results.push(_this3.deleteKey(k));
                  } else {
                    results.push(void 0);
                  }
                } catch (error) {
                  e2 = error;
                  results.push(v2.Events.trigger("error", e2));
                }
              }
              return results;
            }),
            this.timeout / 2
          )).unref === "function" ? base4.unref() : void 0;
        }
        updateSettings(options3 = {}) {
          parser2.overwrite(options3, this.defaults, this);
          parser2.overwrite(options3, options3, this.limiterOptions);
          if (options3.timeout != null) {
            return this._startAutoCleanup();
          }
        }
        disconnect(flush = true) {
          var ref;
          if (!this.sharedConnection) {
            return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
          }
        }
      }
      ;
      Group2.prototype.defaults = {
        timeout: 1e3 * 60 * 5,
        connection: null,
        Promise,
        id: "group-key"
      };
      return Group2;
    }.call(void 0);
    module2.exports = Group;
  }
});
var require_Batcher = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Batcher.js"(exports2, module2) {
    "use strict";
    var Batcher;
    var Events2;
    var parser2;
    parser2 = require_parser();
    Events2 = require_Events();
    Batcher = function() {
      class Batcher2 {
        constructor(options3 = {}) {
          this.options = options3;
          parser2.load(this.options, this.defaults, this);
          this.Events = new Events2(this);
          this._arr = [];
          this._resetPromise();
          this._lastFlush = Date.now();
        }
        _resetPromise() {
          return this._promise = new this.Promise((res, rej) => {
            return this._resolve = res;
          });
        }
        _flush() {
          clearTimeout(this._timeout);
          this._lastFlush = Date.now();
          this._resolve();
          this.Events.trigger("batch", this._arr);
          this._arr = [];
          return this._resetPromise();
        }
        add(data) {
          var ret;
          this._arr.push(data);
          ret = this._promise;
          if (this._arr.length === this.maxSize) {
            this._flush();
          } else if (this.maxTime != null && this._arr.length === 1) {
            this._timeout = setTimeout(() => {
              return this._flush();
            }, this.maxTime);
          }
          return ret;
        }
      }
      ;
      Batcher2.prototype.defaults = {
        maxTime: null,
        maxSize: null,
        Promise
      };
      return Batcher2;
    }.call(void 0);
    module2.exports = Batcher;
  }
});
var require_Bottleneck = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Bottleneck.js"(exports2, module2) {
    "use strict";
    function _slicedToArray2(arr, i2) {
      return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _nonIterableRest2();
    }
    function _iterableToArrayLimit2(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _toArray(arr) {
      return _arrayWithHoles2(arr) || _iterableToArray(arr) || _nonIterableRest2();
    }
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve8(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve8, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve8, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Bottleneck2;
    var DEFAULT_PRIORITY;
    var Events2;
    var Job;
    var LocalDatastore;
    var NUM_PRIORITIES;
    var Queues;
    var RedisDatastore;
    var States;
    var Sync;
    var parser2;
    var splice = [].splice;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser2 = require_parser();
    Queues = require_Queues();
    Job = require_Job();
    LocalDatastore = require_LocalDatastore();
    RedisDatastore = require_RedisDatastore();
    Events2 = require_Events();
    States = require_States();
    Sync = require_Sync();
    Bottleneck2 = function() {
      class Bottleneck3 {
        constructor(options3 = {}, ...invalid) {
          var storeInstanceOptions, storeOptions;
          this._addToQueue = this._addToQueue.bind(this);
          this._validateOptions(options3, invalid);
          parser2.load(options3, this.instanceDefaults, this);
          this._queues = new Queues(NUM_PRIORITIES);
          this._scheduled = {};
          this._states = new States(["RECEIVED", "QUEUED", "RUNNING", "EXECUTING"].concat(this.trackDoneStatus ? ["DONE"] : []));
          this._limiter = null;
          this.Events = new Events2(this);
          this._submitLock = new Sync("submit", this.Promise);
          this._registerLock = new Sync("register", this.Promise);
          storeOptions = parser2.load(options3, this.storeDefaults, {});
          this._store = function() {
            if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
              storeInstanceOptions = parser2.load(options3, this.redisStoreDefaults, {});
              return new RedisDatastore(this, storeOptions, storeInstanceOptions);
            } else if (this.datastore === "local") {
              storeInstanceOptions = parser2.load(options3, this.localStoreDefaults, {});
              return new LocalDatastore(this, storeOptions, storeInstanceOptions);
            } else {
              throw new Bottleneck3.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
            }
          }.call(this);
          this._queues.on("leftzero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
          });
          this._queues.on("zero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
          });
        }
        _validateOptions(options3, invalid) {
          if (!(options3 != null && typeof options3 === "object" && invalid.length === 0)) {
            throw new Bottleneck3.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
          }
        }
        ready() {
          return this._store.ready;
        }
        clients() {
          return this._store.clients;
        }
        channel() {
          return `b_${this.id}`;
        }
        channel_client() {
          return `b_${this.id}_${this._store.clientId}`;
        }
        publish(message) {
          return this._store.__publish__(message);
        }
        disconnect(flush = true) {
          return this._store.__disconnect__(flush);
        }
        chain(_limiter) {
          this._limiter = _limiter;
          return this;
        }
        queued(priority) {
          return this._queues.queued(priority);
        }
        clusterQueued() {
          return this._store.__queued__();
        }
        empty() {
          return this.queued() === 0 && this._submitLock.isEmpty();
        }
        running() {
          return this._store.__running__();
        }
        done() {
          return this._store.__done__();
        }
        jobStatus(id) {
          return this._states.jobStatus(id);
        }
        jobs(status) {
          return this._states.statusJobs(status);
        }
        counts() {
          return this._states.statusCounts();
        }
        _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
        check(weight = 1) {
          return this._store.__check__(weight);
        }
        _clearGlobalState(index) {
          if (this._scheduled[index] != null) {
            clearTimeout(this._scheduled[index].expiration);
            delete this._scheduled[index];
            return true;
          } else {
            return false;
          }
        }
        _free(index, job, options3, eventInfo) {
          var _this = this;
          return _asyncToGenerator2(function* () {
            var e2, running;
            try {
              var _ref = yield _this._store.__free__(index, options3.weight);
              running = _ref.running;
              _this.Events.trigger("debug", `Freed ${options3.id}`, eventInfo);
              if (running === 0 && _this.empty()) {
                return _this.Events.trigger("idle");
              }
            } catch (error1) {
              e2 = error1;
              return _this.Events.trigger("error", e2);
            }
          })();
        }
        _run(index, job, wait) {
          var clearGlobalState, free, run2;
          job.doRun();
          clearGlobalState = this._clearGlobalState.bind(this, index);
          run2 = this._run.bind(this, index, job);
          free = this._free.bind(this, index, job);
          return this._scheduled[index] = {
            timeout: setTimeout(() => {
              return job.doExecute(this._limiter, clearGlobalState, run2, free);
            }, wait),
            expiration: job.options.expiration != null ? setTimeout(function() {
              return job.doExpire(clearGlobalState, run2, free);
            }, wait + job.options.expiration) : void 0,
            job
          };
        }
        _drainOne(capacity) {
          return this._registerLock.schedule(() => {
            var args, index, next, options3, queue;
            if (this.queued() === 0) {
              return this.Promise.resolve(null);
            }
            queue = this._queues.getFirst();
            var _next2 = next = queue.first();
            options3 = _next2.options;
            args = _next2.args;
            if (capacity != null && options3.weight > capacity) {
              return this.Promise.resolve(null);
            }
            this.Events.trigger("debug", `Draining ${options3.id}`, {
              args,
              options: options3
            });
            index = this._randomIndex();
            return this._store.__register__(index, options3.weight, options3.expiration).then(({
              success,
              wait,
              reservoir
            }) => {
              var empty4;
              this.Events.trigger("debug", `Drained ${options3.id}`, {
                success,
                args,
                options: options3
              });
              if (success) {
                queue.shift();
                empty4 = this.empty();
                if (empty4) {
                  this.Events.trigger("empty");
                }
                if (reservoir === 0) {
                  this.Events.trigger("depleted", empty4);
                }
                this._run(index, next, wait);
                return this.Promise.resolve(options3.weight);
              } else {
                return this.Promise.resolve(null);
              }
            });
          });
        }
        _drainAll(capacity, total = 0) {
          return this._drainOne(capacity).then((drained) => {
            var newCapacity;
            if (drained != null) {
              newCapacity = capacity != null ? capacity - drained : capacity;
              return this._drainAll(newCapacity, total + drained);
            } else {
              return this.Promise.resolve(total);
            }
          }).catch((e2) => {
            return this.Events.trigger("error", e2);
          });
        }
        _dropAllQueued(message) {
          return this._queues.shiftAll(function(job) {
            return job.doDrop({
              message
            });
          });
        }
        stop(options3 = {}) {
          var done, waitForExecuting;
          options3 = parser2.load(options3, this.stopDefaults);
          waitForExecuting = (at) => {
            var finished;
            finished = () => {
              var counts;
              counts = this._states.counts;
              return counts[0] + counts[1] + counts[2] + counts[3] === at;
            };
            return new this.Promise((resolve8, reject) => {
              if (finished()) {
                return resolve8();
              } else {
                return this.on("done", () => {
                  if (finished()) {
                    this.removeAllListeners("done");
                    return resolve8();
                  }
                });
              }
            });
          };
          done = options3.dropWaitingJobs ? (this._run = function(index, next) {
            return next.doDrop({
              message: options3.dropErrorMessage
            });
          }, this._drainOne = () => {
            return this.Promise.resolve(null);
          }, this._registerLock.schedule(() => {
            return this._submitLock.schedule(() => {
              var k, ref, v2;
              ref = this._scheduled;
              for (k in ref) {
                v2 = ref[k];
                if (this.jobStatus(v2.job.options.id) === "RUNNING") {
                  clearTimeout(v2.timeout);
                  clearTimeout(v2.expiration);
                  v2.job.doDrop({
                    message: options3.dropErrorMessage
                  });
                }
              }
              this._dropAllQueued(options3.dropErrorMessage);
              return waitForExecuting(0);
            });
          })) : this.schedule({
            priority: NUM_PRIORITIES - 1,
            weight: 0
          }, () => {
            return waitForExecuting(1);
          });
          this._receive = function(job) {
            return job._reject(new Bottleneck3.prototype.BottleneckError(options3.enqueueErrorMessage));
          };
          this.stop = () => {
            return this.Promise.reject(new Bottleneck3.prototype.BottleneckError("stop() has already been called"));
          };
          return done;
        }
        _addToQueue(job) {
          var _this2 = this;
          return _asyncToGenerator2(function* () {
            var args, blocked, error, options3, reachedHWM, shifted, strategy;
            args = job.args;
            options3 = job.options;
            try {
              var _ref2 = yield _this2._store.__submit__(_this2.queued(), options3.weight);
              reachedHWM = _ref2.reachedHWM;
              blocked = _ref2.blocked;
              strategy = _ref2.strategy;
            } catch (error1) {
              error = error1;
              _this2.Events.trigger("debug", `Could not queue ${options3.id}`, {
                args,
                options: options3,
                error
              });
              job.doDrop({
                error
              });
              return false;
            }
            if (blocked) {
              job.doDrop();
              return true;
            } else if (reachedHWM) {
              shifted = strategy === Bottleneck3.prototype.strategy.LEAK ? _this2._queues.shiftLastFrom(options3.priority) : strategy === Bottleneck3.prototype.strategy.OVERFLOW_PRIORITY ? _this2._queues.shiftLastFrom(options3.priority + 1) : strategy === Bottleneck3.prototype.strategy.OVERFLOW ? job : void 0;
              if (shifted != null) {
                shifted.doDrop();
              }
              if (shifted == null || strategy === Bottleneck3.prototype.strategy.OVERFLOW) {
                if (shifted == null) {
                  job.doDrop();
                }
                return reachedHWM;
              }
            }
            job.doQueue(reachedHWM, blocked);
            _this2._queues.push(job);
            yield _this2._drainAll();
            return reachedHWM;
          })();
        }
        _receive(job) {
          if (this._states.jobStatus(job.options.id) != null) {
            job._reject(new Bottleneck3.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
            return false;
          } else {
            job.doReceive();
            return this._submitLock.schedule(this._addToQueue, job);
          }
        }
        submit(...args) {
          var cb, fn, job, options3, ref, ref1, task;
          if (typeof args[0] === "function") {
            var _ref3, _ref4, _splice$call, _splice$call2;
            ref = args, _ref3 = ref, _ref4 = _toArray(_ref3), fn = _ref4[0], args = _ref4.slice(1), _ref3, _splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray2(_splice$call, 1), cb = _splice$call2[0], _splice$call;
            options3 = parser2.load({}, this.jobDefaults);
          } else {
            var _ref5, _ref6, _splice$call3, _splice$call4;
            ref1 = args, _ref5 = ref1, _ref6 = _toArray(_ref5), options3 = _ref6[0], fn = _ref6[1], args = _ref6.slice(2), _ref5, _splice$call3 = splice.call(args, -1), _splice$call4 = _slicedToArray2(_splice$call3, 1), cb = _splice$call4[0], _splice$call3;
            options3 = parser2.load(options3, this.jobDefaults);
          }
          task = (...args2) => {
            return new this.Promise(function(resolve8, reject) {
              return fn(...args2, function(...args3) {
                return (args3[0] != null ? reject : resolve8)(args3);
              });
            });
          };
          job = new Job(task, args, options3, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          job.promise.then(function(args2) {
            return typeof cb === "function" ? cb(...args2) : void 0;
          }).catch(function(args2) {
            if (Array.isArray(args2)) {
              return typeof cb === "function" ? cb(...args2) : void 0;
            } else {
              return typeof cb === "function" ? cb(args2) : void 0;
            }
          });
          return this._receive(job);
        }
        schedule(...args) {
          var job, options3, task;
          if (typeof args[0] === "function") {
            var _args = args;
            var _args2 = _toArray(_args);
            task = _args2[0];
            args = _args2.slice(1);
            options3 = {};
          } else {
            var _args3 = args;
            var _args4 = _toArray(_args3);
            options3 = _args4[0];
            task = _args4[1];
            args = _args4.slice(2);
          }
          job = new Job(task, args, options3, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          this._receive(job);
          return job.promise;
        }
        wrap(fn) {
          var schedule, wrapped;
          schedule = this.schedule.bind(this);
          wrapped = function wrapped2(...args) {
            return schedule(fn.bind(this), ...args);
          };
          wrapped.withOptions = function(options3, ...args) {
            return schedule(options3, fn, ...args);
          };
          return wrapped;
        }
        updateSettings(options3 = {}) {
          var _this3 = this;
          return _asyncToGenerator2(function* () {
            yield _this3._store.__updateSettings__(parser2.overwrite(options3, _this3.storeDefaults));
            parser2.overwrite(options3, _this3.instanceDefaults, _this3);
            return _this3;
          })();
        }
        currentReservoir() {
          return this._store.__currentReservoir__();
        }
        incrementReservoir(incr = 0) {
          return this._store.__incrementReservoir__(incr);
        }
      }
      ;
      Bottleneck3.default = Bottleneck3;
      Bottleneck3.Events = Events2;
      Bottleneck3.version = Bottleneck3.prototype.version = require_version().version;
      Bottleneck3.strategy = Bottleneck3.prototype.strategy = {
        LEAK: 1,
        OVERFLOW: 2,
        OVERFLOW_PRIORITY: 4,
        BLOCK: 3
      };
      Bottleneck3.BottleneckError = Bottleneck3.prototype.BottleneckError = require_BottleneckError();
      Bottleneck3.Group = Bottleneck3.prototype.Group = require_Group();
      Bottleneck3.RedisConnection = Bottleneck3.prototype.RedisConnection = require_RedisConnection();
      Bottleneck3.IORedisConnection = Bottleneck3.prototype.IORedisConnection = require_IORedisConnection();
      Bottleneck3.Batcher = Bottleneck3.prototype.Batcher = require_Batcher();
      Bottleneck3.prototype.jobDefaults = {
        priority: DEFAULT_PRIORITY,
        weight: 1,
        expiration: null,
        id: "<no-id>"
      };
      Bottleneck3.prototype.storeDefaults = {
        maxConcurrent: null,
        minTime: 0,
        highWater: null,
        strategy: Bottleneck3.prototype.strategy.LEAK,
        penalty: null,
        reservoir: null,
        reservoirRefreshInterval: null,
        reservoirRefreshAmount: null,
        reservoirIncreaseInterval: null,
        reservoirIncreaseAmount: null,
        reservoirIncreaseMaximum: null
      };
      Bottleneck3.prototype.localStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 250
      };
      Bottleneck3.prototype.redisStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 5e3,
        clientTimeout: 1e4,
        Redis: null,
        clientOptions: {},
        clusterNodes: null,
        clearDatastore: false,
        connection: null
      };
      Bottleneck3.prototype.instanceDefaults = {
        datastore: "local",
        connection: null,
        id: "<no-id>",
        rejectOnDrop: true,
        trackDoneStatus: false,
        Promise
      };
      Bottleneck3.prototype.stopDefaults = {
        enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
        dropWaitingJobs: true,
        dropErrorMessage: "This limiter has been stopped."
      };
      return Bottleneck3;
    }.call(void 0);
    module2.exports = Bottleneck2;
  }
});
var require_lib31 = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_Bottleneck();
  }
});
var require_package5 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/package.json"(exports2, module2) {
    module2.exports = {
      name: "joi",
      description: "Object schema validation",
      version: "18.0.1",
      repository: {
        url: "git://github.com/hapijs/joi",
        type: "git"
      },
      engines: {
        node: ">= 20"
      },
      main: "lib/index.js",
      types: "lib/index.d.ts",
      browser: "dist/joi-browser.min.js",
      files: [
        "lib/**/*",
        "dist/*"
      ],
      keywords: [
        "schema",
        "validation"
      ],
      dependencies: {
        "@hapi/address": "^5.1.1",
        "@hapi/formula": "^3.0.2",
        "@hapi/hoek": "^11.0.7",
        "@hapi/pinpoint": "^2.0.1",
        "@hapi/tlds": "^1.1.1",
        "@hapi/topo": "^6.0.2",
        "@standard-schema/spec": "^1.0.0"
      },
      devDependencies: {
        "@hapi/bourne": "^3.0.0",
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "^7.0.0",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x",
        "@hapi/lab": "^26.0.0",
        "@types/node": "^20.17.47",
        typescript: "^5.8.3"
      },
      scripts: {
        prepublishOnly: "cd browser && npm install && npm run build",
        test: "lab -t 100 -a @hapi/code -L -Y",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});
var require_schemas2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/schemas.js"(exports2) {
    "use strict";
    var Joi2 = require_lib34();
    var internals = {};
    internals.wrap = Joi2.string().min(1).max(2).allow(false);
    exports2.preferences = Joi2.object({
      allowUnknown: Joi2.boolean(),
      abortEarly: Joi2.boolean(),
      artifacts: Joi2.boolean(),
      cache: Joi2.boolean(),
      context: Joi2.object(),
      convert: Joi2.boolean(),
      dateFormat: Joi2.valid("date", "iso", "string", "time", "utc"),
      debug: Joi2.boolean(),
      errors: {
        escapeHtml: Joi2.boolean(),
        label: Joi2.valid("path", "key", false),
        language: [
          Joi2.string(),
          Joi2.object().ref()
        ],
        render: Joi2.boolean(),
        stack: Joi2.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap,
          string: internals.wrap
        }
      },
      externals: Joi2.boolean(),
      messages: Joi2.object(),
      noDefaults: Joi2.boolean(),
      nonEnumerables: Joi2.boolean(),
      presence: Joi2.valid("required", "optional", "forbidden"),
      skipFunctions: Joi2.boolean(),
      stripUnknown: Joi2.object({
        arrays: Joi2.boolean(),
        objects: Joi2.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi2.boolean()
    }).strict();
    internals.nameRx = /^[a-zA-Z0-9]\w*$/;
    internals.rule = Joi2.object({
      alias: Joi2.array().items(Joi2.string().pattern(internals.nameRx)).single(),
      args: Joi2.array().items(
        Joi2.string(),
        Joi2.object({
          name: Joi2.string().pattern(internals.nameRx).required(),
          ref: Joi2.boolean(),
          assert: Joi2.alternatives([
            Joi2.function(),
            Joi2.object().schema()
          ]).conditional("ref", { is: true, then: Joi2.required() }),
          normalize: Joi2.function(),
          message: Joi2.string().when("assert", { is: Joi2.function(), then: Joi2.required() })
        })
      ),
      convert: Joi2.boolean(),
      manifest: Joi2.boolean(),
      method: Joi2.function().allow(false),
      multi: Joi2.boolean(),
      validate: Joi2.function()
    });
    exports2.extension = Joi2.object({
      type: Joi2.alternatives([
        Joi2.string(),
        Joi2.object().regex()
      ]).required(),
      args: Joi2.function(),
      cast: Joi2.object().pattern(internals.nameRx, Joi2.object({
        from: Joi2.function().maxArity(1).required(),
        to: Joi2.function().minArity(1).maxArity(2).required()
      })),
      base: Joi2.object().schema().when("type", { is: Joi2.object().regex(), then: Joi2.forbidden() }),
      coerce: [
        Joi2.function().maxArity(3),
        Joi2.object({ method: Joi2.function().maxArity(3).required(), from: Joi2.array().items(Joi2.string()).single() })
      ],
      flags: Joi2.object().pattern(internals.nameRx, Joi2.object({
        setter: Joi2.string(),
        default: Joi2.any()
      })),
      manifest: {
        build: Joi2.function().arity(2)
      },
      messages: [Joi2.object(), Joi2.string()],
      modifiers: Joi2.object().pattern(internals.nameRx, Joi2.function().minArity(1).maxArity(2)),
      overrides: Joi2.object().pattern(internals.nameRx, Joi2.function()),
      prepare: Joi2.function().maxArity(3),
      rebuild: Joi2.function().arity(1),
      rules: Joi2.object().pattern(internals.nameRx, internals.rule),
      terms: Joi2.object().pattern(internals.nameRx, Joi2.object({
        init: Joi2.array().allow(null).required(),
        manifest: Joi2.object().pattern(/.+/, [
          Joi2.valid("schema", "single"),
          Joi2.object({
            mapped: Joi2.object({
              from: Joi2.string().required(),
              to: Joi2.string().required()
            }).required()
          })
        ])
      })),
      validate: Joi2.function().maxArity(3)
    }).strict();
    exports2.extensions = Joi2.array().items(Joi2.object(), Joi2.function().arity(1)).strict();
    internals.desc = {
      buffer: Joi2.object({
        buffer: Joi2.string()
      }),
      func: Joi2.object({
        function: Joi2.function().required(),
        options: {
          literal: true
        }
      }),
      override: Joi2.object({
        override: true
      }),
      ref: Joi2.object({
        ref: Joi2.object({
          type: Joi2.valid("value", "global", "local"),
          path: Joi2.array().required(),
          separator: Joi2.string().length(1).allow(false),
          ancestor: Joi2.number().min(0).integer().allow("root"),
          map: Joi2.array().items(Joi2.array().length(2)).min(1),
          adjust: Joi2.function(),
          iterables: Joi2.boolean(),
          in: Joi2.boolean(),
          render: Joi2.boolean()
        }).required()
      }),
      regex: Joi2.object({
        regex: Joi2.string().min(3)
      }),
      special: Joi2.object({
        special: Joi2.valid("deep").required()
      }),
      template: Joi2.object({
        template: Joi2.string().required(),
        options: Joi2.object()
      }),
      value: Joi2.object({
        value: Joi2.alternatives([Joi2.object(), Joi2.array()]).required()
      })
    };
    internals.desc.entity = Joi2.alternatives([
      Joi2.array().items(Joi2.link("...")),
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number(),
      Joi2.string(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.special,
      internals.desc.template,
      internals.desc.value,
      Joi2.link("/")
    ]);
    internals.desc.values = Joi2.array().items(
      null,
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number().allow(Infinity, -Infinity),
      Joi2.string().allow(""),
      Joi2.symbol(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.override,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.template,
      internals.desc.value
    );
    internals.desc.messages = Joi2.object().pattern(/.+/, [
      Joi2.string(),
      internals.desc.template,
      Joi2.object().pattern(/.+/, [Joi2.string(), internals.desc.template])
    ]);
    exports2.description = Joi2.object({
      type: Joi2.string().required(),
      flags: Joi2.object({
        cast: Joi2.string(),
        default: Joi2.any(),
        description: Joi2.string(),
        empty: Joi2.link("/"),
        failover: internals.desc.entity,
        id: Joi2.string(),
        label: Joi2.string(),
        only: true,
        presence: ["optional", "required", "forbidden"],
        result: ["raw", "strip"],
        strip: Joi2.boolean(),
        unit: Joi2.string()
      }).unknown(),
      preferences: {
        allowUnknown: Joi2.boolean(),
        abortEarly: Joi2.boolean(),
        artifacts: Joi2.boolean(),
        cache: Joi2.boolean(),
        convert: Joi2.boolean(),
        dateFormat: ["date", "iso", "string", "time", "utc"],
        errors: {
          escapeHtml: Joi2.boolean(),
          label: ["path", "key"],
          language: [
            Joi2.string(),
            internals.desc.ref
          ],
          wrap: {
            label: internals.wrap,
            array: internals.wrap
          }
        },
        externals: Joi2.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi2.boolean(),
        nonEnumerables: Joi2.boolean(),
        presence: ["required", "optional", "forbidden"],
        skipFunctions: Joi2.boolean(),
        stripUnknown: Joi2.object({
          arrays: Joi2.boolean(),
          objects: Joi2.boolean()
        }).or("arrays", "objects").allow(true, false),
        warnings: Joi2.boolean()
      },
      allow: internals.desc.values,
      invalid: internals.desc.values,
      rules: Joi2.array().min(1).items({
        name: Joi2.string().required(),
        args: Joi2.object().min(1),
        keep: Joi2.boolean(),
        message: [
          Joi2.string(),
          internals.desc.messages
        ],
        warn: Joi2.boolean()
      }),
      // Terms
      keys: Joi2.object().pattern(/.*/, Joi2.link("/")),
      link: internals.desc.ref
    }).pattern(/^[a-z]\w*$/, Joi2.any());
  }
});
var require_lib32 = __commonJS({
  "node_modules/.deno/@hapi+formula@3.0.2/node_modules/@hapi/formula/lib/index.js"(exports2) {
    "use strict";
    var internals = {
      operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
      operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
      operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
      operatorsPrefix: ["!", "n"],
      literals: {
        '"': '"',
        "`": "`",
        "'": "'",
        "[": "]"
      },
      numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
      tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
      symbol: Symbol("formula"),
      settings: Symbol("settings")
    };
    exports2.Parser = class {
      constructor(string3, options3 = {}) {
        if (!options3[internals.settings] && options3.constants) {
          for (const constant in options3.constants) {
            const value = options3.constants[constant];
            if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
              throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
            }
          }
        }
        this.settings = options3[internals.settings] ? options3 : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options3);
        this.single = null;
        this._parts = null;
        this._parse(string3);
      }
      _parse(string3) {
        let parts = [];
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = (inner) => {
          if (parenthesis) {
            throw new Error("Formula missing closing parenthesis");
          }
          const last = parts.length ? parts[parts.length - 1] : null;
          if (!literal && !current && !inner) {
            return;
          }
          if (last && last.type === "reference" && inner === ")") {
            last.type = "function";
            last.value = this._subFormula(current, last.value);
            current = "";
            return;
          }
          if (inner === ")") {
            const sub = new exports2.Parser(current, this.settings);
            parts.push({ type: "segment", value: sub });
          } else if (literal) {
            if (literal === "]") {
              parts.push({ type: "reference", value: current });
              current = "";
              return;
            }
            parts.push({ type: "literal", value: current });
          } else if (internals.operatorCharacters.includes(current)) {
            if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
              last.value += current;
            } else {
              parts.push({ type: "operator", value: current });
            }
          } else if (current.match(internals.numberRx)) {
            parts.push({ type: "constant", value: parseFloat(current) });
          } else if (this.settings.constants[current] !== void 0) {
            parts.push({ type: "constant", value: this.settings.constants[current] });
          } else {
            if (!current.match(internals.tokenRx)) {
              throw new Error(`Formula contains invalid token: ${current}`);
            }
            parts.push({ type: "reference", value: current });
          }
          current = "";
        };
        for (const c of string3) {
          if (literal) {
            if (c === literal) {
              flush();
              literal = false;
            } else {
              current += c;
            }
          } else if (parenthesis) {
            if (c === "(") {
              current += c;
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
              if (!parenthesis) {
                flush(c);
              } else {
                current += c;
              }
            } else {
              current += c;
            }
          } else if (c in internals.literals) {
            literal = internals.literals[c];
          } else if (c === "(") {
            flush();
            ++parenthesis;
          } else if (internals.operatorCharacters.includes(c)) {
            flush();
            current = c;
            flush();
          } else if (c !== " ") {
            current += c;
          } else {
            flush();
          }
        }
        flush();
        parts = parts.map((part, i2) => {
          if (part.type !== "operator" || part.value !== "-" || i2 && parts[i2 - 1].type !== "operator") {
            return part;
          }
          return { type: "operator", value: "n" };
        });
        let operator = false;
        for (const part of parts) {
          if (part.type === "operator") {
            if (internals.operatorsPrefix.includes(part.value)) {
              continue;
            }
            if (!operator) {
              throw new Error("Formula contains an operator in invalid position");
            }
            if (!internals.operators.includes(part.value)) {
              throw new Error(`Formula contains an unknown operator ${part.value}`);
            }
          } else if (operator) {
            throw new Error("Formula missing expected operator");
          }
          operator = !operator;
        }
        if (!operator) {
          throw new Error("Formula contains invalid trailing operator");
        }
        if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
          this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
        }
        this._parts = parts.map((part) => {
          if (part.type === "operator") {
            return internals.operatorsPrefix.includes(part.value) ? part : part.value;
          }
          if (part.type !== "reference") {
            return part.value;
          }
          if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
            throw new Error(`Formula contains invalid reference ${part.value}`);
          }
          if (this.settings.reference) {
            return this.settings.reference(part.value);
          }
          return internals.reference(part.value);
        });
      }
      _subFormula(string3, name) {
        const method = this.settings.functions[name];
        if (typeof method !== "function") {
          throw new Error(`Formula contains unknown function ${name}`);
        }
        let args = [];
        if (string3) {
          let current = "";
          let parenthesis = 0;
          let literal = false;
          const flush = () => {
            if (!current) {
              throw new Error(`Formula contains function ${name} with invalid arguments ${string3}`);
            }
            args.push(current);
            current = "";
          };
          for (let i2 = 0; i2 < string3.length; ++i2) {
            const c = string3[i2];
            if (literal) {
              current += c;
              if (c === literal) {
                literal = false;
              }
            } else if (c in internals.literals && !parenthesis) {
              current += c;
              literal = internals.literals[c];
            } else if (c === "," && !parenthesis) {
              flush();
            } else {
              current += c;
              if (c === "(") {
                ++parenthesis;
              } else if (c === ")") {
                --parenthesis;
              }
            }
          }
          flush();
        }
        args = args.map((arg) => new exports2.Parser(arg, this.settings));
        return function(context) {
          const innerValues = [];
          for (const arg of args) {
            innerValues.push(arg.evaluate(context));
          }
          return method.call(context, ...innerValues);
        };
      }
      evaluate(context) {
        const parts = this._parts.slice();
        for (let i2 = parts.length - 2; i2 >= 0; --i2) {
          const part = parts[i2];
          if (part && part.type === "operator") {
            const current = parts[i2 + 1];
            parts.splice(i2 + 1, 1);
            const value = internals.evaluate(current, context);
            parts[i2] = internals.single(part.value, value);
          }
        }
        internals.operatorsOrder.forEach((set) => {
          for (let i2 = 1; i2 < parts.length - 1; ) {
            if (set.includes(parts[i2])) {
              const operator = parts[i2];
              const left = internals.evaluate(parts[i2 - 1], context);
              const right = internals.evaluate(parts[i2 + 1], context);
              parts.splice(i2, 2);
              const result = internals.calculate(operator, left, right);
              parts[i2 - 1] = result === 0 ? 0 : result;
            } else {
              i2 += 2;
            }
          }
        });
        return internals.evaluate(parts[0], context);
      }
    };
    exports2.Parser.prototype[internals.symbol] = true;
    internals.reference = function(name) {
      return function(context) {
        return context && context[name] !== void 0 ? context[name] : null;
      };
    };
    internals.evaluate = function(part, context) {
      if (part === null) {
        return null;
      }
      if (typeof part === "function") {
        return part(context);
      }
      if (part[internals.symbol]) {
        return part.evaluate(context);
      }
      return part;
    };
    internals.single = function(operator, value) {
      if (operator === "!") {
        return value ? false : true;
      }
      const negative = -value;
      if (negative === 0) {
        return 0;
      }
      return negative;
    };
    internals.calculate = function(operator, left, right) {
      if (operator === "??") {
        return internals.exists(left) ? left : right;
      }
      if (typeof left === "string" || typeof right === "string") {
        if (operator === "+") {
          left = internals.exists(left) ? left : "";
          right = internals.exists(right) ? right : "";
          return left + right;
        }
      } else {
        switch (operator) {
          case "^":
            return Math.pow(left, right);
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "+":
            return left + right;
          case "-":
            return left - right;
        }
      }
      switch (operator) {
        case "<":
          return left < right;
        case "<=":
          return left <= right;
        case ">":
          return left > right;
        case ">=":
          return left >= right;
        case "==":
          return left === right;
        case "!=":
          return left !== right;
        case "&&":
          return left && right;
        case "||":
          return left || right;
      }
      return null;
    };
    internals.exists = function(value) {
      return value !== null && value !== void 0;
    };
  }
});
var require_annotate2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/annotate.js"(exports2) {
    "use strict";
    var { clone: clone2 } = require_lib();
    var Common = require_common2();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports2.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = clone2(this._original);
      for (let i2 = this.details.length - 1; i2 >= 0; --i2) {
        const pos = i2 + 1;
        const error = this.details[i2];
        const path12 = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path12[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path12.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i2 = 0; i2 < this.details.length; ++i2) {
        const pos = i2 + 1;
        message = `${message}
[${pos}] ${this.details[i2].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = (key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i2 = 0; i2 < value.length; ++i2) {
                if (annotations.errors[i2]) {
                  annotated.push(`_$idx$_${annotations.errors[i2].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i2]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});
var require_errors2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/errors.js"(exports2) {
    "use strict";
    var Annotate = require_annotate2();
    var Common = require_common2();
    var Template = require_template2();
    exports2.Report = class {
      constructor(code2, value, local, flags8, messages, state, prefs) {
        this.code = code2;
        this.flags = flags8;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.template = null;
        this.local = local || {};
        this.local.label = exports2.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      _setTemplate(template) {
        this.template = template;
        if (!this.flags.label && this.path.length === 0) {
          const localized = this._template(this.template, "root");
          if (localized) {
            this.local.label = localized;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code2 = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code2}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages, code2) {
        return exports2.template(this.value, messages, code2 || this.code, this.state, this.prefs);
      }
    };
    exports2.path = function(path12) {
      let label = "";
      for (const segment of path12) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports2.template = function(value, messages, code2, state, prefs) {
      if (!messages) {
        return;
      }
      if (Template.isTemplate(messages)) {
        return code2 !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang]) {
        if (messages[lang][code2] !== void 0) {
          return messages[lang][code2];
        }
        if (messages[lang]["*"] !== void 0) {
          return messages[lang]["*"];
        }
      }
      if (!messages[code2]) {
        return messages["*"];
      }
      return messages[code2];
    };
    exports2.label = function(flags8, state, prefs, messages) {
      if (!prefs.errors.label) {
        return "";
      }
      if (flags8.label) {
        return flags8.label;
      }
      let path12 = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path12 = state.path.slice(-1);
      }
      const normalized = exports2.path(path12);
      if (normalized) {
        return normalized;
      }
      return exports2.template(null, prefs.messages, "root", state, prefs) || messages && exports2.template(null, messages, "root", state, prefs) || "value";
    };
    exports2.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports2.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports2.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports2.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports2.details = function(errors, options3 = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options3.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v2) => typeof v2 !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [...new Set(messages)];
      }
      return { message: messages.join(". "), details };
    };
    exports2.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports2.ValidationError;
      }
    };
    exports2.ValidationError.prototype.isJoi = true;
    exports2.ValidationError.prototype.name = "ValidationError";
    exports2.ValidationError.prototype.annotate = Annotate.error;
  }
});
var require_ref2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/ref.js"(exports2) {
    "use strict";
    var { assert: assert22, clone: clone2, reach } = require_lib();
    var Common = require_common2();
    var Template;
    var internals = {
      symbol: Symbol("ref"),
      // Used to internally identify references (shared with other joi versions)
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports2.create = function(key, options3 = {}) {
      assert22(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options3, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]);
      assert22(!options3.prefix || typeof options3.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options3);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options3.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          assert22(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            assert22(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref);
    };
    exports2.in = function(key, options3 = {}) {
      return exports2.create(key, { ...options3, in: true });
    };
    exports2.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options3) {
        assert22(typeof options3 === "object", "Invalid reference construction");
        Common.assertOptions(options3, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "render",
          "separator",
          "type",
          // Copied
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        assert22([false, void 0].includes(options3.separator) || typeof options3.separator === "string" && options3.separator.length === 1, "Invalid separator");
        assert22(!options3.adjust || typeof options3.adjust === "function", "options.adjust must be a function");
        assert22(!options3.map || Array.isArray(options3.map), "options.map must be an array");
        assert22(!options3.map || !options3.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options3);
        assert22(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local, options3 = {}) {
        assert22(!this.in || options3.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options3);
        }
        if (this.type === "local") {
          return this._resolve(local, state, options3);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options3);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options3);
        }
        assert22(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options3);
      }
      _resolve(target, state, options3) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options3.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        if (state.mainstay) {
          state.mainstay.tracer.resolve(state, this, resolved);
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [...state.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      describe() {
        const ref = { path: this.path };
        if (this.type !== "value") {
          ref.type = this.type;
        }
        if (this.separator !== ".") {
          ref.separator = this.separator;
        }
        if (this.type === "value" && this.ancestor !== 1) {
          ref.ancestor = this.ancestor;
        }
        if (this.map) {
          ref.map = [...this.map];
        }
        for (const key of ["adjust", "iterables", "render"]) {
          if (this[key] !== null && this[key] !== void 0) {
            ref[key] = this[key];
          }
        }
        if (this.in !== false) {
          ref.in = true;
        }
        return { ref };
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    exports2.build = function(desc) {
      desc = Object.assign({}, internals.defaults, desc);
      if (desc.type === "value" && desc.ancestor === void 0) {
        desc.ancestor = 1;
      }
      return new internals.Ref(desc);
    };
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return { key: key.slice(local.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i2 = 2;
      while (key[i2] === separator) {
        ++i2;
      }
      return [i2 - 1, i2];
    };
    exports2.toSibling = 0;
    exports2.toParent = 1;
    exports2.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports2.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports2.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
        Template = Template || require_template2();
        if (Template.isTemplate(source)) {
          this.register(source.refs(), target);
        }
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const copy2 = new exports2.Manager();
        copy2.refs = clone2(this.refs);
        return copy2;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});
var require_template2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/template.js"(exports2, module2) {
    "use strict";
    var { assert: assert22, clone: clone2, escapeHtml } = require_lib();
    var Formula = require_lib32();
    var Common = require_common2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module2.exports = exports2 = internals.Template = class {
      constructor(source, options3) {
        assert22(typeof source === "string", "Template source must be a string");
        assert22(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        if (options3) {
          const { functions, ...opts } = options3;
          this._settings = Object.keys(opts).length ? clone2(opts) : void 0;
          this._functions = functions;
          if (this._functions) {
            assert22(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
            assert22(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
          }
        } else {
          this._settings = void 0;
          this._functions = void 0;
        }
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          if (end === -1 || // Ignore non-matching closing
          part[1] === "{") {
            processed.push(`{${internals.decode(part)}`);
            continue;
          }
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
          processed.push(dynamic);
          if (typeof dynamic !== "string") {
            refs = true;
          }
          const rest2 = part.slice(end + ender.length);
          if (rest2) {
            processed.push(internals.decode(rest2));
          }
        }
        if (!refs) {
          this.rendered = processed.join("");
          return;
        }
        this._template = processed;
      }
      static date(date3, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date3);
      }
      describe(options3 = {}) {
        if (!this._settings && options3.compact) {
          return this.source;
        }
        const desc = { template: this.source };
        if (this._settings) {
          desc.options = this._settings;
        }
        if (this._functions) {
          desc.functions = this._functions;
        }
        return desc;
      }
      static build(desc) {
        return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : void 0);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      refs() {
        if (!this._template) {
          return;
        }
        const refs = [];
        for (const part of this._template) {
          if (typeof part !== "string") {
            refs.push(...part.refs);
          }
        }
        return refs;
      }
      resolve(value, state, prefs, local) {
        if (this._template && this._template.length === 1) {
          return this._part(
            this._template[0],
            /* context -> [*/
            value,
            state,
            prefs,
            local,
            {}
            /*] */
          );
        }
        return this.render(value, state, prefs, local);
      }
      _part(part, ...args) {
        if (part.ref) {
          return part.ref.resolve(...args);
        }
        return part.formula.evaluate(args);
      }
      render(value, state, prefs, local, options3 = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = this._part(
              part,
              /* context -> [*/
              value,
              state,
              prefs,
              local,
              options3
              /*] */
            );
            const string3 = internals.stringify(rendered, value, state, prefs, local, options3);
            if (string3 !== void 0) {
              const result = part.raw || (options3.errors && options3.errors.escapeHtml) === false ? string3 : escapeHtml(string3);
              parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
            }
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const refs = [];
        const reference = (variable) => {
          const ref = Ref.create(variable, this._settings);
          refs.push(ref);
          return (context) => {
            const resolved = ref.resolve(...context);
            return resolved !== void 0 ? resolved : null;
          };
        };
        try {
          const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
          var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
        } catch (err) {
          err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
          throw err;
        }
        if (formula.single) {
          if (formula.single.type === "reference") {
            const ref = refs[0];
            return { ref, raw, refs, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
          }
          return internals.stringify(formula.single.value);
        }
        return { formula, raw, refs };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string3) {
      return string3.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string3) {
      return string3.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string3) {
      const parts = [];
      let current = "";
      for (let i2 = 0; i2 < string3.length; ++i2) {
        const char = string3[i2];
        if (char === "{") {
          let next = "";
          while (i2 + 1 < string3.length && string3[i2 + 1] === "{") {
            next += "{";
            ++i2;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, original, state, prefs, local, options3 = {}) {
      const type = typeof value;
      const wrap = prefs && prefs.errors && prefs.errors.wrap || {};
      let skipWrap = false;
      if (Ref.isRef(value) && value.render) {
        skipWrap = value.in;
        value = value.resolve(original, state, prefs, local, { in: value.in, ...options3 });
      }
      if (value === null) {
        return "null";
      }
      if (type === "string") {
        return internals.wrap(value, options3.arrayItems && wrap.string);
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      const values = [];
      for (const item of value) {
        values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options3 }));
      }
      return internals.wrap(values.join(", "), !skipWrap && wrap.array);
    };
    internals.constants = {
      true: true,
      false: false,
      null: null,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 60 * 60 * 1e3,
      day: 24 * 60 * 60 * 1e3
    };
    internals.functions = {
      if(condition, then, otherwise) {
        return condition ? then : otherwise;
      },
      length(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (!item || typeof item !== "object") {
          return null;
        }
        if (Array.isArray(item)) {
          return item.length;
        }
        return Object.keys(item).length;
      },
      msg(code2) {
        const [value, state, prefs, local, options3] = this;
        const messages = options3.messages;
        if (!messages) {
          return "";
        }
        const template = Errors.template(value, messages[0], code2, state, prefs) || Errors.template(value, messages[1], code2, state, prefs);
        if (!template) {
          return "";
        }
        return template.render(value, state, prefs, local, options3);
      },
      number(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          return parseFloat(value);
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        if (value instanceof Date) {
          return value.getTime();
        }
        return null;
      }
    };
  }
});
var require_messages2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/messages.js"(exports2) {
    "use strict";
    var { assert: assert22, clone: clone2 } = require_lib();
    var Template = require_template2();
    exports2.compile = function(messages, target) {
      if (typeof messages === "string") {
        assert22(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        assert22(!target, "Cannot set single message template");
        return messages;
      }
      assert22(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? clone2(target) : {};
      for (let code2 in messages) {
        const message = messages[code2];
        if (code2 === "root" || Template.isTemplate(message)) {
          target[code2] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code2] = new Template(message);
          continue;
        }
        assert22(typeof message === "object" && !Array.isArray(message), "Invalid message for", code2);
        const language = code2;
        target[language] = target[language] || {};
        for (code2 in message) {
          const localized = message[code2];
          if (code2 === "root" || Template.isTemplate(localized)) {
            target[language][code2] = localized;
            continue;
          }
          assert22(typeof localized === "string", "Invalid message for", code2, "in", language);
          target[language][code2] = new Template(localized);
        }
      }
      return target;
    };
    exports2.decompile = function(messages) {
      const target = {};
      for (let code2 in messages) {
        const message = messages[code2];
        if (code2 === "root") {
          target.root = message;
          continue;
        }
        if (Template.isTemplate(message)) {
          target[code2] = message.describe({ compact: true });
          continue;
        }
        const language = code2;
        target[language] = {};
        for (code2 in message) {
          const localized = message[code2];
          if (code2 === "root") {
            target[language].root = localized;
            continue;
          }
          target[language][code2] = localized.describe({ compact: true });
        }
      }
      return target;
    };
    exports2.merge = function(base4, extended) {
      if (!base4) {
        return exports2.compile(extended);
      }
      if (!extended) {
        return base4;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = clone2(base4);
      for (let code2 in extended) {
        const message = extended[code2];
        if (code2 === "root" || Template.isTemplate(message)) {
          target[code2] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code2] = new Template(message);
          continue;
        }
        assert22(typeof message === "object" && !Array.isArray(message), "Invalid message for", code2);
        const language = code2;
        target[language] = target[language] || {};
        for (code2 in message) {
          const localized = message[code2];
          if (code2 === "root" || Template.isTemplate(localized)) {
            target[language][code2] = localized;
            continue;
          }
          assert22(typeof localized === "string", "Invalid message for", code2, "in", language);
          target[language][code2] = new Template(localized);
        }
      }
      return target;
    };
  }
});
var require_common2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/common.js"(exports2) {
    "use strict";
    var { assert: Assert, AssertError } = require_lib();
    var Pkg = require_package5();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports2.version = Pkg.version;
    exports2.defaults = {
      abortEarly: true,
      allowUnknown: false,
      artifacts: false,
      cache: true,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      externals: true,
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false,
      warnings: false
    };
    exports2.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      // Used to internally identify any-based types (shared with other joi versions)
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports2.assertOptions = function(options3, keys, name = "Options") {
      Assert(options3 && typeof options3 === "object" && !Array.isArray(options3), "Options must be of type object");
      const unknownKeys = Object.keys(options3).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports2.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas2();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports2.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports2.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports2.isIsoDate = function(date3) {
      return internals.isoDate.test(date3);
    };
    exports2.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports2.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports2.symbols.ref] || obj[exports2.symbols.template];
    };
    exports2.isSchema = function(schema, options3 = {}) {
      const any = schema && schema[exports2.symbols.any];
      if (!any) {
        return false;
      }
      Assert(options3.legacy || any.version === exports2.version, "Cannot mix different versions of joi schemas");
      return true;
    };
    exports2.isValues = function(obj) {
      return obj[exports2.symbols.values];
    };
    exports2.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports2.preferences = function(target, source) {
      Messages = Messages || require_messages2();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports2.symbols.prefs];
      return merged;
    };
    exports2.tryWithPath = function(fn, key, options3 = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options3.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports2.validateArg = function(value, label, { assert: assert22, message }) {
      if (exports2.isSchema(assert22)) {
        const result = assert22.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert22(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports2.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});
var require_cache = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/cache.js"(exports2) {
    "use strict";
    var { assert: assert22, clone: clone2 } = require_lib();
    var Common = require_common2();
    var internals = {
      max: 1e3,
      supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"])
    };
    exports2.provider = {
      provision(options3) {
        return new internals.Cache(options3);
      }
    };
    internals.Cache = class {
      constructor(options3 = {}) {
        Common.assertOptions(options3, ["max"]);
        assert22(options3.max === void 0 || options3.max && options3.max > 0 && isFinite(options3.max), "Invalid max cache size");
        this._max = options3.max || internals.max;
        this._map = /* @__PURE__ */ new Map();
        this._list = new internals.List();
      }
      get length() {
        return this._map.size;
      }
      set(key, value) {
        if (key !== null && !internals.supported.has(typeof key)) {
          return;
        }
        let node = this._map.get(key);
        if (node) {
          node.value = value;
          this._list.first(node);
          return;
        }
        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
      }
      get(key) {
        const node = this._map.get(key);
        if (node) {
          this._list.first(node);
          return clone2(node.value);
        }
      }
      _compact() {
        if (this._map.size > this._max) {
          const node = this._list.pop();
          this._map.delete(node.key);
        }
      }
    };
    internals.List = class {
      constructor() {
        this.tail = null;
        this.head = null;
      }
      unshift(node) {
        node.next = null;
        node.prev = this.head;
        if (this.head) {
          this.head.next = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        return node;
      }
      first(node) {
        if (node === this.head) {
          return;
        }
        this._remove(node);
        this.unshift(node);
      }
      pop() {
        return this._remove(this.tail);
      }
      _remove(node) {
        const { next, prev } = node;
        next.prev = prev;
        if (prev) {
          prev.next = next;
        }
        if (node === this.tail) {
          this.tail = next;
        }
        node.prev = null;
        node.next = null;
        return node;
      }
    };
  }
});
var require_compile2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/compile.js"(exports2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Common = require_common2();
    var Ref = require_ref2();
    var internals = {};
    exports2.schema = function(Joi2, config2, options3 = {}) {
      Common.assertOptions(options3, ["appendPath", "override"]);
      try {
        return internals.schema(Joi2, config2, options3);
      } catch (err) {
        if (options3.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi2, config2, options3) {
      assert22(config2 !== void 0, "Invalid undefined schema");
      if (Array.isArray(config2)) {
        assert22(config2.length, "Invalid empty array schema");
        if (config2.length === 1) {
          config2 = config2[0];
        }
      }
      const valid = (base4, ...values) => {
        if (options3.override !== false) {
          return base4.valid(Joi2.override, ...values);
        }
        return base4.valid(...values);
      };
      if (internals.simple(config2)) {
        return valid(Joi2, config2);
      }
      if (typeof config2 === "function") {
        return Joi2.custom(config2);
      }
      assert22(typeof config2 === "object", "Invalid schema content:", typeof config2);
      if (Common.isResolvable(config2)) {
        return valid(Joi2, config2);
      }
      if (Common.isSchema(config2)) {
        return config2;
      }
      if (Array.isArray(config2)) {
        for (const item of config2) {
          if (!internals.simple(item)) {
            return Joi2.alternatives().try(...config2);
          }
        }
        return valid(Joi2, ...config2);
      }
      if (config2 instanceof RegExp) {
        return Joi2.string().regex(config2);
      }
      if (config2 instanceof Date) {
        return valid(Joi2.date(), config2);
      }
      assert22(Object.getPrototypeOf(config2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi2.object().keys(config2);
    };
    exports2.ref = function(id, options3) {
      return Ref.isRef(id) ? id : Ref.create(id, options3);
    };
    exports2.compile = function(root, schema, options3 = {}) {
      Common.assertOptions(options3, ["legacy"]);
      const any = schema && schema[Common.symbols.any];
      if (any) {
        assert22(options3.legacy || any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
        return schema;
      }
      if (typeof schema !== "object" || !options3.legacy) {
        return exports2.schema(root, schema, { appendPath: true });
      }
      const compiler = internals.walk(schema);
      if (!compiler) {
        return exports2.schema(root, schema, { appendPath: true });
      }
      return compiler.compile(compiler.root, schema);
    };
    internals.walk = function(schema) {
      if (typeof schema !== "object") {
        return null;
      }
      if (Array.isArray(schema)) {
        for (const item of schema) {
          const compiler = internals.walk(item);
          if (compiler) {
            return compiler;
          }
        }
        return null;
      }
      const any = schema[Common.symbols.any];
      if (any) {
        return { root: schema[any.root], compile: any.compile };
      }
      assert22(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports2.when = function(schema, condition, options3) {
      if (options3 === void 0) {
        assert22(condition && typeof condition === "object", "Missing options");
        options3 = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options3)) {
        options3 = { switch: options3 };
      }
      Common.assertOptions(options3, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        assert22(options3.is === void 0, '"is" can not be used with a schema condition');
        assert22(options3.not === void 0, '"not" can not be used with a schema condition');
        assert22(options3.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema, { is: condition, then: options3.then, otherwise: options3.otherwise, break: options3.break });
      }
      assert22(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      assert22(options3.not === void 0 || options3.is === void 0, 'Cannot combine "is" with "not"');
      if (options3.switch === void 0) {
        let rule2 = options3;
        if (options3.not !== void 0) {
          rule2 = { is: options3.not, then: options3.otherwise, otherwise: options3.then, break: options3.break };
        }
        let is = rule2.is !== void 0 ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
        assert22(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        assert22(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options3.is !== void 0 && !Ref.isRef(options3.is) && !Common.isSchema(options3.is)) {
          is = is.required();
        }
        return internals.condition(schema, { ref: exports2.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      assert22(Array.isArray(options3.switch), '"switch" must be an array');
      assert22(options3.is === void 0, 'Cannot combine "switch" with "is"');
      assert22(options3.not === void 0, 'Cannot combine "switch" with "not"');
      assert22(options3.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports2.ref(condition),
        switch: [],
        break: options3.break
      };
      for (let i2 = 0; i2 < options3.switch.length; ++i2) {
        const test = options3.switch[i2];
        const last = i2 === options3.switch.length - 1;
        Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
        assert22(test.is !== void 0, 'Switch statement missing "is"');
        assert22(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema.$_compile(test.is),
          then: schema.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          assert22(options3.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options3.otherwise !== void 0 ? options3.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            assert22(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});
var require_extend2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/extend.js"(exports2) {
    "use strict";
    var { assert: assert22, clone: clone2 } = require_lib();
    var Common = require_common2();
    var Messages = require_messages2();
    var internals = {};
    exports2.type = function(from6, options3) {
      const base4 = Object.getPrototypeOf(from6);
      const prototype = clone2(base4);
      const schema = from6._assign(Object.create(prototype));
      const def = Object.assign({}, options3);
      delete def.base;
      prototype._definition = def;
      const parent = base4._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          assert22(schema.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      def.prepare = internals.prepare(def.prepare, parent.prepare);
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = { method: def.coerce };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
      }
      def.coerce = internals.coerce(def.coerce, parent.coerce);
      def.validate = internals.validate(def.validate, parent.validate);
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          assert22(typeof rule === "object", "Invalid rule definition for", def.type, name);
          let method = rule.method;
          if (method === void 0) {
            method = function() {
              return this.$_addRule(name);
            };
          }
          if (method) {
            assert22(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          assert22(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = { name: arg };
              }
              assert22(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              if (Common.isSchema(arg.assert)) {
                arg.assert = arg.assert.strict().label(arg.name);
              }
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      const modifiers = Object.assign({}, parent.modifiers);
      if (def.modifiers) {
        for (const name in def.modifiers) {
          assert22(!prototype[name], "Rule conflict in", def.type, name);
          const modifier = def.modifiers[name];
          assert22(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
          const method = function(arg) {
            return this.rule({ [name]: arg });
          };
          prototype[name] = method;
          modifiers[name] = modifier;
        }
      }
      def.modifiers = modifiers;
      if (def.overrides) {
        prototype._super = base4;
        schema.$_super = {};
        for (const override in def.overrides) {
          assert22(base4[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base4[override];
          schema.$_super[override] = base4[override].bind(schema);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      const manifest2 = Object.assign({}, parent.manifest, def.manifest);
      manifest2.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
      def.manifest = manifest2;
      def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
      return schema;
    };
    internals.build = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(obj, desc) {
        return parent(child(obj, desc), desc);
      };
    };
    internals.coerce = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return {
        from: child.from && parent.from ? [.../* @__PURE__ */ new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {
          let coerced;
          if (!parent.from || parent.from.includes(typeof value)) {
            coerced = parent.method(value, helpers);
            if (coerced) {
              if (coerced.errors || coerced.value === void 0) {
                return coerced;
              }
              value = coerced.value;
            }
          }
          if (!child.from || child.from.includes(typeof value)) {
            const own = child.method(value, helpers);
            if (own) {
              return own;
            }
          }
          return coerced;
        }
      };
    };
    internals.prepare = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const prepared = child(value, helpers);
        if (prepared) {
          if (prepared.errors || prepared.value === void 0) {
            return prepared;
          }
          value = prepared.value;
        }
        return parent(value, helpers) || prepared;
      };
    };
    internals.rebuild = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(schema) {
        parent(schema);
        child(schema);
      };
    };
    internals.validate = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const result = parent(value, helpers);
        if (result) {
          if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
            return result;
          }
          value = result.value;
        }
        return child(value, helpers) || result;
      };
    };
  }
});
var require_manifest = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/manifest.js"(exports2) {
    "use strict";
    var { assert: assert22, clone: clone2 } = require_lib();
    var Common = require_common2();
    var Messages = require_messages2();
    var Ref = require_ref2();
    var Template = require_template2();
    var Schemas;
    var internals = {};
    exports2.describe = function(schema) {
      const def = schema._definition;
      const desc = {
        type: schema.type,
        flags: {},
        rules: []
      };
      for (const flag in schema._flags) {
        if (flag[0] !== "_") {
          desc.flags[flag] = internals.describe(schema._flags[flag]);
        }
      }
      if (!Object.keys(desc.flags).length) {
        delete desc.flags;
      }
      if (schema._preferences) {
        desc.preferences = clone2(schema._preferences, { shallow: ["messages"] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
          desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
      }
      if (schema._valids) {
        desc.allow = schema._valids.describe();
      }
      if (schema._invalids) {
        desc.invalid = schema._invalids.describe();
      }
      for (const rule of schema._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {
          continue;
        }
        const item = { name: rule.name };
        for (const custom in def.modifiers) {
          if (rule[custom] !== void 0) {
            item[custom] = internals.describe(rule[custom]);
          }
        }
        if (rule.args) {
          item.args = {};
          for (const key in rule.args) {
            const arg = rule.args[key];
            if (key === "options" && !Object.keys(arg).length) {
              continue;
            }
            item.args[key] = internals.describe(arg, { assign: key });
          }
          if (!Object.keys(item.args).length) {
            delete item.args;
          }
        }
        desc.rules.push(item);
      }
      if (!desc.rules.length) {
        delete desc.rules;
      }
      for (const term in schema.$_terms) {
        if (term[0] === "_") {
          continue;
        }
        assert22(!desc[term], "Cannot describe schema due to internal name conflict with", term);
        const items = schema.$_terms[term];
        if (!items) {
          continue;
        }
        if (items instanceof Map) {
          if (items.size) {
            desc[term] = [...items.entries()];
          }
          continue;
        }
        if (Common.isValues(items)) {
          desc[term] = items.describe();
          continue;
        }
        assert22(def.terms[term], "Term", term, "missing configuration");
        const manifest2 = def.terms[term].manifest;
        const mapped = typeof manifest2 === "object";
        if (!items.length && !mapped) {
          continue;
        }
        const normalized = [];
        for (const item of items) {
          normalized.push(internals.describe(item));
        }
        if (mapped) {
          const { from: from6, to } = manifest2.mapped;
          desc[term] = {};
          for (const item of normalized) {
            desc[term][item[to]] = item[from6];
          }
          continue;
        }
        if (manifest2 === "single") {
          assert22(normalized.length === 1, "Term", term, "contains more than one item");
          desc[term] = normalized[0];
          continue;
        }
        desc[term] = normalized;
      }
      internals.validate(schema.$_root, desc);
      return desc;
    };
    internals.describe = function(item, options3 = {}) {
      if (Array.isArray(item)) {
        return item.map(internals.describe);
      }
      if (item === Common.symbols.deepDefault) {
        return { special: "deep" };
      }
      if (typeof item !== "object" || item === null) {
        return item;
      }
      if (options3.assign === "options") {
        return clone2(item);
      }
      if (Buffer && Buffer.isBuffer(item)) {
        return { buffer: item.toString("binary") };
      }
      if (item instanceof Date) {
        return item.toISOString();
      }
      if (item instanceof Error) {
        return item;
      }
      if (item instanceof RegExp) {
        if (options3.assign === "regex") {
          return item.toString();
        }
        return { regex: item.toString() };
      }
      if (item[Common.symbols.literal]) {
        return { function: item.literal };
      }
      if (typeof item.describe === "function") {
        if (options3.assign === "ref") {
          return item.describe().ref;
        }
        return item.describe();
      }
      const normalized = {};
      for (const key in item) {
        const value = item[key];
        if (value === void 0) {
          continue;
        }
        normalized[key] = internals.describe(value, { assign: key });
      }
      return normalized;
    };
    exports2.build = function(joi, desc) {
      const builder = new internals.Builder(joi);
      return builder.parse(desc);
    };
    internals.Builder = class {
      constructor(joi) {
        this.joi = joi;
      }
      parse(desc) {
        internals.validate(this.joi, desc);
        let schema = this.joi[desc.type]()._bare();
        const def = schema._definition;
        if (desc.flags) {
          for (const flag in desc.flags) {
            const setter = def.flags[flag] && def.flags[flag].setter || flag;
            assert22(typeof schema[setter] === "function", "Invalid flag", flag, "for type", desc.type);
            schema = schema[setter](this.build(desc.flags[flag]));
          }
        }
        if (desc.preferences) {
          schema = schema.preferences(this.build(desc.preferences));
        }
        if (desc.allow) {
          schema = schema.allow(...this.build(desc.allow));
        }
        if (desc.invalid) {
          schema = schema.invalid(...this.build(desc.invalid));
        }
        if (desc.rules) {
          for (const rule of desc.rules) {
            assert22(typeof schema[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
            const args = [];
            if (rule.args) {
              const built = {};
              for (const key in rule.args) {
                built[key] = this.build(rule.args[key], { assign: key });
              }
              const keys = Object.keys(built);
              const definition = def.rules[rule.name].args;
              if (definition) {
                assert22(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
                for (const { name } of definition) {
                  args.push(built[name]);
                }
              } else {
                assert22(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
                args.push(built[keys[0]]);
              }
            }
            schema = schema[rule.name](...args);
            const options3 = {};
            for (const custom in def.modifiers) {
              if (rule[custom] !== void 0) {
                options3[custom] = this.build(rule[custom]);
              }
            }
            if (Object.keys(options3).length) {
              schema = schema.rule(options3);
            }
          }
        }
        const terms = {};
        for (const key in desc) {
          if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
            continue;
          }
          assert22(def.terms[key], "Term", key, "missing configuration");
          const manifest2 = def.terms[key].manifest;
          if (manifest2 === "schema") {
            terms[key] = desc[key].map((item) => this.parse(item));
            continue;
          }
          if (manifest2 === "values") {
            terms[key] = desc[key].map((item) => this.build(item));
            continue;
          }
          if (manifest2 === "single") {
            terms[key] = this.build(desc[key]);
            continue;
          }
          if (typeof manifest2 === "object") {
            terms[key] = {};
            for (const name in desc[key]) {
              const value = desc[key][name];
              terms[key][name] = this.parse(value);
            }
            continue;
          }
          terms[key] = this.build(desc[key]);
        }
        if (desc.whens) {
          terms.whens = desc.whens.map((when) => this.build(when));
        }
        schema = def.manifest.build(schema, terms);
        schema.$_temp.ruleset = false;
        return schema;
      }
      build(desc, options3 = {}) {
        if (desc === null) {
          return null;
        }
        if (Array.isArray(desc)) {
          return desc.map((item) => this.build(item));
        }
        if (desc instanceof Error) {
          return desc;
        }
        if (options3.assign === "options") {
          return clone2(desc);
        }
        if (options3.assign === "regex") {
          return internals.regex(desc);
        }
        if (options3.assign === "ref") {
          return Ref.build(desc);
        }
        if (typeof desc !== "object") {
          return desc;
        }
        if (Object.keys(desc).length === 1) {
          if (desc.buffer) {
            assert22(Buffer, "Buffers are not supported");
            return Buffer && Buffer.from(desc.buffer, "binary");
          }
          if (desc.function) {
            return { [Common.symbols.literal]: true, literal: desc.function };
          }
          if (desc.override) {
            return Common.symbols.override;
          }
          if (desc.ref) {
            return Ref.build(desc.ref);
          }
          if (desc.regex) {
            return internals.regex(desc.regex);
          }
          if (desc.special) {
            assert22(["deep"].includes(desc.special), "Unknown special value", desc.special);
            return Common.symbols.deepDefault;
          }
          if (desc.value) {
            return clone2(desc.value);
          }
        }
        if (desc.type) {
          return this.parse(desc);
        }
        if (desc.template) {
          return Template.build(desc);
        }
        const normalized = {};
        for (const key in desc) {
          normalized[key] = this.build(desc[key], { assign: key });
        }
        return normalized;
      }
    };
    internals.regex = function(string3) {
      const end = string3.lastIndexOf("/");
      const exp = string3.slice(1, end);
      const flags8 = string3.slice(end + 1);
      return new RegExp(exp, flags8);
    };
    internals.validate = function(joi, desc) {
      Schemas = Schemas || require_schemas2();
      joi.assert(desc, Schemas.description);
    };
  }
});
var require_lib33 = __commonJS({
  "node_modules/.deno/@hapi+pinpoint@2.0.1/node_modules/@hapi/pinpoint/lib/index.js"(exports2) {
    "use strict";
    exports2.location = function(depth = 0) {
      const orig = Error.prepareStackTrace;
      Error.prepareStackTrace = (ignore, stack) => stack;
      const capture = {};
      Error.captureStackTrace(capture, this);
      const line = capture.stack[depth + 1];
      Error.prepareStackTrace = orig;
      return {
        filename: line.getFileName(),
        line: line.getLineNumber()
      };
    };
  }
});
var require_trace = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/trace.js"(exports2) {
    "use strict";
    var { deepEqual } = require_lib();
    var Pinpoint = require_lib33();
    var Errors = require_errors2();
    var internals = {
      codes: {
        error: 1,
        pass: 2,
        full: 3
      },
      labels: {
        0: "never used",
        1: "always error",
        2: "always pass"
      }
    };
    exports2.setup = function(root) {
      const trace = function() {
        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
      };
      root.trace = trace;
      root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
      root.untrace = () => {
        root._tracer = null;
      };
    };
    exports2.location = function(schema) {
      return schema.$_setFlag("_tracerLocation", Pinpoint.location(2));
    };
    internals.Tracer = class {
      constructor() {
        this.name = "Joi";
        this._schemas = /* @__PURE__ */ new Map();
      }
      _register(schema) {
        const existing = this._schemas.get(schema);
        if (existing) {
          return existing.store;
        }
        const store = new internals.Store(schema);
        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);
        this._schemas.set(schema, { filename, line, store });
        return store;
      }
      _combine(merged, sources) {
        for (const { store } of this._schemas.values()) {
          store._combine(merged, sources);
        }
      }
      report(file) {
        const coverage = [];
        for (const { filename, line, store } of this._schemas.values()) {
          if (file && file !== filename) {
            continue;
          }
          const missing = [];
          const skipped = [];
          for (const [schema, log2] of store._sources.entries()) {
            if (internals.sub(log2.paths, skipped)) {
              continue;
            }
            if (!log2.entry) {
              missing.push({
                status: "never reached",
                paths: [...log2.paths]
              });
              skipped.push(...log2.paths);
              continue;
            }
            for (const type of ["valid", "invalid"]) {
              const set = schema[`_${type}s`];
              if (!set) {
                continue;
              }
              const values = new Set(set._values);
              const refs = new Set(set._refs);
              for (const { value, ref } of log2[type]) {
                values.delete(value);
                refs.delete(ref);
              }
              if (values.size || refs.size) {
                missing.push({
                  status: [...values, ...[...refs].map((ref) => ref.display)],
                  rule: `${type}s`
                });
              }
            }
            const rules = schema._rules.map((rule) => rule.name);
            for (const type of ["default", "failover"]) {
              if (schema._flags[type] !== void 0) {
                rules.push(type);
              }
            }
            for (const name of rules) {
              const status = internals.labels[log2.rule[name] || 0];
              if (status) {
                const report = { rule: name, status };
                if (log2.paths.size) {
                  report.paths = [...log2.paths];
                }
                missing.push(report);
              }
            }
          }
          if (missing.length) {
            coverage.push({
              filename,
              line,
              missing,
              severity: "error",
              message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
            });
          }
        }
        return coverage.length ? coverage : null;
      }
    };
    internals.Store = class {
      constructor(schema) {
        this.active = true;
        this._sources = /* @__PURE__ */ new Map();
        this._combos = /* @__PURE__ */ new Map();
        this._scan(schema);
      }
      debug(state, source, name, result) {
        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
      }
      entry(schema, state) {
        internals.debug(state, { type: "entry" });
        this._record(schema, (log2) => {
          log2.entry = true;
        });
      }
      filter(schema, state, source, value) {
        internals.debug(state, { type: source, ...value });
        this._record(schema, (log2) => {
          log2[source].add(value);
        });
      }
      log(schema, state, source, name, result) {
        internals.debug(state, { type: source, name, result: result === "full" ? "pass" : result });
        this._record(schema, (log2) => {
          log2[source][name] = log2[source][name] || 0;
          log2[source][name] |= internals.codes[result];
        });
      }
      resolve(state, ref, to) {
        if (!state.mainstay.debug) {
          return;
        }
        const log2 = { type: "resolve", ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log2);
      }
      value(state, by, from6, to, name) {
        if (!state.mainstay.debug || deepEqual(from6, to)) {
          return;
        }
        const log2 = { type: "value", by, from: from6, to, path: state.path };
        if (name) {
          log2.name = name;
        }
        state.mainstay.debug.push(log2);
      }
      _record(schema, each) {
        const log2 = this._sources.get(schema);
        if (log2) {
          each(log2);
          return;
        }
        const sources = this._combos.get(schema);
        for (const source of sources) {
          this._record(source, each);
        }
      }
      _scan(schema, _path) {
        const path12 = _path || [];
        let log2 = this._sources.get(schema);
        if (!log2) {
          log2 = {
            paths: /* @__PURE__ */ new Set(),
            entry: false,
            rule: {},
            valid: /* @__PURE__ */ new Set(),
            invalid: /* @__PURE__ */ new Set()
          };
          this._sources.set(schema, log2);
        }
        if (path12.length) {
          log2.paths.add(path12);
        }
        const each = (sub, source) => {
          const subId = internals.id(sub, source);
          this._scan(sub, path12.concat(subId));
        };
        schema.$_modify({ each, ref: false });
      }
      _combine(merged, sources) {
        this._combos.set(merged, sources);
      }
    };
    internals.message = function(item) {
      const path12 = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
      return `${path12}${item.rule || ""} (${item.status})`;
    };
    internals.id = function(schema, { source, name, path: path12, key }) {
      if (schema._flags.id) {
        return schema._flags.id;
      }
      if (key) {
        return key;
      }
      name = `@${name}`;
      if (source === "terms") {
        return [name, path12[Math.min(path12.length - 1, 1)]];
      }
      return name;
    };
    internals.sub = function(paths, skipped) {
      for (const path12 of paths) {
        for (const skip of skipped) {
          if (deepEqual(path12.slice(0, skip.length), skip)) {
            return true;
          }
        }
      }
      return false;
    };
    internals.debug = function(state, event) {
      if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
      }
    };
  }
});
var require_modify2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/modify.js"(exports2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Common = require_common2();
    var Ref = require_ref2();
    var internals = {};
    exports2.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone2 = new internals.Ids();
        clone2._byId = new Map(this._byId);
        clone2._byKey = new Map(this._byKey);
        clone2._schemaChain = this._schemaChain;
        return clone2;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          assert22(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          assert22(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      fork(path12, adjuster, root) {
        const chain = this._collect(path12);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
        assert22(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
        for (const node of chain) {
          adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }
        return adjusted.schema;
      }
      labels(path12, behind = []) {
        const current = path12[0];
        const node = this._get(current);
        if (!node) {
          return [...behind, ...path12].join(".");
        }
        const forward = path12.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
          return behind.join(".");
        }
        return node.schema._ids.labels(forward, behind);
      }
      reach(path12, behind = []) {
        const current = path12[0];
        const node = this._get(current);
        assert22(node, "Schema does not contain path", [...behind, ...path12].join("."));
        const forward = path12.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema, { key } = {}) {
        if (!schema || !Common.isSchema(schema)) {
          return;
        }
        if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          assert22(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
          assert22(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema, id });
        }
        if (key) {
          assert22(!this._byKey.has(key), "Schema already contains key:", key);
          assert22(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _collect(path12, behind = [], nodes = []) {
        const current = path12[0];
        const node = this._get(current);
        assert22(node, "Schema does not contain path", [...behind, ...path12].join("."));
        nodes = [node, ...nodes];
        const forward = path12.slice(1);
        if (!forward.length) {
          return nodes;
        }
        return node.schema._ids._collect(forward, [...behind, current], nodes);
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    internals.fork = function(schema, id, replacement) {
      const each = (item, { key }) => {
        if (id === (item._flags.id || key)) {
          return replacement;
        }
      };
      const obj = exports2.schema(schema, { each, ref: false });
      return obj ? obj.$_mutateRebuild() : schema;
    };
    exports2.schema = function(schema, options3) {
      let obj;
      for (const name in schema._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema._flags[name], { source: "flags", name }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj._flags[name] = result;
        }
      }
      for (let i2 = 0; i2 < schema._rules.length; ++i2) {
        const rule = schema._rules[i2];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          const clone2 = Object.assign({}, rule);
          clone2.args = result;
          obj._rules[i2] = clone2;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone2);
          }
        }
      }
      for (const name in schema.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options3, _path, _key) {
      const path12 = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone2;
      if (Array.isArray(item)) {
        for (let i2 = 0; i2 < item.length; ++i2) {
          const key = source.source === "terms" && source.name === "keys" && item[i2].key;
          const result = internals.scan(item[i2], source, options3, [i2, ...path12], key);
          if (result !== void 0) {
            clone2 = clone2 || item.slice();
            clone2[i2] = result;
          }
        }
        return clone2;
      }
      if (options3.schema !== false && Common.isSchema(item) || options3.ref !== false && Ref.isRef(item)) {
        const result = options3.each(item, { ...source, path: path12, key: _key });
        if (result === item) {
          return;
        }
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options3, [key, ...path12], _key);
        if (result !== void 0) {
          clone2 = clone2 || Object.assign({}, item);
          clone2[key] = result;
        }
      }
      return clone2;
    };
  }
});
var require_state3 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/state.js"(exports2, module2) {
    "use strict";
    var { clone: clone2, reach } = require_lib();
    var Common = require_common2();
    var internals = {
      value: Symbol("value")
    };
    module2.exports = internals.State = class {
      constructor(path12, ancestors, state) {
        this.path = path12;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
        this.debug = null;
      }
      localize(path12, ancestors = null, schema = null) {
        const state = new internals.State(path12, ancestors, this);
        if (schema && state.schemas) {
          state.schemas = [internals.schemas(schema), ...state.schemas];
        }
        return state;
      }
      nest(schema, debug) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        state.debug = debug;
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = clone2(this.mainstay.shadow.node(this.path));
        }
        this.mainstay.snapshot();
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.restore();
      }
      commit() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.commit();
      }
    };
    internals.schemas = function(schema) {
      if (Common.isSchema(schema)) {
        return { schema };
      }
      return schema;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path12, value, reason) {
        if (!path12.length) {
          return;
        }
        if (reason === "strip" && typeof path12[path12.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i2 = 0; i2 < path12.length; ++i2) {
          const segment = path12[i2];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path12) {
        const node = this.node(path12);
        if (node) {
          return node[internals.value];
        }
      }
      node(path12) {
        if (!this._values) {
          return;
        }
        return reach(this._values, path12, { iterables: true });
      }
      override(path12, node) {
        if (!this._values) {
          return;
        }
        const parents = path12.slice(0, -1);
        const own = path12[path12.length - 1];
        const parent = reach(this._values, parents, { iterables: true });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});
var require_validator3 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/validator.js"(exports2) {
    "use strict";
    var { assert: assert22, clone: clone2, ignore, reach } = require_lib();
    var Common = require_common2();
    var Errors = require_errors2();
    var State = require_state3();
    var internals = {
      result: Symbol("result")
    };
    exports2.entry = function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        assert22(prefs.warnings === void 0, "Cannot override warnings preference in synchronous validation");
        assert22(prefs.artifacts === void 0, "Cannot override artifacts preference in synchronous validation");
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      assert22(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
      }
      if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
      }
      if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
      }
      return outcome;
    };
    exports2.entryAsync = async function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      const mainstay = result.mainstay;
      if (result.error) {
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
      if (mainstay.externals.length) {
        let root = result.value;
        const errors = [];
        for (const external of mainstay.externals) {
          const path12 = external.state.path;
          const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
          let node = root;
          let key;
          let parent;
          const ancestors = path12.length ? [root] : [];
          const original = path12.length ? reach(value, path12) : value;
          if (path12.length) {
            key = path12[path12.length - 1];
            let current = root;
            for (const segment of path12.slice(0, -1)) {
              current = current[segment];
              ancestors.unshift(current);
            }
            parent = ancestors[0];
            node = parent[key];
          }
          try {
            const createError = (code2, local) => (linked || external.schema).$_createError(code2, node, local, external.state, settings);
            const output = await external.method(node, {
              schema: external.schema,
              linked,
              state: external.state,
              prefs,
              original,
              error: createError,
              errorsArray: internals.errorsArray,
              warn: (code2, local) => mainstay.warnings.push((linked || external.schema).$_createError(code2, node, local, external.state, settings)),
              message: (messages, local) => (linked || external.schema).$_createError("external", node, local, external.state, settings, { messages })
            });
            if (output === void 0 || output === node) {
              continue;
            }
            if (output instanceof Errors.Report) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (Array.isArray(output) && output[Common.symbols.errors]) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(...output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (parent) {
              mainstay.tracer.value(external.state, "rule", node, output, "external");
              parent[key] = output;
            } else {
              mainstay.tracer.value(external.state, "rule", root, output, "external");
              root = output;
            }
          } catch (err) {
            if (settings.errors.label) {
              err.message += ` (${external.label})`;
            }
            throw err;
          }
        }
        result.value = root;
        if (errors.length) {
          result.error = Errors.process(errors, value, settings);
          if (mainstay.debug) {
            result.error.debug = mainstay.debug;
          }
          throw result.error;
        }
      }
      if (!settings.warnings && !settings.debug && !settings.artifacts) {
        return result.value;
      }
      const outcome = { value: result.value };
      if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
      }
      if (mainstay.debug) {
        outcome.debug = mainstay.debug;
      }
      if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
      }
      return outcome;
    };
    exports2.standard = function(value, schema) {
      if (schema.isAsync()) {
        return exports2.entryAsync(value, schema);
      }
      return exports2.entry(value, schema);
    };
    internals.Mainstay = class {
      constructor(tracer, debug, links) {
        this.externals = [];
        this.warnings = [];
        this.tracer = tracer;
        this.debug = debug;
        this.links = links;
        this.shadow = null;
        this.artifacts = null;
        this._snapshots = [];
      }
      snapshot() {
        this._snapshots.push({
          externals: this.externals.slice(),
          warnings: this.warnings.slice()
        });
      }
      restore() {
        const snapshot = this._snapshots.pop();
        this.externals = snapshot.externals;
        this.warnings = snapshot.warnings;
      }
      commit() {
        this._snapshots.pop();
      }
    };
    internals.entry = function(value, schema, prefs) {
      const { tracer, cleanup } = internals.tracer(schema, prefs);
      const debug = prefs.debug ? [] : null;
      const links = schema._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = new internals.Mainstay(tracer, debug, links);
      const schemas = schema._ids._schemaChain ? [{ schema }] : null;
      const state = new State([], [], { mainstay, schemas });
      const result = exports2.validate(value, schema, state, prefs);
      if (cleanup) {
        schema.$_root.untrace();
      }
      const error = Errors.process(result.errors, value, prefs);
      return { value: result.value, error, mainstay };
    };
    internals.tracer = function(schema, prefs) {
      if (schema.$_root._tracer) {
        return { tracer: schema.$_root._tracer._register(schema) };
      }
      if (prefs.debug) {
        assert22(schema.$_root.trace, "Debug mode not supported");
        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
      }
      return { tracer: internals.ignore };
    };
    exports2.validate = function(value, schema, state, prefs, overrides = {}) {
      if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
      }
      if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
      }
      if (schema._cache && prefs.cache) {
        const result = schema._cache.get(value);
        state.mainstay.tracer.debug(state, "validate", "cached", !!result);
        if (result) {
          return result;
        }
      }
      const createError = (code2, local, localState) => schema.$_createError(code2, value, local, localState || state, prefs);
      const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: (code2, local, localState) => state.mainstay.warnings.push(createError(code2, local, localState)),
        message: (messages, local) => schema.$_createError("custom", value, local, state, prefs, { messages })
      };
      state.mainstay.tracer.entry(schema, state);
      const def = schema._definition;
      if (def.prepare && value !== void 0 && prefs.convert) {
        const prepared = def.prepare(value, helpers);
        if (prepared) {
          state.mainstay.tracer.value(state, "prepare", value, prepared.value);
          if (prepared.errors) {
            return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
          }
          value = prepared.value;
        }
      }
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          state.mainstay.tracer.value(state, "coerced", value, coerced.value);
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty4 = schema._flags.empty;
      if (empty4 && empty4.$_match(internals.trim(value, schema), state.nest(empty4), Common.defaults)) {
        state.mainstay.tracer.value(state, "empty", value, void 0);
        value = void 0;
      }
      const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema.$_createError("any.required", value, null, state, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          state.mainstay.tracer.value(state, "default", value, {});
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state, prefs)], helpers);
      }
      const errors = [];
      if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            state.mainstay.tracer.value(state, "valids", value, match.value);
            value = match.value;
          }
          state.mainstay.tracer.filter(schema, state, "valid", match);
          return internals.finalize(value, null, helpers);
        }
        if (schema._flags.only) {
          const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          state.mainstay.tracer.filter(schema, state, "invalid", match);
          const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base4 = def.validate(value, helpers);
        if (base4) {
          state.mainstay.tracer.value(state, "base", value, base4.value);
          value = base4.value;
          if (base4.errors) {
            if (!Array.isArray(base4.errors)) {
              errors.push(base4.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base4.errors.length) {
              errors.push(...base4.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "full");
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "error");
          if (rule.warn) {
            state.mainstay.warnings.push(...result.errors);
            continue;
          }
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "pass");
          state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.error = function(report, rule) {
      if (rule.message) {
        report._setTemplate(rule.message);
      }
      return report;
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema, state, prefs } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          state.mainstay.tracer.value(state, "failover", value, failover);
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema._flags.error) {
        if (typeof schema._flags.error === "function") {
          errors = schema._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          for (const error of errors) {
            assert22(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [schema._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        state.mainstay.tracer.value(state, "default", value, defaulted);
        value = defaulted;
      }
      if (schema._flags.cast && value !== void 0) {
        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          state.mainstay.tracer.value(state, "cast", value, casted, schema._flags.cast);
          value = casted;
        }
      }
      if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {
        for (const { method } of schema.$_terms.externals) {
          state.mainstay.externals.push({ method, schema, state, label: Errors.label(schema._flags, state, prefs) });
        }
      }
      const result = { value, errors: errors.length ? errors : null };
      if (schema._flags.result) {
        result.value = schema._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
        state.shadow(value, schema._flags.result);
      }
      if (schema._cache && prefs.cache !== false && !schema._refs.length) {
        schema._cache.set(helpers.original, result);
      }
      if (value !== void 0 && !result.errors && schema._flags.artifact !== void 0) {
        state.mainstay.artifacts = state.mainstay.artifacts || /* @__PURE__ */ new Map();
        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {
          state.mainstay.artifacts.set(schema._flags.artifact, []);
        }
        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);
      }
      return result;
    };
    internals.prefs = function(schema, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
        return schema._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema._preferences);
      if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      const source = schema._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      state.mainstay.tracer.log(schema, state, "rule", flag, "full");
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [clone2(state.ancestors[0]), helpers] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return clone2(source);
    };
    internals.trim = function(value, schema) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.ignore = {
      active: false,
      debug: ignore,
      entry: ignore,
      filter: ignore,
      log: ignore,
      resolve: ignore,
      value: ignore
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});
var require_values2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/values.js"(exports2, module2) {
    "use strict";
    var { assert: assert22, deepEqual } = require_lib();
    var Common = require_common2();
    var internals = {};
    module2.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [...source._values, ...source._refs]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [...remove._values, ...remove._refs]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return { value };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return { value: found };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (deepEqual(item, value)) {
              return { value: item };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, { in: true });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return { value: item, ref };
                }
              } else {
                if (deepEqual(item, value)) {
                  return { value: item, ref };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options3) {
        if (options3 && options3.display) {
          const values = [];
          for (const item of [...this._values, ...this._refs]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
      }
      concat(source) {
        assert22(!source._override, "Cannot concat override set of values");
        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
      }
      describe() {
        const normalized = [];
        if (this._override) {
          normalized.push({ override: true });
        }
        for (const value of this._values.values()) {
          normalized.push(value && typeof value === "object" ? { value } : value);
        }
        for (const value of this._refs.values()) {
          normalized.push(value.describe());
        }
        return normalized;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from6) {
      const map = /* @__PURE__ */ new Map();
      if (from6) {
        for (const value of from6) {
          if (typeof value === "string") {
            map.set(value.toLowerCase(), value);
          }
        }
      }
      return map;
    };
  }
});
var require_base2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/base.js"(exports2, module2) {
    "use strict";
    var { assert: assert22, clone: clone2, deepEqual, merge: merge3 } = require_lib();
    var Cache = require_cache();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Extend = require_extend2();
    var Manifest = require_manifest();
    var Messages = require_messages2();
    var Modify = require_modify2();
    var Ref = require_ref2();
    var Trace = require_trace();
    var Validator = require_validator3();
    var Values = require_values2();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._reset();
      }
      _reset() {
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          // Runtime state (not cloned)
          ruleset: null,
          // null: use last, false: error, number: start position
          whens: {}
          // Runtime cache of generated whens
        };
      }
      // Manifest
      describe() {
        assert22(typeof Manifest.describe === "function", "Manifest functionality disabled");
        return Manifest.describe(this);
      }
      // Rules
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      alter(targets) {
        assert22(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
        assert22(!this._inRuleset(), "Cannot set alterations inside a ruleset");
        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
          const adjuster = targets[target];
          assert22(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
          obj.$_terms.alterations.push({ target, adjuster });
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      artifact(id) {
        assert22(id !== void 0, "Artifact cannot be undefined");
        assert22(!this._cache, "Cannot set an artifact with a rule cache");
        return this.$_setFlag("artifact", id);
      }
      cast(to) {
        assert22(to === false || typeof to === "string", "Invalid to value");
        assert22(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options3) {
        return this._default("default", value, options3);
      }
      description(desc) {
        assert22(desc && typeof desc === "string", "Description must be a non-empty string");
        return this.$_setFlag("description", desc);
      }
      empty(schema) {
        const obj = this.clone();
        if (schema !== void 0) {
          schema = obj.$_compile(schema, { override: false });
        }
        return obj.$_setFlag("empty", schema, { clone: false });
      }
      error(err) {
        assert22(err, "Missing error");
        assert22(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      example(example, options3 = {}) {
        assert22(example !== void 0, "Missing example");
        Common.assertOptions(options3, ["override"]);
        return this._inner("examples", example, { single: true, override: options3.override });
      }
      external(method, description) {
        if (typeof method === "object") {
          assert22(!description, "Cannot combine options with description");
          description = method.description;
          method = method.method;
        }
        assert22(typeof method === "function", "Method must be a function");
        assert22(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
        return this._inner("externals", { method, description }, { single: true });
      }
      failover(value, options3) {
        return this._default("failover", value, options3);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        assert22(typeof id === "string", "id must be a non-empty string");
        assert22(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      label(name) {
        assert22(name && typeof name === "string", "Label name must be a non-empty string");
        return this.$_setFlag("label", name);
      }
      meta(meta) {
        assert22(meta !== void 0, "Meta cannot be undefined");
        return this._inner("metas", meta, { single: true });
      }
      note(...notes) {
        assert22(notes.length, "Missing notes");
        for (const note of notes) {
          assert22(note && typeof note === "string", "Notes must be non-empty strings");
        }
        return this._inner("notes", notes);
      }
      only(mode = true) {
        assert22(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        assert22(prefs, "Missing preferences");
        assert22(prefs.context === void 0, "Cannot override context");
        assert22(prefs.externals === void 0, "Cannot override externals");
        assert22(prefs.warnings === void 0, "Cannot override warnings");
        assert22(prefs.debug === void 0, "Cannot override debug");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        assert22(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled2 = true) {
        return this.$_setFlag("result", enabled2 ? "raw" : void 0);
      }
      result(mode) {
        assert22(["raw", "strip"].includes(mode), "Unknown result mode", mode);
        return this.$_setFlag("result", mode);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled2) {
        const obj = this.clone();
        const convert = enabled2 === void 0 ? false : !enabled2;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
      }
      strip(enabled2 = true) {
        return this.$_setFlag("result", enabled2 ? "strip" : void 0);
      }
      tag(...tags) {
        assert22(tags.length, "Missing tags");
        for (const tag3 of tags) {
          assert22(tag3 && typeof tag3 === "string", "Tags must be non-empty strings");
        }
        return this._inner("tags", tags);
      }
      unit(name) {
        assert22(name && typeof name === "string", "Unit name must be a non-empty string");
        return this.$_setFlag("unit", name);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, { clone: false });
        return obj;
      }
      when(condition, options3) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options3);
        if (!["any", "link"].includes(obj.type)) {
          const conditions = when.is ? [when] : when.switch;
          for (const item of conditions) {
            assert22(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
            assert22(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      // Helpers
      cache(cache3) {
        assert22(!this._inRuleset(), "Cannot set caching inside a ruleset");
        assert22(!this._cache, "Cannot override schema cache");
        assert22(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
        const obj = this.clone();
        obj._cache = cache3 || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        assert22(Common.isSchema(source), "Invalid schema object");
        assert22(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        assert22(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
        assert22(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags8 = Object.assign({}, source._flags);
          delete flags8.empty;
          merge3(obj._flags, flags8);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags8 = Object.assign({}, source._flags);
          delete flags8.empty;
          merge3(obj._flags, flags8);
        } else {
          merge3(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, source]);
        }
        return obj.$_mutateRebuild();
      }
      extend(options3) {
        assert22(!options3.base, "Cannot extend type with another base");
        return Extend.type(this, options3);
      }
      extract(path12) {
        path12 = Array.isArray(path12) ? path12 : path12.split(".");
        return this._ids.reach(path12);
      }
      fork(paths, adjuster) {
        assert22(!this._inRuleset(), "Cannot fork inside a ruleset");
        let obj = this;
        for (let path12 of [].concat(paths)) {
          path12 = Array.isArray(path12) ? path12 : path12.split(".");
          obj = obj._ids.fork(path12, adjuster, obj);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      isAsync() {
        if (Boolean(this.$_terms.externals?.length)) {
          return true;
        }
        if (this.$_terms.whens) {
          for (const when of this.$_terms.whens) {
            if (when.then?.isAsync()) {
              return true;
            }
            if (when.otherwise?.isAsync()) {
              return true;
            }
            if (when.switch) {
              for (const item of when.switch) {
                if (item.then?.isAsync()) {
                  return true;
                }
                if (item.otherwise?.isAsync()) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }
      rule(options3) {
        const def = this._definition;
        Common.assertOptions(options3, Object.keys(def.modifiers));
        assert22(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        assert22(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
        const obj = this.clone();
        for (let i2 = start; i2 < obj._rules.length; ++i2) {
          const original = obj._rules[i2];
          const rule = clone2(original);
          for (const name in options3) {
            def.modifiers[name](rule, options3[name]);
            assert22(rule.name === original.name, "Cannot change rule name");
          }
          obj._rules[i2] = rule;
          if (obj._singleRules.get(rule.name) === original) {
            obj._singleRules.set(rule.name, rule);
          }
        }
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      get ruleset() {
        assert22(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
      }
      get $() {
        return this.ruleset;
      }
      tailor(targets) {
        targets = [].concat(targets);
        assert22(!this._inRuleset(), "Cannot tailor inside a ruleset");
        let obj = this;
        if (this.$_terms.alterations) {
          for (const { target, adjuster } of this.$_terms.alterations) {
            if (targets.includes(target)) {
              obj = adjuster(obj);
              assert22(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
            }
          }
        }
        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      tracer() {
        return Trace.location ? Trace.location(this) : this;
      }
      validate(value, options3) {
        return Validator.entry(value, this, options3);
      }
      validateAsync(value, options3) {
        return Validator.entryAsync(value, this, options3);
      }
      // Extensions
      $_addRule(options3) {
        if (typeof options3 === "string") {
          options3 = { name: options3 };
        }
        assert22(options3 && typeof options3 === "object", "Invalid options");
        assert22(options3.name && typeof options3.name === "string", "Invalid rule name");
        for (const key in options3) {
          assert22(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options3);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        assert22(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          assert22(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error = Common.validateArg(arg, key, resolver);
                  assert22(!error, error, "or reference");
                }
              }
            }
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name, { clone: false });
          obj._singleRules.set(rule.name, rule);
        }
        if (obj.$_temp.ruleset === false) {
          obj.$_temp.ruleset = null;
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema, options3) {
        return Compile.schema(this.$_root, schema, options3);
      }
      $_createError(code2, value, local, state, prefs, options3 = {}) {
        const flags8 = options3.flags !== false ? this._flags : {};
        const messages = options3.messages ? Messages.merge(this._definition.messages, options3.messages) : this._definition.messages;
        return new Errors.Report(code2, value, local, flags8, messages, state, prefs);
      }
      $_getFlag(name) {
        return this._flags[name];
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_mapLabels(path12) {
        path12 = Array.isArray(path12) ? path12 : path12.split(".");
        return this._ids.labels(path12);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options3) {
        Common.assertOptions(options3, ["each", "once", "ref", "schema"]);
        return Modify.schema(this, options3) || this;
      }
      $_mutateRebuild() {
        assert22(!this._inRuleset(), "Cannot add this rule inside a ruleset");
        this._refs.reset();
        this._ids.reset();
        const each = (item, { source, name, path: path12, key }) => {
          const family = this._definition[source][name] && this._definition[source][name].register;
          if (family !== false) {
            this.$_mutateRegister(item, { family, key });
          }
        };
        this.$_modify({ each });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        this.$_temp.ruleset = false;
        return this;
      }
      $_mutateRegister(schema, { family, key } = {}) {
        this._refs.register(schema, family);
        this._ids.register(schema, { key });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path12) {
        return this._ids.reach(path12);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options3 = {}) {
        assert22(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
        const flag = this._definition.flags[name] || {};
        if (deepEqual(value, flag.default)) {
          value = void 0;
        }
        if (deepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options3.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        if (name[0] !== "_") {
          obj.$_temp.ruleset = false;
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      // Internals
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = clone2(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _bare() {
        const obj = this.clone();
        obj._reset();
        const terms = obj._definition.terms;
        for (const name in terms) {
          const term = terms[name];
          obj.$_terms[name] = term.init;
        }
        return obj.$_mutateRebuild();
      }
      _default(flag, value, options3 = {}) {
        Common.assertOptions(options3, "literal");
        assert22(value !== void 0, "Missing", flag, "value");
        assert22(typeof value === "function" || !options3.literal, "Only function value supports literal option");
        if (typeof value === "function" && options3.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return { schema: this };
        }
        const whens = [];
        const ids = [];
        for (let i2 = 0; i2 < this.$_terms.whens.length; ++i2) {
          const when = this.$_terms.whens[i2];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i2}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [when] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i2}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        state.mainstay.tracer.debug(state, "rule", "when", id);
        if (!id) {
          return { schema: this };
        }
        if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
          return { schema: this.$_temp.whens[id], id };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, ...whens]);
        }
        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
      }
      _inner(type, values, options3 = {}) {
        assert22(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
        const obj = this.clone();
        if (!obj.$_terms[type] || options3.override) {
          obj.$_terms[type] = [];
        }
        if (options3.single) {
          obj.$_terms[type].push(values);
        } else {
          obj.$_terms[type].push(...values);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      _inRuleset() {
        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
      }
      _ruleRemove(name, options3 = {}) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        const obj = options3.clone !== false ? this.clone() : this;
        obj._singleRules.delete(name);
        const filtered = [];
        for (let i2 = 0; i2 < obj._rules.length; ++i2) {
          const test = obj._rules[i2];
          if (test.name === name && !test.keep) {
            if (obj._inRuleset() && i2 < obj.$_temp.ruleset) {
              --obj.$_temp.ruleset;
            }
            continue;
          }
          filtered.push(test);
        }
        obj._rules = filtered;
        return obj;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          assert22(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          assert22(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              assert22(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
      // Standard Schema
      get "~standard"() {
        const mapToStandardError = (error) => {
          let issues;
          if (Errors.ValidationError.isError(error)) {
            issues = error.details.map(({ message, path: path12 }) => ({
              message,
              path: path12
            }));
          } else {
            issues = [{
              message: error.message
            }];
          }
          return {
            issues
          };
        };
        const mapToStandardValue = (value) => ({ value });
        return {
          version: 1,
          vendor: "joi",
          validate: (value) => {
            const result = Validator.standard(value, this);
            if (result instanceof Promise) {
              return result.then(mapToStandardValue, mapToStandardError);
            }
            if (!result.error) {
              return mapToStandardValue(result.value);
            }
            return mapToStandardError(result.error);
          }
        };
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module2.exports = new internals.Base();
  }
});
var require_any2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/any.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Base = require_base2();
    var Common = require_common2();
    var Messages = require_messages2();
    module2.exports = Base.extend({
      type: "any",
      flags: {
        only: { default: false }
      },
      terms: {
        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
      },
      rules: {
        custom: {
          method(method, description) {
            assert22(typeof method === "function", "Method must be a function");
            assert22(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({ name: "custom", args: { method, description } });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", { error: err });
            }
          },
          args: ["method", "description"],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({ messages });
          }
        },
        shared: {
          method(schema) {
            assert22(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        warning: {
          method(code2, local) {
            assert22(code2 && typeof code2 === "string", "Invalid warning code");
            return this.$_addRule({ name: "warning", args: { code: code2, local }, warn: true });
          },
          validate(value, helpers, { code: code2, local }) {
            return helpers.error(code2, local);
          },
          args: ["code", "local"],
          multi: true
        }
      },
      modifiers: {
        keep(rule, enabled2 = true) {
          rule.keep = enabled2;
        },
        message(rule, message) {
          rule.message = Messages.compile(message);
        },
        warn(rule, enabled2 = true) {
          rule.warn = enabled2;
        }
      },
      manifest: {
        build(obj, desc) {
          for (const key in desc) {
            const values = desc[key];
            if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
              for (const value of values) {
                obj = obj[key.slice(0, -1)](value);
              }
              continue;
            }
            if (key === "alterations") {
              const alter = {};
              for (const { target, adjuster } of values) {
                alter[target] = adjuster;
              }
              obj = obj.alter(alter);
              continue;
            }
            if (key === "whens") {
              for (const value of values) {
                const { ref, is, not, then, otherwise, concat: concat2 } = value;
                if (concat2) {
                  obj = obj.concat(concat2);
                } else if (ref) {
                  obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                } else {
                  obj = obj.when(is, { then, otherwise, break: value.break });
                }
              }
              continue;
            }
            if (key === "shared") {
              for (const value of values) {
                obj = obj.shared(value);
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});
var require_alternatives2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/alternatives.js"(exports2, module2) {
    "use strict";
    var { assert: assert22, merge: merge3 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var internals = {};
    module2.exports = Any.extend({
      type: "alternatives",
      flags: {
        match: { default: "any" }
        // 'any', 'one', 'all'
      },
      terms: {
        matches: { init: [], register: Ref.toSibling }
      },
      args(schema, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema.try(...schemas[0]);
          }
        }
        return schema.try(...schemas);
      },
      validate(value, helpers) {
        const { schema, error, state, prefs } = helpers;
        if (schema._flags.match) {
          const matched = [];
          const failed = [];
          for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
            const item = schema.$_terms.matches[i2];
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              matched.push(result.value);
              localState.commit();
            } else {
              failed.push(result.errors);
              localState.restore();
            }
          }
          if (matched.length === 0) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.any", context) };
          }
          if (schema._flags.match === "one") {
            return matched.length === 1 ? { value: matched[0] } : { errors: error("alternatives.one") };
          }
          if (matched.length !== schema.$_terms.matches.length) {
            const context = {
              details: failed.map((f) => Errors.details(f, { override: false }))
            };
            return { errors: error("alternatives.all", context) };
          }
          const isAnyObj = (alternative) => {
            return alternative.$_terms.matches.some((v2) => {
              return v2.schema.type === "object" || v2.schema.type === "alternatives" && isAnyObj(v2.schema);
            });
          };
          return isAnyObj(schema) ? { value: matched.reduce((acc, v2) => merge3(acc, v2, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
        }
        const errors = [];
        for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
          const item = schema.$_terms.matches[i2];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              localState.commit();
              return result;
            }
            localState.restore();
            errors.push({ schema: item.schema, reports: result.errors });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [item] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i2}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options3) {
            assert22(!this._flags._endedSwitch, "Unreachable condition");
            assert22(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            assert22(options3.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options3);
            const conditions = match.is ? [match] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, { clone: false });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            assert22(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                assert22(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            assert22(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            assert22(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema of schemas) {
              obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      overrides: {
        label(name) {
          const obj = this.$_parent("label", name);
          const each = (item, source) => {
            return source.path[0] !== "is" && typeof item._flags.label !== "string" ? item.label(name) : void 0;
          };
          return obj.$_modify({ each, ref: false });
        },
        isAsync() {
          if (this.$_terms.externals?.length) {
            return true;
          }
          for (const match of this.$_terms.matches) {
            if (match.schema?.isAsync()) {
              return true;
            }
            if (match.then?.isAsync()) {
              return true;
            }
            if (match.otherwise?.isAsync()) {
              return true;
            }
          }
          return false;
        }
      },
      rebuild(schema) {
        const each = (item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema.$_setFlag("_arrayItems", true, { clone: false });
          }
        };
        schema.$_modify({ each });
      },
      manifest: {
        build(obj, desc) {
          if (desc.matches) {
            for (const match of desc.matches) {
              const { schema, ref, is, not, then, otherwise } = match;
              if (schema) {
                obj = obj.try(schema);
              } else if (ref) {
                obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
              } else {
                obj = obj.conditional(is, { then, otherwise });
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error, state }) {
      if (!failures.length) {
        return { errors: error("alternatives.any") };
      }
      if (failures.length === 1) {
        return { errors: failures[0].reports };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({ type: schema.type, report });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code2] = report.code.split(".");
        if (code2 !== "base") {
          complex.push({ type: schema.type, report });
        } else if (report.code === "object.base") {
          valids.add(report.local.type);
        } else {
          valids.add(type);
        }
      }
      if (!complex.length) {
        return { errors: error("alternatives.types", { types: [...valids] }) };
      }
      if (complex.length === 1) {
        return { errors: complex[0].report };
      }
      return internals.unmatched(failures, error);
    };
    internals.unmatched = function(failures, error) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
    };
  }
});
var require_array2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/array.js"(exports2, module2) {
    "use strict";
    var { assert: assert22, deepEqual, reach } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var internals = {};
    module2.exports = Any.extend({
      type: "array",
      flags: {
        single: { default: false },
        sparse: { default: false }
      },
      terms: {
        items: { init: [], manifest: "schema" },
        ordered: { init: [], manifest: "schema" },
        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
      },
      coerce: {
        from: "object",
        method(value, { schema, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema, error }) {
        if (!Array.isArray(value)) {
          if (schema._flags.single) {
            const single = [value];
            single[Common.symbols.arraySingle] = true;
            return { value: single };
          }
          return { errors: error("array.base") };
        }
        if (!schema.$_getRule("items") && !schema.$_terms.externals) {
          return;
        }
        return { value: value.slice() };
      },
      rules: {
        has: {
          method(schema) {
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "has", args: { schema } });
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { state, prefs, error }, { schema: has2 }) {
            const ancestors = [value, ...state.ancestors];
            for (let i2 = 0; i2 < value.length; ++i2) {
              const localState = state.localize([...state.path, i2], ancestors, has2);
              if (has2.$_match(value[i2], localState, prefs)) {
                return value;
              }
            }
            const patternLabel = has2._flags.label;
            if (patternLabel) {
              return error("array.hasKnown", { patternLabel });
            }
            return error("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, { append: true });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema, error, state, prefs, errorsArray }) {
            const requireds = schema.$_terms._requireds.slice();
            const ordereds = schema.$_terms.ordered.slice();
            const inclusions = [...schema.$_terms._inclusions, ...requireds];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i2 = 0; i2 < il; ++i2) {
              const item = value[i2];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i2 : new Number(i2);
              const path12 = [...state.path, key];
              if (!schema._flags.sparse && item === void 0) {
                errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [value, ...state.ancestors];
              for (const exclusion of schema.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path12, ancestors, exclusion), prefs, { presence: "ignore" })) {
                  continue;
                }
                errors.push(error("array.excludes", { pos: i2, value: item }, state.localize(path12)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path12, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i2] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema.$_terms.items.length) {
                  errors.push(error("array.orderedLength", { pos: i2, limit: schema.$_terms.ordered.length }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path12, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  localState.commit();
                  value[i2] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema._flags.sparse && res.value === void 0) {
                    errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path12, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    localState.commit();
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path: path12, pos: i2, value: void 0 }, state.localize(path12)));
                      errored = true;
                    } else {
                      value[i2] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i2);
                    --i2;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i2);
                  --i2;
                  --il;
                  continue;
                }
                errors.push(error("array.includes", { pos: i2, value: item }, state.localize(path12)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
              if (!errors.length) {
                internals.fillDefault(ordereds, value, state, prefs);
              }
            }
            return errors.length ? errors : value;
          },
          priority: true,
          manifest: false
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, { append: true });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled2) {
            const value = enabled2 === void 0 ? true : !!enabled2;
            assert22(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["by", "order"]);
            const settings = {
              order: options3.order || "ascending"
            };
            if (options3.by) {
              settings.by = Compile.ref(options3.by, { ancestor: 0 });
              assert22(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({ name: "sort", args: { options: settings } });
          },
          validate(value, { error, state, prefs, schema }, { options: options3 }) {
            const { value: sorted, errors } = internals.sort(schema, value, options3, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i2 = 0; i2 < value.length; ++i2) {
              if (value[i2] !== sorted[i2]) {
                return error("array.sort", { order: options3.order, by: options3.by ? options3.by.key : "value" });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled2) {
            const value = enabled2 === void 0 ? true : !!enabled2;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, { clone: false });
          }
        },
        unique: {
          method(comparator, options3 = {}) {
            assert22(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options3, ["ignoreUndefined", "separator"]);
            const rule = { name: "unique", args: { options: options3, comparator } };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options3.separator, ".");
                rule.path = separator ? comparator.split(separator) : [comparator];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error, schema }, { comparator: raw, options: options3 }, { comparator, path: path12 }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              bigint: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || deepEqual;
            const ignoreUndefined = options3.ignoreUndefined;
            for (let i2 = 0; i2 < value.length; ++i2) {
              const item = path12 ? reach(value[i2], path12) : value[i2];
              const records = comparator ? found.custom : found[typeof item];
              assert22(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([...state.path, i2], [value, ...state.ancestors]);
                    const context = {
                      pos: i2,
                      value: value[i2],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path12) {
                      context.path = raw;
                    }
                    return error("array.unique", context, localState);
                  }
                }
                records.set(item, i2);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i2,
                    value: value[i2],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path12) {
                    context.path = raw;
                  }
                  const localState = state.localize([...state.path, i2], [value, ...state.ancestors]);
                  return error("array.unique", context, localState);
                }
                records[item] = i2;
              }
            }
            return value;
          },
          args: ["comparator", "options"],
          multi: true
        }
      },
      overrides: {
        isAsync() {
          if (this.$_terms.externals?.length) {
            return true;
          }
          for (const item of this.$_terms.items) {
            if (item.isAsync()) {
              return true;
            }
          }
          for (const item of this.$_terms.ordered) {
            if (item.isAsync()) {
              return true;
            }
          }
          return false;
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema) {
        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];
        for (const type of schema.$_terms.items) {
          internals.validateSingle(type, schema);
          if (type._flags.presence === "required") {
            schema.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema.$_terms._exclusions.push(type);
          } else {
            schema.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema.$_terms.ordered) {
          internals.validateSingle(type, schema);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.items) {
            obj = obj.items(...desc.items);
          }
          if (desc.ordered) {
            obj = obj.ordered(...desc.ordered);
          }
          return obj;
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
      const knownMisses = [];
      let unknownMisses = 0;
      for (const required2 of requireds) {
        const label = required2._flags.label;
        if (label) {
          knownMisses.push(label);
        } else {
          ++unknownMisses;
        }
      }
      if (knownMisses.length) {
        if (unknownMisses) {
          errors.push(schema.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state, prefs));
        } else {
          errors.push(schema.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state, prefs));
        }
      } else {
        errors.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
      }
    };
    internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fillDefault = function(ordereds, value, state, prefs) {
      const overrides = [];
      let trailingUndefined = true;
      for (let i2 = ordereds.length - 1; i2 >= 0; --i2) {
        const ordered = ordereds[i2];
        const ancestors = [value, ...state.ancestors];
        const override = ordered.$_validate(void 0, state.localize(state.path, ancestors, ordered), prefs).value;
        if (trailingUndefined) {
          if (override === void 0) {
            continue;
          }
          trailingUndefined = false;
        }
        overrides.unshift(override);
      }
      if (overrides.length) {
        value.push(...overrides);
      }
    };
    internals.fastSplice = function(arr, i2) {
      let pos = i2;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        assert22(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, { clone: false });
      }
    };
    internals.sort = function(schema, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = (a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema.$_createError("array.sort.unsupported", value, { type }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      };
      try {
        return { value: value.slice().sort(sort) };
      } catch (err) {
        return { errors: err };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});
var require_boolean2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/boolean.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Values = require_values2();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module2.exports = Any.extend({
      type: "boolean",
      flags: {
        sensitive: { default: false }
      },
      terms: {
        falsy: {
          init: null,
          manifest: "values"
        },
        truthy: {
          init: null,
          manifest: "values"
        }
      },
      coerce(value, { schema }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }
        return { value };
      },
      validate(value, { error }) {
        if (typeof value !== "boolean") {
          return { value, errors: error("boolean.base") };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              assert22(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              assert22(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled2 = true) {
            return this.$_setFlag("sensitive", enabled2);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.truthy) {
            obj = obj.truthy(...desc.truthy);
          }
          if (desc.falsy) {
            obj = obj.falsy(...desc.falsy);
          }
          return obj;
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});
var require_date2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/date.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Template = require_template2();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module2.exports = Any.extend({
      type: "date",
      coerce: {
        from: ["number", "string"],
        method(value, { schema }) {
          return { value: internals.parse(value, schema._flags.format) || value };
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format32 = schema._flags.format;
        if (!prefs.convert || !format32 || typeof value !== "string") {
          return { value, errors: error("date.base") };
        }
        return { value, errors: error("date.format", { format: format32 }) };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date: date3 }, { name, operator, args }) {
            const to = date3 === "now" ? Date.now() : date3.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, { limit: args.date, value });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date3) => {
                return date3 === "now" ? date3 : internals.parse(date3);
              },
              assert: (date3) => date3 !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format32) {
            assert22(["iso", "javascript", "unix"].includes(format32), "Unknown date format", format32);
            return this.$_setFlag("format", format32);
          }
        },
        greater: {
          method(date3) {
            return this.$_addRule({ name: "greater", method: "compare", args: { date: date3 }, operator: ">" });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date3) {
            return this.$_addRule({ name: "less", method: "compare", args: { date: date3 }, operator: "<" });
          }
        },
        max: {
          method(date3) {
            return this.$_addRule({ name: "max", method: "compare", args: { date: date3 }, operator: "<=" });
          }
        },
        min: {
          method(date3) {
            return this.$_addRule({ name: "min", method: "compare", args: { date: date3 }, operator: ">=" });
          }
        },
        timestamp: {
          method(type = "javascript") {
            assert22(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
        // Messages used in date.format
        "date.format.iso": "ISO 8601 date",
        "date.format.javascript": "timestamp or number of milliseconds",
        "date.format.unix": "timestamp or number of seconds"
      }
    });
    internals.parse = function(value, format32) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format32 === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format32) {
        if (format32 === "javascript") {
          return internals.date(1 * value);
        }
        if (format32 === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date3 = new Date(value);
      if (!isNaN(date3.getTime())) {
        return date3;
      }
      return null;
    };
  }
});
var require_keys2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/keys.js"(exports2, module2) {
    "use strict";
    var { applyToDefaults, assert: assert22, clone: Clone } = require_lib();
    var Topo = require_lib2();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var Template = require_template2();
    var internals = {
      renameDefaults: {
        alias: false,
        // Keep old value in place
        multiple: false,
        // Allow renaming multiple keys into the same target
        override: false
        // Overrides an existing key
      }
    };
    module2.exports = Any.extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: { default: void 0 }
      },
      terms: {
        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
        patterns: { init: null },
        renames: { init: null }
      },
      args(schema, keys) {
        return schema.keys(keys);
      },
      validate(value, { schema, error, state, prefs }) {
        if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
          return { value, errors: error("object.base", { type: schema.$_property("typeof") }) };
        }
        if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns && !schema.$_terms.externals) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
          return { value, errors };
        }
        if (!schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns && !schema.$_terms.dependencies) {
          return { value, errors };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema.$_terms.keys) {
          const ancestors = [value, ...state.ancestors];
          for (const child of schema.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([...state.path, key], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              if (result.value !== void 0) {
                value[key] = result.value;
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema._flags._hasPatternMatch) {
          const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema.$_terms.dependencies) {
          for (const dep of schema.$_terms.dependencies) {
            if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
            if (failed) {
              const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
        return { value, errors };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema) {
            if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
              return this;
            }
            return this.keys(schema);
          }
        },
        assert: {
          method(subject, schema, message) {
            if (!Template.isTemplate(subject)) {
              subject = Compile.ref(subject);
            }
            assert22(message === void 0 || typeof message === "string", "Message must be a string");
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { error, prefs, state }, { subject, schema, message }) {
            const about = subject.resolve(value, state, prefs);
            const path12 = Ref.isRef(subject) ? subject.absolute(state) : [];
            if (schema.$_match(about, state.localize(path12, [value, ...state.ancestors], schema), prefs)) {
              return value;
            }
            return error("object.assert", { subject, message });
          },
          args: ["subject", "schema", "message"],
          multi: true
        },
        instance: {
          method(constructor, name) {
            assert22(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({ name: "instance", args: { constructor, name } });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", { type: name, value });
          },
          args: ["constructor", "name"]
        },
        keys: {
          method(schema) {
            assert22(schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
            assert22(!Common.isSchema(schema), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema) {
                Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema, options3 = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, { appendPath: true });
            }
            assert22(schema !== void 0, "Invalid rule");
            Common.assertOptions(options3, ["fallthrough", "matches"]);
            if (isRegExp) {
              assert22(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config2 = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
            if (options3.matches) {
              config2.matches = this.$_compile(options3.matches);
              if (config2.matches.type !== "array") {
                config2.matches = config2.matches.$_root.array().items(config2.matches);
              }
              obj.$_mutateRegister(config2.matches);
              obj.$_setFlag("_hasPatternMatch", true, { clone: false });
            }
            if (options3.fallthrough) {
              config2.fallthrough = true;
            }
            obj.$_terms.patterns.push(config2);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", { value });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", { value });
          }
        },
        rename: {
          method(from6, to, options3 = {}) {
            assert22(typeof from6 === "string" || from6 instanceof RegExp, "Rename missing the from argument");
            assert22(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
            assert22(to !== from6, "Cannot rename key to same name:", from6);
            Common.assertOptions(options3, ["alias", "ignoreUndefined", "override", "multiple"]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              assert22(rename.from !== from6, "Cannot rename the same key multiple times");
            }
            if (to instanceof Template) {
              obj.$_mutateRegister(to);
            }
            obj.$_terms.renames.push({
              from: from6,
              to,
              options: applyToDefaults(internals.renameDefaults, options3)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({ name: "schema", args: { type } });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", { type });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "with", key, peers, options3);
          }
        },
        without: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "without", key, peers, options3);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options3) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options3);
        },
        isAsync() {
          if (this.$_terms.externals?.length) {
            return true;
          }
          if (this.$_terms.keys?.length) {
            for (const key of this.$_terms.keys) {
              if (key.schema.isAsync()) {
                return true;
              }
            }
          }
          if (this.$_terms.patterns?.length) {
            for (const pattern of this.$_terms.patterns) {
              if (pattern.rule.isAsync()) {
                return true;
              }
            }
          }
          return false;
        }
      },
      rebuild(schema) {
        if (schema.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
          }
          schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.keys) {
            obj = obj.keys(desc.keys);
          }
          if (desc.dependencies) {
            for (const { rel, key = null, peers, options: options3 } of desc.dependencies) {
              obj = internals.dependency(obj, rel, key, peers, options3);
            }
          }
          if (desc.patterns) {
            for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
              obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
            }
          }
          if (desc.renames) {
            for (const { from: from6, to, options: options3 } of desc.renames) {
              obj = obj.rename(from6, to, options3);
            }
          }
          return obj;
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
        "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
        "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
        "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, { shallow: true });
        }
        const clone3 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone3, value);
        return clone3;
      }
      const clone2 = function(...args) {
        return value.apply(this, args);
      };
      clone2.prototype = Clone(value.prototype);
      Object.defineProperty(clone2, "name", { value: value.name, writable: false });
      Object.defineProperty(clone2, "length", { value: value.length, writable: false });
      Object.assign(clone2, value);
      return clone2;
    };
    internals.dependency = function(schema, rel, key, peers, options3) {
      assert22(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options3) {
        options3 = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options3, ["separator", "isPresent"]);
      peers = [].concat(peers);
      const separator = Common.default(options3.separator, ".");
      const paths = [];
      for (const peer of peers) {
        assert22(typeof peer === "string", rel, "peers must be strings");
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
      }
      if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
      }
      const obj = schema.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options3));
      return obj;
    };
    internals.dependencies = {
      and(schema, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count3 = dep.peers.length;
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count3 && present.length !== count3) {
          return {
            code: "object.and",
            context: {
              present,
              presentWithLabels: internals.keysToLabels(schema, present),
              missing,
              missingWithLabels: internals.keysToLabels(schema, missing)
            }
          };
        }
      },
      nand(schema, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            mainWithLabel: internals.keysToLabels(schema, main),
            peers: values,
            peersWithLabels: internals.keysToLabels(schema, values)
          }
        };
      },
      or(schema, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths,
            peersWithLabels: internals.keysToLabels(schema, dep.paths)
          }
        };
      },
      oxor(schema, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: "object.oxor", context };
      },
      with(schema, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema, peer.key)
              }
            };
          }
        }
      },
      without(schema, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema, peer.key)
              }
            };
          }
        }
      },
      xor(schema, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        if (present.length === 0) {
          return { code: "object.missing", context };
        }
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: "object.xor", context };
      }
    };
    internals.keysToLabels = function(schema, keys) {
      if (Array.isArray(keys)) {
        return keys.map((key) => schema.$_mapLabels(key));
      }
      return schema.$_mapLabels(keys);
    };
    internals.isPresent = function(options3) {
      return typeof options3.isPresent === "function" ? options3.isPresent : (resolved) => resolved !== void 0;
    };
    internals.rename = function(schema, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from6 in value) {
            if (value[from6] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from6 === rename.to) {
              continue;
            }
            const match = rename.from.exec(from6);
            if (!match) {
              continue;
            }
            matches.push({ from: from6, to: rename.to, match });
          }
        }
        for (const match of matches) {
          const from6 = match.from;
          let to = match.to;
          if (to instanceof Template) {
            to = to.render(value, state, prefs, match.match);
          }
          if (from6 === to) {
            continue;
          }
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema.$_createError("object.rename.multiple", value, { from: from6, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema.$_createError("object.rename.override", value, { from: from6, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from6] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from6];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from6];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
      if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [value, ...state.ancestors];
        for (const key of unprocessed) {
          const item = value[key];
          const path12 = [...state.path, key];
          for (let i2 = 0; i2 < schema.$_terms.patterns.length; ++i2) {
            const pattern = schema.$_terms.patterns[i2];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              state.mainstay.tracer.debug(state, "rule", `pattern.${i2}`, match ? "pass" : "error");
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i2}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path12, ancestors, { schema: pattern.rule, key });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i2].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i2 = 0; i2 < matches.length; ++i2) {
            const match = matches[i2];
            if (!match) {
              continue;
            }
            const stpm = schema.$_terms.patterns[i2].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, { override: false });
              details.matches = match;
              const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && typeof schema._flags.unknown === "undefined" || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([...state.path, unprocessedKey], []);
          const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
          if (prefs.abortEarly) {
            return { value, errors: report };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths, options3) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
        this.options = options3;
      }
      describe() {
        const desc = {
          rel: this.rel,
          peers: this.paths
        };
        if (this.key !== null) {
          desc.key = this.key.key;
        }
        if (this.peers[0].separator !== ".") {
          desc.options = { ...desc.options, separator: this.peers[0].separator };
        }
        if (this.options.isPresent) {
          desc.options = { ...desc.options, isPresent: this.options.isPresent };
        }
        return desc;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < result.length; ++i2) {
          keys.set(result[i2].key, i2);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});
var require_function2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/function.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Keys = require_keys2();
    module2.exports = Keys.extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            assert22(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "arity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", { n });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", { value });
          }
        },
        minArity: {
          method(n) {
            assert22(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({ name: "minArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", { n });
          }
        },
        maxArity: {
          method(n) {
            assert22(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "maxArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", { n });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});
var require_link2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/link.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var internals = {};
    module2.exports = Any.extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: { init: null, manifest: "single", register: false }
      },
      args(schema, ref) {
        return schema.ref(ref);
      },
      validate(value, { schema, state, prefs }) {
        assert22(schema.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema, value, state, prefs) {
        return internals.generate(schema, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            assert22(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            assert22(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            assert22(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [{ ref }];
            return obj;
          }
        },
        relative: {
          method(enabled2 = true) {
            return this.$_setFlag("relative", enabled2);
          }
        }
      },
      overrides: {
        concat(source) {
          assert22(this.$_terms.link, "Uninitialized link schema");
          assert22(Common.isSchema(source), "Invalid schema object");
          assert22(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({ concat: source });
          return obj.$_mutateRebuild();
        }
      },
      manifest: {
        build(obj, desc) {
          assert22(desc.link, "Invalid link description missing link");
          return obj.ref(desc.link);
        }
      }
    });
    internals.generate = function(schema, value, state, prefs) {
      let linked = state.mainstay.links.get(schema);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema.$_terms.link[0].ref;
      const { perspective, path: path12 } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
      try {
        linked = path12.length ? perspective.$_reach(path12) : perspective;
      } catch {
        internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
      if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema, key } of state.schemas) {
          const id = schema._flags.id || key;
          if (id === ref.path[0]) {
            return { perspective: schema, path: ref.path.slice(1) };
          }
          if (schema.$_terms.shared) {
            for (const shared of schema.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return { perspective: shared, path: ref.path.slice(1) };
              }
            }
          }
        }
        return { perspective: null, path: null };
      }
      if (ref.ancestor === "root") {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
      }
      return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
    };
    internals.assert = function(condition, message, ref, schema, state, prefs) {
      if (condition) {
        return;
      }
      assert22(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});
var require_number2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/number.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
      exponentialPartRegex: /[eE][+-]?\d+$/,
      leadingSignAndZerosRegex: /^[+-]?(0*)?/,
      dotRegex: /\./,
      trailingZerosRegex: /0+$/,
      decimalPlaces(value) {
        const str = value.toString();
        const dindex = str.indexOf(".");
        const eindex = str.indexOf("e");
        return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));
      }
    };
    module2.exports = Any.extend({
      type: "number",
      flags: {
        unsafe: { default: false }
      },
      coerce: {
        from: "string",
        method(value, { schema, error }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = { value: parseFloat(value) };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema._flags.unsafe) {
            if (value.match(/e/i)) {
              if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
                result.errors = error("number.unsafe");
                return result;
              }
            } else {
              const string3 = result.value.toString();
              if (string3.match(/e/i)) {
                return result;
              }
              if (string3 !== internals.normalizeDecimal(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return { value, errors: error("number.infinity") };
        }
        if (!Common.isNumber(value)) {
          return { value, errors: error("number.base") };
        }
        const result = { value };
        if (prefs.convert) {
          const rule = schema.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
          }
        },
        multiple: {
          method(base4) {
            const baseDecimalPlace = typeof base4 === "number" ? internals.decimalPlaces(base4) : null;
            const pfactor = Math.pow(10, baseDecimalPlace);
            return this.$_addRule({
              name: "multiple",
              args: {
                base: base4,
                baseDecimalPlace,
                pfactor
              }
            });
          },
          validate(value, helpers, { base: base4, baseDecimalPlace, pfactor }, options3) {
            const valueDecimalPlace = internals.decimalPlaces(value);
            if (valueDecimalPlace > baseDecimalPlace) {
              return helpers.error("number.multiple", { multiple: options3.args.base, value });
            }
            return Math.round(pfactor * value) % Math.round(pfactor * base4) === 0 ? value : helpers.error("number.multiple", { multiple: options3.args.base, value });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            },
            "baseDecimalPlace",
            "pfactor"
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            assert22(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({ name: "precision", args: { limit } });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", { limit, value });
          },
          convert: true
        },
        sign: {
          method(sign2) {
            assert22(["negative", "positive"].includes(sign2), "Invalid sign", sign2);
            return this.$_addRule({ name: "sign", args: { sign: sign2 } });
          },
          validate(value, helpers, { sign: sign2 }) {
            if (sign2 === "negative" && value < 0 || sign2 === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign2}`);
          }
        },
        unsafe: {
          method(enabled2 = true) {
            assert22(typeof enabled2 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled2);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.extractSignificantDigits = function(value) {
      return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});
var require_object2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/object.js"(exports2, module2) {
    "use strict";
    var Keys = require_keys2();
    module2.exports = Keys.extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});
var require_errors3 = __commonJS({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/dist/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorCode = exports2.errorCodes = void 0;
    exports2.errorCodes = {
      EMPTY_STRING: "Address must be a non-empty string",
      FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
      MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
      MISSING_AT_CHAR: "Address must contain one @ character",
      EMPTY_LOCAL: "Address local part cannot be empty",
      ADDRESS_TOO_LONG: "Address too long",
      LOCAL_TOO_LONG: "Address local part too long",
      EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
      INVALID_LOCAL_CHARS: "Address local part contains invalid character",
      DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
      DOMAIN_TOO_LONG: "Domain too long",
      DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
      DOMAIN_INVALID_CHARS: "Domain contains invalid character",
      DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
      DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
      DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
      DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
      DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
      DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
    };
    function errorCode(code2) {
      return { code: code2, error: exports2.errorCodes[code2] };
    }
    exports2.errorCode = errorCode;
  }
});
var require_domain = __commonJS({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/dist/domain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateDomainOptions = exports2.isDomainValid = exports2.analyzeDomain = void 0;
    var Url = __require2("url");
    var errors_1 = require_errors3();
    var MIN_DOMAIN_SEGMENTS = 2;
    var NON_ASCII_RX = /[^\x00-\x7f]/;
    var DOMAIN_CONTROL_RX = /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/;
    var TLD_SEGMENT_RX = /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    var DOMAIN_SEGMENT_RX = /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    var DOMAIN_UNDERSCORE_SEGMENT_RX = /^[a-zA-Z0-9_](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    var URL_IMPL = Url.URL || URL;
    function isTldsAllow(tlds) {
      return !!tlds.allow;
    }
    function analyzeDomain(domain, options3 = {}) {
      if (!domain) {
        return (0, errors_1.errorCode)("DOMAIN_NON_EMPTY_STRING");
      }
      if (typeof domain !== "string") {
        throw new Error("Invalid input: domain must be a string");
      }
      if (domain.length > 256) {
        return (0, errors_1.errorCode)("DOMAIN_TOO_LONG");
      }
      const ascii = !NON_ASCII_RX.test(domain);
      if (!ascii) {
        if (options3.allowUnicode === false) {
          return (0, errors_1.errorCode)("DOMAIN_INVALID_UNICODE_CHARS");
        }
        domain = domain.normalize("NFC");
      }
      if (DOMAIN_CONTROL_RX.test(domain)) {
        return (0, errors_1.errorCode)("DOMAIN_INVALID_CHARS");
      }
      domain = punycode(domain);
      if (options3.allowFullyQualified && domain[domain.length - 1] === ".") {
        domain = domain.slice(0, -1);
      }
      const minDomainSegments = options3.minDomainSegments || MIN_DOMAIN_SEGMENTS;
      const segments = domain.split(".");
      if (segments.length < minDomainSegments) {
        return (0, errors_1.errorCode)("DOMAIN_SEGMENTS_COUNT");
      }
      if (options3.maxDomainSegments) {
        if (segments.length > options3.maxDomainSegments) {
          return (0, errors_1.errorCode)("DOMAIN_SEGMENTS_COUNT_MAX");
        }
      }
      const tlds = options3.tlds;
      if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (isTldsAllow(tlds)) {
          if (!tlds.allow.has(tld)) {
            return (0, errors_1.errorCode)("DOMAIN_FORBIDDEN_TLDS");
          }
        } else if (tlds.deny.has(tld)) {
          return (0, errors_1.errorCode)("DOMAIN_FORBIDDEN_TLDS");
        }
      }
      for (let i2 = 0; i2 < segments.length; ++i2) {
        const segment = segments[i2];
        if (!segment.length) {
          return (0, errors_1.errorCode)("DOMAIN_EMPTY_SEGMENT");
        }
        if (segment.length > 63) {
          return (0, errors_1.errorCode)("DOMAIN_LONG_SEGMENT");
        }
        if (i2 < segments.length - 1) {
          if (options3.allowUnderscore) {
            if (!DOMAIN_UNDERSCORE_SEGMENT_RX.test(segment)) {
              return (0, errors_1.errorCode)("DOMAIN_INVALID_CHARS");
            }
          } else {
            if (!DOMAIN_SEGMENT_RX.test(segment)) {
              return (0, errors_1.errorCode)("DOMAIN_INVALID_CHARS");
            }
          }
        } else {
          if (!TLD_SEGMENT_RX.test(segment)) {
            return (0, errors_1.errorCode)("DOMAIN_INVALID_TLDS_CHARS");
          }
        }
      }
      return null;
    }
    exports2.analyzeDomain = analyzeDomain;
    function isDomainValid(domain, options3) {
      return !analyzeDomain(domain, options3);
    }
    exports2.isDomainValid = isDomainValid;
    function punycode(domain) {
      if (domain.includes("%")) {
        domain = domain.replace(/%/g, "%25");
      }
      try {
        return new URL_IMPL(`http://${domain}`).host;
      } catch (err) {
        return domain;
      }
    }
    function validateDomainOptions(options3) {
      if (!options3) {
        return;
      }
      if (typeof options3.tlds !== "object") {
        throw new Error("Invalid options: tlds must be a boolean or an object");
      }
      if (isTldsAllow(options3.tlds)) {
        if (options3.tlds.allow instanceof Set === false) {
          throw new Error("Invalid options: tlds.allow must be a Set object or true");
        }
        if (options3.tlds.deny) {
          throw new Error("Invalid options: cannot specify both tlds.allow and tlds.deny lists");
        }
      } else {
        if (options3.tlds.deny instanceof Set === false) {
          throw new Error("Invalid options: tlds.deny must be a Set object");
        }
      }
    }
    exports2.validateDomainOptions = validateDomainOptions;
  }
});
var require_email = __commonJS({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/dist/email.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmailValid = exports2.analyzeEmail = void 0;
    var Util = __require2("util");
    var domain_1 = require_domain();
    var errors_1 = require_errors3();
    var NON_ASCII_RX = /[^\x00-\x7f]/;
    var ENCODER_IMPL = new (Util.TextEncoder || TextEncoder)();
    function analyzeEmail(email2, options3) {
      return validateEmail(email2, options3);
    }
    exports2.analyzeEmail = analyzeEmail;
    function isEmailValid(email2, options3) {
      return !validateEmail(email2, options3);
    }
    exports2.isEmailValid = isEmailValid;
    function validateEmail(email2, options3 = {}) {
      if (typeof email2 !== "string") {
        throw new Error("Invalid input: email must be a string");
      }
      if (!email2) {
        return (0, errors_1.errorCode)("EMPTY_STRING");
      }
      const ascii = !NON_ASCII_RX.test(email2);
      if (!ascii) {
        if (options3.allowUnicode === false) {
          return (0, errors_1.errorCode)("FORBIDDEN_UNICODE");
        }
        email2 = email2.normalize("NFC");
      }
      const parts = email2.split("@");
      if (parts.length !== 2) {
        return parts.length > 2 ? (0, errors_1.errorCode)("MULTIPLE_AT_CHAR") : (0, errors_1.errorCode)("MISSING_AT_CHAR");
      }
      const [local, domain] = parts;
      if (!local) {
        return (0, errors_1.errorCode)("EMPTY_LOCAL");
      }
      if (!options3.ignoreLength) {
        if (email2.length > 254) {
          return (0, errors_1.errorCode)("ADDRESS_TOO_LONG");
        }
        if (ENCODER_IMPL.encode(local).length > 64) {
          return (0, errors_1.errorCode)("LOCAL_TOO_LONG");
        }
      }
      return validateLocal(local, ascii) || (0, domain_1.analyzeDomain)(domain, options3);
    }
    function validateLocal(local, ascii) {
      const segments = local.split(".");
      for (const segment of segments) {
        if (!segment.length) {
          return (0, errors_1.errorCode)("EMPTY_LOCAL_SEGMENT");
        }
        if (ascii) {
          if (!ATEXT_RX.test(segment)) {
            return (0, errors_1.errorCode)("INVALID_LOCAL_CHARS");
          }
          continue;
        }
        for (const char of segment) {
          if (ATEXT_RX.test(char)) {
            continue;
          }
          const binary = toBinary(char);
          if (!ATOM_RX.test(binary)) {
            return (0, errors_1.errorCode)("INVALID_LOCAL_CHARS");
          }
        }
      }
      return null;
    }
    function toBinary(char) {
      return Array.from(ENCODER_IMPL.encode(char), (v2) => String.fromCharCode(v2)).join("");
    }
    var ATEXT_RX = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
    var ATOM_RX = new RegExp([
      //  %xC2-DF UTF8-tail
      "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
      //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
      "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
      //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
      "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
    ].join("|"));
  }
});
var require_uri = __commonJS({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/dist/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uriRegex = exports2.ipVersions = void 0;
    var hoek_1 = require_lib();
    function generate() {
      const rfc39862 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const pctEncoded = "%" + hexDigit;
      const pchar = unreserved + pctEncoded + subDelims + ":@";
      const pcharOnly = "[" + pchar + "]";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc39862.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc39862.ipv4address + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc39862.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc39862.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc39862.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc39862.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      rfc39862.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
      rfc39862.schemeRegex = new RegExp(rfc39862.scheme);
      const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      const IPLiteral = "\\[(?:" + rfc39862.ipv6address + "|" + rfc39862.ipvFuture + ")\\]";
      const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
      const host = "(?:" + IPLiteral + "|" + rfc39862.ipv4address + "|" + regName + ")";
      const port = "\\d*";
      const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
      const segment = pcharOnly + "*";
      const segmentNz = pcharOnly + "+";
      const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
      const pathEmpty = "";
      const pathAbEmpty = "(?:\\/" + segment + ")*";
      const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      const pathRootless = segmentNz + pathAbEmpty;
      const pathNoScheme = segmentNzNc + pathAbEmpty;
      const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
      rfc39862.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
      rfc39862.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
      rfc39862.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc39862.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc39862.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      rfc39862.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
      rfc39862.fragment = "[" + pchar + "\\/\\?]*";
      return rfc39862;
    }
    var rfc3986 = generate();
    exports2.ipVersions = {
      v4Cidr: rfc3986.ipv4Cidr,
      v6Cidr: rfc3986.ipv6Cidr,
      ipv4: rfc3986.ipv4address,
      ipv6: rfc3986.ipv6address,
      ipvfuture: rfc3986.ipvFuture
    };
    function createRegex(options3) {
      const rfc = rfc3986;
      const query = options3.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
      const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
      const relative22 = options3.domain ? rfc.relativeRefCapture : rfc.relativeRef;
      if (options3.relativeOnly) {
        return wrap(relative22 + suffix);
      }
      let customScheme = "";
      if (options3.scheme) {
        (0, hoek_1.assert)(options3.scheme instanceof RegExp || typeof options3.scheme === "string" || Array.isArray(options3.scheme), "scheme must be a RegExp, String, or Array");
        const schemes = [].concat(options3.scheme);
        (0, hoek_1.assert)(schemes.length >= 1, "scheme must have at least 1 scheme specified");
        const selections = [];
        for (let i2 = 0; i2 < schemes.length; ++i2) {
          const scheme2 = schemes[i2];
          (0, hoek_1.assert)(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i2 + " must be a RegExp or String");
          if (scheme2 instanceof RegExp) {
            selections.push(scheme2.source.toString());
          } else {
            (0, hoek_1.assert)(rfc.schemeRegex.test(scheme2), "scheme at position " + i2 + " must be a valid scheme");
            selections.push((0, hoek_1.escapeRegex)(scheme2));
          }
        }
        customScheme = selections.join("|");
      }
      const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
      const absolute = "(?:" + scheme + ":" + (options3.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
      const prefix = options3.allowRelative ? "(?:" + absolute + "|" + relative22 + ")" : absolute;
      return wrap(prefix + suffix, customScheme);
    }
    function wrap(raw, scheme = null) {
      raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
      return {
        raw,
        regex: new RegExp(`^${raw}$`),
        scheme
      };
    }
    var genericUriRegex = createRegex({});
    function uriRegex(options3 = {}) {
      if (options3.scheme || options3.allowRelative || options3.relativeOnly || options3.allowQuerySquareBrackets || options3.domain) {
        return createRegex(options3);
      }
      return genericUriRegex;
    }
    exports2.uriRegex = uriRegex;
  }
});
var require_ip = __commonJS({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/dist/ip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipRegex = void 0;
    var hoek_1 = require_lib();
    var uri_1 = require_uri();
    function ipRegex(options3 = {}) {
      const cidr = options3.cidr || "optional";
      (0, hoek_1.assert)(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
      (0, hoek_1.assert)(options3.version === void 0 || typeof options3.version === "string" || Array.isArray(options3.version), "options.version must be a string or an array of string");
      let versions = options3.version || ["ipv4", "ipv6", "ipvfuture"];
      if (!Array.isArray(versions)) {
        versions = [versions];
      }
      (0, hoek_1.assert)(versions.length >= 1, "options.version must have at least 1 version specified");
      for (const version4 of versions) {
        (0, hoek_1.assert)(typeof version4 === "string" && version4 === version4.toLowerCase(), "Invalid options.version value");
        (0, hoek_1.assert)(["ipv4", "ipv6", "ipvfuture"].includes(version4), "options.version contains unknown version " + version4 + " - must be one of ipv4, ipv6, ipvfuture");
      }
      versions = Array.from(new Set(versions));
      const parts = versions.map((version4) => {
        if (cidr === "forbidden") {
          return uri_1.ipVersions[version4];
        }
        const cidrpart = `\\/${version4 === "ipv4" ? uri_1.ipVersions.v4Cidr : uri_1.ipVersions.v6Cidr}`;
        if (cidr === "required") {
          return `${uri_1.ipVersions[version4]}${cidrpart}`;
        }
        return `${uri_1.ipVersions[version4]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      const regex = new RegExp(`^${raw}$`);
      return { cidr, versions, regex, raw };
    }
    exports2.ipRegex = ipRegex;
  }
});
var require_decode2 = __commonJS({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/dist/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uriDecode = void 0;
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    var UTF8 = {
      accept: 12,
      reject: 0,
      data: [
        // Maps bytes to character to a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // Maps a state to a new state when adding a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // Maps the current transition to a mask that needs to apply to the byte
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ]
    };
    function uriDecode(string3) {
      let percentPos = string3.indexOf("%");
      if (percentPos === -1) {
        return string3;
      }
      let decoded = "";
      let last = 0;
      let codepoint = 0;
      let startOfOctets = percentPos;
      let state = UTF8.accept;
      while (percentPos > -1 && percentPos < string3.length) {
        const high = resolveHex(string3[percentPos + 1], 4);
        const low = resolveHex(string3[percentPos + 2], 0);
        const byte = high | low;
        const type = UTF8.data[byte];
        state = UTF8.data[256 + state + type];
        codepoint = codepoint << 6 | byte & UTF8.data[364 + type];
        if (state === UTF8.accept) {
          decoded += string3.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
          codepoint = 0;
          last = percentPos + 3;
          percentPos = string3.indexOf("%", last);
          startOfOctets = percentPos;
          continue;
        }
        if (state === UTF8.reject) {
          return null;
        }
        percentPos += 3;
        if (percentPos >= string3.length || string3[percentPos] !== "%") {
          return null;
        }
      }
      return decoded + string3.slice(last);
    }
    exports2.uriDecode = uriDecode;
    function resolveHex(char, shift) {
      const i2 = HEX[char];
      return i2 === void 0 ? 255 : i2 << shift;
    }
  }
});
var require_dist = __commonJS({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p in m3) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m3, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uriDecode = exports2.uriRegex = exports2.ipRegex = exports2.errorCodes = void 0;
    __exportStar(require_domain(), exports2);
    __exportStar(require_email(), exports2);
    var errors_1 = require_errors3();
    Object.defineProperty(exports2, "errorCodes", { enumerable: true, get: function() {
      return errors_1.errorCodes;
    } });
    var ip_1 = require_ip();
    Object.defineProperty(exports2, "ipRegex", { enumerable: true, get: function() {
      return ip_1.ipRegex;
    } });
    var uri_1 = require_uri();
    Object.defineProperty(exports2, "uriRegex", { enumerable: true, get: function() {
      return uri_1.uriRegex;
    } });
    var decode_1 = require_decode2();
    Object.defineProperty(exports2, "uriDecode", { enumerable: true, get: function() {
      return decode_1.uriDecode;
    } });
  }
});
var require_tlds = __commonJS({
  "node_modules/.deno/@hapi+tlds@1.1.3/node_modules/@hapi/tlds/dist/commonjs/tlds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TLDS = void 0;
    exports2.TLDS = [
      "AAA",
      "AARP",
      "ABB",
      "ABBOTT",
      "ABBVIE",
      "ABC",
      "ABLE",
      "ABOGADO",
      "ABUDHABI",
      "AC",
      "ACADEMY",
      "ACCENTURE",
      "ACCOUNTANT",
      "ACCOUNTANTS",
      "ACO",
      "ACTOR",
      "AD",
      "ADS",
      "ADULT",
      "AE",
      "AEG",
      "AERO",
      "AETNA",
      "AF",
      "AFL",
      "AFRICA",
      "AG",
      "AGAKHAN",
      "AGENCY",
      "AI",
      "AIG",
      "AIRBUS",
      "AIRFORCE",
      "AIRTEL",
      "AKDN",
      "AL",
      "ALIBABA",
      "ALIPAY",
      "ALLFINANZ",
      "ALLSTATE",
      "ALLY",
      "ALSACE",
      "ALSTOM",
      "AM",
      "AMAZON",
      "AMERICANEXPRESS",
      "AMERICANFAMILY",
      "AMEX",
      "AMFAM",
      "AMICA",
      "AMSTERDAM",
      "ANALYTICS",
      "ANDROID",
      "ANQUAN",
      "ANZ",
      "AO",
      "AOL",
      "APARTMENTS",
      "APP",
      "APPLE",
      "AQ",
      "AQUARELLE",
      "AR",
      "ARAB",
      "ARAMCO",
      "ARCHI",
      "ARMY",
      "ARPA",
      "ART",
      "ARTE",
      "AS",
      "ASDA",
      "ASIA",
      "ASSOCIATES",
      "AT",
      "ATHLETA",
      "ATTORNEY",
      "AU",
      "AUCTION",
      "AUDI",
      "AUDIBLE",
      "AUDIO",
      "AUSPOST",
      "AUTHOR",
      "AUTO",
      "AUTOS",
      "AW",
      "AWS",
      "AX",
      "AXA",
      "AZ",
      "AZURE",
      "BA",
      "BABY",
      "BAIDU",
      "BANAMEX",
      "BAND",
      "BANK",
      "BAR",
      "BARCELONA",
      "BARCLAYCARD",
      "BARCLAYS",
      "BAREFOOT",
      "BARGAINS",
      "BASEBALL",
      "BASKETBALL",
      "BAUHAUS",
      "BAYERN",
      "BB",
      "BBC",
      "BBT",
      "BBVA",
      "BCG",
      "BCN",
      "BD",
      "BE",
      "BEATS",
      "BEAUTY",
      "BEER",
      "BERLIN",
      "BEST",
      "BESTBUY",
      "BET",
      "BF",
      "BG",
      "BH",
      "BHARTI",
      "BI",
      "BIBLE",
      "BID",
      "BIKE",
      "BING",
      "BINGO",
      "BIO",
      "BIZ",
      "BJ",
      "BLACK",
      "BLACKFRIDAY",
      "BLOCKBUSTER",
      "BLOG",
      "BLOOMBERG",
      "BLUE",
      "BM",
      "BMS",
      "BMW",
      "BN",
      "BNPPARIBAS",
      "BO",
      "BOATS",
      "BOEHRINGER",
      "BOFA",
      "BOM",
      "BOND",
      "BOO",
      "BOOK",
      "BOOKING",
      "BOSCH",
      "BOSTIK",
      "BOSTON",
      "BOT",
      "BOUTIQUE",
      "BOX",
      "BR",
      "BRADESCO",
      "BRIDGESTONE",
      "BROADWAY",
      "BROKER",
      "BROTHER",
      "BRUSSELS",
      "BS",
      "BT",
      "BUILD",
      "BUILDERS",
      "BUSINESS",
      "BUY",
      "BUZZ",
      "BV",
      "BW",
      "BY",
      "BZ",
      "BZH",
      "CA",
      "CAB",
      "CAFE",
      "CAL",
      "CALL",
      "CALVINKLEIN",
      "CAM",
      "CAMERA",
      "CAMP",
      "CANON",
      "CAPETOWN",
      "CAPITAL",
      "CAPITALONE",
      "CAR",
      "CARAVAN",
      "CARDS",
      "CARE",
      "CAREER",
      "CAREERS",
      "CARS",
      "CASA",
      "CASE",
      "CASH",
      "CASINO",
      "CAT",
      "CATERING",
      "CATHOLIC",
      "CBA",
      "CBN",
      "CBRE",
      "CC",
      "CD",
      "CENTER",
      "CEO",
      "CERN",
      "CF",
      "CFA",
      "CFD",
      "CG",
      "CH",
      "CHANEL",
      "CHANNEL",
      "CHARITY",
      "CHASE",
      "CHAT",
      "CHEAP",
      "CHINTAI",
      "CHRISTMAS",
      "CHROME",
      "CHURCH",
      "CI",
      "CIPRIANI",
      "CIRCLE",
      "CISCO",
      "CITADEL",
      "CITI",
      "CITIC",
      "CITY",
      "CK",
      "CL",
      "CLAIMS",
      "CLEANING",
      "CLICK",
      "CLINIC",
      "CLINIQUE",
      "CLOTHING",
      "CLOUD",
      "CLUB",
      "CLUBMED",
      "CM",
      "CN",
      "CO",
      "COACH",
      "CODES",
      "COFFEE",
      "COLLEGE",
      "COLOGNE",
      "COM",
      "COMMBANK",
      "COMMUNITY",
      "COMPANY",
      "COMPARE",
      "COMPUTER",
      "COMSEC",
      "CONDOS",
      "CONSTRUCTION",
      "CONSULTING",
      "CONTACT",
      "CONTRACTORS",
      "COOKING",
      "COOL",
      "COOP",
      "CORSICA",
      "COUNTRY",
      "COUPON",
      "COUPONS",
      "COURSES",
      "CPA",
      "CR",
      "CREDIT",
      "CREDITCARD",
      "CREDITUNION",
      "CRICKET",
      "CROWN",
      "CRS",
      "CRUISE",
      "CRUISES",
      "CU",
      "CUISINELLA",
      "CV",
      "CW",
      "CX",
      "CY",
      "CYMRU",
      "CYOU",
      "CZ",
      "DAD",
      "DANCE",
      "DATA",
      "DATE",
      "DATING",
      "DATSUN",
      "DAY",
      "DCLK",
      "DDS",
      "DE",
      "DEAL",
      "DEALER",
      "DEALS",
      "DEGREE",
      "DELIVERY",
      "DELL",
      "DELOITTE",
      "DELTA",
      "DEMOCRAT",
      "DENTAL",
      "DENTIST",
      "DESI",
      "DESIGN",
      "DEV",
      "DHL",
      "DIAMONDS",
      "DIET",
      "DIGITAL",
      "DIRECT",
      "DIRECTORY",
      "DISCOUNT",
      "DISCOVER",
      "DISH",
      "DIY",
      "DJ",
      "DK",
      "DM",
      "DNP",
      "DO",
      "DOCS",
      "DOCTOR",
      "DOG",
      "DOMAINS",
      "DOT",
      "DOWNLOAD",
      "DRIVE",
      "DTV",
      "DUBAI",
      "DUNLOP",
      "DUPONT",
      "DURBAN",
      "DVAG",
      "DVR",
      "DZ",
      "EARTH",
      "EAT",
      "EC",
      "ECO",
      "EDEKA",
      "EDU",
      "EDUCATION",
      "EE",
      "EG",
      "EMAIL",
      "EMERCK",
      "ENERGY",
      "ENGINEER",
      "ENGINEERING",
      "ENTERPRISES",
      "EPSON",
      "EQUIPMENT",
      "ER",
      "ERICSSON",
      "ERNI",
      "ES",
      "ESQ",
      "ESTATE",
      "ET",
      "EU",
      "EUROVISION",
      "EUS",
      "EVENTS",
      "EXCHANGE",
      "EXPERT",
      "EXPOSED",
      "EXPRESS",
      "EXTRASPACE",
      "FAGE",
      "FAIL",
      "FAIRWINDS",
      "FAITH",
      "FAMILY",
      "FAN",
      "FANS",
      "FARM",
      "FARMERS",
      "FASHION",
      "FAST",
      "FEDEX",
      "FEEDBACK",
      "FERRARI",
      "FERRERO",
      "FI",
      "FIDELITY",
      "FIDO",
      "FILM",
      "FINAL",
      "FINANCE",
      "FINANCIAL",
      "FIRE",
      "FIRESTONE",
      "FIRMDALE",
      "FISH",
      "FISHING",
      "FIT",
      "FITNESS",
      "FJ",
      "FK",
      "FLICKR",
      "FLIGHTS",
      "FLIR",
      "FLORIST",
      "FLOWERS",
      "FLY",
      "FM",
      "FO",
      "FOO",
      "FOOD",
      "FOOTBALL",
      "FORD",
      "FOREX",
      "FORSALE",
      "FORUM",
      "FOUNDATION",
      "FOX",
      "FR",
      "FREE",
      "FRESENIUS",
      "FRL",
      "FROGANS",
      "FRONTIER",
      "FTR",
      "FUJITSU",
      "FUN",
      "FUND",
      "FURNITURE",
      "FUTBOL",
      "FYI",
      "GA",
      "GAL",
      "GALLERY",
      "GALLO",
      "GALLUP",
      "GAME",
      "GAMES",
      "GAP",
      "GARDEN",
      "GAY",
      "GB",
      "GBIZ",
      "GD",
      "GDN",
      "GE",
      "GEA",
      "GENT",
      "GENTING",
      "GEORGE",
      "GF",
      "GG",
      "GGEE",
      "GH",
      "GI",
      "GIFT",
      "GIFTS",
      "GIVES",
      "GIVING",
      "GL",
      "GLASS",
      "GLE",
      "GLOBAL",
      "GLOBO",
      "GM",
      "GMAIL",
      "GMBH",
      "GMO",
      "GMX",
      "GN",
      "GODADDY",
      "GOLD",
      "GOLDPOINT",
      "GOLF",
      "GOO",
      "GOODYEAR",
      "GOOG",
      "GOOGLE",
      "GOP",
      "GOT",
      "GOV",
      "GP",
      "GQ",
      "GR",
      "GRAINGER",
      "GRAPHICS",
      "GRATIS",
      "GREEN",
      "GRIPE",
      "GROCERY",
      "GROUP",
      "GS",
      "GT",
      "GU",
      "GUCCI",
      "GUGE",
      "GUIDE",
      "GUITARS",
      "GURU",
      "GW",
      "GY",
      "HAIR",
      "HAMBURG",
      "HANGOUT",
      "HAUS",
      "HBO",
      "HDFC",
      "HDFCBANK",
      "HEALTH",
      "HEALTHCARE",
      "HELP",
      "HELSINKI",
      "HERE",
      "HERMES",
      "HIPHOP",
      "HISAMITSU",
      "HITACHI",
      "HIV",
      "HK",
      "HKT",
      "HM",
      "HN",
      "HOCKEY",
      "HOLDINGS",
      "HOLIDAY",
      "HOMEDEPOT",
      "HOMEGOODS",
      "HOMES",
      "HOMESENSE",
      "HONDA",
      "HORSE",
      "HOSPITAL",
      "HOST",
      "HOSTING",
      "HOT",
      "HOTELS",
      "HOTMAIL",
      "HOUSE",
      "HOW",
      "HR",
      "HSBC",
      "HT",
      "HU",
      "HUGHES",
      "HYATT",
      "HYUNDAI",
      "IBM",
      "ICBC",
      "ICE",
      "ICU",
      "ID",
      "IE",
      "IEEE",
      "IFM",
      "IKANO",
      "IL",
      "IM",
      "IMAMAT",
      "IMDB",
      "IMMO",
      "IMMOBILIEN",
      "IN",
      "INC",
      "INDUSTRIES",
      "INFINITI",
      "INFO",
      "ING",
      "INK",
      "INSTITUTE",
      "INSURANCE",
      "INSURE",
      "INT",
      "INTERNATIONAL",
      "INTUIT",
      "INVESTMENTS",
      "IO",
      "IPIRANGA",
      "IQ",
      "IR",
      "IRISH",
      "IS",
      "ISMAILI",
      "IST",
      "ISTANBUL",
      "IT",
      "ITAU",
      "ITV",
      "JAGUAR",
      "JAVA",
      "JCB",
      "JE",
      "JEEP",
      "JETZT",
      "JEWELRY",
      "JIO",
      "JLL",
      "JM",
      "JMP",
      "JNJ",
      "JO",
      "JOBS",
      "JOBURG",
      "JOT",
      "JOY",
      "JP",
      "JPMORGAN",
      "JPRS",
      "JUEGOS",
      "JUNIPER",
      "KAUFEN",
      "KDDI",
      "KE",
      "KERRYHOTELS",
      "KERRYPROPERTIES",
      "KFH",
      "KG",
      "KH",
      "KI",
      "KIA",
      "KIDS",
      "KIM",
      "KINDLE",
      "KITCHEN",
      "KIWI",
      "KM",
      "KN",
      "KOELN",
      "KOMATSU",
      "KOSHER",
      "KP",
      "KPMG",
      "KPN",
      "KR",
      "KRD",
      "KRED",
      "KUOKGROUP",
      "KW",
      "KY",
      "KYOTO",
      "KZ",
      "LA",
      "LACAIXA",
      "LAMBORGHINI",
      "LAMER",
      "LAND",
      "LANDROVER",
      "LANXESS",
      "LASALLE",
      "LAT",
      "LATINO",
      "LATROBE",
      "LAW",
      "LAWYER",
      "LB",
      "LC",
      "LDS",
      "LEASE",
      "LECLERC",
      "LEFRAK",
      "LEGAL",
      "LEGO",
      "LEXUS",
      "LGBT",
      "LI",
      "LIDL",
      "LIFE",
      "LIFEINSURANCE",
      "LIFESTYLE",
      "LIGHTING",
      "LIKE",
      "LILLY",
      "LIMITED",
      "LIMO",
      "LINCOLN",
      "LINK",
      "LIVE",
      "LIVING",
      "LK",
      "LLC",
      "LLP",
      "LOAN",
      "LOANS",
      "LOCKER",
      "LOCUS",
      "LOL",
      "LONDON",
      "LOTTE",
      "LOTTO",
      "LOVE",
      "LPL",
      "LPLFINANCIAL",
      "LR",
      "LS",
      "LT",
      "LTD",
      "LTDA",
      "LU",
      "LUNDBECK",
      "LUXE",
      "LUXURY",
      "LV",
      "LY",
      "MA",
      "MADRID",
      "MAIF",
      "MAISON",
      "MAKEUP",
      "MAN",
      "MANAGEMENT",
      "MANGO",
      "MAP",
      "MARKET",
      "MARKETING",
      "MARKETS",
      "MARRIOTT",
      "MARSHALLS",
      "MATTEL",
      "MBA",
      "MC",
      "MCKINSEY",
      "MD",
      "ME",
      "MED",
      "MEDIA",
      "MEET",
      "MELBOURNE",
      "MEME",
      "MEMORIAL",
      "MEN",
      "MENU",
      "MERCKMSD",
      "MG",
      "MH",
      "MIAMI",
      "MICROSOFT",
      "MIL",
      "MINI",
      "MINT",
      "MIT",
      "MITSUBISHI",
      "MK",
      "ML",
      "MLB",
      "MLS",
      "MM",
      "MMA",
      "MN",
      "MO",
      "MOBI",
      "MOBILE",
      "MODA",
      "MOE",
      "MOI",
      "MOM",
      "MONASH",
      "MONEY",
      "MONSTER",
      "MORMON",
      "MORTGAGE",
      "MOSCOW",
      "MOTO",
      "MOTORCYCLES",
      "MOV",
      "MOVIE",
      "MP",
      "MQ",
      "MR",
      "MS",
      "MSD",
      "MT",
      "MTN",
      "MTR",
      "MU",
      "MUSEUM",
      "MUSIC",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NAB",
      "NAGOYA",
      "NAME",
      "NAVY",
      "NBA",
      "NC",
      "NE",
      "NEC",
      "NET",
      "NETBANK",
      "NETFLIX",
      "NETWORK",
      "NEUSTAR",
      "NEW",
      "NEWS",
      "NEXT",
      "NEXTDIRECT",
      "NEXUS",
      "NF",
      "NFL",
      "NG",
      "NGO",
      "NHK",
      "NI",
      "NICO",
      "NIKE",
      "NIKON",
      "NINJA",
      "NISSAN",
      "NISSAY",
      "NL",
      "NO",
      "NOKIA",
      "NORTON",
      "NOW",
      "NOWRUZ",
      "NOWTV",
      "NP",
      "NR",
      "NRA",
      "NRW",
      "NTT",
      "NU",
      "NYC",
      "NZ",
      "OBI",
      "OBSERVER",
      "OFFICE",
      "OKINAWA",
      "OLAYAN",
      "OLAYANGROUP",
      "OLLO",
      "OM",
      "OMEGA",
      "ONE",
      "ONG",
      "ONL",
      "ONLINE",
      "OOO",
      "OPEN",
      "ORACLE",
      "ORANGE",
      "ORG",
      "ORGANIC",
      "ORIGINS",
      "OSAKA",
      "OTSUKA",
      "OTT",
      "OVH",
      "PA",
      "PAGE",
      "PANASONIC",
      "PARIS",
      "PARS",
      "PARTNERS",
      "PARTS",
      "PARTY",
      "PAY",
      "PCCW",
      "PE",
      "PET",
      "PF",
      "PFIZER",
      "PG",
      "PH",
      "PHARMACY",
      "PHD",
      "PHILIPS",
      "PHONE",
      "PHOTO",
      "PHOTOGRAPHY",
      "PHOTOS",
      "PHYSIO",
      "PICS",
      "PICTET",
      "PICTURES",
      "PID",
      "PIN",
      "PING",
      "PINK",
      "PIONEER",
      "PIZZA",
      "PK",
      "PL",
      "PLACE",
      "PLAY",
      "PLAYSTATION",
      "PLUMBING",
      "PLUS",
      "PM",
      "PN",
      "PNC",
      "POHL",
      "POKER",
      "POLITIE",
      "PORN",
      "POST",
      "PR",
      "PRAXI",
      "PRESS",
      "PRIME",
      "PRO",
      "PROD",
      "PRODUCTIONS",
      "PROF",
      "PROGRESSIVE",
      "PROMO",
      "PROPERTIES",
      "PROPERTY",
      "PROTECTION",
      "PRU",
      "PRUDENTIAL",
      "PS",
      "PT",
      "PUB",
      "PW",
      "PWC",
      "PY",
      "QA",
      "QPON",
      "QUEBEC",
      "QUEST",
      "RACING",
      "RADIO",
      "RE",
      "READ",
      "REALESTATE",
      "REALTOR",
      "REALTY",
      "RECIPES",
      "RED",
      "REDUMBRELLA",
      "REHAB",
      "REISE",
      "REISEN",
      "REIT",
      "RELIANCE",
      "REN",
      "RENT",
      "RENTALS",
      "REPAIR",
      "REPORT",
      "REPUBLICAN",
      "REST",
      "RESTAURANT",
      "REVIEW",
      "REVIEWS",
      "REXROTH",
      "RICH",
      "RICHARDLI",
      "RICOH",
      "RIL",
      "RIO",
      "RIP",
      "RO",
      "ROCKS",
      "RODEO",
      "ROGERS",
      "ROOM",
      "RS",
      "RSVP",
      "RU",
      "RUGBY",
      "RUHR",
      "RUN",
      "RW",
      "RWE",
      "RYUKYU",
      "SA",
      "SAARLAND",
      "SAFE",
      "SAFETY",
      "SAKURA",
      "SALE",
      "SALON",
      "SAMSCLUB",
      "SAMSUNG",
      "SANDVIK",
      "SANDVIKCOROMANT",
      "SANOFI",
      "SAP",
      "SARL",
      "SAS",
      "SAVE",
      "SAXO",
      "SB",
      "SBI",
      "SBS",
      "SC",
      "SCB",
      "SCHAEFFLER",
      "SCHMIDT",
      "SCHOLARSHIPS",
      "SCHOOL",
      "SCHULE",
      "SCHWARZ",
      "SCIENCE",
      "SCOT",
      "SD",
      "SE",
      "SEARCH",
      "SEAT",
      "SECURE",
      "SECURITY",
      "SEEK",
      "SELECT",
      "SENER",
      "SERVICES",
      "SEVEN",
      "SEW",
      "SEX",
      "SEXY",
      "SFR",
      "SG",
      "SH",
      "SHANGRILA",
      "SHARP",
      "SHELL",
      "SHIA",
      "SHIKSHA",
      "SHOES",
      "SHOP",
      "SHOPPING",
      "SHOUJI",
      "SHOW",
      "SI",
      "SILK",
      "SINA",
      "SINGLES",
      "SITE",
      "SJ",
      "SK",
      "SKI",
      "SKIN",
      "SKY",
      "SKYPE",
      "SL",
      "SLING",
      "SM",
      "SMART",
      "SMILE",
      "SN",
      "SNCF",
      "SO",
      "SOCCER",
      "SOCIAL",
      "SOFTBANK",
      "SOFTWARE",
      "SOHU",
      "SOLAR",
      "SOLUTIONS",
      "SONG",
      "SONY",
      "SOY",
      "SPA",
      "SPACE",
      "SPORT",
      "SPOT",
      "SR",
      "SRL",
      "SS",
      "ST",
      "STADA",
      "STAPLES",
      "STAR",
      "STATEBANK",
      "STATEFARM",
      "STC",
      "STCGROUP",
      "STOCKHOLM",
      "STORAGE",
      "STORE",
      "STREAM",
      "STUDIO",
      "STUDY",
      "STYLE",
      "SU",
      "SUCKS",
      "SUPPLIES",
      "SUPPLY",
      "SUPPORT",
      "SURF",
      "SURGERY",
      "SUZUKI",
      "SV",
      "SWATCH",
      "SWISS",
      "SX",
      "SY",
      "SYDNEY",
      "SYSTEMS",
      "SZ",
      "TAB",
      "TAIPEI",
      "TALK",
      "TAOBAO",
      "TARGET",
      "TATAMOTORS",
      "TATAR",
      "TATTOO",
      "TAX",
      "TAXI",
      "TC",
      "TCI",
      "TD",
      "TDK",
      "TEAM",
      "TECH",
      "TECHNOLOGY",
      "TEL",
      "TEMASEK",
      "TENNIS",
      "TEVA",
      "TF",
      "TG",
      "TH",
      "THD",
      "THEATER",
      "THEATRE",
      "TIAA",
      "TICKETS",
      "TIENDA",
      "TIPS",
      "TIRES",
      "TIROL",
      "TJ",
      "TJMAXX",
      "TJX",
      "TK",
      "TKMAXX",
      "TL",
      "TM",
      "TMALL",
      "TN",
      "TO",
      "TODAY",
      "TOKYO",
      "TOOLS",
      "TOP",
      "TORAY",
      "TOSHIBA",
      "TOTAL",
      "TOURS",
      "TOWN",
      "TOYOTA",
      "TOYS",
      "TR",
      "TRADE",
      "TRADING",
      "TRAINING",
      "TRAVEL",
      "TRAVELERS",
      "TRAVELERSINSURANCE",
      "TRUST",
      "TRV",
      "TT",
      "TUBE",
      "TUI",
      "TUNES",
      "TUSHU",
      "TV",
      "TVS",
      "TW",
      "TZ",
      "UA",
      "UBANK",
      "UBS",
      "UG",
      "UK",
      "UNICOM",
      "UNIVERSITY",
      "UNO",
      "UOL",
      "UPS",
      "US",
      "UY",
      "UZ",
      "VA",
      "VACATIONS",
      "VANA",
      "VANGUARD",
      "VC",
      "VE",
      "VEGAS",
      "VENTURES",
      "VERISIGN",
      "VERSICHERUNG",
      "VET",
      "VG",
      "VI",
      "VIAJES",
      "VIDEO",
      "VIG",
      "VIKING",
      "VILLAS",
      "VIN",
      "VIP",
      "VIRGIN",
      "VISA",
      "VISION",
      "VIVA",
      "VIVO",
      "VLAANDEREN",
      "VN",
      "VODKA",
      "VOLVO",
      "VOTE",
      "VOTING",
      "VOTO",
      "VOYAGE",
      "VU",
      "WALES",
      "WALMART",
      "WALTER",
      "WANG",
      "WANGGOU",
      "WATCH",
      "WATCHES",
      "WEATHER",
      "WEATHERCHANNEL",
      "WEBCAM",
      "WEBER",
      "WEBSITE",
      "WED",
      "WEDDING",
      "WEIBO",
      "WEIR",
      "WF",
      "WHOSWHO",
      "WIEN",
      "WIKI",
      "WILLIAMHILL",
      "WIN",
      "WINDOWS",
      "WINE",
      "WINNERS",
      "WME",
      "WOLTERSKLUWER",
      "WOODSIDE",
      "WORK",
      "WORKS",
      "WORLD",
      "WOW",
      "WS",
      "WTC",
      "WTF",
      "XBOX",
      "XEROX",
      "XIHUAN",
      "XIN",
      "XN--11B4C3D",
      "XN--1CK2E1B",
      "XN--1QQW23A",
      "XN--2SCRJ9C",
      "XN--30RR7Y",
      "XN--3BST00M",
      "XN--3DS443G",
      "XN--3E0B707E",
      "XN--3HCRJ9C",
      "XN--3PXU8K",
      "XN--42C2D9A",
      "XN--45BR5CYL",
      "XN--45BRJ9C",
      "XN--45Q11C",
      "XN--4DBRK0CE",
      "XN--4GBRIM",
      "XN--54B7FTA0CC",
      "XN--55QW42G",
      "XN--55QX5D",
      "XN--5SU34J936BGSG",
      "XN--5TZM5G",
      "XN--6FRZ82G",
      "XN--6QQ986B3XL",
      "XN--80ADXHKS",
      "XN--80AO21A",
      "XN--80AQECDR1A",
      "XN--80ASEHDB",
      "XN--80ASWG",
      "XN--8Y0A063A",
      "XN--90A3AC",
      "XN--90AE",
      "XN--90AIS",
      "XN--9DBQ2A",
      "XN--9ET52U",
      "XN--9KRT00A",
      "XN--B4W605FERD",
      "XN--BCK1B9A5DRE4C",
      "XN--C1AVG",
      "XN--C2BR7G",
      "XN--CCK2B3B",
      "XN--CCKWCXETD",
      "XN--CG4BKI",
      "XN--CLCHC0EA0B2G2A9GCD",
      "XN--CZR694B",
      "XN--CZRS0T",
      "XN--CZRU2D",
      "XN--D1ACJ3B",
      "XN--D1ALF",
      "XN--E1A4C",
      "XN--ECKVDTC9D",
      "XN--EFVY88H",
      "XN--FCT429K",
      "XN--FHBEI",
      "XN--FIQ228C5HS",
      "XN--FIQ64B",
      "XN--FIQS8S",
      "XN--FIQZ9S",
      "XN--FJQ720A",
      "XN--FLW351E",
      "XN--FPCRJ9C3D",
      "XN--FZC2C9E2C",
      "XN--FZYS8D69UVGM",
      "XN--G2XX48C",
      "XN--GCKR3F0F",
      "XN--GECRJ9C",
      "XN--GK3AT1E",
      "XN--H2BREG3EVE",
      "XN--H2BRJ9C",
      "XN--H2BRJ9C8C",
      "XN--HXT814E",
      "XN--I1B6B1A6A2E",
      "XN--IMR513N",
      "XN--IO0A7I",
      "XN--J1AEF",
      "XN--J1AMH",
      "XN--J6W193G",
      "XN--JLQ480N2RG",
      "XN--JVR189M",
      "XN--KCRX77D1X4A",
      "XN--KPRW13D",
      "XN--KPRY57D",
      "XN--KPUT3I",
      "XN--L1ACC",
      "XN--LGBBAT1AD8J",
      "XN--MGB9AWBF",
      "XN--MGBA3A3EJT",
      "XN--MGBA3A4F16A",
      "XN--MGBA7C0BBN0A",
      "XN--MGBAAM7A8H",
      "XN--MGBAB2BD",
      "XN--MGBAH1A3HJKRD",
      "XN--MGBAI9AZGQP6J",
      "XN--MGBAYH7GPA",
      "XN--MGBBH1A",
      "XN--MGBBH1A71E",
      "XN--MGBC0A9AZCG",
      "XN--MGBCA7DZDO",
      "XN--MGBCPQ6GPA1A",
      "XN--MGBERP4A5D4AR",
      "XN--MGBGU82A",
      "XN--MGBI4ECEXP",
      "XN--MGBPL2FH",
      "XN--MGBT3DHD",
      "XN--MGBTX2B",
      "XN--MGBX4CD0AB",
      "XN--MIX891F",
      "XN--MK1BU44C",
      "XN--MXTQ1M",
      "XN--NGBC5AZD",
      "XN--NGBE9E0A",
      "XN--NGBRX",
      "XN--NODE",
      "XN--NQV7F",
      "XN--NQV7FS00EMA",
      "XN--NYQY26A",
      "XN--O3CW4H",
      "XN--OGBPF8FL",
      "XN--OTU796D",
      "XN--P1ACF",
      "XN--P1AI",
      "XN--PGBS0DH",
      "XN--PSSY2U",
      "XN--Q7CE6A",
      "XN--Q9JYB4C",
      "XN--QCKA1PMC",
      "XN--QXA6A",
      "XN--QXAM",
      "XN--RHQV96G",
      "XN--ROVU88B",
      "XN--RVC1E0AM3E",
      "XN--S9BRJ9C",
      "XN--SES554G",
      "XN--T60B56A",
      "XN--TCKWE",
      "XN--TIQ49XQYJ",
      "XN--UNUP4Y",
      "XN--VERMGENSBERATER-CTB",
      "XN--VERMGENSBERATUNG-PWB",
      "XN--VHQUV",
      "XN--VUQ861B",
      "XN--W4R85EL8FHU5DNRA",
      "XN--W4RS40L",
      "XN--WGBH1C",
      "XN--WGBL6A",
      "XN--XHQ521B",
      "XN--XKC2AL3HYE2A",
      "XN--XKC2DL3A5EE0H",
      "XN--Y9A3AQ",
      "XN--YFRO4I67O",
      "XN--YGBI2AMMX",
      "XN--ZFR164B",
      "XXX",
      "XYZ",
      "YACHTS",
      "YAHOO",
      "YAMAXUN",
      "YANDEX",
      "YE",
      "YODOBASHI",
      "YOGA",
      "YOKOHAMA",
      "YOU",
      "YOUTUBE",
      "YT",
      "YUN",
      "ZA",
      "ZAPPOS",
      "ZARA",
      "ZERO",
      "ZIP",
      "ZM",
      "ZONE",
      "ZUERICH",
      "ZW"
    ];
  }
});
var require_commonjs = __commonJS({
  "node_modules/.deno/@hapi+tlds@1.1.3/node_modules/@hapi/tlds/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tlds = void 0;
    var tlds_js_1 = require_tlds();
    exports2.tlds = new Set(tlds_js_1.TLDS.map((tld) => tld.toLowerCase()));
  }
});
var require_string2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/string.js"(exports2, module2) {
    "use strict";
    var { assert: assert22, escapeRegex: escapeRegex2 } = require_lib();
    var { isDomainValid, isEmailValid, ipRegex, uriRegex } = require_dist();
    var Tlds = require_commonjs();
    var Any = require_any2();
    var Common = require_common2();
    var internals = {
      tlds: Tlds.tlds instanceof Set ? { tlds: { allow: Tlds.tlds, deny: null } } : false,
      // $lab:coverage:ignore$
      base64Regex: {
        // paddingRequired
        true: {
          // urlSafe
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: {
        withPrefix: /^0x[0-9a-f]+$/i,
        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
        withoutPrefix: /^[0-9a-f]+$/i
      },
      ipRegex: ipRegex({ cidr: "forbidden" }).regex,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5",
        uuidv6: "6",
        uuidv7: "7",
        uuidv8: "8"
      },
      guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]),
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
    };
    module2.exports = Any.extend({
      type: "string",
      flags: {
        insensitive: { default: false },
        truncate: { default: false }
      },
      terms: {
        replacements: { init: null }
      },
      coerce: {
        from: "string",
        method(value, { schema, state, prefs }) {
          const normalize22 = schema.$_getRule("normalize");
          if (normalize22) {
            value = value.normalize(normalize22.args.form);
          }
          const casing = schema.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema.$_terms.replacements) {
            for (const replacement of schema.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema._flags.truncate) {
            const rule = schema.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return { value };
        }
      },
      validate(value, { schema, error }) {
        if (typeof value !== "string") {
          return { value, errors: error("string.base") };
        }
        if (value === "") {
          const min = schema.$_getRule("min");
          if (min && min.args.limit === 0) {
            return;
          }
          return { value, errors: error("string.empty") };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["paddingRequired", "urlSafe"]);
            options3 = { urlSafe: false, paddingRequired: true, ...options3 };
            assert22(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            assert22(typeof options3.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({ name: "base64", args: { options: options3 } });
          },
          validate(value, helpers, { options: options3 }) {
            const regex = internals.base64Regex[options3.paddingRequired][options3.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            assert22(["lower", "upper"].includes(direction), "Invalid case:", direction);
            return this.$_addRule({ name: "case", args: { direction } });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i2 = value.length;
            let sum = 0;
            let mul = 1;
            while (i2--) {
              const char = value.charAt(i2) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["paddingRequired"]);
            options3 = { paddingRequired: true, ...options3 };
            assert22(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({ name: "dataUri", args: { options: options3 } });
          },
          validate(value, helpers, { options: options3 }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options3.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        domain: {
          method(options3) {
            if (options3) {
              Common.assertOptions(options3, ["allowFullyQualified", "allowUnicode", "allowUnderscore", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const address = internals.addressOptions(options3);
            return this.$_addRule({ name: "domain", args: { options: options3 }, address });
          },
          validate(value, helpers, args, { address }) {
            if (isDomainValid(value, address)) {
              return value;
            }
            return helpers.error("string.domain");
          }
        },
        email: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]);
            assert22(options3.multiple === void 0 || typeof options3.multiple === "boolean", "multiple option must be an boolean");
            const address = internals.addressOptions(options3);
            const regex = new RegExp(`\\s*[${options3.separator ? escapeRegex2(options3.separator) : ","}]\\s*`);
            return this.$_addRule({ name: "email", args: { options: options3 }, regex, address });
          },
          validate(value, helpers, { options: options3 }, { regex, address }) {
            const emails = options3.multiple ? value.split(regex) : [value];
            const invalids = [];
            for (const email2 of emails) {
              if (!isEmailValid(email2, address)) {
                invalids.push(email2);
              }
            }
            if (!invalids.length) {
              return value;
            }
            return helpers.error("string.email", { value, invalids });
          }
        },
        guid: {
          alias: "uuid",
          method(options3 = {}) {
            Common.assertOptions(options3, ["version", "separator", "wrapper"]);
            assert22(
              options3.wrapper === void 0 || typeof options3.wrapper === "boolean" || typeof options3.wrapper === "string" && typeof internals.guidBrackets[options3.wrapper] === "string",
              `"wrapper" must be true, false, or one of "${Object.keys(internals.guidBrackets).filter(Boolean).join('", "')}"`
            );
            let versionNumbers = "";
            if (options3.version) {
              const versions = [].concat(options3.version);
              assert22(versions.length >= 1, "version must have at least 1 valid version specified");
              const set = /* @__PURE__ */ new Set();
              for (let i2 = 0; i2 < versions.length; ++i2) {
                const version4 = versions[i2];
                assert22(typeof version4 === "string", "version at position " + i2 + " must be a string");
                const versionNumber = internals.guidVersions[version4.toLowerCase()];
                assert22(versionNumber, "version at position " + i2 + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                assert22(!set.has(versionNumber), "version at position " + i2 + " must not be a duplicate");
                versionNumbers += versionNumber;
                set.add(versionNumber);
              }
            }
            assert22(internals.guidSeparators.has(options3.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options3.separator === void 0 ? "[:-]?" : options3.separator === true ? "[:-]" : options3.separator === false ? "[]?" : `\\${options3.separator}`;
            let wrapperStart;
            let wrapperEnd;
            if (options3.wrapper === void 0) {
              wrapperStart = "[\\[{\\(]?";
              wrapperEnd = "[\\]}\\)]?";
            } else if (options3.wrapper === true) {
              wrapperStart = "[\\[{\\(]";
              wrapperEnd = "[\\]}\\)]";
            } else if (options3.wrapper === false) {
              wrapperStart = "";
              wrapperEnd = "";
            } else {
              wrapperStart = escapeRegex2(options3.wrapper);
              wrapperEnd = escapeRegex2(internals.guidBrackets[options3.wrapper]);
            }
            const regex = new RegExp(
              `^(${wrapperStart})[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}(${wrapperEnd})$`,
              "i"
            );
            return this.$_addRule({ name: "guid", args: { options: options3 }, regex });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            const open = results[1];
            const close = results[results.length - 1];
            if ((open || close) && internals.guidBrackets[open] !== close) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["byteAligned", "prefix"]);
            options3 = { byteAligned: false, prefix: false, ...options3 };
            assert22(typeof options3.byteAligned === "boolean", "byteAligned must be boolean");
            assert22(typeof options3.prefix === "boolean" || options3.prefix === "optional", 'prefix must be boolean or "optional"');
            return this.$_addRule({ name: "hex", args: { options: options3 } });
          },
          validate(value, helpers, { options: options3 }) {
            const re = options3.prefix === "optional" ? internals.hexRegex.withOptionalPrefix : options3.prefix === true ? internals.hexRegex.withPrefix : internals.hexRegex.withoutPrefix;
            if (!re.test(value)) {
              return helpers.error("string.hex");
            }
            if (options3.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (isDomainValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        ip: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["cidr", "version"]);
            const { cidr, versions, regex } = ipRegex(options3);
            const version4 = options3.version ? versions : void 0;
            return this.$_addRule({ name: "ip", args: { options: { cidr, version: version4 } }, regex });
          },
          validate(value, helpers, { options: options3 }, { regex }) {
            if (regex.test(value)) {
              return value;
            }
            if (options3.version) {
              return helpers.error("string.ipVersion", { value, cidr: options3.cidr, version: options3.version });
            }
            return helpers.error("string.ip", { value, cidr: options3.cidr });
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length4 = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length4, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, { limit: args.limit, value, encoding });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: ["limit", "encoding"]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: ["limit", "encoding"]
        },
        normalize: {
          method(form = "NFC") {
            assert22(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({ name: "normalize", args: { form } });
          },
          validate(value, { error }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error("string.normalize", { value, form });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options3 = {}) {
            assert22(regex instanceof RegExp, "regex must be a RegExp");
            assert22(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options3 === "string") {
              options3 = { name: options3 };
            }
            Common.assertOptions(options3, ["invert", "name"]);
            const errorCode = ["string.pattern", options3.invert ? ".invert" : "", options3.name ? ".name" : ".base"].join("");
            return this.$_addRule({ name: "pattern", args: { regex, options: options3 }, errorCode });
          },
          validate(value, helpers, { regex, options: options3 }, { errorCode }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options3.invert) {
              return value;
            }
            return helpers.error(errorCode, { name: options3.name, regex, value });
          },
          args: ["regex", "options"],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(escapeRegex2(pattern), "g");
            }
            assert22(pattern instanceof RegExp, "pattern must be a RegExp");
            assert22(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({ pattern, replacement });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled2 = true) {
            assert22(typeof enabled2 === "boolean", "enabled must be a boolean");
            return this.$_addRule({ name: "trim", args: { enabled: enabled2 } });
          },
          validate(value, helpers, { enabled: enabled2 }) {
            if (!enabled2 || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled2 = true) {
            assert22(typeof enabled2 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled2);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        },
        uri: {
          method(options3 = {}) {
            Common.assertOptions(options3, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme", "encodeUri"]);
            if (options3.domain) {
              Common.assertOptions(options3.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
            }
            const { regex, scheme } = uriRegex(options3);
            const domain = options3.domain ? internals.addressOptions(options3.domain) : null;
            return this.$_addRule({ name: "uri", args: { options: options3 }, regex, domain, scheme });
          },
          validate(value, helpers, { options: options3 }, { regex, domain, scheme }) {
            if (["http:/", "https:/"].includes(value)) {
              return helpers.error("string.uri");
            }
            let match = regex.exec(value);
            if (!match && helpers.prefs.convert && options3.encodeUri) {
              const encoded = encodeURI(value);
              match = regex.exec(encoded);
              if (match) {
                value = encoded;
              }
            }
            if (match) {
              const matched = match[1] || match[2];
              if (domain && (!options3.allowRelative || matched) && !isDomainValid(matched, domain)) {
                return helpers.error("string.domain", { value: matched });
              }
              return value;
            }
            if (options3.relativeOnly) {
              return helpers.error("string.uriRelativeOnly");
            }
            if (options3.scheme) {
              return helpers.error("string.uriCustomScheme", { scheme, value });
            }
            return helpers.error("string.uri");
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.replacements) {
            for (const { pattern, replacement } of desc.replacements) {
              obj = obj.replace(pattern, replacement);
            }
          }
          return obj;
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.domain": "{{#label}} must contain a valid domain name",
        "string.email": "{{#label}} must be a valid email",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
        "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uri": "{{#label}} must be a valid uri",
        "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
        "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.addressOptions = function(options3) {
      if (!options3) {
        return internals.tlds || options3;
      }
      assert22(options3.minDomainSegments === void 0 || Number.isSafeInteger(options3.minDomainSegments) && options3.minDomainSegments > 0, "minDomainSegments must be a positive integer");
      assert22(options3.maxDomainSegments === void 0 || Number.isSafeInteger(options3.maxDomainSegments) && options3.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
      if (options3.tlds === false) {
        return options3;
      }
      if (options3.tlds === true || options3.tlds === void 0) {
        assert22(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options3, internals.tlds);
      }
      assert22(typeof options3.tlds === "object", "tlds must be true, false, or an object");
      const deny = options3.tlds.deny;
      if (deny) {
        if (Array.isArray(deny)) {
          options3 = Object.assign({}, options3, { tlds: { deny: new Set(deny) } });
        }
        assert22(options3.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
        assert22(!options3.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
        internals.validateTlds(options3.tlds.deny, "tlds.deny");
        return options3;
      }
      const allow = options3.tlds.allow;
      if (!allow) {
        return { ...options3, tlds: false };
      }
      if (allow === true) {
        assert22(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options3, internals.tlds);
      }
      if (Array.isArray(allow)) {
        options3 = Object.assign({}, options3, { tlds: { allow: new Set(allow) } });
      }
      assert22(options3.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
      internals.validateTlds(options3.tlds.allow, "tlds.allow");
      return options3;
    };
    internals.validateTlds = function(set, source) {
      for (const tld of set) {
        assert22(isDomainValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
      }
    };
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      if (/.*T.*[+-]\d\d$/.test(value)) {
        value += "00";
      }
      const date3 = new Date(value);
      if (isNaN(date3.getTime())) {
        return null;
      }
      return date3.toISOString();
    };
    internals.length = function(schema, name, limit, operator, encoding) {
      assert22(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
    };
  }
});
var require_symbol2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/symbol.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Any = require_any2();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module2.exports = Any.extend({
      type: "symbol",
      terms: {
        map: { init: new internals.Map() }
      },
      coerce: {
        method(value, { schema, error }) {
          const lookup = schema.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema._flags.only || typeof value === "symbol") {
            return { value };
          }
          return { value, errors: error("symbol.map", { map: schema.$_terms.map }) };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "symbol") {
          return { value, errors: error("symbol.base") };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            assert22(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols2 = [];
            for (const entry of iterable) {
              assert22(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              assert22(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              assert22(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols2.push(value);
            }
            return obj.valid(...symbols2);
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.map) {
            obj = obj.map(desc.map);
          }
          return obj;
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});
var require_binary2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/binary.js"(exports2, module2) {
    "use strict";
    var { assert: assert22 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    module2.exports = Any.extend({
      type: "binary",
      coerce: {
        from: ["string", "object"],
        method(value, { schema }) {
          if (typeof value === "string" || value !== null && value.type === "Buffer") {
            try {
              return { value: Buffer.from(value, schema._flags.encoding) };
            } catch {
            }
          }
        }
      },
      validate(value, { error }) {
        if (!Buffer.isBuffer(value)) {
          return { value, errors: error("binary.base") };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            assert22(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});
var require_lib34 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/index.js"(exports2, module2) {
    "use strict";
    var { assert: assert22, clone: clone2 } = require_lib();
    var Cache = require_cache();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Extend = require_extend2();
    var Manifest = require_manifest();
    var Ref = require_ref2();
    var Template = require_template2();
    var Trace = require_trace();
    var Schemas;
    var internals = {
      types: {
        alternatives: require_alternatives2(),
        any: require_any2(),
        array: require_array2(),
        boolean: require_boolean2(),
        date: require_date2(),
        function: require_function2(),
        link: require_link2(),
        number: require_number2(),
        object: require_object2(),
        string: require_string2(),
        symbol: require_symbol2()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary2();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          assert22(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      root.x = root.expression;
      if (Trace.setup) {
        Trace.setup(root);
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      cache: Cache.provider,
      assert(value, schema, ...args) {
        internals.assert(value, schema, true, args);
      },
      attempt(value, schema, ...args) {
        return internals.assert(value, schema, false, args);
      },
      build(desc) {
        assert22(typeof Manifest.build === "function", "Manifest functionality disabled");
        return Manifest.build(this, desc);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema, options3) {
        return Compile.compile(this, schema, options3);
      },
      defaults(modifier) {
        assert22(typeof modifier === "function", "modifier must be a function");
        const joi = Object.assign({}, this);
        for (const type of joi._types) {
          const schema = modifier(joi[type]());
          assert22(Common.isSchema(schema), "modifier must return a valid schema object");
          joi[type] = function(...args) {
            return internals.generate(this, schema, args);
          };
        }
        return joi;
      },
      expression(...args) {
        return new Template(...args);
      },
      extend(...extensions) {
        Common.verifyFlat(extensions, "extend");
        Schemas = Schemas || require_schemas2();
        assert22(extensions.length, "You need to provide at least one extension");
        this.assert(extensions, Schemas.extensions);
        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);
        for (let extension of extensions) {
          if (typeof extension === "function") {
            extension = extension(joi);
          }
          this.assert(extension, Schemas.extension);
          const expanded = internals.expandExtension(extension, joi);
          for (const item of expanded) {
            assert22(joi[item.type] === void 0 || joi._types.has(item.type), "Cannot override name", item.type);
            const base4 = item.base || this.any();
            const schema = Extend.type(base4, item);
            joi._types.add(item.type);
            joi[item.type] = function(...args) {
              return internals.generate(this, schema, args);
            };
          }
        }
        return joi;
      },
      isError: Errors.ValidationError.isError,
      isExpression: Template.isTemplate,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      },
      types() {
        const types = {};
        for (const type of this._types) {
          types[type] = this[type]();
        }
        for (const target in internals.aliases) {
          types[target] = this[target]();
        }
        return types;
      }
    };
    internals.assert = function(value, schema, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options3 = message !== null ? args[1] : args[0];
      const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options3 || {}));
      let error = result.error;
      if (!error) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
      if (error instanceof Errors.ValidationError === false) {
        error = clone2(error);
      }
      error.message = message ? `${message} ${display}` : display;
      throw error;
    };
    internals.generate = function(root, schema, args) {
      assert22(root, "Must be invoked on a Joi instance.");
      schema.$_root = root;
      if (!schema._definition.args || !args.length) {
        return schema;
      }
      return schema._definition.args(schema, ...args);
    };
    internals.expandExtension = function(extension, joi) {
      if (typeof extension.type === "string") {
        return [extension];
      }
      const extended = [];
      for (const type of joi._types) {
        if (extension.type.test(type)) {
          const item = Object.assign({}, extension);
          item.type = type;
          item.base = joi[type]();
          extended.push(item);
        }
      }
      return extended;
    };
    module2.exports = internals.root();
  }
});
var routes_exports = {};
function notFoundNoCache(h2) {
  return h2.response().code(404).header("Cache-Control", "no-store");
}
var import_boom3;
var import_npm_bottleneck;
var import_npm_chalk2;
var import_npm_joi;
var MEGABYTE;
var SECOND;
var CID_REGEX;
var KV_KEY_REGEX;
var NAME_REGEX;
var POSITIVE_INTEGER_REGEX;
var FILE_UPLOAD_MAX_BYTES;
var SIGNUP_LIMIT_MIN;
var SIGNUP_LIMIT_HOUR;
var SIGNUP_LIMIT_DAY;
var SIGNUP_LIMIT_DISABLED;
var limiterPerMinute;
var limiterPerHour;
var limiterPerDay;
var cidLookupTable;
var limiterKey;
var ctEq;
var isCheloniaDashboard;
var appDir;
var dashboardDir;
var staticServeConfig;
var errorMapper;
var route;
var init_routes = __esm({
  "src/serve/routes.ts"() {
    "use strict";
    init_chelonia();
    init_persistent_actions();
    init_SPMessage();
    init_functions();
    init_functions();
    import_boom3 = __toESM(require_lib6());
    init_esm3();
    import_npm_bottleneck = __toESM(require_lib31());
    import_npm_chalk2 = __toESM(require_source());
    import_npm_joi = __toESM(require_lib34());
    init_database();
    init_instance_keys();
    init_zkppSalt();
    MEGABYTE = 1048576;
    SECOND = 1e3;
    CID_REGEX = /^z[1-9A-HJ-NP-Za-km-z]{8,72}$/;
    KV_KEY_REGEX = /^(?!_private)[^\x00]{1,256}$/;
    NAME_REGEX = /^(?![_-])((?!([_-])\2)[a-z\d_-]){1,80}(?<![_-])$/;
    POSITIVE_INTEGER_REGEX = /^\d{1,16}$/;
    FILE_UPLOAD_MAX_BYTES = parseInt(process9.env.FILE_UPLOAD_MAX_BYTES) || 30 * MEGABYTE;
    SIGNUP_LIMIT_MIN = parseInt(process9.env.SIGNUP_LIMIT_MIN) || 2;
    SIGNUP_LIMIT_HOUR = parseInt(process9.env.SIGNUP_LIMIT_HOUR) || 10;
    SIGNUP_LIMIT_DAY = parseInt(process9.env.SIGNUP_LIMIT_DAY) || 50;
    SIGNUP_LIMIT_DISABLED = process9.env.NODE_ENV !== "production" || process9.env.SIGNUP_LIMIT_DISABLED === "true";
    limiterPerMinute = new import_npm_bottleneck.default.Group({
      strategy: import_npm_bottleneck.default.strategy.LEAK,
      highWater: 0,
      reservoir: SIGNUP_LIMIT_MIN,
      reservoirRefreshInterval: 60 * SECOND,
      reservoirRefreshAmount: SIGNUP_LIMIT_MIN
    });
    limiterPerHour = new import_npm_bottleneck.default.Group({
      strategy: import_npm_bottleneck.default.strategy.LEAK,
      highWater: 0,
      reservoir: SIGNUP_LIMIT_HOUR,
      reservoirRefreshInterval: 60 * 60 * SECOND,
      reservoirRefreshAmount: SIGNUP_LIMIT_HOUR
    });
    limiterPerDay = new import_npm_bottleneck.default.Group({
      strategy: import_npm_bottleneck.default.strategy.LEAK,
      highWater: 0,
      reservoir: SIGNUP_LIMIT_DAY,
      reservoirRefreshInterval: 24 * 60 * 60 * SECOND,
      reservoirRefreshAmount: SIGNUP_LIMIT_DAY
    });
    cidLookupTable = {
      [multicodes2.SHELTER_CONTRACT_MANIFEST]: "application/vnd.shelter.contractmanifest+json",
      [multicodes2.SHELTER_CONTRACT_TEXT]: "application/vnd.shelter.contracttext",
      [multicodes2.SHELTER_CONTRACT_DATA]: "application/vnd.shelter.contractdata+json",
      [multicodes2.SHELTER_FILE_MANIFEST]: "application/vnd.shelter.filemanifest+json",
      [multicodes2.SHELTER_FILE_CHUNK]: "application/vnd.shelter.filechunk+octet-stream"
    };
    limiterKey = (ip) => {
      const ipVersion = isIP(ip);
      if (ipVersion === 4) {
        return ip;
      } else if (ipVersion === 6) {
        const [address, zoneIdx] = ip.split("%");
        const segments = address.split(":");
        let isCompressed = false;
        for (let i2 = 0; i2 < segments.length - 1; i2++) {
          if (!isCompressed && segments[i2] === "") {
            const requiredSegments = 8 - (segments.length - 1);
            if (requiredSegments < 0) {
              throw new Error("Invalid IPv6 address: too many segments");
            }
            if ((i2 === 0 || i2 === segments.length - 2) && segments[i2 + 1] === "") {
              segments[i2 + 1] = "0";
            }
            if (i2 === 0 && segments.length === 3 && segments[i2 + 2] === "") {
              segments[i2 + 2] = "0";
            }
            segments.splice(i2, 1, ...new Array(requiredSegments).fill("0"));
            isCompressed = true;
            continue;
          }
          segments[i2] = segments[i2].replace(/^0+/, "0");
        }
        if (segments.length === 8 && isIP(segments[7]) === 4) {
          return segments[7];
        } else if (segments.length === 8) {
          if (zoneIdx) {
            segments[7] = segments[7].replace(/^0+/, "0");
            return segments.join(":").toLowerCase() + "%" + zoneIdx;
          } else {
            return segments.slice(0, 4).join(":").toLowerCase() + "::";
          }
        } else {
          throw new Error("Invalid IPv6 address");
        }
      }
      throw new Error("Invalid address format");
    };
    ctEq = (expected, actual) => {
      let r = actual.length ^ expected.length;
      for (let i2 = 0; i2 < actual.length; i2++) {
        r |= actual.codePointAt(i2) ^ expected.codePointAt(i2);
      }
      return r === 0;
    };
    isCheloniaDashboard = process9.env.IS_CHELONIA_DASHBOARD_DEV;
    appDir = process9.env.CHELONIA_APP_DIR || ".";
    dashboardDir = import.meta.dirname || "./build/dist-dashboard";
    staticServeConfig = {
      routePath: isCheloniaDashboard ? "/dashboard/{path*}" : "/app/{path*}",
      distAssets: path10.resolve(path10.join(isCheloniaDashboard ? dashboardDir : appDir, "assets")),
      distIndexHtml: path10.resolve(path10.join(isCheloniaDashboard ? dashboardDir : appDir, "index.html")),
      redirect: isCheloniaDashboard ? "/dashboard/" : "/app/"
    };
    errorMapper = (e2) => {
      switch (e2?.name) {
        case "BackendErrorNotFound":
          return import_boom3.default.notFound();
        case "BackendErrorGone":
          return import_boom3.default.resourceGone();
        case "BackendErrorBadData":
          return import_boom3.default.badData(e2.message);
        default:
          console.error(e2, "Unexpected backend error");
          return import_boom3.default.internal(e2.message ?? "internal error");
      }
    };
    route = new Proxy({}, {
      get: function(_obj, prop) {
        return function(path12, options3, handler) {
          esm_default("okTurtles.data/apply", SERVER_INSTANCE, function(server) {
            server.route({ path: path12, method: prop, options: options3, handler });
          });
        };
      }
    });
    route.POST("/event", {
      auth: {
        strategy: "chel-shelter",
        mode: "optional"
      },
      validate: {
        headers: import_npm_joi.default.object({
          "shelter-namespace-registration": import_npm_joi.default.string().regex(NAME_REGEX)
        }),
        options: {
          allowUnknown: true
        },
        payload: import_npm_joi.default.string().required()
      }
    }, async function(request) {
      if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
      const ip = request.headers["x-real-ip"] || request.info.remoteAddress;
      try {
        const deserializedHEAD = SPMessage.deserializeHEAD(request.payload);
        try {
          const parsed = maybeParseCID(deserializedHEAD.head.manifest);
          if (parsed?.code !== multicodes2.SHELTER_CONTRACT_MANIFEST) {
            return import_boom3.default.badData("Invalid manifest");
          }
          const credentials = request.auth.credentials;
          if (!credentials?.billableContractID && deserializedHEAD.isFirstMessage) {
            const manifest2 = await esm_default("chelonia.db/get", deserializedHEAD.head.manifest);
            const parsedManifest = JSON.parse(manifest2);
            const { name } = JSON.parse(parsedManifest.body);
            if (name !== "gi.contracts/identity") {
              return import_boom3.default.unauthorized("This contract type requires ownership information", "shelter");
            }
            if (process9.env.CHELONIA_REGISTRATION_DISABLED) {
              return import_boom3.default.forbidden("Registration disabled");
            }
            if (!SIGNUP_LIMIT_DISABLED) {
              try {
                const keyedIp = limiterKey(ip);
                await limiterPerMinute.key(keyedIp).schedule(() => Promise.resolve());
                await limiterPerHour.key(keyedIp).schedule(() => Promise.resolve());
                await limiterPerDay.key(keyedIp).schedule(() => Promise.resolve());
              } catch {
                console.warn("rate limit hit for IP:", ip);
                throw import_boom3.default.tooManyRequests("Rate limit exceeded");
              }
            }
          }
          const saltUpdateToken = request.headers["shelter-salt-update-token"];
          let updateSalts;
          if (saltUpdateToken) {
            updateSalts = await redeemSaltUpdateToken(deserializedHEAD.contractID, saltUpdateToken);
          }
          await esm_default("backend/server/handleEntry", deserializedHEAD, request.payload);
          await updateSalts?.(deserializedHEAD.hash);
          if (deserializedHEAD.isFirstMessage) {
            if (credentials?.billableContractID) {
              await esm_default("backend/server/saveOwner", credentials.billableContractID, deserializedHEAD.contractID);
            } else {
              await esm_default("backend/server/registerBillableEntity", deserializedHEAD.contractID);
            }
            const name = request.headers["shelter-namespace-registration"];
            if (name) {
              const cheloniaState = esm_default("chelonia/rootState");
              if (cheloniaState.contracts[deserializedHEAD.contractID]?.type === "gi.contracts/identity") {
                const r = await esm_default("backend/db/registerName", name, deserializedHEAD.contractID);
                if (import_boom3.default.isBoom(r)) {
                  return r;
                }
                const saltRegistrationToken = request.headers["shelter-salt-registration-token"];
                console.info(`new user: ${name}=${deserializedHEAD.contractID} (${ip})`);
                if (saltRegistrationToken) {
                  await redeemSaltRegistrationToken(name, deserializedHEAD.contractID, saltRegistrationToken);
                }
              }
            }
            const deletionTokenDgst = request.headers["shelter-deletion-token-digest"];
            if (deletionTokenDgst) {
              await esm_default("chelonia.db/set", `_private_deletionTokenDgst_${deserializedHEAD.contractID}`, deletionTokenDgst);
            }
          }
          await esm_default("backend/server/updateSize", deserializedHEAD.contractID, Buffer11.byteLength(request.payload), deserializedHEAD.isFirstMessage && !credentials?.billableContractID ? deserializedHEAD.contractID : void 0);
        } catch (err) {
          console.error(err, import_npm_chalk2.default.bold.yellow(err.name));
          if (err.name === "ChelErrorDBBadPreviousHEAD" || err.name === "ChelErrorAlreadyProcessed") {
            const HEADinfo = await esm_default("chelonia/db/latestHEADinfo", deserializedHEAD.contractID) ?? { HEAD: null, height: 0 };
            const r = import_boom3.default.conflict(err.message, { HEADinfo });
            Object.assign(r.output.headers, {
              "shelter-headinfo-head": HEADinfo.HEAD,
              "shelter-headinfo-height": HEADinfo.height
            });
            return r;
          } else if (err.name === "ChelErrorSignatureError") {
            return import_boom3.default.badData("Invalid signature");
          } else if (err.name === "ChelErrorSignatureKeyUnauthorized") {
            return import_boom3.default.forbidden("Unauthorized signing key");
          }
          throw err;
        }
        return deserializedHEAD.hash;
      } catch (err) {
        err.ip = ip;
        logger.error(err, "POST /event", err.message);
        return err;
      }
    });
    route.GET("/eventsAfter/{contractID}/{since}/{limit?}", {
      validate: {
        params: import_npm_joi.default.object({
          contractID: import_npm_joi.default.string().regex(CID_REGEX).required(),
          since: import_npm_joi.default.string().regex(POSITIVE_INTEGER_REGEX).required(),
          limit: import_npm_joi.default.string().regex(POSITIVE_INTEGER_REGEX)
        }),
        query: import_npm_joi.default.object({
          keyOps: import_npm_joi.default.boolean()
        })
      }
    }, async function(request) {
      const { contractID, since, limit } = request.params;
      const ip = request.headers["x-real-ip"] || request.info.remoteAddress;
      try {
        const parsed = maybeParseCID(contractID);
        if (parsed?.code !== multicodes2.SHELTER_CONTRACT_DATA) {
          return import_boom3.default.badRequest();
        }
        const stream = await esm_default("backend/db/streamEntriesAfter", contractID, Number(since), limit == null ? void 0 : Number(limit), { keyOps: !!request.query["keyOps"] });
        request.events.once("disconnect", stream.destroy.bind(stream));
        return stream;
      } catch (err) {
        err.ip = ip;
        logger.error(err, `GET /eventsAfter/${contractID}/${since}`, err.message);
        return err;
      }
    });
    route.GET("/ownResources", {
      auth: {
        strategies: ["chel-shelter"],
        mode: "required"
      }
    }, async function(request) {
      const billableContractID = request.auth.credentials.billableContractID;
      const resources = (await esm_default("chelonia.db/get", `_private_resources_${billableContractID}`))?.split("\0");
      return resources || [];
    });
    if (process9.env.NODE_ENV === "development") {
      const levelToColor = {
        error: import_npm_chalk2.default.bold.red,
        warn: import_npm_chalk2.default.yellow,
        log: import_npm_chalk2.default.green,
        info: import_npm_chalk2.default.green,
        debug: import_npm_chalk2.default.blue
      };
      route.POST("/log", {
        validate: {
          payload: import_npm_joi.default.object({
            level: import_npm_joi.default.string().required(),
            value: import_npm_joi.default.string().required()
          })
        }
      }, function(request, h2) {
        if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
        const ip = request.headers["x-real-ip"] || request.info.remoteAddress;
        const log2 = levelToColor[request.payload.level];
        console.debug(import_npm_chalk2.default.bold.yellow(`REMOTE LOG (${ip}): `) + log2(`[${request.payload.level}] ${request.payload.value}`));
        return h2.response().code(200);
      });
    }
    route.GET("/name/{name}", {
      validate: {
        params: import_npm_joi.default.object({
          name: import_npm_joi.default.string().regex(NAME_REGEX).required()
        })
      }
    }, async function(request, h2) {
      const { name } = request.params;
      try {
        const lookupResult = await esm_default("backend/db/lookupName", name);
        return lookupResult ? h2.response(lookupResult).type("text/plain") : notFoundNoCache(h2);
      } catch (err) {
        logger.error(err, `GET /name/${name}`, err.message);
        return err;
      }
    });
    route.GET("/latestHEADinfo/{contractID}", {
      cache: { otherwise: "no-store" },
      validate: {
        params: import_npm_joi.default.object({
          contractID: import_npm_joi.default.string().regex(CID_REGEX).required()
        })
      }
    }, async function(request, h2) {
      const { contractID } = request.params;
      try {
        const parsed = maybeParseCID(contractID);
        if (parsed?.code !== multicodes2.SHELTER_CONTRACT_DATA) return import_boom3.default.badRequest();
        const HEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
        if (HEADinfo === "") {
          return import_boom3.default.resourceGone();
        }
        if (!HEADinfo) {
          console.warn(`[backend] latestHEADinfo not found for ${contractID}`);
          return notFoundNoCache(h2);
        }
        return HEADinfo;
      } catch (err) {
        logger.error(err, `GET /latestHEADinfo/${contractID}`, err.message);
        return err;
      }
    });
    route.GET("/time", {}, function(_request, h2) {
      return h2.response((/* @__PURE__ */ new Date()).toISOString()).header("cache-control", "no-store").type("text/plain");
    });
    route.POST(
      "/streams-test",
      {
        payload: {
          parse: false
        }
      },
      function(request, h2) {
        if (request.payload.byteLength === 2 && Buffer11.from(request.payload).toString() === "ok") {
          return h2.response().code(204);
        } else {
          return import_boom3.default.badRequest();
        }
      }
    );
    if (process9.env.NODE_ENV === "development") {
      route.POST("/dev-file", {
        payload: {
          output: "data",
          multipart: true,
          allow: "multipart/form-data",
          failAction: function(_request, _h, err) {
            console.error("failAction error:", err);
            return import_boom3.default.isBoom(err) ? err : import_boom3.default.boomify(err || new Error());
          },
          maxBytes: 6 * MEGABYTE,
          // TODO: make this a configurable setting
          timeout: 10 * SECOND
          // TODO: make this a configurable setting
        }
      }, async function(request) {
        if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
        try {
          console.log("FILE UPLOAD!");
          const { hash: hash32, data } = request.payload;
          if (!hash32) return import_boom3.default.badRequest("missing hash");
          if (!data) return import_boom3.default.badRequest("missing data");
          const parsed = maybeParseCID(hash32);
          if (!parsed) return import_boom3.default.badRequest("invalid hash");
          const ourHash = createCID2(data, parsed.code);
          if (ourHash !== hash32) {
            console.error(`hash(${hash32}) != ourHash(${ourHash})`);
            return import_boom3.default.badRequest("bad hash!");
          }
          await esm_default("chelonia.db/set", hash32, data);
          return "/file/" + hash32;
        } catch (err) {
          logger.error(err);
          return import_boom3.default.internal("File upload failed");
        }
      });
    }
    route.POST("/file", {
      auth: {
        strategies: ["chel-shelter"],
        mode: "required"
      },
      payload: {
        parse: true,
        output: "stream",
        multipart: { output: "annotated" },
        allow: "multipart/form-data",
        failAction: function(_request, _h, err) {
          console.error(err, "failAction error");
          return import_boom3.default.isBoom(err) ? err : import_boom3.default.boomify(err || new Error());
        },
        maxBytes: FILE_UPLOAD_MAX_BYTES,
        timeout: 10 * SECOND
        // TODO: make this a configurable setting
      }
    }, async function(request, h2) {
      if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
      try {
        console.info("FILE UPLOAD!");
        const credentials = request.auth.credentials;
        if (!credentials?.billableContractID) {
          return import_boom3.default.unauthorized("Uploading files requires ownership information", "shelter");
        }
        const manifestMeta = request.payload["manifest"];
        if (typeof manifestMeta !== "object") return import_boom3.default.badRequest("missing manifest");
        if (manifestMeta.filename !== "manifest.json") return import_boom3.default.badRequest("wrong manifest filename");
        if (!(manifestMeta.payload instanceof Uint8Array)) return import_boom3.default.badRequest("wrong manifest format");
        const manifest2 = (() => {
          try {
            return JSON.parse(Buffer11.from(manifestMeta.payload).toString());
          } catch {
            throw import_boom3.default.badData("Error parsing manifest");
          }
        })();
        if (typeof manifest2 !== "object") return import_boom3.default.badData("manifest format is invalid");
        if (manifest2.version !== "1.0.0") return import_boom3.default.badData("unsupported manifest version");
        if (manifest2.cipher !== "aes256gcm") return import_boom3.default.badData("unsupported cipher");
        if (!Array.isArray(manifest2.chunks) || !manifest2.chunks.length) return import_boom3.default.badData("missing chunks");
        let ourSize = 0;
        const chunks = manifest2.chunks.map((chunk, i2) => {
          if (!Array.isArray(chunk) || chunk.length !== 2 || typeof chunk[0] !== "number" || typeof chunk[1] !== "string" || !Number.isSafeInteger(chunk[0]) || chunk[0] <= 0) {
            throw import_boom3.default.badData("bad chunk description");
          }
          if (!request.payload[i2] || !(request.payload[i2].payload instanceof Uint8Array)) {
            throw import_boom3.default.badRequest("chunk missing in submitted data");
          }
          const ourHash = createCID2(request.payload[i2].payload, multicodes2.SHELTER_FILE_CHUNK);
          if (request.payload[i2].payload.byteLength !== chunk[0]) {
            throw import_boom3.default.badRequest("bad chunk size");
          }
          if (ourHash !== chunk[1]) {
            throw import_boom3.default.badRequest("bad chunk hash");
          }
          ourSize += chunk[0];
          return [ourHash, request.payload[i2].payload];
        });
        if (ourSize !== manifest2.size) return import_boom3.default.badRequest("Mismatched total size");
        const manifestHash = createCID2(manifestMeta.payload, multicodes2.SHELTER_FILE_MANIFEST);
        if (await esm_default("chelonia.db/get", manifestHash)) {
          throw new Error(`Manifest ${manifestHash} already exists`);
        }
        await Promise.all(chunks.map(async ([cid]) => {
          const exists = !!await esm_default("chelonia.db/get", cid);
          if (exists) {
            throw new Error(`Chunk ${cid} already exists`);
          }
        }));
        await Promise.all(chunks.map(([cid, data]) => esm_default("chelonia.db/set", cid, data)));
        await esm_default("chelonia.db/set", manifestHash, manifestMeta.payload);
        await esm_default("backend/server/saveOwner", credentials.billableContractID, manifestHash);
        const size = manifest2.size + manifestMeta.payload.byteLength;
        await esm_default("backend/server/updateSize", manifestHash, size);
        await esm_default("backend/server/updateContractFilesTotalSize", credentials.billableContractID, size);
        const deletionTokenDgst = request.headers["shelter-deletion-token-digest"];
        if (deletionTokenDgst) {
          await esm_default("chelonia.db/set", `_private_deletionTokenDgst_${manifestHash}`, deletionTokenDgst);
        }
        return h2.response(manifestHash);
      } catch (err) {
        logger.error(err, "POST /file", err.message);
        return err;
      }
    });
    route.GET("/file/{hash}", {
      validate: {
        params: import_npm_joi.default.object({
          hash: import_npm_joi.default.string().regex(CID_REGEX).required()
        })
      }
    }, async function(request, h2) {
      const { hash: hash32 } = request.params;
      const parsed = maybeParseCID(hash32);
      if (!parsed) {
        return import_boom3.default.badRequest();
      }
      const blobOrString = await esm_default("chelonia.db/get", `any:${hash32}`);
      if (blobOrString?.length === 0) {
        return import_boom3.default.resourceGone();
      } else if (!blobOrString) {
        return notFoundNoCache(h2);
      }
      const type = cidLookupTable[parsed.code] || "application/octet-stream";
      return h2.response(blobOrString).etag(hash32).header("Cache-Control", "public,max-age=31536000,immutable").header("content-security-policy", "default-src 'none'; frame-ancestors 'none'; form-action 'none'; upgrade-insecure-requests; sandbox").header("x-content-type-options", "nosniff").type(type);
    });
    route.POST("/deleteFile/{hash}", {
      auth: {
        // Allow file deletion, and allow either the bearer of the deletion token or
        // the file owner to delete it
        strategies: ["chel-shelter", "chel-bearer"],
        mode: "required"
      },
      validate: {
        params: import_npm_joi.default.object({
          hash: import_npm_joi.default.string().regex(CID_REGEX).required()
        })
      }
    }, async function(request, h2) {
      if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
      const { hash: hash32 } = request.params;
      const strategy = request.auth.strategy;
      const parsed = maybeParseCID(hash32);
      if (parsed?.code !== multicodes2.SHELTER_FILE_MANIFEST) {
        return import_boom3.default.badRequest();
      }
      const owner = await esm_default("chelonia.db/get", `_private_owner_${hash32}`);
      if (!owner) {
        return import_boom3.default.notFound();
      }
      switch (strategy) {
        case "chel-shelter": {
          const ultimateOwner = await lookupUltimateOwner(owner);
          if (!ctEq(request.auth.credentials.billableContractID, ultimateOwner)) {
            return import_boom3.default.unauthorized("Invalid shelter auth", "shelter");
          }
          break;
        }
        case "chel-bearer": {
          const expectedTokenDgst = await esm_default("chelonia.db/get", `_private_deletionTokenDgst_${hash32}`);
          if (!expectedTokenDgst) {
            return import_boom3.default.notFound();
          }
          const tokenDgst = blake32Hash2(request.auth.credentials.token);
          if (!ctEq(expectedTokenDgst, tokenDgst)) {
            return import_boom3.default.unauthorized("Invalid token", "bearer");
          }
          break;
        }
        default:
          return import_boom3.default.unauthorized("Missing or invalid auth strategy");
      }
      try {
        await esm_default("backend/deleteFile", hash32, null, true);
        return h2.response();
      } catch (e2) {
        return errorMapper(e2);
      }
    });
    route.POST("/deleteContract/{hash}", {
      auth: {
        // Allow file deletion, and allow either the bearer of the deletion token or
        // the file owner to delete it
        strategies: ["chel-shelter", "chel-bearer"],
        mode: "required"
      }
    }, async function(request, h2) {
      if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
      const { hash: hash32 } = request.params;
      const strategy = request.auth.strategy;
      if (!hash32 || hash32.startsWith("_private")) return import_boom3.default.notFound();
      switch (strategy) {
        case "chel-shelter": {
          const owner = await esm_default("chelonia.db/get", `_private_owner_${hash32}`);
          if (!owner) {
            return import_boom3.default.notFound();
          }
          const ultimateOwner = await lookupUltimateOwner(owner);
          if (!ctEq(request.auth.credentials.billableContractID, ultimateOwner)) {
            return import_boom3.default.unauthorized("Invalid shelter auth", "shelter");
          }
          break;
        }
        case "chel-bearer": {
          const expectedTokenDgst = await esm_default("chelonia.db/get", `_private_deletionTokenDgst_${hash32}`);
          if (!expectedTokenDgst) {
            return import_boom3.default.notFound();
          }
          const tokenDgst = blake32Hash2(request.auth.credentials.token);
          if (!ctEq(expectedTokenDgst, tokenDgst)) {
            return import_boom3.default.unauthorized("Invalid token", "bearer");
          }
          break;
        }
        default:
          return import_boom3.default.unauthorized("Missing or invalid auth strategy");
      }
      const username = await esm_default("chelonia.db/get", `_private_cid2name_${hash32}`);
      try {
        const [id] = esm_default("chelonia.persistentActions/enqueue", ["backend/deleteContract", hash32, null, true]);
        if (username) {
          const ip = request.headers["x-real-ip"] || request.info.remoteAddress;
          console.info({ contractID: hash32, username, ip, taskId: id }, "Scheduled deletion on named contract");
        }
        return h2.response({ id }).code(202);
      } catch (e2) {
        return errorMapper(e2);
      }
    });
    route.POST("/kv/{contractID}/{key}", {
      auth: {
        strategies: ["chel-shelter"],
        mode: "required"
      },
      payload: {
        parse: false,
        maxBytes: 6 * MEGABYTE,
        // TODO: make this a configurable setting
        timeout: 10 * SECOND
        // TODO: make this a configurable setting
      },
      validate: {
        params: import_npm_joi.default.object({
          contractID: import_npm_joi.default.string().regex(CID_REGEX).required(),
          key: import_npm_joi.default.string().regex(KV_KEY_REGEX).required()
        })
      }
    }, function(request, h2) {
      if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
      const { contractID, key } = request.params;
      const parsed = maybeParseCID(contractID);
      if (parsed?.code !== multicodes2.SHELTER_CONTRACT_DATA) {
        return import_boom3.default.badRequest();
      }
      if (!ctEq(request.auth.credentials.billableContractID, contractID)) {
        return import_boom3.default.unauthorized(null, "shelter");
      }
      return esm_default("chelonia/queueInvocation", contractID, async () => {
        const existing = await esm_default("chelonia.db/get", `_private_kv_${contractID}_${key}`);
        const expectedEtag = request.headers["if-match"];
        if (!expectedEtag) {
          return import_boom3.default.badRequest("if-match is required");
        }
        const cid = existing ? createCID2(existing, multicodes2.RAW) : "";
        if (expectedEtag === "*") {
        } else {
          if (!expectedEtag.split(",").map((v2) => v2.trim()).includes(`"${cid}"`)) {
            return h2.response(existing || "").etag(cid).header("x-cid", `"${cid}"`).code(412);
          }
        }
        try {
          const serializedData = JSON.parse(request.payload.toString());
          const { contracts } = esm_default("chelonia/rootState");
          if (contracts[contractID].height !== Number(serializedData.height)) {
            return h2.response(existing || "").etag(cid).header("x-cid", `"${cid}"`).code(409);
          }
          esm_default("chelonia/parseEncryptedOrUnencryptedDetachedMessage", {
            contractID,
            serializedData,
            meta: key
          });
        } catch {
          return import_boom3.default.badData();
        }
        const existingSize = existing ? Buffer11.from(existing).byteLength : 0;
        await esm_default("chelonia.db/set", `_private_kv_${contractID}_${key}`, request.payload);
        await esm_default("backend/server/updateSize", contractID, request.payload.byteLength - existingSize);
        await appendToIndexFactory(`_private_kvIdx_${contractID}`)(key);
        esm_default("backend/server/broadcastKV", contractID, key, request.payload.toString()).catch((e2) => console.error(e2, "Error broadcasting KV update", contractID, key));
        return h2.response().code(204);
      });
    });
    route.GET("/kv/{contractID}/{key}", {
      auth: {
        strategies: ["chel-shelter"],
        mode: "required"
      },
      cache: { otherwise: "no-store" },
      validate: {
        params: import_npm_joi.default.object({
          contractID: import_npm_joi.default.string().regex(CID_REGEX).required(),
          key: import_npm_joi.default.string().regex(KV_KEY_REGEX).required()
        })
      }
    }, async function(request, h2) {
      const { contractID, key } = request.params;
      const parsed = maybeParseCID(contractID);
      if (parsed?.code !== multicodes2.SHELTER_CONTRACT_DATA) {
        return import_boom3.default.badRequest();
      }
      if (!ctEq(request.auth.credentials.billableContractID, contractID)) {
        return import_boom3.default.unauthorized(null, "shelter");
      }
      const result = await esm_default("chelonia.db/get", `_private_kv_${contractID}_${key}`);
      if (!result) {
        return notFoundNoCache(h2);
      }
      const cid = createCID2(result, multicodes2.RAW);
      return h2.response(result).etag(cid).header("x-cid", `"${cid}"`);
    });
    route.GET("/serverMessages", { cache: { otherwise: "no-store" } }, (_request, h2) => {
      if (!process9.env.CHELONIA_SERVER_MESSAGES) return [];
      return h2.response(process9.env.CHELONIA_SERVER_MESSAGES).type("application/json");
    });
    route.GET("/assets/{subpath*}", {
      ext: {
        onPostHandler: {
          method(request, h2) {
            if (request.path.includes("assets/js/sw-")) {
              console.debug("adding header: Service-Worker-Allowed /");
              if (request.response instanceof import_boom3.default.Boom) {
                request.response.output.headers["Service-Worker-Allowed"] = "/";
              } else {
                request.response.header("Service-Worker-Allowed", "/");
              }
            }
            return h2.continue;
          }
        }
      },
      files: {
        relativeTo: staticServeConfig.distAssets
      }
    }, function(request, h2) {
      const { subpath } = request.params;
      const basename7 = path10.basename(subpath);
      if (basename7.includes("-cached")) {
        return h2.file(subpath, { etagMethod: false }).etag(basename7).header("Cache-Control", "public,max-age=31536000,immutable");
      }
      return h2.file(subpath);
    });
    if (isCheloniaDashboard) {
      route.GET("/dashboard/assets/{subpath*}", {
        ext: {
          onPostHandler: {
            method(request, h2) {
              if (request.path.includes("assets/js/sw-")) {
                console.debug("adding header: Service-Worker-Allowed /");
                if (request.response instanceof import_boom3.default.Boom) {
                  request.response.output.headers["Service-Worker-Allowed"] = "/";
                } else {
                  request.response.header("Service-Worker-Allowed", "/");
                }
              }
              return h2.continue;
            }
          }
        },
        files: {
          relativeTo: staticServeConfig.distAssets
        }
      }, function(request, h2) {
        const { subpath } = request.params;
        const basename7 = path10.basename(subpath);
        if (basename7.includes("-cached")) {
          return h2.file(subpath, { etagMethod: false }).etag(basename7).header("Cache-Control", "public,max-age=31536000,immutable");
        }
        return h2.file(subpath);
      });
    }
    route.GET(staticServeConfig.routePath, {}, {
      file: staticServeConfig.distIndexHtml
    });
    route.GET("/", {}, function(_req, h2) {
      return h2.redirect(staticServeConfig.redirect);
    });
    route.POST("/zkpp/register/{name}", {
      validate: {
        params: import_npm_joi.default.object({
          name: import_npm_joi.default.string().regex(NAME_REGEX).required()
        }),
        payload: import_npm_joi.default.alternatives([
          {
            // b is a hash of a random public key (`g^r`) with secret key `r`,
            // which is used by the requester to commit to that particular `r`
            b: import_npm_joi.default.string().required()
          },
          {
            // `r` is the value used to derive `b` (in this case, it's the public
            // key `g^r`)
            r: import_npm_joi.default.string().required(),
            // `s` is an opaque (to the client) value that was earlier returned by
            // the server
            s: import_npm_joi.default.string().required(),
            // `sig` is an opaque (to the client) value returned by the server
            // to validate the request (ensuring that (`r`, `s`) come from a
            // previous request
            sig: import_npm_joi.default.string().required(),
            // `Eh` is the  Eh = E_{S_A + S_C}(h), where S_A and S_C are salts and
            //                                     h = H\_{S_A}(P)
            Eh: import_npm_joi.default.string().required()
          }
        ])
      }
    }, async function(req) {
      if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
      const lookupResult = await esm_default("backend/db/lookupName", req.params["name"]);
      if (lookupResult) {
        return import_boom3.default.conflict();
      }
      try {
        const { payload } = req;
        if (payload["b"]) {
          const result = registrationKey(req.params["name"], payload["b"]);
          if (result) {
            return result;
          }
        } else {
          const result = register(req.params["name"], payload["r"], payload["s"], payload["sig"], payload["Eh"]);
          if (result) {
            return result;
          }
        }
      } catch (e2) {
        e2.ip = req.headers["x-real-ip"] || req.info.remoteAddress;
        console.error(e2, "Error at POST /zkpp/{name}: " + e2.message);
      }
      return import_boom3.default.internal("internal error");
    });
    route.GET("/zkpp/{contractID}/auth_hash", {
      validate: {
        params: import_npm_joi.default.object({
          contractID: import_npm_joi.default.string().regex(CID_REGEX).required()
        }),
        query: import_npm_joi.default.object({ b: import_npm_joi.default.string().required() })
      }
    }, async function(req, h2) {
      try {
        const challenge = await getChallenge(req.params["contractID"], req.query["b"]);
        return challenge || notFoundNoCache(h2);
      } catch (e2) {
        e2.ip = req.headers["x-real-ip"] || req.info.remoteAddress;
        console.error(e2, "Error at GET /zkpp/{contractID}/auth_hash: " + e2.message);
      }
      return import_boom3.default.internal("internal error");
    });
    route.GET("/zkpp/{contractID}/contract_hash", {
      validate: {
        params: import_npm_joi.default.object({
          contractID: import_npm_joi.default.string().regex(CID_REGEX).required()
        }),
        query: import_npm_joi.default.object({
          r: import_npm_joi.default.string().required(),
          s: import_npm_joi.default.string().required(),
          sig: import_npm_joi.default.string().required(),
          hc: import_npm_joi.default.string().required()
        })
      }
    }, async function(req) {
      try {
        const salt = await getContractSalt(req.params["contractID"], req.query["r"], req.query["s"], req.query["sig"], req.query["hc"]);
        if (salt) {
          return salt;
        }
      } catch (e2) {
        e2.ip = req.headers["x-real-ip"] || req.info.remoteAddress;
        console.error(e2, "Error at GET /zkpp/{contractID}/contract_hash: " + e2.message);
      }
      return import_boom3.default.internal("internal error");
    });
    route.POST("/zkpp/{contractID}/updatePasswordHash", {
      validate: {
        params: import_npm_joi.default.object({
          contractID: import_npm_joi.default.string().regex(CID_REGEX).required()
        }),
        payload: import_npm_joi.default.object({
          r: import_npm_joi.default.string().required(),
          s: import_npm_joi.default.string().required(),
          sig: import_npm_joi.default.string().required(),
          hc: import_npm_joi.default.string().required(),
          Ea: import_npm_joi.default.string().required()
        })
      }
    }, async function(req) {
      if (process9.env.CHELONIA_ARCHIVE_MODE) return import_boom3.default.notImplemented("Server in archive mode");
      try {
        const { payload } = req;
        const result = await updateContractSalt(req.params["contractID"], payload["r"], payload["s"], payload["sig"], payload["hc"], payload["Ea"]);
        if (result) {
          return result;
        }
      } catch (e2) {
        e2.ip = req.headers["x-real-ip"] || req.info.remoteAddress;
        console.error(e2, "Error at POST /zkpp/{contractID}/updatePasswordHash: " + e2.message);
      }
      return import_boom3.default.internal("internal error");
    });
  }
});
var server_exports = {};
var import_boom4;
var Hapi2;
var import_inert2;
var import_npm_chalk3;
var createWorker;
var ownerSizeTotalWorker;
var creditsWorker;
var CONTRACTS_VERSION;
var GI_VERSION;
var hapi;
var appendToOrphanedNamesIndex;
var init_server = __esm({
  "src/serve/server.ts"() {
    "use strict";
    init_chelonia();
    init_persistent_actions();
    init_SPMessage();
    init_presets();
    init_functions();
    import_boom4 = __toESM(require_lib6());
    Hapi2 = __toESM(require_lib29());
    import_inert2 = __toESM(require_lib30());
    init_esm3();
    import_npm_chalk3 = __toESM(require_source());
    init_auth();
    init_constants2();
    init_database();
    init_errors2();
    init_events();
    init_instance_keys();
    init_pubsub2();
    init_push();
    createWorker = (path12) => {
      let worker;
      let ready;
      const launchWorker = () => {
        worker = new Worker(path12);
        return new Promise((resolve8, reject) => {
          const msgHandler = (msg) => {
            if (msg === "ready") {
              worker.off("error", reject);
              worker.on("error", (e2) => {
                console.error(e2, `Running worker ${basename6(path12)} terminated. Attempting relaunch...`);
                worker.off("message", msgHandler);
                ready = launchWorker().catch((e3) => {
                  console.error(e3, `Error on worker ${basename6(path12)} relaunch`);
                  process10.exit(1);
                });
              });
              resolve8();
            }
          };
          worker.on("message", msgHandler);
          worker.once("error", reject);
        });
      };
      ready = launchWorker();
      const rpcSbp = (...args) => {
        return ready.then(() => new Promise((resolve8, reject) => {
          const mc = new MessageChannel();
          const cleanup = /* @__PURE__ */ ((worker2) => () => {
            worker2.off("error", reject);
            mc.port2.onmessage = null;
            mc.port2.onmessageerror = null;
          })(worker);
          mc.port2.onmessage = (event) => {
            cleanup();
            const [success, result] = event.data;
            if (success) return resolve8(result);
            reject(result);
          };
          mc.port2.onmessageerror = () => {
            cleanup();
            reject(Error("Message error"));
          };
          worker.postMessage([mc.port1, ...args], [mc.port1]);
          worker.once("error", reject);
        }));
      };
      return {
        ready,
        rpcSbp,
        terminate: () => worker.terminate()
      };
    };
    if (CREDITS_WORKER_TASK_TIME_INTERVAL && OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL > CREDITS_WORKER_TASK_TIME_INTERVAL) {
      process10.stderr.write("The size calculation worker must run more frequently than the credits worker for accurate billing");
      process10.exit(1);
    }
    ownerSizeTotalWorker = process10.env.CHELONIA_ARCHIVE_MODE || !OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL ? void 0 : createWorker(join8(import.meta.dirname || ".", "serve", "ownerSizeTotalWorker.js"));
    creditsWorker = process10.env.CHELONIA_ARCHIVE_MODE || !CREDITS_WORKER_TASK_TIME_INTERVAL ? void 0 : createWorker(join8(import.meta.dirname || ".", "serve", "creditsWorker.js"));
    ({ CONTRACTS_VERSION, GI_VERSION } = process10.env);
    hapi = new Hapi2.Server({
      // debug: false, // <- Hapi v16 was outputing too many unnecessary debug statements
      //               // v17 doesn't seem to do this anymore so I've re-enabled the logging
      // debug: { log: ['error'], request: ['error'] },
      port: process10.env.API_PORT,
      // See: https://github.com/hapijs/discuss/issues/262#issuecomment-204616831
      routes: {
        cors: {
          // TODO: figure out if we can live with '*' or if we need to restrict it
          origin: ["*"]
          // origin: [
          //   process.env.API_URL,
          //   // improve support for browsersync proxy
          //   ...(process.env.NODE_ENV === 'development' && ['http://localhost:3000'])
          // ]
        }
      }
    });
    hapi.ext({
      type: "onPreResponse",
      method: function(request, h2) {
        try {
          if (!(request.response instanceof import_boom4.default.Boom)) {
            request.response.header("X-Frame-Options", "DENY");
          } else {
            request.response.output.headers["X-Frame-Options"] = "DENY";
          }
        } catch (err) {
          console.warn(import_npm_chalk3.default.yellow("[backend] Could not set X-Frame-Options header:", err.message));
        }
        return h2.continue;
      }
    });
    appendToOrphanedNamesIndex = appendToIndexFactory("_private_orphaned_names_index");
    esm_default("okTurtles.data/set", SERVER_INSTANCE, hapi);
    esm_default("sbp/selectors/register", {
      "backend/server/persistState": async function(deserializedHEAD) {
        const contractID = deserializedHEAD.contractID;
        const cheloniaState = esm_default("chelonia/rootState");
        if (!cheloniaState.contracts[contractID] || cheloniaState.contracts[contractID].height < deserializedHEAD.head.height) {
          return;
        }
        if (cheloniaState.contracts[contractID].HEAD === deserializedHEAD.hash) {
          const state = {
            contractState: cheloniaState[contractID],
            cheloniaContractInfo: cheloniaState.contracts[contractID]
          };
          await esm_default("chelonia.db/set", "_private_cheloniaState_" + contractID, JSON.stringify(state));
        }
        if (contractID === deserializedHEAD.hash) {
          await esm_default("backend/server/appendToContractIndex", contractID);
        }
        if (cheloniaState.contracts[contractID].previousKeyOp === deserializedHEAD.hash) {
          await appendToIndexFactory(`_private_keyop_idx_${contractID}_${deserializedHEAD.head.height - deserializedHEAD.head.height % KEYOP_SEGMENT_LENGTH}`)(String(deserializedHEAD.head.height));
        }
      },
      "backend/server/appendToContractIndex": appendToIndexFactory("_private_cheloniaState_index"),
      "backend/server/broadcastKV": async function(contractID, key, entry) {
        const pubsub = esm_default("okTurtles.data/get", PUBSUB_INSTANCE);
        const pubsubMessage = createKvMessage(contractID, key, entry);
        const subscribers = pubsub.enumerateSubscribers(contractID, key);
        console.debug(import_npm_chalk3.default.blue.bold(`[pubsub] Broadcasting KV change on ${contractID} to key ${key}`));
        await pubsub.broadcast(pubsubMessage, { to: subscribers, wsOnly: true });
      },
      "backend/server/broadcastEntry": async function(deserializedHEAD, entry) {
        const pubsub = esm_default("okTurtles.data/get", PUBSUB_INSTANCE);
        const contractID = deserializedHEAD.contractID;
        const contractType = esm_default("chelonia/rootState").contracts[contractID]?.type;
        const pubsubMessage = createMessage(NOTIFICATION_TYPE.ENTRY, entry, { contractID, contractType });
        const subscribers = pubsub.enumerateSubscribers(contractID);
        console.debug(import_npm_chalk3.default.blue.bold(`[pubsub] Broadcasting ${deserializedHEAD.description()}`));
        await pubsub.broadcast(pubsubMessage, { to: subscribers });
      },
      "backend/server/broadcastDeletion": async function(contractID) {
        const pubsub = esm_default("okTurtles.data/get", PUBSUB_INSTANCE);
        const pubsubMessage = createMessage(NOTIFICATION_TYPE.DELETION, contractID);
        const subscribers = pubsub.enumerateSubscribers(contractID);
        console.debug(import_npm_chalk3.default.blue.bold(`[pubsub] Broadcasting deletion of ${contractID}`));
        await pubsub.broadcast(pubsubMessage, { to: subscribers });
      },
      "backend/server/handleEntry": async function(deserializedHEAD, entry) {
        const contractID = deserializedHEAD.contractID;
        if (deserializedHEAD.head.op === SPMessage.OP_CONTRACT) {
          esm_default("okTurtles.data/get", PUBSUB_INSTANCE).channels.add(contractID);
        }
        await esm_default("chelonia/private/in/enqueueHandleEvent", contractID, entry);
        await esm_default("backend/server/persistState", deserializedHEAD, entry);
        esm_default("backend/server/broadcastEntry", deserializedHEAD, entry).catch((e2) => console.error(e2, "Error broadcasting entry", contractID, deserializedHEAD.hash));
      },
      "backend/server/saveOwner": async function(ownerID, resourceID) {
        await esm_default("chelonia/queueInvocation", ownerID, async () => {
          const owner = await esm_default("chelonia.db/get", ownerID);
          if (!owner) {
            throw new Error("Owner resource does not exist");
          }
          await esm_default("chelonia.db/set", `_private_owner_${resourceID}`, ownerID);
          const resourcesKey = `_private_resources_${ownerID}`;
          await appendToIndexFactory(resourcesKey)(resourceID);
          esm_default("chelonia.persistentActions/enqueue", ["backend/server/addToIndirectResourcesIndex", resourceID]);
        });
      },
      "backend/server/addToIndirectResourcesIndex": async function(resourceID) {
        const ownerID = await esm_default("chelonia.db/get", `_private_owner_${resourceID}`);
        let indirectOwnerID = ownerID;
        while (indirectOwnerID = await esm_default("chelonia.db/get", `_private_owner_${indirectOwnerID}`)) {
          await appendToIndexFactory(`_private_indirectResources_${indirectOwnerID}`)(resourceID);
        }
      },
      "backend/server/removeFromIndirectResourcesIndex": async function(resourceID) {
        const ownerID = await esm_default("chelonia.db/get", `_private_owner_${resourceID}`);
        const resources = await esm_default("chelonia.db/get", `_private_resources_${resourceID}`);
        const indirectResources = resources ? await esm_default("chelonia.db/get", `_private_indirectResources_${resourceID}`) : void 0;
        const allSubresources = [
          resourceID,
          ...resources ? resources.split("\0") : [],
          ...indirectResources ? indirectResources.split("\0") : []
        ];
        let indirectOwnerID = ownerID;
        while (indirectOwnerID = await esm_default("chelonia.db/get", `_private_owner_${indirectOwnerID}`)) {
          await removeFromIndexFactory(`_private_indirectResources_${indirectOwnerID}`)(allSubresources);
        }
      },
      "backend/server/registerBillableEntity": appendToIndexFactory("_private_billable_entities"),
      "backend/server/updateSize": function(resourceID, size, ultimateOwnerID) {
        const sizeKey = `_private_size_${resourceID}`;
        return updateSize(resourceID, sizeKey, size).then(() => {
          return ownerSizeTotalWorker?.rpcSbp("worker/updateSizeSideEffects", { resourceID, size, ultimateOwnerID });
        });
      },
      "backend/server/updateContractFilesTotalSize": function(resourceID, size) {
        const sizeKey = `_private_contractFilesTotalSize_${resourceID}`;
        return updateSize(resourceID, sizeKey, size, true);
      },
      "backend/server/stop": function() {
        return hapi.stop();
      },
      async "backend/deleteFile"(cid, ultimateOwnerID, skipIfDeleted) {
        const owner = await esm_default("chelonia.db/get", `_private_owner_${cid}`);
        const rawManifest = await esm_default("chelonia.db/get", cid);
        const size = await esm_default("chelonia.db/get", `_private_size_${cid}`);
        if (owner && !ultimateOwnerID) ultimateOwnerID = await lookupUltimateOwner(owner);
        if (rawManifest === "") {
          if (skipIfDeleted) return;
          throw new BackendErrorGone();
        }
        if (!rawManifest) {
          if (skipIfDeleted) return;
          throw new BackendErrorNotFound();
        }
        try {
          const manifest2 = JSON.parse(rawManifest);
          if (!manifest2 || typeof manifest2 !== "object") throw new BackendErrorBadData("manifest format is invalid");
          if (manifest2.version !== "1.0.0") throw new BackendErrorBadData("unsupported manifest version");
          if (!Array.isArray(manifest2.chunks) || !manifest2.chunks.length) throw new BackendErrorBadData("missing chunks");
          await Promise.all(manifest2.chunks.map(([, cid2]) => esm_default("chelonia.db/delete", cid2)));
        } catch (e2) {
          console.warn(e2, `Error parsing manifest for ${cid}. It's probably not a file manifest.`);
          throw new BackendErrorNotFound();
        }
        const resourcesKey = `_private_resources_${owner}`;
        await removeFromIndexFactory(resourcesKey)(cid);
        await esm_default("backend/server/removeFromIndirectResourcesIndex", cid);
        await esm_default("chelonia.db/delete", `_private_owner_${cid}`);
        await esm_default("chelonia.db/delete", `_private_size_${cid}`);
        await esm_default("chelonia.db/delete", `_private_deletionTokenDgst_${cid}`);
        await esm_default("chelonia.db/set", cid, "");
        await esm_default("backend/server/updateContractFilesTotalSize", owner, -Number(size));
        if (ultimateOwnerID && size) {
          await ownerSizeTotalWorker?.rpcSbp("worker/updateSizeSideEffects", { resourceID: cid, size: -parseInt(size), ultimateOwnerID });
        }
      },
      async "backend/deleteContract"(cid, ultimateOwnerID, skipIfDeleted) {
        let contractsPendingDeletion = esm_default("okTurtles.data/get", "contractsPendingDeletion");
        if (!contractsPendingDeletion) {
          contractsPendingDeletion = /* @__PURE__ */ new Set();
          esm_default("okTurtles.data/set", "contractsPendingDeletion", contractsPendingDeletion);
        }
        if (contractsPendingDeletion.has(cid)) {
          return;
        }
        contractsPendingDeletion.add(cid);
        return await esm_default("chelonia/queueInvocation", cid, async () => {
          const owner = await esm_default("chelonia.db/get", `_private_owner_${cid}`);
          if (!ultimateOwnerID) ultimateOwnerID = await lookupUltimateOwner(cid);
          const rawManifest = await esm_default("chelonia.db/get", cid);
          const size = await esm_default("chelonia.db/get", `_private_size_${cid}`);
          if (rawManifest === "") {
            if (skipIfDeleted) return;
            throw new BackendErrorGone();
          }
          if (!rawManifest) {
            if (skipIfDeleted) return;
            throw new BackendErrorNotFound();
          }
          const resourcesKey = `_private_resources_${cid}`;
          const resources = await esm_default("chelonia.db/get", resourcesKey);
          if (resources) {
            await Promise.allSettled(resources.split("\0").map((resourceCid) => {
              const parsed = parseCID(resourceCid);
              if (parsed.code === multicodes2.SHELTER_CONTRACT_DATA) {
                return esm_default("chelonia.persistentActions/enqueue", ["backend/deleteContract", resourceCid, ultimateOwnerID, true]);
              } else if (parsed.code === multicodes2.SHELTER_FILE_MANIFEST) {
                return esm_default("chelonia.persistentActions/enqueue", ["backend/deleteFile", resourceCid, ultimateOwnerID, true]);
              } else {
                console.warn({ cid, resourceCid, code: parsed.code }, "Resource should be deleted but it is of an unknown type");
              }
              return void 0;
            }));
          }
          await esm_default("chelonia.db/delete", resourcesKey);
          const latestHEADinfo = await esm_default("chelonia/db/latestHEADinfo", cid);
          if (latestHEADinfo) {
            for (let i2 = latestHEADinfo.height; i2 > 0; i2--) {
              const eventKey = `_private_hidx=${cid}#${i2}`;
              const event = await esm_default("chelonia.db/get", eventKey);
              if (event) {
                await esm_default("chelonia.db/delete", JSON.parse(event).hash);
                await esm_default("chelonia.db/delete", eventKey);
              }
              if (i2 % KEYOP_SEGMENT_LENGTH === 0) {
                await esm_default("chelonia.db/delete", `_private_keyop_idx_${cid}_${i2}`);
              }
            }
            await esm_default("chelonia/db/deleteLatestHEADinfo", cid);
          }
          const kvIndexKey = `_private_kvIdx_${cid}`;
          const kvKeys = await esm_default("chelonia.db/get", kvIndexKey);
          if (kvKeys) {
            await Promise.all(kvKeys.split("\0").map((key) => {
              return esm_default("chelonia.db/delete", `_private_kv_${cid}_${key}`);
            }));
          }
          await esm_default("chelonia.db/delete", kvIndexKey);
          await esm_default("backend/server/removeFromIndirectResourcesIndex", cid);
          await esm_default("chelonia.db/delete", `_private_indirectResources_${cid}`);
          await esm_default("chelonia.db/get", `_private_cid2name_${cid}`).then((name) => {
            if (!name) return;
            return Promise.all([
              esm_default("chelonia.db/delete", `_private_cid2name_${cid}`),
              appendToOrphanedNamesIndex(name)
            ]);
          });
          await esm_default("chelonia.db/delete", `_private_rid_${cid}`);
          await esm_default("chelonia.db/delete", `_private_owner_${cid}`);
          await esm_default("chelonia.db/delete", `_private_size_${cid}`);
          await esm_default("chelonia.db/delete", `_private_contractFilesTotalSize_${cid}`);
          await esm_default("chelonia.db/delete", `_private_deletionTokenDgst_${cid}`);
          await removeFromIndexFactory(`_private_resources_${owner}`)(cid);
          await esm_default("chelonia.db/delete", `_private_hidx=${cid}#0`);
          await esm_default("chelonia.db/delete", `_private_keyop_idx_${cid}_0`);
          await esm_default("chelonia.db/set", cid, "");
          esm_default("chelonia/private/removeImmediately", cid);
          if (size) {
            await ownerSizeTotalWorker?.rpcSbp("worker/updateSizeSideEffects", { resourceID: cid, size: -parseInt(size), ultimateOwnerID });
          }
          await esm_default("chelonia.db/delete", `_private_cheloniaState_${cid}`);
          await removeFromIndexFactory("_private_cheloniaState_index")(cid);
          await removeFromIndexFactory("_private_billable_entities")(cid);
          esm_default("backend/server/broadcastDeletion", cid).catch((e2) => {
            console.error(e2, "Error broadcasting contract deletion", cid);
          });
        }).finally(() => {
          contractsPendingDeletion.delete(cid);
        }).catch((e2) => {
          console.error(e2, "Error in contract deletion cleanup");
          throw e2;
        });
      }
    });
    if (process10.env.NODE_ENV === "development" && !process10.env.CI) {
      hapi.events.on("response", (req) => {
        const ip = req.headers["x-real-ip"] || req.info.remoteAddress;
        const statusCode = req.response instanceof import_boom4.default.Boom ? req.response.output.statusCode : req.response.statusCode;
        console.debug(import_npm_chalk3.default`{grey ${ip}: ${req.method} ${req.path} --> ${statusCode}}`);
      });
    }
    esm_default("okTurtles.data/set", PUBSUB_INSTANCE, createServer(hapi.listener, {
      serverHandlers: {
        connection(socket) {
          const versionInfo = {
            GI_VERSION: GI_VERSION || null,
            CONTRACTS_VERSION: CONTRACTS_VERSION || null
          };
          socket.send(createNotification(NOTIFICATION_TYPE.VERSION_INFO, versionInfo));
        }
      },
      socketHandlers: {
        // The `close()` handler signals the server that the WS has been closed and
        // that subsequent messages to subscribed channels should now be sent to its
        // associated web push subscription, if it exists.
        close() {
          const socket = this;
          const { server } = this;
          const subscriptionId = socket.pushSubscriptionId;
          if (!subscriptionId) return;
          if (!server.pushSubscriptions[subscriptionId]) return;
          server.pushSubscriptions[subscriptionId].sockets.delete(socket);
          delete socket.pushSubscriptionId;
          if (server.pushSubscriptions[subscriptionId].sockets.size === 0) {
            server.pushSubscriptions[subscriptionId].subscriptions.forEach((channelID) => {
              if (!server.subscribersByChannelID[channelID]) {
                server.subscribersByChannelID[channelID] = /* @__PURE__ */ new Set();
              }
              server.subscribersByChannelID[channelID].add(server.pushSubscriptions[subscriptionId]);
            });
          }
        }
      },
      messageHandlers: {
        [REQUEST_TYPE.PUSH_ACTION]: async function({ data }) {
          const socket = this;
          const { action, payload } = data;
          if (!action) {
            socket.send(createPushErrorResponse({ message: "'action' field is required" }));
          }
          const handler = pushServerActionhandlers[action];
          if (handler) {
            try {
              await handler.call(socket, payload);
            } catch (error) {
              const message = error?.message || `push server failed to perform [${action}] action`;
              console.warn(error, `[${socket.ip}] Action '${action}' for '${REQUEST_TYPE.PUSH_ACTION}' handler failed: ${message}`);
              socket.send(createPushErrorResponse({ actionType: action, message }));
            }
          } else {
            socket.send(createPushErrorResponse({ message: `No handler for the '${action}' action` }));
          }
        },
        // This handler adds subscribed channels to the web push subscription
        // associated with the WS, so that when the WS is closed we can continue
        // sending messages as web push notifications.
        [NOTIFICATION_TYPE.SUB]({ channelID }) {
          const socket = this;
          const { server } = this;
          if (!socket.pushSubscriptionId) return;
          if (!server.pushSubscriptions[socket.pushSubscriptionId]) {
            delete socket.pushSubscriptionId;
            return;
          }
          addChannelToSubscription(server, socket.pushSubscriptionId, channelID);
        },
        // This handler removes subscribed channels from the web push subscription
        // associated with the WS, so that when the WS is closed we don't send
        // messages as web push notifications.
        [NOTIFICATION_TYPE.UNSUB]({ channelID }) {
          const socket = this;
          const { server } = this;
          if (!socket.pushSubscriptionId) return;
          if (!server.pushSubscriptions[socket.pushSubscriptionId]) {
            delete socket.pushSubscriptionId;
            return;
          }
          deleteChannelFromSubscription(server, socket.pushSubscriptionId, channelID);
        }
      }
    }));
    (async function() {
      await initDB();
      await ownerSizeTotalWorker?.ready;
      await creditsWorker?.ready;
      await esm_default("chelonia/configure", SERVER);
      esm_default("chelonia.persistentActions/configure", {
        databaseKey: "_private_persistent_actions"
      });
      const savedStateIndex = await esm_default("chelonia.db/get", "_private_cheloniaState_index");
      if (savedStateIndex) {
        const recoveredState = /* @__PURE__ */ Object.create(null);
        recoveredState.contracts = /* @__PURE__ */ Object.create(null);
        const channels = esm_default("okTurtles.data/get", PUBSUB_INSTANCE).channels;
        await Promise.all(savedStateIndex.split("\0").map(async (contractID) => {
          const cpSerialized = await esm_default("chelonia.db/get", `_private_cheloniaState_${contractID}`);
          if (!cpSerialized) {
            console.warn(`[server] missing state for contractID ${contractID} - skipping setup for this contract`);
            return;
          }
          const cp = JSON.parse(cpSerialized);
          recoveredState[contractID] = cp.contractState;
          recoveredState.contracts[contractID] = cp.cheloniaContractInfo;
          channels.add(contractID);
        }));
        Object.assign(esm_default("chelonia/rootState"), recoveredState);
      }
      const savedWebPushIndex = await esm_default("chelonia.db/get", "_private_webpush_index");
      if (savedWebPushIndex) {
        const { pushSubscriptions, subscribersByChannelID } = esm_default("okTurtles.data/get", PUBSUB_INSTANCE);
        await Promise.all(savedWebPushIndex.split("\0").map(async (subscriptionId) => {
          const subscriptionSerialized = await esm_default("chelonia.db/get", `_private_webpush_${subscriptionId}`);
          if (!subscriptionSerialized) {
            console.warn(`[server] missing state for subscriptionId '${subscriptionId}' - skipping setup for this subscription`);
            return;
          }
          const { settings, subscriptionInfo, channelIDs } = JSON.parse(subscriptionSerialized);
          pushSubscriptions[subscriptionId] = subscriptionInfoWrapper(subscriptionId, subscriptionInfo, { channelIDs, settings });
          channelIDs.forEach((channelID) => {
            if (!subscribersByChannelID[channelID]) subscribersByChannelID[channelID] = /* @__PURE__ */ new Set();
            subscribersByChannelID[channelID].add(pushSubscriptions[subscriptionId]);
          });
        }));
      }
      esm_default("chelonia.persistentActions/load").catch((e2) => {
        console.error(e2, "Error loading persistent actions");
      });
      await hapi.register([
        { plugin: auth_default },
        { plugin: import_inert2.default }
        // {
        //   plugin: require('hapi-pino'),
        //   options: {
        //     instance: logger
        //   }
        // }
      ]);
      await Promise.resolve().then(() => (init_routes(), routes_exports));
      await hapi.start();
      console.info("Backend server running at:", hapi.info.uri);
      esm_default("okTurtles.events/emit", SERVER_RUNNING, hapi);
    })();
    (() => {
      const map = /* @__PURE__ */ new WeakMap();
      setInterval(() => {
        const now = Date.now();
        const pubsub = esm_default("okTurtles.data/get", PUBSUB_INSTANCE);
        const notification = JSON.stringify({ type: "recurring" });
        Object.values(pubsub?.pushSubscriptions || {}).filter(
          (pushSubscription) => !!pushSubscription.settings.heartbeatInterval && pushSubscription.sockets.size === 0
        ).forEach((pushSubscription) => {
          const last = map.get(pushSubscription) ?? Number.NEGATIVE_INFINITY;
          if (now - last < pushSubscription.settings.heartbeatInterval) return;
          postEvent(pushSubscription, notification).then(() => {
            map.set(pushSubscription, now);
          }).catch((e2) => {
            console.warn(e2, "Error sending recurring message to web push client", pushSubscription.id);
          });
        });
      }, 1 * 60 * 60 * 1e3);
    })();
  }
});
var serve_exports = {};
__export(serve_exports, {
  default: () => serve_default
});
function logSBP(_domain, selector, data) {
  if (!dontLog[selector]) {
    if (selector === "backend/server/handleEntry") {
      console.debug(import_npm_chalk4.default.bold(`[sbp] ${selector}`), data[0].description());
    } else {
      console.debug(import_npm_chalk4.default.bold(`[sbp] ${selector}`), data);
    }
  }
}
var import_npm_chalk4;
var dontLog;
var serve_default;
var exit2;
var handleSignal;
var init_serve = __esm({
  "src/serve/index.ts"() {
    "use strict";
    init_module();
    init_esm4();
    init_esm5();
    init_esm3();
    import_npm_chalk4 = __toESM(require_source());
    init_events();
    init_instance_keys();
    init_logger();
    console.info("NODE_ENV =", process11.env.NODE_ENV);
    dontLog = {
      "backend/server/broadcastEntry": true,
      "backend/server/broadcastDeletion": true,
      "backend/server/broadcastKV": true
    };
    ["backend"].forEach((domain) => esm_default("sbp/filters/domain/add", domain, logSBP));
    [].forEach((sel) => esm_default("sbp/filters/selector/add", sel, logSBP));
    serve_default = new Promise((resolve8, reject) => {
      esm_default("okTurtles.events/on", SERVER_RUNNING, function() {
        console.info(import_npm_chalk4.default.bold("backend startup sequence complete."));
        resolve8();
      });
      Promise.resolve().then(() => (init_server(), server_exports)).catch(reject);
    });
    esm_default("okTurtles.events/once", SERVER_EXITING, () => {
      esm_default("okTurtles.data/apply", PUBSUB_INSTANCE, function(pubsub) {
        esm_default("okTurtles.eventQueue/queueEvent", SERVER_EXITING, () => {
          return new Promise((resolve8) => {
            pubsub.on("close", async function() {
              try {
                await esm_default("backend/server/stop");
                console.info("Hapi server down");
              } catch (err) {
                console.error(err, "Error during shutdown");
              } finally {
                resolve8();
              }
            });
            pubsub.close();
            pubsub.clients.forEach((client) => client.terminate());
          });
        });
      });
    });
    process11.on("uncaughtException", (err) => {
      console.error(err, "[server] Unhandled exception");
      process11.exit(1);
    });
    process11.on("unhandledRejection", (reason) => {
      console.error(reason, "[server] Unhandled promise rejection:", reason);
      process11.exit(1);
    });
    exit2 = (code2) => {
      esm_default("okTurtles.events/once", SERVER_EXITING, () => {
        esm_default("okTurtles.eventQueue/queueEvent", SERVER_EXITING, () => {
          process11.send?.({});
          process11.nextTick(() => process11.exit(code2));
        });
      });
      esm_default("okTurtles.events/emit", SERVER_EXITING);
    };
    handleSignal = (signal, code2) => {
      process11.on(signal, () => {
        console.error(`Exiting upon receiving ${signal} (${code2})`);
        exit2(128 + code2);
      });
    };
    [
      ["SIGHUP", 1],
      ["SIGINT", 2],
      ["SIGQUIT", 3],
      ["SIGTERM", 15],
      ["SIGUSR1", 10],
      ["SIGUSR2", 11]
    ].forEach(([signal, code2]) => handleSignal(signal, code2));
    process11.on("message", (message) => {
      console.info("message received in child, shutting down...", message);
      exit2(0);
    });
  }
});
var commands_exports = {};
__export(commands_exports, {
  deploy: () => deploy,
  eventsAfter: () => eventsAfter,
  get: () => get2,
  hash: () => hash3,
  help: () => help,
  keygen: () => keygen2,
  manifest: () => manifest,
  migrate: () => migrate,
  serve: () => serve,
  upload: () => upload,
  verifySignature: () => verifySignature2,
  version: () => version3
});
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init2(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init2(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init2 });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert2,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert2(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v2) => typeof v2 === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v2]) => v2);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  const set = false;
  Object.defineProperty(object2, key, {
    get() {
      if (!set) {
        const value = getter();
        object2[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v2) {
      Object.defineProperty(object2, key, {
        value: v2
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path12) {
  if (!path12)
    return obj;
  return path12.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      resolvedObj[keys[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
function randomString(length4 = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i2 = 0; i2 < length4; i2++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o2) {
  if (isObject(o2) === false)
    return false;
  const ctor = o2.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x3, startIndex = 0) {
  for (let i2 = startIndex; i2 < x3.issues.length; i2++) {
    if (x3.issues[i2]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path12, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path12);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = /* @__PURE__ */ $constructor("$ZodError", initializer);
var $ZodRealError = /* @__PURE__ */ $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version4) => {
  if (!version4)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version4}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length4 > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x3) => x3);
    const minIndent = Math.min(...lines.map((x3) => x3.length - x3.trimStart().length));
    const dedented = lines.map((x3) => x3.slice(minIndent)).map((x3) => " ".repeat(this.indent * 2) + x3);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x3) => `  ${x3}`)];
    return new F(...args, lines.join("\n"));
  }
};
var version = {
  major: 4,
  minor: 0,
  patch: 5
};
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v2 = versionMap[def.version];
    if (v2 === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v2 of field.values)
          propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v2 = def.innerType._zod.values;
    return v2 ? new Set([...v2].filter((x3) => x3 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = /* @__PURE__ */ registry();
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length4, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length: length4
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = /* @__PURE__ */ $constructor("ZodError", initializer2);
var ZodRealError = /* @__PURE__ */ $constructor("ZodError", initializer2, {
  Parent: Error
});
var parse7 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse7(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options3, params) {
  return new ZodUnion({
    type: "union",
    options: options3,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [v2, v2])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
init_utils();
async function upload(args, internal = false) {
  const [urlOrDirOrSqliteFile, ...files] = args;
  if (files.length === 0) throw new Error("missing files!");
  const uploaded = [];
  const uploaderFn = await isDir(urlOrDirOrSqliteFile) ? uploadEntryToDir : urlOrDirOrSqliteFile.endsWith(".db") ? uploadEntryToSQLite : uploadEntryToURL;
  for (const filepath_ of files) {
    let type = multicodes.RAW;
    let filepath = filepath_;
    if (internal) {
      if (filepath_[1] !== "|") throw new Error("Invalid path format");
      switch (filepath_[0]) {
        case "r":
          break;
        case "m":
          type = multicodes.SHELTER_CONTRACT_MANIFEST;
          break;
        case "t":
          type = multicodes.SHELTER_CONTRACT_TEXT;
          break;
        default:
          throw new Error("Unknown file type: " + filepath_[0]);
      }
      filepath = filepath_.slice(2);
    }
    const entry = await createEntryFromFile(filepath, type);
    const destination = await uploaderFn(entry, urlOrDirOrSqliteFile);
    if (!internal) {
      console.log(green("uploaded:"), destination);
    } else {
      console.log(green(`${relative3(".", filepath)}:`), destination);
    }
    uploaded.push([filepath, destination]);
  }
  return uploaded;
}
async function uploadEntryToURL([cid, buffer], url) {
  const form = new FormData();
  form.append("hash", cid);
  form.append("data", new Blob([buffer]));
  return await fetch(`${url}/dev-file`, { method: "POST", body: form }).then(handleFetchResult("text")).then((r) => {
    if (r !== `/file/${cid}`) {
      throw new Error(`server returned bad URL: ${r}`);
    }
    return `${url}${r}`;
  });
}
async function uploadEntryToDir([cid, buffer], dir) {
  await revokeNet();
  const destination = join3(dir, cid);
  await Deno.writeFile(destination, buffer);
  return destination;
}
async function uploadEntryToSQLite([cid, buffer], sqlitedb) {
  await revokeNet();
  const { initStorage: initStorage3, writeData: writeData3 } = await Promise.resolve().then(() => (init_database_sqlite(), database_sqlite_exports));
  await initStorage3({ dirname: dirname3(sqlitedb), filename: basename3(sqlitedb) });
  await writeData3(cid, buffer);
  return cid;
}
function handleFetchResult(type) {
  return async function(r) {
    if (!r.ok) throw new Error(`${r.status}: ${r.statusText}`);
    return await r[type]();
  };
}
var CONTRACT_TEXT_PREFIX = "t|";
var CONTRACT_MANIFEST_PREFIX = "m|";
var ContractBodySchema = object({
  contract: object({ file: string2() }),
  contractSlim: object({ file: string2() }).optional()
});
async function deploy(args) {
  const [urlOrDirOrSqliteFile, ...manifests] = args;
  if (manifests.length === 0) throw new Error("missing url or manifests!");
  const toUpload = [];
  for (const manifestPath of manifests) {
    const json = JSON.parse(Deno.readTextFileSync(manifestPath));
    const body = ContractBodySchema.parse(JSON.parse(json.body));
    const dirname6 = dirname3(manifestPath);
    toUpload.push(CONTRACT_TEXT_PREFIX + join3(dirname6, body.contract.file));
    if (body.contractSlim) {
      toUpload.push(CONTRACT_TEXT_PREFIX + join3(dirname6, body.contractSlim.file));
    }
    toUpload.push(CONTRACT_MANIFEST_PREFIX + manifestPath);
  }
  await upload([urlOrDirOrSqliteFile, ...toUpload], true);
}
init_utils();
var backend;
var defaultLimit = 50;
var headPrefix = "head=";
async function eventsAfter(args) {
  const parsedArgs = parse6(args);
  const limit = Number(parsedArgs.limit ?? defaultLimit);
  if (!isArrayLength(limit)) exit("argument --limit must be a valid array length");
  const [urlOrLocalPath, contractID] = parsedArgs._.map(String);
  const height = Number(parsedArgs._[2]);
  const src4 = urlOrLocalPath;
  try {
    let messages;
    if (isURL(src4)) {
      messages = await getRemoteMessagesSince(src4, contractID, height, limit);
    } else {
      messages = await getMessagesSince(src4, contractID, height, limit);
    }
    console.log(JSON.stringify(messages, null, 2));
  } catch (error) {
    exit(error);
  }
}
async function getMessage(hash32) {
  const value = await readString(hash32);
  if (!value) throw new Error(`no entry for ${hash32}!`);
  return JSON.parse(value);
}
async function getMessagesSince(src4, contractID, sinceHeight, limit) {
  backend = await getBackend(src4);
  const contractHEAD = await readString(`${headPrefix}${contractID}`);
  if (contractHEAD === void 0) {
    throw new Deno.errors.NotFound(`contract ${contractID} doesn't exist!`);
  }
  const entries = [];
  let currentHEAD = JSON.parse(contractHEAD).HEAD;
  let currentHeight;
  while (true) {
    const entry = await getMessage(currentHEAD);
    if (!entry) {
      throw new Deno.errors.NotFound(`entry ${currentHEAD} no longer exists.`);
    }
    const head = JSON.parse(entry.head);
    currentHeight = head.height;
    entries.push(entry);
    if (currentHeight === sinceHeight) {
      break;
    }
    currentHEAD = head.previousHEAD;
  }
  return entries.reverse().slice(0, limit);
}
async function getRemoteMessagesSince(src4, contractID, sinceHeight, limit) {
  const response = await fetch(`${src4}/eventsAfter/${contractID}/${sinceHeight}`);
  if (!response.ok) {
    const bodyText = await response.text().catch(() => "") || "";
    throw new Error(`failed network request to ${src4}: ${response.status} - ${response.statusText} - '${bodyText}'`);
  }
  const b64messages = await response.json();
  if (b64messages.length > limit) {
    b64messages.length = limit;
  }
  return b64messages.map((b64str) => JSON.parse(new TextDecoder().decode(decodeBase64(b64str))));
}
async function readString(key) {
  const rv = await backend.readData(key);
  if (rv === void 0) return void 0;
  return typeof rv === "string" ? rv : new TextDecoder().decode(rv);
}
init_utils();
async function get2(args) {
  const parsedArgs = parse6(args);
  const [urlOrLocalPath, key] = parsedArgs._.map(String);
  const src4 = urlOrLocalPath;
  try {
    const data = isURL(src4) ? await readRemoteData(src4, key) : await (await getBackend(src4)).readData(key);
    if (data === void 0) exit(`no entry found for ${key}`);
    if (typeof data === "string") {
      console.log(data);
    } else {
      await writeAll(Deno.stdout, data);
    }
  } catch (error) {
    exit(error);
  }
}
init_utils();
async function hash3(args, multicode = multicodes.RAW, internal = false) {
  const [filename] = args;
  if (!filename) {
    console.error("please pass in a file");
    Deno.exit(1);
  }
  const [cid] = await createEntryFromFile(filename, multicode);
  if (!internal) {
    console.log(`CID(${filename}):`, cid);
  }
  return cid;
}
function help(args) {
  if (args == null || args.length === 0) {
    console.log(`
      chel
      chel help [command]
      chel version
      chel keygen [--out <key.json>] [--pubout <key.pub.json>]
      chel verifySignature [-k <pubkey.json>] <manifest.json>
      chel manifest [-k|--key <pubkey1.json> [-k|--key <pubkey2.json> ...]] [--out=<manifest.json>] [-s|--slim <contract-slim.js>] [-v|--version <version>] [-n|--name <name>] <key.json> <contract-bundle.js>
      chel deploy <url-or-dir-or-sqlitedb> <contract-manifest.json> [<manifest2.json> [<manifest3.json> ...]]
      chel upload <url-or-dir-or-sqlitedb> <file1> [<file2> [<file3> ...]]
      chel latestState <url> <contractID>
      chel eventsAfter [--limit N] <url-or-dir-or-sqlitedb> <contractID> <height>
      chel eventsBefore [--limit N] <url> <contractID> <hash>
      chel get <url-or-dir-or-sqlitedb> <hash>
      chel hash <file>
      chel migrate --from <backend> --to <backend> --out <dir-or-sqlitedb> <dir-or-sqlitedb>
    `);
  } else if (helpDict[args[0]]) {
    console.log(helpDict[args[0]]);
  } else {
    console.error(`Unknown command: ${args[0]}`);
  }
}
var helpDict = {
  help: `
    chel help [command]
  `,
  version: `
    chel version
  `,
  hash: `
    chel hash <file>

    Computes and logs the content identifier (CID) for the given file.
    File contents will be interpreted as raw binary data, unless the file extension is '.json'.
  `,
  manifest: `
    chel manifest [-k|--key <pubkey1> [-k|--key <pubkey2> ...]]
                  [--out=<manifest.json>]
                  [--slim <contract-slim.js>]
                  [-v|--version <version>]
                  <key.json> <contract-bundle.js>

    If unspecified, <version> is set to 'x'.
  `,
  migrate: `
    chel migrate --from (fs|sqlite) --to (fs|sqlite) --out <dir-or-sqlitedb> [<dir-or-sqlitedb>='.']

    Reads all key-value pairs from a given database and creates or updates another database accordingly.
    - The output database will be created if necessary.
    - The source database won't be modified nor deleted.
    - Invalid key-value pairs entries will be skipped.
    - Arguments --from and --to must be different.
    - The source and --out must resolve to distinct paths.
    - Requires read and write access to the source.
    - Requires read and write access to --out.
  `,
  upload: `
    chel upload <url-or-dir-or-sqlitedb> <file1> [<file2> [<file3> ...]]

    Requires read and write access to the destination.
  `,
  deploy: `
    chel deploy <url-or-dir> <contract-manifest.json> [<manifest2.json> [<manifest3.json> ...]]
  `,
  eventsAfter: `
    chel eventsAfter [--limit N=50] <url-or-localpath> <contractID> <hash>

    Displays a JSON array of the N first events that happened in a given contract, since a given entry identified by its hash.
    - Older events are displayed first.
    - The output is parseable with tools such as 'jq'.
    - If <hash> is the same as <contractID>, then the oldest events will be returned.
    - If <url-or-localpath> is a URL, then its /eventsAfter REST endpoint will be called.
  `,
  get: `
    chel get <url-or-dir-or-sqlitedb> <hash>
    
    Retrieves the entry associated with a given <hash> key, from a given database or server.
    When the first argument is a URL, this queries the GET <url>/file/<hash> route.

    - The output can be piped to a file, like this:
      chel get https://url.com mygreatlongkey > file.png
  `
};
init_esm2();
init_utils();
var keygen2 = async (args) => {
  await revokeNet();
  const parsedArgs = parse6(args);
  const key = keygen(EDWARDS25519SHA512BATCH);
  const pubKeyData = {
    version: "1.0.0",
    pubkey: serializeKey(key, false)
  };
  const keyData = {
    ...pubKeyData,
    privkey: serializeKey(key, true)
  };
  const result = JSON.stringify(keyData);
  const pubResult = JSON.stringify(pubKeyData);
  const idx = keyId(key).slice(-12);
  const outFile = parsedArgs.out || `${EDWARDS25519SHA512BATCH}-${idx}.json`;
  const pubOutFile = parsedArgs.pubout || `${EDWARDS25519SHA512BATCH}-${idx}.pub.json`;
  await Deno.writeTextFile(outFile, result);
  console.log(green("wrote:"), outFile, blue("(secret)"));
  await Deno.writeTextFile(pubOutFile, pubResult);
  console.log(green("wrote:"), pubOutFile, blue("(public)"));
};
init_esm2();
init_utils();
function isSigningKeyDescriptor(obj) {
  return obj !== null && typeof obj === "object" && typeof obj.privkey === "string";
}
async function manifest(args) {
  await revokeNet();
  const parsedArgs = parse6(args, { collect: ["key"], alias: { key: "k" } });
  const [keyFileRaw, contractFileRaw] = parsedArgs._;
  if (typeof keyFileRaw !== "string" || typeof contractFileRaw !== "string") {
    exit("Missing or invalid key or contract file");
  }
  const keyFile = keyFileRaw;
  const contractFile = contractFileRaw;
  const parsedFilepath = parse3(contractFile);
  const { name: contractFileName, base: contractBasename, dir: contractDir } = parsedFilepath;
  const name = parsedArgs.name || parsedArgs.n || contractFileName;
  const version4 = parsedArgs.version || parsedArgs.v || "x";
  const slim = parsedArgs.slim || parsedArgs.s;
  const outFile = parsedArgs.out || join3(contractDir, `${contractFileName}.${version4}.manifest.json`);
  if (!keyFile) exit("Missing signing key file");
  const signingKeyDescriptorRaw = await readJsonFile(keyFile);
  if (!isSigningKeyDescriptor(signingKeyDescriptorRaw)) {
    exit("Invalid signing key file: missing or invalid privkey", true);
  }
  const signingKeyDescriptor = signingKeyDescriptorRaw;
  const signingKey = deserializeKey(signingKeyDescriptor.privkey);
  const publicKeys = Array.from(new Set(
    [serializeKey(signingKey, false)].concat(...await Promise.all(parsedArgs.key?.map(
      async (kf) => {
        if (typeof kf !== "string" && typeof kf !== "number") {
          exit(`Invalid key file reference: ${String(kf)}`);
        }
        const descriptor = await readJsonFile(String(kf));
        const key = deserializeKey(descriptor.pubkey);
        if (key.type !== EDWARDS25519SHA512BATCH) {
          exit(`Invalid key type ${key.type}; only ${EDWARDS25519SHA512BATCH} keys are supported.`);
        }
        return serializeKey(key, false);
      }
    ) || []))
  ));
  const body = {
    name,
    version: version4,
    contract: {
      hash: await hash3([contractFile], multicodes.SHELTER_CONTRACT_TEXT, true),
      file: contractBasename
    },
    signingKeys: publicKeys
  };
  if (typeof slim === "string" && slim !== "") {
    body.contractSlim = {
      file: basename3(slim),
      hash: await hash3([slim], multicodes.SHELTER_CONTRACT_TEXT, true)
    };
  }
  const serializedBody = JSON.stringify(body);
  const head = { manifestVersion: "1.0.0" };
  const serializedHead = JSON.stringify(head);
  const manifest2 = JSON.stringify({
    head: serializedHead,
    body: serializedBody,
    signature: {
      keyId: keyId(signingKey),
      value: sign(signingKey, serializedBody + serializedHead)
    }
  });
  if (parsedArgs.out === "-") {
    console.log(manifest2);
  } else {
    Deno.writeTextFileSync(outFile, manifest2);
    console.log(green("wrote:"), outFile);
  }
}
init_utils();
async function migrate(args) {
  await revokeNet();
  const parsedArgs = parse6(args);
  const { from: from6, to, out } = parsedArgs;
  const src4 = resolve3(parsedArgs._[0] ? String(parsedArgs._[0]) : ".");
  if (!from6) exit("missing argument: --from");
  if (!to) exit("missing argument: --to");
  if (!out) exit("missing argument: --out");
  if (from6 === to) exit("arguments --from and --to must be different");
  let backendFrom;
  let backendTo;
  try {
    backendFrom = await getBackend(src4, { type: from6, create: false });
    backendTo = await getBackend(out, { type: to, create: true });
  } catch (error) {
    exit(error);
  }
  const numKeys2 = await backendFrom.count();
  let numVisitedKeys = 0;
  for await (const key of backendFrom.iterKeys()) {
    if (!isValidKey(key)) continue;
    const value = await backendFrom.readData(key);
    if (value === void 0) continue;
    if (isNotHashKey(key)) {
      await backendTo.writeData(key, value);
    } else {
      await backendTo.writeDataOnce(key, value);
    }
    ++numVisitedKeys;
    if (numVisitedKeys % (numKeys2 / 10) < 1) {
      console.log(`[chel] Migrating... ${Math.round(numVisitedKeys / (numKeys2 / 10))}0% done`);
    }
  }
  numKeys2 && console.log(`[chel] ${green("Migrated:")} ${numKeys2} entries`);
}
async function startDashboardServer(port) {
  const dashboardServer = await Promise.resolve().then(() => (init_dashboard_server(), dashboard_server_exports));
  await dashboardServer.startDashboard(port);
}
async function startApplicationServer(port, directory) {
  process12.env.API_PORT = port.toString();
  process12.env.CHELONIA_APP_DIR = directory;
  const startServer = await Promise.resolve().then(() => (init_serve(), serve_exports));
  await startServer.default;
}
async function serve(args) {
  const { directory, options: options3 } = parseServeArgs(args);
  const {
    dp: dashboardPort = 8888,
    port: applicationPort = 8e3,
    "db-type": dbType = "mem",
    "db-location": dbLocation
  } = options3;
  console.log(cyan("\u{1F680} Starting Chelonia app server..."));
  console.log(blue("Directory:"), directory || "");
  console.log(blue("Dashboard port:"), dashboardPort);
  console.log(blue("Application port:"), applicationPort);
  console.log(blue("Database type:"), dbType);
  if (dbLocation) {
    console.log(gray(`Database location: ${dbLocation}`));
  }
  try {
    console.log(cyan("\u{1F680} Starting dashboard server..."));
    try {
      await startDashboardServer(dashboardPort);
      console.log(green(`\u2705 Dashboard server started on port ${dashboardPort}`));
    } catch (error) {
      console.error(red("\u274C Failed to start dashboard server:"), error);
      throw error;
    }
    console.log(cyan("\u{1F680} Starting application server..."));
    try {
      await startApplicationServer(applicationPort, directory);
      console.log(green(`\u2705 Application server started on port ${applicationPort}`));
    } catch (error) {
      console.error(red("\u274C Failed to start application server:"), error);
      throw error;
    }
    console.log(green("\u2705 Both servers started successfully!"));
    console.log(yellow(`\u{1F4CA} Dashboard: http://localhost:${dashboardPort}`));
    console.log(yellow(`\u{1F310} Application: http://localhost:${applicationPort}`));
    await new Promise(() => {
    });
  } catch (error) {
    console.error(red("\u274C Failed to start server:"), error);
    process12.exit(1);
  }
}
function parseServeArgs(args) {
  const parsed = parse6(args, {
    string: ["dp", "port", "db-type", "db-location"],
    default: {
      dp: "8888",
      port: "8000",
      "db-type": "mem"
    }
  });
  const directory = parsed._[0] || ".";
  const options3 = {
    dp: parseInt(parsed.dp),
    port: parseInt(parsed.port),
    "db-type": parsed["db-type"],
    "db-location": parsed["db-location"]
  };
  return { directory, options: options3 };
}
init_esm2();
init_utils();
function isExternalKeyDescriptor(obj) {
  return obj !== null && typeof obj === "object" && typeof obj.pubkey === "string";
}
function isManifest(obj) {
  const maybe = obj;
  return typeof obj === "object" && obj !== null && typeof maybe.head === "string" && typeof maybe.body === "string" && typeof maybe.signature === "object" && maybe.signature !== null;
}
var verifySignature2 = async (args, internal = false) => {
  await revokeNet();
  const parsedArgs = parse6(args);
  const [manifestFile] = parsedArgs._;
  const keyFile = parsedArgs.k;
  const [externalKeyDescriptorRaw, manifestRaw] = await Promise.all([
    typeof keyFile === "string" ? readJsonFile(keyFile) : null,
    readJsonFile(manifestFile)
  ]);
  let externalKeyDescriptor;
  if (keyFile && externalKeyDescriptorRaw) {
    if (!isExternalKeyDescriptor(externalKeyDescriptorRaw)) {
      return exit("Public key missing from key file", internal);
    }
    externalKeyDescriptor = externalKeyDescriptorRaw;
  }
  if (!isManifest(manifestRaw)) {
    return exit("Invalid manifest: missing signature key ID", internal);
  }
  const manifest2 = manifestRaw;
  if (!manifest2.head) {
    exit("Invalid manifest: missing head", internal);
  }
  if (!manifest2.body) {
    exit("Invalid manifest: missing body", internal);
  }
  if (!manifest2.signature) {
    exit("Invalid manifest: missing signature", internal);
  }
  if (!manifest2.signature.keyId) {
    exit("Invalid manifest: missing signature key ID", internal);
  }
  if (!manifest2.signature.value) {
    exit("Invalid manifest: missing signature value", internal);
  }
  const body = JSON.parse(manifest2.body);
  const signingKey = body.signingKeys?.find((k) => {
    return keyId(k) === manifest2.signature.keyId;
  });
  if (externalKeyDescriptor) {
    const id = keyId(externalKeyDescriptor.pubkey);
    if (manifest2.signature.keyId !== id) {
      exit(`Invalid manifest signature: key ID doesn't match the provided key file. Expected ${id} but got ${manifest2.signature.keyId}.`, internal);
    }
  }
  const serializedPubKey = signingKey || externalKeyDescriptor?.pubkey;
  if (!serializedPubKey) {
    exit("The manifest appears to be signed but verification can't proceed because the key used is unknown.", internal);
  }
  const pubKey = deserializeKey(serializedPubKey);
  try {
    verifySignature(pubKey, manifest2.body + manifest2.head, manifest2.signature.value);
  } catch (e2) {
    exit("Error validating signature: " + (e2?.message || String(e2)), internal);
  }
  if (!signingKey) {
    exit("The signature is valid but the signing key is not listed in signingKeys", internal);
  }
  const parsedFilepath = parse3(manifestFile);
  if (!body.contract?.file) {
    exit("Invalid manifest: no contract file", internal);
  }
  const computedHash = await hash3([join3(parsedFilepath.dir, body.contract.file)], multicodes.SHELTER_CONTRACT_TEXT, true);
  if (computedHash !== body.contract.hash) {
    exit(`Invalid contract file hash. Expected ${body.contract.hash} but got ${computedHash}`, internal);
  }
  if (body.contractSlim) {
    const computedHash2 = await hash3([join3(parsedFilepath.dir, body.contractSlim.file)], multicodes.SHELTER_CONTRACT_TEXT, true);
    if (computedHash2 !== body.contractSlim.hash) {
      exit(`Invalid slim contract file hash. Expected ${body.contractSlim.hash} but got ${computedHash2}`, internal);
    }
  }
  if (!internal) console.log(green("ok"), "all checks passed");
};
function version3() {
  console.log("3.0.0");
}
var [command, ...rest] = Deno.args;
if (!command) {
  help();
} else if (commands_exports[command]) {
  await commands_exports[command](rest);
} else {
  console.error(`Unknown command: ${command}`);
  Deno.exit(1);
}
Deno.exit(0);
/*! Bundled license information:

scrypt-async/scrypt-async.js:
  (*!
   * Fast "async" scrypt implementation in JavaScript.
   * Copyright (c) 2013-2016 Dmitry Chestnykh | BSD License
   * https://github.com/dchest/scrypt-async-js
   *)
*/
