var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
import { createRequire } from "node:module";
var __require = createRequire(import.meta.url);

var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from6, except, desc) => {
  if (from6 && typeof from6 === "object" || typeof from6 === "function") {
    for (let key of __getOwnPropNames(from6))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from6[key], enumerable: !(desc = __getOwnPropDesc(from6, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.deno/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/.deno/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl3) {
      "use strict";
      var gf = function(init2) {
        var i2, r = new Float64Array(16);
        if (init2) for (i2 = 0; i2 < init2.length; i2++) r[i2] = init2[i2];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([
        1
      ]), _121665 = gf([
        56129,
        1
      ]), D = gf([
        30883,
        4953,
        19914,
        30187,
        55467,
        16705,
        2637,
        112,
        59544,
        30585,
        16505,
        36039,
        65139,
        11119,
        27886,
        20995
      ]), D2 = gf([
        61785,
        9906,
        39828,
        60374,
        45398,
        33411,
        5274,
        224,
        53552,
        61171,
        33010,
        6542,
        64743,
        22239,
        55772,
        9222
      ]), X = gf([
        54554,
        36645,
        11616,
        51542,
        42930,
        38181,
        51040,
        26924,
        56412,
        64982,
        57905,
        49316,
        21502,
        52590,
        14035,
        8553
      ]), Y = gf([
        26200,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214
      ]), I2 = gf([
        41136,
        18958,
        6951,
        50414,
        58488,
        44335,
        6150,
        12099,
        55207,
        15867,
        153,
        11085,
        57099,
        20417,
        9344,
        11139
      ]);
      function ts64(x3, i2, h2, l) {
        x3[i2] = h2 >> 24 & 255;
        x3[i2 + 1] = h2 >> 16 & 255;
        x3[i2 + 2] = h2 >> 8 & 255;
        x3[i2 + 3] = h2 & 255;
        x3[i2 + 4] = l >> 24 & 255;
        x3[i2 + 5] = l >> 16 & 255;
        x3[i2 + 6] = l >> 8 & 255;
        x3[i2 + 7] = l & 255;
      }
      function vn(x3, xi, y, yi, n) {
        var i2, d = 0;
        for (i2 = 0; i2 < n; i2++) d |= x3[xi + i2] ^ y[yi + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x3, xi, y, yi) {
        return vn(x3, xi, y, yi, 16);
      }
      function crypto_verify_32(x3, xi, y, yi) {
        return vn(x3, xi, y, yi, 32);
      }
      function core_salsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x22 = x22 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x1 >>> 0 & 255;
        o2[5] = x1 >>> 8 & 255;
        o2[6] = x1 >>> 16 & 255;
        o2[7] = x1 >>> 24 & 255;
        o2[8] = x22 >>> 0 & 255;
        o2[9] = x22 >>> 8 & 255;
        o2[10] = x22 >>> 16 & 255;
        o2[11] = x22 >>> 24 & 255;
        o2[12] = x3 >>> 0 & 255;
        o2[13] = x3 >>> 8 & 255;
        o2[14] = x3 >>> 16 & 255;
        o2[15] = x3 >>> 24 & 255;
        o2[16] = x4 >>> 0 & 255;
        o2[17] = x4 >>> 8 & 255;
        o2[18] = x4 >>> 16 & 255;
        o2[19] = x4 >>> 24 & 255;
        o2[20] = x5 >>> 0 & 255;
        o2[21] = x5 >>> 8 & 255;
        o2[22] = x5 >>> 16 & 255;
        o2[23] = x5 >>> 24 & 255;
        o2[24] = x6 >>> 0 & 255;
        o2[25] = x6 >>> 8 & 255;
        o2[26] = x6 >>> 16 & 255;
        o2[27] = x6 >>> 24 & 255;
        o2[28] = x7 >>> 0 & 255;
        o2[29] = x7 >>> 8 & 255;
        o2[30] = x7 >>> 16 & 255;
        o2[31] = x7 >>> 24 & 255;
        o2[32] = x8 >>> 0 & 255;
        o2[33] = x8 >>> 8 & 255;
        o2[34] = x8 >>> 16 & 255;
        o2[35] = x8 >>> 24 & 255;
        o2[36] = x9 >>> 0 & 255;
        o2[37] = x9 >>> 8 & 255;
        o2[38] = x9 >>> 16 & 255;
        o2[39] = x9 >>> 24 & 255;
        o2[40] = x10 >>> 0 & 255;
        o2[41] = x10 >>> 8 & 255;
        o2[42] = x10 >>> 16 & 255;
        o2[43] = x10 >>> 24 & 255;
        o2[44] = x11 >>> 0 & 255;
        o2[45] = x11 >>> 8 & 255;
        o2[46] = x11 >>> 16 & 255;
        o2[47] = x11 >>> 24 & 255;
        o2[48] = x12 >>> 0 & 255;
        o2[49] = x12 >>> 8 & 255;
        o2[50] = x12 >>> 16 & 255;
        o2[51] = x12 >>> 24 & 255;
        o2[52] = x13 >>> 0 & 255;
        o2[53] = x13 >>> 8 & 255;
        o2[54] = x13 >>> 16 & 255;
        o2[55] = x13 >>> 24 & 255;
        o2[56] = x14 >>> 0 & 255;
        o2[57] = x14 >>> 8 & 255;
        o2[58] = x14 >>> 16 & 255;
        o2[59] = x14 >>> 24 & 255;
        o2[60] = x15 >>> 0 & 255;
        o2[61] = x15 >>> 8 & 255;
        o2[62] = x15 >>> 16 & 255;
        o2[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x5 >>> 0 & 255;
        o2[5] = x5 >>> 8 & 255;
        o2[6] = x5 >>> 16 & 255;
        o2[7] = x5 >>> 24 & 255;
        o2[8] = x10 >>> 0 & 255;
        o2[9] = x10 >>> 8 & 255;
        o2[10] = x10 >>> 16 & 255;
        o2[11] = x10 >>> 24 & 255;
        o2[12] = x15 >>> 0 & 255;
        o2[13] = x15 >>> 8 & 255;
        o2[14] = x15 >>> 16 & 255;
        o2[15] = x15 >>> 24 & 255;
        o2[16] = x6 >>> 0 & 255;
        o2[17] = x6 >>> 8 & 255;
        o2[18] = x6 >>> 16 & 255;
        o2[19] = x6 >>> 24 & 255;
        o2[20] = x7 >>> 0 & 255;
        o2[21] = x7 >>> 8 & 255;
        o2[22] = x7 >>> 16 & 255;
        o2[23] = x7 >>> 24 & 255;
        o2[24] = x8 >>> 0 & 255;
        o2[25] = x8 >>> 8 & 255;
        o2[26] = x8 >>> 16 & 255;
        o2[27] = x8 >>> 24 & 255;
        o2[28] = x9 >>> 0 & 255;
        o2[29] = x9 >>> 8 & 255;
        o2[30] = x9 >>> 16 & 255;
        o2[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([
        101,
        120,
        112,
        97,
        110,
        100,
        32,
        51,
        50,
        45,
        98,
        121,
        116,
        101,
        32,
        107
      ]);
      function crypto_stream_salsa20_xor(c, cpos, m3, mpos, b, n, k) {
        var z = new Uint8Array(16), x3 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = m3[mpos + i2] ^ x3[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z[i2] & 255) | 0;
            z[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = m3[mpos + i2] ^ x3[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x3 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = x3[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z[i2] & 255) | 0;
            z[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x3, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = x3[i2];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m3, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20_xor(c, cpos, m3, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m3, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m3[mpos + 0] & 255 | (m3[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m3[mpos + 2] & 255 | (m3[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m3[mpos + 4] & 255 | (m3[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m3[mpos + 6] & 255 | (m3[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m3[mpos + 8] & 255 | (m3[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m3[mpos + 10] & 255 | (m3[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m3[mpos + 12] & 255 | (m3[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m3[mpos + 14] & 255 | (m3[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c, mask, f, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c;
          c = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g2[0] = this.h[0] + 5;
        c = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this.h[i2] + c;
          c = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g2[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask | g2[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this.h[i2] + this.pad[i2] | 0) + (f >>> 16) | 0;
          this.h[i2] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m3, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes) want = bytes;
          for (i2 = 0; i2 < want; i2++) this.buffer[this.leftover + i2] = m3[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16) return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m3, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++) this.buffer[this.leftover + i2] = m3[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m3, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m3, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m3, mpos, n, k) {
        var x3 = new Uint8Array(16);
        crypto_onetimeauth(x3, 0, m3, mpos, n, k);
        return crypto_verify_16(h2, hpos, x3, 0);
      }
      function crypto_secretbox(c, m3, d, n, k) {
        var i2;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m3, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i2 = 0; i2 < 16; i2++) c[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m3, c, d, n, k) {
        var i2;
        var x3 = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x3, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x3) !== 0) return -1;
        crypto_stream_xor(m3, 0, c, 0, d, n, k);
        for (i2 = 0; i2 < 32; i2++) m3[i2] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r[i2] = a[i2] | 0;
      }
      function car25519(o2) {
        var i2, v2, c = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v2 = o2[i2] + c + 65535;
          c = Math.floor(v2 / 65536);
          o2[i2] = v2 - c * 65536;
        }
        o2[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t = c & (p[i2] ^ q[i2]);
          p[i2] ^= t;
          q[i2] ^= t;
        }
      }
      function pack25519(o2, n) {
        var i2, j, b;
        var m3 = gf(), t = gf();
        for (i2 = 0; i2 < 16; i2++) t[i2] = n[i2];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m3[0] = t[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m3[i2] = t[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
            m3[i2 - 1] &= 65535;
          }
          m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
          b = m3[15] >> 16 & 1;
          m3[14] &= 65535;
          sel25519(t, m3, 1 - b);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o2[2 * i2] = t[i2] & 255;
          o2[2 * i2 + 1] = t[i2] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o2, n) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o2[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
        o2[15] &= 32767;
      }
      function A2(o2, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a[i2] + b[i2];
      }
      function Z(o2, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a[i2] - b[i2];
      }
      function M2(o2, a, b) {
        var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v2 = a[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b2;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b2;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b2;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b2;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b2;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b2;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b2;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b2;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b2;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b2;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b2;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b2;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b2;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b2;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b2;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b2;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o2[0] = t0;
        o2[1] = t1;
        o2[2] = t2;
        o2[3] = t3;
        o2[4] = t4;
        o2[5] = t5;
        o2[6] = t6;
        o2[7] = t7;
        o2[8] = t8;
        o2[9] = t9;
        o2[10] = t10;
        o2[11] = t11;
        o2[12] = t12;
        o2[13] = t13;
        o2[14] = t14;
        o2[15] = t15;
      }
      function S2(o2, a) {
        M2(o2, a, a);
      }
      function inv25519(o2, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 253; a >= 0; a--) {
          S2(c, c);
          if (a !== 2 && a !== 4) M2(c, c, i2);
        }
        for (a = 0; a < 16; a++) o2[a] = c[a];
      }
      function pow2523(o2, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 250; a >= 0; a--) {
          S2(c, c);
          if (a !== 1) M2(c, c, i2);
        }
        for (a = 0; a < 16; a++) o2[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x3 = new Float64Array(80), r, i2;
        var a = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf();
        for (i2 = 0; i2 < 31; i2++) z[i2] = n[i2];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x3, p);
        for (i2 = 0; i2 < 16; i2++) {
          b[i2] = x3[i2];
          d[i2] = a[i2] = c[i2] = 0;
        }
        a[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r = z[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A2(e2, a, c);
          Z(a, a, c);
          A2(c, b, d);
          Z(b, b, d);
          S2(d, e2);
          S2(f, a);
          M2(a, c, a);
          M2(c, b, e2);
          A2(e2, a, c);
          Z(a, a, c);
          S2(b, a);
          Z(c, d, f);
          M2(a, c, _121665);
          A2(a, a, d);
          M2(c, c, a);
          M2(a, d, f);
          M2(d, b, x3);
          S2(b, e2);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x3[i2 + 16] = a[i2];
          x3[i2 + 32] = c[i2];
          x3[i2 + 48] = b[i2];
          x3[i2 + 64] = d[i2];
        }
        var x32 = x3.subarray(32);
        var x16 = x3.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x3) {
        randombytes(x3, 32);
        return crypto_scalarmult_base(y, x3);
      }
      function crypto_box_beforenm(k, y, x3) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x3, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m3, d, n, y, x3) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x3);
        return crypto_box_afternm(c, m3, d, n, k);
      }
      function crypto_box_open(m3, c, d, n, y, x3) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x3);
        return crypto_box_open_afternm(m3, c, d, n, k);
      }
      var K3 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m3, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j, h2, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m3[j + 0] << 24 | m3[j + 1] << 16 | m3[j + 2] << 8 | m3[j + 3];
            wl[i2] = m3[j + 4] << 24 | m3[j + 5] << 16 | m3[j + 6] << 8 | m3[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = K3[i2 * 2];
            l = K3[i2 * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = wh[i2 % 16];
            l = wl[i2 % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h2 = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h2 = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h2 = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h2 & 65535;
                d = h2 >>> 16;
                h2 = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h2 = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h2 = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h2 = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h2 = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h2 = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h2 = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h2 = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h2 = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m3, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x3 = new Uint8Array(256), i2, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m3, n);
        n %= 128;
        for (i2 = 0; i2 < n; i2++) x3[i2] = m3[b - n + i2];
        x3[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x3[n - 9] = 0;
        ts64(x3, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x3, n);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf(), g2 = gf(), h2 = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M2(a, a, t);
        A2(b, p[0], p[1]);
        A2(t, q[0], q[1]);
        M2(b, b, t);
        M2(c, p[3], q[3]);
        M2(c, c, D2);
        M2(d, p[2], q[2]);
        A2(d, d, d);
        Z(e2, b, a);
        Z(f, d, c);
        A2(g2, d, c);
        A2(h2, b, a);
        M2(p[0], e2, f);
        M2(p[1], h2, g2);
        M2(p[2], g2, f);
        M2(p[3], e2, h2);
      }
      function cswap(p, q, b) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p[i2], q[i2], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M2(tx, p[0], zi);
        M2(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i2;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b = s[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M2(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L = new Float64Array([
        237,
        211,
        245,
        92,
        26,
        99,
        18,
        88,
        214,
        156,
        247,
        162,
        222,
        249,
        222,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        16
      ]);
      function modL(r, x3) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x3[j] += carry - 16 * x3[i2] * L[j - (i2 - 32)];
            carry = Math.floor((x3[j] + 128) / 256);
            x3[j] -= carry * 256;
          }
          x3[j] += carry;
          x3[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x3[j] += carry - (x3[31] >> 4) * L[j];
          carry = x3[j] >> 8;
          x3[j] &= 255;
        }
        for (j = 0; j < 32; j++) x3[j] -= carry * L[j];
        for (i2 = 0; i2 < 32; i2++) {
          x3[i2 + 1] += x3[i2] >> 8;
          r[i2] = x3[i2] & 255;
        }
      }
      function reduce(r) {
        var x3 = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x3[i2] = r[i2];
        for (i2 = 0; i2 < 64; i2++) r[i2] = 0;
        modL(r, x3);
      }
      function crypto_sign(sm, m3, n, sk) {
        var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
        var i2, j, x3 = new Float64Array(64);
        var p = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i2 = 0; i2 < n; i2++) sm[64 + i2] = m3[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d[32 + i2];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h2, sm, n + 64);
        reduce(h2);
        for (i2 = 0; i2 < 64; i2++) x3[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x3[i2] = r[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x3[i2 + j] += h2[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x3);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S2(num, r[1]);
        M2(den, num, D);
        Z(num, num, r[2]);
        A2(den, r[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r[0], t, den);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r[0], r[0], I2);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M2(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m3, sm, n, pk) {
        var i2;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p = [
          gf(),
          gf(),
          gf(),
          gf()
        ], q = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i2 = 0; i2 < n; i2++) m3[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m3[i2 + 32] = pk[i2];
        crypto_hash(h2, m3, n);
        reduce(h2);
        scalarmult(p, q, h2);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i2 = 0; i2 < n; i2++) m3[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n; i2++) m3[i2] = sm[i2 + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl3.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
      }
      nacl3.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl3.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m3 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m3.length);
        for (var i2 = 0; i2 < msg.length; i2++) m3[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c, m3, m3.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl3.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m3 = new Uint8Array(c.length);
        for (var i2 = 0; i2 < box.length; i2++) c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m3, c, c.length, nonce, key) !== 0) return null;
        return m3.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl3.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl3.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl3.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl3.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl3.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl3.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl3.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl3.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox(msg, nonce, k);
      };
      nacl3.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl3.box.after = nacl3.secretbox;
      nacl3.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox.open(msg, nonce, k);
      };
      nacl3.box.open.after = nacl3.secretbox.open;
      nacl3.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return {
          publicKey: pk,
          secretKey: sk
        };
      };
      nacl3.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return {
          publicKey: pk,
          secretKey: new Uint8Array(secretKey)
        };
      };
      nacl3.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl3.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl3.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl3.box.nonceLength = crypto_box_NONCEBYTES;
      nacl3.box.overheadLength = nacl3.secretbox.overheadLength;
      nacl3.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl3.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m3 = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m3.length; i2++) m3[i2] = tmp[i2];
        return m3;
      };
      nacl3.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl3.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl3.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES) throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
      };
      nacl3.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return {
          publicKey: pk,
          secretKey: sk
        };
      };
      nacl3.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return {
          publicKey: pk,
          secretKey: new Uint8Array(secretKey)
        };
      };
      nacl3.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return {
          publicKey: pk,
          secretKey: sk
        };
      };
      nacl3.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl3.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl3.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl3.sign.signatureLength = crypto_sign_BYTES;
      nacl3.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl3.hash.hashLength = crypto_hash_BYTES;
      nacl3.verify = function(x3, y) {
        checkArrayTypes(x3, y);
        if (x3.length === 0 || y.length === 0) return false;
        if (x3.length !== y.length) return false;
        return vn(x3, 0, y, 0, x3.length) === 0 ? true : false;
      };
      nacl3.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl3.setPRNG(function(x3, n) {
            var i2, v2 = new Uint8Array(n);
            for (i2 = 0; i2 < n; i2 += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n; i2++) x3[i2] = v2[i2];
            cleanup(v2);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = __require("node:crypto");
          if (crypto2 && crypto2.randomBytes) {
            nacl3.setPRNG(function(x3, n) {
              var i2, v2 = crypto2.randomBytes(n);
              for (i2 = 0; i2 < n; i2++) x3[i2] = v2[i2];
              cleanup(v2);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/util.js
var require_util = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/util.js"(exports2, module2) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder3 = new TextEncoder();
        ret = encoder3.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex2(bytes) {
      return Array.prototype.map.call(bytes, function(n) {
        return (n < 16 ? "0" : "") + n.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i2 = 0; i2 < arr.length; i2 += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i2]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i2]).toUpperCase();
        } else throw new Error("Invalid size " + size);
        if (i2 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i2 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N11, M2) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N11);
      for (let i2 = 0; i2 < N11; i2++) {
        input[i2] = i2 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i2 = 0; i2 < M2; i2++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(Math.round(N11 / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND");
      }
    }
    module2.exports = {
      normalizeInput,
      toHex: toHex2,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2b.js"(exports2, module2) {
    var util = require_util();
    function ADD64AA(v6, a, b) {
      const o0 = v6[a] + v6[b];
      let o1 = v6[a + 1] + v6[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v6[a] = o0;
      v6[a + 1] = o1;
    }
    function ADD64AC(v6, a, b0, b1) {
      let o0 = v6[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v6[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v6[a] = o0;
      v6[a + 1] = o1;
    }
    function B2B_GET32(arr, i2) {
      return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
    }
    function B2B_G(a, b, c, d, ix, iy) {
      const x0 = m3[ix];
      const x1 = m3[ix + 1];
      const y0 = m3[iy];
      const y1 = m3[iy + 1];
      ADD64AA(v2, a, b);
      ADD64AC(v2, a, x0, x1);
      let xor0 = v2[d] ^ v2[a];
      let xor1 = v2[d + 1] ^ v2[a + 1];
      v2[d] = xor1;
      v2[d + 1] = xor0;
      ADD64AA(v2, c, d);
      xor0 = v2[b] ^ v2[c];
      xor1 = v2[b + 1] ^ v2[c + 1];
      v2[b] = xor0 >>> 24 ^ xor1 << 8;
      v2[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v2, a, b);
      ADD64AC(v2, a, y0, y1);
      xor0 = v2[d] ^ v2[a];
      xor1 = v2[d + 1] ^ v2[a + 1];
      v2[d] = xor0 >>> 16 ^ xor1 << 16;
      v2[d + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v2, c, d);
      xor0 = v2[b] ^ v2[c];
      xor1 = v2[b + 1] ^ v2[c + 1];
      v2[b] = xor1 >>> 31 ^ xor0 << 1;
      v2[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(SIGMA8.map(function(x3) {
      return x3 * 2;
    }));
    var v2 = new Uint32Array(32);
    var m3 = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 16; i2++) {
        v2[i2] = ctx.h[i2];
        v2[i2 + 16] = BLAKE2B_IV32[i2];
      }
      v2[24] = v2[24] ^ ctx.t;
      v2[25] = v2[25] ^ ctx.t / 4294967296;
      if (last) {
        v2[28] = ~v2[28];
        v2[29] = ~v2[29];
      }
      for (i2 = 0; i2 < 32; i2++) {
        m3[i2] = B2B_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 12; i2++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
      }
      for (i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = ctx.h[i2] ^ v2[i2] ^ v2[i2 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit2(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        c: 0,
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameterBlock, i2 * 4);
      }
      if (key) {
        blake2bUpdate2(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate2(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2bFinal2(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
      }
      return out;
    }
    function blake2b4(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit2(outlen, key, salt, personal);
      blake2bUpdate2(ctx, input);
      return blake2bFinal2(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b4(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module2.exports = {
      blake2b: blake2b4,
      blake2bHex,
      blake2bInit: blake2bInit2,
      blake2bUpdate: blake2bUpdate2,
      blake2bFinal: blake2bFinal2
    };
  }
});

// node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2s.js"(exports2, module2) {
    var util = require_util();
    function B2S_GET32(v6, i2) {
      return v6[i2] ^ v6[i2 + 1] << 8 ^ v6[i2 + 2] << 16 ^ v6[i2 + 3] << 24;
    }
    function B2S_G(a, b, c, d, x3, y) {
      v2[a] = v2[a] + v2[b] + x3;
      v2[d] = ROTR32(v2[d] ^ v2[a], 16);
      v2[c] = v2[c] + v2[d];
      v2[b] = ROTR32(v2[b] ^ v2[c], 12);
      v2[a] = v2[a] + v2[b] + y;
      v2[d] = ROTR32(v2[d] ^ v2[a], 8);
      v2[c] = v2[c] + v2[d];
      v2[b] = ROTR32(v2[b] ^ v2[c], 7);
    }
    function ROTR32(x3, y) {
      return x3 >>> y ^ x3 << 32 - y;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v2 = new Uint32Array(16);
    var m3 = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 8; i2++) {
        v2[i2] = ctx.h[i2];
        v2[i2 + 8] = BLAKE2S_IV[i2];
      }
      v2[12] ^= ctx.t;
      v2[13] ^= ctx.t / 4294967296;
      if (last) {
        v2[14] = ~v2[14];
      }
      for (i2 = 0; i2 < 16; i2++) {
        m3[i2] = B2S_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 10; i2++) {
        B2S_G(0, 4, 8, 12, m3[SIGMA[i2 * 16 + 0]], m3[SIGMA[i2 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m3[SIGMA[i2 * 16 + 2]], m3[SIGMA[i2 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m3[SIGMA[i2 * 16 + 4]], m3[SIGMA[i2 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m3[SIGMA[i2 * 16 + 6]], m3[SIGMA[i2 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m3[SIGMA[i2 * 16 + 8]], m3[SIGMA[i2 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m3[SIGMA[i2 * 16 + 10]], m3[SIGMA[i2 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m3[SIGMA[i2 * 16 + 12]], m3[SIGMA[i2 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m3[SIGMA[i2 * 16 + 14]], m3[SIGMA[i2 * 16 + 15]]);
      }
      for (i2 = 0; i2 < 8; i2++) {
        ctx.h[i2] ^= v2[i2] ^ v2[i2 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        b: new Uint8Array(64),
        c: 0,
        t: 0,
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3) & 255;
      }
      return out;
    }
    function blake2s2(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s2(input, key, outlen);
      return util.toHex(output);
    }
    module2.exports = {
      blake2s: blake2s2,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/index.js"(exports2, module2) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module2.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/link/interface.js
var require_interface = __commonJS({
  "node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/link/interface.js"() {
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assertError.js
var require_assertError = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assertError.js"(exports2, module2) {
    "use strict";
    module2.exports = class AssertError extends Error {
      name = "AssertError";
      constructor(message, ctor) {
        super(message || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, ctor);
        }
      }
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/stringify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(...args) {
      try {
        return JSON.stringify(...args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assert.js
var require_assert = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assert.js"(exports2, module2) {
    "use strict";
    var AssertError = require_assertError();
    var Stringify = require_stringify();
    var assert4 = module2.exports = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
      });
      throw new AssertError(msgs.join(" "), assert4);
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reach.js
var require_reach = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reach.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var internals = {};
    module2.exports = function(obj, chain, options3) {
      if (chain === false || chain === null || chain === void 0) {
        return obj;
      }
      options3 = options3 || {};
      if (typeof options3 === "string") {
        options3 = {
          separator: options3
        };
      }
      const isChainArray = Array.isArray(chain);
      Assert(!isChainArray || !options3.separator, "Separator option is not valid for array-based chain");
      const path = isChainArray ? chain : chain.split(options3.separator || ".");
      let ref = obj;
      for (let i2 = 0; i2 < path.length; ++i2) {
        let key = path[i2];
        const type = options3.iterables && internals.iterables(ref);
        if (Array.isArray(ref) || type === "set") {
          const number4 = Number(key);
          if (Number.isInteger(number4)) {
            key = number4 < 0 ? ref.length + number4 : number4;
          }
        }
        if (!ref || typeof ref === "function" && options3.functions === false || // Defaults to true
        !type && ref[key] === void 0) {
          Assert(!options3.strict || i2 + 1 === path.length, "Missing segment", key, "in reach path ", chain);
          Assert(typeof ref === "object" || options3.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options3.default;
          break;
        }
        if (!type) {
          ref = ref[key];
        } else if (type === "set") {
          ref = [
            ...ref
          ][key];
        } else {
          ref = ref.get(key);
        }
      }
      return ref;
    };
    internals.iterables = function(ref) {
      if (ref instanceof Set) {
        return "set";
      }
      if (ref instanceof Map) {
        return "map";
      }
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/types.js
var require_types = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/types.js"(exports2, module2) {
    "use strict";
    var internals = {};
    exports2 = module2.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      url: URL.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      [
        "[object Error]",
        exports2.error
      ],
      [
        "[object Map]",
        exports2.map
      ],
      [
        "[object Promise]",
        exports2.promise
      ],
      [
        "[object Set]",
        exports2.set
      ],
      [
        "[object URL]",
        exports2.url
      ],
      [
        "[object WeakMap]",
        exports2.weakMap
      ],
      [
        "[object WeakSet]",
        exports2.weakSet
      ]
    ]);
    exports2.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports2.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports2.buffer;
      }
      if (obj instanceof Date) {
        return exports2.date;
      }
      if (obj instanceof RegExp) {
        return exports2.regex;
      }
      if (obj instanceof Error) {
        return exports2.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports2.generic;
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/utils.js"(exports2) {
    "use strict";
    exports2.keys = function(obj, options3 = {}) {
      return options3.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/clone.js
var require_clone = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/clone.js"(exports2, module2) {
    "use strict";
    var Reach = require_reach();
    var Types = require_types();
    var Utils = require_utils();
    var internals = {
      needsProtoHack: /* @__PURE__ */ new Set([
        Types.set,
        Types.map,
        Types.weakSet,
        Types.weakMap
      ]),
      structuredCloneExists: typeof structuredClone === "function"
    };
    module2.exports = internals.clone = function(obj, options3 = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      let clone2 = internals.clone;
      let seen = _seen;
      if (options3.shallow) {
        if (options3.shallow !== true) {
          return internals.cloneWithShallow(obj, options3);
        }
        clone2 = (value) => value;
      } else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
          return lookup;
        }
      } else {
        seen = /* @__PURE__ */ new Map();
      }
      const baseProto = Types.getInternalProto(obj);
      switch (baseProto) {
        case Types.buffer:
          return Buffer?.from(obj);
        case Types.date:
          return new Date(obj.getTime());
        case Types.regex:
        case Types.url:
          return new baseProto.constructor(obj);
      }
      const newObj = internals.base(obj, baseProto, options3);
      if (newObj === obj) {
        return obj;
      }
      if (seen) {
        seen.set(obj, newObj);
      }
      if (baseProto === Types.set) {
        for (const value of obj) {
          newObj.add(clone2(value, options3, seen));
        }
      } else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
          newObj.set(key, clone2(value, options3, seen));
        }
      }
      const keys = Utils.keys(obj, options3);
      for (const key of keys) {
        if (key === "__proto__") {
          continue;
        }
        if (baseProto === Types.array && key === "length") {
          newObj.length = obj.length;
          continue;
        }
        if (internals.structuredCloneExists && baseProto === Types.error && key === "stack") {
          continue;
        }
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, key, descriptor);
          } else if (descriptor.enumerable) {
            newObj[key] = clone2(obj[key], options3, seen);
          } else {
            Object.defineProperty(newObj, key, {
              enumerable: false,
              writable: true,
              configurable: true,
              value: clone2(obj[key], options3, seen)
            });
          }
        } else {
          Object.defineProperty(newObj, key, {
            enumerable: true,
            writable: true,
            configurable: true,
            value: clone2(obj[key], options3, seen)
          });
        }
      }
      return newObj;
    };
    internals.cloneWithShallow = function(source, options3) {
      const keys = options3.shallow;
      options3 = Object.assign({}, options3);
      options3.shallow = false;
      const seen = /* @__PURE__ */ new Map();
      for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === "object" || typeof ref === "function") {
          seen.set(ref, ref);
        }
      }
      return internals.clone(source, options3, seen);
    };
    internals.base = function(obj, baseProto, options3) {
      if (options3.prototype === false) {
        if (internals.needsProtoHack.has(baseProto)) {
          return new baseProto.constructor();
        }
        return baseProto === Types.array ? [] : {};
      }
      const proto3 = Object.getPrototypeOf(obj);
      if (proto3 && proto3.isImmutable) {
        return obj;
      }
      if (baseProto === Types.array) {
        const newObj = [];
        if (proto3 !== baseProto) {
          Object.setPrototypeOf(newObj, proto3);
        }
        return newObj;
      } else if (baseProto === Types.error && internals.structuredCloneExists && (proto3 === baseProto || Error.isPrototypeOf(proto3.constructor))) {
        const err = structuredClone(obj);
        if (Object.getPrototypeOf(err) !== proto3) {
          Object.setPrototypeOf(err, proto3);
        }
        return err;
      }
      if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto3.constructor();
        if (proto3 !== baseProto) {
          Object.setPrototypeOf(newObj, proto3);
        }
        return newObj;
      }
      return Object.create(proto3);
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/merge.js
var require_merge = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/merge.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Utils = require_utils();
    var internals = {};
    module2.exports = internals.merge = function(target, source, options3) {
      Assert(target && typeof target === "object", "Invalid target value: must be an object");
      Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      options3 = Object.assign({
        nullOverride: true,
        mergeArrays: true
      }, options3);
      if (Array.isArray(source)) {
        Assert(Array.isArray(target), "Cannot merge array onto an object");
        if (!options3.mergeArrays) {
          target.length = 0;
        }
        for (let i2 = 0; i2 < source.length; ++i2) {
          target.push(Clone(source[i2], {
            symbols: options3.symbols
          }));
        }
        return target;
      }
      const keys = Utils.keys(source, options3);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (target[key] === value) {
            continue;
          }
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
          value instanceof RegExp) {
            target[key] = Clone(value, {
              symbols: options3.symbols
            });
          } else {
            internals.merge(target[key], value, options3);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (options3.nullOverride) {
            target[key] = value;
          }
        }
      }
      return target;
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/applyToDefaults.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Merge = require_merge();
    var Reach = require_reach();
    var internals = {};
    module2.exports = function(defaults, source, options3 = {}) {
      Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
      Assert(typeof options3 === "object", "Invalid options: must be an object");
      if (!source) {
        return null;
      }
      if (options3.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options3);
      }
      const copy4 = Clone(defaults);
      if (source === true) {
        return copy4;
      }
      const nullOverride = options3.nullOverride !== void 0 ? options3.nullOverride : false;
      return Merge(copy4, source, {
        nullOverride,
        mergeArrays: false
      });
    };
    internals.applyToDefaultsWithShallow = function(defaults, source, options3) {
      const keys = options3.shallow;
      Assert(Array.isArray(keys), "Invalid keys");
      const seen = /* @__PURE__ */ new Map();
      const merge3 = source === true ? null : /* @__PURE__ */ new Set();
      for (let key of keys) {
        key = Array.isArray(key) ? key : key.split(".");
        const ref = Reach(defaults, key);
        if (ref && typeof ref === "object") {
          seen.set(ref, merge3 && Reach(source, key) || ref);
        } else if (merge3) {
          merge3.add(key);
        }
      }
      const copy4 = Clone(defaults, {}, seen);
      if (!merge3) {
        return copy4;
      }
      for (const key of merge3) {
        internals.reachCopy(copy4, source, key);
      }
      const nullOverride = options3.nullOverride !== void 0 ? options3.nullOverride : false;
      return Merge(copy4, source, {
        nullOverride,
        mergeArrays: false
      });
    };
    internals.reachCopy = function(dst, src4, path) {
      for (const segment of path) {
        if (!(segment in src4)) {
          return;
        }
        const val = src4[segment];
        if (typeof val !== "object" || val === null) {
          return;
        }
        src4 = val;
      }
      const value = src4;
      let ref = dst;
      for (let i2 = 0; i2 < path.length - 1; ++i2) {
        const segment = path[i2];
        if (typeof ref[segment] !== "object") {
          ref[segment] = {};
        }
        ref = ref[segment];
      }
      ref[path[path.length - 1]] = value;
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/bench.js
var require_bench = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/bench.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = internals.Bench = class {
      constructor() {
        this.ts = 0;
        this.reset();
      }
      reset() {
        this.ts = internals.Bench.now();
      }
      elapsed() {
        return internals.Bench.now() - this.ts;
      }
      static now() {
        const ts = process.hrtime();
        return ts[0] * 1e3 + ts[1] / 1e6;
      }
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/ignore.js
var require_ignore = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/ignore.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/block.js
var require_block = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/block.js"(exports2, module2) {
    "use strict";
    var Ignore = require_ignore();
    module2.exports = function() {
      return new Promise(Ignore);
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/deepEqual.js"(exports2, module2) {
    "use strict";
    var Types = require_types();
    var internals = {
      mismatched: null
    };
    module2.exports = function(obj, ref, options3) {
      options3 = Object.assign({
        prototype: true
      }, options3);
      return !!internals.isDeepEqual(obj, ref, options3, []);
    };
    internals.isDeepEqual = function(obj, ref, options3, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (obj === null || ref === null) {
        return false;
      }
      if (type === "function") {
        if (!options3.deepFunction || obj.toString() !== ref.toString()) {
          return false;
        }
      } else if (type !== "object") {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options3.prototype);
      switch (instanceType) {
        case Types.buffer:
          return Buffer && Buffer.prototype.equals.call(obj, ref);
        // $lab:coverage:ignore$
        case Types.promise:
          return obj === ref;
        case Types.regex:
        case Types.url:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i2 = seen.length - 1; i2 >= 0; --i2) {
        if (seen[i2].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options3, seen);
      } finally {
        seen.pop();
      }
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return Types.getInternalProto(obj);
      }
      const type = Types.getInternalProto(obj);
      if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options3, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === Types.array) {
        if (options3.part) {
          for (const objValue of obj) {
            for (const refValue of ref) {
              if (isDeepEqual(objValue, refValue, options3, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i2 = 0; i2 < obj.length; ++i2) {
            if (!isDeepEqual(obj[i2], ref[i2], options3, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(Set.prototype.values.call(ref));
          for (const objEntry of Set.prototype.values.call(obj)) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options3, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of Map.prototype.entries.call(obj)) {
          if (value === void 0 && !Map.prototype.has.call(ref, key)) {
            return false;
          }
          if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options3, seen)) {
            return false;
          }
        }
      } else if (instanceType === Types.error) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options3, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options3.part && objKeys.length !== keys(ref).length && !options3.skip) {
        return false;
      }
      let skipped = 0;
      for (const key of objKeys) {
        if (options3.skip && options3.skip.includes(key)) {
          if (ref[key] === void 0) {
            ++skipped;
          }
          continue;
        }
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options3, seen)) {
          return false;
        }
      }
      if (!options3.part && objKeys.length - skipped !== keys(ref).length) {
        return false;
      }
      if (options3.symbols !== false) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (const key of objSymbols) {
          if (!options3.skip?.includes(key)) {
            if (hasOwnEnumerableProperty(obj, key)) {
              if (!hasOwnEnumerableProperty(ref, key)) {
                return false;
              }
              if (!isDeepEqual(obj[key], ref[key], options3, seen)) {
                return false;
              }
            } else if (hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeRegex.js"(exports2, module2) {
    "use strict";
    module2.exports = function(string4) {
      return string4.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/contain.js
var require_contain = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/contain.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var EscapeRegex = require_escapeRegex();
    var Utils = require_utils();
    var internals = {};
    module2.exports = function(ref, values, options3 = {}) {
      if (typeof values !== "object") {
        values = [
          values
        ];
      }
      Assert(!Array.isArray(values) || values.length, "Values array cannot be empty");
      if (typeof ref === "string") {
        return internals.string(ref, values, options3);
      }
      if (Array.isArray(ref)) {
        return internals.array(ref, values, options3);
      }
      Assert(typeof ref === "object", "Reference must be string or an object");
      return internals.object(ref, values, options3);
    };
    internals.array = function(ref, values, options3) {
      if (!Array.isArray(values)) {
        values = [
          values
        ];
      }
      if (!ref.length) {
        return false;
      }
      if (options3.only && options3.once && ref.length !== values.length) {
        return false;
      }
      let compare;
      const map2 = /* @__PURE__ */ new Map();
      for (const value of values) {
        if (!options3.deep || !value || typeof value !== "object") {
          const existing = map2.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map2.set(value, {
              allowed: 1,
              hits: 0
            });
          }
        } else {
          compare = compare ?? internals.compare(options3);
          let found = false;
          for (const [key, existing] of map2.entries()) {
            if (compare(key, value)) {
              ++existing.allowed;
              found = true;
              break;
            }
          }
          if (!found) {
            map2.set(value, {
              allowed: 1,
              hits: 0
            });
          }
        }
      }
      let hits = 0;
      for (const item of ref) {
        let match;
        if (!options3.deep || !item || typeof item !== "object") {
          match = map2.get(item);
        } else {
          compare = compare ?? internals.compare(options3);
          for (const [key, existing] of map2.entries()) {
            if (compare(key, item)) {
              match = existing;
              break;
            }
          }
        }
        if (match) {
          ++match.hits;
          ++hits;
          if (options3.once && match.hits > match.allowed) {
            return false;
          }
        }
      }
      if (options3.only && hits !== ref.length) {
        return false;
      }
      for (const match of map2.values()) {
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options3.part) {
          return false;
        }
      }
      return !!hits;
    };
    internals.object = function(ref, values, options3) {
      Assert(options3.once === void 0, "Cannot use option once with object");
      const keys = Utils.keys(ref, options3);
      if (!keys.length) {
        return false;
      }
      if (Array.isArray(values)) {
        return internals.array(keys, values, options3);
      }
      const symbols2 = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
      const targets = [
        ...Object.keys(values),
        ...symbols2
      ];
      const compare = internals.compare(options3);
      const set2 = new Set(targets);
      for (const key of keys) {
        if (!set2.has(key)) {
          if (options3.only) {
            return false;
          }
          continue;
        }
        if (!compare(values[key], ref[key])) {
          return false;
        }
        set2.delete(key);
      }
      if (set2.size) {
        return options3.part ? set2.size < targets.length : false;
      }
      return true;
    };
    internals.string = function(ref, values, options3) {
      if (ref === "") {
        return values.length === 1 && values[0] === "" || // '' contains ''
        !options3.once && !values.some((v2) => v2 !== "");
      }
      const map2 = /* @__PURE__ */ new Map();
      const patterns = [];
      for (const value of values) {
        Assert(typeof value === "string", "Cannot compare string reference to non-string value");
        if (value) {
          const existing = map2.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map2.set(value, {
              allowed: 1,
              hits: 0
            });
            patterns.push(EscapeRegex(value));
          }
        } else if (options3.once || options3.only) {
          return false;
        }
      }
      if (!patterns.length) {
        return true;
      }
      const regex = new RegExp(`(${patterns.join("|")})`, "g");
      const leftovers = ref.replace(regex, ($0, $1) => {
        ++map2.get($1).hits;
        return "";
      });
      if (options3.only && leftovers) {
        return false;
      }
      let any2 = false;
      for (const match of map2.values()) {
        if (match.hits) {
          any2 = true;
        }
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options3.part) {
          return false;
        }
        if (options3.once) {
          return false;
        }
      }
      return !!any2;
    };
    internals.compare = function(options3) {
      if (!options3.deep) {
        return internals.shallow;
      }
      const hasOnly = options3.only !== void 0;
      const hasPart = options3.part !== void 0;
      const flags = {
        prototype: hasOnly ? options3.only : hasPart ? !options3.part : false,
        part: hasOnly ? !options3.only : hasPart ? options3.part : false
      };
      return (a, b) => DeepEqual(a, b, flags);
    };
    internals.shallow = function(a, b) {
      return a === b;
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js
var require_escapeHeaderAttribute = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    module2.exports = function(attribute) {
      Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
      return attribute.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHtml.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i2 = 0; i2 < input.length; ++i2) {
        const charCode = input.charCodeAt(i2);
        if (internals.isSafe(charCode)) {
          escaped += input[i2];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml.get(charCode);
      if (namedEscape) {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = charCode.toString(16).padStart(2, "0");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return internals.safeCharCodes.has(charCode);
    };
    internals.namedHtml = /* @__PURE__ */ new Map([
      [
        38,
        "&amp;"
      ],
      [
        60,
        "&lt;"
      ],
      [
        62,
        "&gt;"
      ],
      [
        34,
        "&quot;"
      ],
      [
        160,
        "&nbsp;"
      ],
      [
        162,
        "&cent;"
      ],
      [
        163,
        "&pound;"
      ],
      [
        164,
        "&curren;"
      ],
      [
        169,
        "&copy;"
      ],
      [
        174,
        "&reg;"
      ]
    ]);
    internals.safeCharCodes = function() {
      const safe = /* @__PURE__ */ new Set();
      for (let i2 = 32; i2 < 123; ++i2) {
        if (i2 >= 97 || // a-z
        i2 >= 65 && i2 <= 90 || // A-Z
        i2 >= 48 && i2 <= 57 || // 0-9
        i2 === 32 || // space
        i2 === 46 || // .
        i2 === 44 || // ,
        i2 === 45 || // -
        i2 === 58 || // :
        i2 === 95) {
          safe.add(i2);
        }
      }
      return safe;
    }();
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeJson.js
var require_escapeJson = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeJson.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(input) {
      if (!input) {
        return "";
      }
      return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
    };
    internals.escape = function(char) {
      return internals.replacements.get(char);
    };
    internals.replacements = /* @__PURE__ */ new Map([
      [
        "<",
        "\\u003c"
      ],
      [
        ">",
        "\\u003e"
      ],
      [
        "&",
        "\\u0026"
      ],
      [
        "\u2028",
        "\\u2028"
      ],
      [
        "\u2029",
        "\\u2029"
      ]
    ]);
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/flatten.js
var require_flatten = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/flatten.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = internals.flatten = function(array2, target) {
      const result = target || [];
      for (const entry of array2) {
        if (Array.isArray(entry)) {
          internals.flatten(entry, result);
        } else {
          result.push(entry);
        }
      }
      return result;
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/intersect.js
var require_intersect = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/intersect.js"(exports2, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(array1, array2, options3 = {}) {
      if (!array1 || !array2) {
        return options3.first ? null : [];
      }
      const common3 = [];
      const hash3 = Array.isArray(array1) ? new Set(array1) : array1;
      const found = /* @__PURE__ */ new Set();
      for (const value of array2) {
        if (internals.has(hash3, value) && !found.has(value)) {
          if (options3.first) {
            return value;
          }
          common3.push(value);
          found.add(value);
        }
      }
      return options3.first ? null : common3;
    };
    internals.has = function(ref, key) {
      if (typeof ref.has === "function") {
        return ref.has(key);
      }
      return ref[key] !== void 0;
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/isPromise.js"(exports2, module2) {
    "use strict";
    module2.exports = function(promise2) {
      return typeof promise2?.then === "function";
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/once.js
var require_once = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/once.js"(exports2, module2) {
    "use strict";
    var internals = {
      wrapped: Symbol("wrapped")
    };
    module2.exports = function(method) {
      if (method[internals.wrapped]) {
        return method;
      }
      let once = false;
      const wrappedFn = function(...args) {
        if (!once) {
          once = true;
          method(...args);
        }
      };
      wrappedFn[internals.wrapped] = true;
      return wrappedFn;
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reachTemplate.js
var require_reachTemplate = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reachTemplate.js"(exports2, module2) {
    "use strict";
    var Reach = require_reach();
    module2.exports = function(obj, template, options3) {
      return template.replace(/{([^{}]+)}/g, ($0, chain) => {
        const value = Reach(obj, chain, options3);
        return value ?? "";
      });
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/wait.js
var require_wait = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/wait.js"(exports2, module2) {
    "use strict";
    var internals = {
      maxTimer: 2 ** 31 - 1
      // ~25 days
    };
    module2.exports = function(timeout, returnValue, options3) {
      if (typeof timeout === "bigint") {
        timeout = Number(timeout);
      }
      if (timeout >= Number.MAX_SAFE_INTEGER) {
        timeout = Infinity;
      }
      if (typeof timeout !== "number" && timeout !== void 0) {
        throw new TypeError("Timeout must be a number or bigint");
      }
      return new Promise((resolve7) => {
        const _setTimeout = options3 ? options3.setTimeout : setTimeout;
        const activate = () => {
          const time3 = Math.min(timeout, internals.maxTimer);
          timeout -= time3;
          _setTimeout(() => timeout > 0 ? activate() : resolve7(returnValue), time3);
        };
        if (timeout !== Infinity) {
          activate();
        }
      });
    };
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/index.js
var require_lib = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/index.js"(exports2) {
    "use strict";
    exports2.applyToDefaults = require_applyToDefaults();
    exports2.assert = require_assert();
    exports2.AssertError = require_assertError();
    exports2.Bench = require_bench();
    exports2.block = require_block();
    exports2.clone = require_clone();
    exports2.contain = require_contain();
    exports2.deepEqual = require_deepEqual();
    exports2.escapeHeaderAttribute = require_escapeHeaderAttribute();
    exports2.escapeHtml = require_escapeHtml();
    exports2.escapeJson = require_escapeJson();
    exports2.escapeRegex = require_escapeRegex();
    exports2.flatten = require_flatten();
    exports2.ignore = require_ignore();
    exports2.intersect = require_intersect();
    exports2.isPromise = require_isPromise();
    exports2.merge = require_merge();
    exports2.once = require_once();
    exports2.reach = require_reach();
    exports2.reachTemplate = require_reachTemplate();
    exports2.stringify = require_stringify();
    exports2.wait = require_wait();
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/package.json
var require_package = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/package.json"(exports2, module2) {
    module2.exports = {
      name: "@hapi/validate",
      description: "Object schema validation",
      version: "2.0.1",
      repository: "git://github.com/hapijs/validate",
      main: "lib/index.js",
      files: [
        "lib/**/*"
      ],
      eslintConfig: {
        extends: [
          "plugin:@hapi/module"
        ]
      },
      dependencies: {
        "@hapi/hoek": "^11.0.2",
        "@hapi/topo": "^6.0.1"
      },
      devDependencies: {
        "@hapi/bourne": "^3.0.0",
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "*",
        "@hapi/lab": "^25.1.2"
      },
      scripts: {
        test: "lab -t 100 -a @hapi/code -L",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/schemas.js
var require_schemas = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/schemas.js"(exports2) {
    "use strict";
    var Joi = require_lib3();
    var internals = {};
    internals.wrap = Joi.string().min(1).max(2).allow(false);
    exports2.preferences = Joi.object({
      allowUnknown: Joi.boolean(),
      abortEarly: Joi.boolean(),
      context: Joi.object(),
      convert: Joi.boolean(),
      dateFormat: Joi.valid("date", "iso", "string", "time", "utc"),
      errors: {
        escapeHtml: Joi.boolean(),
        label: Joi.valid("path", "key", false),
        language: [
          Joi.string(),
          Joi.object().ref()
        ],
        render: Joi.boolean(),
        stack: Joi.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap
        }
      },
      messages: Joi.object(),
      noDefaults: Joi.boolean(),
      nonEnumerables: Joi.boolean(),
      presence: Joi.valid("required", "optional", "forbidden"),
      skipFunctions: Joi.boolean(),
      stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
      }).or("arrays", "objects").allow(true, false)
    }).strict();
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/ref.js
var require_ref = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/ref.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      symbol: Symbol("ref"),
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports2.create = function(key, options3 = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options3, [
        "adjust",
        "ancestor",
        "in",
        "iterables",
        "map",
        "prefix",
        "separator"
      ]);
      Assert(!options3.prefix || typeof options3.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options3);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options3.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [
        key
      ];
      return new internals.Ref(ref);
    };
    exports2.in = function(key, options3 = {}) {
      return exports2.create(key, Object.assign({}, options3, {
        in: true
      }));
    };
    exports2.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options3) {
        Assert(typeof options3 === "object", "Invalid reference construction");
        Common.assertOptions(options3, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "separator",
          "type",
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        Assert([
          false,
          void 0
        ].includes(options3.separator) || typeof options3.separator === "string" && options3.separator.length === 1, "Invalid separator");
        Assert(!options3.adjust || typeof options3.adjust === "function", "options.adjust must be a function");
        Assert(!options3.map || Array.isArray(options3.map), "options.map must be an array");
        Assert(!options3.map || !options3.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options3);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local, options3 = {}) {
        Assert(!this.in || options3.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options3);
        }
        if (this.type === "local") {
          return this._resolve(local, state, options3);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options3);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options3);
        }
        Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options3);
      }
      _resolve(target, state, options3) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options3.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, {
            iterables: this.iterables,
            functions: true
          });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [
          ...state.path.slice(0, -this.ancestor),
          ...this.path
        ];
      }
      clone() {
        return new internals.Ref(this);
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return {
            key: key.slice(globalp.length),
            type: "global"
          };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return {
            key: key.slice(local.length),
            type: "local"
          };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return {
            key: key.slice(root.length),
            type: "value",
            root: true
          };
        }
      }
      return {
        key,
        type: "value"
      };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [
          1,
          0
        ];
      }
      if (key[0] !== separator) {
        return [
          1,
          0
        ];
      }
      if (key[1] !== separator) {
        return [
          0,
          1
        ];
      }
      let i2 = 2;
      while (key[i2] === separator) {
        ++i2;
      }
      return [
        i2 - 1,
        i2
      ];
    };
    exports2.toSibling = 0;
    exports2.toParent = 1;
    exports2.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports2.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({
                ancestor: item.ancestor - target,
                root: item.root
              });
            }
          }
          return;
        }
        if (exports2.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({
            ancestor: source.ancestor - target,
            root: source.root
          });
        }
      }
      clone() {
        const copy4 = new exports2.Manager();
        copy4.refs = Clone(this.refs);
        return copy4;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/template.js
var require_template = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/template.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var EscapeHtml = require_escapeHtml();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module2.exports = exports2 = internals.Template = class {
      constructor(source, options3) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        this._settings = Clone(options3);
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), {
            raw,
            wrapped
          });
          processed.push(dynamic);
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        this._template = processed;
      }
      static date(date5, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date5);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      render(value, state, prefs, local, options3 = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = part.ref.resolve(value, state, prefs, local, options3);
            const string4 = internals.stringify(rendered, prefs, options3.errors);
            const result = part.raw || options3.errors?.escapeHtml === false ? string4 : EscapeHtml(string4);
            parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const ref = Ref.create(content, this._settings);
        return {
          ref,
          raw,
          wrapped: wrapped || ref.type === "local" && ref.key === "label"
        };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string4) {
      return string4.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string4) {
      return string4.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string4) {
      const parts = [];
      let current = "";
      for (let i2 = 0; i2 < string4.length; ++i2) {
        const char = string4[i2];
        if (char === "{") {
          let next = "";
          while (i2 + 1 < string4.length && string4[i2 + 1] === "{") {
            next += "{";
            ++i2;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, prefs, options3) {
      const type = typeof value;
      if (value === null) {
        return "null";
      }
      if (value === void 0) {
        return "";
      }
      if (type === "string") {
        return value;
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      let partial2 = "";
      for (const item of value) {
        partial2 = partial2 + (partial2.length ? ", " : "") + internals.stringify(item, prefs, options3);
      }
      return internals.wrap(partial2, prefs.errors.wrap.array);
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/messages.js
var require_messages = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/messages.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Template = require_template();
    exports2.compile = function(messages, target) {
      if (typeof messages === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        Assert(!target, "Cannot set single message template");
        return messages;
      }
      Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code3 in messages) {
        const message = messages[code3];
        if (code3 === "root" || Template.isTemplate(message)) {
          target[code3] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code3] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code3);
        const language = code3;
        target[language] = target[language] || {};
        for (code3 in message) {
          const localized = message[code3];
          if (code3 === "root" || Template.isTemplate(localized)) {
            target[language][code3] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code3, "in", language);
          target[language][code3] = new Template(localized);
        }
      }
      return target;
    };
    exports2.merge = function(base4, extended) {
      if (!base4) {
        return exports2.compile(extended);
      }
      if (!extended) {
        return base4;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base4);
      for (let code3 in extended) {
        const message = extended[code3];
        if (code3 === "root" || Template.isTemplate(message)) {
          target[code3] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code3] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code3);
        const language = code3;
        target[language] = target[language] || {};
        for (code3 in message) {
          const localized = message[code3];
          if (code3 === "root" || Template.isTemplate(localized)) {
            target[language][code3] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code3, "in", language);
          target[language][code3] = new Template(localized);
        }
      }
      return target;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/common.js
var require_common = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/common.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var AssertError = require_assertError();
    var Pkg = require_package();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports2.version = Pkg.version;
    exports2.defaults = {
      abortEarly: true,
      allowUnknown: false,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false
    };
    exports2.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports2.assertOptions = function(options3, keys, name = "Options") {
      Assert(options3 && typeof options3 === "object" && !Array.isArray(options3), "Options must be of type object");
      const unknownKeys = Object.keys(options3).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports2.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([
          result.error.details[0].message
        ]);
      }
    };
    exports2.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports2.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports2.isIsoDate = function(date5) {
      return internals.isoDate.test(date5);
    };
    exports2.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports2.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports2.symbols.ref] || obj[exports2.symbols.template];
    };
    exports2.isSchema = function(schema, options3 = {}) {
      const any2 = schema && schema[exports2.symbols.any];
      if (!any2) {
        return false;
      }
      return true;
    };
    exports2.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports2.preferences = function(target, source) {
      Messages = Messages || require_messages();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports2.symbols.prefs];
      return merged;
    };
    exports2.tryWithPath = function(fn, key, options3 = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options3.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports2.validateArg = function(value, label, { assert: assert4, message }) {
      if (exports2.isSchema(assert4)) {
        const result = assert4.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert4(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports2.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/compile.js
var require_compile = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/compile.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports2.schema = function(Joi, config2, options3 = {}) {
      Common.assertOptions(options3, [
        "appendPath",
        "override"
      ]);
      try {
        return internals.schema(Joi, config2, options3);
      } catch (err) {
        if (options3.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi, config2, options3) {
      Assert(config2 !== void 0, "Invalid undefined schema");
      if (Array.isArray(config2)) {
        Assert(config2.length, "Invalid empty array schema");
        if (config2.length === 1) {
          config2 = config2[0];
        }
      }
      const valid = (base4, ...values) => {
        if (options3.override !== false) {
          return base4.valid(Joi.override, ...values);
        }
        return base4.valid(...values);
      };
      if (internals.simple(config2)) {
        return valid(Joi, config2);
      }
      if (typeof config2 === "function") {
        return Joi.custom(config2);
      }
      Assert(typeof config2 === "object", "Invalid schema content:", typeof config2);
      if (Common.isResolvable(config2)) {
        return valid(Joi, config2);
      }
      if (Common.isSchema(config2)) {
        return config2;
      }
      if (Array.isArray(config2)) {
        for (const item of config2) {
          if (!internals.simple(item)) {
            return Joi.alternatives().try(...config2);
          }
        }
        return valid(Joi, ...config2);
      }
      if (config2 instanceof RegExp) {
        return Joi.string().regex(config2);
      }
      if (config2 instanceof Date) {
        return valid(Joi.date(), config2);
      }
      Assert(Object.getPrototypeOf(config2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi.object().keys(config2);
    };
    exports2.ref = function(id, options3) {
      return Ref.isRef(id) ? id : Ref.create(id, options3);
    };
    exports2.compile = function(root, schema) {
      const any2 = schema && schema[Common.symbols.any];
      if (any2) {
        Assert(any2.version === Common.version, "Cannot mix different versions of joi schemas:", any2.version, Common.version);
        return schema;
      }
      return exports2.schema(root, schema, {
        appendPath: true
      });
    };
    internals.simple = function(value) {
      return value === null || [
        "boolean",
        "string",
        "number"
      ].includes(typeof value);
    };
    exports2.when = function(schema, condition, options3) {
      if (options3 === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options3 = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options3)) {
        options3 = {
          switch: options3
        };
      }
      Common.assertOptions(options3, [
        "is",
        "not",
        "then",
        "otherwise",
        "switch",
        "break"
      ]);
      if (Common.isSchema(condition)) {
        Assert(options3.is === void 0, '"is" can not be used with a schema condition');
        Assert(options3.not === void 0, '"not" can not be used with a schema condition');
        Assert(options3.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema, {
          is: condition,
          then: options3.then,
          otherwise: options3.otherwise,
          break: options3.break
        });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options3.not === void 0 || options3.is === void 0, 'Cannot combine "is" with "not"');
      if (options3.switch === void 0) {
        let rule2 = options3;
        if (options3.not !== void 0) {
          rule2 = {
            is: options3.not,
            then: options3.otherwise,
            otherwise: options3.then,
            break: options3.break
          };
        }
        let is = rule2.is !== void 0 ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options3.is !== void 0 && !Ref.isRef(options3.is) && !Common.isSchema(options3.is)) {
          is = is.required();
        }
        return internals.condition(schema, {
          ref: exports2.ref(condition),
          is,
          then: rule2.then,
          otherwise: rule2.otherwise,
          break: rule2.break
        });
      }
      Assert(Array.isArray(options3.switch), '"switch" must be an array');
      Assert(options3.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options3.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options3.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports2.ref(condition),
        switch: [],
        break: options3.break
      };
      for (let i2 = 0; i2 < options3.switch.length; ++i2) {
        const test = options3.switch[i2];
        const last = i2 === options3.switch.length - 1;
        Common.assertOptions(test, last ? [
          "is",
          "then",
          "otherwise"
        ] : [
          "is",
          "then"
        ]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema.$_compile(test.is),
          then: schema.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          Assert(options3.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options3.otherwise !== void 0 ? options3.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema, condition) {
      for (const key of [
        "then",
        "otherwise"
      ]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/annotate.js
var require_annotate = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/annotate.js"(exports2) {
    "use strict";
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports2.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = Clone(this._original);
      for (let i2 = this.details.length - 1; i2 >= 0; --i2) {
        const pos = i2 + 1;
        const error40 = this.details[i2];
        const path = error40.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || {
              errors: {},
              missing: {}
            };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error40.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i2 = 0; i2 < this.details.length; ++i2) {
        const pos = i2 + 1;
        message = `${message}
[${pos}] ${this.details[i2].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = (key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i2 = 0; i2 < value.length; ++i2) {
                if (annotations.errors[i2]) {
                  annotated.push(`_$idx$_${annotations.errors[i2].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i2]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/errors.js
var require_errors = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/errors.js"(exports2) {
    "use strict";
    var Annotate = require_annotate();
    var Common = require_common();
    var Template = require_template();
    exports2.Report = class {
      constructor(code3, value, local, flags, messages, state, prefs) {
        this.code = code3;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.local = local || {};
        this.local.label = exports2.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code3 = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code3}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, {
          errors: this.prefs.errors,
          messages: [
            this.prefs.messages,
            this.messages
          ]
        });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages) {
        return exports2.template(this.value, messages, this.code, this.state, this.prefs);
      }
    };
    exports2.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports2.template = function(value, messages, code3, state, prefs) {
      if (Template.isTemplate(messages)) {
        return code3 !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang] && messages[lang][code3] !== void 0) {
        return messages[lang][code3];
      }
      return messages[code3];
    };
    exports2.label = function(flags, state, prefs, messages) {
      if (!prefs.errors.label) {
        return "";
      }
      let path = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path = state.path.slice(-1);
      }
      const normalized = exports2.path(path);
      if (normalized) {
        return normalized;
      }
      return exports2.template(null, prefs.messages, "root", state, prefs) || exports2.template(null, messages, "root", state, prefs) || "value";
    };
    exports2.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports2.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports2.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports2.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports2.details = function(errors, options3 = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options3.override !== false) {
            return {
              override: item
            };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: {
              error: item
            }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v2) => typeof v2 !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [
          ...new Set(messages)
        ];
      }
      return {
        message: messages.join(". "),
        details
      };
    };
    exports2.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports2.ValidationError;
      }
    };
    exports2.ValidationError.prototype.isJoi = true;
    exports2.ValidationError.prototype.name = "ValidationError";
    exports2.ValidationError.prototype.annotate = Annotate.error;
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/extend.js
var require_extend = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/extend.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    exports2.type = function(from6, options3) {
      const base4 = Object.getPrototypeOf(from6);
      const prototype = Clone(base4);
      const schema = from6._assign(Object.create(prototype));
      const def = Object.assign({}, options3);
      delete def.base;
      prototype._definition = def;
      const parent = base4._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          Assert(schema.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = {
            method: def.coerce
          };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = {
            method: def.coerce.method,
            from: [].concat(def.coerce.from)
          };
        }
      }
      def.coerce = def.coerce || parent.coerce;
      def.validate = def.validate || parent.validate;
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
          const method = rule.method;
          if (method) {
            Assert(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          Assert(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = {
                  name: arg
                };
              }
              Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      if (def.overrides) {
        prototype._super = base4;
        schema.$_super = {};
        for (const override in def.overrides) {
          Assert(base4[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base4[override];
          schema.$_super[override] = base4[override].bind(schema);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      def.rebuild = def.rebuild || parent.rebuild;
      return schema;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/modify.js
var require_modify = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/modify.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports2.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone2 = new internals.Ids();
        clone2._byId = new Map(this._byId);
        clone2._byKey = new Map(this._byKey);
        clone2._schemaChain = this._schemaChain;
        return clone2;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      reach(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [
          ...behind,
          ...path
        ].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [
          ...behind,
          current
        ]);
      }
      register(schema, { key } = {}) {
        if (!schema || !Common.isSchema(schema)) {
          return;
        }
        if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, {
            schema,
            id
          });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, {
            schema,
            id: key
          });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    exports2.schema = function(schema, options3) {
      let obj;
      for (const name in schema._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema._flags[name], {
          source: "flags",
          name
        }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj._flags[name] = result;
        }
      }
      for (let i2 = 0; i2 < schema._rules.length; ++i2) {
        const rule = schema._rules[i2];
        const result = internals.scan(rule.args, {
          source: "rules",
          name: rule.name
        }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          const clone2 = Object.assign({}, rule);
          clone2.args = result;
          obj._rules[i2] = clone2;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone2);
          }
        }
      }
      for (const name in schema.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema.$_terms[name], {
          source: "terms",
          name
        }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options3, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone2;
      if (Array.isArray(item)) {
        for (let i2 = 0; i2 < item.length; ++i2) {
          const key = source.name === "keys" && item[i2].key;
          const result = internals.scan(item[i2], source, options3, [
            i2,
            ...path
          ], key);
          if (result !== void 0) {
            clone2 = clone2 || item.slice();
            clone2[i2] = result;
          }
        }
        return clone2;
      }
      if (options3.schema !== false && Common.isSchema(item) || options3.ref !== false && Ref.isRef(item)) {
        const result = options3.each(item, {
          ...source,
          path,
          key: _key
        });
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options3, [
          key,
          ...path
        ], _key);
        if (result !== void 0) {
          clone2 = clone2 || Object.assign({}, item);
          clone2[key] = result;
        }
      }
      return clone2;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/state.js
var require_state = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/state.js"(exports2, module2) {
    "use strict";
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      value: Symbol("value")
    };
    module2.exports = internals.State = class {
      constructor(path, ancestors, state) {
        this.path = path;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
      }
      localize(path, ancestors = null, schema = null) {
        const state = new internals.State(path, ancestors, this);
        if (schema && state.schemas) {
          state.schemas = [
            internals.schemas(schema),
            ...state.schemas
          ];
        }
        return state;
      }
      nest(schema) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [
          internals.schemas(schema),
          ...state.schemas
        ];
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
      }
    };
    internals.schemas = function(schema) {
      if (Common.isSchema(schema)) {
        return {
          schema
        };
      }
      return schema;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path, value, reason) {
        if (!path.length) {
          return;
        }
        if (reason === "strip" && typeof path[path.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i2 = 0; i2 < path.length; ++i2) {
          const segment = path[i2];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path) {
        const node = this.node(path);
        if (node) {
          return node[internals.value];
        }
      }
      node(path) {
        if (!this._values) {
          return;
        }
        return Reach(this._values, path, {
          iterables: true
        });
      }
      override(path, node) {
        if (!this._values) {
          return;
        }
        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, {
          iterables: true
        });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/validator.js
var require_validator = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/validator.js"(exports2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Errors = require_errors();
    var State = require_state();
    var internals = {
      result: Symbol("result")
    };
    exports2.entry = function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      const outcome = {
        value: result.value
      };
      if (result.error) {
        outcome.error = result.error;
      }
      return outcome;
    };
    internals.entry = function(value, schema, prefs) {
      const links = schema._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = {
        links
      };
      const schemas = schema._ids._schemaChain ? [
        {
          schema
        }
      ] : null;
      const state = new State([], [], {
        mainstay,
        schemas
      });
      const result = exports2.validate(value, schema, state, prefs);
      const error40 = Errors.process(result.errors, value, prefs);
      return {
        value: result.value,
        error: error40,
        mainstay
      };
    };
    exports2.validate = function(value, schema, state, prefs, overrides = {}) {
      if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
      }
      if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
      }
      const createError = (code3, local, localState) => schema.$_createError(code3, value, local, localState || state, prefs);
      const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        message: (messages, local) => schema.$_createError("custom", value, local, state, prefs, {
          messages
        })
      };
      const def = schema._definition;
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty4 = schema._flags.empty;
      if (empty4 && empty4.$_match(internals.trim(value, schema), state.nest(empty4), Common.defaults)) {
        value = void 0;
      }
      const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [
            schema.$_createError("any.required", value, null, state, prefs)
          ], helpers);
        }
        if (presence === "optional") {
          if (schema._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [
          schema.$_createError("any.unknown", value, null, state, prefs)
        ], helpers);
      }
      const errors = [];
      if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            value = match.value;
          }
          return internals.finalize(value, null, helpers);
        }
        if (schema._flags.only) {
          const report = schema.$_createError("any.only", value, {
            valids: schema._valids.values({
              display: true
            })
          }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [
              report
            ], helpers);
          }
          errors.push(report);
        }
      }
      if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          const report = schema.$_createError("any.invalid", value, {
            invalids: schema._invalids.values({
              display: true
            })
          }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [
              report
            ], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base4 = def.validate(value, helpers);
        if (base4) {
          value = base4.value;
          if (base4.errors) {
            if (!Array.isArray(base4.errors)) {
              errors.push(base4.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base4.errors.length) {
              errors.push(...base4.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema.$_createError("any.ref", resolved, {
                arg: key,
                ref: args[key],
                reason: invalid
              }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        return {
          errors: [
            ret
          ],
          value: null
        };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        return {
          errors: ret,
          value: null
        };
      }
      return {
        errors: null,
        value: ret
      };
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema, state } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema._flags.error) {
        if (typeof schema._flags.error === "function") {
          errors = schema._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [
              errors
            ];
          }
          for (const error40 of errors) {
            Assert(error40 instanceof Error || error40 instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [
            schema._flags.error
          ];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        value = defaulted;
      }
      if (schema._flags.cast && value !== void 0) {
        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          value = casted;
        }
      }
      const result = {
        value,
        errors: errors.length ? errors : null
      };
      if (schema._flags.result) {
        result.value = schema._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state.shadow(value, schema._flags.result);
      }
      return result;
    };
    internals.prefs = function(schema, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
        return schema._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema._preferences);
      if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      const source = schema._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [
          Clone(state.ancestors[0]),
          helpers
        ] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema.$_createError(`any.${flag}`, null, {
            error: err
          }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/values.js
var require_values = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/values.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Common = require_common();
    var internals = {};
    module2.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [
            ...source._values,
            ...source._refs
          ]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [
            ...remove._values,
            ...remove._refs
          ]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return {
            value
          };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return {
              value: found
            };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (DeepEqual(item, value)) {
              return {
                value: item
              };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, {
              in: true
            });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [
              resolved
            ] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return {
                    value: item,
                    ref
                  };
                }
              } else {
                if (DeepEqual(item, value)) {
                  return {
                    value: item,
                    ref
                  };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options3) {
        if (options3 && options3.display) {
          const values = [];
          for (const item of [
            ...this._values,
            ...this._refs
          ]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([
          ...this._values,
          ...this._refs
        ]);
      }
      clone() {
        const set2 = new internals.Values(this._values, this._refs);
        set2._override = this._override;
        return set2;
      }
      concat(source) {
        Assert(!source._override, "Cannot concat override set of values");
        const set2 = new internals.Values([
          ...this._values,
          ...source._values
        ], [
          ...this._refs,
          ...source._refs
        ]);
        set2._override = this._override;
        return set2;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from6) {
      const map2 = /* @__PURE__ */ new Map();
      if (from6) {
        for (const value of from6) {
          if (typeof value === "string") {
            map2.set(value.toLowerCase(), value);
          }
        }
      }
      return map2;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/base.js
var require_base = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/base.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var DeepEqual = require_deepEqual();
    var Merge = require_merge();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Messages = require_messages();
    var Modify = require_modify();
    var Ref = require_ref();
    var Validator = require_validator();
    var Values = require_values();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          whens: {}
          // Runtime cache of generated whens
        };
      }
      // Rules
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      cast(to) {
        Assert(to === false || typeof to === "string", "Invalid to value");
        Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options3) {
        return this._default("default", value, options3);
      }
      empty(schema) {
        const obj = this.clone();
        if (schema !== void 0) {
          schema = obj.$_compile(schema, {
            override: false
          });
        }
        return obj.$_setFlag("empty", schema, {
          clone: false
        });
      }
      error(err) {
        Assert(err, "Missing error");
        Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      failover(value, options3) {
        return this._default("failover", value, options3);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        Assert(typeof id === "string", "id must be a non-empty string");
        Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      only(mode = true) {
        Assert(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        Assert(prefs, "Missing preferences");
        Assert(prefs.context === void 0, "Cannot override context");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        Assert([
          "optional",
          "required",
          "forbidden"
        ].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled3 = true) {
        return this.$_setFlag("result", enabled3 ? "raw" : void 0);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled3) {
        const obj = this.clone();
        const convert = enabled3 === void 0 ? false : !enabled3;
        obj._preferences = Common.preferences(obj._preferences, {
          convert
        });
        return obj;
      }
      strip(enabled3 = true) {
        return this.$_setFlag("result", enabled3 ? "strip" : void 0);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, {
          clone: false
        });
        return obj;
      }
      when(condition, options3) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options3);
        if (![
          "any",
          "link"
        ].includes(obj.type)) {
          const conditions = when.is ? [
            when
          ] : when.switch;
          for (const item of conditions) {
            Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then?.type);
            Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise?.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      // Helpers
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else {
          Merge(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        return obj.$_mutateRebuild();
      }
      validate(value, options3) {
        return Validator.entry(value, this, options3);
      }
      validateAsync(value, options3) {
        const result = this.validate(value, options3);
        if (result.error) {
          throw result.error;
        }
        return result.value;
      }
      // Extensions
      $_addRule(options3) {
        if (typeof options3 === "string") {
          options3 = {
            name: options3
          };
        }
        Assert(options3 && typeof options3 === "object", "Invalid options");
        Assert(options3.name && typeof options3.name === "string", "Invalid rule name");
        for (const key in options3) {
          Assert(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options3);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        Assert(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error40 = Common.validateArg(arg, key, resolver);
                  Assert(!error40, error40, "or reference");
                }
              }
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name);
          obj._singleRules.set(rule.name, rule);
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema, options3) {
        return Compile.schema(this.$_root, schema, options3);
      }
      $_createError(code3, value, local, state, prefs, options3 = {}) {
        const flags = options3.flags !== false ? this._flags : {};
        const messages = options3.messages ? Messages.merge(this._definition.messages, options3.messages) : this._definition.messages;
        return new Errors.Report(code3, value, local, flags, messages, state, prefs);
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options3) {
        Common.assertOptions(options3, [
          "each",
          "once",
          "ref",
          "schema"
        ]);
        return Modify.schema(this, options3) || this;
      }
      $_mutateRebuild() {
        this._refs.reset();
        this._ids.reset();
        const each = (item, { source, name, path, key }) => {
          const family = this._definition[source][name]?.register;
          if (family !== false) {
            this.$_mutateRegister(item, {
              family,
              key
            });
          }
        };
        this.$_modify({
          each
        });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        return this;
      }
      $_mutateRegister(schema, { family, key } = {}) {
        this._refs.register(schema, family);
        this._ids.register(schema, {
          key
        });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path) {
        return this._ids.reach(path);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options3 = {}) {
        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
          value = void 0;
        }
        if (DeepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options3.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      // Internals
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids?.clone();
        target._invalids = this._invalids?.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, {
          shallow: true
        });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _default(flag, value, options3 = {}) {
        Common.assertOptions(options3, "literal");
        Assert(value !== void 0, "Missing", flag, "value");
        Assert(typeof value === "function" || !options3.literal, "Only function value supports literal option");
        if (typeof value === "function" && options3.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _extend(options3) {
        Assert(!options3.base, "Cannot extend type with another base");
        return Extend.type(this, options3);
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return {
            schema: this
          };
        }
        const whens = [];
        const ids = [];
        for (let i2 = 0; i2 < this.$_terms.whens.length; ++i2) {
          const when = this.$_terms.whens[i2];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i2}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [
            when
          ] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i2}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([
                  ...state.path,
                  `${baseId}.then`
                ], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([
                ...state.path,
                `${baseId}.otherwise`
              ], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        if (!id) {
          return {
            schema: this
          };
        }
        if (this.$_temp.whens[id]) {
          return {
            schema: this.$_temp.whens[id],
            id
          };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        this.$_temp.whens[id] = obj;
        return {
          schema: obj,
          id
        };
      }
      _ruleRemove(name) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        this._singleRules.delete(name);
        const filtered = [];
        for (let i2 = 0; i2 < this._rules.length; ++i2) {
          const test = this._rules[i2];
          if (test.name === name) {
            continue;
          }
          filtered.push(test);
        }
        this._rules = filtered;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          Assert(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module2.exports = new internals.Base();
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/any.js
var require_any = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/any.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Base = require_base();
    var Common = require_common();
    module2.exports = Base._extend({
      type: "any",
      flags: {
        only: {
          default: false
        }
      },
      terms: {
        alterations: {
          init: null
        },
        examples: {
          init: null
        },
        metas: {
          init: []
        },
        notes: {
          init: []
        },
        shared: {
          init: null
        },
        tags: {
          init: []
        },
        whens: {
          init: null
        }
      },
      rules: {
        custom: {
          method(method, description) {
            Assert(typeof method === "function", "Method must be a function");
            Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({
              name: "custom",
              args: {
                method,
                description
              }
            });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", {
                error: err
              });
            }
          },
          args: [
            "method",
            "description"
          ],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({
              messages
            });
          }
        },
        shared: {
          method(schema) {
            Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema);
            obj.$_mutateRegister(schema);
            return obj;
          }
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": "{{#label}} must be one of {{#valids}}",
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/alternatives.js
var require_alternatives = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/alternatives.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {};
    module2.exports = Any._extend({
      type: "alternatives",
      flags: {
        match: {
          default: "any"
        }
        // 'any', 'one', 'all'
      },
      terms: {
        matches: {
          init: [],
          register: Ref.toSibling
        }
      },
      args(schema, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema.try(...schemas[0]);
          }
        }
        return schema.try(...schemas);
      },
      validate(value, helpers) {
        const { schema, error: error40, state, prefs } = helpers;
        if (schema._flags.match) {
          let hits = 0;
          let matched;
          for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
            const item = schema.$_terms.matches[i2];
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              ++hits;
              matched = result.value;
            } else {
              localState.restore();
            }
          }
          if (!hits) {
            return {
              errors: error40("alternatives.any")
            };
          }
          if (schema._flags.match === "one") {
            return hits === 1 ? {
              value: matched
            } : {
              errors: error40("alternatives.one")
            };
          }
          return hits === schema.$_terms.matches.length ? {
            value
          } : {
            errors: error40("alternatives.all")
          };
        }
        const errors = [];
        for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
          const item = schema.$_terms.matches[i2];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              return result;
            }
            localState.restore();
            errors.push({
              schema: item.schema,
              reports: result.errors
            });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [
            item
          ] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i2}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options3) {
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            Assert(options3.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options3);
            const conditions = match.is ? [
              match
            ] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, {
                  clone: false
                });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            Assert([
              "any",
              "one",
              "all"
            ].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            Assert(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema of schemas) {
              obj.$_terms.matches.push({
                schema: obj.$_compile(schema)
              });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      rebuild(schema) {
        const each = (item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema.$_setFlag("_arrayItems", true, {
              clone: false
            });
          }
        };
        schema.$_modify({
          each
        });
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error: error40, state }) {
      if (!failures.length) {
        return {
          errors: error40("alternatives.any")
        };
      }
      if (failures.length === 1) {
        return {
          errors: failures[0].reports
        };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error40);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error40);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({
            type: schema.type,
            report
          });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code3] = report.code.split(".");
        if (code3 !== "base") {
          complex.push({
            type: schema.type,
            report
          });
          continue;
        }
        valids.add(type);
      }
      if (!complex.length) {
        return {
          errors: error40("alternatives.types", {
            types: [
              ...valids
            ]
          })
        };
      }
      if (complex.length === 1) {
        return {
          errors: complex[0].report
        };
      }
      return internals.unmatched(failures, error40);
    };
    internals.unmatched = function(failures, error40) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return {
        errors: error40("alternatives.match", Errors.details(errors, {
          override: false
        }))
      };
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/array.js
var require_array = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/array.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Reach = require_reach();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var internals = {};
    module2.exports = Any._extend({
      type: "array",
      flags: {
        single: {
          default: false
        },
        sparse: {
          default: false
        }
      },
      terms: {
        items: {
          init: []
        },
        ordered: {
          init: []
        },
        _exclusions: {
          init: []
        },
        _inclusions: {
          init: []
        },
        _requireds: {
          init: []
        }
      },
      coerce: {
        from: "object",
        method(value, { schema, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema, error: error40 }) {
        if (!Array.isArray(value)) {
          if (schema._flags.single) {
            const single = [
              value
            ];
            single[Common.symbols.arraySingle] = true;
            return {
              value: single
            };
          }
          return {
            errors: error40("array.base")
          };
        }
        if (!schema.$_getRule("items")) {
          return;
        }
        return {
          value: value.slice()
        };
      },
      rules: {
        has: {
          method(schema) {
            schema = this.$_compile(schema, {
              appendPath: true
            });
            const obj = this.$_addRule({
              name: "has",
              args: {
                schema
              }
            });
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { state, prefs, error: error40 }, { schema: has3 }) {
            const ancestors = [
              value,
              ...state.ancestors
            ];
            for (let i2 = 0; i2 < value.length; ++i2) {
              const localState = state.localize([
                ...state.path,
                i2
              ], ancestors, has3);
              if (has3.$_match(value[i2], localState, prefs)) {
                return value;
              }
            }
            return error40("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, {
                append: true
              });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema, error: error40, state, prefs, errorsArray }) {
            const requireds = schema.$_terms._requireds.slice();
            const ordereds = schema.$_terms.ordered.slice();
            const inclusions = [
              ...schema.$_terms._inclusions,
              ...requireds
            ];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i2 = 0; i2 < il; ++i2) {
              const item = value[i2];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i2 : new Number(i2);
              const path = [
                ...state.path,
                key
              ];
              if (!schema._flags.sparse && item === void 0) {
                errors.push(error40("array.sparse", {
                  key,
                  path,
                  pos: i2,
                  value: void 0
                }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [
                value,
                ...state.ancestors
              ];
              for (const exclusion of schema.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, {
                  presence: "ignore"
                })) {
                  continue;
                }
                errors.push(error40("array.excludes", {
                  pos: i2,
                  value: item
                }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error40("array.sparse", {
                        key,
                        path,
                        pos: i2,
                        value: void 0
                      }, state.localize(path)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i2] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema.$_terms.items.length) {
                  errors.push(error40("array.orderedLength", {
                    pos: i2,
                    limit: schema.$_terms.ordered.length
                  }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  value[i2] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema._flags.sparse && res.value === void 0) {
                    errors.push(error40("array.sparse", {
                      key,
                      path,
                      pos: i2,
                      value: void 0
                    }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error40("array.sparse", {
                        key,
                        path,
                        pos: i2,
                        value: void 0
                      }, state.localize(path)));
                      errored = true;
                    } else {
                      value[i2] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i2);
                    --i2;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms._inclusions.length && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i2);
                  --i2;
                  --il;
                  continue;
                }
                errors.push(error40("array.includes", {
                  pos: i2,
                  value: item
                }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
            }
            return errors.length ? errors : value;
          },
          priority: true
        },
        length: {
          method(limit) {
            return this.$_addRule({
              name: "length",
              args: {
                limit
              },
              operator: "="
            });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "length",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "length",
              args: {
                limit
              },
              operator: ">="
            });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, {
                append: true
              });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled3) {
            const value = enabled3 === void 0 ? true : !!enabled3;
            Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "by",
              "order"
            ]);
            const settings = {
              order: options3.order || "ascending"
            };
            if (options3.by) {
              settings.by = Compile.ref(options3.by, {
                ancestor: 0
              });
              Assert(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({
              name: "sort",
              args: {
                options: settings
              }
            });
          },
          validate(value, { error: error40, state, prefs, schema }, { options: options3 }) {
            const { value: sorted, errors } = internals.sort(schema, value, options3, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i2 = 0; i2 < value.length; ++i2) {
              if (value[i2] !== sorted[i2]) {
                return error40("array.sort", {
                  order: options3.order,
                  by: options3.by ? options3.by.key : "value"
                });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled3) {
            const value = enabled3 === void 0 ? true : !!enabled3;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, {
              clone: false
            });
          }
        },
        unique: {
          method(comparator, options3 = {}) {
            Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options3, [
              "ignoreUndefined",
              "separator"
            ]);
            const rule = {
              name: "unique",
              args: {
                options: options3,
                comparator
              }
            };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options3.separator, ".");
                rule.path = separator ? comparator.split(separator) : [
                  comparator
                ];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error: error40, schema }, { comparator: raw, options: options3 }, { comparator, path }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || DeepEqual;
            const ignoreUndefined = options3.ignoreUndefined;
            for (let i2 = 0; i2 < value.length; ++i2) {
              const item = path ? Reach(value[i2], path) : value[i2];
              const records = comparator ? found.custom : found[typeof item];
              Assert(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([
                      ...state.path,
                      i2
                    ], [
                      value,
                      ...state.ancestors
                    ]);
                    const context = {
                      pos: i2,
                      value: value[i2],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path) {
                      context.path = raw;
                    }
                    return error40("array.unique", context, localState);
                  }
                }
                records.set(item, i2);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i2,
                    value: value[i2],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  const localState = state.localize([
                    ...state.path,
                    i2
                  ], [
                    value,
                    ...state.ancestors
                  ]);
                  return error40("array.unique", context, localState);
                }
                records[item] = i2;
              }
            }
            return value;
          },
          args: [
            "comparator",
            "options"
          ],
          multi: true
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema) {
        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];
        for (const type of schema.$_terms.items) {
          internals.validateSingle(type, schema);
          if (type._flags.presence === "required") {
            schema.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema.$_terms._exclusions.push(type);
          } else {
            schema.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema.$_terms.ordered) {
          internals.validateSingle(type, schema);
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
      let unknownMisses = 0;
      for (let i2 = 0; i2 < requireds.length; ++i2) {
        ++unknownMisses;
      }
      errors.push(schema.$_createError("array.includesRequiredUnknowns", value, {
        unknownMisses
      }, state, prefs));
    };
    internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fastSplice = function(arr, i2) {
      let pos = i2;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, {
          clone: false
        });
      }
    };
    internals.sort = function(schema, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = (a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema.$_createError("array.sort.unsupported", value, {
            type
          }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      };
      try {
        return {
          value: value.slice().sort(sort)
        };
      } catch (err) {
        return {
          errors: err
        };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/boolean.js
var require_boolean = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/boolean.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Values = require_values();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module2.exports = Any._extend({
      type: "boolean",
      flags: {
        sensitive: {
          default: false
        }
      },
      terms: {
        falsy: {
          init: null
        },
        truthy: {
          init: null
        }
      },
      coerce(value, { schema }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema.$_terms.truthy?.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy?.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }
        return {
          value
        };
      },
      validate(value, { error: error40 }) {
        if (typeof value !== "boolean") {
          return {
            value,
            errors: error40("boolean.base")
          };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              Assert(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              Assert(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled3 = true) {
            return this.$_setFlag("sensitive", enabled3);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/date.js
var require_date = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/date.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Template = require_template();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module2.exports = Any._extend({
      type: "date",
      coerce: {
        from: [
          "number",
          "string"
        ],
        method(value, { schema }) {
          return {
            value: internals.parse(value, schema._flags.format) || value
          };
        }
      },
      validate(value, { schema, error: error40, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format10 = schema._flags.format;
        if (!prefs.convert || !format10 || typeof value !== "string") {
          return {
            value,
            errors: error40("date.base")
          };
        }
        return {
          value,
          errors: error40("date.format", {
            format: format10
          })
        };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date: date5 }, { name, operator, args }) {
            const to = date5 === "now" ? Date.now() : date5.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, {
              limit: args.date,
              value
            });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date5) => {
                return date5 === "now" ? date5 : internals.parse(date5);
              },
              assert: (date5) => date5 !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format10) {
            Assert([
              "iso",
              "javascript",
              "unix"
            ].includes(format10), "Unknown date format", format10);
            return this.$_setFlag("format", format10);
          }
        },
        greater: {
          method(date5) {
            return this.$_addRule({
              name: "greater",
              method: "compare",
              args: {
                date: date5
              },
              operator: ">"
            });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date5) {
            return this.$_addRule({
              name: "less",
              method: "compare",
              args: {
                date: date5
              },
              operator: "<"
            });
          }
        },
        max: {
          method(date5) {
            return this.$_addRule({
              name: "max",
              method: "compare",
              args: {
                date: date5
              },
              operator: "<="
            });
          }
        },
        min: {
          method(date5) {
            return this.$_addRule({
              name: "min",
              method: "compare",
              args: {
                date: date5
              },
              operator: ">="
            });
          }
        },
        timestamp: {
          method(type = "javascript") {
            Assert([
              "javascript",
              "unix"
            ].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": "{{#label}} must be in {{#format}} format",
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}"
      }
    });
    internals.parse = function(value, format10) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format10 === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format10) {
        if (format10 === "javascript") {
          return internals.date(1 * value);
        }
        if (format10 === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date5 = new Date(value);
      if (!isNaN(date5.getTime())) {
        return date5;
      }
      return null;
    };
  }
});

// node_modules/.deno/@hapi+topo@6.0.2/node_modules/@hapi/topo/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.deno/@hapi+topo@6.0.2/node_modules/@hapi/topo/lib/index.js"(exports2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var internals = {};
    exports2.Sorter = class {
      constructor() {
        this._items = [];
        this.nodes = [];
      }
      add(nodes, options3) {
        options3 = options3 ?? {};
        const before = [].concat(options3.before ?? []);
        const after = [].concat(options3.after ?? []);
        const group = options3.group ?? "?";
        const sort = options3.sort ?? 0;
        assert4(!before.includes(group), `Item cannot come before itself: ${group}`);
        assert4(!before.includes("?"), "Item cannot come before unassociated items");
        assert4(!after.includes(group), `Item cannot come after itself: ${group}`);
        assert4(!after.includes("?"), "Item cannot come after unassociated items");
        if (!Array.isArray(nodes)) {
          nodes = [
            nodes
          ];
        }
        for (const node of nodes) {
          const item = {
            seq: this._items.length,
            sort,
            before,
            after,
            group,
            node
          };
          this._items.push(item);
        }
        if (!options3.manual) {
          const valid = this._sort();
          assert4(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
        }
        return this.nodes;
      }
      merge(others) {
        if (!Array.isArray(others)) {
          others = [
            others
          ];
        }
        for (const other of others) {
          if (other) {
            for (const item of other._items) {
              this._items.push(Object.assign({}, item));
            }
          }
        }
        this._items.sort(internals.mergeSort);
        for (let i2 = 0; i2 < this._items.length; ++i2) {
          this._items[i2].seq = i2;
        }
        const valid = this._sort();
        assert4(valid, "merge created a dependencies error");
        return this.nodes;
      }
      sort() {
        const valid = this._sort();
        assert4(valid, "sort created a dependencies error");
        return this.nodes;
      }
      _sort() {
        const graph = {};
        const graphAfters = /* @__PURE__ */ Object.create(null);
        const groups = /* @__PURE__ */ Object.create(null);
        for (const item of this._items) {
          const seq = item.seq;
          const group = item.group;
          groups[group] = groups[group] ?? [];
          groups[group].push(seq);
          graph[seq] = item.before;
          for (const after of item.after) {
            graphAfters[after] = graphAfters[after] ?? [];
            graphAfters[after].push(seq);
          }
        }
        for (const node in graph) {
          const expandedGroups = [];
          for (const graphNodeItem in graph[node]) {
            const group = graph[node][graphNodeItem];
            groups[group] = groups[group] ?? [];
            expandedGroups.push(...groups[group]);
          }
          graph[node] = expandedGroups;
        }
        for (const group in graphAfters) {
          if (groups[group]) {
            for (const node of groups[group]) {
              graph[node].push(...graphAfters[group]);
            }
          }
        }
        const ancestors = {};
        for (const node in graph) {
          const children = graph[node];
          for (const child of children) {
            ancestors[child] = ancestors[child] ?? [];
            ancestors[child].push(node);
          }
        }
        const visited = {};
        const sorted = [];
        for (let i2 = 0; i2 < this._items.length; ++i2) {
          let next = i2;
          if (ancestors[i2]) {
            next = null;
            for (let j = 0; j < this._items.length; ++j) {
              if (visited[j] === true) {
                continue;
              }
              if (!ancestors[j]) {
                ancestors[j] = [];
              }
              const shouldSeeCount = ancestors[j].length;
              let seenCount = 0;
              for (let k = 0; k < shouldSeeCount; ++k) {
                if (visited[ancestors[j][k]]) {
                  ++seenCount;
                }
              }
              if (seenCount === shouldSeeCount) {
                next = j;
                break;
              }
            }
          }
          if (next !== null) {
            visited[next] = true;
            sorted.push(next);
          }
        }
        if (sorted.length !== this._items.length) {
          return false;
        }
        const seqIndex = {};
        for (const item of this._items) {
          seqIndex[item.seq] = item;
        }
        this._items = [];
        this.nodes = [];
        for (const value of sorted) {
          const sortedItem = seqIndex[value];
          this.nodes.push(sortedItem.node);
          this._items.push(sortedItem);
        }
        return true;
      }
    };
    internals.mergeSort = (a, b) => {
      return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/keys.js
var require_keys = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/keys.js"(exports2, module2) {
    "use strict";
    var ApplyToDefaults = require_applyToDefaults();
    var Assert = require_assert();
    var Clone = require_clone();
    var Topo = require_lib2();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      renameDefaults: {
        alias: false,
        multiple: false,
        override: false
        // Overrides an existing key
      }
    };
    module2.exports = Any._extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: {
          default: false
        }
      },
      terms: {
        dependencies: {
          init: null
        },
        keys: {
          init: null
        },
        patterns: {
          init: null
        },
        renames: {
          init: null
        }
      },
      args(schema, keys) {
        return schema.keys(keys);
      },
      validate(value, { schema, error: error40, state, prefs }) {
        if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
          return {
            value,
            errors: error40("object.base", {
              type: schema.$_property("typeof")
            })
          };
        }
        if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
          return {
            value,
            errors
          };
        }
        if (!schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns && !schema.$_terms.dependencies) {
          return {
            value,
            errors
          };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema.$_terms.keys) {
          const ancestors = [
            value,
            ...state.ancestors
          ];
          for (const child of schema.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([
              ...state.path,
              key
            ], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: result.errors
                };
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema._flags._hasPatternMatch) {
          const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema.$_terms.dependencies) {
          for (const dep of schema.$_terms.dependencies) {
            if (dep.key && dep.key.resolve(value, state, prefs, null, {
              shadow: false
            }) === void 0) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
            if (failed) {
              const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: report
                };
              }
              errors.push(report);
            }
          }
        }
        return {
          value,
          errors
        };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema) {
            if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
              return this;
            }
            return this.keys(schema);
          }
        },
        assert: {
          method(subject, schema, message) {
            subject = Compile.ref(subject);
            Assert(message === void 0 || typeof message === "string", "Message must be a string");
            schema = this.$_compile(schema, {
              appendPath: true
            });
            const obj = this.$_addRule({
              name: "assert",
              args: {
                subject,
                schema,
                message
              }
            });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { error: error40, prefs, state }, { subject, schema, message }) {
            const about = subject.resolve(value, state, prefs);
            const path = subject.absolute(state);
            if (schema.$_match(about, state.localize(path, [
              value,
              ...state.ancestors
            ], schema), prefs)) {
              return value;
            }
            return error40("object.assert", {
              subject,
              message
            });
          },
          args: [
            "subject",
            "schema",
            "message"
          ],
          multi: true
        },
        instance: {
          method(constructor, name) {
            Assert(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({
              name: "instance",
              args: {
                constructor,
                name
              }
            });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", {
              type: name,
              value
            });
          },
          args: [
            "constructor",
            "name"
          ]
        },
        keys: {
          method(schema) {
            Assert(schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
            Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema) {
                Common.tryWithPath(() => obj.$_terms.keys.push({
                  key,
                  schema: this.$_compile(schema[key])
                }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({
              name: "length",
              args: {
                limit
              },
              operator: "="
            });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "length",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "length",
              args: {
                limit
              },
              operator: ">="
            });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema, options3 = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, {
                appendPath: true
              });
            }
            Assert(schema !== void 0, "Invalid rule");
            Common.assertOptions(options3, [
              "fallthrough",
              "matches"
            ]);
            if (isRegExp) {
              Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema = this.$_compile(schema, {
              appendPath: true
            });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config2 = {
              [isRegExp ? "regex" : "schema"]: pattern,
              rule: schema
            };
            if (options3.matches) {
              config2.matches = this.$_compile(options3.matches);
              if (config2.matches.type !== "array") {
                config2.matches = config2.matches.$_root.array().items(config2.matches);
              }
              obj.$_mutateRegister(config2.matches);
              obj.$_setFlag("_hasPatternMatch", true, {
                clone: false
              });
            }
            if (options3.fallthrough) {
              config2.fallthrough = true;
            }
            obj.$_terms.patterns.push(config2);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", {
              value
            });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", {
              value
            });
          }
        },
        rename: {
          method(from6, to, options3 = {}) {
            Assert(typeof from6 === "string" || from6 instanceof RegExp, "Rename missing the from argument");
            Assert(typeof to === "string", "Invalid rename to argument");
            Assert(to !== from6, "Cannot rename key to same name:", from6);
            Common.assertOptions(options3, [
              "alias",
              "ignoreUndefined",
              "override",
              "multiple"
            ]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              Assert(rename.from !== from6, "Cannot rename the same key multiple times");
            }
            obj.$_terms.renames.push({
              from: from6,
              to,
              options: ApplyToDefaults(internals.renameDefaults, options3)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({
              name: "schema",
              args: {
                type
              }
            });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", {
              type
            });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "with", key, peers, options3);
          }
        },
        without: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "without", key, peers, options3);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options3) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options3);
        }
      },
      rebuild(schema) {
        if (schema.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, {
              after: child.schema.$_rootReferences(),
              group: child.key
            }), child.key);
          }
          schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#present}} without its required peers {{#missing}}",
        "object.assert": "{{#label}} is invalid because it failed to pass the assertion test",
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": "{{#label}} must have {{#limit}} keys",
        "object.max": "{{#label}} must have less than or equal to {{#limit}} keys",
        "object.min": "{{#label}} must have at least {{#limit}} keys",
        "object.missing": "{{#label}} must contain at least one of {{#peers}}",
        "object.nand": "{{:#main}} must not exist simultaneously with {{#peers}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peers}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#main}} missing required peer {{:#peer}}",
        "object.without": "{{:#main}} conflict with forbidden peer {{:#peer}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peers}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, {
            shallow: true
          });
        }
        const clone3 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone3, value);
        return clone3;
      }
      const clone2 = function(...args) {
        return value.apply(this, args);
      };
      clone2.prototype = Clone(value.prototype);
      Object.defineProperty(clone2, "name", {
        value: value.name,
        writable: false
      });
      Object.defineProperty(clone2, "length", {
        value: value.length,
        writable: false
      });
      Object.assign(clone2, value);
      return clone2;
    };
    internals.dependency = function(schema, rel, key, peers, options3) {
      Assert(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options3) {
        options3 = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options3, [
        "separator"
      ]);
      peers = [].concat(peers);
      const separator = Common.default(options3.separator, ".");
      const paths = [];
      for (const peer of peers) {
        Assert(typeof peer === "string", rel, "peers must be a string or a reference");
        paths.push(Compile.ref(peer, {
          separator,
          ancestor: 0,
          prefix: false
        }));
      }
      if (key !== null) {
        key = Compile.ref(key, {
          separator,
          ancestor: 0,
          prefix: false
        });
      }
      const obj = schema.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
      return obj;
    };
    internals.dependencies = {
      and(schema, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count = dep.peers.length;
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, {
            shadow: false
          }) === void 0) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count && present.length !== count) {
          return {
            code: "object.and",
            context: {
              present,
              missing
            }
          };
        }
      },
      nand(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, {
            shadow: false
          }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            peers: values
          }
        };
      },
      or(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, {
            shadow: false
          }) !== void 0) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths
          }
        };
      },
      oxor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, {
            shadow: false
          }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = {
          peers: dep.paths
        };
        context.present = present;
        return {
          code: "object.oxor",
          context
        };
      },
      with(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, {
            shadow: false
          }) === void 0) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                peer: peer.key
              }
            };
          }
        }
      },
      without(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, {
            shadow: false
          }) !== void 0) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                peer: peer.key
              }
            };
          }
        }
      },
      xor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, {
            shadow: false
          }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = {
          peers: dep.paths
        };
        if (present.length === 0) {
          return {
            code: "object.missing",
            context
          };
        }
        context.present = present;
        return {
          code: "object.xor",
          context
        };
      }
    };
    internals.rename = function(schema, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from6 in value) {
            if (value[from6] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from6 === rename.to) {
              continue;
            }
            const match = rename.from.exec(from6);
            if (!match) {
              continue;
            }
            matches.push({
              from: from6,
              to: rename.to,
              match
            });
          }
        }
        for (const match of matches) {
          const from6 = match.from;
          const to = match.to;
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema.$_createError("object.rename.multiple", value, {
              from: from6,
              to,
              pattern
            }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema.$_createError("object.rename.override", value, {
              from: from6,
              to,
              pattern
            }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from6] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from6];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from6];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
      if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [
          value,
          ...state.ancestors
        ];
        for (const key of unprocessed) {
          const item = value[key];
          const path = [
            ...state.path,
            key
          ];
          for (let i2 = 0; i2 < schema.$_terms.patterns.length; ++i2) {
            const pattern = schema.$_terms.patterns[i2];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i2}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path, ancestors, {
              schema: pattern.rule,
              key
            });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: result.errors
                };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i2].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i2 = 0; i2 < matches.length; ++i2) {
            const match = matches[i2];
            if (!match) {
              continue;
            }
            const stpm = schema.$_terms.patterns[i2].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, {
                override: false
              });
              details.matches = match;
              const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: report
                };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([
            ...state.path,
            unprocessedKey
          ], []);
          const report = schema.$_createError("object.unknown", value[unprocessedKey], {
            child: unprocessedKey
          }, localState, prefs, {
            flags: false
          });
          if (prefs.abortEarly) {
            return {
              value,
              errors: report
            };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < result.length; ++i2) {
          keys.set(result[i2].key, i2);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = {
              key,
              schema: result[pos].schema.concat(item.schema)
            };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/function.js
var require_function = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/function.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Keys = require_keys();
    module2.exports = Keys._extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({
              name: "arity",
              args: {
                n
              }
            });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", {
              n
            });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", {
              value
            });
          }
        },
        minArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({
              name: "minArity",
              args: {
                n
              }
            });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", {
              n
            });
          }
        },
        maxArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({
              name: "maxArity",
              args: {
                n
              }
            });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", {
              n
            });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/link.js
var require_link = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/link.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var internals = {};
    module2.exports = Any._extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: {
          init: null,
          register: false
        }
      },
      args(schema, ref) {
        return schema.ref(ref);
      },
      validate(value, { schema, state, prefs }) {
        Assert(schema.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema, value, state, prefs) {
        return internals.generate(schema, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            Assert(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [
              {
                ref
              }
            ];
            return obj;
          }
        },
        relative: {
          method(enabled3 = true) {
            return this.$_setFlag("relative", enabled3);
          }
        }
      },
      overrides: {
        concat(source) {
          Assert(this.$_terms.link, "Uninitialized link schema");
          Assert(Common.isSchema(source), "Invalid schema object");
          Assert(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({
            concat: source
          });
          return obj.$_mutateRebuild();
        }
      }
    });
    internals.generate = function(schema, value, state, prefs) {
      let linked = state.mainstay.links.get(schema);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema.$_terms.link[0].ref;
      const { perspective, path } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
      try {
        linked = path.length ? perspective.$_reach(path) : perspective;
      } catch (ignoreErr) {
        internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
      if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema, key } of state.schemas) {
          const id = schema._flags.id || key;
          if (id === ref.path[0]) {
            return {
              perspective: schema,
              path: ref.path.slice(1)
            };
          }
          if (schema.$_terms.shared) {
            for (const shared of schema.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return {
                  perspective: shared,
                  path: ref.path.slice(1)
                };
              }
            }
          }
        }
        return {
          perspective: null,
          path: null
        };
      }
      if (ref.ancestor === "root") {
        return {
          perspective: state.schemas[state.schemas.length - 1].schema,
          path: ref.path
        };
      }
      return {
        perspective: state.schemas[ref.ancestor]?.schema,
        path: ref.path
      };
    };
    internals.assert = function(condition, message, ref, schema, state, prefs) {
      if (condition) {
        return;
      }
      Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/number.js
var require_number = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/number.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
    };
    module2.exports = Any._extend({
      type: "number",
      flags: {
        unsafe: {
          default: false
        }
      },
      coerce: {
        from: "string",
        method(value, { schema, error: error40 }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = {
            value: parseFloat(value)
          };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema._flags.unsafe) {
            if (value.match(/e/i)) {
              const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
              if (constructed !== internals.normalizeExponent(value)) {
                result.errors = error40("number.unsafe");
                return result;
              }
            } else {
              const string4 = result.value.toString();
              if (string4.match(/e/i)) {
                return result;
              }
              if (string4 !== internals.normalizeDecimal(value)) {
                result.errors = error40("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema, error: error40, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return {
            value,
            errors: error40("number.infinity")
          };
        }
        if (!Common.isNumber(value)) {
          return {
            value,
            errors: error40("number.base")
          };
        }
        const result = {
          value
        };
        if (prefs.convert) {
          const rule = schema.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error40("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({
              name: "greater",
              method: "compare",
              args: {
                limit
              },
              operator: ">"
            });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({
              name: "less",
              method: "compare",
              args: {
                limit
              },
              operator: "<"
            });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "compare",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "compare",
              args: {
                limit
              },
              operator: ">="
            });
          }
        },
        multiple: {
          method(base4) {
            return this.$_addRule({
              name: "multiple",
              args: {
                base: base4
              }
            });
          },
          validate(value, helpers, { base: base4 }, options3) {
            if (value % base4 === 0) {
              return value;
            }
            return helpers.error("number.multiple", {
              multiple: options3.args.base,
              value
            });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            }
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            Assert(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({
              name: "precision",
              args: {
                limit
              }
            });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", {
              limit,
              value
            });
          },
          convert: true
        },
        sign: {
          method(sign2) {
            Assert([
              "negative",
              "positive"
            ].includes(sign2), "Invalid sign", sign2);
            return this.$_addRule({
              name: "sign",
              args: {
                sign: sign2
              }
            });
          },
          validate(value, helpers, { sign: sign2 }) {
            if (sign2 === "negative" && value < 0 || sign2 === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign2}`);
          }
        },
        unsafe: {
          method(enabled3 = true) {
            Assert(typeof enabled3 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled3);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.normalizeExponent = function(str) {
      return str.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0+$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([1-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/object.js
var require_object = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/object.js"(exports2, module2) {
    "use strict";
    var Keys = require_keys();
    module2.exports = Keys._extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/string.js
var require_string = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/string.js"(exports2, module2) {
    "use strict";
    var Url2 = __require("node:url");
    var Assert = require_assert();
    var EscapeRegex = require_escapeRegex();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      base64Regex: {
        // paddingRequired
        true: {
          // urlSafe
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: /^[a-f0-9]+$/i,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5"
      },
      guidSeparators: /* @__PURE__ */ new Set([
        void 0,
        true,
        false,
        "-",
        ":"
      ]),
      normalizationForms: [
        "NFC",
        "NFD",
        "NFKC",
        "NFKD"
      ],
      domainControlRx: /[\x00-\x20@\:\/]/,
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      finalSegmentAdditionalRx: /[^0-9]/
      // Domain segment which is additionally not all-numeric
    };
    module2.exports = Any._extend({
      type: "string",
      flags: {
        insensitive: {
          default: false
        },
        truncate: {
          default: false
        }
      },
      terms: {
        replacements: {
          init: null
        }
      },
      coerce: {
        from: "string",
        method(value, { schema, state, prefs }) {
          const normalize7 = schema.$_getRule("normalize");
          if (normalize7) {
            value = value.normalize(normalize7.args.form);
          }
          const casing = schema.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema.$_terms.replacements) {
            for (const replacement of schema.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema._flags.truncate) {
            const rule = schema.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return {
                    value,
                    errors: schema.$_createError("any.ref", limit, {
                      ref: rule.args.limit,
                      arg: "limit",
                      reason: "must be a positive integer"
                    }, state, prefs)
                  };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return {
            value
          };
        }
      },
      validate(value, { error: error40 }) {
        if (typeof value !== "string") {
          return {
            value,
            errors: error40("string.base")
          };
        }
        if (value === "") {
          return {
            value,
            errors: error40("string.empty")
          };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "paddingRequired",
              "urlSafe"
            ]);
            options3 = {
              urlSafe: false,
              paddingRequired: true,
              ...options3
            };
            Assert(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            Assert(typeof options3.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({
              name: "base64",
              args: {
                options: options3
              }
            });
          },
          validate(value, helpers, { options: options3 }) {
            const regex = internals.base64Regex[options3.paddingRequired][options3.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            Assert([
              "lower",
              "upper"
            ].includes(direction), "Invalid case:", direction);
            return this.$_addRule({
              name: "case",
              args: {
                direction
              }
            });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i2 = value.length;
            let sum = 0;
            let mul = 1;
            while (i2--) {
              const char = value.charAt(i2) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "paddingRequired"
            ]);
            options3 = {
              paddingRequired: true,
              ...options3
            };
            Assert(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({
              name: "dataUri",
              args: {
                options: options3
              }
            });
          },
          validate(value, helpers, { options: options3 }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options3.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        guid: {
          alias: "uuid",
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "version",
              "separator"
            ]);
            let versionNumbers = "";
            if (options3.version) {
              const versions = [].concat(options3.version);
              Assert(versions.length >= 1, "version must have at least 1 valid version specified");
              const set2 = /* @__PURE__ */ new Set();
              for (let i2 = 0; i2 < versions.length; ++i2) {
                const version4 = versions[i2];
                Assert(typeof version4 === "string", "version at position " + i2 + " must be a string");
                const versionNumber = internals.guidVersions[version4.toLowerCase()];
                Assert(versionNumber, "version at position " + i2 + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                Assert(!set2.has(versionNumber), "version at position " + i2 + " must not be a duplicate");
                versionNumbers += versionNumber;
                set2.add(versionNumber);
              }
            }
            Assert(internals.guidSeparators.has(options3.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options3.separator === void 0 ? "[:-]?" : options3.separator === true ? "[:-]" : options3.separator === false ? "[]?" : `\\${options3.separator}`;
            const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
            return this.$_addRule({
              name: "guid",
              args: {
                options: options3
              },
              regex
            });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "byteAligned"
            ]);
            options3 = {
              byteAligned: false,
              ...options3
            };
            Assert(typeof options3.byteAligned === "boolean", "byteAligned must be boolean");
            return this.$_addRule({
              name: "hex",
              args: {
                options: options3
              }
            });
          },
          validate(value, helpers, { options: options3 }) {
            if (!internals.hexRegex.test(value)) {
              return helpers.error("string.hex");
            }
            if (options3.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (internals.isDomainValid(value) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error: error40 }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error40("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length4 = encoding ? Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length4, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, {
              limit: args.limit,
              value,
              encoding
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: [
            "limit",
            "encoding"
          ]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: [
            "limit",
            "encoding"
          ]
        },
        normalize: {
          method(form = "NFC") {
            Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({
              name: "normalize",
              args: {
                form
              }
            });
          },
          validate(value, { error: error40 }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error40("string.normalize", {
              value,
              form
            });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options3 = {}) {
            Assert(regex instanceof RegExp, "regex must be a RegExp");
            Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options3 === "string") {
              options3 = {
                name: options3
              };
            }
            Common.assertOptions(options3, [
              "invert",
              "name"
            ]);
            const errorCode2 = [
              "string.pattern",
              options3.invert ? ".invert" : "",
              options3.name ? ".name" : ".base"
            ].join("");
            return this.$_addRule({
              name: "pattern",
              args: {
                regex,
                options: options3
              },
              errorCode: errorCode2
            });
          },
          validate(value, helpers, { regex, options: options3 }, { errorCode: errorCode2 }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options3.invert) {
              return value;
            }
            return helpers.error(errorCode2, {
              name: options3.name,
              regex,
              value
            });
          },
          args: [
            "regex",
            "options"
          ],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(EscapeRegex(pattern), "g");
            }
            Assert(pattern instanceof RegExp, "pattern must be a RegExp");
            Assert(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({
              pattern,
              replacement
            });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled3 = true) {
            Assert(typeof enabled3 === "boolean", "enabled must be a boolean");
            return this.$_addRule({
              name: "trim",
              args: {
                enabled: enabled3
              }
            });
          },
          validate(value, helpers, { enabled: enabled3 }) {
            if (!enabled3 || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled3 = true) {
            Assert(typeof enabled3 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled3);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:.} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:.} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:.} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:.} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      const date5 = new Date(value);
      if (isNaN(date5.getTime())) {
        return null;
      }
      return date5.toISOString();
    };
    internals.length = function(schema, name, limit, operator, encoding) {
      Assert(!encoding || Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema.$_addRule({
        name,
        method: "length",
        args: {
          limit,
          encoding
        },
        operator
      });
    };
    internals.rfc3986 = function() {
      const rfc39862 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc39862.ipv4 = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc39862.ipv4 + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc39862.v4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc39862.v6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc39862.ipv6 = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc39862.ipvfuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      return rfc39862;
    };
    internals.ipRegex = function() {
      const versions = [
        "ipv4",
        "ipv6",
        "ipvfuture"
      ];
      const rfc39862 = internals.rfc3986();
      const parts = versions.map((version4) => {
        const cidrpart = `\\/${version4 === "ipv4" ? rfc39862.v4Cidr : rfc39862.v6Cidr}`;
        return `${rfc39862[version4]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      return new RegExp(`^${raw}$`);
    }();
    internals.isDomainValid = function(domain2) {
      if (domain2.length > 256) {
        return false;
      }
      domain2 = domain2.normalize("NFC");
      if (internals.domainControlRx.test(domain2)) {
        return false;
      }
      domain2 = internals.punycode(domain2);
      const segments = domain2.split(".");
      for (let i2 = 0; i2 < segments.length; ++i2) {
        const segment = segments[i2];
        if (!segment.length) {
          return false;
        }
        if (segment.length > 63) {
          return false;
        }
        if (!internals.domainSegmentRx.test(segment)) {
          return false;
        }
        const isFinalSegment = i2 === segments.length - 1;
        if (isFinalSegment && !internals.finalSegmentAdditionalRx.test(segment)) {
          return false;
        }
      }
      return true;
    };
    internals.punycode = function(domain2) {
      try {
        return new Url2.URL(`http://${domain2}`).host;
      } catch (err) {
        return domain2;
      }
    };
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/symbol.js
var require_symbol = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/symbol.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module2.exports = Any._extend({
      type: "symbol",
      terms: {
        map: {
          init: new internals.Map()
        }
      },
      coerce: {
        method(value, { schema, error: error40 }) {
          const lookup = schema.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema._flags.only || typeof value === "symbol") {
            return {
              value
            };
          }
          return {
            value,
            errors: error40("symbol.map", {
              map: schema.$_terms.map
            })
          };
        }
      },
      validate(value, { error: error40 }) {
        if (typeof value !== "symbol") {
          return {
            value,
            errors: error40("symbol.base")
          };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols2 = [];
            for (const entry of iterable) {
              Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              Assert(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols2.push(value);
            }
            return obj.valid(...symbols2);
          }
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/binary.js
var require_binary = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/types/binary.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    module2.exports = Any._extend({
      type: "binary",
      coerce: {
        from: "string",
        method(value, { schema }) {
          try {
            return {
              value: Buffer.from(value, schema._flags.encoding)
            };
          } catch (ignoreErr) {
          }
        }
      },
      validate(value, { error: error40 }) {
        if (!Buffer.isBuffer(value)) {
          return {
            value,
            errors: error40("binary.base")
          };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({
              name: "length",
              method: "length",
              args: {
                limit
              },
              operator: "="
            });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "length",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "length",
              args: {
                limit
              },
              operator: ">="
            });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});

// node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/.deno/@hapi+validate@2.0.1/node_modules/@hapi/validate/lib/index.js"(exports2, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      types: {
        alternatives: require_alternatives(),
        any: require_any(),
        array: require_array(),
        boolean: require_boolean(),
        date: require_date(),
        function: require_function(),
        link: require_link(),
        number: require_number(),
        object: require_object(),
        string: require_string(),
        symbol: require_symbol()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          Assert(!args.length || [
            "alternatives",
            "link",
            "object"
          ].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of [
        "allow",
        "custom",
        "disallow",
        "equal",
        "exist",
        "forbidden",
        "invalid",
        "not",
        "only",
        "optional",
        "options",
        "prefs",
        "preferences",
        "required",
        "strip",
        "valid",
        "when"
      ]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      assert(value, schema, ...args) {
        internals.assert(value, schema, true, args);
      },
      attempt(value, schema, ...args) {
        return internals.assert(value, schema, false, args);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema, options3) {
        return Compile.compile(this, schema, options3);
      },
      isError: Errors.ValidationError.isError,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      }
    };
    internals.assert = function(value, schema, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options3 = message ? args[1] : args[0];
      const result = schema.validate(value, Common.preferences({
        errors: {
          stack: true
        }
      }, options3 || {}));
      let error40 = result.error;
      if (!error40) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error40.annotate === "function" ? error40.annotate() : error40.message;
      if (error40 instanceof Errors.ValidationError === false) {
        error40 = Clone(error40);
      }
      error40.message = message ? `${message} ${display}` : display;
      throw error40;
    };
    internals.generate = function(root, schema, args) {
      Assert(root, "Must be invoked on a Joi instance.");
      schema.$_root = root;
      if (!schema._definition.args || !args.length) {
        return schema;
      }
      return schema._definition.args(schema, ...args);
    };
    module2.exports = internals.root();
  }
});

// node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/symbols.js"(exports2) {
    "use strict";
    exports2.injection = Symbol("injection");
  }
});

// node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/request.js
var require_request = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/request.js"(exports2, module2) {
    "use strict";
    var Events2 = __require("node:events");
    var Stream = __require("node:stream");
    var Url2 = __require("node:url");
    var Symbols = require_symbols();
    var internals = {};
    exports2 = module2.exports = internals.Request = class extends Stream.Readable {
      constructor(options3) {
        super({
          emitClose: !!options3.simulate?.close,
          autoDestroy: true
          // This is the default in node 14+
        });
        let url2 = options3.url;
        if (typeof url2 === "object") {
          url2 = Url2.format(url2);
        }
        const uri = Url2.parse(url2);
        this.url = uri.path;
        this.httpVersion = "1.1";
        this.method = options3.method ? options3.method.toUpperCase() : "GET";
        this.headers = {};
        const headers = options3.headers ?? {};
        const fields = Object.keys(headers);
        fields.forEach((field) => {
          this.headers[field.toLowerCase()] = headers[field];
        });
        this.headers["user-agent"] = this.headers["user-agent"] ?? "shot";
        const hostHeaderFromUri = function() {
          if (uri.port) {
            return uri.host;
          }
          if (uri.protocol) {
            return uri.hostname + (uri.protocol === "https:" ? ":443" : ":80");
          }
          return null;
        };
        this.headers.host = this.headers.host ?? hostHeaderFromUri() ?? options3.authority ?? "localhost:80";
        this.socket = this.connection = new internals.MockSocket(options3);
        let payload = options3.payload ?? null;
        if (payload && typeof payload !== "string" && !(payload instanceof Stream) && !Buffer.isBuffer(payload)) {
          payload = JSON.stringify(payload);
          this.headers["content-type"] = this.headers["content-type"] || "application/json";
        }
        if (payload && !(payload instanceof Stream) && !this.headers.hasOwnProperty("content-length")) {
          this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
        }
        this._shot = {
          payload,
          isDone: false,
          simulate: options3.simulate ?? {}
        };
        return this;
      }
      prepare(next) {
        if (this._shot.payload instanceof Stream === false) {
          return next();
        }
        const chunks = [];
        this._shot.payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
        this._shot.payload.on("end", () => {
          const payload = Buffer.concat(chunks);
          this.headers["content-length"] = this.headers["content-length"] || payload.length;
          this._shot.payload = payload;
          return next();
        });
      }
      _read(size) {
        setImmediate(() => {
          if (this._shot.isDone) {
            if (this._shot.simulate.end !== false) {
              this.push(null);
            }
            return;
          }
          this._shot.isDone = true;
          if (this._shot.payload) {
            if (this._shot.simulate.split) {
              this.push(this._shot.payload.slice(0, 1));
              this.push(this._shot.payload.slice(1));
            } else {
              this.push(this._shot.payload);
            }
          }
          if (this._shot.simulate.error) {
            this.destroy(new Error("Simulated"));
          } else if (this._shot.simulate.end !== false) {
            this.push(null);
          } else if (this._shot.simulate.close) {
            this.emit("close");
          }
        });
      }
    };
    internals.Request.prototype[Symbols.injection] = true;
    internals.MockSocket = class MockSocket extends Events2.EventEmitter {
      constructor({ remoteAddress }) {
        super();
        this.remoteAddress = remoteAddress ?? "127.0.0.1";
      }
      // Net.Socket APIs used by hapi
      end() {
      }
      setTimeout() {
      }
    };
  }
});

// node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/response.js
var require_response = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/response.js"(exports2, module2) {
    "use strict";
    var Http = __require("node:http");
    var Stream = __require("node:stream");
    var Hoek = require_lib();
    var Symbols = require_symbols();
    var internals = {};
    exports2 = module2.exports = internals.Response = class extends Http.ServerResponse {
      constructor(req, onEnd) {
        super({
          method: req.method,
          httpVersionMajor: 1,
          httpVersionMinor: 1
        });
        this._shot = {
          headers: null,
          trailers: {},
          payloadChunks: []
        };
        this.assignSocket(internals.nullSocket());
        this.socket.on("error", Hoek.ignore);
        if (req._shot.simulate.close) {
          req.once("close", () => {
            process.nextTick(() => this.destroy());
          });
        }
        const finalize = (aborted2) => {
          const res = internals.payload(this);
          res.raw.req = req;
          if (aborted2) {
            res.aborted = aborted2;
            if (!this.headersSent) {
              res.statusCode = 499;
            }
          }
          this.removeListener("close", abort);
          process.nextTick(() => onEnd(res));
        };
        const abort = () => finalize(true);
        this.once("finish", finalize);
        this.on("close", abort);
      }
      writeHead(...args) {
        const headers = args[args.length - 1];
        if (typeof headers === "object" && headers !== null) {
          const headerNames = Object.keys(headers);
          for (let i2 = 0; i2 < headerNames.length; ++i2) {
            const name = headerNames[i2];
            try {
              this.setHeader(name, headers[name]);
              break;
            } catch (ignoreErr) {
            }
          }
        }
        const result = super.writeHead(...args);
        this._shot.headers = this.getHeaders();
        [
          "Date",
          "Connection",
          "Transfer-Encoding"
        ].forEach((name) => {
          const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
          const field = this._header.match(regex);
          if (field) {
            this._shot.headers[name.toLowerCase()] = field[1];
          }
        });
        return result;
      }
      write(data, encoding, callback) {
        super.write(data, encoding, callback);
        this._shot.payloadChunks.push(Buffer.from(data, encoding));
        return true;
      }
      end(data, encoding, callback) {
        if (data) {
          this.write(data, encoding);
        }
        super.end(callback);
        this.emit("finish");
      }
      addTrailers(trailers) {
        for (const key in trailers) {
          this._shot.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
        }
      }
    };
    internals.Response.prototype[Symbols.injection] = true;
    internals.payload = function(response) {
      const res = {
        raw: {
          res: response
        },
        headers: response._shot.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {}
      };
      const rawBuffer = Buffer.concat(response._shot.payloadChunks);
      res.rawPayload = rawBuffer;
      res.payload = rawBuffer.toString();
      res.trailers = response._shot.trailers;
      return res;
    };
    internals.nullSocket = function() {
      return new Stream.Writable({
        write(chunk, encoding, callback) {
          setImmediate(callback);
        }
      });
    };
  }
});

// node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/.deno/@hapi+shot@6.0.2/node_modules/@hapi/shot/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Validate = require_lib3();
    var Request2 = require_request();
    var Response2 = require_response();
    var Symbols = require_symbols();
    var internals = {};
    internals.options = Validate.object().keys({
      url: Validate.alternatives([
        Validate.string(),
        Validate.object().keys({
          protocol: Validate.string(),
          hostname: Validate.string(),
          port: Validate.any(),
          pathname: Validate.string().required(),
          query: Validate.any()
        })
      ]).required(),
      headers: Validate.object(),
      payload: Validate.any(),
      simulate: {
        end: Validate.boolean(),
        split: Validate.boolean(),
        error: Validate.boolean(),
        close: Validate.boolean()
      },
      authority: Validate.string(),
      remoteAddress: Validate.string(),
      method: Validate.string(),
      validate: Validate.boolean()
    });
    exports2.inject = async function(dispatchFunc, options3) {
      options3 = typeof options3 === "string" ? {
        url: options3
      } : options3;
      if (options3?.validate !== false) {
        Hoek.assert(typeof dispatchFunc === "function", "Invalid or missing dispatch function");
        Validate.assert(options3 ?? null, internals.options, "Invalid options:");
      }
      return new Promise((resolve7) => {
        const req = new Request2(options3);
        const res = new Response2(req, resolve7);
        req.prepare(() => dispatchFunc(req, res));
      });
    };
    exports2.isInjection = function(obj) {
      return !!obj[Symbols.injection];
    };
  }
});

// node_modules/.deno/@hapi+teamwork@6.0.1/node_modules/@hapi/teamwork/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/.deno/@hapi+teamwork@6.0.1/node_modules/@hapi/teamwork/lib/index.js"(exports2) {
    "use strict";
    var internals = {};
    exports2.Team = class {
      #meetings = null;
      #count = null;
      #notes = null;
      #done = false;
      #strict = false;
      constructor(options3) {
        this._init(options3);
      }
      static _notes(instance) {
        return instance.#notes;
      }
      _init(options3 = {}) {
        this.work = new Promise((resolve7, reject) => {
          this._resolve = resolve7;
          this._reject = reject;
        });
        const meetings = options3.meetings ?? 1;
        const strict = !!options3.strict;
        if (!Number.isInteger(meetings) || meetings <= 0) {
          if (meetings === 0 && !strict) {
            return this._finalize(null, null);
          }
          throw new Error("Invalid meetings value");
        }
        this.#meetings = meetings;
        this.#count = meetings;
        this.#notes = [];
        this.#done = false;
        this.#strict = strict;
      }
      _finalize(err, note) {
        this.#done = true;
        this.#notes = null;
        if (err) {
          this._reject(err);
        } else {
          this._resolve(note);
        }
      }
      attend(note) {
        if (this.#done) {
          if (this.#strict) {
            throw new Error("Unscheduled meeting");
          }
          return;
        }
        if (note instanceof Error) {
          return this._finalize(note);
        }
        this.#notes.push(note);
        if (--this.#count) {
          return;
        }
        this._finalize(null, this.#meetings === 1 ? this.#notes[0] : this.#notes);
      }
      async regroup(options3) {
        try {
          await this.work;
        } catch {
        }
        this._init(options3);
      }
    };
    exports2.Events = class {
      #iterators = /* @__PURE__ */ new Set();
      static _iterators(instance) {
        return instance.#iterators;
      }
      static isIterator(iterator) {
        return iterator instanceof internals.EventsIterator;
      }
      iterator() {
        const iterator = new internals.EventsIterator(this);
        this.#iterators.add(iterator);
        return iterator;
      }
      emit(value) {
        for (const iterator of this.#iterators) {
          iterator._queue({
            value,
            done: false
          });
        }
      }
      end() {
        for (const iterator of this.#iterators) {
          iterator._queue({
            done: true
          });
        }
      }
      _remove(iterator) {
        this.#iterators.delete(iterator);
      }
    };
    internals.EventsIterator = class {
      #events;
      #pending = null;
      #queue = [];
      constructor(events) {
        this.#events = events;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      next() {
        if (this.#queue.length) {
          return Promise.resolve(this.#queue.shift());
        }
        if (!this.#events) {
          return {
            done: true
          };
        }
        this.#pending = new exports2.Team();
        return this.#pending.work;
      }
      return() {
        this._cleanup();
        return {
          done: true
        };
      }
      _cleanup() {
        this.#events?._remove(this);
        this.#events = null;
      }
      _queue(item) {
        if (item.done) {
          this._cleanup();
        }
        if (this.#pending) {
          this.#pending.attend(item);
          this.#pending = null;
        } else {
          this.#queue.push(item);
        }
      }
    };
  }
});

// node_modules/.deno/@hapi+boom@10.0.1/node_modules/@hapi/boom/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/.deno/@hapi+boom@10.0.1/node_modules/@hapi/boom/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {
      codes: /* @__PURE__ */ new Map([
        [
          100,
          "Continue"
        ],
        [
          101,
          "Switching Protocols"
        ],
        [
          102,
          "Processing"
        ],
        [
          200,
          "OK"
        ],
        [
          201,
          "Created"
        ],
        [
          202,
          "Accepted"
        ],
        [
          203,
          "Non-Authoritative Information"
        ],
        [
          204,
          "No Content"
        ],
        [
          205,
          "Reset Content"
        ],
        [
          206,
          "Partial Content"
        ],
        [
          207,
          "Multi-Status"
        ],
        [
          300,
          "Multiple Choices"
        ],
        [
          301,
          "Moved Permanently"
        ],
        [
          302,
          "Moved Temporarily"
        ],
        [
          303,
          "See Other"
        ],
        [
          304,
          "Not Modified"
        ],
        [
          305,
          "Use Proxy"
        ],
        [
          307,
          "Temporary Redirect"
        ],
        [
          400,
          "Bad Request"
        ],
        [
          401,
          "Unauthorized"
        ],
        [
          402,
          "Payment Required"
        ],
        [
          403,
          "Forbidden"
        ],
        [
          404,
          "Not Found"
        ],
        [
          405,
          "Method Not Allowed"
        ],
        [
          406,
          "Not Acceptable"
        ],
        [
          407,
          "Proxy Authentication Required"
        ],
        [
          408,
          "Request Time-out"
        ],
        [
          409,
          "Conflict"
        ],
        [
          410,
          "Gone"
        ],
        [
          411,
          "Length Required"
        ],
        [
          412,
          "Precondition Failed"
        ],
        [
          413,
          "Request Entity Too Large"
        ],
        [
          414,
          "Request-URI Too Large"
        ],
        [
          415,
          "Unsupported Media Type"
        ],
        [
          416,
          "Requested Range Not Satisfiable"
        ],
        [
          417,
          "Expectation Failed"
        ],
        [
          418,
          "I'm a teapot"
        ],
        [
          422,
          "Unprocessable Entity"
        ],
        [
          423,
          "Locked"
        ],
        [
          424,
          "Failed Dependency"
        ],
        [
          425,
          "Too Early"
        ],
        [
          426,
          "Upgrade Required"
        ],
        [
          428,
          "Precondition Required"
        ],
        [
          429,
          "Too Many Requests"
        ],
        [
          431,
          "Request Header Fields Too Large"
        ],
        [
          451,
          "Unavailable For Legal Reasons"
        ],
        [
          500,
          "Internal Server Error"
        ],
        [
          501,
          "Not Implemented"
        ],
        [
          502,
          "Bad Gateway"
        ],
        [
          503,
          "Service Unavailable"
        ],
        [
          504,
          "Gateway Time-out"
        ],
        [
          505,
          "HTTP Version Not Supported"
        ],
        [
          506,
          "Variant Also Negotiates"
        ],
        [
          507,
          "Insufficient Storage"
        ],
        [
          509,
          "Bandwidth Limit Exceeded"
        ],
        [
          510,
          "Not Extended"
        ],
        [
          511,
          "Network Authentication Required"
        ]
      ])
    };
    exports2.Boom = class extends Error {
      constructor(messageOrError, options3 = {}) {
        if (messageOrError instanceof Error) {
          return exports2.boomify(Hoek.clone(messageOrError), options3);
        }
        const { statusCode = 500, data = null, ctor = exports2.Boom } = options3;
        const error40 = new Error(messageOrError ? messageOrError : void 0);
        Error.captureStackTrace(error40, ctor);
        error40.data = data;
        const boom = internals.initialize(error40, statusCode);
        Object.defineProperty(boom, "typeof", {
          value: ctor
        });
        if (options3.decorate) {
          Object.assign(boom, options3.decorate);
        }
        return boom;
      }
      static [Symbol.hasInstance](instance) {
        if (this === exports2.Boom) {
          return exports2.isBoom(instance);
        }
        return this.prototype.isPrototypeOf(instance);
      }
    };
    exports2.isBoom = function(err, statusCode) {
      return err instanceof Error && !!err.isBoom && (!statusCode || err.output.statusCode === statusCode);
    };
    exports2.boomify = function(err, options3) {
      Hoek.assert(err instanceof Error, "Cannot wrap non-Error object");
      options3 = options3 || {};
      if (options3.data !== void 0) {
        err.data = options3.data;
      }
      if (options3.decorate) {
        Object.assign(err, options3.decorate);
      }
      if (!err.isBoom) {
        return internals.initialize(err, options3.statusCode ?? 500, options3.message);
      }
      if (options3.override === false || // Defaults to true
      !options3.statusCode && !options3.message) {
        return err;
      }
      return internals.initialize(err, options3.statusCode ?? err.output.statusCode, options3.message);
    };
    exports2.badRequest = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 400,
        data,
        ctor: exports2.badRequest
      });
    };
    exports2.unauthorized = function(message, scheme, attributes) {
      const err = new exports2.Boom(message, {
        statusCode: 401,
        ctor: exports2.unauthorized
      });
      if (!scheme) {
        return err;
      }
      if (typeof scheme !== "string") {
        err.output.headers["WWW-Authenticate"] = scheme.join(", ");
        return err;
      }
      let wwwAuthenticate = `${scheme}`;
      if (attributes || message) {
        err.output.payload.attributes = {};
      }
      if (attributes) {
        if (typeof attributes === "string") {
          wwwAuthenticate += " " + Hoek.escapeHeaderAttribute(attributes);
          err.output.payload.attributes = attributes;
        } else {
          wwwAuthenticate += " " + Object.keys(attributes).map((name) => {
            const value = attributes[name] ?? "";
            err.output.payload.attributes[name] = value;
            return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
          }).join(", ");
        }
      }
      if (message) {
        if (attributes) {
          wwwAuthenticate += ",";
        }
        wwwAuthenticate += ` error="${Hoek.escapeHeaderAttribute(message)}"`;
        err.output.payload.attributes.error = message;
      } else {
        err.isMissing = true;
      }
      err.output.headers["WWW-Authenticate"] = wwwAuthenticate;
      return err;
    };
    exports2.paymentRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 402,
        data,
        ctor: exports2.paymentRequired
      });
    };
    exports2.forbidden = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 403,
        data,
        ctor: exports2.forbidden
      });
    };
    exports2.notFound = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 404,
        data,
        ctor: exports2.notFound
      });
    };
    exports2.methodNotAllowed = function(messageOrError, data, allow) {
      const err = new exports2.Boom(messageOrError, {
        statusCode: 405,
        data,
        ctor: exports2.methodNotAllowed
      });
      if (typeof allow === "string") {
        allow = [
          allow
        ];
      }
      if (Array.isArray(allow)) {
        err.output.headers.Allow = allow.join(", ");
      }
      return err;
    };
    exports2.notAcceptable = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 406,
        data,
        ctor: exports2.notAcceptable
      });
    };
    exports2.proxyAuthRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 407,
        data,
        ctor: exports2.proxyAuthRequired
      });
    };
    exports2.clientTimeout = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 408,
        data,
        ctor: exports2.clientTimeout
      });
    };
    exports2.conflict = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 409,
        data,
        ctor: exports2.conflict
      });
    };
    exports2.resourceGone = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 410,
        data,
        ctor: exports2.resourceGone
      });
    };
    exports2.lengthRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 411,
        data,
        ctor: exports2.lengthRequired
      });
    };
    exports2.preconditionFailed = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 412,
        data,
        ctor: exports2.preconditionFailed
      });
    };
    exports2.entityTooLarge = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 413,
        data,
        ctor: exports2.entityTooLarge
      });
    };
    exports2.uriTooLong = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 414,
        data,
        ctor: exports2.uriTooLong
      });
    };
    exports2.unsupportedMediaType = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 415,
        data,
        ctor: exports2.unsupportedMediaType
      });
    };
    exports2.rangeNotSatisfiable = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 416,
        data,
        ctor: exports2.rangeNotSatisfiable
      });
    };
    exports2.expectationFailed = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 417,
        data,
        ctor: exports2.expectationFailed
      });
    };
    exports2.teapot = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 418,
        data,
        ctor: exports2.teapot
      });
    };
    exports2.badData = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 422,
        data,
        ctor: exports2.badData
      });
    };
    exports2.locked = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 423,
        data,
        ctor: exports2.locked
      });
    };
    exports2.failedDependency = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 424,
        data,
        ctor: exports2.failedDependency
      });
    };
    exports2.tooEarly = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 425,
        data,
        ctor: exports2.tooEarly
      });
    };
    exports2.preconditionRequired = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 428,
        data,
        ctor: exports2.preconditionRequired
      });
    };
    exports2.tooManyRequests = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 429,
        data,
        ctor: exports2.tooManyRequests
      });
    };
    exports2.illegal = function(messageOrError, data) {
      return new exports2.Boom(messageOrError, {
        statusCode: 451,
        data,
        ctor: exports2.illegal
      });
    };
    exports2.internal = function(message, data, statusCode = 500) {
      return internals.serverError(message, data, statusCode, exports2.internal);
    };
    exports2.notImplemented = function(message, data) {
      return internals.serverError(message, data, 501, exports2.notImplemented);
    };
    exports2.badGateway = function(message, data) {
      return internals.serverError(message, data, 502, exports2.badGateway);
    };
    exports2.serverUnavailable = function(message, data) {
      return internals.serverError(message, data, 503, exports2.serverUnavailable);
    };
    exports2.gatewayTimeout = function(message, data) {
      return internals.serverError(message, data, 504, exports2.gatewayTimeout);
    };
    exports2.badImplementation = function(message, data) {
      const err = internals.serverError(message, data, 500, exports2.badImplementation);
      err.isDeveloperError = true;
      return err;
    };
    internals.initialize = function(err, statusCode, message) {
      const numberCode = parseInt(statusCode, 10);
      Hoek.assert(!isNaN(numberCode) && numberCode >= 400, "First argument must be a number (400+):", statusCode);
      err.isBoom = true;
      err.isServer = numberCode >= 500;
      if (!err.hasOwnProperty("data")) {
        err.data = null;
      }
      err.output = {
        statusCode: numberCode,
        payload: {},
        headers: {}
      };
      Object.defineProperty(err, "reformat", {
        value: internals.reformat,
        configurable: true
      });
      if (!message && !err.message) {
        err.reformat();
        message = err.output.payload.error;
      }
      if (message) {
        const props = Object.getOwnPropertyDescriptor(err, "message") || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), "message");
        Hoek.assert(!props || props.configurable && !props.get, "The error is not compatible with boom");
        err.message = message + (err.message ? ": " + err.message : "");
        err.output.payload.message = err.message;
      }
      err.reformat();
      return err;
    };
    internals.reformat = function(debug = false) {
      this.output.payload.statusCode = this.output.statusCode;
      this.output.payload.error = internals.codes.get(this.output.statusCode) || "Unknown";
      if (this.output.statusCode === 500 && debug !== true) {
        this.output.payload.message = "An internal server error occurred";
      } else if (this.message) {
        this.output.payload.message = this.message;
      }
    };
    internals.serverError = function(messageOrError, data, statusCode, ctor) {
      if (data instanceof Error && !data.isBoom) {
        return exports2.boomify(data, {
          statusCode,
          message: messageOrError
        });
      }
      return new exports2.Boom(messageOrError, {
        statusCode,
        data,
        ctor
      });
    };
  }
});

// node_modules/.deno/@hapi+bounce@3.0.2/node_modules/@hapi/bounce/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/.deno/@hapi+bounce@3.0.2/node_modules/@hapi/bounce/lib/index.js"(exports2) {
    "use strict";
    var Assert = __require("node:assert");
    var Boom = require_lib6();
    var Hoek = require_lib();
    var internals = {
      system: [
        // JavaScript
        EvalError,
        RangeError,
        ReferenceError,
        SyntaxError,
        TypeError,
        URIError,
        // Node
        Assert.AssertionError,
        // Hoek
        Hoek.AssertError
      ]
    };
    exports2.rethrow = function(err, types, options3 = {}) {
      return internals.catch(err, types, options3, true);
    };
    exports2.ignore = function(err, types, options3 = {}) {
      return internals.catch(err, types, options3, false);
    };
    internals.catch = function(err, types, options3, match) {
      if (internals.match(err, types) !== match) {
        return;
      }
      if (options3.override) {
        err = options3.override;
      }
      if (options3.decorate) {
        Object.assign(err, options3.decorate);
      }
      if (options3.return) {
        return err;
      }
      throw err;
    };
    exports2.background = async function(operation, action = "rethrow", types = "system", options3 = {}) {
      try {
        if (typeof operation === "function") {
          await operation();
        } else {
          await operation;
        }
      } catch (err) {
        return exports2[action](err, types, options3);
      }
    };
    exports2.isBoom = function(err) {
      return Boom.isBoom(err);
    };
    exports2.isError = function(err) {
      return err instanceof Error;
    };
    exports2.isSystem = function(err) {
      if (!err) {
        return false;
      }
      if (err.isBoom) {
        return false;
      }
      for (const system of internals.system) {
        if (err instanceof system) {
          return true;
        }
      }
      return false;
    };
    internals.rules = {
      system: exports2.isSystem,
      boom: exports2.isBoom
    };
    internals.match = function(err, types) {
      if (!types) {
        return true;
      }
      types = Array.isArray(types) ? types : [
        types
      ];
      for (const type of types) {
        if (typeof type === "string") {
          if (internals.rules[type](err)) {
            return true;
          }
        } else if (typeof type === "object") {
          if (Hoek.contain(err, type, {
            deep: true,
            part: true
          })) {
            return true;
          }
        } else if (err instanceof type) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/.deno/@hapi+somever@4.1.1/node_modules/@hapi/somever/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/.deno/@hapi+somever@4.1.1/node_modules/@hapi/somever/lib/index.js"(exports2) {
    "use strict";
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {
      maxLength: 256,
      wildcards: [
        "x",
        "X",
        "*"
      ],
      any: Symbol("any")
    };
    internals.versionRx = /^\s*[vV]?(\d+|[xX*])(?:\.(\d+|[xX*])(?:\.(\d+|[xX*])(?:\-?([^+]+))?(?:\+(.+))?)?)?\s*$/;
    internals.strict = {
      tokenRx: /^[-\dA-Za-z]+(?:\.[-\dA-Za-z]+)*$/,
      numberRx: /^((?:0)|(?:[1-9]\d*))$/
    };
    exports2.version = function(version4, options3) {
      return new internals.Version(version4, options3);
    };
    exports2.range = function(range) {
      return new internals.Range(range);
    };
    exports2.match = function(version4, range, options3) {
      try {
        return exports2.range(range).match(version4, options3);
      } catch (err) {
        Bounce.rethrow(err, "system");
        return false;
      }
    };
    exports2.compare = function(a, b, options3 = {}) {
      let aFirst = -1;
      let bFirst = 1;
      a = exports2.version(a, options3);
      b = exports2.version(b, options3);
      if (options3.range && !options3.includePrerelease && a.prerelease.length && (a.major !== b.major || a.minor !== b.minor || a.patch !== b.patch || !b.prerelease.length)) {
        aFirst = -2;
        bFirst = 2;
      }
      for (let i2 = 0; i2 < 3; ++i2) {
        const av = a.dots[i2];
        const bv = b.dots[i2];
        if (av === bv || av === internals.any || // Wildcard is equal to everything
        bv === internals.any) {
          continue;
        }
        return av - bv < 0 ? aFirst : bFirst;
      }
      if (!a.prerelease.length && !b.prerelease.length) {
        return 0;
      } else if (!b.prerelease.length) {
        return options3.includePrerelease && b.patch === internals.any ? 0 : aFirst;
      } else if (!a.prerelease.length) {
        return options3.includePrerelease && a.patch === internals.any ? 0 : bFirst;
      }
      for (let i2 = 0; ; ++i2) {
        const ai = a.prerelease[i2];
        const bi = b.prerelease[i2];
        if (ai === void 0 && bi === void 0) {
          return 0;
        }
        if (ai === bi) {
          continue;
        }
        if (ai === void 0) {
          return aFirst;
        }
        if (bi === void 0) {
          return bFirst;
        }
        const an = Number.isFinite(ai);
        const bn = Number.isFinite(bi);
        if (an !== bn) {
          return an ? aFirst : bFirst;
        }
        return ai < bi ? aFirst : bFirst;
      }
    };
    internals.Version = class {
      constructor(version4, options3 = {}) {
        Hoek.assert(version4, "Missing version argument");
        if (version4 instanceof internals.Version) {
          return version4;
        }
        if (typeof version4 === "object") {
          this._copy(version4);
        } else {
          this._parse(version4, options3);
        }
        this.format();
      }
      _copy(version4) {
        this.major = version4.major === void 0 ? internals.any : version4.major;
        this.minor = version4.minor === void 0 ? internals.any : version4.minor;
        this.patch = version4.patch === void 0 ? internals.any : version4.patch;
        this.prerelease = version4.prerelease ?? [];
        this.build = version4.build ?? [];
      }
      _parse(version4, options3) {
        Hoek.assert(typeof version4 === "string", "Version argument must be a string");
        Hoek.assert(version4.length <= internals.maxLength, "Version string too long");
        const match = version4.match(internals.versionRx);
        if (!match) {
          throw new Error(`Invalid version string format: ${version4}`);
        }
        this.major = internals.Version._number(match[1], "major", options3);
        this.minor = internals.Version._number(match[2] || "x", "minor", options3);
        this.patch = internals.Version._number(match[3] || "x", "patch", options3);
        this.prerelease = internals.Version._sub(match[4], "prerelease", options3);
        this.build = internals.Version._sub(match[5], "build", options3);
      }
      static _number(string4, source, options3) {
        if (internals.wildcards.includes(string4)) {
          return internals.any;
        }
        if (options3.strict) {
          Hoek.assert(string4.match(internals.strict.numberRx), "Value must be 0 or a number without a leading zero:", source);
        }
        const value = parseInt(string4, 10);
        Hoek.assert(value <= Number.MAX_SAFE_INTEGER, "Value must be positive and less than max safe integer:", source);
        return value;
      }
      static _sub(string4, source, options3) {
        if (!string4) {
          return [];
        }
        if (options3.strict) {
          Hoek.assert(string4.match(internals.strict.tokenRx), "Value can only contain dot-separated hyphens, digits, a-z or A-Z:", source);
        }
        const subs = [];
        const parts = string4.split(".");
        for (const part of parts) {
          if (!part) {
            throw new Error(`Invalid empty ${source} segment`);
          }
          subs.push(part.match(/^\d+$/) ? internals.Version._number(part, source, {
            strict: options3.strict
          }) : part);
        }
        return subs;
      }
      format() {
        this.version = `${internals.dot(this.major)}.${internals.dot(this.minor)}.${internals.dot(this.patch)}${internals.token(this.prerelease, "-")}${internals.token(this.build, "+")}`;
        this.dots = [
          this.major,
          this.minor,
          this.patch
        ];
        this.wildcard = this.major === internals.any && this.minor === internals.any && this.patch === internals.any && !this.prerelease.length;
      }
      toString() {
        return this.version;
      }
      compare(to, options3) {
        return internals.Version.compare(this, to, options3);
      }
      static compare(a, b, options3 = {}) {
        return exports2.compare(a, b, options3);
      }
    };
    internals.dot = (v2) => {
      return v2 === internals.any ? "x" : v2;
    };
    internals.token = (v2, prefix) => {
      if (!v2.length) {
        return "";
      }
      return `${prefix}${v2.join(".")}`;
    };
    internals.Range = class {
      constructor(range, options3) {
        this._settings = Object.assign({}, options3);
        this._anything = false;
        this._or = [];
        this._active = null;
        if (range !== void 0) {
          this.pattern(range);
        }
        this._another();
      }
      _another() {
        if (!this._active || this._active.rules.length) {
          this._active = {
            rules: []
          };
          this._or.push(this._active);
        }
        return this;
      }
      _rule(operator, version4) {
        version4 = exports2.version(version4, this._settings);
        const compare = internals.operator(operator);
        this._active.rules.push({
          compare,
          version: version4,
          operator
        });
        return this;
      }
      get or() {
        return this._another();
      }
      equal(version4) {
        return this._rule("=", version4);
      }
      above(version4) {
        return this._rule(">", version4);
      }
      below(version4) {
        return this._rule("<", version4);
      }
      between(from6, to) {
        this._rule(">=", from6);
        this._rule("<=", to);
        return this;
      }
      minor(version4) {
        version4 = exports2.version(version4, this._settings);
        if (version4.major === internals.any) {
          this._rule("=", version4);
          return this;
        }
        this._rule(">=", version4);
        if (version4.minor === internals.any) {
          this._rule("<", {
            major: version4.major + 1,
            minor: 0,
            patch: 0,
            prerelease: [
              0
            ]
          });
        } else {
          this._rule("<", {
            major: version4.major,
            minor: version4.minor + 1,
            patch: 0,
            prerelease: [
              0
            ]
          });
        }
        return this;
      }
      compatible(version4) {
        version4 = exports2.version(version4, this._settings);
        if (version4.major === internals.any) {
          this._rule("=", version4);
          return this;
        }
        this._rule(">=", version4);
        if (version4.major === 0 && version4.minor !== internals.any) {
          if (version4.minor === 0) {
            this._rule("<", {
              major: 0,
              minor: 0,
              patch: version4.patch + 1,
              prerelease: [
                0
              ]
            });
          } else {
            this._rule("<", {
              major: 0,
              minor: version4.minor + 1,
              patch: 0,
              prerelease: [
                0
              ]
            });
          }
        } else {
          this._rule("<", {
            major: version4.major + 1,
            minor: 0,
            patch: 0,
            prerelease: [
              0
            ]
          });
        }
        return this;
      }
      pattern(range) {
        try {
          this._pattern(range);
          return this;
        } catch (err) {
          throw new Error(`Invalid range: "${range}" because: ${err.message}`);
        }
      }
      _pattern(range) {
        if (range === "") {
          this._anything = true;
          return;
        }
        const normalized = internals.normalize(range);
        const ors = normalized.split(/\s*\|\|\s*/);
        for (const condition of ors) {
          if (!condition) {
            this._anything = true;
            return;
          }
          this._another();
          const ands = condition.split(/\s+/);
          for (const and of ands) {
            const hyphen = and.indexOf("@");
            if (hyphen !== -1) {
              const from6 = and.slice(0, hyphen);
              const to = and.slice(hyphen + 1);
              this.between(from6, to);
              continue;
            }
            const parts = and.match(/^(\^|~|<\=|>\=|<|>|\=)?(.+)$/);
            const operator = parts[1];
            const version4 = exports2.version(parts[2], this._settings);
            if (version4.wildcard) {
              this._anything = true;
              return;
            }
            if (operator === "~") {
              this.minor(version4);
              continue;
            }
            if (operator === "^") {
              this.compatible(version4);
              continue;
            }
            if (operator) {
              this._rule(operator, version4);
              continue;
            }
            this.equal(version4);
          }
        }
      }
      match(version4, options3 = {}) {
        version4 = exports2.version(version4, this._settings);
        if (this._anything) {
          return !!options3.includePrerelease || !version4.prerelease.length;
        }
        for (const { rules } of this._or) {
          if (!rules.length) {
            continue;
          }
          let matches = 0;
          let excludes = 0;
          for (const rule of rules) {
            const compare = version4.compare(rule.version, Object.assign(this._settings, options3, {
              range: true
            }));
            const exclude = Math.abs(compare) === 2;
            if (rule.compare.includes(compare / (exclude ? 2 : 1))) {
              ++matches;
              if (exclude) {
                ++excludes;
              }
            } else {
              break;
            }
          }
          if (matches === rules.length && excludes < matches) {
            return true;
          }
        }
        return false;
      }
      toString() {
        if (this._anything) {
          return "*";
        }
        let string4 = "";
        for (const { rules } of this._or) {
          if (!rules.length) {
            continue;
          }
          const conditions = [];
          for (const rule of rules) {
            conditions.push(`${rule.operator !== "=" ? rule.operator : ""}${rule.version.version}`);
          }
          string4 += (string4 ? "||" : "") + conditions.join(" ");
        }
        return string4;
      }
    };
    internals.operator = function(compare) {
      switch (compare) {
        case "=":
          return [
            0
          ];
        case ">":
          return [
            1
          ];
        case ">=":
          return [
            0,
            1
          ];
        case "<":
          return [
            -1
          ];
        case "<=":
          return [
            0,
            -1
          ];
      }
    };
    internals.normalize = function(range) {
      return range.replace(/ \- /g, "@").replace(/~>/g, "~").replace(/(\^|~|<\=|>\=|<|>|\=)\s*([^\s]+)/g, ($0, $1, $2) => `${$1}${$2}`);
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/config.js
var require_config = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/config.js"(exports2) {
    "use strict";
    var Os = __require("node:os");
    var Somever = require_lib8();
    var Validate = require_lib3();
    var internals = {};
    exports2.symbol = Symbol("hapi-response");
    exports2.apply = function(type, options3, ...message) {
      const result = internals[type].validate(options3);
      if (result.error) {
        throw new Error(`Invalid ${type} options ${message.length ? "(" + message.join(" ") + ")" : ""} ${result.error.annotate()}`);
      }
      return result.value;
    };
    exports2.enable = function(options3) {
      const settings = options3 ? Object.assign({}, options3) : {};
      if (settings.security === true) {
        settings.security = {};
      }
      if (settings.cors === true) {
        settings.cors = {};
      }
      return settings;
    };
    exports2.versionMatch = (version4, range) => Somever.match(version4, range, {
      includePrerelease: true
    });
    internals.access = Validate.object({
      entity: Validate.valid("user", "app", "any"),
      scope: [
        false,
        Validate.array().items(Validate.string()).single().min(1)
      ]
    });
    internals.auth = Validate.alternatives([
      Validate.string(),
      internals.access.keys({
        mode: Validate.valid("required", "optional", "try"),
        strategy: Validate.string(),
        strategies: Validate.array().items(Validate.string()).min(1),
        access: Validate.array().items(internals.access.min(1)).single().min(1),
        payload: [
          Validate.valid("required", "optional"),
          Validate.boolean()
        ]
      }).without("strategy", "strategies").without("access", [
        "scope",
        "entity"
      ])
    ]);
    internals.event = Validate.object({
      method: Validate.array().items(Validate.function()).single(),
      options: Validate.object({
        before: Validate.array().items(Validate.string()).single(),
        after: Validate.array().items(Validate.string()).single(),
        bind: Validate.any(),
        sandbox: Validate.valid("server", "plugin"),
        timeout: Validate.number().integer().min(1)
      }).default({})
    });
    internals.exts = Validate.array().items(internals.event.keys({
      type: Validate.string().required()
    })).single();
    internals.failAction = Validate.alternatives([
      Validate.valid("error", "log", "ignore"),
      Validate.function()
    ]).default("error");
    internals.routeBase = Validate.object({
      app: Validate.object().allow(null),
      auth: internals.auth.allow(false),
      bind: Validate.object().allow(null),
      cache: Validate.object({
        expiresIn: Validate.number(),
        expiresAt: Validate.string(),
        privacy: Validate.valid("default", "public", "private"),
        statuses: Validate.array().items(Validate.number().integer().min(200)).min(1).single().default([
          200,
          204
        ]),
        otherwise: Validate.string().default("no-cache")
      }).allow(false).default(),
      compression: Validate.object().pattern(/.+/, Validate.object()).default(),
      cors: Validate.object({
        origin: Validate.array().min(1).allow("ignore").default([
          "*"
        ]),
        maxAge: Validate.number().default(86400),
        headers: Validate.array().items(Validate.string()).default([
          "Accept",
          "Authorization",
          "Content-Type",
          "If-None-Match"
        ]),
        additionalHeaders: Validate.array().items(Validate.string()).default([]),
        exposedHeaders: Validate.array().items(Validate.string()).default([
          "WWW-Authenticate",
          "Server-Authorization"
        ]),
        additionalExposedHeaders: Validate.array().items(Validate.string()).default([]),
        credentials: Validate.boolean().when("origin", {
          is: "ignore",
          then: false
        }).default(false),
        preflightStatusCode: Validate.valid(200, 204).default(200)
      }).allow(false, true).default(false),
      ext: Validate.object({
        onPreAuth: Validate.array().items(internals.event).single(),
        onCredentials: Validate.array().items(internals.event).single(),
        onPostAuth: Validate.array().items(internals.event).single(),
        onPreHandler: Validate.array().items(internals.event).single(),
        onPostHandler: Validate.array().items(internals.event).single(),
        onPreResponse: Validate.array().items(internals.event).single(),
        onPostResponse: Validate.array().items(internals.event).single()
      }).default({}),
      files: Validate.object({
        relativeTo: Validate.string().pattern(/^([\/\.])|([A-Za-z]:\\)|(\\\\)/).default(".")
      }).default(),
      json: Validate.object({
        replacer: Validate.alternatives(Validate.function(), Validate.array()).allow(null).default(null),
        space: Validate.number().allow(null).default(null),
        suffix: Validate.string().allow(null).default(null),
        escape: Validate.boolean().default(false)
      }).default(),
      log: Validate.object({
        collect: Validate.boolean().default(false)
      }).default(),
      payload: Validate.object({
        output: Validate.valid("data", "stream", "file").default("data"),
        parse: Validate.boolean().allow("gunzip").default(true),
        multipart: Validate.object({
          output: Validate.valid("data", "stream", "file", "annotated").required()
        }).default(false).allow(true, false),
        allow: Validate.array().items(Validate.string()).single(),
        override: Validate.string(),
        protoAction: Validate.valid("error", "remove", "ignore").default("error"),
        maxBytes: Validate.number().integer().positive().default(1024 * 1024),
        maxParts: Validate.number().integer().positive().default(1e3),
        uploads: Validate.string().default(Os.tmpdir()),
        failAction: internals.failAction,
        timeout: Validate.number().integer().positive().allow(false).default(10 * 1e3),
        defaultContentType: Validate.string().default("application/json"),
        compression: Validate.object().pattern(/.+/, Validate.object()).default()
      }).default(),
      plugins: Validate.object(),
      response: Validate.object({
        disconnectStatusCode: Validate.number().integer().min(400).default(499),
        emptyStatusCode: Validate.valid(200, 204).default(204),
        failAction: internals.failAction,
        modify: Validate.boolean(),
        options: Validate.object(),
        ranges: Validate.boolean().default(true),
        sample: Validate.number().min(0).max(100).when("modify", {
          then: Validate.forbidden()
        }),
        schema: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false),
        status: Validate.object().pattern(/\d\d\d/, Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false))
      }).default(),
      security: Validate.object({
        hsts: Validate.alternatives([
          Validate.object({
            maxAge: Validate.number(),
            includeSubdomains: Validate.boolean(),
            includeSubDomains: Validate.boolean(),
            preload: Validate.boolean()
          }),
          Validate.boolean(),
          Validate.number()
        ]).default(15768e3),
        xframe: Validate.alternatives([
          Validate.boolean(),
          Validate.valid("sameorigin", "deny"),
          Validate.object({
            rule: Validate.valid("sameorigin", "deny", "allow-from"),
            source: Validate.string()
          })
        ]).default("deny"),
        xss: Validate.valid("enabled", "disabled", false).default("disabled"),
        noOpen: Validate.boolean().default(true),
        noSniff: Validate.boolean().default(true),
        referrer: Validate.alternatives([
          Validate.boolean().valid(false),
          Validate.valid("", "no-referrer", "no-referrer-when-downgrade", "unsafe-url", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin")
        ]).default(false)
      }).allow(null, false, true).default(false),
      state: Validate.object({
        parse: Validate.boolean().default(true),
        failAction: internals.failAction
      }).default(),
      timeout: Validate.object({
        socket: Validate.number().integer().positive().allow(false),
        server: Validate.number().integer().positive().allow(false).default(false)
      }).default(),
      validate: Validate.object({
        headers: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
        params: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
        query: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        payload: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        state: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        failAction: internals.failAction,
        errorFields: Validate.object(),
        options: Validate.object().default(),
        validator: Validate.object()
      }).default()
    });
    internals.server = Validate.object({
      address: Validate.string().hostname(),
      app: Validate.object().allow(null),
      autoListen: Validate.boolean(),
      cache: Validate.allow(null),
      compression: Validate.object({
        minBytes: Validate.number().min(1).integer().default(1024)
      }).allow(false).default(),
      debug: Validate.object({
        request: Validate.array().items(Validate.string()).single().allow(false).default([
          "implementation"
        ]),
        log: Validate.array().items(Validate.string()).single().allow(false)
      }).allow(false).default(),
      host: Validate.string().hostname().allow(null),
      info: Validate.object({
        remote: Validate.boolean().default(false)
      }).default({}),
      listener: Validate.any(),
      load: Validate.object({
        sampleInterval: Validate.number().integer().min(0).default(0)
      }).unknown().default(),
      mime: Validate.object().empty(null).default(),
      operations: Validate.object({
        cleanStop: Validate.boolean().default(true)
      }).default(),
      plugins: Validate.object(),
      port: Validate.alternatives([
        Validate.number().integer().min(0),
        Validate.string().pattern(/\//),
        Validate.string().pattern(/^\\\\\.\\pipe\\/)
        // Windows named pipe
      ]).allow(null),
      query: Validate.object({
        parser: Validate.function()
      }).default(),
      router: Validate.object({
        isCaseSensitive: Validate.boolean().default(true),
        stripTrailingSlash: Validate.boolean().default(false)
      }).default(),
      routes: internals.routeBase.default(),
      state: Validate.object(),
      tls: Validate.alternatives([
        Validate.object().allow(null),
        Validate.boolean()
      ]),
      uri: Validate.string().pattern(/[^/]$/)
    });
    internals.vhost = Validate.alternatives([
      Validate.string().hostname(),
      Validate.array().items(Validate.string().hostname()).min(1)
    ]);
    internals.handler = Validate.alternatives([
      Validate.function(),
      Validate.object().length(1)
    ]);
    internals.route = Validate.object({
      method: Validate.string().pattern(/^[a-zA-Z0-9!#\$%&'\*\+\-\.^_`\|~]+$/).required(),
      path: Validate.string().required(),
      rules: Validate.object(),
      vhost: internals.vhost,
      // Validated in route construction
      handler: Validate.any(),
      options: Validate.any(),
      config: Validate.any()
      // Backwards compatibility
    }).without("config", "options");
    internals.pre = [
      Validate.function(),
      Validate.object({
        method: Validate.alternatives(Validate.string(), Validate.function()).required(),
        assign: Validate.string(),
        mode: Validate.valid("serial", "parallel"),
        failAction: internals.failAction
      })
    ];
    internals.routeConfig = internals.routeBase.keys({
      description: Validate.string(),
      id: Validate.string(),
      isInternal: Validate.boolean(),
      notes: [
        Validate.string(),
        Validate.array().items(Validate.string())
      ],
      pre: Validate.array().items(...internals.pre.concat(Validate.array().items(...internals.pre).min(1))),
      tags: [
        Validate.string(),
        Validate.array().items(Validate.string())
      ]
    });
    internals.cacheConfig = Validate.alternatives([
      Validate.function(),
      Validate.object({
        name: Validate.string().invalid("_default"),
        shared: Validate.boolean(),
        provider: [
          Validate.function(),
          {
            constructor: Validate.function().required(),
            options: Validate.object({
              partition: Validate.string().default("hapi-cache")
            }).unknown().default({})
          }
        ],
        engine: Validate.object()
      }).xor("provider", "engine")
    ]);
    internals.cache = Validate.array().items(internals.cacheConfig).min(1).single();
    internals.cachePolicy = Validate.object({
      cache: Validate.string().allow(null).allow(""),
      segment: Validate.string(),
      shared: Validate.boolean()
    }).unknown();
    internals.method = Validate.object({
      bind: Validate.object().allow(null),
      generateKey: Validate.function(),
      cache: internals.cachePolicy
    });
    internals.methodObject = Validate.object({
      name: Validate.string().required(),
      method: Validate.function().required(),
      options: Validate.object()
    });
    internals.register = Validate.object({
      once: true,
      routes: Validate.object({
        prefix: Validate.string().pattern(/^\/.+/),
        vhost: internals.vhost
      }).default({})
    });
    internals.semver = Validate.string();
    internals.plugin = internals.register.keys({
      options: Validate.any(),
      plugin: Validate.object({
        register: Validate.function().required(),
        name: Validate.string().when("pkg.name", {
          is: Validate.exist(),
          otherwise: Validate.required()
        }),
        version: Validate.string(),
        multiple: Validate.boolean().default(false),
        dependencies: [
          Validate.array().items(Validate.string()).single(),
          Validate.object().pattern(/.+/, internals.semver)
        ],
        once: true,
        requirements: Validate.object({
          hapi: Validate.string(),
          node: Validate.string()
        }).default(),
        pkg: Validate.object({
          name: Validate.string(),
          version: Validate.string().default("0.0.0")
        }).unknown().default({})
      }).unknown()
    }).without("once", "options").unknown();
    internals.rules = Validate.object({
      validate: Validate.object({
        schema: Validate.alternatives(Validate.object(), Validate.array()).required(),
        options: Validate.object().default({
          allowUnknown: true
        })
      })
    });
  }
});

// node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/decode.js
var require_decode = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/decode.js"(exports2) {
    "use strict";
    var internals = {};
    exports2.decode = function(string4) {
      let percentPos = string4.indexOf("%");
      if (percentPos === -1) {
        return string4;
      }
      let decoded = "";
      let last = 0;
      let codepoint = 0;
      let startOfOctets = percentPos;
      let state = internals.utf8.accept;
      while (percentPos > -1 && percentPos < string4.length) {
        const high = internals.resolveHex(string4[percentPos + 1], 4);
        const low = internals.resolveHex(string4[percentPos + 2], 0);
        const byte = high | low;
        const type = internals.utf8.data[byte];
        state = internals.utf8.data[256 + state + type];
        codepoint = codepoint << 6 | byte & internals.utf8.data[364 + type];
        if (state === internals.utf8.accept) {
          decoded += string4.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
          codepoint = 0;
          last = percentPos + 3;
          percentPos = string4.indexOf("%", last);
          startOfOctets = percentPos;
          continue;
        }
        if (state === internals.utf8.reject) {
          return null;
        }
        percentPos += 3;
        if (percentPos >= string4.length || string4[percentPos] !== "%") {
          return null;
        }
      }
      return decoded + string4.slice(last);
    };
    internals.resolveHex = function(char, shift) {
      const i2 = internals.hex[char];
      return i2 === void 0 ? 255 : i2 << shift;
    };
    internals.hex = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    internals.utf8 = {
      accept: 12,
      reject: 0,
      data: [
        // Maps bytes to character to a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // Maps a state to a new state when adding a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // Maps the current transition to a mask that needs to apply to the byte
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ]
    };
  }
});

// node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/regex.js
var require_regex = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/regex.js"(exports2) {
    "use strict";
    exports2.generate = function() {
      const empty4 = "(?:^\\/$)";
      const legalChars = "[\\w\\!\\$&'\\(\\)\\*\\+\\,;\\=\\:@\\-\\.~]";
      const encoded = "%[A-F0-9]{2}";
      const literalChar = "(?:" + legalChars + "|" + encoded + ")";
      const literal2 = literalChar + "+";
      const literalOptional = literalChar + "*";
      const midParam = "(?:\\{\\w+(?:\\*[1-9]\\d*)?\\})";
      const endParam = "(?:\\/(?:\\{\\w+(?:(?:\\*(?:[1-9]\\d*)?)|(?:\\?))?\\})?)?";
      const partialParam = "(?:\\{\\w+\\??\\})";
      const mixedParam = "(?:(?:" + literal2 + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + "(?:" + literal2 + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + literal2 + ")";
      const segmentContent = "(?:" + literal2 + "|" + midParam + "|" + mixedParam + ")";
      const segment = "\\/" + segmentContent;
      const segments = "(?:" + segment + ")*";
      const path = "(?:^" + segments + endParam + "$)";
      const parseParam = "(" + literal2 + ")|(?:\\{(\\w+)(?:(\\*)(\\d+)?)?(\\?)?\\})";
      const expressions = {
        parseParam: new RegExp(parseParam, "g"),
        validatePath: new RegExp(empty4 + "|" + path),
        validatePathEncoded: /%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g
      };
      return expressions;
    };
  }
});

// node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/segment.js
var require_segment = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/segment.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {};
    exports2 = module2.exports = internals.Segment = function() {
      this._edge = null;
      this._fulls = null;
      this._literals = null;
      this._param = null;
      this._mixed = null;
      this._wildcard = null;
    };
    internals.Segment.prototype.add = function(segments, record2) {
      const current = segments[0];
      const remaining = segments.slice(1);
      const isEdge = !remaining.length;
      const literals = [];
      let isLiteral = true;
      for (let i2 = 0; i2 < segments.length && isLiteral; ++i2) {
        isLiteral = segments[i2].literal !== void 0;
        literals.push(segments[i2].literal);
      }
      if (isLiteral) {
        this._fulls = this._fulls ?? /* @__PURE__ */ new Map();
        let literal2 = "/" + literals.join("/");
        if (!record2.settings.isCaseSensitive) {
          literal2 = literal2.toLowerCase();
        }
        Hoek.assert(!this._fulls.has(literal2), "New route", record2.path, "conflicts with existing", this._fulls.get(literal2)?.record.path);
        this._fulls.set(literal2, {
          segment: current,
          record: record2
        });
      } else if (current.literal !== void 0) {
        this._literals = this._literals ?? /* @__PURE__ */ new Map();
        const currentLiteral = record2.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase();
        if (!this._literals.has(currentLiteral)) {
          this._literals.set(currentLiteral, new internals.Segment());
        }
        this._literals.get(currentLiteral).add(remaining, record2);
      } else if (current.wildcard) {
        Hoek.assert(!this._wildcard, "New route", record2.path, "conflicts with existing", this._wildcard?.record.path);
        Hoek.assert(!this._param || !this._param._wildcard, "New route", record2.path, "conflicts with existing", this._param?._wildcard?.record.path);
        this._wildcard = {
          segment: current,
          record: record2
        };
      } else if (current.mixed) {
        this._mixed = this._mixed ?? [];
        let mixed = this._mixedLookup(current);
        if (!mixed) {
          mixed = {
            segment: current,
            node: new internals.Segment()
          };
          this._mixed.push(mixed);
          this._mixed.sort(internals.mixed);
        }
        if (isEdge) {
          Hoek.assert(!mixed.node._edge, "New route", record2.path, "conflicts with existing", mixed.node._edge?.record.path);
          mixed.node._edge = {
            segment: current,
            record: record2
          };
        } else {
          mixed.node.add(remaining, record2);
        }
      } else {
        this._param = this._param ?? new internals.Segment();
        if (isEdge) {
          Hoek.assert(!this._param._edge, "New route", record2.path, "conflicts with existing", this._param._edge?.record.path);
          this._param._edge = {
            segment: current,
            record: record2
          };
        } else {
          Hoek.assert(!this._wildcard || !remaining[0].wildcard, "New route", record2.path, "conflicts with existing", this._wildcard?.record.path);
          this._param.add(remaining, record2);
        }
      }
    };
    internals.Segment.prototype._mixedLookup = function(segment) {
      for (let i2 = 0; i2 < this._mixed.length; ++i2) {
        if (internals.mixed({
          segment
        }, this._mixed[i2]) === 0) {
          return this._mixed[i2];
        }
      }
      return null;
    };
    internals.mixed = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      const as = a.segment;
      const bs = b.segment;
      if (as.length !== bs.length) {
        return as.length > bs.length ? aFirst : bFirst;
      }
      if (as.first !== bs.first) {
        return as.first ? bFirst : aFirst;
      }
      for (let i2 = 0; i2 < as.segments.length; ++i2) {
        const am = as.segments[i2];
        const bm = bs.segments[i2];
        if (am === bm) {
          continue;
        }
        if (am.length === bm.length) {
          return am > bm ? bFirst : aFirst;
        }
        return am.length < bm.length ? bFirst : aFirst;
      }
      return 0;
    };
    internals.Segment.prototype.lookup = function(path, segments, options3) {
      let match = null;
      if (this._fulls) {
        match = this._fulls.get(options3.isCaseSensitive ? path : path.toLowerCase());
        if (match) {
          return {
            record: match.record,
            array: []
          };
        }
      }
      const current = segments[0];
      const nextPath = path.slice(current.length + 1);
      const remainder = segments.length > 1 ? segments.slice(1) : null;
      if (this._literals) {
        const literal2 = options3.isCaseSensitive ? current : current.toLowerCase();
        match = this._literals.get(literal2);
        if (match) {
          const record2 = internals.deeper(match, nextPath, remainder, [], options3);
          if (record2) {
            return record2;
          }
        }
      }
      if (this._mixed) {
        for (let i2 = 0; i2 < this._mixed.length; ++i2) {
          match = this._mixed[i2];
          const params = current.match(match.segment.mixed);
          if (params) {
            const array2 = [];
            for (let j = 1; j < params.length; ++j) {
              array2.push(params[j]);
            }
            const record2 = internals.deeper(match.node, nextPath, remainder, array2, options3);
            if (record2) {
              return record2;
            }
          }
        }
      }
      if (this._param) {
        if (current || this._param._edge?.segment.empty) {
          const record2 = internals.deeper(this._param, nextPath, remainder, [
            current
          ], options3);
          if (record2) {
            return record2;
          }
        }
      }
      if (this._wildcard) {
        return {
          record: this._wildcard.record,
          array: [
            path.slice(1)
          ]
        };
      }
      return null;
    };
    internals.deeper = function(match, path, segments, array2, options3) {
      if (!segments) {
        if (match._edge) {
          return {
            record: match._edge.record,
            array: array2
          };
        }
        if (match._wildcard) {
          return {
            record: match._wildcard.record,
            array: array2
          };
        }
      } else {
        const result = match.lookup(path, segments, options3);
        if (result) {
          return {
            record: result.record,
            array: array2.concat(result.array)
          };
        }
      }
      return null;
    };
  }
});

// node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/.deno/@hapi+call@9.0.1/node_modules/@hapi/call/lib/index.js"(exports2) {
    "use strict";
    var Boom = require_lib6();
    var Hoek = require_lib();
    var Decode = require_decode();
    var Regex = require_regex();
    var Segment = require_segment();
    var internals = {
      pathRegex: Regex.generate(),
      defaults: {
        isCaseSensitive: true
      }
    };
    exports2.Router = internals.Router = function(options3) {
      this.settings = Hoek.applyToDefaults(internals.defaults, options3 || {});
      this.routes = /* @__PURE__ */ new Map();
      this.ids = /* @__PURE__ */ new Map();
      this.vhosts = null;
      this.specials = {
        badRequest: null,
        notFound: null,
        options: null
      };
    };
    internals.Router.prototype.add = function(config2, route) {
      const method = config2.method.toLowerCase();
      const vhost = config2.vhost || "*";
      if (vhost !== "*") {
        this.vhosts = this.vhosts ?? /* @__PURE__ */ new Map();
        if (!this.vhosts.has(vhost)) {
          this.vhosts.set(vhost, /* @__PURE__ */ new Map());
        }
      }
      const table = vhost === "*" ? this.routes : this.vhosts.get(vhost);
      if (!table.has(method)) {
        table.set(method, {
          routes: [],
          router: new Segment()
        });
      }
      const analysis = config2.analysis ?? this.analyze(config2.path);
      const record2 = {
        path: config2.path,
        route: route || config2.path,
        segments: analysis.segments,
        params: analysis.params,
        fingerprint: analysis.fingerprint,
        settings: this.settings
      };
      const map2 = table.get(method);
      map2.router.add(analysis.segments, record2);
      map2.routes.push(record2);
      map2.routes.sort(internals.sort);
      const last = record2.segments[record2.segments.length - 1];
      if (last.empty) {
        map2.router.add(analysis.segments.slice(0, -1), record2);
      }
      if (config2.id) {
        Hoek.assert(!this.ids.has(config2.id), "Route id", config2.id, "for path", config2.path, "conflicts with existing path", this.ids.has(config2.id) && this.ids.get(config2.id).path);
        this.ids.set(config2.id, record2);
      }
      return record2;
    };
    internals.Router.prototype.special = function(type, route) {
      Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, "Unknown special route type:", type);
      this.specials[type] = {
        route
      };
    };
    internals.Router.prototype.route = function(method, path, hostname2) {
      const segments = path.length === 1 ? [
        ""
      ] : path.split("/").slice(1);
      const vhost = this.vhosts && hostname2 && this.vhosts.get(hostname2);
      const route = vhost && this._lookup(path, segments, vhost, method) || this._lookup(path, segments, this.routes, method) || method === "head" && vhost && this._lookup(path, segments, vhost, "get") || method === "head" && this._lookup(path, segments, this.routes, "get") || method === "options" && this.specials.options || vhost && this._lookup(path, segments, vhost, "*") || this._lookup(path, segments, this.routes, "*") || this.specials.notFound || Boom.notFound();
      return route;
    };
    internals.Router.prototype._lookup = function(path, segments, table, method) {
      const set2 = table.get(method);
      if (!set2) {
        return null;
      }
      const match = set2.router.lookup(path, segments, this.settings);
      if (!match) {
        return null;
      }
      const assignments = {};
      const array2 = [];
      for (let i2 = 0; i2 < match.array.length; ++i2) {
        const name = match.record.params[i2];
        const value = Decode.decode(match.array[i2]);
        if (value === null) {
          return this.specials.badRequest ?? Boom.badRequest("Invalid request path");
        }
        if (assignments[name] !== void 0) {
          assignments[name] = assignments[name] + "/" + value;
        } else {
          assignments[name] = value;
        }
        if (i2 + 1 === match.array.length || // Only include the last segment of a multi-segment param
        name !== match.record.params[i2 + 1]) {
          array2.push(assignments[name]);
        }
      }
      return {
        params: assignments,
        paramsArray: array2,
        route: match.record.route
      };
    };
    internals.Router.prototype.normalize = function(path) {
      if (path && path.indexOf("%") !== -1) {
        const uppercase2 = path.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, (encoded) => encoded.toUpperCase());
        const decoded = uppercase2.replace(/%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g, (encoded) => String.fromCharCode(parseInt(encoded.substring(1), 16)));
        path = decoded;
      }
      if (path && (path.indexOf("/.") !== -1 || path[0] === ".")) {
        const hasLeadingSlash = path[0] === "/";
        const segments = path.split("/");
        const normalized = [];
        let segment;
        for (let i2 = 0; i2 < segments.length; ++i2) {
          segment = segments[i2];
          if (segment === "..") {
            normalized.pop();
          } else if (segment !== ".") {
            normalized.push(segment);
          }
        }
        if (segment === "." || segment === "..") {
          normalized.push("");
        }
        path = normalized.join("/");
        if (path[0] !== "/" && hasLeadingSlash) {
          path = "/" + path;
        }
      }
      return path;
    };
    internals.Router.prototype.analyze = function(path) {
      Hoek.assert(internals.pathRegex.validatePath.test(path), "Invalid path:", path);
      Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path), "Path cannot contain encoded non-reserved path characters:", path);
      const pathParts = path.split("/");
      const segments = [];
      const params = [];
      const fingers = [];
      for (let i2 = 1; i2 < pathParts.length; ++i2) {
        let segment = pathParts[i2];
        if (segment.indexOf("{") === -1) {
          segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();
          fingers.push(segment);
          segments.push({
            literal: segment
          });
          continue;
        }
        const parts = internals.parseParams(segment);
        if (parts.length === 1) {
          const item = parts[0];
          Hoek.assert(params.indexOf(item.name) === -1, "Cannot repeat the same parameter name:", item.name, "in:", path);
          params.push(item.name);
          if (item.wildcard) {
            if (item.count) {
              for (let j = 0; j < item.count; ++j) {
                fingers.push("?");
                segments.push({});
                if (j) {
                  params.push(item.name);
                }
              }
            } else {
              fingers.push("#");
              segments.push({
                wildcard: true
              });
            }
          } else {
            fingers.push("?");
            segments.push({
              empty: item.empty
            });
          }
        } else {
          const seg = {
            length: parts.length,
            first: typeof parts[0] !== "string",
            segments: []
          };
          let finger = "";
          let regex = "^";
          for (let j = 0; j < parts.length; ++j) {
            const part = parts[j];
            if (typeof part === "string") {
              finger = finger + part;
              regex = regex + Hoek.escapeRegex(part);
              seg.segments.push(part);
            } else {
              Hoek.assert(params.indexOf(part.name) === -1, "Cannot repeat the same parameter name:", part.name, "in:", path);
              params.push(part.name);
              finger = finger + "?";
              regex = regex + "(." + (part.empty ? "*" : "+") + ")";
            }
          }
          seg.mixed = new RegExp(regex + "$", !this.settings.isCaseSensitive ? "i" : "");
          fingers.push(finger);
          segments.push(seg);
        }
      }
      return {
        segments,
        fingerprint: "/" + fingers.join("/"),
        params
      };
    };
    internals.parseParams = function(segment) {
      const parts = [];
      segment.replace(internals.pathRegex.parseParam, ($0, literal2, name, wildcard, count, empty4) => {
        if (literal2) {
          parts.push(literal2);
        } else {
          parts.push({
            name,
            wildcard: !!wildcard,
            count: count && parseInt(count, 10),
            empty: !!empty4
          });
        }
        return "";
      });
      return parts;
    };
    internals.Router.prototype.table = function(host) {
      const result = [];
      const collect = (table) => {
        if (!table) {
          return;
        }
        for (const map2 of table.values()) {
          for (const record2 of map2.routes) {
            result.push(record2.route);
          }
        }
      };
      if (this.vhosts) {
        const vhosts = host ? [].concat(host) : [
          ...this.vhosts.keys()
        ];
        for (const vhost of vhosts) {
          collect(this.vhosts.get(vhost));
        }
      }
      collect(this.routes);
      return result;
    };
    internals.sort = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      const as = a.segments;
      const bs = b.segments;
      if (as.length !== bs.length) {
        return as.length > bs.length ? bFirst : aFirst;
      }
      for (let i2 = 0; ; ++i2) {
        if (as[i2].literal) {
          if (bs[i2].literal) {
            if (as[i2].literal === bs[i2].literal) {
              continue;
            }
            return as[i2].literal > bs[i2].literal ? bFirst : aFirst;
          }
          return aFirst;
        }
        if (bs[i2].literal) {
          return bFirst;
        }
        return as[i2].wildcard ? bFirst : aFirst;
      }
    };
  }
});

// node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/client.js
var require_client = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/client.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var Boom = require_lib6();
    var internals = {
      validate: Symbol("validate")
    };
    internals.defaults = {
      partition: "catbox"
    };
    module2.exports = class {
      constructor(engine, options3) {
        Hoek.assert(engine, "Missing catbox client engine");
        Hoek.assert(typeof engine === "object" && typeof engine.start === "function" || typeof engine === "function", "engine must be an engine object or engine prototype (function)");
        Hoek.assert(typeof engine === "function" || !options3, "Can only specify options with function engine config");
        const settings = Object.assign({}, internals.defaults, options3);
        Hoek.assert(settings.partition.match(/^[\w\-]+$/), "Invalid partition name:" + settings.partition);
        this.connection = typeof engine === "object" ? engine : new engine(settings);
      }
      async start() {
        await this.connection.start();
      }
      async stop() {
        await this.connection.stop();
      }
      isReady() {
        return this.connection.isReady();
      }
      validateSegmentName(name) {
        return this.connection.validateSegmentName(name);
      }
      async get(key) {
        this[internals.validate](key, null);
        if (key === null) {
          return null;
        }
        const result = await this.connection.get(key);
        if (!result || result.item === void 0 || result.item === null) {
          return null;
        }
        const now = Date.now();
        const expires = result.stored + result.ttl;
        const ttl = expires - now;
        if (ttl <= 0) {
          return null;
        }
        const cached2 = {
          item: result.item,
          stored: result.stored,
          ttl
        };
        return cached2;
      }
      async set(key, value, ttl) {
        this[internals.validate](key);
        if (ttl <= 0) {
          return;
        }
        await this.connection.set(key, value, ttl);
      }
      async drop(key) {
        this[internals.validate](key);
        await this.connection.drop(key);
      }
      [internals.validate](key, allow = {}) {
        if (!this.isReady()) {
          throw Boom.internal("Disconnected");
        }
        const isValidKey = key && typeof key.id === "string" && key.segment && typeof key.segment === "string";
        if (!isValidKey && key !== allow) {
          throw Boom.internal("Invalid key");
        }
      }
    };
  }
});

// node_modules/.deno/@hapi+podium@5.0.2/node_modules/@hapi/podium/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/.deno/@hapi+podium@5.0.2/node_modules/@hapi/podium/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Teamwork = require_lib5();
    var Validate = require_lib3();
    var internals = {
      schema: {
        base: Validate.object({
          name: Validate.string().required(),
          clone: Validate.boolean(),
          tags: Validate.boolean(),
          spread: Validate.boolean(),
          channels: Validate.array().items(Validate.string()).single().unique().min(1).cast("set")
        })
      }
    };
    internals.schema.event = internals.schema.base.keys({
      shared: Validate.boolean()
    });
    internals.schema.listener = internals.schema.base.keys({
      listener: Validate.func().required(),
      context: Validate.object(),
      count: Validate.number().integer().min(1),
      filter: {
        tags: Validate.array().items(Validate.string()).single().unique().min(1).required(),
        all: Validate.boolean()
      }
    });
    exports2.validate = function(events) {
      const normalized = [];
      events = [].concat(events);
      for (let event of events) {
        if (typeof event === "string") {
          event = {
            name: event
          };
        }
        normalized.push(Validate.attempt(event, internals.schema.event, "Invalid event options"));
      }
      return normalized;
    };
    exports2.Podium = class {
      /** @type {Map<string,internals.EventListener>} */
      #listeners = /* @__PURE__ */ new Map();
      constructor(events, options3) {
        if (events) {
          this.registerEvent(events, options3);
        }
      }
      registerEvent(events, options3) {
        events = [].concat(events);
        for (let event of events) {
          if (typeof event === "string") {
            event = {
              name: event
            };
          }
          if (options3?.validate !== false) {
            event = Validate.attempt(event, internals.schema.event, "Invalid event options");
          }
          const name = event.name;
          if (this.#listeners.has(name)) {
            Hoek.assert(event.shared, `Event ${name} exists`);
            continue;
          }
          this.#listeners.set(name, new internals.EventListener(event));
        }
      }
      emit(criteria, data) {
        let thrownErr;
        this.#emitToEachListener(criteria, data, ([err]) => {
          thrownErr = thrownErr ?? err;
        });
        if (thrownErr) {
          throw thrownErr;
        }
      }
      async gauge(criteria, data) {
        const promises = [];
        this.#emitToEachListener(criteria, data, ([err, result]) => {
          promises.push(err ? Promise.reject(err) : result);
        });
        return await Promise.allSettled(promises);
      }
      #emitToEachListener(criteria, data, fn) {
        criteria = internals.criteria(criteria);
        const name = criteria.name;
        Hoek.assert(name, "Criteria missing event name");
        const event = this.#listeners.get(name);
        Hoek.assert(event, `Unknown event ${name}`);
        if (!event.handlers) {
          return;
        }
        Hoek.assert(!criteria.channel || typeof criteria.channel === "string", "Invalid channel name");
        Hoek.assert(!criteria.channel || !event.flags.channels || event.flags.channels.has(criteria.channel), `Unknown ${criteria.channel} channel`);
        Hoek.assert(!event.flags.spread || Array.isArray(data) || typeof data === "function", "Data must be an array for spread event");
        if (typeof criteria.tags === "string") {
          criteria = {
            ...criteria
          };
          criteria.tags = {
            [criteria.tags]: true
          };
        }
        if (criteria.tags && Array.isArray(criteria.tags)) {
          const tags = {};
          for (const tag2 of criteria.tags) {
            tags[tag2] = true;
          }
          criteria = {
            ...criteria
          };
          criteria.tags = tags;
        }
        let generated = false;
        for (const handler of event.handlers) {
          if (handler.channels && !(criteria.channel && handler.channels.has(criteria.channel))) {
            continue;
          }
          if (handler.filter) {
            if (!criteria.tags) {
              continue;
            }
            const match = Hoek.intersect(criteria.tags, handler.filter.tags, {
              first: !handler.filter.all
            });
            if (!match || handler.filter.all && match.length !== handler.filter.tags.length) {
              continue;
            }
          }
          if (handler.count) {
            --handler.count;
            if (handler.count < 1) {
              event.removeListener(handler.listener);
            }
          }
          if (!generated && typeof data === "function") {
            data = data();
            generated = true;
          }
          const update = event.flagged("clone", handler) ? Hoek.clone(data) : data;
          const args = event.flagged("spread", handler) && Array.isArray(update) ? update.slice(0) : [
            update
          ];
          if (event.flagged("tags", handler) && criteria.tags) {
            args.push(criteria.tags);
          }
          try {
            if (handler.context) {
              fn([
                null,
                handler.listener.apply(handler.context, args)
              ]);
            } else {
              fn([
                null,
                handler.listener(...args)
              ]);
            }
          } catch (err) {
            fn([
              err,
              null
            ]);
          }
        }
      }
      addListener(criteria, listener, context) {
        criteria = internals.criteria(criteria);
        criteria.listener = listener;
        criteria.context = context;
        if (criteria.filter && (typeof criteria.filter === "string" || Array.isArray(criteria.filter))) {
          criteria = {
            ...criteria
          };
          criteria.filter = {
            tags: criteria.filter
          };
        }
        criteria = Validate.attempt(criteria, internals.schema.listener, "Invalid event listener options");
        const name = criteria.name;
        const event = this.#listeners.get(name);
        Hoek.assert(event, `Unknown event ${name}`);
        event.addHandler(criteria);
        return this;
      }
      on(criteria, listener, context) {
        return this.addListener(criteria, listener, context);
      }
      once(criteria, listener, context) {
        criteria = {
          ...internals.criteria(criteria),
          count: 1
        };
        if (listener) {
          return this.addListener(criteria, listener, context);
        }
        return new Promise((resolve7) => {
          this.addListener(criteria, (...args) => resolve7(args));
        });
      }
      few(criteria) {
        Hoek.assert(typeof criteria === "object", "Criteria must be an object");
        Hoek.assert(criteria.count, "Criteria must include a count limit");
        const team = new Teamwork.Team({
          meetings: criteria.count
        });
        this.addListener(criteria, (...args) => team.attend(args));
        return team.work;
      }
      removeListener(name, listener) {
        Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
        Hoek.assert(typeof listener === "function", "Listener must be a function");
        this.#listeners.get(name).removeListener(listener);
        return this;
      }
      off(name, listener) {
        return this.removeListener(name, listener);
      }
      removeAllListeners(name) {
        Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
        this.#listeners.get(name).handlers = null;
        return this;
      }
      hasListeners(name) {
        Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
        return !!this.#listeners.get(name).handlers;
      }
    };
    internals.EventListener = class {
      constructor(flags) {
        this.flags = flags;
        this.handlers = null;
      }
      addHandler(handler) {
        Hoek.assert(!handler.channels || !this.flags.channels || Hoek.intersect(this.flags.channels, handler.channels).length === handler.channels.size, `Unknown event channels ${handler.channels && [
          ...handler.channels
        ].join(", ")}`);
        this.handlers = this.handlers ? [
          ...this.handlers,
          handler
        ] : [
          handler
        ];
      }
      removeListener(listener) {
        const filtered = this.handlers?.filter((item) => item.listener !== listener);
        this.handlers = filtered?.length ? filtered : null;
      }
      flagged(name, handler) {
        return handler[name] ?? this.flags[name] ?? false;
      }
    };
    internals.criteria = function(criteria) {
      if (typeof criteria === "string") {
        return {
          name: criteria
        };
      }
      return criteria;
    };
  }
});

// node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/pending.js
var require_pending = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/pending.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = class {
      id = null;
      timeout = null;
      count = 1;
      rule = null;
      resolve = null;
      reject = null;
      constructor(id, rule) {
        this.id = id;
        this.rule = rule;
        this.promise = new Promise((resolve7, reject) => {
          this.resolve = resolve7;
          this.reject = reject;
        });
      }
      join() {
        ++this.count;
        return this.promise;
      }
      send(err, value, cached2, report) {
        clearTimeout(this.timeout);
        if (err && !cached2) {
          this.reject(err);
          return;
        }
        if (!this.rule.getDecoratedValue) {
          this.resolve(value);
          return;
        }
        if (err) {
          report.error = err;
        }
        this.resolve({
          value,
          cached: cached2,
          report
        });
      }
      setTimeout(fn, timeoutMs) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(fn, timeoutMs);
      }
    };
  }
});

// node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/policy.js
var require_policy = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/policy.js"(exports2, module2) {
    "use strict";
    var Boom = require_lib6();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Validate = require_lib3();
    var Pending = require_pending();
    var internals = {
      day: 24 * 60 * 60 * 1e3,
      events: Podium.validate([
        {
          name: "error",
          channels: [
            "generate",
            "persist"
          ]
        }
      ])
    };
    internals.schema = Validate.object({
      expiresIn: Validate.number().integer().min(1),
      expiresAt: Validate.string().regex(/^\d\d?\:\d\d$/),
      staleIn: [
        Validate.number().integer().min(1).when("expiresAt", {
          is: Validate.required(),
          then: Validate.number().max(864e5 - 1)
        }),
        Validate.func()
      ],
      staleTimeout: Validate.number().integer().min(1),
      generateFunc: Validate.func(),
      generateTimeout: Validate.number().integer().min(1).allow(false),
      generateOnReadError: Validate.boolean(),
      generateIgnoreWriteError: Validate.boolean(),
      dropOnError: Validate.boolean(),
      pendingGenerateTimeout: Validate.number().integer().min(1),
      getDecoratedValue: Validate.boolean().default(false),
      // Ignored external keys (hapi)
      privacy: Validate.any(),
      cache: Validate.any(),
      segment: Validate.any(),
      shared: Validate.any()
    }).without("expiresIn", "expiresAt").with("staleIn", "generateFunc").with("generateOnReadError", "generateFunc").with("generateIgnoreWriteError", "generateFunc").with("dropOnError", "generateFunc").and("generateFunc", "generateTimeout").and("staleIn", "staleTimeout");
    exports2 = module2.exports = internals.Policy = class {
      rule = null;
      stats = {
        sets: 0,
        gets: 0,
        hits: 0,
        stales: 0,
        generates: 0,
        errors: 0
      };
      _events = null;
      _cache = null;
      _segment = null;
      _pendings = /* @__PURE__ */ new Map();
      _pendingGenerateCall = /* @__PURE__ */ new Map();
      constructor(options3, cache3, segment) {
        this._cache = cache3;
        this.rules(options3);
        if (cache3) {
          const nameErr = cache3.validateSegmentName(segment);
          Hoek.assert(nameErr === null, "Invalid segment name: " + segment + (nameErr ? " (" + nameErr.message + ")" : ""));
          this._segment = segment;
        }
      }
      get client() {
        return this._cache;
      }
      get events() {
        if (!this._events) {
          this._events = new Podium.Podium(internals.events, {
            validate: false
          });
        }
        return this._events;
      }
      _error(source, error40) {
        if (!this._events) {
          return;
        }
        this._events.emit({
          name: "error",
          channel: source
        }, {
          source,
          error: error40
        });
      }
      rules(options3) {
        this.rule = internals.Policy.compile(options3, !!this._cache);
      }
      async get(key) {
        ++this.stats.gets;
        if (!key || typeof key === "string") {
          key = {
            id: key,
            string: true
          };
        }
        let pending = this._pendings.get(key.id);
        if (pending !== void 0) {
          return pending.join();
        }
        pending = new Pending(key.id, this.rule);
        this._pendings.set(key.id, pending);
        try {
          await this._get(pending, key);
        } catch (err) {
          this._send(key, err);
        }
        return pending.promise;
      }
      async _get(pending, key) {
        const report = {};
        const timer2 = new Hoek.Bench();
        if (this._cache) {
          try {
            var cached2 = await this._cache.get({
              segment: this._segment,
              id: key.id
            });
          } catch (err) {
            report.error = err;
            ++this.stats.errors;
            this._error("persist", err);
          }
        }
        report.msec = timer2.elapsed();
        if (cached2) {
          report.stored = cached2.stored;
          report.ttl = cached2.ttl;
          const staleIn = typeof this.rule.staleIn === "function" ? this.rule.staleIn(cached2.stored, cached2.ttl) : this.rule.staleIn;
          cached2.isStale = staleIn ? Date.now() - cached2.stored >= staleIn : false;
          report.isStale = cached2.isStale;
          if (cached2.isStale) {
            ++this.stats.stales;
          }
        }
        if (!this.rule.generateFunc || report.error && !this.rule.generateOnReadError) {
          this._send(key, report.error, cached2 ? cached2.item : null, cached2, report);
          return;
        }
        if (cached2 && !cached2.isStale) {
          this._send(key, null, cached2.item, cached2, report);
          return;
        }
        return Promise.race([
          pending.promise,
          this._generate(pending, key, cached2, report)
        ]);
      }
      _generate(pending, key, cached2, report) {
        if (cached2) {
          cached2.ttl = cached2.ttl - this.rule.staleTimeout;
        }
        if (cached2 && cached2.ttl > 0) {
          pending.setTimeout(() => this._send(key, null, cached2.item, cached2, report), this.rule.staleTimeout);
        } else if (this.rule.generateTimeout) {
          pending.setTimeout(() => this._send(key, Boom.serverUnavailable(), null, null, report), this.rule.generateTimeout);
        }
        if (this._pendingGenerateCall.has(key.id)) {
          return;
        }
        ++this.stats.generates;
        if (this.rule.pendingGenerateTimeout) {
          const timeout = setTimeout(() => this._pendingGenerateCall.delete(key.id), this.rule.pendingGenerateTimeout);
          this._pendingGenerateCall.set(key.id, timeout);
        }
        return this._callGenerateFunc(key, cached2, report);
      }
      async _callGenerateFunc(key, cached2, report) {
        const flags = {};
        try {
          var value = await this.rule.generateFunc(key.string ? key.id : key, flags);
        } catch (err) {
          var generateError = err;
          this._error("generate", err);
        }
        const pendingTimeout = this._pendingGenerateCall.get(key.id);
        if (pendingTimeout) {
          clearTimeout(pendingTimeout);
          this._pendingGenerateCall.delete(key.id);
        }
        try {
          if (flags.ttl === 0 || // null or undefined means use policy
          generateError && this.rule.dropOnError) {
            await this.drop(key.id);
          } else if (!generateError) {
            await this.set(key.id, value, flags.ttl);
          }
        } catch (err) {
          var persistError = err;
          this._error("persist", err);
        }
        const error40 = generateError || (this.rule.generateIgnoreWriteError ? null : persistError);
        if (cached2 && error40 && !this.rule.dropOnError) {
          this._send(key, error40, cached2.item, cached2, report);
          return;
        }
        this._send(key, error40, value, null, report);
      }
      _send(key, err, value, cached2, report) {
        const pending = this._pendings.get(key.id);
        if (!pending) {
          return;
        }
        this._pendings.delete(key.id);
        pending.send(err, value, cached2, report);
        if (report?.isStale !== void 0) {
          this.stats.hits = this.stats.hits + pending.count;
        }
      }
      async set(key, value, ttl) {
        ++this.stats.sets;
        if (!this._cache) {
          return;
        }
        try {
          await this._cache.set({
            segment: this._segment,
            id: internals.id(key)
          }, value, ttl || internals.Policy.ttl(this.rule));
        } catch (err) {
          ++this.stats.errors;
          throw err;
        }
      }
      async drop(key) {
        if (!this._cache) {
          return;
        }
        try {
          await this._cache.drop({
            segment: this._segment,
            id: internals.id(key)
          });
          return;
        } catch (err) {
          ++this.stats.errors;
          throw err;
        }
      }
      ttl(created) {
        return internals.Policy.ttl(this.rule, created);
      }
      isReady() {
        if (!this._cache) {
          return false;
        }
        return this._cache.connection.isReady();
      }
      static compile(options3, serverSide) {
        const rule = {};
        if (!options3 || !Object.keys(options3).length) {
          return rule;
        }
        options3 = Validate.attempt(options3, internals.schema, "Invalid cache policy configuration");
        const hasExpiresIn = options3.expiresIn !== void 0 && options3.expiresIn !== null;
        const hasExpiresAt = options3.expiresAt !== void 0 && options3.expiresAt !== null;
        Hoek.assert(!hasExpiresIn || !options3.staleIn || typeof options3.staleIn === "function" || options3.staleIn < options3.expiresIn, "staleIn must be less than expiresIn");
        Hoek.assert(!options3.staleIn || serverSide, "Cannot use stale options without server-side caching");
        Hoek.assert(!options3.staleTimeout || !hasExpiresIn || options3.staleTimeout < options3.expiresIn, "staleTimeout must be less than expiresIn");
        Hoek.assert(!options3.staleTimeout || !hasExpiresIn || typeof options3.staleIn === "function" || options3.staleTimeout < options3.expiresIn - options3.staleIn, "staleTimeout must be less than the delta between expiresIn and staleIn");
        Hoek.assert(!options3.staleTimeout || !options3.pendingGenerateTimeout || options3.staleTimeout < options3.pendingGenerateTimeout, "pendingGenerateTimeout must be greater than staleTimeout if specified");
        if (hasExpiresAt) {
          const time3 = /^(\d\d?):(\d\d)$/.exec(options3.expiresAt);
          rule.expiresAt = {
            hours: parseInt(time3[1], 10),
            minutes: parseInt(time3[2], 10)
          };
        } else {
          rule.expiresIn = options3.expiresIn ?? 0;
        }
        if (options3.generateFunc) {
          rule.generateFunc = options3.generateFunc;
          rule.generateTimeout = options3.generateTimeout;
          if (options3.staleIn) {
            rule.staleIn = options3.staleIn;
            rule.staleTimeout = options3.staleTimeout;
          }
          rule.dropOnError = options3.dropOnError !== void 0 ? options3.dropOnError : true;
          rule.pendingGenerateTimeout = options3.pendingGenerateTimeout !== void 0 ? options3.pendingGenerateTimeout : 0;
        }
        rule.generateOnReadError = options3.generateOnReadError !== void 0 ? options3.generateOnReadError : true;
        rule.generateIgnoreWriteError = options3.generateIgnoreWriteError !== void 0 ? options3.generateIgnoreWriteError : true;
        rule.getDecoratedValue = options3.getDecoratedValue;
        return rule;
      }
      static ttl(rule, created, now) {
        now = now ?? Date.now();
        created = created ?? now;
        const age = now - created;
        if (age < 0) {
          return 0;
        }
        if (rule.expiresIn) {
          return Math.max(rule.expiresIn - age, 0);
        }
        if (rule.expiresAt) {
          if (age > internals.day) {
            return 0;
          }
          const expiresAt = new Date(created);
          expiresAt.setHours(rule.expiresAt.hours);
          expiresAt.setMinutes(rule.expiresAt.minutes);
          expiresAt.setSeconds(0);
          expiresAt.setMilliseconds(0);
          let expires = expiresAt.getTime();
          if (expires <= created) {
            expires = expires + internals.day;
          }
          if (now >= expires) {
            return 0;
          }
          return expires - now;
        }
        return 0;
      }
    };
    internals.id = function(key) {
      return key && typeof key === "object" ? key.id : key;
    };
  }
});

// node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/.deno/@hapi+catbox@12.1.1/node_modules/@hapi/catbox/lib/index.js"(exports2) {
    "use strict";
    var Client = require_client();
    var Policy = require_policy();
    exports2.Client = Client;
    exports2.Policy = exports2.policy = Policy;
  }
});

// node_modules/.deno/@hapi+catbox-memory@6.0.2/node_modules/@hapi/catbox-memory/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/.deno/@hapi+catbox-memory@6.0.2/node_modules/@hapi/catbox-memory/lib/index.js"(exports2) {
    "use strict";
    var Boom = require_lib6();
    var Hoek = require_lib();
    var internals = {
      maxTimer: 2147483647,
      entrySize: 144
      // Approximate cache entry size without value: 144 bytes
    };
    internals.defaults = {
      maxByteSize: 100 * 1024 * 1024,
      minCleanupIntervalMsec: 1e3,
      cloneBuffersOnGet: false
    };
    exports2.Engine = class CatboxMemoryEngine {
      constructor(options3 = {}) {
        Hoek.assert(options3.maxByteSize === void 0 || options3.maxByteSize >= 0, "Invalid cache maxByteSize value");
        Hoek.assert(options3.allowMixedContent === void 0, "allowMixedContent no longer supported");
        Hoek.assert(options3.minCleanupIntervalMsec === void 0 || options3.minCleanupIntervalMsec < internals.maxTimer, "Invalid cache minCleanupIntervalMsec value");
        Hoek.assert(options3.cloneBuffersOnGet === void 0 || typeof options3.cloneBuffersOnGet === "boolean", "Invalid cloneBuffersOnGet value");
        this.settings = Hoek.applyToDefaults(internals.defaults, options3);
        this.cache = null;
        this._timer = null;
        this._timerDue = null;
      }
      start() {
        if (!this.cache) {
          this.cache = /* @__PURE__ */ new Map();
          this.byteSize = 0;
        }
      }
      _scheduleCleanup(msec) {
        const cleanup = () => {
          this._timer = null;
          this._timerDue = null;
          const now2 = Date.now();
          let next = Infinity;
          for (const [, segment] of this.cache) {
            for (const [id, envelope] of segment) {
              const ttl = envelope.stored + envelope.ttl - now2;
              if (ttl <= 0) {
                segment.delete(id);
                this.byteSize -= envelope.byteSize;
              } else {
                next = Math.min(next, ttl);
              }
            }
          }
          if (next !== Infinity) {
            this._scheduleCleanup(next);
          }
        };
        const now = Date.now();
        const timeout = Math.min(Math.max(this.settings.minCleanupIntervalMsec, msec), internals.maxTimer);
        if (this._timer) {
          if (this._timerDue - now < msec) {
            return;
          }
          clearTimeout(this._timer);
        }
        this._timerDue = now + timeout;
        this._timer = setTimeout(cleanup, timeout);
      }
      stop() {
        clearTimeout(this._timer);
        this._timer = null;
        this._timerDue = null;
        this.cache = null;
        this.byteSize = 0;
      }
      isReady() {
        return !!this.cache;
      }
      validateSegmentName(name) {
        if (!name) {
          throw new Boom.Boom("Empty string");
        }
        if (name.indexOf("\0") !== -1) {
          throw new Boom.Boom("Includes null character");
        }
        return null;
      }
      get(key) {
        if (!this.cache) {
          throw new Boom.Boom("Connection not started");
        }
        const segment = this.cache.get(key.segment);
        if (!segment) {
          return null;
        }
        const envelope = segment.get(key.id);
        if (!envelope) {
          return null;
        }
        if (envelope.stored + envelope.ttl < Date.now()) {
          this.drop(key);
          return null;
        }
        let item = null;
        if (Buffer.isBuffer(envelope.item)) {
          item = envelope.item;
          if (this.settings.cloneBuffersOnGet) {
            const copy4 = Buffer.alloc(item.length);
            item.copy(copy4);
            item = copy4;
          }
        } else {
          try {
            item = JSON.parse(envelope.item);
          } catch (err) {
            throw new Boom.Boom("Bad value content");
          }
        }
        const result = {
          item,
          stored: envelope.stored,
          ttl: envelope.ttl
        };
        return result;
      }
      set(key, value, ttl) {
        if (!this.cache) {
          throw new Boom.Boom("Connection not started");
        }
        const envelope = new internals.MemoryCacheEntry(key, value, ttl);
        let segment = this.cache.get(key.segment);
        if (!segment) {
          segment = /* @__PURE__ */ new Map();
          this.cache.set(key.segment, segment);
        }
        const cachedItem = segment.get(key.id);
        if (cachedItem) {
          this.byteSize -= cachedItem.byteSize;
        }
        if (this.settings.maxByteSize && this.byteSize + envelope.byteSize > this.settings.maxByteSize) {
          throw new Boom.Boom("Cache size limit reached");
        }
        this._scheduleCleanup(ttl);
        segment.set(key.id, envelope);
        this.byteSize += envelope.byteSize;
      }
      drop(key) {
        if (!this.cache) {
          throw new Boom.Boom("Connection not started");
        }
        const segment = this.cache.get(key.segment);
        if (segment) {
          const item = segment.get(key.id);
          if (item) {
            this.byteSize -= item.byteSize;
            segment.delete(key.id);
          }
        }
      }
    };
    internals.MemoryCacheEntry = class {
      constructor(key, value, ttl) {
        let valueByteSize = 0;
        if (Buffer.isBuffer(value)) {
          this.item = Buffer.alloc(value.length);
          value.copy(this.item);
          valueByteSize = this.item.length;
        } else {
          this.item = JSON.stringify(value);
          valueByteSize = Buffer.byteLength(this.item);
        }
        this.stored = Date.now();
        this.ttl = ttl;
        this.byteSize = internals.entrySize + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);
        this.timeoutId = null;
      }
    };
  }
});

// node_modules/.deno/@hapi+heavy@8.0.1/node_modules/@hapi/heavy/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/.deno/@hapi+heavy@8.0.1/node_modules/@hapi/heavy/lib/index.js"(exports2) {
    "use strict";
    var PerfHooks = __require("node:perf_hooks");
    var Boom = require_lib6();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var internals = {};
    internals.schema = Validate.object({
      sampleInterval: Validate.number().min(0),
      maxHeapUsedBytes: Validate.number().min(0),
      maxEventLoopDelay: Validate.number().min(0),
      maxEventLoopUtilization: Validate.number().min(0),
      maxRssBytes: Validate.number().min(0)
    }).unknown();
    internals.defaults = {
      sampleInterval: 0,
      maxHeapUsedBytes: 0,
      maxRssBytes: 0,
      maxEventLoopDelay: 0,
      maxEventLoopUtilization: 0
      // Max event loop utilization value after which requests are rejected (zero is no max)
    };
    exports2.Heavy = class Heavy {
      constructor(options3) {
        options3 = options3 || {};
        Validate.assert(options3, internals.schema, "Invalid load monitoring options");
        this.settings = Hoek.applyToDefaults(internals.defaults, options3);
        Hoek.assert(this.settings.sampleInterval || !this.settings.maxEventLoopDelay && !this.settings.maxHeapUsedBytes && !this.settings.maxRssBytes && !this.settings.maxEventLoopUtilization, "Load sample interval must be set to enable load limits");
        this._eventLoopTimer = null;
        this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization();
        this._loadBench = new Hoek.Bench();
        this.load = {
          eventLoopDelay: 0,
          eventLoopUtilization: 0,
          heapUsed: 0,
          rss: 0
        };
      }
      start() {
        if (!this.settings.sampleInterval) {
          return;
        }
        const loopSample = () => {
          this._loadBench.reset();
          const measure = () => {
            const mem = process.memoryUsage();
            this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization(this._eventLoopUtilization);
            this.load.eventLoopDelay = this._loadBench.elapsed() - this.settings.sampleInterval;
            this.load.eventLoopUtilization = this._eventLoopUtilization.utilization;
            this.load.heapUsed = mem.heapUsed;
            this.load.rss = mem.rss;
            loopSample();
          };
          this._eventLoopTimer = setTimeout(measure, this.settings.sampleInterval);
        };
        loopSample();
      }
      stop() {
        clearTimeout(this._eventLoopTimer);
        this._eventLoopTimer = null;
      }
      check() {
        if (!this.settings.sampleInterval) {
          return;
        }
        Hoek.assert(this._eventLoopTimer, "Cannot check load when sampler is not started");
        const elapsed = this._loadBench.elapsed();
        const load = this.load;
        if (elapsed > this.settings.sampleInterval) {
          this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization(this._eventLoopUtilization);
          load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this.settings.sampleInterval);
          load.eventLoopUtilization = this._eventLoopUtilization.utilization;
        }
        if (this.settings.maxEventLoopDelay && load.eventLoopDelay > this.settings.maxEventLoopDelay) {
          throw Boom.serverUnavailable("Server under heavy load (event loop)", load);
        }
        if (this.settings.maxEventLoopUtilization && load.eventLoopUtilization > this.settings.maxEventLoopUtilization) {
          throw Boom.serverUnavailable("Server under heavy load (event loop utilization)", load);
        }
        if (this.settings.maxHeapUsedBytes && load.heapUsed > this.settings.maxHeapUsedBytes) {
          throw Boom.serverUnavailable("Server under heavy load (heap)", load);
        }
        if (this.settings.maxRssBytes && load.rss > this.settings.maxRssBytes) {
          throw Boom.serverUnavailable("Server under heavy load (rss)", load);
        }
      }
    };
  }
});

// node_modules/.deno/mime-db@1.54.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/.deno/mime-db@1.54.0/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/ace+json": {
        source: "iana",
        compressible: true
      },
      "application/ace-groupcomm+cbor": {
        source: "iana"
      },
      "application/ace-trl+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/aif+cbor": {
        source: "iana"
      },
      "application/aif+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-cdni+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-cdnifilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-propmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-propmapparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-tips+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-tipsparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/appinstaller": {
        compressible: false,
        extensions: ["appinstaller"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/appx": {
        compressible: false,
        extensions: ["appx"]
      },
      "application/appxbundle": {
        compressible: false,
        extensions: ["appxbundle"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/automationml-aml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["aml"]
      },
      "application/automationml-amlx+zip": {
        source: "iana",
        compressible: false,
        extensions: ["amlx"]
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/bufr": {
        source: "iana"
      },
      "application/c2pa": {
        source: "iana"
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/ce+cbor": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/cid-edhoc+cbor-seq": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/city+json-seq": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-eap": {
        source: "iana"
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/concise-problem-details+cbor": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cose-x509": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwl": {
        source: "iana",
        extensions: ["cwl"]
      },
      "application/cwl+json": {
        source: "iana",
        compressible: true
      },
      "application/cwl+yaml": {
        source: "iana"
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana",
        extensions: ["dcm"]
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dpop+jwt": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/eat+cwt": {
        source: "iana"
      },
      "application/eat+jwt": {
        source: "iana"
      },
      "application/eat-bun+cbor": {
        source: "iana"
      },
      "application/eat-bun+json": {
        source: "iana",
        compressible: true
      },
      "application/eat-ucs+cbor": {
        source: "iana"
      },
      "application/eat-ucs+json": {
        source: "iana",
        compressible: true
      },
      "application/ecmascript": {
        source: "apache",
        compressible: true,
        extensions: ["ecma"]
      },
      "application/edhoc+cbor-seq": {
        source: "iana"
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.legacyesn+json": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/entity-statement+jwt": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geopose+json": {
        source: "iana",
        compressible: true
      },
      "application/geoxacml+json": {
        source: "iana",
        compressible: true
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gnap-binding-jws": {
        source: "iana"
      },
      "application/gnap-binding-jwsd": {
        source: "iana"
      },
      "application/gnap-binding-rotation-jws": {
        source: "iana"
      },
      "application/gnap-binding-rotation-jwsd": {
        source: "iana"
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/grib": {
        source: "iana"
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "iana",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "apache",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/jscontact+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jsonpath": {
        source: "iana"
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+jwt": {
        source: "iana"
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/linkset": {
        source: "iana"
      },
      "application/linkset+json": {
        source: "iana",
        compressible: true
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/logout+jwt": {
        source: "iana"
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4", "mpg4", "mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msix": {
        compressible: false,
        extensions: ["msix"]
      },
      "application/msixbundle": {
        compressible: false,
        extensions: ["msixbundle"]
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: true,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/ohttp-keys": {
        source: "iana"
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["sig", "asc"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/private-token-issuer-directory": {
        source: "iana"
      },
      "application/private-token-request": {
        source: "iana"
      },
      "application/private-token-response": {
        source: "iana"
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/provided-claims+jwt": {
        source: "iana"
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.implied-document+xml": {
        source: "iana",
        compressible: true
      },
      "application/prs.implied-executable": {
        source: "iana"
      },
      "application/prs.implied-object+json": {
        source: "iana",
        compressible: true
      },
      "application/prs.implied-object+json-seq": {
        source: "iana"
      },
      "application/prs.implied-object+yaml": {
        source: "iana"
      },
      "application/prs.implied-structure": {
        source: "iana"
      },
      "application/prs.mayfile": {
        source: "iana"
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.vcfbzip2": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsf"]
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "apache"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resolve-response+jwt": {
        source: "iana"
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-checklist": {
        source: "iana"
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-signed-tal": {
        source: "iana"
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "apache"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana",
        extensions: ["sql"]
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/sslkeylogfile": {
        source: "iana"
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/st2110-41": {
        source: "iana"
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/stratum": {
        source: "iana"
      },
      "application/swid+cbor": {
        source: "iana"
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tm+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/toc+cbor": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        source: "iana",
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/trust-chain+json": {
        source: "iana",
        compressible: true
      },
      "application/trust-mark+jwt": {
        source: "iana"
      },
      "application/trust-mark-delegation+jwt": {
        source: "iana"
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/uccs+cbor": {
        source: "iana"
      },
      "application/ujcs+json": {
        source: "iana",
        compressible: true
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vc": {
        source: "iana"
      },
      "application/vc+cose": {
        source: "iana"
      },
      "application/vc+jwt": {
        source: "iana"
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.1ob": {
        source: "iana"
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3a+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ach+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc8+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsa2x": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsa2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsv2x": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsv2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.crs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.current-location-discovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.pinapp-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.seal-group-doc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-network-qos-management-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-ue-config-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-unicast-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-user-profile-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.v2x": {
        source: "iana"
      },
      "application/vnd.3gpp.vae-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acm.addressxfer+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.acm.chatbot+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "apache",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "apache"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.parquet": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.apexlang": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "apache"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autodesk.fbx": {
        extensions: ["fbx"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.belightsoft.lhzd+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.belightsoft.lhzl+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bzip3": {
        source: "iana"
      },
      "application/vnd.c3voc.schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.cncf.helm.chart.content.v1.tar+gzip": {
        source: "iana"
      },
      "application/vnd.cncf.helm.chart.provenance.v1.prov": {
        source: "iana"
      },
      "application/vnd.cncf.helm.config.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datalog": {
        source: "iana"
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.dcmp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dcmp"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.eln+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.erofs": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "apache",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.fdsn.stationxml+xml": {
        source: "iana",
        charset: "XML-BASED",
        compressible: true
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.freelog.comic": {
        source: "iana"
      },
      "application/vnd.frogans.fnc": {
        source: "apache",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "apache",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.ga4gh.passport+jwt": {
        source: "iana"
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.genozip": {
        source: "iana"
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.catmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.ebuild": {
        source: "iana"
      },
      "application/vnd.gentoo.eclass": {
        source: "iana"
      },
      "application/vnd.gentoo.gpkg": {
        source: "iana"
      },
      "application/vnd.gentoo.manifest": {
        source: "iana"
      },
      "application/vnd.gentoo.pkgmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.xpak": {
        source: "iana"
      },
      "application/vnd.geo+json": {
        source: "apache",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.pinboard": {
        source: "iana"
      },
      "application/vnd.geogebra.slides": {
        source: "iana",
        extensions: ["ggs"]
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.gnu.taler.exchange+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gnu.taler.merchant+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.google-apps.audio": {},
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.drawing": {
        compressible: false,
        extensions: ["gdraw"]
      },
      "application/vnd.google-apps.drive-sdk": {
        compressible: false
      },
      "application/vnd.google-apps.file": {},
      "application/vnd.google-apps.folder": {
        compressible: false
      },
      "application/vnd.google-apps.form": {
        compressible: false,
        extensions: ["gform"]
      },
      "application/vnd.google-apps.fusiontable": {},
      "application/vnd.google-apps.jam": {
        compressible: false,
        extensions: ["gjam"]
      },
      "application/vnd.google-apps.mail-layout": {},
      "application/vnd.google-apps.map": {
        compressible: false,
        extensions: ["gmap"]
      },
      "application/vnd.google-apps.photo": {},
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.script": {
        compressible: false,
        extensions: ["gscript"]
      },
      "application/vnd.google-apps.shortcut": {},
      "application/vnd.google-apps.site": {
        compressible: false,
        extensions: ["gsite"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-apps.unknown": {},
      "application/vnd.google-apps.video": {},
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdcf"]
      },
      "application/vnd.gpxsee.map+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.hsl": {
        source: "iana"
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "apache"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "apache",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "apache"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.ipfs.ipns-record": {
        source: "iana"
      },
      "application/vnd.ipld.car": {
        source: "iana"
      },
      "application/vnd.ipld.dag-cbor": {
        source: "iana"
      },
      "application/vnd.ipld.dag-json": {
        source: "iana"
      },
      "application/vnd.ipld.raw": {
        source: "iana"
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kdl": {
        source: "iana"
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.keyman.kmp+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.keyman.kmx": {
        source: "iana"
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.ldev.productlicensing": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.mdl": {
        source: "iana"
      },
      "application/vnd.mdl-mbsdf": {
        source: "iana"
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.medicalholodeck.recordxr": {
        source: "iana"
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mermaid": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.modl": {
        source: "iana"
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-visio.viewer": {
        extensions: ["vdx"]
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msgpack": {
        source: "iana"
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nato.bindingdataobject+cbor": {
        source: "iana"
      },
      "application/vnd.nato.bindingdataobject+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nato.bindingdataobject+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bdo"]
      },
      "application/vnd.nato.openxmlformats-package.iepd+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "apache",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oai.workflows": {
        source: "iana"
      },
      "application/vnd.oai.workflows+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oai.workflows+yaml": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.base": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "apache",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-master-template": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.onvif.metadata": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openvpi.dspx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.procrate.brushset": {
        extensions: ["brushset"]
      },
      "application/vnd.procreate.brush": {
        extensions: ["brush"]
      },
      "application/vnd.procreate.dream": {
        extensions: ["drm"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.pt.mundusmundi": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtm"]
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.relpipe": {
        source: "iana"
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sketchometry": {
        source: "iana"
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.smintio.portals.archive": {
        source: "iana"
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sybyl.mol2": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uic.osdm+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml", "uo"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veraison.tsm-report+cbor": {
        source: "iana"
      },
      "application/vnd.veraison.tsm-report+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vocalshaper.vsp4": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.wasmflow.wafl": {
        source: "iana"
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordlift": {
        source: "iana"
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xarin.cpj": {
        source: "iana"
      },
      "application/vnd.xecrets-encrypted": {
        source: "iana"
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/voucher-jws+json": {
        source: "iana",
        compressible: true
      },
      "application/vp": {
        source: "iana"
      },
      "application/vp+cose": {
        source: "iana"
      },
      "application/vp+jwt": {
        source: "iana"
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blender": {
        extensions: ["blend"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-compressed": {
        extensions: ["rar"]
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-ipynb+json": {
        compressible: true,
        extensions: ["ipynb"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zip-compressed": {
        extensions: ["zip"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yaml": {
        source: "iana"
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+cbor": {
        source: "iana"
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-sid+json": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zip+dotlottie": {
        extensions: ["lottie"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana",
        extensions: ["adts", "aac"]
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flac": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/matroska": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/midi-clip": {
        source: "iana"
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a", "m4b"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "apache"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        source: "iana",
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp", "dib"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/dpx": {
        source: "iana",
        extensions: ["dpx"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/j2c": {
        source: "iana"
      },
      "image/jaii": {
        source: "iana",
        extensions: ["jaii"]
      },
      "image/jais": {
        source: "iana",
        extensions: ["jais"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpg", "jpeg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm", "jpgm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxl": {
        source: "iana",
        extensions: ["jxl"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false,
        extensions: ["jfif"]
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif", "btf"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.clip": {
        source: "iana"
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "iana",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-adobe-dng": {
        extensions: ["dng"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-emf": {
        source: "iana"
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-wmf": {
        source: "iana"
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/bhttp": {
        source: "iana"
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/mls": {
        source: "iana"
      },
      "message/news": {
        source: "apache"
      },
      "message/ohttp-req": {
        source: "iana"
      },
      "message/ohttp-res": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime", "mht", "mhtml"]
      },
      "message/s-http": {
        source: "apache"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "apache"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/jt": {
        source: "iana",
        extensions: ["jt"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/prc": {
        source: "iana",
        extensions: ["prc"]
      },
      "model/step": {
        source: "iana",
        extensions: ["step", "stp", "stpnc", "p21", "210"]
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/u3d": {
        source: "iana",
        extensions: ["u3d"]
      },
      "model/vnd.bary": {
        source: "iana",
        extensions: ["bary"]
      },
      "model/vnd.cld": {
        source: "iana",
        extensions: ["cld"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana",
        extensions: ["pyo", "pyox"]
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usda": {
        source: "iana",
        extensions: ["usda"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "apache"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/hl7v2": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["md", "markdown"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/prs.texi": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.exchangeable": {
        source: "iana"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "apache"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.vcf": {
        source: "iana"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vnd.zoo.kcl": {
        source: "iana"
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/wgsl": {
        source: "iana",
        extensions: ["wgsl"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/evc": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/h266": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/lottie+json": {
        source: "iana",
        compressible: true
      },
      "video/matroska": {
        source: "iana"
      },
      "video/matroska-3d": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts", "m2t", "m2ts", "mts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.planar": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "apache"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/.deno/@hapi+mimos@7.0.1/node_modules/@hapi/mimos/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/.deno/@hapi+mimos@7.0.1/node_modules/@hapi/mimos/lib/index.js"(exports2) {
    "use strict";
    var Path = __require("node:path");
    var Hoek = require_lib();
    var MimeDb = require_db();
    var internals = {
      compressibleRx: /^text\/|\+json$|\+text$|\+xml$/
    };
    exports2.MimosEntry = class {
      constructor(type, mime) {
        this.type = type;
        this.source = "mime-db";
        this.extensions = [];
        this.compressible = void 0;
        Object.assign(this, mime);
        if (this.compressible === void 0) {
          this.compressible = internals.compressibleRx.test(type);
        }
      }
    };
    internals.insertEntry = function(type, entry, db2) {
      db2.byType.set(type, entry);
      for (const ext of entry.extensions) {
        db2.byExtension.set(ext, entry);
        if (ext.length > db2.maxExtLength) {
          db2.maxExtLength = ext.length;
        }
      }
    };
    internals.compile = function(mimedb) {
      const db2 = {
        byType: /* @__PURE__ */ new Map(),
        byExtension: /* @__PURE__ */ new Map(),
        maxExtLength: 0
      };
      for (const type in mimedb) {
        const entry = new exports2.MimosEntry(type, mimedb[type]);
        internals.insertEntry(type, entry, db2);
      }
      return db2;
    };
    internals.getTypePart = function(fulltype) {
      const splitAt = fulltype.indexOf(";");
      return splitAt === -1 ? fulltype : fulltype.slice(0, splitAt);
    };
    internals.applyPredicate = function(mime) {
      if (mime.predicate) {
        return mime.predicate(Hoek.clone(mime));
      }
      return mime;
    };
    exports2.Mimos = class Mimos {
      #db = internals.base;
      constructor(options3 = {}) {
        if (options3.override) {
          Hoek.assert(typeof options3.override === "object", "overrides option must be an object");
          this.#db = {
            ...this.#db,
            byType: new Map(this.#db.byType),
            byExtension: new Map(this.#db.byExtension)
          };
          for (const type in options3.override) {
            const override = options3.override[type];
            Hoek.assert(!override.predicate || typeof override.predicate === "function", "predicate option must be a function");
            const from6 = this.#db.byType.get(type);
            const baseEntry = from6 ? Hoek.applyToDefaults(from6, override) : override;
            const entry = new exports2.MimosEntry(type, baseEntry);
            internals.insertEntry(type, entry, this.#db);
          }
        }
      }
      path(path) {
        const extension = Path.extname(path).slice(1).toLowerCase();
        const mime = this.#db.byExtension.get(extension) ?? {};
        return internals.applyPredicate(mime);
      }
      type(type) {
        type = internals.getTypePart(type);
        let mime = this.#db.byType.get(type);
        if (!mime) {
          type = type.trim().toLowerCase();
          mime = this.#db.byType.get(type);
        }
        if (!mime) {
          mime = new exports2.MimosEntry(type, {
            source: "mimos"
          });
          internals.insertEntry(type, mime, this.#db);
          return mime;
        }
        return internals.applyPredicate(mime);
      }
    };
    internals.base = internals.compile(MimeDb);
  }
});

// node_modules/.deno/@hapi+bourne@3.0.0/node_modules/@hapi/bourne/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/.deno/@hapi+bourne@3.0.0/node_modules/@hapi/bourne/lib/index.js"(exports2) {
    "use strict";
    var internals = {
      suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
    };
    exports2.parse = function(text, ...args) {
      const firstOptions = typeof args[0] === "object" && args[0];
      const reviver = args.length > 1 || !firstOptions ? args[0] : void 0;
      const options3 = args.length > 1 && args[1] || firstOptions || {};
      const obj = JSON.parse(text, reviver);
      if (options3.protoAction === "ignore") {
        return obj;
      }
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (!text.match(internals.suspectRx)) {
        return obj;
      }
      exports2.scan(obj, options3);
      return obj;
    };
    exports2.scan = function(obj, options3 = {}) {
      let next = [
        obj
      ];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (options3.protoAction !== "remove") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(node[key]);
            }
          }
        }
      }
    };
    exports2.safeParse = function(text, reviver) {
      try {
        return exports2.parse(text, reviver);
      } catch (ignoreError) {
        return null;
      }
    };
  }
});

// node_modules/.deno/@hapi+cryptiles@6.0.1/node_modules/@hapi/cryptiles/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/.deno/@hapi+cryptiles@6.0.1/node_modules/@hapi/cryptiles/lib/index.js"(exports2) {
    "use strict";
    var Crypto = __require("node:crypto");
    var Boom = require_lib6();
    var internals = {};
    exports2.randomString = function(size) {
      const buffer = exports2.randomBits((size + 1) * 6);
      const string4 = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      return string4.slice(0, size);
    };
    exports2.randomAlphanumString = function(size) {
      let result = "";
      while (result.length < size) {
        const buffer = exports2.randomBits((size + 1) * 6);
        result += buffer.toString("base64").replace(/[^a-zA-Z0-9]/g, "");
      }
      return result.slice(0, size);
    };
    exports2.randomDigits = function(size) {
      const digits = [];
      let buffer = internals.random(size * 2);
      let pos = 0;
      while (digits.length < size) {
        if (pos >= buffer.length) {
          buffer = internals.random(size * 2);
          pos = 0;
        }
        if (buffer[pos] < 250) {
          digits.push(buffer[pos] % 10);
        }
        ++pos;
      }
      return digits.join("");
    };
    exports2.randomBits = function(bits) {
      if (!bits || bits < 0) {
        throw Boom.internal("Invalid random bits count");
      }
      const bytes = Math.ceil(bits / 8);
      return internals.random(bytes);
    };
    exports2.fixedTimeComparison = function(a, b) {
      try {
        return Crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
      } catch (err) {
        return false;
      }
    };
    internals.random = function(bytes) {
      try {
        return Crypto.randomBytes(bytes);
      } catch (err) {
        throw Boom.internal("Failed generating random bits: " + err.message);
      }
    };
  }
});

// node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/decoder.js"(exports2) {
    "use strict";
    var Stream = __require("node:stream");
    var internals = {
      decodeChars: [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        62,
        -1,
        -1,
        -1,
        63,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        -1,
        -1,
        -1,
        -1,
        -1
      ]
    };
    exports2.decode = function(buffer) {
      const decodeChars = internals.decodeChars;
      const len = buffer.length;
      const allocated = Math.ceil(len / 4) * 3;
      const result = Buffer.alloc(allocated);
      let c1;
      let c2;
      let c3;
      let c4;
      let j = 0;
      for (let i2 = 0; i2 < len; ) {
        do {
          c1 = decodeChars[buffer[i2++] & 255];
        } while (i2 < len && c1 === -1);
        if (c1 === -1) {
          break;
        }
        do {
          c2 = decodeChars[buffer[i2++] & 255];
        } while (i2 < len && c2 === -1);
        if (c2 === -1) {
          break;
        }
        result[j++] = c1 << 2 | (c2 & 48) >> 4;
        do {
          c3 = buffer[i2++] & 255;
          if (c3 === 61) {
            return result.slice(0, j);
          }
          c3 = decodeChars[c3];
        } while (i2 < len && c3 === -1);
        if (c3 === -1) {
          break;
        }
        result[j++] = (c2 & 15) << 4 | (c3 & 60) >> 2;
        do {
          c4 = buffer[i2++] & 255;
          if (c4 === 61) {
            return result.slice(0, j);
          }
          c4 = decodeChars[c4];
        } while (i2 < len && c4 === -1);
        if (c4 !== -1) {
          result[j++] = (c3 & 3) << 6 | c4;
        }
      }
      return j === allocated ? result : result.slice(0, j);
    };
    exports2.Decoder = class Decoder extends Stream.Transform {
      constructor() {
        super();
        this._reminder = null;
      }
      _transform(chunk, encoding, callback) {
        let part = this._reminder ? Buffer.concat([
          this._reminder,
          chunk
        ]) : chunk;
        const remaining = part.length % 4;
        if (remaining) {
          this._reminder = part.slice(part.length - remaining);
          part = part.slice(0, part.length - remaining);
        } else {
          this._reminder = null;
        }
        this.push(exports2.decode(part));
        return callback();
      }
      _flush(callback) {
        if (this._reminder) {
          this.push(exports2.decode(this._reminder));
        }
        return callback();
      }
    };
  }
});

// node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/encoder.js"(exports2) {
    "use strict";
    var Stream = __require("node:stream");
    exports2.encode = function(buffer) {
      return Buffer.from(buffer.toString("base64"));
    };
    exports2.Encoder = class Encoder extends Stream.Transform {
      constructor() {
        super();
        this._reminder = null;
      }
      _transform(chunk, encoding, callback) {
        let part = this._reminder ? Buffer.concat([
          this._reminder,
          chunk
        ]) : chunk;
        const remaining = part.length % 3;
        if (remaining) {
          this._reminder = part.slice(part.length - remaining);
          part = part.slice(0, part.length - remaining);
        } else {
          this._reminder = null;
        }
        this.push(exports2.encode(part));
        return callback();
      }
      _flush(callback) {
        if (this._reminder) {
          this.push(exports2.encode(this._reminder));
        }
        return callback();
      }
    };
  }
});

// node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/.deno/@hapi+b64@6.0.1/node_modules/@hapi/b64/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Decoder4 = require_decoder();
    var Encoder4 = require_encoder();
    exports2.decode = Decoder4.decode;
    exports2.encode = Encoder4.encode;
    exports2.Decoder = Decoder4.Decoder;
    exports2.Encoder = Encoder4.Encoder;
    exports2.base64urlEncode = function(value, encoding) {
      Hoek.assert(typeof value === "string" || Buffer.isBuffer(value), "value must be string or buffer");
      const buf2 = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || "binary");
      return buf2.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    };
    exports2.base64urlDecode = function(value, encoding) {
      if (typeof value !== "string") {
        throw new Error("Value not a string");
      }
      if (!/^[\w\-]*$/.test(value)) {
        throw new Error("Invalid character");
      }
      const buf2 = Buffer.from(value, "base64");
      return encoding === "buffer" ? buf2 : buf2.toString(encoding || "binary");
    };
  }
});

// node_modules/.deno/@hapi+iron@7.0.1/node_modules/@hapi/iron/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/.deno/@hapi+iron@7.0.1/node_modules/@hapi/iron/lib/index.js"(exports2) {
    "use strict";
    var Crypto = __require("node:crypto");
    var B64 = require_lib17();
    var Boom = require_lib6();
    var Bourne = require_lib15();
    var Cryptiles = require_lib16();
    var Hoek = require_lib();
    var internals = {};
    exports2.defaults = {
      encryption: {
        saltBits: 256,
        algorithm: "aes-256-cbc",
        iterations: 1,
        minPasswordlength: 32
      },
      integrity: {
        saltBits: 256,
        algorithm: "sha256",
        iterations: 1,
        minPasswordlength: 32
      },
      ttl: 0,
      timestampSkewSec: 60,
      localtimeOffsetMsec: 0
      // Local clock time offset express in a number of milliseconds (positive or negative)
    };
    exports2.algorithms = {
      "aes-128-ctr": {
        keyBits: 128,
        ivBits: 128
      },
      "aes-256-cbc": {
        keyBits: 256,
        ivBits: 128
      },
      "sha256": {
        keyBits: 256
      }
    };
    exports2.macFormatVersion = "2";
    exports2.macPrefix = "Fe26." + exports2.macFormatVersion;
    exports2.generateKey = async function(password, options3) {
      if (!password) {
        throw new Boom.Boom("Empty password");
      }
      if (!options3 || typeof options3 !== "object") {
        throw new Boom.Boom("Bad options");
      }
      const algorithm = exports2.algorithms[options3.algorithm];
      if (!algorithm) {
        throw new Boom.Boom("Unknown algorithm: " + options3.algorithm);
      }
      const result = {};
      if (Buffer.isBuffer(password)) {
        if (password.length < algorithm.keyBits / 8) {
          throw new Boom.Boom("Key buffer (password) too small");
        }
        result.key = password;
        result.salt = "";
      } else {
        if (password.length < options3.minPasswordlength) {
          throw new Boom.Boom("Password string too short (min " + options3.minPasswordlength + " characters required)");
        }
        let salt = options3.salt;
        if (!salt) {
          if (!options3.saltBits) {
            throw new Boom.Boom("Missing salt and saltBits options");
          }
          const randomSalt = Cryptiles.randomBits(options3.saltBits);
          salt = randomSalt.toString("hex");
        }
        const derivedKey = await internals.pbkdf2(password, salt, options3.iterations, algorithm.keyBits / 8, "sha1");
        result.key = derivedKey;
        result.salt = salt;
      }
      if (options3.iv) {
        result.iv = options3.iv;
      } else if (algorithm.ivBits) {
        result.iv = Cryptiles.randomBits(algorithm.ivBits);
      }
      return result;
    };
    exports2.encrypt = async function(password, options3, data) {
      const key = await exports2.generateKey(password, options3);
      const cipher = Crypto.createCipheriv(options3.algorithm, key.key, key.iv);
      const encrypted = Buffer.concat([
        cipher.update(data, "utf8"),
        cipher.final()
      ]);
      return {
        encrypted,
        key
      };
    };
    exports2.decrypt = async function(password, options3, data) {
      const key = await exports2.generateKey(password, options3);
      const decipher = Crypto.createDecipheriv(options3.algorithm, key.key, key.iv);
      let dec = decipher.update(data, null, "utf8");
      dec = dec + decipher.final("utf8");
      return dec;
    };
    exports2.hmacWithPassword = async function(password, options3, data) {
      const key = await exports2.generateKey(password, options3);
      const hmac = Crypto.createHmac(options3.algorithm, key.key).update(data);
      const digest = hmac.digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      return {
        digest,
        salt: key.salt
      };
    };
    internals.normalizePassword = function(password) {
      if (password && typeof password === "object" && !Buffer.isBuffer(password)) {
        return {
          id: password.id,
          encryption: password.secret ?? password.encryption,
          integrity: password.secret ?? password.integrity
        };
      }
      return {
        encryption: password,
        integrity: password
      };
    };
    exports2.seal = async function(object2, password, options3) {
      options3 = Object.assign({}, options3);
      const now = Date.now() + (options3.localtimeOffsetMsec ?? 0);
      const objectString = internals.stringify(object2);
      let passwordId = "";
      password = internals.normalizePassword(password);
      if (password.id) {
        if (!/^\w+$/.test(password.id)) {
          throw new Boom.Boom("Invalid password id");
        }
        passwordId = password.id;
      }
      const { encrypted, key } = await exports2.encrypt(password.encryption, options3.encryption, objectString);
      const encryptedB64 = B64.base64urlEncode(encrypted);
      const iv = B64.base64urlEncode(key.iv);
      const expiration = options3.ttl ? now + options3.ttl : "";
      const macBaseString = exports2.macPrefix + "*" + passwordId + "*" + key.salt + "*" + iv + "*" + encryptedB64 + "*" + expiration;
      const mac = await exports2.hmacWithPassword(password.integrity, options3.integrity, macBaseString);
      const sealed = macBaseString + "*" + mac.salt + "*" + mac.digest;
      return sealed;
    };
    exports2.unseal = async function(sealed, password, options3) {
      options3 = Object.assign({}, options3);
      const now = Date.now() + (options3.localtimeOffsetMsec ?? 0);
      const parts = sealed.split("*");
      if (parts.length !== 8) {
        throw new Boom.Boom("Incorrect number of sealed components");
      }
      const macPrefix = parts[0];
      const passwordId = parts[1];
      const encryptionSalt = parts[2];
      const encryptionIv = parts[3];
      const encryptedB64 = parts[4];
      const expiration = parts[5];
      const hmacSalt = parts[6];
      const hmac = parts[7];
      const macBaseString = macPrefix + "*" + passwordId + "*" + encryptionSalt + "*" + encryptionIv + "*" + encryptedB64 + "*" + expiration;
      if (macPrefix !== exports2.macPrefix) {
        throw new Boom.Boom("Wrong mac prefix");
      }
      if (expiration) {
        if (!expiration.match(/^\d+$/)) {
          throw new Boom.Boom("Invalid expiration");
        }
        const exp = parseInt(expiration, 10);
        if (exp <= now - options3.timestampSkewSec * 1e3) {
          throw new Boom.Boom("Expired seal");
        }
      }
      if (!password) {
        throw new Boom.Boom("Empty password");
      }
      if (typeof password === "object" && !Buffer.isBuffer(password)) {
        password = password[passwordId || "default"];
        if (!password) {
          throw new Boom.Boom("Cannot find password: " + passwordId);
        }
      }
      password = internals.normalizePassword(password);
      const macOptions = Hoek.clone(options3.integrity);
      macOptions.salt = hmacSalt;
      const mac = await exports2.hmacWithPassword(password.integrity, macOptions, macBaseString);
      if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw new Boom.Boom("Bad hmac value");
      }
      try {
        var encrypted = B64.base64urlDecode(encryptedB64, "buffer");
      } catch (err) {
        throw Boom.boomify(err);
      }
      const decryptOptions = Hoek.clone(options3.encryption);
      decryptOptions.salt = encryptionSalt;
      try {
        decryptOptions.iv = B64.base64urlDecode(encryptionIv, "buffer");
      } catch (err) {
        throw Boom.boomify(err);
      }
      const decrypted = await exports2.decrypt(password.encryption, decryptOptions, encrypted);
      try {
        return Bourne.parse(decrypted);
      } catch (err) {
        throw new Boom.Boom("Failed parsing sealed object JSON: " + err.message);
      }
    };
    internals.stringify = function(object2) {
      try {
        return JSON.stringify(object2);
      } catch (err) {
        throw new Boom.Boom("Failed to stringify object: " + err.message);
      }
    };
    internals.pbkdf2 = function(...args) {
      return new Promise((resolve7, reject) => {
        const next = (err, result) => {
          if (err) {
            return reject(Boom.boomify(err));
          }
          resolve7(result);
        };
        args.push(next);
        Crypto.pbkdf2(...args);
      });
    };
  }
});

// node_modules/.deno/@hapi+statehood@8.2.0/node_modules/@hapi/statehood/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/.deno/@hapi+statehood@8.2.0/node_modules/@hapi/statehood/lib/index.js"(exports2) {
    "use strict";
    var Querystring = __require("node:querystring");
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Bourne = require_lib15();
    var Cryptiles = require_lib16();
    var Hoek = require_lib();
    var Iron = require_lib18();
    var Validate = require_lib3();
    var internals = {
      macPrefix: "hapi.signed.cookie.1"
    };
    internals.schema = Validate.object({
      strictHeader: Validate.boolean(),
      ignoreErrors: Validate.boolean(),
      isSecure: Validate.boolean(),
      isHttpOnly: Validate.boolean(),
      isPartitioned: Validate.boolean(),
      isSameSite: Validate.valid("Strict", "Lax", "None", false),
      path: Validate.string().allow(null),
      domain: Validate.string().allow(null),
      ttl: Validate.number().allow(null),
      encoding: Validate.string().valid("base64json", "base64", "form", "iron", "none"),
      sign: Validate.object({
        password: [
          Validate.string(),
          Validate.binary(),
          Validate.object()
        ],
        integrity: Validate.object()
      }),
      iron: Validate.object(),
      password: [
        Validate.string(),
        Validate.binary(),
        Validate.object()
      ],
      contextualize: Validate.function(),
      // Used by hapi
      clearInvalid: Validate.boolean(),
      autoValue: Validate.any(),
      passThrough: Validate.boolean()
    });
    internals.defaults = {
      strictHeader: true,
      ignoreErrors: false,
      isSecure: true,
      isHttpOnly: true,
      isPartitioned: false,
      isSameSite: "Strict",
      path: null,
      domain: null,
      ttl: null,
      encoding: "none"
      // options: 'base64json', 'base64', 'form', 'iron', 'none'
    };
    internals.validateRx = {
      nameRx: {
        strict: /^[^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+$/,
        loose: /^[^=\s]*$/
      },
      valueRx: {
        strict: /^[^\x00-\x20\"\,\;\\\x7F]*$/,
        loose: /^(?:"([^\"]*)")|(?:[^\;]*)$/
      },
      domainRx: /^\.?[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d]))(?:\.[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d])))*$/,
      domainLabelLenRx: /^\.?[a-z\d\-]{1,63}(?:\.[a-z\d\-]{1,63})*$/,
      pathRx: /^\/[^\x00-\x1F\;]*$/
    };
    internals.pairsRx = /\s*([^=\s]*)\s*=\s*([^\;]*)(?:(?:;\s*)|$)/g;
    exports2.Definitions = class {
      constructor(options3) {
        this.settings = Hoek.applyToDefaults(internals.defaults, options3 ?? {});
        Validate.assert(this.settings, internals.schema, "Invalid state definition defaults");
        this.cookies = {};
        this.names = [];
      }
      add(name, options3) {
        Hoek.assert(name && typeof name === "string", "Invalid name");
        Hoek.assert(!this.cookies[name], "State already defined:", name);
        const settings = Hoek.applyToDefaults(this.settings, options3 ?? {}, {
          nullOverride: true
        });
        Validate.assert(settings, internals.schema, "Invalid state definition: " + name);
        this.cookies[name] = settings;
        this.names.push(name);
      }
      async parse(cookies) {
        const state = {};
        const names = [];
        const verify = internals.parsePairs(cookies, (name, value) => {
          if (name === "__proto__") {
            throw Boom.badRequest("Invalid cookie header");
          }
          if (state[name]) {
            if (!Array.isArray(state[name])) {
              state[name] = [
                state[name]
              ];
            }
            state[name].push(value);
          } else {
            state[name] = value;
            names.push(name);
          }
        });
        const failed = [];
        if (verify !== null) {
          if (!this.settings.ignoreErrors) {
            throw Boom.badRequest("Invalid cookie header");
          }
          failed.push({
            settings: this.settings,
            reason: `Header contains unexpected syntax: ${verify}`
          });
        }
        const errored = [];
        const record2 = (reason, name, value, definition) => {
          const details = {
            name,
            value,
            settings: definition,
            reason: typeof reason === "string" ? reason : reason.message
          };
          failed.push(details);
          if (!definition.ignoreErrors) {
            errored.push(details);
          }
        };
        const parsed = {};
        for (const name of names) {
          const value = state[name];
          const definition = this.cookies[name] ?? this.settings;
          if (definition.strictHeader) {
            const reason = internals.validate(name, state);
            if (reason) {
              record2(reason, name, value, definition);
              continue;
            }
          }
          if (definition.encoding === "none") {
            parsed[name] = value;
            continue;
          }
          if (!Array.isArray(value)) {
            try {
              const unsigned = await internals.unsign(name, value, definition);
              const result = await internals.decode(unsigned, definition);
              parsed[name] = result;
            } catch (err) {
              Bounce.rethrow(err, "system");
              record2(err, name, value, definition);
            }
            continue;
          }
          const arrayResult = [];
          for (const arrayValue of value) {
            try {
              const unsigned = await internals.unsign(name, arrayValue, definition);
              const result = await internals.decode(unsigned, definition);
              arrayResult.push(result);
            } catch (err) {
              Bounce.rethrow(err, "system");
              record2(err, name, value, definition);
            }
          }
          parsed[name] = arrayResult;
        }
        if (errored.length) {
          const error40 = Boom.badRequest("Invalid cookie value", errored);
          error40.states = parsed;
          error40.failed = failed;
          throw error40;
        }
        return {
          states: parsed,
          failed
        };
      }
      async format(cookies, context) {
        if (!cookies || Array.isArray(cookies) && !cookies.length) {
          return [];
        }
        if (!Array.isArray(cookies)) {
          cookies = [
            cookies
          ];
        }
        const header = [];
        for (let i2 = 0; i2 < cookies.length; ++i2) {
          const cookie = cookies[i2];
          const base4 = this.cookies[cookie.name] ?? this.settings;
          let definition = cookie.options ? Hoek.applyToDefaults(base4, cookie.options, {
            nullOverride: true
          }) : base4;
          if (definition.contextualize) {
            if (definition === base4) {
              definition = Hoek.clone(definition);
            }
            await definition.contextualize(definition, context);
          }
          const nameRx = definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose;
          if (!nameRx.test(cookie.name)) {
            throw Boom.badImplementation("Invalid cookie name: " + cookie.name);
          }
          const value = await exports2.prepareValue(cookie.name, cookie.value, definition);
          const valueRx = definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose;
          if (value && (typeof value !== "string" || !value.match(valueRx))) {
            throw Boom.badImplementation("Invalid cookie value: " + cookie.value);
          }
          let segment = cookie.name + "=" + (value || "");
          if (definition.ttl !== null && definition.ttl !== void 0) {
            const expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);
            segment = segment + "; Max-Age=" + Math.floor(definition.ttl / 1e3) + "; Expires=" + expires.toUTCString();
          }
          if (definition.isSecure) {
            segment = segment + "; Secure";
          }
          if (definition.isHttpOnly) {
            segment = segment + "; HttpOnly";
          }
          if (definition.isSameSite) {
            segment = `${segment}; SameSite=${definition.isSameSite}`;
          }
          if (definition.isPartitioned) {
            if (!definition.isSecure) {
              throw Boom.badImplementation("Partitioned cookies must be secure");
            }
            if (definition.isSameSite !== "None") {
              throw Boom.badImplementation("Partitioned cookies must have SameSite=None");
            }
            segment = `${segment}; Partitioned`;
          }
          if (definition.domain) {
            const domain2 = definition.domain.toLowerCase();
            if (!domain2.match(internals.validateRx.domainLabelLenRx)) {
              throw Boom.badImplementation("Cookie domain too long: " + definition.domain);
            }
            if (!domain2.match(internals.validateRx.domainRx)) {
              throw Boom.badImplementation("Invalid cookie domain: " + definition.domain);
            }
            segment = segment + "; Domain=" + domain2;
          }
          if (definition.path) {
            if (!definition.path.match(internals.validateRx.pathRx)) {
              throw Boom.badImplementation("Invalid cookie path: " + definition.path);
            }
            segment = segment + "; Path=" + definition.path;
          }
          header.push(segment);
        }
        return header;
      }
      passThrough(header, fallback) {
        if (!this.names.length) {
          return header;
        }
        const exclude = [];
        for (let i2 = 0; i2 < this.names.length; ++i2) {
          const name = this.names[i2];
          const definition = this.cookies[name];
          const passCookie = definition.passThrough !== void 0 ? definition.passThrough : fallback;
          if (!passCookie) {
            exclude.push(name);
          }
        }
        return exports2.exclude(header, exclude);
      }
    };
    internals.parsePairs = function(cookies, eachPairFn) {
      let index = 0;
      while (index < cookies.length) {
        const eqIndex = cookies.indexOf("=", index);
        if (eqIndex === -1) {
          return cookies.slice(index);
        }
        const semiIndex = cookies.indexOf(";", eqIndex);
        const endOfValueIndex = semiIndex !== -1 ? semiIndex : cookies.length;
        const name = cookies.slice(index, eqIndex).trim();
        const value = cookies.slice(eqIndex + 1, endOfValueIndex).trim();
        const unquotedValue = value.startsWith('"') && value.endsWith('"') && value !== '"' ? value.slice(1, -1) : value;
        eachPairFn(name, unquotedValue);
        index = endOfValueIndex + 1;
      }
      return null;
    };
    internals.validate = function(name, state) {
      if (!name.match(internals.validateRx.nameRx.strict)) {
        return "Invalid cookie name";
      }
      const values = [].concat(state[name]);
      for (let i2 = 0; i2 < values.length; ++i2) {
        if (!values[i2].match(internals.validateRx.valueRx.strict)) {
          return "Invalid cookie value";
        }
      }
      return null;
    };
    internals.unsign = async function(name, value, definition) {
      if (!definition.sign) {
        return value;
      }
      const pos = value.lastIndexOf(".");
      if (pos === -1) {
        throw Boom.badRequest("Missing signature separator");
      }
      const unsigned = value.slice(0, pos);
      const sig = value.slice(pos + 1);
      if (!sig) {
        throw Boom.badRequest("Missing signature");
      }
      const sigParts = sig.split("*");
      if (sigParts.length !== 2) {
        throw Boom.badRequest("Invalid signature format");
      }
      const hmacSalt = sigParts[0];
      const hmac = sigParts[1];
      const macOptions = Hoek.clone(definition.sign.integrity ?? Iron.defaults.integrity);
      macOptions.salt = hmacSalt;
      const mac = await Iron.hmacWithPassword(definition.sign.password, macOptions, [
        internals.macPrefix,
        name,
        unsigned
      ].join("\n"));
      if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw Boom.badRequest("Invalid hmac value");
      }
      return unsigned;
    };
    internals.decode = async function(value, definition) {
      if (!value && definition.encoding === "form") {
        return {};
      }
      Hoek.assert(typeof value === "string", "Invalid string");
      if (definition.encoding === "iron") {
        return await Iron.unseal(value, definition.password, definition.iron ?? Iron.defaults);
      }
      if (definition.encoding === "base64json") {
        const decoded = Buffer.from(value, "base64").toString("binary");
        try {
          return Bourne.parse(decoded);
        } catch (err) {
          throw Boom.badRequest("Invalid JSON payload");
        }
      }
      if (definition.encoding === "base64") {
        return Buffer.from(value, "base64").toString("binary");
      }
      return Querystring.parse(value);
    };
    exports2.prepareValue = async function(name, value, options3) {
      Hoek.assert(options3 && typeof options3 === "object", "Missing or invalid options");
      try {
        const encoded = await internals.encode(value, options3);
        const signed = await internals.sign(name, encoded, options3.sign);
        return signed;
      } catch (err) {
        throw Boom.badImplementation("Failed to encode cookie (" + name + ") value: " + err.message);
      }
    };
    internals.encode = function(value, options3) {
      if (value === void 0 || options3.encoding === "none") {
        return value;
      }
      if (options3.encoding === "iron") {
        return Iron.seal(value, options3.password, options3.iron ?? Iron.defaults);
      }
      if (options3.encoding === "base64") {
        return Buffer.from(value, "binary").toString("base64");
      }
      if (options3.encoding === "base64json") {
        const stringified = JSON.stringify(value);
        return Buffer.from(stringified, "binary").toString("base64");
      }
      return Querystring.stringify(value);
    };
    internals.sign = async function(name, value, options3) {
      if (value === void 0 || !options3) {
        return value;
      }
      const mac = await Iron.hmacWithPassword(options3.password, options3.integrity ?? Iron.defaults.integrity, [
        internals.macPrefix,
        name,
        value
      ].join("\n"));
      const signed = value + "." + mac.salt + "*" + mac.digest;
      return signed;
    };
    exports2.exclude = function(cookies, excludes) {
      let result = "";
      const verify = cookies.replace(internals.pairsRx, ($0, $1, $2) => {
        if (excludes.indexOf($1) === -1) {
          result = result + (result ? ";" : "") + $1 + "=" + $2;
        }
        return "";
      });
      return verify === "" ? result : Boom.badRequest("Invalid cookie header");
    };
  }
});

// node_modules/.deno/@hapi+content@6.0.0/node_modules/@hapi/content/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/.deno/@hapi+content@6.0.0/node_modules/@hapi/content/lib/index.js"(exports2) {
    "use strict";
    var Boom = require_lib6();
    var internals = {};
    internals.contentTypeRegex = /^([^\/\s]+\/[^\s;]+)(.*)?$/;
    internals.charsetParamRegex = /;\s*charset=(?:"([^"]+)"|([^;"\s]+))/i;
    internals.boundaryParamRegex = /;\s*boundary=(?:"([^"]+)"|([^;"\s]+))/i;
    exports2.type = function(header) {
      if (!header) {
        throw Boom.badRequest("Invalid content-type header");
      }
      const match = header.match(internals.contentTypeRegex);
      if (!match) {
        throw Boom.badRequest("Invalid content-type header");
      }
      const result = {
        mime: match[1].toLowerCase()
      };
      const params = match[2];
      if (params) {
        const param = params.match(internals.charsetParamRegex);
        if (param) {
          result.charset = (param[1] || param[2]).toLowerCase();
        }
      }
      if (result.mime.indexOf("multipart/") === 0) {
        if (params) {
          const param = params.match(internals.boundaryParamRegex);
          if (param) {
            result.boundary = param[1] || param[2];
          }
        }
        if (!result.boundary) {
          throw Boom.badRequest("Invalid content-type header: multipart missing boundary");
        }
      }
      return result;
    };
    internals.contentDispositionRegex = /^\s*form-data\s*(?:;\s*(.+))?$/i;
    internals.contentDispositionParamRegex = /([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;'"\s]+\'[\w-]*\'[^;\s]+)|(?:\"([^"]*)\")|([^;\s]*))(?:\s*(?:;\s*)|$)/g;
    exports2.disposition = function(header) {
      if (!header) {
        throw Boom.badRequest("Missing content-disposition header");
      }
      const match = header.match(internals.contentDispositionRegex);
      if (!match) {
        throw Boom.badRequest("Invalid content-disposition header format");
      }
      const parameters = match[1];
      if (!parameters) {
        throw Boom.badRequest("Invalid content-disposition header missing parameters");
      }
      const result = {};
      parameters.replace(internals.contentDispositionParamRegex, ($0, $1, $2, $3, $4, $5) => {
        if ($1 === "__proto__") {
          throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
        let value;
        if ($2) {
          if (!$3) {
            throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
          }
          try {
            value = decodeURIComponent($3.split("'")[2]);
          } catch (err) {
            throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
          }
        } else {
          value = $4 || $5 || "";
        }
        if ($1 === "name" && value === "__proto__") {
          throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
        result[$1] = value;
      });
      if (!result.name) {
        throw Boom.badRequest("Invalid content-disposition header missing name parameter");
      }
      return result;
    };
  }
});

// node_modules/.deno/@hapi+file@3.0.0/node_modules/@hapi/file/lib/index.js
var require_lib21 = __commonJS({
  "node_modules/.deno/@hapi+file@3.0.0/node_modules/@hapi/file/lib/index.js"(exports2) {
    "use strict";
    var Crypto = __require("node:crypto");
    var Path = __require("node:path");
    exports2.uniqueFilename = function(path, extension) {
      if (extension) {
        extension = extension[0] !== "." ? "." + extension : extension;
      } else {
        extension = "";
      }
      path = Path.resolve(path);
      const name = [
        Date.now(),
        process.pid,
        Crypto.randomBytes(8).toString("hex")
      ].join("-") + extension;
      return Path.join(path, name);
    };
  }
});

// node_modules/.deno/@hapi+vise@5.0.1/node_modules/@hapi/vise/lib/index.js
var require_lib22 = __commonJS({
  "node_modules/.deno/@hapi+vise@5.0.1/node_modules/@hapi/vise/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    exports2.Vise = class Vise {
      constructor(chunks) {
        this.length = 0;
        this._chunks = [];
        this._offset = 0;
        if (chunks) {
          chunks = [].concat(chunks);
          for (let i2 = 0; i2 < chunks.length; ++i2) {
            this.push(chunks[i2]);
          }
        }
      }
      push(chunk) {
        Hoek.assert(Buffer.isBuffer(chunk), "Chunk must be a buffer");
        const item = {
          data: chunk,
          length: chunk.length,
          offset: this.length + this._offset,
          index: this._chunks.length
        };
        this._chunks.push(item);
        this.length += chunk.length;
      }
      shift(length4) {
        if (!length4) {
          return [];
        }
        const prevOffset = this._offset;
        const item = this.#chunkAt(length4);
        let dropTo = this._chunks.length;
        this._offset = 0;
        if (item) {
          dropTo = item.chunk.index;
          this._offset = item.offset;
        }
        const chunks = [];
        for (let i2 = 0; i2 < dropTo; ++i2) {
          const chunk = this._chunks.shift();
          if (i2 === 0 && prevOffset) {
            chunks.push(chunk.data.slice(prevOffset));
          } else {
            chunks.push(chunk.data);
          }
        }
        if (this._offset) {
          chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));
        }
        this.length = 0;
        for (let i2 = 0; i2 < this._chunks.length; ++i2) {
          const chunk = this._chunks[i2];
          chunk.offset = this.length, chunk.index = i2;
          this.length += chunk.length;
        }
        this.length -= this._offset;
        return chunks;
      }
      readUInt8(pos) {
        const item = this.#chunkAt(pos);
        return item ? item.chunk.data[item.offset] : void 0;
      }
      at(pos) {
        return this.readUInt8(pos);
      }
      #chunkAt(pos) {
        if (pos < 0) {
          return null;
        }
        pos = pos + this._offset;
        for (let i2 = 0; i2 < this._chunks.length; ++i2) {
          const chunk = this._chunks[i2];
          const offset = pos - chunk.offset;
          if (offset < chunk.length) {
            return {
              chunk,
              offset
            };
          }
        }
        return null;
      }
      chunks() {
        const chunks = [];
        for (let i2 = 0; i2 < this._chunks.length; ++i2) {
          const chunk = this._chunks[i2];
          if (i2 === 0 && this._offset) {
            chunks.push(chunk.data.slice(this._offset));
          } else {
            chunks.push(chunk.data);
          }
        }
        return chunks;
      }
      startsWith(value, pos, length4) {
        pos = pos ?? 0;
        length4 = length4 ? Math.min(value.length, length4) : value.length;
        if (pos + length4 > this.length) {
          return false;
        }
        const start = this.#chunkAt(pos);
        if (!start) {
          return false;
        }
        let j = start.chunk.index;
        for (let i2 = 0; j < this._chunks.length && i2 < length4; ++j) {
          const chunk = this._chunks[j];
          let k = j === start.chunk.index ? start.offset : 0;
          for (; k < chunk.length && i2 < length4; ++k, ++i2) {
            if (chunk.data[k] !== value[i2]) {
              return false;
            }
          }
        }
        return true;
      }
    };
  }
});

// node_modules/.deno/@hapi+nigel@5.0.1/node_modules/@hapi/nigel/lib/index.js
var require_lib23 = __commonJS({
  "node_modules/.deno/@hapi+nigel@5.0.1/node_modules/@hapi/nigel/lib/index.js"(exports2) {
    "use strict";
    var Stream = __require("node:stream");
    var Hoek = require_lib();
    var { Vise } = require_lib22();
    var internals = {};
    exports2.compile = function(needle) {
      Hoek.assert(needle?.length, "Missing needle");
      Hoek.assert(Buffer.isBuffer(needle), "Needle must be a buffer");
      const profile = {
        value: needle,
        lastPos: needle.length - 1,
        last: needle[needle.length - 1],
        length: needle.length,
        badCharShift: Buffer.alloc(256)
        // Lookup table of how many characters can be skipped for each match
      };
      for (let i2 = 0; i2 < 256; ++i2) {
        profile.badCharShift[i2] = profile.length;
      }
      const last = profile.length - 1;
      for (let i2 = 0; i2 < last; ++i2) {
        profile.badCharShift[profile.value[i2]] = last - i2;
      }
      return profile;
    };
    exports2.horspool = function(haystack, needle, start) {
      Hoek.assert(haystack, "Missing haystack");
      needle = needle.badCharShift ? needle : exports2.compile(needle);
      start = start ?? 0;
      for (let i2 = start; i2 <= haystack.length - needle.length; ) {
        const lastChar = haystack.readUInt8(i2 + needle.lastPos);
        if (lastChar === needle.last && internals.startsWith(haystack, needle, i2)) {
          return i2;
        }
        i2 += needle.badCharShift[lastChar];
      }
      return -1;
    };
    internals.startsWith = function(haystack, needle, pos) {
      if (haystack.startsWith) {
        return haystack.startsWith(needle.value, pos, needle.lastPos);
      }
      for (let i2 = 0; i2 < needle.lastPos; ++i2) {
        if (needle.value[i2] !== haystack.readUInt8(pos + i2)) {
          return false;
        }
      }
      return true;
    };
    exports2.all = function(haystack, needle, start) {
      needle = exports2.compile(needle);
      start = start ?? 0;
      const matches = [];
      for (let i2 = start; i2 !== -1 && i2 < haystack.length; ) {
        i2 = exports2.horspool(haystack, needle, i2);
        if (i2 !== -1) {
          matches.push(i2);
          i2 += needle.length;
        }
      }
      return matches;
    };
    internals._indexOf = function(haystack, needle) {
      Hoek.assert(haystack, "Missing haystack");
      for (let i2 = 0; i2 <= haystack.length - needle.length; ++i2) {
        if (haystack.startsWith(needle.value, i2)) {
          return i2;
        }
      }
      return -1;
    };
    exports2.Stream = class extends Stream.Writable {
      constructor(needle) {
        super();
        this.needle(needle);
        this._haystack = new Vise();
        this._indexOf = this._needle.length > 2 ? exports2.horspool : internals._indexOf;
        this.on("finish", () => {
          const chunks = this._haystack.chunks();
          for (let i2 = 0; i2 < chunks.length; ++i2) {
            this.emit("haystack", chunks[i2]);
          }
        });
      }
      needle(needle) {
        this._needle = exports2.compile(needle);
      }
      _write(chunk, encoding, next) {
        this._haystack.push(chunk);
        let match = this._indexOf(this._haystack, this._needle);
        if (match === -1 && chunk.length >= this._needle.length) {
          this._flush(this._haystack.length - chunk.length);
        }
        while (match !== -1) {
          this._flush(match);
          this._haystack.shift(this._needle.length);
          this.emit("needle");
          match = this._indexOf(this._haystack, this._needle);
        }
        if (this._haystack.length) {
          const notChecked = this._haystack.length - this._needle.length + 1;
          let i2 = notChecked;
          for (; i2 < this._haystack.length; ++i2) {
            if (this._haystack.startsWith(this._needle.value, i2, this._haystack.length - i2)) {
              break;
            }
          }
          this._flush(i2);
        }
        return next();
      }
      _flush(pos) {
        const chunks = this._haystack.shift(pos);
        for (let i2 = 0; i2 < chunks.length; ++i2) {
          this.emit("haystack", chunks[i2]);
        }
      }
      flush() {
        const chunks = this._haystack.shift(this._haystack.length);
        for (let i2 = 0; i2 < chunks.length; ++i2) {
          this.emit("haystack", chunks[i2]);
        }
      }
    };
  }
});

// node_modules/.deno/@hapi+pez@6.1.0/node_modules/@hapi/pez/lib/index.js
var require_lib24 = __commonJS({
  "node_modules/.deno/@hapi+pez@6.1.0/node_modules/@hapi/pez/lib/index.js"(exports2) {
    "use strict";
    var Stream = __require("node:stream");
    var B64 = require_lib17();
    var Boom = require_lib6();
    var Content = require_lib20();
    var Hoek = require_lib();
    var Nigel = require_lib23();
    var internals = {};
    internals.state = {
      preamble: 0,
      boundary: 1,
      header: 2,
      payload: 3,
      epilogue: 4
    };
    internals.defaults = {
      maxBytes: Infinity,
      maxParts: Infinity
    };
    exports2.Dispenser = class extends Stream.Writable {
      constructor(options3) {
        super({
          autoDestroy: false
        });
        Hoek.assert(options3 !== null && typeof options3 === "object", "options must be an object");
        const settings = Hoek.applyToDefaults(internals.defaults, options3);
        this._boundary = settings.boundary;
        this._state = internals.state.preamble;
        this._held = "";
        this._stream = null;
        this._headers = {};
        this._name = "";
        this._pendingHeader = "";
        this._error = null;
        this._bytesCount = 0;
        this._partsCount = 0;
        this._maxBytes = settings.maxBytes;
        this._maxParts = settings.maxParts;
        this._parts = new Nigel.Stream(Buffer.from("--" + settings.boundary));
        this._lines = new Nigel.Stream(Buffer.from("\r\n"));
        this._parts.on("needle", () => this.#onPartEnd());
        this._parts.on("haystack", (chunk) => this.#onPart(chunk));
        this._lines.on("needle", () => this.#onLineEnd());
        this._lines.on("haystack", (chunk) => this.#onLine(chunk));
        this.once("finish", () => this._parts.end());
        this._parts.once("close", () => this._lines.end());
        let piper = null;
        let finish = (err) => {
          if (piper) {
            piper.removeListener("data", onReqData);
            piper.removeListener("error", finish);
            piper.removeListener("aborted", onReqAborted);
          }
          if (err) {
            return this.#abort(err);
          }
          this.#emit("close");
        };
        finish = Hoek.once(finish);
        this._lines.once("close", () => {
          if (this._state === internals.state.epilogue) {
            if (this._held) {
              this.#emit("epilogue", this._held);
              this._held = "";
            }
          } else if (this._state === internals.state.boundary) {
            if (!this._held) {
              this.#abort(Boom.badRequest("Missing end boundary"));
            } else if (this._held !== "--") {
              this.#abort(Boom.badRequest("Only white space allowed after boundary at end"));
            }
          } else {
            this.#abort(Boom.badRequest("Incomplete multipart payload"));
          }
          setImmediate(finish);
        });
        const onReqAborted = () => {
          finish(Boom.badRequest("Client request aborted"));
        };
        const onReqData = (data) => {
          this._bytesCount += Buffer.byteLength(data);
          if (this._bytesCount > this._maxBytes) {
            finish(Boom.entityTooLarge("Maximum size exceeded"));
          }
        };
        this.once("pipe", (req) => {
          piper = req;
          req.on("data", onReqData);
          req.once("error", finish);
          req.once("aborted", onReqAborted);
        });
      }
      _write(buffer, encoding, next) {
        if (this._error) {
          return next();
        }
        this._parts.write(buffer);
        return next();
      }
      #emit(...args) {
        if (this._error) {
          return;
        }
        this.emit(...args);
      }
      #abort(err) {
        this.#emit("error", err);
        this._error = err;
      }
      #onPartEnd() {
        this._lines.flush();
        if (this._state === internals.state.preamble) {
          if (this._held) {
            const last = this._held.length - 1;
            if (this._held[last] !== "\n" || this._held[last - 1] !== "\r") {
              return this.#abort(Boom.badRequest("Preamble missing CRLF terminator"));
            }
            this.#emit("preamble", this._held.slice(0, -2));
            this._held = "";
          }
          this._parts.needle(Buffer.from("\r\n--" + this._boundary));
        } else {
          this._partsCount++;
          if (this._partsCount > this._maxParts) {
            return this.#abort(Boom.badRequest("Maximum parts exceeded"));
          }
        }
        this._state = internals.state.boundary;
        if (this._stream) {
          this._stream.end();
          this._stream = null;
        } else if (this._name) {
          this.#emit("field", this._name, this._held);
          this._name = "";
          this._held = "";
        }
      }
      #onPart(chunk) {
        if (this._state === internals.state.preamble) {
          this._held = this._held + chunk.toString();
        } else if (this._state === internals.state.payload) {
          if (this._stream) {
            this._stream.write(chunk);
          } else {
            this._held = this._held + chunk.toString();
          }
        } else {
          this._lines.write(chunk);
        }
      }
      #onLineEnd() {
        if (this._state === internals.state.boundary) {
          if (this._held) {
            this._held = this._held.replace(/[\t ]/g, "");
            if (this._held) {
              if (this._held === "--") {
                this._state = internals.state.epilogue;
                this._held = "";
                return;
              }
              return this.#abort(Boom.badRequest("Only white space allowed after boundary"));
            }
          }
          this._state = internals.state.header;
          return;
        }
        if (this._state === internals.state.header) {
          if (this._held) {
            if (this._held[0] === " " || this._held[0] === "	") {
              if (!this._pendingHeader) {
                return this.#abort(Boom.badRequest("Invalid header continuation without valid declaration on previous line"));
              }
              this._pendingHeader = this._pendingHeader + " " + this._held.slice(1);
              this._held = "";
              return;
            }
            this.#flushHeader();
            this._pendingHeader = this._held;
            this._held = "";
            return;
          }
          this.#flushHeader();
          this._state = internals.state.payload;
          let disposition;
          try {
            disposition = Content.disposition(this._headers["content-disposition"]);
          } catch (err) {
            return this.#abort(err);
          }
          if (disposition.filename !== void 0) {
            const stream = new Stream.PassThrough();
            const transferEncoding = this._headers["content-transfer-encoding"];
            if (transferEncoding && transferEncoding.toLowerCase() === "base64") {
              this._stream = new B64.Decoder();
              this._stream.pipe(stream);
            } else {
              this._stream = stream;
            }
            stream.name = disposition.name;
            stream.filename = disposition.filename;
            stream.headers = this._headers;
            this._headers = {};
            this.#emit("part", stream);
          } else {
            this._name = disposition.name;
          }
          this._lines.flush();
          return;
        }
        this._held = this._held + "\r\n";
      }
      #onLine(chunk) {
        if (this._stream) {
          this._stream.write(chunk);
        } else {
          this._held = this._held + chunk.toString();
        }
      }
      #flushHeader() {
        if (!this._pendingHeader) {
          return;
        }
        const sep = this._pendingHeader.indexOf(":");
        if (sep === -1) {
          return this.#abort(Boom.badRequest("Invalid header missing colon separator"));
        }
        if (!sep) {
          return this.#abort(Boom.badRequest("Invalid header missing field name"));
        }
        const name = this._pendingHeader.slice(0, sep).toLowerCase();
        if (name === "__proto__") {
          return this.#abort(Boom.badRequest("Invalid header"));
        }
        this._headers[name] = this._pendingHeader.slice(sep + 1).trim();
        this._pendingHeader = "";
      }
    };
  }
});

// node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/payload.js
var require_payload = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/payload.js"(exports2, module2) {
    "use strict";
    var Stream = __require("node:stream");
    var internals = {};
    module2.exports = internals.Payload = class extends Stream.Readable {
      constructor(payload, encoding) {
        super();
        const data = [].concat(payload || "");
        let size = 0;
        for (let i2 = 0; i2 < data.length; ++i2) {
          const chunk = data[i2];
          size = size + chunk.length;
          data[i2] = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        this._data = Buffer.concat(data, size);
        this._position = 0;
        this._encoding = encoding || "utf8";
      }
      _read(size) {
        const chunk = this._data.slice(this._position, this._position + size);
        this.push(chunk, this._encoding);
        this._position = this._position + chunk.length;
        if (this._position >= this._data.length) {
          this.push(null);
        }
      }
    };
  }
});

// node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/recorder.js
var require_recorder = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/recorder.js"(exports2, module2) {
    "use strict";
    var Stream = __require("node:stream");
    var Boom = require_lib6();
    var internals = {};
    module2.exports = internals.Recorder = class extends Stream.Writable {
      constructor(options3) {
        super();
        this.settings = options3;
        this.buffers = [];
        this.length = 0;
      }
      _write(chunk, encoding, next) {
        if (this.settings.maxBytes && this.length + chunk.length > this.settings.maxBytes) {
          return this.emit("error", Boom.entityTooLarge("Payload content length greater than maximum allowed: " + this.settings.maxBytes));
        }
        this.length = this.length + chunk.length;
        this.buffers.push(chunk);
        next();
      }
      collect() {
        const buffer = this.buffers.length === 0 ? Buffer.alloc(0) : this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length);
        return buffer;
      }
    };
  }
});

// node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/tap.js
var require_tap = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/tap.js"(exports2, module2) {
    "use strict";
    var Stream = __require("node:stream");
    var Payload = require_payload();
    var internals = {};
    module2.exports = internals.Tap = class extends Stream.Transform {
      constructor() {
        super();
        this.buffers = [];
      }
      _transform(chunk, encoding, next) {
        this.buffers.push(chunk);
        next(null, chunk);
      }
      collect() {
        return new Payload(this.buffers);
      }
    };
  }
});

// node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/index.js
var require_lib25 = __commonJS({
  "node_modules/.deno/@hapi+wreck@18.1.0/node_modules/@hapi/wreck/lib/index.js"(exports2, module2) {
    "use strict";
    var Events2 = __require("node:events");
    var Http = __require("node:http");
    var Https = __require("node:https");
    var Stream = __require("node:stream");
    var Url2 = __require("node:url");
    var Zlib = __require("node:zlib");
    var Boom = require_lib6();
    var Bourne = require_lib15();
    var Hoek = require_lib();
    var Payload = require_payload();
    var Recorder = require_recorder();
    var Tap = require_tap();
    var internals = {
      jsonRegex: /^application\/([a-z0-9.]*[+-]json|json)$/,
      shallowOptions: [
        "agent",
        "agents",
        "beforeRedirect",
        "payload",
        "redirected"
      ],
      httpOptions: [
        "secureProtocol",
        "ciphers",
        "lookup",
        "family",
        "hints"
      ]
    };
    internals.Client = class {
      constructor(options3 = {}) {
        Hoek.assert(!options3.agents || options3.agents.https && options3.agents.http && options3.agents.httpsAllowUnauthorized, 'Option agents must include "http", "https", and "httpsAllowUnauthorized"');
        this._defaults = Hoek.clone(options3, {
          shallow: internals.shallowOptions
        });
        this.agents = this._defaults.agents || {
          https: new Https.Agent({
            maxSockets: Infinity
          }),
          http: new Http.Agent({
            maxSockets: Infinity
          }),
          httpsAllowUnauthorized: new Https.Agent({
            maxSockets: Infinity,
            rejectUnauthorized: false
          })
        };
        if (this._defaults.events) {
          this.events = new Events2.EventEmitter();
        }
      }
      defaults(options3) {
        Hoek.assert(options3 && typeof options3 === "object", "options must be provided to defaults");
        options3 = Hoek.applyToDefaults(this._defaults, options3, {
          shallow: internals.shallowOptions
        });
        return new internals.Client(options3);
      }
      request(method, url2, options3 = {}) {
        try {
          options3 = Hoek.applyToDefaults(this._defaults, options3, {
            shallow: internals.shallowOptions
          });
          Hoek.assert(options3.payload === void 0 || typeof options3.payload === "string" || typeof options3.payload === "object", "options.payload must be a string, a Buffer, a Stream, or an Object");
          Hoek.assert(internals.isNullOrUndefined(options3.agent) || typeof options3.rejectUnauthorized !== "boolean", "options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set");
          Hoek.assert(internals.isNullOrUndefined(options3.beforeRedirect) || typeof options3.beforeRedirect === "function", "options.beforeRedirect must be a function");
          Hoek.assert(internals.isNullOrUndefined(options3.redirected) || typeof options3.redirected === "function", "options.redirected must be a function");
          Hoek.assert(options3.gunzip === void 0 || typeof options3.gunzip === "boolean" || options3.gunzip === "force", 'options.gunzip must be a boolean or "force"');
        } catch (err) {
          return Promise.reject(err);
        }
        if (options3.baseUrl) {
          url2 = internals.resolveUrl(options3.baseUrl, url2);
          delete options3.baseUrl;
        }
        const relay = {};
        const req = this._request(method, url2, options3, relay);
        const promise2 = new Promise((resolve7, reject) => {
          relay.callback = (err, res) => {
            if (err) {
              reject(err);
              return;
            }
            resolve7(res);
            return;
          };
        });
        promise2.req = req;
        return promise2;
      }
      _request(method, url2, options3, relay, _trace) {
        const uri = {};
        if (options3.socketPath) {
          uri.socketPath = options3.socketPath;
          const parsedUri = new Url2.URL(url2, `unix://${options3.socketPath}`);
          internals.applyUrlToOptions(uri, {
            host: "",
            protocol: "http:",
            hash: parsedUri.hash,
            search: parsedUri.search,
            searchParams: parsedUri.searchParams,
            pathname: parsedUri.pathname,
            href: parsedUri.href
          });
        } else {
          uri.setHost = false;
          const parsedUri = new Url2.URL(url2);
          internals.applyUrlToOptions(uri, parsedUri);
        }
        uri.method = method.toUpperCase();
        uri.headers = /* @__PURE__ */ Object.create(null);
        const usedHeaders = /* @__PURE__ */ new Set();
        if (options3.headers) {
          for (const [key, value] of Object.entries(options3.headers)) {
            if (value !== void 0) {
              uri.headers[key] = value;
              usedHeaders.add(key.toLowerCase());
            }
          }
        }
        if (!usedHeaders.has("host")) {
          uri.headers.host = uri.host;
        }
        if (options3.payload && typeof options3.payload === "object" && !(options3.payload instanceof Stream) && !Buffer.isBuffer(options3.payload)) {
          options3.payload = JSON.stringify(options3.payload);
          if (!usedHeaders.has("content-type")) {
            uri.headers["content-type"] = "application/json";
          }
        }
        if (options3.gunzip && !usedHeaders.has("accept-encoding")) {
          uri.headers["accept-encoding"] = "gzip";
        }
        const payloadSupported = uri.method !== "GET" && uri.method !== "HEAD" && !internals.isNullOrUndefined(options3.payload);
        if (payloadSupported && (typeof options3.payload === "string" || Buffer.isBuffer(options3.payload)) && !usedHeaders.has("content-length")) {
          uri.headers["content-length"] = Buffer.isBuffer(options3.payload) ? options3.payload.length : Buffer.byteLength(options3.payload);
        }
        let redirects = options3.hasOwnProperty("redirects") ? options3.redirects : false;
        _trace = _trace ?? [];
        _trace.push({
          method: uri.method,
          url: url2
        });
        const client = uri.protocol === "https:" ? Https : Http;
        for (const option of internals.httpOptions) {
          if (options3[option] !== void 0) {
            uri[option] = options3[option];
          }
        }
        if (options3.rejectUnauthorized !== void 0 && uri.protocol === "https:") {
          uri.agent = options3.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
        } else if (options3.agent || options3.agent === false) {
          uri.agent = options3.agent;
        } else {
          uri.agent = uri.protocol === "https:" ? this.agents.https : this.agents.http;
        }
        this._emit("preRequest", uri, options3);
        const start = Date.now();
        const req = client.request(uri);
        this._emit("request", req);
        let shadow = null;
        let timeoutId;
        const onError = (err) => {
          err.trace = _trace;
          return finishOnce(Boom.badGateway("Client request error", err));
        };
        const onAbort = () => {
          if (!req.socket) {
            const error40 = new Error("socket hang up");
            error40.code = "ECONNRESET";
            finishOnce(error40);
          }
        };
        req.once("error", onError);
        const onResponse = (res) => {
          const statusCode = res.statusCode;
          const redirectMethod = internals.redirectMethod(statusCode, uri.method, options3);
          if (redirects === false || !redirectMethod) {
            return finishOnce(null, res);
          }
          res.destroy();
          if (redirects === 0) {
            return finishOnce(Boom.badGateway("Maximum redirections reached", _trace));
          }
          let location = res.headers.location;
          if (!location) {
            return finishOnce(Boom.badGateway("Received redirection without location", _trace));
          }
          if (!/^https?:/i.test(location)) {
            location = Url2.resolve(uri.href, location);
          }
          const redirectOptions = Hoek.clone(options3, {
            shallow: internals.shallowOptions
          });
          redirectOptions.payload = shadow ?? options3.payload;
          redirectOptions.redirects = --redirects;
          if (timeoutId) {
            clearTimeout(timeoutId);
            const elapsed = Date.now() - start;
            redirectOptions.timeout = (redirectOptions.timeout - elapsed).toString();
          }
          if (redirectOptions.headers) {
            const parsedLocation = new URL(location);
            if (uri.hostname !== parsedLocation.hostname) {
              for (const header of Object.keys(redirectOptions.headers)) {
                const lowerHeader = header.toLowerCase();
                if (lowerHeader === "authorization" || lowerHeader === "cookie") {
                  delete redirectOptions.headers[header];
                }
              }
            }
          }
          const followRedirect = (err) => {
            if (err) {
              err.trace = _trace;
              return finishOnce(Boom.badGateway("Invalid redirect", err));
            }
            const redirectReq = this._request(redirectMethod, location, redirectOptions, {
              callback: finishOnce
            }, _trace);
            if (options3.redirected) {
              options3.redirected(statusCode, location, redirectReq);
            }
          };
          if (!options3.beforeRedirect) {
            return followRedirect();
          }
          return options3.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, followRedirect);
        };
        const finish = (err, res) => {
          if (err) {
            req.abort();
          }
          req.removeListener("response", onResponse);
          req.removeListener("error", onError);
          req.removeListener("abort", onAbort);
          req.on("error", Hoek.ignore);
          clearTimeout(timeoutId);
          this._emit("response", err, {
            req,
            res,
            start,
            uri
          });
          return relay.callback(err, res);
        };
        const finishOnce = Hoek.once(finish);
        req.once("response", onResponse);
        if (options3.timeout) {
          timeoutId = setTimeout(() => finishOnce(Boom.gatewayTimeout("Client request timeout")), options3.timeout);
        }
        req.on("abort", onAbort);
        if (payloadSupported) {
          if (options3.payload instanceof Stream) {
            let stream = options3.payload;
            if (redirects) {
              const collector = new Tap();
              collector.once("finish", () => {
                shadow = collector.collect();
              });
              stream = options3.payload.pipe(collector);
            }
            internals.deferPipeUntilSocketConnects(req, stream);
            return req;
          }
          req.write(options3.payload);
        }
        req.end();
        return req;
      }
      _emit(...args) {
        if (this.events) {
          this.events.emit(...args);
        }
      }
      read(res, options3 = {}) {
        return new Promise((resolve7, reject) => {
          this._read(res, options3, (err, payload) => {
            if (err) {
              reject(err);
              return;
            }
            resolve7(payload);
            return;
          });
        });
      }
      _read(res, options3, callback) {
        options3 = Hoek.applyToDefaults(this._defaults, options3, {
          shallow: internals.shallowOptions
        });
        let clientTimeoutId = null;
        const finish = (err, buffer) => {
          clearTimeout(clientTimeoutId);
          reader.removeListener("error", onReaderError);
          reader.removeListener("finish", onReaderFinish);
          res.removeListener("error", onResError);
          res.removeListener("close", onResAborted);
          res.removeListener("aborted", onResAborted);
          res.on("error", Hoek.ignore);
          if (err) {
            return callback(err);
          }
          if (!options3.json) {
            return callback(null, buffer);
          }
          if (options3.json === "force") {
            return internals.tryParseBuffer(buffer, callback);
          }
          const contentType = res.headers?.["content-type"] ?? "";
          const mime = contentType.split(";")[0].trim().toLowerCase();
          if (!internals.jsonRegex.test(mime)) {
            if (options3.json === "strict") {
              return callback(Boom.notAcceptable("The content-type is not JSON compatible"));
            }
            return callback(null, buffer);
          }
          return internals.tryParseBuffer(buffer, callback);
        };
        const finishOnce = Hoek.once(finish);
        const clientTimeout = options3.timeout;
        if (clientTimeout && clientTimeout > 0) {
          clientTimeoutId = setTimeout(() => finishOnce(Boom.clientTimeout()), clientTimeout);
        }
        const onResError = (err) => {
          return finishOnce(err.isBoom ? err : Boom.internal("Payload stream error", err));
        };
        const onResAborted = () => {
          if (!res.complete) {
            finishOnce(Boom.internal("Payload stream closed prematurely"));
          }
        };
        res.once("error", onResError);
        res.once("close", onResAborted);
        res.once("aborted", onResAborted);
        const reader = new Recorder({
          maxBytes: options3.maxBytes
        });
        const onReaderError = (err) => {
          if (res.destroy) {
            res.destroy();
          }
          return finishOnce(err);
        };
        reader.once("error", onReaderError);
        const onReaderFinish = () => {
          return finishOnce(null, reader.collect());
        };
        reader.once("finish", onReaderFinish);
        if (options3.gunzip) {
          const contentEncoding = options3.gunzip === "force" ? "gzip" : res.headers?.["content-encoding"] ?? "";
          if (/^(x-)?gzip(\s*,\s*identity)?$/.test(contentEncoding)) {
            const gunzip = Zlib.createGunzip();
            gunzip.once("error", onReaderError);
            res.pipe(gunzip).pipe(reader);
            return;
          }
        }
        res.pipe(reader);
      }
      toReadableStream(payload, encoding) {
        return new Payload(payload, encoding);
      }
      parseCacheControl(field) {
        const regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;
        const header = {};
        const error40 = field.replace(regex, ($0, $1, $2, $3) => {
          const value = $2 || $3;
          header[$1] = value ? value.toLowerCase() : true;
          return "";
        });
        if (header["max-age"]) {
          try {
            const maxAge = parseInt(header["max-age"], 10);
            if (isNaN(maxAge)) {
              return null;
            }
            header["max-age"] = maxAge;
          } catch (err) {
          }
        }
        return error40 ? null : header;
      }
      // Shortcuts
      get(uri, options3) {
        return this._shortcut("GET", uri, options3);
      }
      post(uri, options3) {
        return this._shortcut("POST", uri, options3);
      }
      patch(uri, options3) {
        return this._shortcut("PATCH", uri, options3);
      }
      put(uri, options3) {
        return this._shortcut("PUT", uri, options3);
      }
      delete(uri, options3) {
        return this._shortcut("DELETE", uri, options3);
      }
      async _shortcut(method, uri, options3 = {}) {
        const res = await this.request(method, uri, options3);
        let payload;
        try {
          payload = await this.read(res, options3);
        } catch (err) {
          err.data = err.data ?? {};
          err.data.res = res;
          throw err;
        }
        if (res.statusCode < 400) {
          return {
            res,
            payload
          };
        }
        const data = {
          isResponseError: true,
          headers: res.headers,
          res,
          payload
        };
        throw new Boom.Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, {
          statusCode: res.statusCode,
          data
        });
      }
    };
    internals.resolveUrl = function(baseUrl, path) {
      if (!path) {
        return baseUrl;
      }
      const url2 = new Url2.URL(path, baseUrl);
      return Url2.format(url2);
    };
    internals.deferPipeUntilSocketConnects = function(req, stream) {
      const onSocket = (socket) => {
        if (!socket.connecting) {
          return onSocketConnect();
        }
        socket.once("connect", onSocketConnect);
      };
      const onSocketConnect = () => {
        stream.pipe(req);
        stream.removeListener("error", onStreamError);
      };
      const onStreamError = (err) => {
        req.emit("error", err);
      };
      req.once("socket", onSocket);
      stream.on("error", onStreamError);
    };
    internals.redirectMethod = function(code3, method, options3) {
      switch (code3) {
        case 301:
        case 302:
          return options3.redirectMethod || method;
        case 303:
          if (options3.redirect303) {
            return "GET";
          }
          break;
        case 307:
        case 308:
          return method;
      }
      return null;
    };
    internals.tryParseBuffer = function(buffer, next) {
      if (buffer.length === 0) {
        return next(null, null);
      }
      let payload;
      try {
        payload = Bourne.parse(buffer.toString());
      } catch (err) {
        return next(Boom.badGateway(err.message, {
          payload: buffer
        }));
      }
      return next(null, payload);
    };
    internals.applyUrlToOptions = (options3, url2) => {
      options3.host = url2.host;
      options3.origin = url2.origin;
      options3.searchParams = url2.searchParams;
      options3.protocol = url2.protocol;
      options3.hostname = typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname;
      options3.hash = url2.hash;
      options3.search = url2.search;
      options3.pathname = url2.pathname;
      options3.path = `${url2.pathname}${url2.search}`;
      options3.href = url2.href;
      if (url2.port !== "") {
        options3.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options3.auth = `${url2.username}:${url2.password}`;
        options3.username = url2.username;
        options3.password = url2.password;
      }
      return options3;
    };
    internals.isNullOrUndefined = (val) => [
      null,
      void 0
    ].includes(val);
    module2.exports = new internals.Client();
  }
});

// node_modules/.deno/@hapi+subtext@8.1.1/node_modules/@hapi/subtext/lib/index.js
var require_lib26 = __commonJS({
  "node_modules/.deno/@hapi+subtext@8.1.1/node_modules/@hapi/subtext/lib/index.js"(exports2) {
    "use strict";
    var Fs = __require("node:fs");
    var Fsp = __require("node:fs/promises");
    var Os = __require("node:os");
    var Querystring = __require("node:querystring");
    var Stream = __require("node:stream");
    var Zlib = __require("node:zlib");
    var Boom = require_lib6();
    var Bourne = require_lib15();
    var Content = require_lib20();
    var File2 = require_lib21();
    var Hoek = require_lib();
    var Pez = require_lib24();
    var Wreck = require_lib25();
    var internals = {
      kSubtext: Symbol("subtext"),
      decoders: {
        gzip: (options3) => Zlib.createGunzip(options3),
        deflate: (options3) => Zlib.createInflate(options3)
      }
    };
    exports2.parse = async function(req, tap, options3) {
      Hoek.assert(options3, "Missing options");
      Hoek.assert(options3.parse !== void 0, "Missing parse option setting");
      Hoek.assert(options3.output !== void 0, "Missing output option setting");
      const contentLength = req.headers["content-length"];
      if (options3.maxBytes !== void 0 && contentLength && parseInt(contentLength, 10) > options3.maxBytes) {
        throw Boom.entityTooLarge("Payload content length greater than maximum allowed: " + options3.maxBytes);
      }
      const contentType = Content.type(options3.override || req.headers["content-type"] || options3.defaultContentType || "application/octet-stream");
      try {
        if (options3.allow && options3.allow.indexOf(contentType.mime) === -1) {
          throw Boom.unsupportedMediaType();
        }
        const parsed = {
          mime: contentType.mime
        };
        if (options3.parse === true) {
          parsed.payload = await internals.parse(req, tap, options3, contentType);
          return parsed;
        }
        parsed.payload = await internals.raw(req, tap, options3);
        return parsed;
      } catch (err) {
        err.mime = contentType.mime;
        throw err;
      }
    };
    internals.parse = async function(req, tap, options3, contentType) {
      const output = options3.output;
      let source = internals.decoder(req, options3);
      if (tap) {
        [source] = internals.pipe(source, tap);
      }
      if (contentType.mime === "multipart/form-data") {
        if (options3.multipart === false) {
          throw Boom.unsupportedMediaType();
        }
        return await internals.multipart(req, options3, source, contentType);
      }
      if (output === "stream") {
        return source;
      }
      if (output === "file") {
        const file2 = await internals.writeFile(req, options3, source);
        return file2.item;
      }
      const payload = await Wreck.read(source, {
        timeout: options3.timeout,
        maxBytes: options3.maxBytes
      });
      return internals.object(options3, payload, contentType.mime);
    };
    internals.decoder = function(source, options3) {
      const contentEncoding = source.headers["content-encoding"];
      const decoders = options3.decoders ?? internals.decoders;
      if (!decoders.hasOwnProperty(contentEncoding)) {
        return source;
      }
      const decoderOptions = options3.compression?.[contentEncoding] ?? null;
      const stream = decoders[contentEncoding](decoderOptions);
      const orig = stream.emit;
      stream.emit = (event, ...args) => {
        if (event === "error") {
          args = [
            Boom.badRequest("Invalid compressed payload", args[0])
          ];
        }
        return orig.call(stream, event, ...args);
      };
      [source] = internals.pipe(source, stream);
      return source;
    };
    internals.raw = async function(req, tap, options3) {
      const output = options3.output;
      let source = req;
      if (options3.parse === "gunzip") {
        source = internals.decoder(source, options3);
      }
      if (tap) {
        [source] = internals.pipe(source, tap);
      }
      if (output === "stream") {
        return source;
      }
      if (output === "file") {
        const file2 = await internals.writeFile(req, options3, source);
        return file2.item;
      }
      return await Wreck.read(source, {
        timeout: options3.timeout,
        maxBytes: options3.maxBytes
      });
    };
    internals.object = function(options3, payload, mime) {
      if (mime === "application/octet-stream") {
        return payload.length ? payload : null;
      }
      if (mime.match(/^text\/.+$/)) {
        return payload.toString("utf8");
      }
      if (/^application\/(?:.+\+)?json$/.test(mime)) {
        if (!payload.length) {
          return null;
        }
        try {
          return Bourne.parse(payload.toString("utf8"), {
            protoAction: options3.protoAction
          });
        } catch (err) {
          const error41 = Boom.badRequest("Invalid request payload JSON format", err);
          error41.raw = payload;
          throw error41;
        }
      }
      if (mime === "application/x-www-form-urlencoded") {
        const parse10 = options3.querystring ?? Querystring.parse;
        return payload.length ? parse10(payload.toString("utf8")) : {};
      }
      const error40 = Boom.unsupportedMediaType();
      error40.raw = payload;
      throw error40;
    };
    internals.multipart = function(req, options3, source, contentType) {
      return new Promise((resolve7, reject) => {
        const clientTimeout = options3.timeout;
        const clientTimeoutId = clientTimeout ? setTimeout(() => reject(Boom.clientTimeout()), clientTimeout) : null;
        const dispenserOptions = Hoek.applyToDefaults(contentType, {
          maxBytes: options3.maxBytes,
          maxParts: options3.maxParts
        });
        const dispenser = new Pez.Dispenser(dispenserOptions);
        const data = {};
        const pendingFiles = [];
        const onError = (err) => {
          const cleanup = internals.cleanupFiles(pendingFiles);
          cleanup.catch(Hoek.ignore);
          reject(Boom.badRequest("Invalid multipart payload format", err));
        };
        dispenser.once("error", onError);
        const set2 = (name, value) => {
          if (!data.hasOwnProperty(name)) {
            data[name] = value;
          } else if (Array.isArray(data[name])) {
            data[name].push(value);
          } else {
            data[name] = [
              data[name],
              value
            ];
          }
        };
        const finalize = async () => {
          clearTimeout(clientTimeoutId);
          dispenser.removeListener("error", onError);
          dispenser.removeListener("part", onPart);
          dispenser.removeListener("field", onField);
          dispenser.removeListener("close", onClose);
          try {
            const files = await Promise.all(pendingFiles);
            for (const { item, name } of files) {
              set2(name, item);
            }
          } catch (err) {
            reject(err);
            return;
          }
          resolve7(data);
        };
        const output = typeof options3.multipart === "object" ? options3.multipart.output : options3.output;
        const onPart = (part) => {
          if (output === "file") {
            pendingFiles.push(internals.writeFile(req, options3, part));
          } else {
            internals.part(part, output, set2, options3);
          }
        };
        dispenser.on("part", onPart);
        const onField = (name, value) => set2(name, value);
        dispenser.on("field", onField);
        const onClose = () => finalize();
        dispenser.once("close", onClose);
        source.pipe(dispenser);
      });
    };
    internals.writeFile = function(req, options3, stream) {
      const promise2 = new Promise((resolve7, reject) => {
        const path = File2.uniqueFilename(options3.uploads ?? Os.tmpdir());
        const file2 = Fs.createWriteStream(path, {
          flags: "wx"
        });
        const counter = new internals.Counter(options3);
        const finalize = (err) => {
          req.removeListener("aborted", onAbort);
          file2.removeListener("close", finalize);
          file2.removeListener("error", finalize);
          if (err) {
            unpipeStreamToCounter();
            unpipeCounterToFile();
            file2.close();
            Fs.unlink(path, () => reject(err));
            return;
          }
          const result = {
            item: {
              path,
              bytes: counter.bytes
            }
          };
          if (stream.name) {
            result.name = stream.name;
            result.item.filename = stream.filename;
            result.item.headers = stream.headers;
          }
          resolve7(result);
        };
        file2.once("close", finalize);
        file2.once("error", finalize);
        const onAbort = () => finalize(Boom.badRequest("Client connection aborted"));
        req.once("aborted", onAbort);
        const [, unpipeStreamToCounter] = internals.pipe(stream, counter);
        const [, unpipeCounterToFile] = internals.pipe(counter, file2);
      });
      promise2.catch(Hoek.ignore);
      return promise2;
    };
    internals.cleanupFiles = async (pendingFiles) => {
      const results = await Promise.allSettled(pendingFiles);
      await Promise.all(results.map(async (result) => {
        if (result.value) {
          await Fsp.unlink(result.value.item.path);
        }
      }));
    };
    internals.part = async function(part, output, set2, options3) {
      const payload = await Wreck.read(part);
      if (output === "stream") {
        const item = Wreck.toReadableStream(payload);
        item.hapi = {
          filename: part.filename,
          headers: part.headers
        };
        return set2(part.name, item);
      }
      const ct = part.headers["content-type"] || "";
      const mime = ct.split(";")[0].trim().toLowerCase();
      const annotate = (value) => set2(part.name, output === "annotated" ? {
        filename: part.filename,
        headers: part.headers,
        payload: value
      } : value);
      if (!mime) {
        return annotate(payload);
      }
      if (!payload.length) {
        return annotate({});
      }
      try {
        const object2 = internals.object(options3, payload, mime);
        annotate(object2);
      } catch (err) {
        annotate(payload);
      }
    };
    internals.pipe = function(from6, to) {
      const forwardError = (err) => {
        unpipe();
        to.emit("error", err);
      };
      const unpipe = () => {
        from6.removeListener("error", forwardError);
        return from6.unpipe(to);
      };
      from6.once("error", forwardError);
      return [
        from6.pipe(to),
        unpipe
      ];
    };
    internals.Counter = class extends Stream.Transform {
      constructor(options3) {
        super();
        this.bytes = 0;
        this._maxBytes = options3.maxBytes;
      }
      _transform(chunk, encoding, next) {
        this.bytes = this.bytes + chunk.length;
        if (this._maxBytes !== void 0 && this.bytes > this._maxBytes) {
          return next(Boom.entityTooLarge("Payload content length greater than maximum allowed: " + this._maxBytes));
        }
        return next(null, chunk);
      }
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/ext.js
var require_ext = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/ext.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var Topo = require_lib2();
    var internals = {};
    exports2 = module2.exports = internals.Ext = class {
      type = null;
      nodes = null;
      #core = null;
      #routes = [];
      #topo = new Topo.Sorter();
      constructor(type, core) {
        this.#core = core;
        this.type = type;
      }
      add(event) {
        const methods = [].concat(event.method);
        for (const method of methods) {
          const settings = {
            before: event.options.before,
            after: event.options.after,
            group: event.realm.plugin,
            sort: this.#core.extensionsSeq++
          };
          const node = {
            func: method,
            bind: event.options.bind,
            server: event.server,
            realm: event.realm,
            timeout: event.options.timeout
          };
          this.#topo.add(node, settings);
        }
        this.nodes = this.#topo.nodes;
        for (const route of this.#routes) {
          route.rebuild(event);
        }
      }
      merge(others) {
        const merge3 = [];
        for (const other of others) {
          merge3.push(other.#topo);
        }
        this.#topo.merge(merge3);
        this.nodes = this.#topo.nodes.length ? this.#topo.nodes : null;
      }
      subscribe(route) {
        this.#routes.push(route);
      }
      static combine(route, type) {
        const ext = new internals.Ext(type, route._core);
        const events = route.settings.ext[type];
        if (events) {
          for (let event of events) {
            event = Object.assign({}, event);
            Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for route extension");
            event.realm = route.realm;
            ext.add(event);
          }
        }
        const server = route._core.extensions.route[type];
        const realm = route.realm._extensions[type];
        ext.merge([
          server,
          realm
        ]);
        server.subscribe(route);
        realm.subscribe(route);
        return ext;
      }
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/handler.js
var require_handler = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/handler.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {};
    exports2.execute = async function(request) {
      if (request._route._prerequisites) {
        for (const set2 of request._route._prerequisites) {
          const pres = [];
          for (const item of set2) {
            pres.push(internals.handler(request, item.method, item));
          }
          const responses = await Promise.all(pres);
          for (const response of responses) {
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      const result = await internals.handler(request, request.route.settings.handler);
      if (result._takeover || typeof result === "symbol") {
        return result;
      }
      request._setResponse(result);
    };
    internals.handler = async function(request, method, pre) {
      const bind = request.route.settings.bind;
      const realm = request.route.realm;
      let response = await request._core.toolkit.execute(method, request, {
        bind,
        realm,
        continue: "null"
      });
      if (!pre) {
        if (response.isBoom) {
          request._log([
            "handler",
            "error"
          ], response);
          throw response;
        }
        return response;
      }
      if (response.isBoom) {
        response.assign = pre.assign;
        response = await request._core.toolkit.failAction(request, pre.failAction, response, {
          tags: [
            "pre",
            "error"
          ],
          retain: true
        });
      }
      if (typeof response === "symbol") {
        return response;
      }
      if (pre.assign) {
        request.pre[pre.assign] = response.isBoom ? response : response.source;
        request.preResponses[pre.assign] = response;
      }
      if (response._takeover) {
        return response;
      }
    };
    exports2.defaults = function(method, handler, core) {
      let defaults = null;
      if (typeof handler === "object") {
        const type = Object.keys(handler)[0];
        const serverHandler = core.decorations.handler.get(type);
        Hoek.assert(serverHandler, "Unknown handler:", type);
        if (serverHandler.defaults) {
          defaults = typeof serverHandler.defaults === "function" ? serverHandler.defaults(method) : serverHandler.defaults;
        }
      }
      return defaults ?? {};
    };
    exports2.configure = function(handler, route) {
      if (typeof handler === "object") {
        const type = Object.keys(handler)[0];
        const serverHandler = route._core.decorations.handler.get(type);
        Hoek.assert(serverHandler, "Unknown handler:", type);
        return serverHandler(route.public, handler[type]);
      }
      return handler;
    };
    exports2.prerequisitesConfig = function(config2) {
      if (!config2) {
        return null;
      }
      const prerequisites = [];
      for (let pres of config2) {
        pres = [].concat(pres);
        const set2 = [];
        for (let pre of pres) {
          if (typeof pre !== "object") {
            pre = {
              method: pre
            };
          }
          const item = {
            method: pre.method,
            assign: pre.assign,
            failAction: pre.failAction ?? "error"
          };
          set2.push(item);
        }
        prerequisites.push(set2);
      }
      return prerequisites.length ? prerequisites : null;
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/headers.js
var require_headers = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/headers.js"(exports2) {
    "use strict";
    var Stream = __require("node:stream");
    var Boom = require_lib6();
    var internals = {};
    exports2.cache = function(response) {
      const request = response.request;
      if (response.headers["cache-control"]) {
        return;
      }
      const settings = request.route.settings.cache;
      const policy = settings && request._route._cache && (settings._statuses.has(response.statusCode) || response.statusCode === 304 && settings._statuses.has(200));
      if (policy || response.settings.ttl) {
        const ttl = response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl();
        const privacy = request.auth.isAuthenticated || response.headers["set-cookie"] ? "private" : settings.privacy ?? "default";
        response._header("cache-control", "max-age=" + Math.floor(ttl / 1e3) + ", must-revalidate" + (privacy !== "default" ? ", " + privacy : ""));
      } else if (settings) {
        response._header("cache-control", settings.otherwise);
      }
    };
    exports2.content = async function(response) {
      const request = response.request;
      if (response._isPayloadSupported() || request.method === "head") {
        await response._marshal();
        if (typeof response._payload.size === "function") {
          response._header("content-length", response._payload.size(), {
            override: false
          });
        }
        if (!response._isPayloadSupported()) {
          response._close();
          response._payload = new internals.Empty();
        }
        exports2.type(response);
      } else {
        response._close();
        response._payload = new internals.Empty();
        delete response.headers["content-length"];
      }
    };
    exports2.state = async function(response) {
      const request = response.request;
      const states = [];
      for (const stateName in request._states) {
        states.push(request._states[stateName]);
      }
      try {
        for (const name in request._core.states.cookies) {
          const autoValue = request._core.states.cookies[name].autoValue;
          if (!autoValue || name in request._states || name in request.state) {
            continue;
          }
          if (typeof autoValue !== "function") {
            states.push({
              name,
              value: autoValue
            });
            continue;
          }
          const value = await autoValue(request);
          states.push({
            name,
            value
          });
        }
        if (!states.length) {
          return;
        }
        let header = await request._core.states.format(states, request);
        const existing = response.headers["set-cookie"];
        if (existing) {
          header = (Array.isArray(existing) ? existing : [
            existing
          ]).concat(header);
        }
        response._header("set-cookie", header);
      } catch (err) {
        const error40 = Boom.boomify(err);
        request._log([
          "state",
          "response",
          "error"
        ], error40);
        request._states = {};
        throw error40;
      }
    };
    exports2.type = function(response) {
      const type = response.contentType;
      if (type !== null && type !== response.headers["content-type"]) {
        response.type(type);
      }
    };
    exports2.entity = function(response) {
      const request = response.request;
      if (!request._entity) {
        return;
      }
      if (request._entity.etag && !response.headers.etag) {
        response.etag(request._entity.etag, {
          vary: request._entity.vary
        });
      }
      if (request._entity.modified && !response.headers["last-modified"]) {
        response.header("last-modified", request._entity.modified);
      }
    };
    exports2.unmodified = function(response) {
      const request = response.request;
      if (response.statusCode === 304) {
        return;
      }
      const entity = {
        etag: response.headers.etag,
        vary: response.settings.varyEtag,
        modified: response.headers["last-modified"]
      };
      const etag = request._core.Response.unmodified(request, entity);
      if (etag) {
        response.code(304);
        if (etag !== true) {
          response.headers.etag = etag;
        }
      }
    };
    internals.Empty = class extends Stream.Readable {
      _read() {
        this.push(null);
      }
      writeToStream(stream) {
        stream.end();
      }
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/security.js
var require_security = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/security.js"(exports2) {
    "use strict";
    exports2.route = function(settings) {
      if (!settings) {
        return null;
      }
      const security = settings;
      if (security.hsts) {
        if (security.hsts === true) {
          security._hsts = "max-age=15768000";
        } else if (typeof security.hsts === "number") {
          security._hsts = "max-age=" + security.hsts;
        } else {
          security._hsts = "max-age=" + (security.hsts.maxAge ?? 15768e3);
          if (security.hsts.includeSubdomains || security.hsts.includeSubDomains) {
            security._hsts = security._hsts + "; includeSubDomains";
          }
          if (security.hsts.preload) {
            security._hsts = security._hsts + "; preload";
          }
        }
      }
      if (security.xframe) {
        if (security.xframe === true) {
          security._xframe = "DENY";
        } else if (typeof security.xframe === "string") {
          security._xframe = security.xframe.toUpperCase();
        } else if (security.xframe.rule === "allow-from") {
          if (!security.xframe.source) {
            security._xframe = "SAMEORIGIN";
          } else {
            security._xframe = "ALLOW-FROM " + security.xframe.source;
          }
        } else {
          security._xframe = security.xframe.rule.toUpperCase();
        }
      }
      return security;
    };
    exports2.headers = function(response) {
      const security = response.request.route.settings.security;
      if (security._hsts) {
        response._header("strict-transport-security", security._hsts, {
          override: false
        });
      }
      if (security._xframe) {
        response._header("x-frame-options", security._xframe, {
          override: false
        });
      }
      if (security.xss === "enabled") {
        response._header("x-xss-protection", "1; mode=block", {
          override: false
        });
      } else if (security.xss === "disabled") {
        response._header("x-xss-protection", "0", {
          override: false
        });
      }
      if (security.noOpen) {
        response._header("x-download-options", "noopen", {
          override: false
        });
      }
      if (security.noSniff) {
        response._header("x-content-type-options", "nosniff", {
          override: false
        });
      }
      if (security.referrer !== false) {
        response._header("referrer-policy", security.referrer, {
          override: false
        });
      }
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/streams.js
var require_streams = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/streams.js"(exports2) {
    "use strict";
    var Stream = __require("node:stream");
    var Boom = require_lib6();
    var Teamwork = require_lib5();
    var internals = {
      team: Symbol("team")
    };
    exports2.isStream = function(stream) {
      const isReadableStream = stream instanceof Stream.Readable;
      if (!isReadableStream && typeof stream?.pipe === "function") {
        throw Boom.badImplementation("Cannot reply with a stream-like object that is not an instance of Stream.Readable");
      }
      if (!isReadableStream) {
        return false;
      }
      if (stream.readableObjectMode) {
        throw Boom.badImplementation("Cannot reply with stream in object mode");
      }
      return true;
    };
    exports2.drain = function(stream) {
      const team = new Teamwork.Team();
      stream[internals.team] = team;
      stream.on("readable", internals.read);
      stream.on("error", internals.end);
      stream.on("end", internals.end);
      stream.on("close", internals.end);
      return team.work;
    };
    internals.read = function() {
      while (this.read()) {
      }
    };
    internals.end = function() {
      this.removeListener("readable", internals.read);
      this.removeListener("error", internals.end);
      this.removeListener("end", internals.end);
      this.removeListener("close", internals.end);
      this[internals.team].attend();
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/validation.js
var require_validation = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/validation.js"(exports2) {
    "use strict";
    var Boom = require_lib6();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var internals = {};
    exports2.validator = function(validator) {
      Hoek.assert(validator, "Missing validator");
      Hoek.assert(typeof validator.compile === "function", "Invalid validator compile method");
      return validator;
    };
    exports2.compile = function(rule, validator, realm, core) {
      validator = validator ?? internals.validator(realm, core);
      if (rule === false) {
        return Validate.object({}).allow(null);
      }
      if (typeof rule === "function") {
        return rule;
      }
      if (!rule || // false tested above
      rule === true) {
        return null;
      }
      if (typeof rule.validate === "function") {
        return rule;
      }
      Hoek.assert(validator, "Cannot set uncompiled validation rules without configuring a validator");
      return validator.compile(rule);
    };
    internals.validator = function(realm, core) {
      while (realm) {
        if (realm.validator) {
          return realm.validator;
        }
        realm = realm.parent;
      }
      return core.validator;
    };
    exports2.headers = function(request) {
      return internals.input("headers", request);
    };
    exports2.params = function(request) {
      return internals.input("params", request);
    };
    exports2.payload = function(request) {
      if (request.method === "get" || request.method === "head") {
        return;
      }
      return internals.input("payload", request);
    };
    exports2.query = function(request) {
      return internals.input("query", request);
    };
    exports2.state = function(request) {
      return internals.input("state", request);
    };
    internals.input = async function(source, request) {
      const localOptions = {
        context: {
          headers: request.headers,
          params: request.params,
          query: request.query,
          payload: request.payload,
          state: request.state,
          auth: request.auth,
          app: {
            route: request.route.settings.app,
            request: request.app
          }
        }
      };
      delete localOptions.context[source];
      Hoek.merge(localOptions, request.route.settings.validate.options);
      try {
        const schema = request.route.settings.validate[source];
        const bind = request.route.settings.bind;
        var value = await (typeof schema !== "function" ? internals.validate(request[source], schema, localOptions) : schema.call(bind, request[source], localOptions));
        return;
      } catch (err) {
        var validationError = err;
      } finally {
        request.orig[source] = request[source];
        if (value !== void 0) {
          request[source] = value;
        }
      }
      if (request.route.settings.validate.failAction === "ignore") {
        return;
      }
      const defaultError = validationError.isBoom ? validationError : Boom.badRequest(`Invalid request ${source} input`);
      const detailedError = Boom.boomify(validationError, {
        statusCode: 400,
        override: false,
        data: {
          defaultError
        }
      });
      detailedError.output.payload.validation = {
        source,
        keys: []
      };
      if (validationError.details) {
        for (const details of validationError.details) {
          const path = details.path;
          detailedError.output.payload.validation.keys.push(Hoek.escapeHtml(path.join(".")));
        }
      }
      if (request.route.settings.validate.errorFields) {
        for (const field in request.route.settings.validate.errorFields) {
          detailedError.output.payload[field] = request.route.settings.validate.errorFields[field];
        }
      }
      return request._core.toolkit.failAction(request, request.route.settings.validate.failAction, defaultError, {
        details: detailedError,
        tags: [
          "validation",
          "error",
          source
        ]
      });
    };
    exports2.response = async function(request) {
      if (request.route.settings.response.sample) {
        const currentSample = Math.ceil(Math.random() * 100);
        if (currentSample > request.route.settings.response.sample) {
          return;
        }
      }
      const response = request.response;
      const statusCode = response.isBoom ? response.output.statusCode : response.statusCode;
      const statusSchema = request.route.settings.response.status[statusCode];
      if (statusCode >= 400 && !statusSchema) {
        return;
      }
      const schema = statusSchema !== void 0 ? statusSchema : request.route.settings.response.schema;
      if (schema === null) {
        return;
      }
      if (!response.isBoom && request.response.variety !== "plain") {
        throw Boom.badImplementation("Cannot validate non-object response");
      }
      const localOptions = {
        context: {
          headers: request.headers,
          params: request.params,
          query: request.query,
          payload: request.payload,
          state: request.state,
          auth: request.auth,
          app: {
            route: request.route.settings.app,
            request: request.app
          }
        }
      };
      const source = response.isBoom ? response.output.payload : response.source;
      Hoek.merge(localOptions, request.route.settings.response.options);
      try {
        let value;
        if (typeof schema !== "function") {
          value = await internals.validate(source, schema, localOptions);
        } else {
          value = await schema(source, localOptions);
        }
        if (value !== void 0 && request.route.settings.response.modify) {
          if (response.isBoom) {
            response.output.payload = value;
          } else {
            response.source = value;
          }
        }
      } catch (err) {
        return request._core.toolkit.failAction(request, request.route.settings.response.failAction, err, {
          tags: [
            "validation",
            "response",
            "error"
          ]
        });
      }
    };
    internals.validate = function(value, schema, options3) {
      if (typeof schema.validateAsync === "function") {
        return schema.validateAsync(value, options3);
      }
      return schema.validate(value, options3);
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/route.js
var require_route = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/route.js"(exports2, module2) {
    "use strict";
    var Assert = __require("node:assert");
    var Bounce = require_lib7();
    var Catbox = require_lib11();
    var Hoek = require_lib();
    var Subtext = require_lib26();
    var Validate = require_lib3();
    var Auth = require_auth();
    var Config = require_config();
    var Cors = require_cors();
    var Ext = require_ext();
    var Handler = require_handler();
    var Headers2 = require_headers();
    var Security = require_security();
    var Streams = require_streams();
    var Validation = require_validation();
    var internals = {};
    exports2 = module2.exports = internals.Route = class {
      constructor(route, server, options3 = {}) {
        const core = server._core;
        const realm = server.realm;
        Config.apply("route", route, route.method, route.path);
        const method = route.method.toLowerCase();
        Hoek.assert(method !== "head", "Cannot set HEAD route:", route.path);
        const path = realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (route.path !== "/" ? route.path : "") : route.path;
        Hoek.assert(path === "/" || path[path.length - 1] !== "/" || !core.settings.router.stripTrailingSlash, "Path cannot end with a trailing slash when configured to strip:", route.method, route.path);
        const vhost = realm.modifiers.route.vhost ?? route.vhost;
        this.method = method;
        this.path = path;
        let config2 = route.options ?? route.config ?? {};
        if (typeof config2 === "function") {
          config2 = config2.call(realm.settings.bind, server);
        }
        config2 = Config.enable(config2);
        this._assert(method !== "get" || !config2.payload, "Cannot set payload settings on HEAD or GET request");
        this._assert(method !== "get" || !config2.validate?.payload, "Cannot validate HEAD or GET request payload");
        this._assert(!route.rules || !config2.rules, "Route rules can only appear once");
        const rules = route.rules ?? config2.rules;
        const rulesConfig = internals.rules(rules, {
          method,
          path,
          vhost
        }, server);
        delete config2.rules;
        this._assert(route.handler || config2.handler, "Missing or undefined handler");
        this._assert(!!route.handler ^ !!config2.handler, "Handler must only appear once");
        const handler = Config.apply("handler", route.handler ?? config2.handler);
        delete config2.handler;
        const handlerDefaults = Handler.defaults(method, handler, core);
        const settings = internals.config([
          core.settings.routes,
          handlerDefaults,
          realm.settings,
          rulesConfig,
          config2
        ]);
        this.settings = Config.apply("routeConfig", settings, method, path);
        this._core = core;
        this.realm = realm;
        this.settings.vhost = vhost;
        this.settings.plugins = this.settings.plugins ?? {};
        this.settings.app = this.settings.app ?? {};
        this._special = !!options3.special;
        this._analysis = this._core.router.analyze(this.path);
        this.params = this._analysis.params;
        this.fingerprint = this._analysis.fingerprint;
        this.public = {
          method: this.method,
          path: this.path,
          vhost,
          realm,
          settings: this.settings,
          fingerprint: this.fingerprint,
          auth: {
            access: (request) => Auth.testAccess(request, this.public)
          }
        };
        this._setupValidation();
        if (this.method === "get") {
          this.settings.payload = null;
        } else {
          this.settings.payload.decoders = this._core.compression.decoders;
        }
        this._assert(!this.settings.validate.payload || this.settings.payload.parse, "Route payload must be set to 'parse' when payload validation enabled");
        this._assert(!this.settings.validate.state || this.settings.state.parse, "Route state must be set to 'parse' when state validation enabled");
        this.settings.auth = this._special ? false : this._core.auth._setupRoute(this.settings.auth, path);
        if (this.method === "get" && typeof this.settings.cache === "object" && (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {
          this.settings.cache._statuses = new Set(this.settings.cache.statuses);
          this._cache = new Catbox.Policy({
            expiresIn: this.settings.cache.expiresIn,
            expiresAt: this.settings.cache.expiresAt
          });
        }
        this.settings.cors = Cors.route(this.settings.cors);
        this.settings.security = Security.route(this.settings.security);
        this.settings.handler = Handler.configure(handler, this);
        this._prerequisites = Handler.prerequisitesConfig(this.settings.pre);
        this._extensions = {
          onPreResponse: Ext.combine(this, "onPreResponse"),
          onPostResponse: Ext.combine(this, "onPostResponse")
        };
        if (this._special) {
          this._cycle = [
            internals.drain,
            Handler.execute
          ];
          this.rebuild();
          return;
        }
        this._extensions.onPreAuth = Ext.combine(this, "onPreAuth");
        this._extensions.onCredentials = Ext.combine(this, "onCredentials");
        this._extensions.onPostAuth = Ext.combine(this, "onPostAuth");
        this._extensions.onPreHandler = Ext.combine(this, "onPreHandler");
        this._extensions.onPostHandler = Ext.combine(this, "onPostHandler");
        this.rebuild();
      }
      _setupValidation() {
        const validation = this.settings.validate;
        if (this.method === "get") {
          validation.payload = null;
        }
        this._assert(!validation.params || this.params.length, "Cannot set path parameters validations without path parameters");
        for (const type of [
          "headers",
          "params",
          "query",
          "payload",
          "state"
        ]) {
          validation[type] = Validation.compile(validation[type], this.settings.validate.validator, this.realm, this._core);
        }
        if (this.settings.response.schema !== void 0 || this.settings.response.status) {
          this.settings.response._validate = true;
          const rule = this.settings.response.schema;
          this.settings.response.status = this.settings.response.status ?? {};
          const statuses = Object.keys(this.settings.response.status);
          if (rule === true && !statuses.length) {
            this.settings.response._validate = false;
          } else {
            this.settings.response.schema = Validation.compile(rule, this.settings.validate.validator, this.realm, this._core);
            for (const code3 of statuses) {
              this.settings.response.status[code3] = Validation.compile(this.settings.response.status[code3], this.settings.validate.validator, this.realm, this._core);
            }
          }
        }
      }
      rebuild(event) {
        if (event) {
          this._extensions[event.type].add(event);
        }
        if (this._special) {
          this._postCycle = this._extensions.onPreResponse.nodes ? [
            this._extensions.onPreResponse
          ] : [];
          this._buildMarshalCycle();
          return;
        }
        this._cycle = [];
        if (this.settings.state.parse) {
          this._cycle.push(internals.state);
        }
        if (this._extensions.onPreAuth.nodes) {
          this._cycle.push(this._extensions.onPreAuth);
        }
        if (this._core.auth._enabled(this, "authenticate")) {
          this._cycle.push(Auth.authenticate);
        }
        if (this.method !== "get") {
          this._cycle.push(internals.payload);
          if (this._core.auth._enabled(this, "payload")) {
            this._cycle.push(Auth.payload);
          }
        }
        if (this._core.auth._enabled(this, "authenticate") && this._extensions.onCredentials.nodes) {
          this._cycle.push(this._extensions.onCredentials);
        }
        if (this._core.auth._enabled(this, "access")) {
          this._cycle.push(Auth.access);
        }
        if (this._extensions.onPostAuth.nodes) {
          this._cycle.push(this._extensions.onPostAuth);
        }
        if (this.settings.validate.headers) {
          this._cycle.push(Validation.headers);
        }
        if (this.settings.validate.params) {
          this._cycle.push(Validation.params);
        }
        if (this.settings.validate.query) {
          this._cycle.push(Validation.query);
        }
        if (this.settings.validate.payload) {
          this._cycle.push(Validation.payload);
        }
        if (this.settings.validate.state) {
          this._cycle.push(Validation.state);
        }
        if (this._extensions.onPreHandler.nodes) {
          this._cycle.push(this._extensions.onPreHandler);
        }
        this._cycle.push(Handler.execute);
        if (this._extensions.onPostHandler.nodes) {
          this._cycle.push(this._extensions.onPostHandler);
        }
        this._postCycle = [];
        if (this.settings.response._validate && this.settings.response.sample !== 0) {
          this._postCycle.push(Validation.response);
        }
        if (this._extensions.onPreResponse.nodes) {
          this._postCycle.push(this._extensions.onPreResponse);
        }
        this._buildMarshalCycle();
      }
      _buildMarshalCycle() {
        this._marshalCycle = [
          Headers2.type
        ];
        if (this.settings.cors) {
          this._marshalCycle.push(Cors.headers);
        }
        if (this.settings.security) {
          this._marshalCycle.push(Security.headers);
        }
        this._marshalCycle.push(Headers2.entity);
        if (this.method === "get" || this.method === "*") {
          this._marshalCycle.push(Headers2.unmodified);
        }
        this._marshalCycle.push(Headers2.cache);
        this._marshalCycle.push(Headers2.state);
        this._marshalCycle.push(Headers2.content);
        if (this._core.auth._enabled(this, "response")) {
          this._marshalCycle.push(Auth.response);
        }
      }
      _assert(condition, message) {
        if (condition) {
          return;
        }
        if (this.method[0] !== "_") {
          message = `${message}: ${this.method.toUpperCase()} ${this.path}`;
        }
        throw new Assert.AssertionError({
          message,
          actual: false,
          expected: true,
          operator: "==",
          stackStartFunction: this._assert
        });
      }
    };
    internals.state = async function(request) {
      request.state = {};
      const req = request.raw.req;
      const cookies = req.headers.cookie;
      if (!cookies) {
        return;
      }
      try {
        var result = await request._core.states.parse(cookies);
      } catch (err) {
        Bounce.rethrow(err, "system");
        var parseError = err;
      }
      const { states, failed = [] } = result ?? parseError;
      request.state = states ?? {};
      for (const item of failed) {
        if (item.settings.clearInvalid) {
          request._clearState(item.name);
        }
      }
      if (!parseError) {
        return;
      }
      parseError.header = cookies;
      return request._core.toolkit.failAction(request, request.route.settings.state.failAction, parseError, {
        tags: [
          "state",
          "error"
        ]
      });
    };
    internals.payload = async function(request) {
      if (request.method === "get" || request.method === "head") {
        return;
      }
      if (request.payload !== void 0) {
        return internals.drain(request);
      }
      if (request._expectContinue) {
        request._expectContinue = false;
        request.raw.res.writeContinue();
      }
      try {
        const { payload, mime } = await Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload);
        request._isPayloadPending = !!payload?._readableState;
        request.mime = mime;
        request.payload = payload;
      } catch (err) {
        Bounce.rethrow(err, "system");
        await internals.drain(request);
        request.mime = err.mime;
        request.payload = null;
        return request._core.toolkit.failAction(request, request.route.settings.payload.failAction, err, {
          tags: [
            "payload",
            "error"
          ]
        });
      }
    };
    internals.drain = async function(request) {
      if (request._expectContinue) {
        request._isPayloadPending = false;
        request._expectContinue = false;
      }
      if (request._isPayloadPending) {
        await Streams.drain(request.raw.req);
        request._isPayloadPending = false;
      }
    };
    internals.config = function(chain) {
      if (!chain.length) {
        return {};
      }
      let config2 = chain[0];
      for (const item of chain) {
        config2 = Hoek.applyToDefaults(config2, item, {
          shallow: [
            "bind",
            "validate.headers",
            "validate.payload",
            "validate.params",
            "validate.query",
            "validate.state"
          ]
        });
      }
      return config2;
    };
    internals.rules = function(rules, info, server) {
      const configs = [];
      let realm = server.realm;
      while (realm) {
        if (realm._rules) {
          const source = !realm._rules.settings.validate ? rules : Validate.attempt(rules, realm._rules.settings.validate.schema, realm._rules.settings.validate.options);
          const config2 = realm._rules.processor(source, info);
          if (config2) {
            configs.unshift(config2);
          }
        }
        realm = realm.parent;
      }
      return internals.config(configs);
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/cors.js
var require_cors = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/cors.js"(exports2) {
    "use strict";
    var Boom = require_lib6();
    var Hoek = require_lib();
    var Route = null;
    var internals = {};
    exports2.route = function(options3) {
      if (!options3) {
        return false;
      }
      const settings = Hoek.clone(options3);
      settings._headers = settings.headers.concat(settings.additionalHeaders);
      settings._headersString = settings._headers.join(",");
      for (let i2 = 0; i2 < settings._headers.length; ++i2) {
        settings._headers[i2] = settings._headers[i2].toLowerCase();
      }
      if (settings._headers.indexOf("origin") === -1) {
        settings._headers.push("origin");
      }
      settings._exposedHeaders = settings.exposedHeaders.concat(settings.additionalExposedHeaders).join(",");
      if (settings.origin === "ignore") {
        settings._origin = false;
      } else if (settings.origin.indexOf("*") !== -1) {
        Hoek.assert(settings.origin.length === 1, "Cannot specify cors.origin * together with other values");
        settings._origin = true;
      } else {
        settings._origin = {
          qualified: [],
          wildcards: []
        };
        for (const origin of settings.origin) {
          if (origin.indexOf("*") !== -1) {
            settings._origin.wildcards.push(new RegExp("^" + Hoek.escapeRegex(origin).replace(/\\\*/g, ".*").replace(/\\\?/g, ".") + "$"));
          } else {
            settings._origin.qualified.push(origin);
          }
        }
      }
      return settings;
    };
    exports2.options = function(route, server) {
      if (route.method === "options" || !route.settings.cors) {
        return;
      }
      exports2.handler(server);
    };
    exports2.handler = function(server) {
      Route = Route || require_route();
      if (server._core.router.specials.options) {
        return;
      }
      const definition = {
        method: "_special",
        path: "/{p*}",
        handler: internals.handler,
        options: {
          cors: false
        }
      };
      const route = new Route(definition, server, {
        special: true
      });
      server._core.router.special("options", route);
    };
    internals.handler = function(request, h2) {
      const method = request.headers["access-control-request-method"];
      if (!method) {
        throw Boom.notFound("CORS error: Missing Access-Control-Request-Method header");
      }
      const route = request.server.match(method, request.path, request.info.hostname);
      if (!route) {
        throw Boom.notFound();
      }
      const settings = route.settings.cors;
      if (!settings) {
        return {
          message: "CORS is disabled for this route"
        };
      }
      const origin = request.headers.origin;
      if (!origin && settings._origin !== false) {
        throw Boom.notFound("CORS error: Missing Origin header");
      }
      if (!exports2.matchOrigin(origin, settings)) {
        return {
          message: "CORS error: Origin not allowed"
        };
      }
      let headers = request.headers["access-control-request-headers"];
      if (headers) {
        headers = headers.toLowerCase().split(/\s*,\s*/);
        if (Hoek.intersect(headers, settings._headers).length !== headers.length) {
          return {
            message: "CORS error: Some headers are not allowed"
          };
        }
      }
      const response = h2.response();
      response.code(settings.preflightStatusCode);
      response._header("access-control-allow-origin", settings._origin ? origin : "*");
      response._header("access-control-allow-methods", method);
      response._header("access-control-allow-headers", settings._headersString);
      response._header("access-control-max-age", settings.maxAge);
      if (settings.credentials) {
        response._header("access-control-allow-credentials", "true");
      }
      if (settings._exposedHeaders) {
        response._header("access-control-expose-headers", settings._exposedHeaders);
      }
      return response;
    };
    exports2.headers = function(response) {
      const request = response.request;
      const settings = request.route.settings.cors;
      if (settings._origin !== false) {
        response.vary("origin");
      }
      if (request.info.cors && !request.info.cors.isOriginMatch || // After route lookup
      !exports2.matchOrigin(request.headers.origin, request.route.settings.cors)) {
        return;
      }
      response._header("access-control-allow-origin", settings._origin ? request.headers.origin : "*");
      if (settings.credentials) {
        response._header("access-control-allow-credentials", "true");
      }
      if (settings._exposedHeaders) {
        response._header("access-control-expose-headers", settings._exposedHeaders, {
          append: true
        });
      }
    };
    exports2.matchOrigin = function(origin, settings) {
      if (settings._origin === true || settings._origin === false) {
        return true;
      }
      if (!origin) {
        return false;
      }
      if (settings._origin.qualified.indexOf(origin) !== -1) {
        return true;
      }
      for (const wildcard of settings._origin.wildcards) {
        if (origin.match(wildcard)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/toolkit.js
var require_toolkit = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/toolkit.js"(exports2) {
    "use strict";
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {};
    exports2.reserved = [
      "abandon",
      "authenticated",
      "close",
      "context",
      "continue",
      "entity",
      "redirect",
      "realm",
      "request",
      "response",
      "state",
      "unauthenticated",
      "unstate"
    ];
    exports2.symbols = {
      abandon: Symbol("abandon"),
      close: Symbol("close"),
      continue: Symbol("continue")
    };
    exports2.Manager = class {
      constructor() {
        this._toolkit = internals.toolkit();
      }
      async execute(method, request, options3) {
        const h2 = new this._toolkit(request, options3);
        const bind = options3.bind ?? null;
        try {
          let operation;
          if (bind) {
            operation = method.call(bind, request, h2);
          } else if (options3.args) {
            operation = method(request, h2, ...options3.args);
          } else {
            operation = method(request, h2);
          }
          var response = await exports2.timed(operation, options3);
        } catch (err) {
          if (Bounce.isSystem(err)) {
            response = Boom.badImplementation(err);
          } else if (!Bounce.isError(err)) {
            response = Boom.badImplementation("Cannot throw non-error object", err);
          } else {
            response = Boom.boomify(err);
          }
        }
        if (options3.ignoreResponse) {
          return response;
        }
        if (response === void 0) {
          response = Boom.badImplementation(`${method.name} method did not return a value, a promise, or throw an error`);
        }
        if (options3.continue && response === exports2.symbols.continue) {
          if (options3.continue === "undefined") {
            return;
          }
          response = null;
        }
        if (options3.auth && response instanceof internals.Auth) {
          return response;
        }
        if (typeof response !== "symbol") {
          response = request._core.Response.wrap(response, request);
          if (!response.isBoom && response._state === "init") {
            await response._prepare();
          }
        }
        return response;
      }
      decorate(name, method) {
        this._toolkit.prototype[name] = method;
      }
      async failAction(request, failAction, err, options3) {
        const retain = options3.retain ? err : void 0;
        if (failAction === "ignore") {
          return retain;
        }
        if (failAction === "log") {
          request._log(options3.tags, err);
          return retain;
        }
        if (failAction === "error") {
          throw err;
        }
        return await this.execute(failAction, request, {
          realm: request.route.realm,
          args: [
            options3.details ?? err
          ]
        });
      }
    };
    exports2.timed = async function(method, options3) {
      if (!options3.timeout) {
        return method;
      }
      const timer2 = new Promise((resolve7, reject) => {
        const handler = () => {
          reject(Boom.internal(`${options3.name} timed out`));
        };
        setTimeout(handler, options3.timeout);
      });
      return await Promise.race([
        timer2,
        method
      ]);
    };
    internals.toolkit = function() {
      const Toolkit = class {
        constructor(request, options3) {
          this.context = options3.bind;
          this.realm = options3.realm;
          this.request = request;
          this._auth = options3.auth;
        }
        response(result) {
          Hoek.assert(!result || typeof result !== "object" || typeof result.then !== "function", "Cannot wrap a promise");
          Hoek.assert(result instanceof Error === false, "Cannot wrap an error");
          Hoek.assert(typeof result !== "symbol", "Cannot wrap a symbol");
          return this.request._core.Response.wrap(result, this.request);
        }
        redirect(location) {
          return this.response("").redirect(location);
        }
        entity(options3) {
          Hoek.assert(options3, "Entity method missing required options");
          Hoek.assert(options3.etag || options3.modified, "Entity methods missing required options key");
          this.request._entity = options3;
          const entity = this.request._core.Response.entity(options3.etag, options3);
          if (this.request._core.Response.unmodified(this.request, entity)) {
            return this.response().code(304).takeover();
          }
        }
        state(name, value, options3) {
          this.request._setState(name, value, options3);
        }
        unstate(name, options3) {
          this.request._clearState(name, options3);
        }
        authenticated(data) {
          Hoek.assert(this._auth, "Method not supported outside of authentication");
          Hoek.assert(data?.credentials, "Authentication data missing credentials information");
          return new internals.Auth(null, data);
        }
        unauthenticated(error40, data) {
          Hoek.assert(this._auth, "Method not supported outside of authentication");
          Hoek.assert(!data || data.credentials, "Authentication data missing credentials information");
          return new internals.Auth(error40, data);
        }
      };
      Toolkit.prototype.abandon = exports2.symbols.abandon;
      Toolkit.prototype.close = exports2.symbols.close;
      Toolkit.prototype.continue = exports2.symbols.continue;
      return Toolkit;
    };
    internals.Auth = class {
      constructor(error40, data) {
        this.isAuth = true;
        this.error = error40;
        this.data = data;
      }
    };
  }
});

// node_modules/.deno/@hapi+ammo@6.0.1/node_modules/@hapi/ammo/lib/index.js
var require_lib27 = __commonJS({
  "node_modules/.deno/@hapi+ammo@6.0.1/node_modules/@hapi/ammo/lib/index.js"(exports2) {
    "use strict";
    var Stream = __require("node:stream");
    var Hoek = require_lib();
    var internals = {};
    internals.headerRx = /^bytes=[\s,]*((?:(?:\d+\-\d*)|(?:\-\d+))(?:\s*,\s*(?:(?:\d+\-\d*)|(?:\-\d+)))*)$/i;
    exports2.header = function(header, length4) {
      const parts = internals.headerRx.exec(header);
      if (!parts) {
        return null;
      }
      const lastPos = length4 - 1;
      const result = [];
      const ranges = parts[1].match(/\d*\-\d*/g);
      for (let range of ranges) {
        let from6;
        let to;
        range = range.split("-");
        if (range[0]) {
          from6 = parseInt(range[0], 10);
        }
        if (range[1]) {
          to = parseInt(range[1], 10);
          if (from6 !== void 0) {
            if (to > lastPos) {
              to = lastPos;
            }
          } else {
            from6 = length4 - to;
            to = lastPos;
          }
        } else {
          to = lastPos;
        }
        if (from6 > to) {
          return null;
        }
        result.push(new internals.Range(from6, to));
      }
      if (result.length === 1) {
        return result;
      }
      result.sort((a, b) => a.from - b.from);
      const consolidated = [];
      for (let i2 = result.length - 1; i2 > 0; --i2) {
        const current = result[i2];
        const before = result[i2 - 1];
        if (current.from <= before.to + 1) {
          before.to = current.to;
        } else {
          consolidated.unshift(current);
        }
      }
      consolidated.unshift(result[0]);
      return consolidated;
    };
    internals.Range = class {
      constructor(from6, to) {
        this.from = from6;
        this.to = to;
      }
    };
    exports2.Clip = class extends Stream.Transform {
      constructor(range) {
        if (!(range instanceof internals.Range)) {
          Hoek.assert(typeof range === "object", 'Expected "range" object');
          const from6 = range.from ?? 0;
          Hoek.assert(typeof from6 === "number", '"range.from" must be a number');
          Hoek.assert(from6 === parseInt(from6, 10) && from6 >= 0, '"range.from" must be a positive integer');
          const to = range.to ?? 0;
          Hoek.assert(typeof to === "number", '"range.to" must be a number');
          Hoek.assert(to === parseInt(to, 10) && to >= 0, '"range.to" must be a positive integer');
          Hoek.assert(to >= from6, '"range.to" must be greater than or equal to "range.from"');
          range = new internals.Range(from6, to);
        }
        super();
        this._range = range;
        this._next = 0;
        this._pipes = /* @__PURE__ */ new Set();
        this.on("pipe", (pipe2) => this._pipes.add(pipe2));
        this.on("unpipe", (pipe2) => this._pipes.delete(pipe2));
      }
      _transform(chunk, encoding, done) {
        try {
          internals.processChunk(this, chunk);
        } catch (err) {
          return done(err);
        }
        return done();
      }
      _flush(done) {
        this._pipes.clear();
        done();
      }
    };
    internals.processChunk = function(stream, chunk) {
      const pos = stream._next;
      stream._next = stream._next + chunk.length;
      if (stream._next <= stream._range.from) {
        return;
      }
      if (pos > stream._range.to) {
        for (const pipe2 of stream._pipes) {
          pipe2.unpipe(stream);
        }
        stream._pipes.clear();
        stream.end();
        return;
      }
      const from6 = Math.max(0, stream._range.from - pos);
      const to = Math.min(chunk.length, stream._range.to - pos + 1);
      stream.push(chunk.slice(from6, to));
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/transmit.js
var require_transmit = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/transmit.js"(exports2) {
    "use strict";
    var Http = __require("node:http");
    var Ammo = require_lib27();
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Teamwork = require_lib5();
    var Config = require_config();
    var internals = {};
    exports2.send = async function(request) {
      const response = request.response;
      try {
        if (response.isBoom) {
          await internals.fail(request, response);
          return;
        }
        await internals.marshal(response);
        await internals.transmit(response);
      } catch (err) {
        Bounce.rethrow(err, "system");
        request._setResponse(err);
        return internals.fail(request, err);
      }
    };
    internals.marshal = async function(response) {
      for (const func of response.request._route._marshalCycle) {
        await func(response);
      }
    };
    internals.fail = async function(request, boom) {
      const response = internals.error(request, boom);
      request.response = response;
      try {
        await internals.marshal(response);
      } catch (err) {
        Bounce.rethrow(err, "system");
        const minimal = {
          statusCode: response.statusCode,
          error: Http.STATUS_CODES[response.statusCode],
          message: boom.message
        };
        response._payload = new request._core.Response.Payload(JSON.stringify(minimal), {});
      }
      return internals.transmit(response);
    };
    internals.error = function(request, boom) {
      const error40 = boom.output;
      const response = new request._core.Response(error40.payload, request, {
        error: boom
      });
      response.code(error40.statusCode);
      response.headers = Hoek.clone(error40.headers);
      return response;
    };
    internals.transmit = function(response) {
      const request = response.request;
      const length4 = internals.length(response);
      const encoding = request._core.compression.encoding(response, length4);
      const ranger = encoding ? null : internals.range(response, length4);
      const compressor = internals.encoding(response, encoding);
      const isInjection = request.isInjected;
      if (!(isInjection || request._core.started) || request._isPayloadPending && !request.raw.req._readableState.ended) {
        response._header("connection", "close");
      }
      internals.writeHead(response);
      if (isInjection) {
        request.raw.res[Config.symbol] = {
          request
        };
        if (response.variety === "plain") {
          request.raw.res[Config.symbol].result = response._isPayloadSupported() ? response.source : null;
        }
      }
      const stream = internals.chain([
        response._payload,
        response._tap(),
        compressor,
        ranger
      ]);
      return internals.pipe(request, stream);
    };
    internals.length = function(response) {
      const request = response.request;
      const header = response.headers["content-length"];
      if (header === void 0) {
        return null;
      }
      let length4 = header;
      if (typeof length4 === "string") {
        length4 = parseInt(header, 10);
        if (!isFinite(length4)) {
          delete response.headers["content-length"];
          return null;
        }
      }
      if (length4 === 0 && !response._statusCode && response.statusCode === 200 && request.route.settings.response.emptyStatusCode !== 200) {
        response.code(204);
        delete response.headers["content-length"];
      }
      return length4;
    };
    internals.range = function(response, length4) {
      const request = response.request;
      if (!length4 || !request.route.settings.response.ranges || request.method !== "get" || response.statusCode !== 200) {
        return null;
      }
      response._header("accept-ranges", "bytes");
      if (!request.headers.range) {
        return null;
      }
      if (request.headers["if-range"] && request.headers["if-range"] !== response.headers.etag) {
        return null;
      }
      const ranges = Ammo.header(request.headers.range, length4);
      if (!ranges) {
        const error40 = Boom.rangeNotSatisfiable();
        error40.output.headers["content-range"] = "bytes */" + length4;
        throw error40;
      }
      if (ranges.length !== 1) {
        return null;
      }
      const range = ranges[0];
      response.code(206);
      response.bytes(range.to - range.from + 1);
      response._header("content-range", "bytes " + range.from + "-" + range.to + "/" + length4);
      return new Ammo.Clip(range);
    };
    internals.encoding = function(response, encoding) {
      const request = response.request;
      const header = response.headers["content-encoding"] || encoding;
      if (header && response.headers.etag && response.settings.varyEtag) {
        response.headers.etag = response.headers.etag.slice(0, -1) + "-" + header + '"';
      }
      if (!encoding || response.statusCode === 206 || !response._isPayloadSupported()) {
        return null;
      }
      delete response.headers["content-length"];
      response._header("content-encoding", encoding);
      const compressor = request._core.compression.encoder(request, encoding);
      if (response.variety === "stream" && typeof response._payload.setCompressor === "function") {
        response._payload.setCompressor(compressor);
      }
      return compressor;
    };
    internals.pipe = function(request, stream) {
      const team = new Teamwork.Team();
      const env = {
        stream,
        request,
        team
      };
      if (request._closed) {
        internals.end(env, "aborted");
        return team.work;
      }
      const aborted2 = internals.end.bind(null, env, "aborted");
      const close = internals.end.bind(null, env, "close");
      const end = internals.end.bind(null, env, null);
      request.raw.req.on("aborted", aborted2);
      request.raw.res.on("close", close);
      request.raw.res.on("error", end);
      request.raw.res.on("finish", end);
      if (stream.writeToStream) {
        stream.writeToStream(request.raw.res);
      } else {
        stream.on("error", end);
        stream.on("close", aborted2);
        stream.pipe(request.raw.res);
      }
      return team.work;
    };
    internals.end = function(env, event, err) {
      const { request, stream, team } = env;
      if (!team) {
        return;
      }
      env.team = null;
      if (request.raw.res.writableEnded) {
        request.info.responded = Date.now();
        team.attend();
        return;
      }
      if (err) {
        request.raw.res.destroy();
        request._core.Response.drain(stream);
      }
      const origResponse = request.response;
      const error40 = err ? Boom.boomify(err) : new Boom.Boom(`Request ${event}`, {
        statusCode: request.route.settings.response.disconnectStatusCode,
        data: origResponse
      });
      request._setResponse(error40);
      if (request.raw.res[Config.symbol]) {
        request.raw.res[Config.symbol].error = event ? error40 : new Boom.Boom(`Response error`, {
          statusCode: request.route.settings.response.disconnectStatusCode,
          data: origResponse
        });
      }
      if (event) {
        request._log([
          "response",
          "error",
          event
        ]);
      } else {
        request._log([
          "response",
          "error"
        ], err);
      }
      request.raw.res.end();
      team.attend();
    };
    internals.writeHead = function(response) {
      const res = response.request.raw.res;
      const headers = Object.keys(response.headers);
      let i2 = 0;
      try {
        for (; i2 < headers.length; ++i2) {
          const header = headers[i2];
          const value = response.headers[header];
          if (value !== void 0) {
            res.setHeader(header, value);
          }
        }
      } catch (err) {
        for (--i2; i2 >= 0; --i2) {
          res.removeHeader(headers[i2]);
        }
        throw Boom.boomify(err);
      }
      if (response.settings.message) {
        res.statusMessage = response.settings.message;
      }
      try {
        res.writeHead(response.statusCode);
      } catch (err) {
        throw Boom.boomify(err);
      }
    };
    internals.chain = function(sources) {
      let from6 = sources[0];
      for (let i2 = 1; i2 < sources.length; ++i2) {
        const to = sources[i2];
        if (to) {
          from6.on("close", internals.destroyPipe.bind(from6, to));
          from6.on("error", internals.errorPipe.bind(from6, to));
          from6 = from6.pipe(to);
        }
      }
      return from6;
    };
    internals.destroyPipe = function(to) {
      if (!this.readableEnded && !this.errored) {
        to.destroy();
      }
    };
    internals.errorPipe = function(to, err) {
      to.emit("error", err);
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/request.js
var require_request2 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/request.js"(exports2, module2) {
    "use strict";
    var Querystring = __require("node:querystring");
    var Url2 = __require("node:url");
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Cors = require_cors();
    var Toolkit = require_toolkit();
    var Transmit = require_transmit();
    var internals = {
      events: Podium.validate([
        "finish",
        {
          name: "peek",
          spread: true
        },
        "disconnect"
      ]),
      reserved: [
        "server",
        "url",
        "query",
        "path",
        "method",
        "mime",
        "setUrl",
        "setMethod",
        "headers",
        "id",
        "app",
        "plugins",
        "route",
        "auth",
        "pre",
        "preResponses",
        "info",
        "isInjected",
        "orig",
        "params",
        "paramsArray",
        "payload",
        "state",
        "response",
        "raw",
        "domain",
        "log",
        "logs",
        "generateResponse"
      ]
    };
    exports2 = module2.exports = internals.Request = class {
      constructor(server, req, res, options3) {
        this._allowInternals = !!options3.allowInternals;
        this._closed = false;
        this._core = server._core;
        this._entity = null;
        this._eventContext = {
          request: this
        };
        this._events = null;
        this._expectContinue = !!options3.expectContinue;
        this._isInjected = !!options3.isInjected;
        this._isPayloadPending = !!(req.headers["content-length"] || req.headers["transfer-encoding"]);
        this._isReplied = false;
        this._route = this._core.router.specials.notFound.route;
        this._serverTimeoutId = null;
        this._states = {};
        this._url = null;
        this._urlError = null;
        this.app = options3.app ? Object.assign({}, options3.app) : {};
        this.headers = req.headers;
        this.logs = [];
        this.method = req.method.toLowerCase();
        this.mime = null;
        this.orig = {};
        this.params = null;
        this.paramsArray = null;
        this.path = null;
        this.payload = void 0;
        this.plugins = options3.plugins ? Object.assign({}, options3.plugins) : {};
        this.pre = {};
        this.preResponses = {};
        this.raw = {
          req,
          res
        };
        this.response = null;
        this.route = this._route.public;
        this.query = null;
        this.server = server;
        this.state = null;
        this.info = new internals.Info(this);
        this.auth = {
          isAuthenticated: false,
          isAuthorized: false,
          isInjected: options3.auth ? true : false,
          [internals.Request.symbols.authPayload]: options3.auth?.payload ?? true,
          credentials: options3.auth?.credentials ?? null,
          artifacts: options3.auth?.artifacts ?? null,
          strategy: options3.auth?.strategy ?? null,
          mode: null,
          error: null
        };
        this._initializeUrl();
      }
      static generate(server, req, res, options3) {
        const request = new server._core.Request(server, req, res, options3);
        if (server._core.decorations.requestApply) {
          for (const [property, assignment] of server._core.decorations.requestApply.entries()) {
            request[property] = assignment(request);
          }
        }
        request._listen();
        return request;
      }
      get events() {
        if (!this._events) {
          this._events = new Podium.Podium(internals.events);
        }
        return this._events;
      }
      get isInjected() {
        return this._isInjected;
      }
      get url() {
        if (this._urlError) {
          return null;
        }
        if (this._url) {
          return this._url;
        }
        return this._parseUrl(this.raw.req.url, this._core.settings.router);
      }
      _initializeUrl() {
        try {
          this._setUrl(this.raw.req.url, this._core.settings.router.stripTrailingSlash, {
            fast: true
          });
        } catch (err) {
          this.path = this.raw.req.url;
          this.query = {};
          this._urlError = Boom.boomify(err, {
            statusCode: 400,
            override: false
          });
        }
      }
      setUrl(url2, stripTrailingSlash) {
        Hoek.assert(this.params === null, "Cannot change request URL after routing");
        if (url2 instanceof Url2.URL) {
          url2 = url2.href;
        }
        Hoek.assert(typeof url2 === "string", "Url must be a string or URL object");
        this._setUrl(url2, stripTrailingSlash, {
          fast: false
        });
      }
      _setUrl(source, stripTrailingSlash, { fast }) {
        const url2 = this._parseUrl(source, {
          stripTrailingSlash,
          _fast: fast
        });
        this.query = this._parseQuery(url2.searchParams);
        this.path = url2.pathname;
      }
      _parseUrl(source, options3) {
        if (source[0] === "/") {
          if (options3._fast) {
            const url2 = {
              pathname: source,
              searchParams: ""
            };
            const q = source.indexOf("?");
            const h2 = source.indexOf("#");
            if (q !== -1 && (h2 === -1 || q < h2)) {
              url2.pathname = source.slice(0, q);
              const query = h2 === -1 ? source.slice(q + 1) : source.slice(q + 1, h2);
              url2.searchParams = Querystring.parse(query);
            } else {
              url2.pathname = h2 === -1 ? source : source.slice(0, h2);
            }
            this._normalizePath(url2, options3);
            return url2;
          }
          this._url = new Url2.URL(`${this._core.info.protocol}://${this.info.host || `${this._core.info.host}:${this._core.info.port}`}${source}`);
        } else {
          this._url = new Url2.URL(source);
          this.info.hostname = this._url.hostname;
          this.info.host = this._url.host;
        }
        this._normalizePath(this._url, options3);
        this._urlError = null;
        return this._url;
      }
      _normalizePath(url2, options3) {
        let path = this._core.router.normalize(url2.pathname);
        if (options3.stripTrailingSlash && path.length > 1 && path[path.length - 1] === "/") {
          path = path.slice(0, -1);
        }
        url2.pathname = path;
      }
      _parseQuery(searchParams) {
        let query = /* @__PURE__ */ Object.create(null);
        if (searchParams instanceof Url2.URLSearchParams) {
          for (let [key, value] of searchParams) {
            const entry = query[key];
            if (entry !== void 0) {
              value = [].concat(entry, value);
            }
            query[key] = value;
          }
        } else {
          query = Object.assign(query, searchParams);
        }
        const parser2 = this._core.settings.query.parser;
        if (parser2) {
          query = parser2(query);
          if (!query || typeof query !== "object") {
            throw Boom.badImplementation("Parsed query must be an object");
          }
        }
        return query;
      }
      setMethod(method) {
        Hoek.assert(this.params === null, "Cannot change request method after routing");
        Hoek.assert(method && typeof method === "string", "Missing method");
        this.method = method.toLowerCase();
      }
      active() {
        return !!this._eventContext.request;
      }
      async _execute() {
        this.info.acceptEncoding = this._core.compression.accept(this);
        try {
          await this._onRequest();
        } catch (err) {
          Bounce.rethrow(err, "system");
          return this._reply(err);
        }
        this._lookup();
        this._setTimeouts();
        await this._lifecycle();
        this._reply();
      }
      async _onRequest() {
        if (this._core.extensions.route.onRequest.nodes) {
          const response = await this._invoke(this._core.extensions.route.onRequest);
          if (response) {
            if (!internals.skip(response)) {
              throw Boom.badImplementation("onRequest extension methods must return an error, a takeover response, or a continue signal");
            }
            throw response;
          }
        }
        if (this._urlError) {
          throw this._urlError;
        }
      }
      _listen() {
        if (this._isPayloadPending) {
          this.raw.req.on("end", internals.event.bind(this.raw.req, this._eventContext, "end"));
        }
        this.raw.res.on("close", internals.event.bind(this.raw.res, this._eventContext, "close"));
        this.raw.req.on("error", internals.event.bind(this.raw.req, this._eventContext, "error"));
        this.raw.req.on("aborted", internals.event.bind(this.raw.req, this._eventContext, "abort"));
        this.raw.res.once("close", internals.closed.bind(this.raw.res, this));
      }
      _lookup() {
        const match = this._core.router.route(this.method, this.path, this.info.hostname);
        if (!match.route.settings.isInternal || this._allowInternals) {
          this._route = match.route;
          this.route = this._route.public;
        }
        this.params = match.params ?? {};
        this.paramsArray = match.paramsArray ?? [];
        if (this.route.settings.cors) {
          this.info.cors = {
            isOriginMatch: Cors.matchOrigin(this.headers.origin, this.route.settings.cors)
          };
        }
      }
      _setTimeouts() {
        if (this.raw.req.socket && this.route.settings.timeout.socket !== void 0) {
          this.raw.req.socket.setTimeout(this.route.settings.timeout.socket || 0);
        }
        let serverTimeout = this.route.settings.timeout.server;
        if (!serverTimeout) {
          return;
        }
        const elapsed = Date.now() - this.info.received;
        serverTimeout = Math.floor(serverTimeout - elapsed);
        if (serverTimeout <= 0) {
          internals.timeoutReply(this, serverTimeout);
          return;
        }
        this._serverTimeoutId = setTimeout(internals.timeoutReply, serverTimeout, this, serverTimeout);
      }
      async _lifecycle() {
        for (const func of this._route._cycle) {
          if (this._isReplied) {
            return;
          }
          try {
            var response = await (typeof func === "function" ? func(this) : this._invoke(func));
          } catch (err) {
            Bounce.rethrow(err, "system");
            response = this._core.Response.wrap(err, this);
          }
          if (!response || response === Toolkit.symbols.continue) {
            continue;
          }
          if (!internals.skip(response)) {
            response = Boom.badImplementation("Lifecycle methods called before the handler can only return an error, a takeover response, or a continue signal");
          }
          this._setResponse(response);
          return;
        }
      }
      async _invoke(event, options3 = {}) {
        for (const ext of event.nodes) {
          const realm = ext.realm;
          const bind = ext.bind ?? realm.settings.bind;
          const response = await this._core.toolkit.execute(ext.func, this, {
            bind,
            realm,
            timeout: ext.timeout,
            name: event.type,
            ignoreResponse: options3.ignoreResponse
          });
          if (options3.ignoreResponse) {
            if (Boom.isBoom(response)) {
              this._log([
                "ext",
                "error"
              ], response);
            }
            continue;
          }
          if (response === Toolkit.symbols.continue) {
            continue;
          }
          if (internals.skip(response) || this.response === null) {
            return response;
          }
          this._setResponse(response);
        }
      }
      async _reply(exit) {
        if (this._isReplied) {
          return;
        }
        this._isReplied = true;
        if (this._serverTimeoutId) {
          clearTimeout(this._serverTimeoutId);
        }
        if (exit) {
          this._setResponse(this._core.Response.wrap(exit, this));
        }
        if (!this._eventContext.request) {
          this._finalize();
          return;
        }
        if (typeof this.response === "symbol") {
          this._abort();
          return;
        }
        await this._postCycle();
        if (!this._eventContext.request || typeof this.response === "symbol") {
          this._abort();
          return;
        }
        await Transmit.send(this);
        this._finalize();
      }
      async _postCycle() {
        for (const func of this._route._postCycle) {
          if (!this._eventContext.request) {
            return;
          }
          try {
            var response = await (typeof func === "function" ? func(this) : this._invoke(func));
          } catch (err) {
            Bounce.rethrow(err, "system");
            response = this._core.Response.wrap(err, this);
          }
          if (response && response !== Toolkit.symbols.continue) {
            this._setResponse(response);
          }
        }
      }
      _abort() {
        if (this.response === Toolkit.symbols.close) {
          this.raw.res.end();
        }
        this._finalize();
      }
      _finalize() {
        this._eventContext.request = null;
        if (this.response._close) {
          if (this.response.statusCode === 500 && this.response._error) {
            const tags = this.response._error.isDeveloperError ? [
              "internal",
              "implementation",
              "error"
            ] : [
              "internal",
              "error"
            ];
            this._log(tags, this.response._error, "error");
          }
          this.response._close();
        }
        this.info.completed = Date.now();
        this._core.events.emit("response", this);
        if (this._route._extensions.onPostResponse.nodes) {
          this._invoke(this._route._extensions.onPostResponse, {
            ignoreResponse: true
          });
        }
      }
      _setResponse(response) {
        if (this.response && !this.response.isBoom && this.response !== response && this.response.source !== response.source) {
          this.response._close?.();
        }
        if (this.info.completed) {
          response._close?.();
          return;
        }
        this.response = response;
      }
      _setState(name, value, options3) {
        const state = {
          name,
          value
        };
        if (options3) {
          Hoek.assert(!options3.autoValue, "Cannot set autoValue directly in a response");
          state.options = Hoek.clone(options3);
        }
        this._states[name] = state;
      }
      _clearState(name, options3 = {}) {
        const state = {
          name
        };
        state.options = Hoek.clone(options3);
        state.options.ttl = 0;
        this._states[name] = state;
      }
      _tap() {
        if (!this._events) {
          return null;
        }
        if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
          return new this._core.Response.Peek(this._events);
        }
        return null;
      }
      log(tags, data) {
        return this._log(tags, data, "app");
      }
      _log(tags, data, channel = "internal") {
        if (!this._core.events.hasListeners("request") && !this.route.settings.log.collect) {
          return;
        }
        if (!Array.isArray(tags)) {
          tags = [
            tags
          ];
        }
        const timestamp = Date.now();
        const field = data instanceof Error ? "error" : "data";
        let event = [
          this,
          {
            request: this.info.id,
            timestamp,
            tags,
            [field]: data,
            channel
          }
        ];
        if (typeof data === "function") {
          event = () => [
            this,
            {
              request: this.info.id,
              timestamp,
              tags,
              data: data(),
              channel
            }
          ];
        }
        if (this.route.settings.log.collect) {
          if (typeof data === "function") {
            event = event();
          }
          this.logs.push(event[1]);
        }
        this._core.events.emit({
          name: "request",
          channel,
          tags
        }, event);
      }
      generateResponse(source, options3) {
        return new this._core.Response(source, this, options3);
      }
    };
    internals.Request.reserved = internals.reserved;
    internals.Request.symbols = {
      authPayload: Symbol("auth.payload")
    };
    internals.Info = class {
      constructor(request) {
        this._request = request;
        const req = request.raw.req;
        const host = req.headers.host ? req.headers.host.trim() : "";
        const received = Date.now();
        this.received = received;
        this.referrer = req.headers.referrer || req.headers.referer || "";
        this.host = host;
        this.hostname = host.split(":")[0];
        this.id = `${received}:${request._core.info.id}:${request._core._counter()}`;
        this._remoteAddress = null;
        this._remotePort = null;
        this.acceptEncoding = null;
        this.cors = null;
        this.responded = 0;
        this.completed = 0;
        if (request._core.settings.info.remote) {
          this.remoteAddress;
          this.remotePort;
        }
      }
      get remoteAddress() {
        if (!this._remoteAddress) {
          const ipv6Prefix = "::ffff:";
          const socketAddress = this._request.raw.req.socket.remoteAddress;
          if (socketAddress && socketAddress.startsWith(ipv6Prefix) && socketAddress.includes(".", ipv6Prefix.length)) {
            this._remoteAddress = socketAddress.slice(ipv6Prefix.length);
          } else {
            this._remoteAddress = socketAddress;
          }
        }
        return this._remoteAddress;
      }
      get remotePort() {
        if (this._remotePort === null) {
          this._remotePort = this._request.raw.req.socket.remotePort || "";
        }
        return this._remotePort;
      }
      toJSON() {
        return {
          acceptEncoding: this.acceptEncoding,
          completed: this.completed,
          cors: this.cors,
          host: this.host,
          hostname: this.hostname,
          id: this.id,
          received: this.received,
          referrer: this.referrer,
          remoteAddress: this.remoteAddress,
          remotePort: this.remotePort,
          responded: this.responded
        };
      }
    };
    internals.closed = function(request) {
      request._closed = true;
    };
    internals.event = function({ request }, event, err) {
      if (!request) {
        return;
      }
      request._isPayloadPending = false;
      if (event === "close" && request.raw.res.writableEnded) {
        return;
      }
      if (event === "end") {
        return;
      }
      request._log(err ? [
        "request",
        "error"
      ] : [
        "request",
        "error",
        event
      ], err);
      if (event === "error") {
        return;
      }
      request._eventContext.request = null;
      if (event === "abort") {
        request._reply(new Boom.Boom("Request aborted", {
          statusCode: request.route.settings.response.disconnectStatusCode,
          data: request.response
        }));
        if (request._events) {
          request._events.emit("disconnect");
        }
      }
    };
    internals.timeoutReply = function(request, timeout) {
      const elapsed = Date.now() - request.info.received;
      request._log([
        "request",
        "server",
        "timeout",
        "error"
      ], {
        timeout,
        elapsed
      });
      request._reply(Boom.serverUnavailable());
    };
    internals.skip = function(response) {
      return response.isBoom || response._takeover || typeof response === "symbol";
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/auth.js
var require_auth = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/auth.js"(exports2, module2) {
    "use strict";
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Config = require_config();
    var Request2 = require_request2();
    var internals = {
      missing: Symbol("missing")
    };
    exports2 = module2.exports = internals.Auth = class {
      #core = null;
      #schemes = {};
      #strategies = {};
      api = {};
      settings = {
        default: null
        // Strategy used as default if route has no auth settings
      };
      constructor(core) {
        this.#core = core;
      }
      public(server) {
        return {
          api: this.api,
          settings: this.settings,
          scheme: this.scheme.bind(this),
          strategy: this._strategy.bind(this, server),
          default: this.default.bind(this),
          test: this.test.bind(this),
          verify: this.verify.bind(this),
          lookup: this.lookup.bind(this)
        };
      }
      scheme(name, scheme) {
        Hoek.assert(name, "Authentication scheme must have a name");
        Hoek.assert(!this.#schemes[name], "Authentication scheme name already exists:", name);
        Hoek.assert(typeof scheme === "function", "scheme must be a function:", name);
        this.#schemes[name] = scheme;
      }
      _strategy(server, name, scheme, options3 = {}) {
        Hoek.assert(name, "Authentication strategy must have a name");
        Hoek.assert(typeof options3 === "object", "options must be an object");
        Hoek.assert(!this.#strategies[name], "Authentication strategy name already exists");
        Hoek.assert(scheme, "Authentication strategy", name, "missing scheme");
        Hoek.assert(this.#schemes[scheme], "Authentication strategy", name, "uses unknown scheme:", scheme);
        server = server._clone();
        const strategy = this.#schemes[scheme](server, options3);
        Hoek.assert(strategy.authenticate, "Invalid scheme:", name, "missing authenticate() method");
        Hoek.assert(typeof strategy.authenticate === "function", "Invalid scheme:", name, "invalid authenticate() method");
        Hoek.assert(!strategy.payload || typeof strategy.payload === "function", "Invalid scheme:", name, "invalid payload() method");
        Hoek.assert(!strategy.response || typeof strategy.response === "function", "Invalid scheme:", name, "invalid response() method");
        strategy.options = strategy.options ?? {};
        Hoek.assert(strategy.payload || !strategy.options.payload, "Cannot require payload validation without a payload method");
        this.#strategies[name] = {
          methods: strategy,
          realm: server.realm
        };
        if (strategy.api) {
          this.api[name] = strategy.api;
        }
      }
      default(options3) {
        Hoek.assert(!this.settings.default, "Cannot set default strategy more than once");
        options3 = Config.apply("auth", options3, "default strategy");
        this.settings.default = this._setupRoute(Hoek.clone(options3));
        const routes = this.#core.router.table();
        for (const route of routes) {
          route.rebuild();
        }
      }
      async test(name, request) {
        Hoek.assert(name, "Missing authentication strategy name");
        const strategy = this.#strategies[name];
        Hoek.assert(strategy, "Unknown authentication strategy:", name);
        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, {
          bind,
          realm,
          auth: true
        });
        if (!response.isAuth) {
          throw response;
        }
        if (response.error) {
          throw response.error;
        }
        return response.data;
      }
      async verify(request) {
        const auth = request.auth;
        if (auth.error) {
          throw auth.error;
        }
        if (!auth.isAuthenticated) {
          return;
        }
        const strategy = this.#strategies[auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", auth.strategy);
        if (!strategy.methods.verify) {
          return;
        }
        const bind = strategy.methods;
        await strategy.methods.verify.call(bind, auth);
      }
      static testAccess(request, route) {
        const auth = request._core.auth;
        try {
          return auth._access(request, route);
        } catch (err) {
          Bounce.rethrow(err, "system");
          return false;
        }
      }
      _setupRoute(options3, path) {
        if (!options3) {
          return options3;
        }
        if (typeof options3 === "string") {
          options3 = {
            strategies: [
              options3
            ]
          };
        } else if (options3.strategy) {
          options3.strategies = [
            options3.strategy
          ];
          delete options3.strategy;
        }
        if (path && !options3.strategies) {
          Hoek.assert(this.settings.default, "Route missing authentication strategy and no default defined:", path);
          options3 = Hoek.applyToDefaults(this.settings.default, options3);
        }
        path = path ?? "default strategy";
        Hoek.assert(options3.strategies?.length, "Missing authentication strategy:", path);
        options3.mode = options3.mode ?? "required";
        if (options3.entity !== void 0 || // Backwards compatibility with <= 11.x.x
        options3.scope !== void 0) {
          options3.access = [
            {
              entity: options3.entity,
              scope: options3.scope
            }
          ];
          delete options3.entity;
          delete options3.scope;
        }
        if (options3.access) {
          for (const access of options3.access) {
            access.scope = internals.setupScope(access);
          }
        }
        if (options3.payload === true) {
          options3.payload = "required";
        }
        let hasAuthenticatePayload = false;
        for (const name of options3.strategies) {
          const strategy = this.#strategies[name];
          Hoek.assert(strategy, "Unknown authentication strategy", name, "in", path);
          Hoek.assert(strategy.methods.payload || options3.payload !== "required", "Payload validation can only be required when all strategies support it in", path);
          hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;
          Hoek.assert(!strategy.methods.options.payload || options3.payload === void 0 || options3.payload === "required", "Cannot set authentication payload to", options3.payload, "when a strategy requires payload validation in", path);
        }
        Hoek.assert(!options3.payload || hasAuthenticatePayload, "Payload authentication requires at least one strategy with payload support in", path);
        return options3;
      }
      lookup(route) {
        if (route.settings.auth === false) {
          return false;
        }
        return route.settings.auth || this.settings.default;
      }
      _enabled(route, type) {
        const config2 = this.lookup(route);
        if (!config2) {
          return false;
        }
        if (type === "authenticate") {
          return true;
        }
        if (type === "access") {
          return !!config2.access;
        }
        for (const name of config2.strategies) {
          const strategy = this.#strategies[name];
          if (strategy.methods[type]) {
            return true;
          }
        }
        return false;
      }
      static authenticate(request) {
        const auth = request._core.auth;
        return auth._authenticate(request);
      }
      async _authenticate(request) {
        const config2 = this.lookup(request.route);
        const errors = [];
        request.auth.mode = config2.mode;
        if (request.auth.credentials) {
          internals.validate(null, {
            credentials: request.auth.credentials,
            artifacts: request.auth.artifacts
          }, request.auth.strategy, config2, request, errors);
          return;
        }
        for (const name of config2.strategies) {
          const strategy = this.#strategies[name];
          const bind = strategy.methods;
          const realm = strategy.realm;
          const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, {
            bind,
            realm,
            auth: true
          });
          const message = response.isAuth ? internals.validate(response.error, response.data, name, config2, request, errors) : internals.validate(response, null, name, config2, request, errors);
          if (!message) {
            return;
          }
          if (message !== internals.missing) {
            return message;
          }
        }
        const err = Boom.unauthorized("Missing authentication", errors);
        if (config2.mode === "required") {
          throw err;
        }
        request.auth.isAuthenticated = false;
        request.auth.credentials = null;
        request.auth.error = err;
        request._log([
          "auth",
          "unauthenticated"
        ]);
      }
      static access(request) {
        const auth = request._core.auth;
        request.auth.isAuthorized = auth._access(request);
      }
      _access(request, route) {
        const config2 = this.lookup(route || request.route);
        if (!config2?.access) {
          return true;
        }
        const credentials = request.auth.credentials;
        if (!credentials) {
          if (config2.mode !== "required") {
            return false;
          }
          throw Boom.forbidden("Request is unauthenticated");
        }
        const requestEntity = credentials.user ? "user" : "app";
        const scopeErrors = [];
        for (const access of config2.access) {
          const entity = access.entity;
          if (entity && entity !== "any" && entity !== requestEntity) {
            continue;
          }
          let scope = access.scope;
          if (scope) {
            if (!credentials.scope) {
              scopeErrors.push(scope);
              continue;
            }
            scope = internals.expandScope(request, scope);
            if (!internals.validateScope(credentials, scope, "required") || !internals.validateScope(credentials, scope, "selection") || !internals.validateScope(credentials, scope, "forbidden")) {
              scopeErrors.push(scope);
              continue;
            }
          }
          return true;
        }
        if (scopeErrors.length) {
          request._log([
            "auth",
            "scope",
            "error"
          ]);
          throw Boom.forbidden("Insufficient scope", {
            got: credentials.scope,
            need: scopeErrors
          });
        }
        if (requestEntity === "app") {
          request._log([
            "auth",
            "entity",
            "user",
            "error"
          ]);
          throw Boom.forbidden("Application credentials cannot be used on a user endpoint");
        }
        request._log([
          "auth",
          "entity",
          "app",
          "error"
        ]);
        throw Boom.forbidden("User credentials cannot be used on an application endpoint");
      }
      static async payload(request) {
        if (!request.auth.isAuthenticated || !request.auth[Request2.symbols.authPayload]) {
          return;
        }
        const auth = request._core.auth;
        const strategy = auth.#strategies[request.auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
        if (!strategy.methods.payload) {
          return;
        }
        const config2 = auth.lookup(request.route);
        const setting = config2.payload ?? (strategy.methods.options.payload ? "required" : false);
        if (!setting) {
          return;
        }
        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.payload, request, {
          bind,
          realm
        });
        if (response.isBoom && response.isMissing) {
          return setting === "optional" ? void 0 : Boom.unauthorized("Missing payload authentication");
        }
        return response;
      }
      static async response(response) {
        const request = response.request;
        const auth = request._core.auth;
        if (!request.auth.isAuthenticated) {
          return;
        }
        const strategy = auth.#strategies[request.auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
        if (!strategy.methods.response) {
          return;
        }
        const bind = strategy.methods;
        const realm = strategy.realm;
        const error40 = await request._core.toolkit.execute(strategy.methods.response, request, {
          bind,
          realm,
          continue: "undefined"
        });
        if (error40) {
          throw error40;
        }
      }
    };
    internals.setupScope = function(access) {
      if (!access.scope) {
        return false;
      }
      if (!Array.isArray(access.scope)) {
        return access.scope;
      }
      const scope = {};
      for (const value of access.scope) {
        const prefix = value[0];
        const type = prefix === "+" ? "required" : prefix === "!" ? "forbidden" : "selection";
        const clean = type === "selection" ? value : value.slice(1);
        scope[type] = scope[type] ?? [];
        scope[type].push(clean);
        if (!scope._hasParameters?.[type] && /{([^}]+)}/.test(clean)) {
          scope._hasParameters = scope._hasParameters ?? {};
          scope._hasParameters[type] = true;
        }
      }
      return scope;
    };
    internals.validate = function(err, result, name, config2, request, errors) {
      result = result ?? {};
      request.auth.isAuthenticated = !err;
      if (err) {
        if (err instanceof Error === false) {
          request._log([
            "auth",
            "unauthenticated",
            "response",
            name
          ], {
            statusCode: err.statusCode
          });
          return err;
        }
        if (err.isMissing) {
          request._log([
            "auth",
            "unauthenticated",
            "missing",
            name
          ], err);
          errors.push(err.output.headers["WWW-Authenticate"]);
          return internals.missing;
        }
      }
      request.auth.strategy = name;
      request.auth.credentials = result.credentials;
      request.auth.artifacts = result.artifacts;
      if (!err) {
        return;
      }
      request.auth.error = err;
      if (config2.mode === "try") {
        request._log([
          "auth",
          "unauthenticated",
          "try",
          name
        ], err);
        return;
      }
      request._log([
        "auth",
        "unauthenticated",
        "error",
        name
      ], err);
      throw err;
    };
    internals.expandScope = function(request, scope) {
      if (!scope._hasParameters) {
        return scope;
      }
      const expanded = {
        required: internals.expandScopeType(request, scope, "required"),
        selection: internals.expandScopeType(request, scope, "selection"),
        forbidden: internals.expandScopeType(request, scope, "forbidden")
      };
      return expanded;
    };
    internals.expandScopeType = function(request, scope, type) {
      if (!scope._hasParameters[type]) {
        return scope[type];
      }
      const expanded = [];
      const context = {
        params: request.params,
        query: request.query,
        payload: request.payload,
        credentials: request.auth.credentials
      };
      for (const template of scope[type]) {
        expanded.push(Hoek.reachTemplate(context, template));
      }
      return expanded;
    };
    internals.validateScope = function(credentials, scope, type) {
      if (!scope[type]) {
        return true;
      }
      const count = typeof credentials.scope === "string" ? scope[type].indexOf(credentials.scope) !== -1 ? 1 : 0 : Hoek.intersect(scope[type], credentials.scope).length;
      if (type === "forbidden") {
        return count === 0;
      }
      if (type === "required") {
        return count === scope.required.length;
      }
      return !!count;
    };
  }
});

// node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/header.js
var require_header = __commonJS({
  "node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/header.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Boom = require_lib6();
    var internals = {};
    exports2.selection = function(header, preferences, options3) {
      const selections = exports2.selections(header, preferences, options3);
      return selections.length ? selections[0] : "";
    };
    exports2.selections = function(header, preferences, options3) {
      Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
      return internals.parse(header || "", preferences, options3);
    };
    internals.parse = function(raw, preferences, options3) {
      const header = raw.replace(/[ \t]/g, "");
      const lowers = /* @__PURE__ */ new Map();
      if (preferences) {
        let pos = 0;
        for (const preference of preferences) {
          const lower = preference.toLowerCase();
          lowers.set(lower, {
            orig: preference,
            pos: pos++
          });
          if (options3.prefixMatch) {
            const parts2 = lower.split("-");
            while (parts2.pop(), parts2.length > 0) {
              const joined = parts2.join("-");
              if (!lowers.has(joined)) {
                lowers.set(joined, {
                  orig: preference,
                  pos: pos++
                });
              }
            }
          }
        }
      }
      const parts = header.split(",");
      const selections = [];
      const map2 = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < parts.length; ++i2) {
        const part = parts[i2];
        if (!part) {
          continue;
        }
        const params = part.split(";");
        if (params.length > 2) {
          throw Boom.badRequest(`Invalid ${options3.type} header`);
        }
        let token = params[0].toLowerCase();
        if (!token) {
          throw Boom.badRequest(`Invalid ${options3.type} header`);
        }
        if (options3.equivalents?.has(token)) {
          token = options3.equivalents.get(token);
        }
        const selection = {
          token,
          pos: i2,
          q: 1
        };
        if (preferences && lowers.has(token)) {
          selection.pref = lowers.get(token).pos;
        }
        map2.add(selection.token);
        if (params.length === 2) {
          const q = params[1];
          const [key, value] = q.split("=");
          if (!value || key !== "q" && key !== "Q") {
            throw Boom.badRequest(`Invalid ${options3.type} header`);
          }
          const score = parseFloat(value);
          if (score === 0) {
            continue;
          }
          if (Number.isFinite(score) && score <= 1 && score >= 1e-3) {
            selection.q = score;
          }
        }
        selections.push(selection);
      }
      selections.sort(internals.sort);
      const values = selections.map((selection) => selection.token);
      if (options3.default && !map2.has(options3.default)) {
        values.push(options3.default);
      }
      if (!preferences?.length) {
        return values;
      }
      const preferred = [];
      for (const selection of values) {
        if (selection === "*") {
          for (const [preference, value] of lowers) {
            if (!map2.has(preference)) {
              preferred.push(value.orig);
            }
          }
        } else {
          const lower = selection.toLowerCase();
          if (lowers.has(lower)) {
            preferred.push(lowers.get(lower).orig);
          }
        }
      }
      return preferred;
    };
    internals.sort = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      if (b.q !== a.q) {
        return b.q - a.q;
      }
      if (b.pref !== a.pref) {
        if (a.pref === void 0) {
          return bFirst;
        }
        if (b.pref === void 0) {
          return aFirst;
        }
        return a.pref - b.pref;
      }
      return a.pos - b.pos;
    };
  }
});

// node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/media.js
var require_media = __commonJS({
  "node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/media.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Boom = require_lib6();
    var internals = {};
    exports2.selection = function(header, preferences) {
      const selections = exports2.selections(header, preferences);
      return selections.length ? selections[0] : "";
    };
    exports2.selections = function(header, preferences) {
      Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
      return internals.parse(header, preferences);
    };
    internals.validMediaRx = /^(?:\*\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/[\w\!#\$%&'\*\+\-\.\^`\|~]+)$/;
    internals.parse = function(raw, preferences) {
      const { header, quoted } = internals.normalize(raw);
      const parts = header.split(",");
      const selections = [];
      const map2 = {};
      for (let i2 = 0; i2 < parts.length; ++i2) {
        const part = parts[i2];
        if (!part) {
          continue;
        }
        const pairs = part.split(";");
        const token = pairs.shift().toLowerCase();
        if (!internals.validMediaRx.test(token)) {
          continue;
        }
        const selection = {
          token,
          params: {},
          exts: {},
          pos: i2
        };
        let target = "params";
        for (const pair of pairs) {
          const kv = pair.split("=");
          if (kv.length !== 2 || !kv[1]) {
            throw Boom.badRequest(`Invalid accept header`);
          }
          const key = kv[0];
          let value = kv[1];
          if (key === "q" || key === "Q") {
            target = "exts";
            value = parseFloat(value);
            if (!Number.isFinite(value) || value > 1 || value < 1e-3 && value !== 0) {
              value = 1;
            }
            selection.q = value;
          } else {
            if (value[0] === '"') {
              value = `"${quoted[value]}"`;
            }
            selection[target][kv[0]] = value;
          }
        }
        const params = Object.keys(selection.params);
        selection.original = [
          ""
        ].concat(params.map((key) => `${key}=${selection.params[key]}`)).join(";");
        selection.specificity = params.length;
        if (selection.q === void 0) {
          selection.q = 1;
        }
        const tparts = selection.token.split("/");
        selection.type = tparts[0];
        selection.subtype = tparts[1];
        map2[selection.token] = selection;
        if (selection.q) {
          selections.push(selection);
        }
      }
      selections.sort(internals.sort);
      return internals.preferences(map2, selections, preferences);
    };
    internals.normalize = function(raw) {
      raw = raw || "*/*";
      const normalized = {
        header: raw,
        quoted: {}
      };
      if (raw.includes('"')) {
        let i2 = 0;
        normalized.header = raw.replace(/="([^"]*)"/g, ($0, $1) => {
          const key = '"' + ++i2;
          normalized.quoted[key] = $1;
          return "=" + key;
        });
      }
      normalized.header = normalized.header.replace(/[ \t]/g, "");
      return normalized;
    };
    internals.sort = function(a, b) {
      if (b.q !== a.q) {
        return b.q - a.q;
      }
      if (a.type !== b.type) {
        return internals.innerSort(a, b, "type");
      }
      if (a.subtype !== b.subtype) {
        return internals.innerSort(a, b, "subtype");
      }
      if (a.specificity !== b.specificity) {
        return b.specificity - a.specificity;
      }
      return a.pos - b.pos;
    };
    internals.innerSort = function(a, b, key) {
      const aFirst = -1;
      const bFirst = 1;
      if (a[key] === "*") {
        return bFirst;
      }
      if (b[key] === "*") {
        return aFirst;
      }
      return a[key] < b[key] ? aFirst : bFirst;
    };
    internals.preferences = function(map2, selections, preferences) {
      if (!preferences?.length) {
        return selections.map((selection) => selection.token + selection.original);
      }
      const lowers = /* @__PURE__ */ Object.create(null);
      const flat = /* @__PURE__ */ Object.create(null);
      let any2 = false;
      for (const preference of preferences) {
        const lower = preference.toLowerCase();
        flat[lower] = preference;
        const parts = lower.split("/");
        const type = parts[0];
        const subtype = parts[1];
        if (type === "*") {
          Hoek.assert(subtype === "*", "Invalid media type preference contains wildcard type with a subtype");
          any2 = true;
          continue;
        }
        lowers[type] = lowers[type] ?? /* @__PURE__ */ Object.create(null);
        lowers[type][subtype] = preference;
      }
      const preferred = [];
      for (const selection of selections) {
        const token = selection.token;
        const { type, subtype } = map2[token];
        const subtypes = lowers[type];
        if (type === "*") {
          for (const preference of Object.keys(flat)) {
            if (!map2[preference]) {
              preferred.push(flat[preference]);
            }
          }
          if (any2) {
            preferred.push("*/*");
          }
          continue;
        }
        if (any2) {
          preferred.push((flat[token] || token) + selection.original);
          continue;
        }
        if (subtype !== "*") {
          const pref = flat[token];
          if (pref || subtypes && subtypes["*"]) {
            preferred.push((pref || token) + selection.original);
          }
          continue;
        }
        if (subtypes) {
          for (const psub of Object.keys(subtypes)) {
            if (!map2[`${type}/${psub}`]) {
              preferred.push(subtypes[psub]);
            }
          }
        }
      }
      return preferred;
    };
  }
});

// node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/index.js
var require_lib28 = __commonJS({
  "node_modules/.deno/@hapi+accept@6.0.3/node_modules/@hapi/accept/lib/index.js"(exports2) {
    "use strict";
    var Header = require_header();
    var Media = require_media();
    var internals = {
      options: {
        charset: {
          type: "accept-charset"
        },
        encoding: {
          type: "accept-encoding",
          default: "identity",
          equivalents: /* @__PURE__ */ new Map([
            [
              "x-compress",
              "compress"
            ],
            [
              "x-gzip",
              "gzip"
            ]
          ])
        },
        language: {
          type: "accept-language",
          prefixMatch: true
        }
      }
    };
    for (const type in internals.options) {
      exports2[type] = (header, preferences) => Header.selection(header, preferences, internals.options[type]);
      exports2[`${type}s`] = (header, preferences) => Header.selections(header, preferences, internals.options[type]);
    }
    exports2.mediaType = (header, preferences) => Media.selection(header, preferences);
    exports2.mediaTypes = (header, preferences) => Media.selections(header, preferences);
    exports2.parseAll = function(requestHeaders) {
      return {
        charsets: exports2.charsets(requestHeaders["accept-charset"]),
        encodings: exports2.encodings(requestHeaders["accept-encoding"]),
        languages: exports2.languages(requestHeaders["accept-language"]),
        mediaTypes: exports2.mediaTypes(requestHeaders.accept)
      };
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/compression.js
var require_compression = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/compression.js"(exports2, module2) {
    "use strict";
    var Zlib = __require("node:zlib");
    var Accept = require_lib28();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {
      common: [
        "gzip, deflate",
        "deflate, gzip",
        "gzip",
        "deflate",
        "gzip, deflate, br"
      ]
    };
    exports2 = module2.exports = internals.Compression = class {
      decoders = {
        gzip: (options3) => Zlib.createGunzip(options3),
        deflate: (options3) => Zlib.createInflate(options3)
      };
      encodings = [
        "identity",
        "gzip",
        "deflate"
      ];
      encoders = {
        identity: null,
        gzip: (options3) => Zlib.createGzip(options3),
        deflate: (options3) => Zlib.createDeflate(options3)
      };
      #common = null;
      constructor() {
        this._updateCommons();
      }
      _updateCommons() {
        this.#common = /* @__PURE__ */ new Map();
        for (const header of internals.common) {
          this.#common.set(header, Accept.encoding(header, this.encodings));
        }
      }
      addEncoder(encoding, encoder3) {
        Hoek.assert(this.encoders[encoding] === void 0, `Cannot override existing encoder for ${encoding}`);
        Hoek.assert(typeof encoder3 === "function", `Invalid encoder function for ${encoding}`);
        this.encoders[encoding] = encoder3;
        this.encodings.unshift(encoding);
        this._updateCommons();
      }
      addDecoder(encoding, decoder) {
        Hoek.assert(this.decoders[encoding] === void 0, `Cannot override existing decoder for ${encoding}`);
        Hoek.assert(typeof decoder === "function", `Invalid decoder function for ${encoding}`);
        this.decoders[encoding] = decoder;
      }
      accept(request) {
        const header = request.headers["accept-encoding"];
        if (!header) {
          return "identity";
        }
        const common3 = this.#common.get(header);
        if (common3) {
          return common3;
        }
        try {
          return Accept.encoding(header, this.encodings);
        } catch (err) {
          Bounce.rethrow(err, "system");
          err.header = header;
          request._log([
            "accept-encoding",
            "error"
          ], err);
          return "identity";
        }
      }
      encoding(response, length4) {
        if (response.settings.compressed) {
          response.headers["content-encoding"] = response.settings.compressed;
          return null;
        }
        const request = response.request;
        if (!request._core.settings.compression || length4 !== null && length4 < request._core.settings.compression.minBytes) {
          return null;
        }
        const mime = request._core.mime.type(response.headers["content-type"] || "application/octet-stream");
        if (!mime.compressible) {
          return null;
        }
        response.vary("accept-encoding");
        if (response.headers["content-encoding"]) {
          return null;
        }
        return request.info.acceptEncoding === "identity" ? null : request.info.acceptEncoding;
      }
      encoder(request, encoding) {
        const encoder3 = this.encoders[encoding];
        Hoek.assert(encoder3 !== void 0, `Unknown encoding ${encoding}`);
        return encoder3(request.route.settings.compression[encoding]);
      }
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/methods.js
var require_methods = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/methods.js"(exports2, module2) {
    "use strict";
    var Boom = require_lib6();
    var Hoek = require_lib();
    var Config = require_config();
    var internals = {
      methodNameRx: /^[_$a-zA-Z][$\w]*(?:\.[_$a-zA-Z][$\w]*)*$/
    };
    exports2 = module2.exports = internals.Methods = class {
      methods = {};
      #core = null;
      constructor(core) {
        this.#core = core;
      }
      add(name, method, options3, realm) {
        if (typeof name !== "object") {
          return this._add(name, method, options3, realm);
        }
        const items = [].concat(name);
        for (let item of items) {
          item = Config.apply("methodObject", item);
          this._add(item.name, item.method, item.options ?? {}, realm);
        }
      }
      _add(name, method, options3, realm) {
        Hoek.assert(typeof method === "function", "method must be a function");
        Hoek.assert(typeof name === "string", "name must be a string");
        Hoek.assert(name.match(internals.methodNameRx), "Invalid name:", name);
        Hoek.assert(!Hoek.reach(this.methods, name, {
          functions: false
        }), "Server method function name already exists:", name);
        options3 = Config.apply("method", options3, name);
        const settings = Hoek.clone(options3, {
          shallow: [
            "bind"
          ]
        });
        settings.generateKey = settings.generateKey ?? internals.generateKey;
        const bind = settings.bind ?? realm.settings.bind ?? null;
        const bound = !bind ? method : (...args) => method.apply(bind, args);
        if (!settings.cache) {
          return this._assign(name, bound);
        }
        Hoek.assert(!settings.cache.generateFunc, "Cannot set generateFunc with method caching:", name);
        Hoek.assert(settings.cache.generateTimeout !== void 0, "Method caching requires a timeout value in generateTimeout:", name);
        settings.cache.generateFunc = (id, flags) => bound(...id.args, flags);
        const cache3 = this.#core._cachePolicy(settings.cache, "#" + name);
        const func = function(...args) {
          const key = settings.generateKey.apply(bind, args);
          if (typeof key !== "string") {
            return Promise.reject(Boom.badImplementation("Invalid method key when invoking: " + name, {
              name,
              args
            }));
          }
          return cache3.get({
            id: key,
            args
          });
        };
        func.cache = {
          drop: function(...args) {
            const key = settings.generateKey.apply(bind, args);
            if (typeof key !== "string") {
              return Promise.reject(Boom.badImplementation("Invalid method key when invoking: " + name, {
                name,
                args
              }));
            }
            return cache3.drop(key);
          },
          stats: cache3.stats
        };
        this._assign(name, func, func);
      }
      _assign(name, method) {
        const path = name.split(".");
        let ref = this.methods;
        for (let i2 = 0; i2 < path.length; ++i2) {
          if (!ref[path[i2]]) {
            ref[path[i2]] = i2 + 1 === path.length ? method : {};
          }
          ref = ref[path[i2]];
        }
      }
    };
    internals.supportedArgs = [
      "string",
      "number",
      "boolean"
    ];
    internals.generateKey = function(...args) {
      let key = "";
      for (let i2 = 0; i2 < args.length; ++i2) {
        const arg = args[i2];
        if (!internals.supportedArgs.includes(typeof arg)) {
          return null;
        }
        key = key + (i2 ? ":" : "") + encodeURIComponent(arg.toString());
      }
      return key;
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/response.js
var require_response2 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/response.js"(exports2, module2) {
    "use strict";
    var Stream = __require("node:stream");
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Streams = require_streams();
    var internals = {
      events: Podium.validate([
        "finish",
        {
          name: "peek",
          spread: true
        }
      ]),
      hopByHop: {
        connection: true,
        "keep-alive": true,
        "proxy-authenticate": true,
        "proxy-authorization": true,
        "te": true,
        "trailer": true,
        "transfer-encoding": true,
        "upgrade": true
      },
      reserved: [
        "app",
        "headers",
        "plugins",
        "request",
        "source",
        "statusCode",
        "variety",
        "settings",
        "events",
        "code",
        "message",
        "header",
        "vary",
        "etag",
        "type",
        "contentType",
        "bytes",
        "location",
        "created",
        "compressed",
        "replacer",
        "space",
        "suffix",
        "escape",
        "passThrough",
        "redirect",
        "temporary",
        "permanent",
        "rewritable",
        "encoding",
        "charset",
        "ttl",
        "state",
        "unstate",
        "takeover"
      ]
    };
    exports2 = module2.exports = internals.Response = class {
      constructor(source, request, options3 = {}) {
        this.app = {};
        this.headers = {};
        this.plugins = {};
        this.request = request;
        this.source = null;
        this.statusCode = null;
        this.variety = null;
        this.settings = {
          charset: "utf-8",
          compressed: null,
          encoding: "utf8",
          message: null,
          passThrough: true,
          stringify: null,
          ttl: null,
          varyEtag: false
        };
        this._events = null;
        this._payload = null;
        this._error = options3.error ?? null;
        this._contentType = null;
        this._takeover = false;
        this._statusCode = false;
        this._state = this._error ? "prepare" : "init";
        this._processors = {
          marshal: options3.marshal,
          prepare: options3.prepare,
          close: options3.close
        };
        this._setSource(source, options3.variety);
      }
      static wrap(result, request) {
        if (result instanceof request._core.Response || typeof result === "symbol") {
          return result;
        }
        if (result instanceof Error) {
          return Boom.boomify(result);
        }
        return new request._core.Response(result, request);
      }
      _setSource(source, variety) {
        this.variety = variety ?? "plain";
        if (source === null || source === void 0) {
          source = null;
        } else if (Buffer.isBuffer(source)) {
          this.variety = "buffer";
          this._contentType = "application/octet-stream";
        } else if (Streams.isStream(source)) {
          this.variety = "stream";
          this._contentType = "application/octet-stream";
        }
        this.source = source;
        if (this.variety === "plain" && this.source !== null) {
          this._contentType = typeof this.source === "string" ? "text/html" : "application/json";
        }
      }
      get events() {
        if (!this._events) {
          this._events = new Podium.Podium(internals.events);
        }
        return this._events;
      }
      code(statusCode) {
        Hoek.assert(Number.isSafeInteger(statusCode), "Status code must be an integer");
        this.statusCode = statusCode;
        this._statusCode = true;
        return this;
      }
      message(httpMessage) {
        this.settings.message = httpMessage;
        return this;
      }
      header(key, value, options3) {
        key = key.toLowerCase();
        if (key === "vary") {
          return this.vary(value);
        }
        return this._header(key, value, options3);
      }
      _header(key, value, options3 = {}) {
        const append = options3.append ?? false;
        const separator = options3.separator || ",";
        const override = options3.override !== false;
        const duplicate = options3.duplicate !== false;
        if (!append && override || !this.headers[key]) {
          this.headers[key] = value;
        } else if (override) {
          if (key === "set-cookie") {
            this.headers[key] = [].concat(this.headers[key], value);
          } else {
            const existing = this.headers[key];
            if (!duplicate) {
              const values = existing.split(separator);
              for (const v2 of values) {
                if (v2 === value) {
                  return this;
                }
              }
            }
            this.headers[key] = existing + separator + value;
          }
        }
        return this;
      }
      vary(value) {
        if (value === "*") {
          this.headers.vary = "*";
        } else if (!this.headers.vary) {
          this.headers.vary = value;
        } else if (this.headers.vary !== "*") {
          this._header("vary", value, {
            append: true,
            duplicate: false
          });
        }
        return this;
      }
      etag(tag2, options3) {
        const entity = this.request._core.Response.entity(tag2, options3);
        this._header("etag", entity.etag);
        this.settings.varyEtag = entity.vary;
        return this;
      }
      static entity(tag2, options3 = {}) {
        Hoek.assert(tag2 !== "*", "ETag cannot be *");
        return {
          etag: (options3.weak ? "W/" : "") + '"' + tag2 + '"',
          vary: options3.vary !== false && !options3.weak,
          modified: options3.modified
        };
      }
      static unmodified(request, entity) {
        if (request.method !== "get" && request.method !== "head") {
          return false;
        }
        if (entity.etag && request.headers["if-none-match"]) {
          const ifNoneMatch = request.headers["if-none-match"].split(/\s*,\s*/);
          for (const etag of ifNoneMatch) {
            if (etag === entity.etag) {
              return true;
            }
            if (!entity.vary) {
              continue;
            }
            if (etag === `W/${entity.etag}`) {
              return etag;
            }
            const etagBase = entity.etag.slice(0, -1);
            const encoders = request._core.compression.encodings;
            for (const encoder3 of encoders) {
              if (etag === etagBase + `-${encoder3}"`) {
                return true;
              }
            }
          }
          return false;
        }
        if (!entity.modified) {
          return false;
        }
        const ifModifiedSinceHeader = request.headers["if-modified-since"];
        if (!ifModifiedSinceHeader) {
          return false;
        }
        const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
        if (!ifModifiedSince) {
          return false;
        }
        const lastModified = internals.parseDate(entity.modified);
        if (!lastModified) {
          return false;
        }
        return ifModifiedSince >= lastModified;
      }
      type(type) {
        this._header("content-type", type);
        return this;
      }
      get contentType() {
        let type = this.headers["content-type"];
        if (type) {
          type = type.trim();
          if (this.settings.charset && type.match(/^(?:text\/)|(?:application\/(?:json)|(?:javascript))/) && !type.match(/; *charset=/)) {
            const semi = type[type.length - 1] === ";";
            return type + (semi ? " " : "; ") + "charset=" + this.settings.charset;
          }
          return type;
        }
        if (this._contentType) {
          const charset = this.settings.charset && this._contentType !== "application/octet-stream" ? "; charset=" + this.settings.charset : "";
          return this._contentType + charset;
        }
        return null;
      }
      bytes(bytes) {
        this._header("content-length", bytes);
        return this;
      }
      location(uri) {
        this._header("location", uri);
        return this;
      }
      created(location) {
        Hoek.assert(this.request.method === "post" || this.request.method === "put" || this.request.method === "patch", "Cannot return 201 status codes for " + this.request.method.toUpperCase());
        this.statusCode = 201;
        this.location(location);
        return this;
      }
      compressed(encoding) {
        Hoek.assert(encoding && typeof encoding === "string", "Invalid content-encoding");
        this.settings.compressed = encoding;
        return this;
      }
      replacer(method) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.replacer = method;
        return this;
      }
      spaces(count) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.space = count;
        return this;
      }
      suffix(suffix) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.suffix = suffix;
        return this;
      }
      escape(escape) {
        this.settings.stringify = this.settings.stringify ?? {};
        this.settings.stringify.escape = escape;
        return this;
      }
      passThrough(enabled3) {
        this.settings.passThrough = enabled3 !== false;
        return this;
      }
      redirect(location) {
        this.statusCode = 302;
        this.location(location);
        return this;
      }
      temporary(isTemporary) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setTemporary(isTemporary !== false);
        return this;
      }
      permanent(isPermanent) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setTemporary(isPermanent === false);
        return this;
      }
      rewritable(isRewritable) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setRewritable(isRewritable !== false);
        return this;
      }
      _isTemporary() {
        return this.statusCode === 302 || this.statusCode === 307;
      }
      _isRewritable() {
        return this.statusCode === 301 || this.statusCode === 302;
      }
      _setTemporary(isTemporary) {
        if (isTemporary) {
          if (this._isRewritable()) {
            this.statusCode = 302;
          } else {
            this.statusCode = 307;
          }
        } else {
          if (this._isRewritable()) {
            this.statusCode = 301;
          } else {
            this.statusCode = 308;
          }
        }
      }
      _setRewritable(isRewritable) {
        if (isRewritable) {
          if (this._isTemporary()) {
            this.statusCode = 302;
          } else {
            this.statusCode = 301;
          }
        } else {
          if (this._isTemporary()) {
            this.statusCode = 307;
          } else {
            this.statusCode = 308;
          }
        }
      }
      encoding(encoding) {
        this.settings.encoding = encoding;
        return this;
      }
      charset(charset) {
        this.settings.charset = charset ?? null;
        return this;
      }
      ttl(ttl) {
        this.settings.ttl = ttl;
        return this;
      }
      state(name, value, options3) {
        this.request._setState(name, value, options3);
        return this;
      }
      unstate(name, options3) {
        this.request._clearState(name, options3);
        return this;
      }
      takeover() {
        this._takeover = true;
        return this;
      }
      _prepare() {
        Hoek.assert(this._state === "init");
        this._state = "prepare";
        this._passThrough();
        if (!this._processors.prepare) {
          return this;
        }
        try {
          return this._processors.prepare(this);
        } catch (err) {
          throw Boom.boomify(err);
        }
      }
      _passThrough() {
        if (this.variety === "stream" && this.settings.passThrough) {
          if (this.source.statusCode && !this.statusCode) {
            this.statusCode = this.source.statusCode;
          }
          if (this.source.headers) {
            let headerKeys = Object.keys(this.source.headers);
            if (headerKeys.length) {
              const localHeaders = this.headers;
              this.headers = {};
              const connection = this.source.headers.connection;
              const byHop = {};
              if (connection) {
                connection.split(/\s*,\s*/).forEach((header) => {
                  byHop[header] = true;
                });
              }
              for (const key of headerKeys) {
                const lower = key.toLowerCase();
                if (!internals.hopByHop[lower] && !byHop[lower]) {
                  this.header(lower, Hoek.clone(this.source.headers[key]));
                }
              }
              headerKeys = Object.keys(localHeaders);
              for (const key of headerKeys) {
                this.header(key, localHeaders[key], {
                  append: key === "set-cookie"
                });
              }
            }
          }
        }
        this.statusCode = this.statusCode ?? 200;
      }
      async _marshal() {
        Hoek.assert(this._state === "prepare");
        this._state = "marshall";
        let source = this.source;
        if (this._processors.marshal) {
          try {
            source = await this._processors.marshal(this);
          } catch (err) {
            throw Boom.boomify(err);
          }
        }
        if (Streams.isStream(source)) {
          this._payload = source;
          return;
        }
        const jsonify = this.variety === "plain" && source !== null && typeof source !== "string";
        if (!jsonify && this.settings.stringify) {
          throw Boom.badImplementation("Cannot set formatting options on non object response");
        }
        let payload = source;
        if (jsonify) {
          const options3 = this.settings.stringify ?? {};
          const space = options3.space ?? this.request.route.settings.json.space;
          const replacer = options3.replacer ?? this.request.route.settings.json.replacer;
          const suffix = options3.suffix ?? this.request.route.settings.json.suffix ?? "";
          const escape = this.request.route.settings.json.escape;
          try {
            if (replacer || space) {
              payload = JSON.stringify(payload, replacer, space);
            } else {
              payload = JSON.stringify(payload);
            }
          } catch (err) {
            throw Boom.boomify(err);
          }
          if (suffix) {
            payload = payload + suffix;
          }
          if (escape) {
            payload = Hoek.escapeJson(payload);
          }
        }
        this._payload = new internals.Response.Payload(payload, this.settings);
      }
      _tap() {
        if (!this._events) {
          return null;
        }
        if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
          return new internals.Response.Peek(this._events);
        }
        return null;
      }
      _close() {
        if (this._state === "close") {
          return;
        }
        this._state = "close";
        if (this._processors.close) {
          try {
            this._processors.close(this);
          } catch (err) {
            Bounce.rethrow(err, "system");
            this.request._log([
              "response",
              "cleanup",
              "error"
            ], err);
          }
        }
        const stream = this._payload || this.source;
        if (Streams.isStream(stream)) {
          internals.Response.drain(stream);
        }
      }
      _isPayloadSupported() {
        return this.request.method !== "head" && this.statusCode !== 304 && this.statusCode !== 204;
      }
      static drain(stream) {
        stream.destroy();
      }
    };
    internals.Response.reserved = internals.reserved;
    internals.parseDate = function(string4) {
      try {
        return Date.parse(string4);
      } catch (errIgnore) {
      }
    };
    internals.Response.Payload = class extends Stream.Readable {
      constructor(payload, options3) {
        super();
        this._data = payload;
        this._encoding = options3.encoding;
      }
      _read(size) {
        if (this._data) {
          this.push(this._data, this._encoding);
        }
        this.push(null);
      }
      size() {
        if (!this._data) {
          return 0;
        }
        return Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding);
      }
      writeToStream(stream) {
        if (this._data) {
          stream.write(this._data, this._encoding);
        }
        stream.end();
      }
    };
    internals.Response.Peek = class extends Stream.Transform {
      constructor(podium) {
        super();
        this._podium = podium;
        this.on("finish", () => podium.emit("finish"));
      }
      _transform(chunk, encoding, callback) {
        this._podium.emit("peek", [
          chunk,
          encoding
        ]);
        this.push(chunk, encoding);
        callback();
      }
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/core.js
var require_core = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/core.js"(exports2, module2) {
    "use strict";
    var Http = __require("node:http");
    var Https = __require("node:https");
    var Os = __require("node:os");
    var Path = __require("node:path");
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Call = require_lib9();
    var Catbox = require_lib11();
    var { Engine: CatboxMemory } = require_lib12();
    var { Heavy } = require_lib13();
    var Hoek = require_lib();
    var { Mimos } = require_lib14();
    var Podium = require_lib10();
    var Statehood = require_lib19();
    var Auth = require_auth();
    var Compression = require_compression();
    var Config = require_config();
    var Cors = require_cors();
    var Ext = require_ext();
    var Methods = require_methods();
    var Request2 = require_request2();
    var Response2 = require_response2();
    var Route = require_route();
    var Toolkit = require_toolkit();
    var Validation = require_validation();
    var internals = {
      counter: {
        min: 1e4,
        max: 99999
      },
      events: [
        {
          name: "cachePolicy",
          spread: true
        },
        {
          name: "log",
          channels: [
            "app",
            "internal"
          ],
          tags: true
        },
        {
          name: "request",
          channels: [
            "app",
            "internal",
            "error"
          ],
          tags: true,
          spread: true
        },
        "response",
        "route",
        "start",
        "closing",
        "stop"
      ],
      badRequestResponse: Buffer.from("HTTP/1.1 400 Bad Request\r\n\r\n", "ascii")
    };
    exports2 = module2.exports = internals.Core = class {
      actives = /* @__PURE__ */ new WeakMap();
      app = {};
      auth = new Auth(this);
      caches = /* @__PURE__ */ new Map();
      compression = new Compression();
      controlled = null;
      dependencies = [];
      events = new Podium.Podium(internals.events);
      heavy = null;
      info = null;
      instances = /* @__PURE__ */ new Set();
      listener = null;
      methods = new Methods(this);
      mime = null;
      onConnection = null;
      phase = "stopped";
      plugins = {};
      registrations = {};
      registring = 0;
      Request = class extends Request2 {
      };
      Response = class extends Response2 {
      };
      requestCounter = {
        value: internals.counter.min,
        min: internals.counter.min,
        max: internals.counter.max
      };
      root = null;
      router = null;
      settings = null;
      sockets = null;
      started = false;
      states = null;
      toolkit = new Toolkit.Manager();
      type = null;
      validator = null;
      extensionsSeq = 0;
      extensions = {
        server: {
          onPreStart: new Ext("onPreStart", this),
          onPostStart: new Ext("onPostStart", this),
          onPreStop: new Ext("onPreStop", this),
          onPostStop: new Ext("onPostStop", this)
        },
        route: {
          onRequest: new Ext("onRequest", this),
          onPreAuth: new Ext("onPreAuth", this),
          onCredentials: new Ext("onCredentials", this),
          onPostAuth: new Ext("onPostAuth", this),
          onPreHandler: new Ext("onPreHandler", this),
          onPostHandler: new Ext("onPostHandler", this),
          onPreResponse: new Ext("onPreResponse", this),
          onPostResponse: new Ext("onPostResponse", this)
        }
      };
      decorations = {
        handler: /* @__PURE__ */ new Map(),
        request: /* @__PURE__ */ new Map(),
        response: /* @__PURE__ */ new Map(),
        server: /* @__PURE__ */ new Map(),
        toolkit: /* @__PURE__ */ new Map(),
        requestApply: null,
        public: {
          handler: [],
          request: [],
          response: [],
          server: [],
          toolkit: []
        }
      };
      constructor(options3) {
        const { settings, type } = internals.setup(options3);
        this.settings = settings;
        this.type = type;
        this.heavy = new Heavy(this.settings.load);
        this.mime = new Mimos(this.settings.mime);
        this.router = new Call.Router(this.settings.router);
        this.states = new Statehood.Definitions(this.settings.state);
        this._debug();
        this._initializeCache();
        if (this.settings.routes.validate.validator) {
          this.validator = Validation.validator(this.settings.routes.validate.validator);
        }
        this.listener = this._createListener();
        this._initializeListener();
        this.info = this._info();
      }
      _debug() {
        const debug = this.settings.debug;
        if (!debug) {
          return;
        }
        const method = (event) => {
          const data = event.error ?? event.data;
          console.error("Debug:", event.tags.join(", "), data ? "\n    " + (data.stack ?? (typeof data === "object" ? Hoek.stringify(data) : data)) : "");
        };
        if (debug.log) {
          const filter = debug.log.some((tag2) => tag2 === "*") ? void 0 : debug.log;
          this.events.on({
            name: "log",
            filter
          }, method);
        }
        if (debug.request) {
          const filter = debug.request.some((tag2) => tag2 === "*") ? void 0 : debug.request;
          this.events.on({
            name: "request",
            filter
          }, (request, event) => method(event));
        }
      }
      _initializeCache() {
        if (this.settings.cache) {
          this._createCache(this.settings.cache);
        }
        if (!this.caches.has("_default")) {
          this._createCache([
            {
              provider: CatboxMemory
            }
          ]);
        }
      }
      _info() {
        const now = Date.now();
        const protocol = this.type === "tcp" ? this.settings.tls ? "https" : "http" : this.type;
        const host = this.settings.host || Os.hostname() || "localhost";
        const port = this.settings.port;
        const info = {
          created: now,
          started: 0,
          host,
          port,
          protocol,
          id: Os.hostname() + ":" + process.pid + ":" + now.toString(36),
          uri: this.settings.uri ?? protocol + ":" + (this.type === "tcp" ? "//" + host + (port ? ":" + port : "") : port)
        };
        return info;
      }
      _counter() {
        const next = ++this.requestCounter.value;
        if (this.requestCounter.value > this.requestCounter.max) {
          this.requestCounter.value = this.requestCounter.min;
        }
        return next - 1;
      }
      _createCache(configs) {
        Hoek.assert(this.phase !== "initializing", "Cannot provision server cache while server is initializing");
        configs = Config.apply("cache", configs);
        const added = [];
        for (let config2 of configs) {
          if (typeof config2 === "function") {
            config2 = {
              provider: {
                constructor: config2
              }
            };
          }
          const name = config2.name ?? "_default";
          Hoek.assert(!this.caches.has(name), "Cannot configure the same cache more than once: ", name === "_default" ? "default cache" : name);
          let client = null;
          if (config2.provider) {
            let provider = config2.provider;
            if (typeof provider === "function") {
              provider = {
                constructor: provider
              };
            }
            client = new Catbox.Client(provider.constructor, provider.options ?? {
              partition: "hapi-cache"
            });
          } else {
            client = new Catbox.Client(config2.engine);
          }
          this.caches.set(name, {
            client,
            segments: {},
            shared: config2.shared ?? false
          });
          added.push(client);
        }
        return added;
      }
      registerServer(server) {
        if (!this.root) {
          this.root = server;
          this._defaultRoutes();
        }
        this.instances.add(server);
      }
      async _start() {
        if (this.phase === "initialized" || this.phase === "started") {
          this._validateDeps();
        }
        if (this.phase === "started") {
          return;
        }
        if (this.phase !== "stopped" && this.phase !== "initialized") {
          throw new Error("Cannot start server while it is in " + this.phase + " phase");
        }
        if (this.phase !== "initialized") {
          await this._initialize();
        }
        this.phase = "starting";
        this.started = true;
        this.info.started = Date.now();
        try {
          await this._listen();
        } catch (err) {
          this.started = false;
          this.phase = "invalid";
          throw err;
        }
        this.phase = "started";
        this.events.emit("start");
        try {
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.start()));
          }
          await this._invoke("onPostStart");
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _listen() {
        return new Promise((resolve7, reject) => {
          if (!this.settings.autoListen) {
            resolve7();
            return;
          }
          const onError = (err) => {
            reject(err);
            return;
          };
          this.listener.once("error", onError);
          const finalize = () => {
            this.listener.removeListener("error", onError);
            resolve7();
            return;
          };
          if (this.type !== "tcp") {
            this.listener.listen(this.settings.port, finalize);
          } else {
            const address = this.settings.address || this.settings.host || null;
            this.listener.listen(this.settings.port, address, finalize);
          }
        });
      }
      async _initialize() {
        if (this.registring) {
          throw new Error("Cannot start server before plugins finished registration");
        }
        if (this.phase === "initialized") {
          return;
        }
        if (this.phase !== "stopped") {
          throw new Error("Cannot initialize server while it is in " + this.phase + " phase");
        }
        this._validateDeps();
        this.phase = "initializing";
        try {
          const caches = [];
          this.caches.forEach((cache3) => caches.push(cache3.client.start()));
          await Promise.all(caches);
          await this._invoke("onPreStart");
          this.heavy.start();
          this.phase = "initialized";
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.initialize()));
          }
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _validateDeps() {
        for (const { deps, plugin } of this.dependencies) {
          for (const dep in deps) {
            const version4 = deps[dep];
            Hoek.assert(this.registrations[dep], "Plugin", plugin, "missing dependency", dep);
            Hoek.assert(version4 === "*" || Config.versionMatch(this.registrations[dep].version, version4), "Plugin", plugin, "requires", dep, "version", version4, "but found", this.registrations[dep].version);
          }
        }
      }
      async _stop(options3 = {}) {
        options3.timeout = options3.timeout ?? 5e3;
        if ([
          "stopped",
          "initialized",
          "started",
          "invalid"
        ].indexOf(this.phase) === -1) {
          throw new Error("Cannot stop server while in " + this.phase + " phase");
        }
        this.phase = "stopping";
        try {
          await this._invoke("onPreStop");
          if (this.started) {
            this.started = false;
            this.info.started = 0;
            await this._unlisten(options3.timeout);
          }
          const caches = [];
          this.caches.forEach((cache3) => caches.push(cache3.client.stop()));
          await Promise.all(caches);
          this.events.emit("stop");
          this.heavy.stop();
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.stop(options3)));
          }
          await this._invoke("onPostStop");
          this.phase = "stopped";
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _unlisten(timeout) {
        let timeoutId = null;
        if (this.settings.operations.cleanStop) {
          const destroy = () => {
            for (const connection of this.sockets) {
              connection.destroy();
            }
            this.sockets.clear();
          };
          timeoutId = setTimeout(destroy, timeout);
          for (const connection of this.sockets) {
            if (!this.actives.has(connection)) {
              connection.end();
            }
          }
        }
        return new Promise((resolve7) => {
          this.listener.close(() => {
            if (this.settings.operations.cleanStop) {
              this.listener.removeListener(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
              clearTimeout(timeoutId);
            }
            this._initializeListener();
            resolve7();
          });
          this.events.emit("closing");
        });
      }
      async _invoke(type) {
        const exts = this.extensions.server[type];
        if (!exts.nodes) {
          return;
        }
        for (const ext of exts.nodes) {
          const bind = ext.bind ?? ext.realm.settings.bind;
          const operation = ext.func.call(bind, ext.server, bind);
          await Toolkit.timed(operation, {
            timeout: ext.timeout,
            name: type
          });
        }
      }
      _defaultRoutes() {
        this.router.special("notFound", new Route({
          method: "_special",
          path: "/{p*}",
          handler: internals.notFound
        }, this.root, {
          special: true
        }));
        this.router.special("badRequest", new Route({
          method: "_special",
          path: "/{p*}",
          handler: internals.badRequest
        }, this.root, {
          special: true
        }));
        if (this.settings.routes.cors) {
          Cors.handler(this.root);
        }
      }
      _dispatch(options3 = {}) {
        return (req, res) => {
          const request = Request2.generate(this.root, req, res, options3);
          if (this.settings.operations.cleanStop && req.socket) {
            this.actives.set(req.socket, request);
            const env = {
              core: this,
              req
            };
            res.on("finish", internals.onFinish.bind(res, env));
          }
          if (this.settings.load.sampleInterval) {
            try {
              this.heavy.check();
            } catch (err) {
              Bounce.rethrow(err, "system");
              this._log([
                "load"
              ], this.heavy.load);
              request._reply(err);
              return;
            }
          }
          request._execute();
        };
      }
      _createListener() {
        const listener = this.settings.listener ?? (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());
        listener.on("request", this._dispatch());
        listener.on("checkContinue", this._dispatch({
          expectContinue: true
        }));
        listener.on("clientError", (err, socket) => {
          this._log([
            "connection",
            "client",
            "error"
          ], err);
          if (socket.readable) {
            const request = this.settings.operations.cleanStop && this.actives.get(socket);
            if (request) {
              if (err.code === "HPE_INVALID_METHOD") {
                request.raw.res.once("close", () => {
                  if (socket.readable) {
                    socket.end(internals.badRequestResponse);
                  } else {
                    socket.destroy(err);
                  }
                });
                return;
              }
              const error40 = Boom.badRequest();
              error40.output.headers = {
                connection: "close"
              };
              request._reply(error40);
            } else {
              socket.end(internals.badRequestResponse);
            }
          } else {
            socket.destroy(err);
          }
        });
        return listener;
      }
      _initializeListener() {
        this.listener.once("listening", () => {
          if (this.type === "tcp") {
            const address = this.listener.address();
            this.info.address = address.address;
            this.info.port = address.port;
            this.info.uri = this.settings.uri ?? this.info.protocol + "://" + this.info.host + ":" + this.info.port;
          }
          if (this.settings.operations.cleanStop) {
            this.sockets = /* @__PURE__ */ new Set();
            const self2 = this;
            const onClose = function() {
              self2.sockets.delete(this);
            };
            this.onConnection = (connection) => {
              this.sockets.add(connection);
              connection.on("close", onClose);
            };
            this.listener.on(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
          }
        });
      }
      _cachePolicy(options3, _segment, realm) {
        options3 = Config.apply("cachePolicy", options3);
        const plugin = realm?.plugin;
        const segment = options3.segment ?? _segment ?? (plugin ? `!${plugin}` : "");
        Hoek.assert(segment, "Missing cache segment name");
        const cacheName = options3.cache ?? "_default";
        const cache3 = this.caches.get(cacheName);
        Hoek.assert(cache3, "Unknown cache", cacheName);
        Hoek.assert(!cache3.segments[segment] || cache3.shared || options3.shared, "Cannot provision the same cache segment more than once");
        cache3.segments[segment] = true;
        const policy = new Catbox.Policy(options3, cache3.client, segment);
        this.events.emit("cachePolicy", [
          policy,
          options3.cache,
          segment
        ]);
        return policy;
      }
      log(tags, data) {
        return this._log(tags, data, "app");
      }
      _log(tags, data, channel = "internal") {
        if (!this.events.hasListeners("log")) {
          return;
        }
        if (!Array.isArray(tags)) {
          tags = [
            tags
          ];
        }
        const timestamp = Date.now();
        const field = data instanceof Error ? "error" : "data";
        let event = {
          timestamp,
          tags,
          [field]: data,
          channel
        };
        if (typeof data === "function") {
          event = () => ({
            timestamp,
            tags,
            data: data(),
            channel
          });
        }
        this.events.emit({
          name: "log",
          tags,
          channel
        }, event);
      }
    };
    internals.setup = function(options3 = {}) {
      let settings = Hoek.clone(options3, {
        shallow: [
          "cache",
          "listener",
          "routes.bind"
        ]
      });
      settings.app = settings.app ?? {};
      settings.routes = Config.enable(settings.routes);
      settings = Config.apply("server", settings);
      if (settings.port === void 0) {
        settings.port = 0;
      }
      const type = typeof settings.port === "string" ? "socket" : "tcp";
      if (type === "socket") {
        settings.port = settings.port.indexOf("/") !== -1 ? Path.resolve(settings.port) : settings.port.toLowerCase();
      }
      if (settings.autoListen === void 0) {
        settings.autoListen = true;
      }
      Hoek.assert(settings.autoListen || !settings.port, "Cannot specify port when autoListen is false");
      Hoek.assert(settings.autoListen || !settings.address, "Cannot specify address when autoListen is false");
      return {
        settings,
        type
      };
    };
    internals.notFound = function() {
      throw Boom.notFound();
    };
    internals.badRequest = function() {
      throw Boom.badRequest();
    };
    internals.onFinish = function(env) {
      const { core, req } = env;
      core.actives.delete(req.socket);
      if (!core.started) {
        req.socket.end();
      }
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/package.json
var require_package2 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/package.json"(exports2, module2) {
    module2.exports = {
      name: "@hapi/hapi",
      description: "HTTP Server framework",
      homepage: "https://hapi.dev",
      version: "21.4.3",
      repository: "git://github.com/hapijs/hapi",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      engines: {
        node: ">=14.15.0"
      },
      files: [
        "lib"
      ],
      keywords: [
        "framework",
        "http",
        "api",
        "web"
      ],
      eslintConfig: {
        extends: [
          "plugin:@hapi/module"
        ]
      },
      dependencies: {
        "@hapi/accept": "^6.0.3",
        "@hapi/ammo": "^6.0.1",
        "@hapi/boom": "^10.0.1",
        "@hapi/bounce": "^3.0.2",
        "@hapi/call": "^9.0.1",
        "@hapi/catbox": "^12.1.1",
        "@hapi/catbox-memory": "^6.0.2",
        "@hapi/heavy": "^8.0.1",
        "@hapi/hoek": "^11.0.7",
        "@hapi/mimos": "^7.0.1",
        "@hapi/podium": "^5.0.2",
        "@hapi/shot": "^6.0.2",
        "@hapi/somever": "^4.1.1",
        "@hapi/statehood": "^8.2.0",
        "@hapi/subtext": "^8.1.1",
        "@hapi/teamwork": "^6.0.0",
        "@hapi/topo": "^6.0.2",
        "@hapi/validate": "^2.0.1"
      },
      devDependencies: {
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "^6.0.0",
        "@hapi/inert": "^7.1.0",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@^15.0.0",
        "@hapi/lab": "^25.3.2",
        "@hapi/vision": "^7.0.3",
        "@hapi/wreck": "^18.1.0",
        "@types/node": "^18.19.122",
        handlebars: "^4.7.8",
        joi: "^17.13.3",
        "legacy-readable-stream": "npm:readable-stream@^1.0.34",
        typescript: "^4.9.5"
      },
      scripts: {
        test: "lab -a @hapi/code -t 100 -L -m 5000 -Y",
        "test-tap": "lab -a @hapi/code -r tap -o tests.tap -m 5000",
        "test-cov-html": "lab -a @hapi/code -r html -o coverage.html -m 5000"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/server.js
var require_server = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/server.js"(exports2, module2) {
    "use strict";
    var Hoek = require_lib();
    var Shot = require_lib4();
    var Teamwork = require_lib5();
    var Config = require_config();
    var Core = require_core();
    var Cors = require_cors();
    var Ext = require_ext();
    var Package = require_package2();
    var Route = require_route();
    var Toolkit = require_toolkit();
    var Validation = require_validation();
    var internals = {};
    exports2 = module2.exports = function(options3) {
      const core = new Core(options3);
      return new internals.Server(core);
    };
    internals.Server = class {
      constructor(core, name, parent) {
        this._core = core;
        this.app = core.app;
        this.auth = core.auth.public(this);
        this.decorations = core.decorations.public;
        this.cache = internals.cache(this);
        this.events = core.events;
        this.info = core.info;
        this.listener = core.listener;
        this.load = core.heavy.load;
        this.methods = core.methods.methods;
        this.mime = core.mime;
        this.plugins = core.plugins;
        this.registrations = core.registrations;
        this.settings = core.settings;
        this.states = core.states;
        this.type = core.type;
        this.version = Package.version;
        this.realm = {
          _extensions: {
            onPreAuth: new Ext("onPreAuth", core),
            onCredentials: new Ext("onCredentials", core),
            onPostAuth: new Ext("onPostAuth", core),
            onPreHandler: new Ext("onPreHandler", core),
            onPostHandler: new Ext("onPostHandler", core),
            onPreResponse: new Ext("onPreResponse", core),
            onPostResponse: new Ext("onPostResponse", core)
          },
          modifiers: {
            route: {}
          },
          parent: parent ? parent.realm : null,
          plugin: name,
          pluginOptions: {},
          plugins: {},
          _rules: null,
          settings: {
            bind: void 0,
            files: {
              relativeTo: void 0
            }
          },
          validator: null
        };
        for (const [property, method] of core.decorations.server.entries()) {
          this[property] = method;
        }
        core.registerServer(this);
      }
      _clone(name) {
        return new internals.Server(this._core, name, this);
      }
      bind(context) {
        Hoek.assert(typeof context === "object", "bind must be an object");
        this.realm.settings.bind = context;
      }
      control(server) {
        Hoek.assert(server instanceof internals.Server, "Can only control Server objects");
        this._core.controlled = this._core.controlled ?? [];
        this._core.controlled.push(server);
      }
      decoder(encoding, decoder) {
        return this._core.compression.addDecoder(encoding, decoder);
      }
      decorate(type, property, method, options3 = {}) {
        Hoek.assert(this._core.decorations.public[type], "Unknown decoration type:", type);
        Hoek.assert(property, "Missing decoration property name");
        Hoek.assert(typeof property === "string" || typeof property === "symbol", "Decoration property must be a string or a symbol");
        const propertyName = property.toString();
        Hoek.assert(propertyName[0] !== "_", "Property name cannot begin with an underscore:", propertyName);
        const existing = this._core.decorations[type].get(property);
        if (options3.extend) {
          Hoek.assert(type !== "handler", "Cannot extend handler decoration:", propertyName);
          Hoek.assert(existing, `Cannot extend missing ${type} decoration: ${propertyName}`);
          Hoek.assert(typeof method === "function", `Extended ${type} decoration method must be a function: ${propertyName}`);
          method = method(existing);
        } else {
          Hoek.assert(existing === void 0, `${type[0].toUpperCase() + type.slice(1)} decoration already defined: ${propertyName}`);
        }
        if (type === "handler") {
          Hoek.assert(typeof method === "function", "Handler must be a function:", propertyName);
          Hoek.assert(!method.defaults || typeof method.defaults === "object" || typeof method.defaults === "function", "Handler defaults property must be an object or function");
          Hoek.assert(!options3.extend, "Cannot extend handler decoration:", propertyName);
        } else if (type === "request") {
          Hoek.assert(!this._core.Request.reserved.includes(property), "Cannot override the built-in request interface decoration:", propertyName);
          if (options3.apply) {
            this._core.decorations.requestApply = this._core.decorations.requestApply ?? /* @__PURE__ */ new Map();
            this._core.decorations.requestApply.set(property, method);
          } else {
            this._core.Request.prototype[property] = method;
          }
        } else if (type === "response") {
          Hoek.assert(!this._core.Response.reserved.includes(property), "Cannot override the built-in response interface decoration:", propertyName);
          this._core.Response.prototype[property] = method;
        } else if (type === "toolkit") {
          Hoek.assert(!Toolkit.reserved.includes(property), "Cannot override the built-in toolkit decoration:", propertyName);
          this._core.toolkit.decorate(property, method);
        } else {
          if (typeof property === "string") {
            Hoek.assert(!Object.getOwnPropertyNames(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
          } else {
            Hoek.assert(!Object.getOwnPropertySymbols(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
          }
          this._core.instances.forEach((server) => {
            server[property] = method;
          });
        }
        this._core.decorations[type].set(property, method);
        this._core.decorations.public[type].push(property);
      }
      dependency(dependencies, after) {
        Hoek.assert(this.realm.plugin, "Cannot call dependency() outside of a plugin");
        Hoek.assert(!after || typeof after === "function", "Invalid after method");
        if (typeof dependencies === "string") {
          dependencies = {
            [dependencies]: "*"
          };
        } else if (Array.isArray(dependencies)) {
          const map2 = {};
          for (const dependency of dependencies) {
            map2[dependency] = "*";
          }
          dependencies = map2;
        }
        this._core.dependencies.push({
          plugin: this.realm.plugin,
          deps: dependencies
        });
        if (after) {
          this.ext("onPreStart", after, {
            after: Object.keys(dependencies)
          });
        }
      }
      encoder(encoding, encoder3) {
        return this._core.compression.addEncoder(encoding, encoder3);
      }
      event(event) {
        this._core.events.registerEvent(event);
      }
      expose(key, value, options3 = {}) {
        Hoek.assert(this.realm.plugin, "Cannot call expose() outside of a plugin");
        let plugin = this.realm.plugin;
        if (plugin[0] === "@" && options3.scope !== true) {
          plugin = plugin.replace(/^@([^/]+)\//, ($0, $1) => {
            return !options3.scope ? "" : `${$1}__`;
          });
        }
        this._core.plugins[plugin] = this._core.plugins[plugin] ?? {};
        if (typeof key === "string") {
          this._core.plugins[plugin][key] = value;
        } else {
          Hoek.merge(this._core.plugins[plugin], key);
        }
      }
      ext(events, method, options3) {
        let promise2;
        if (typeof events === "string") {
          if (!method) {
            const team = new Teamwork.Team();
            method = (request, h2) => {
              team.attend(request);
              return h2.continue;
            };
            promise2 = team.work;
          }
          events = {
            type: events,
            method,
            options: options3
          };
        }
        events = Config.apply("exts", events);
        for (const event of events) {
          this._ext(event);
        }
        return promise2;
      }
      _ext(event) {
        event = Object.assign({}, event);
        event.realm = this.realm;
        const type = event.type;
        if (!this._core.extensions.server[type]) {
          if (event.options.sandbox === "plugin") {
            Hoek.assert(this.realm._extensions[type], "Unknown event type", type);
            return this.realm._extensions[type].add(event);
          }
          Hoek.assert(this._core.extensions.route[type], "Unknown event type", type);
          return this._core.extensions.route[type].add(event);
        }
        Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for server extension");
        Hoek.assert(type !== "onPreStart" || this._core.phase === "stopped", "Cannot add onPreStart (after) extension after the server was initialized");
        event.server = this;
        this._core.extensions.server[type].add(event);
      }
      async inject(options3) {
        let settings = options3;
        if (typeof settings === "string") {
          settings = {
            url: settings
          };
        }
        if (!settings.authority || settings.auth || settings.app || settings.plugins || settings.allowInternals !== void 0) {
          settings = Object.assign({}, settings);
          delete settings.auth;
          delete settings.app;
          delete settings.plugins;
          delete settings.allowInternals;
          settings.authority = settings.authority ?? this._core.info.host + ":" + this._core.info.port;
        }
        Hoek.assert(!options3.credentials, "options.credentials no longer supported (use options.auth)");
        if (options3.auth) {
          Hoek.assert(typeof options3.auth === "object", "options.auth must be an object");
          Hoek.assert(options3.auth.credentials, "options.auth.credentials is missing");
          Hoek.assert(options3.auth.strategy, "options.auth.strategy is missing");
        }
        const needle = this._core._dispatch({
          auth: options3.auth,
          allowInternals: options3.allowInternals,
          app: options3.app,
          plugins: options3.plugins,
          isInjected: true
        });
        const res = await Shot.inject(needle, settings);
        const custom2 = res.raw.res[Config.symbol];
        if (custom2) {
          delete res.raw.res[Config.symbol];
          res.request = custom2.request;
          if (custom2.error) {
            throw custom2.error;
          }
          if (custom2.result !== void 0) {
            res.result = custom2.result;
          }
        }
        if (res.result === void 0) {
          res.result = res.payload;
        }
        return res;
      }
      log(tags, data) {
        return this._core.log(tags, data);
      }
      lookup(id) {
        Hoek.assert(id && typeof id === "string", "Invalid route id:", id);
        const record2 = this._core.router.ids.get(id);
        if (!record2) {
          return null;
        }
        return record2.route.public;
      }
      match(method, path, host) {
        Hoek.assert(method && typeof method === "string", "Invalid method:", method);
        Hoek.assert(path && typeof path === "string" && path[0] === "/", "Invalid path:", path);
        Hoek.assert(!host || typeof host === "string", "Invalid host:", host);
        const match = this._core.router.route(method.toLowerCase(), path, host);
        Hoek.assert(match !== this._core.router.specials.badRequest, "Invalid path:", path);
        if (match === this._core.router.specials.notFound) {
          return null;
        }
        return match.route.public;
      }
      method(name, method, options3 = {}) {
        return this._core.methods.add(name, method, options3, this.realm);
      }
      path(relativeTo) {
        Hoek.assert(relativeTo && typeof relativeTo === "string", "relativeTo must be a non-empty string");
        this.realm.settings.files.relativeTo = relativeTo;
      }
      async register(plugins, options3 = {}) {
        if (this.realm.modifiers.route.prefix || this.realm.modifiers.route.vhost) {
          options3 = Hoek.clone(options3);
          options3.routes = options3.routes ?? {};
          options3.routes.prefix = (this.realm.modifiers.route.prefix ?? "") + (options3.routes.prefix ?? "") || void 0;
          options3.routes.vhost = this.realm.modifiers.route.vhost ?? options3.routes.vhost;
        }
        options3 = Config.apply("register", options3);
        ++this._core.registring;
        try {
          const items = [].concat(plugins);
          for (let item of items) {
            if (!item.plugin) {
              item = {
                plugin: item
              };
            } else if (!item.plugin.register) {
              item = {
                options: item.options,
                once: item.once,
                routes: item.routes,
                plugin: item.plugin.plugin
              };
            } else if (typeof item === "function") {
              item = Object.assign({}, item);
            }
            item = Config.apply("plugin", item);
            const name = item.plugin.name ?? item.plugin.pkg.name;
            const clone2 = this._clone(name);
            clone2.realm.modifiers.route.prefix = item.routes.prefix ?? options3.routes.prefix;
            clone2.realm.modifiers.route.vhost = item.routes.vhost ?? options3.routes.vhost;
            clone2.realm.pluginOptions = item.options ?? {};
            const requirements = item.plugin.requirements;
            Hoek.assert(!requirements.node || Config.versionMatch(process.version, requirements.node), "Plugin", name, "requires node version", requirements.node, "but found", process.version);
            Hoek.assert(!requirements.hapi || Config.versionMatch(this.version, requirements.hapi), "Plugin", name, "requires hapi version", requirements.hapi, "but found", this.version);
            if (this._core.registrations[name]) {
              if (item.plugin.once || item.once || options3.once) {
                continue;
              }
              Hoek.assert(item.plugin.multiple, "Plugin", name, "already registered");
            } else {
              this._core.registrations[name] = {
                version: item.plugin.version ?? item.plugin.pkg.version,
                name,
                options: item.options
              };
            }
            if (item.plugin.dependencies) {
              clone2.dependency(item.plugin.dependencies);
            }
            await item.plugin.register(clone2, item.options ?? {});
          }
        } finally {
          --this._core.registring;
        }
        return this;
      }
      route(options3) {
        Hoek.assert(typeof options3 === "object", "Invalid route options");
        options3 = [].concat(options3);
        for (const config2 of options3) {
          if (Array.isArray(config2.method)) {
            for (const method of config2.method) {
              const settings = Object.assign({}, config2);
              settings.method = method;
              this._addRoute(settings, this);
            }
          } else {
            this._addRoute(config2, this);
          }
        }
      }
      _addRoute(config2, server) {
        const route = new Route(config2, server);
        const vhosts = [].concat(route.settings.vhost ?? "*");
        for (const vhost of vhosts) {
          const record2 = this._core.router.add({
            method: route.method,
            path: route.path,
            vhost,
            analysis: route._analysis,
            id: route.settings.id
          }, route);
          route.fingerprint = record2.fingerprint;
          route.params = record2.params;
        }
        this.events.emit("route", route.public);
        Cors.options(route.public, server);
      }
      rules(processor, options3 = {}) {
        Hoek.assert(!this.realm._rules, "Server realm rules already defined");
        const settings = Config.apply("rules", options3);
        if (settings.validate) {
          const schema = settings.validate.schema;
          settings.validate.schema = Validation.compile(schema, null, this.realm, this._core);
        }
        this.realm._rules = {
          processor,
          settings
        };
      }
      state(name, options3) {
        this.states.add(name, options3);
      }
      table(host) {
        return this._core.router.table(host);
      }
      validator(validator) {
        Hoek.assert(!this.realm.validator, "Validator already set");
        this.realm.validator = Validation.validator(validator);
      }
      start() {
        return this._core._start();
      }
      initialize() {
        return this._core._initialize();
      }
      stop(options3) {
        return this._core._stop(options3);
      }
    };
    internals.cache = (plugin) => {
      const policy = function(options3, _segment) {
        return this._core._cachePolicy(options3, _segment, plugin.realm);
      };
      policy.provision = async (opts) => {
        const clients = plugin._core._createCache(opts);
        if ([
          "initialized",
          "starting",
          "started"
        ].includes(plugin._core.phase)) {
          await Promise.all(clients.map((client) => client.start()));
        }
      };
      return policy;
    };
  }
});

// node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/index.js
var require_lib29 = __commonJS({
  "node_modules/.deno/@hapi+hapi@21.4.3/node_modules/@hapi/hapi/lib/index.js"(exports2) {
    "use strict";
    var Server = require_server();
    exports2.Server = Server;
    exports2.server = Server;
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/package.json
var require_package3 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/package.json"(exports2, module2) {
    module2.exports = {
      name: "joi",
      description: "Object schema validation",
      version: "18.0.1",
      repository: {
        url: "git://github.com/hapijs/joi",
        type: "git"
      },
      engines: {
        node: ">= 20"
      },
      main: "lib/index.js",
      types: "lib/index.d.ts",
      browser: "dist/joi-browser.min.js",
      files: [
        "lib/**/*",
        "dist/*"
      ],
      keywords: [
        "schema",
        "validation"
      ],
      dependencies: {
        "@hapi/address": "^5.1.1",
        "@hapi/formula": "^3.0.2",
        "@hapi/hoek": "^11.0.7",
        "@hapi/pinpoint": "^2.0.1",
        "@hapi/tlds": "^1.1.1",
        "@hapi/topo": "^6.0.2",
        "@standard-schema/spec": "^1.0.0"
      },
      devDependencies: {
        "@hapi/bourne": "^3.0.0",
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "^7.0.0",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x",
        "@hapi/lab": "^26.0.0",
        "@types/node": "^20.17.47",
        typescript: "^5.8.3"
      },
      scripts: {
        prepublishOnly: "cd browser && npm install && npm run build",
        test: "lab -t 100 -a @hapi/code -L -Y",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/schemas.js
var require_schemas2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/schemas.js"(exports2) {
    "use strict";
    var Joi = require_lib32();
    var internals = {};
    internals.wrap = Joi.string().min(1).max(2).allow(false);
    exports2.preferences = Joi.object({
      allowUnknown: Joi.boolean(),
      abortEarly: Joi.boolean(),
      artifacts: Joi.boolean(),
      cache: Joi.boolean(),
      context: Joi.object(),
      convert: Joi.boolean(),
      dateFormat: Joi.valid("date", "iso", "string", "time", "utc"),
      debug: Joi.boolean(),
      errors: {
        escapeHtml: Joi.boolean(),
        label: Joi.valid("path", "key", false),
        language: [
          Joi.string(),
          Joi.object().ref()
        ],
        render: Joi.boolean(),
        stack: Joi.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap,
          string: internals.wrap
        }
      },
      externals: Joi.boolean(),
      messages: Joi.object(),
      noDefaults: Joi.boolean(),
      nonEnumerables: Joi.boolean(),
      presence: Joi.valid("required", "optional", "forbidden"),
      skipFunctions: Joi.boolean(),
      stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi.boolean()
    }).strict();
    internals.nameRx = /^[a-zA-Z0-9]\w*$/;
    internals.rule = Joi.object({
      alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
      args: Joi.array().items(Joi.string(), Joi.object({
        name: Joi.string().pattern(internals.nameRx).required(),
        ref: Joi.boolean(),
        assert: Joi.alternatives([
          Joi.function(),
          Joi.object().schema()
        ]).conditional("ref", {
          is: true,
          then: Joi.required()
        }),
        normalize: Joi.function(),
        message: Joi.string().when("assert", {
          is: Joi.function(),
          then: Joi.required()
        })
      })),
      convert: Joi.boolean(),
      manifest: Joi.boolean(),
      method: Joi.function().allow(false),
      multi: Joi.boolean(),
      validate: Joi.function()
    });
    exports2.extension = Joi.object({
      type: Joi.alternatives([
        Joi.string(),
        Joi.object().regex()
      ]).required(),
      args: Joi.function(),
      cast: Joi.object().pattern(internals.nameRx, Joi.object({
        from: Joi.function().maxArity(1).required(),
        to: Joi.function().minArity(1).maxArity(2).required()
      })),
      base: Joi.object().schema().when("type", {
        is: Joi.object().regex(),
        then: Joi.forbidden()
      }),
      coerce: [
        Joi.function().maxArity(3),
        Joi.object({
          method: Joi.function().maxArity(3).required(),
          from: Joi.array().items(Joi.string()).single()
        })
      ],
      flags: Joi.object().pattern(internals.nameRx, Joi.object({
        setter: Joi.string(),
        default: Joi.any()
      })),
      manifest: {
        build: Joi.function().arity(2)
      },
      messages: [
        Joi.object(),
        Joi.string()
      ],
      modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
      overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
      prepare: Joi.function().maxArity(3),
      rebuild: Joi.function().arity(1),
      rules: Joi.object().pattern(internals.nameRx, internals.rule),
      terms: Joi.object().pattern(internals.nameRx, Joi.object({
        init: Joi.array().allow(null).required(),
        manifest: Joi.object().pattern(/.+/, [
          Joi.valid("schema", "single"),
          Joi.object({
            mapped: Joi.object({
              from: Joi.string().required(),
              to: Joi.string().required()
            }).required()
          })
        ])
      })),
      validate: Joi.function().maxArity(3)
    }).strict();
    exports2.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();
    internals.desc = {
      buffer: Joi.object({
        buffer: Joi.string()
      }),
      func: Joi.object({
        function: Joi.function().required(),
        options: {
          literal: true
        }
      }),
      override: Joi.object({
        override: true
      }),
      ref: Joi.object({
        ref: Joi.object({
          type: Joi.valid("value", "global", "local"),
          path: Joi.array().required(),
          separator: Joi.string().length(1).allow(false),
          ancestor: Joi.number().min(0).integer().allow("root"),
          map: Joi.array().items(Joi.array().length(2)).min(1),
          adjust: Joi.function(),
          iterables: Joi.boolean(),
          in: Joi.boolean(),
          render: Joi.boolean()
        }).required()
      }),
      regex: Joi.object({
        regex: Joi.string().min(3)
      }),
      special: Joi.object({
        special: Joi.valid("deep").required()
      }),
      template: Joi.object({
        template: Joi.string().required(),
        options: Joi.object()
      }),
      value: Joi.object({
        value: Joi.alternatives([
          Joi.object(),
          Joi.array()
        ]).required()
      })
    };
    internals.desc.entity = Joi.alternatives([
      Joi.array().items(Joi.link("...")),
      Joi.boolean(),
      Joi.function(),
      Joi.number(),
      Joi.string(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.special,
      internals.desc.template,
      internals.desc.value,
      Joi.link("/")
    ]);
    internals.desc.values = Joi.array().items(null, Joi.boolean(), Joi.function(), Joi.number().allow(Infinity, -Infinity), Joi.string().allow(""), Joi.symbol(), internals.desc.buffer, internals.desc.func, internals.desc.override, internals.desc.ref, internals.desc.regex, internals.desc.template, internals.desc.value);
    internals.desc.messages = Joi.object().pattern(/.+/, [
      Joi.string(),
      internals.desc.template,
      Joi.object().pattern(/.+/, [
        Joi.string(),
        internals.desc.template
      ])
    ]);
    exports2.description = Joi.object({
      type: Joi.string().required(),
      flags: Joi.object({
        cast: Joi.string(),
        default: Joi.any(),
        description: Joi.string(),
        empty: Joi.link("/"),
        failover: internals.desc.entity,
        id: Joi.string(),
        label: Joi.string(),
        only: true,
        presence: [
          "optional",
          "required",
          "forbidden"
        ],
        result: [
          "raw",
          "strip"
        ],
        strip: Joi.boolean(),
        unit: Joi.string()
      }).unknown(),
      preferences: {
        allowUnknown: Joi.boolean(),
        abortEarly: Joi.boolean(),
        artifacts: Joi.boolean(),
        cache: Joi.boolean(),
        convert: Joi.boolean(),
        dateFormat: [
          "date",
          "iso",
          "string",
          "time",
          "utc"
        ],
        errors: {
          escapeHtml: Joi.boolean(),
          label: [
            "path",
            "key"
          ],
          language: [
            Joi.string(),
            internals.desc.ref
          ],
          wrap: {
            label: internals.wrap,
            array: internals.wrap
          }
        },
        externals: Joi.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi.boolean(),
        nonEnumerables: Joi.boolean(),
        presence: [
          "required",
          "optional",
          "forbidden"
        ],
        skipFunctions: Joi.boolean(),
        stripUnknown: Joi.object({
          arrays: Joi.boolean(),
          objects: Joi.boolean()
        }).or("arrays", "objects").allow(true, false),
        warnings: Joi.boolean()
      },
      allow: internals.desc.values,
      invalid: internals.desc.values,
      rules: Joi.array().min(1).items({
        name: Joi.string().required(),
        args: Joi.object().min(1),
        keep: Joi.boolean(),
        message: [
          Joi.string(),
          internals.desc.messages
        ],
        warn: Joi.boolean()
      }),
      // Terms
      keys: Joi.object().pattern(/.*/, Joi.link("/")),
      link: internals.desc.ref
    }).pattern(/^[a-z]\w*$/, Joi.any());
  }
});

// node_modules/.deno/@hapi+formula@3.0.2/node_modules/@hapi/formula/lib/index.js
var require_lib30 = __commonJS({
  "node_modules/.deno/@hapi+formula@3.0.2/node_modules/@hapi/formula/lib/index.js"(exports2) {
    "use strict";
    var internals = {
      operators: [
        "!",
        "^",
        "*",
        "/",
        "%",
        "+",
        "-",
        "<",
        "<=",
        ">",
        ">=",
        "==",
        "!=",
        "&&",
        "||",
        "??"
      ],
      operatorCharacters: [
        "!",
        "^",
        "*",
        "/",
        "%",
        "+",
        "-",
        "<",
        "=",
        ">",
        "&",
        "|",
        "?"
      ],
      operatorsOrder: [
        [
          "^"
        ],
        [
          "*",
          "/",
          "%"
        ],
        [
          "+",
          "-"
        ],
        [
          "<",
          "<=",
          ">",
          ">="
        ],
        [
          "==",
          "!="
        ],
        [
          "&&"
        ],
        [
          "||",
          "??"
        ]
      ],
      operatorsPrefix: [
        "!",
        "n"
      ],
      literals: {
        '"': '"',
        "`": "`",
        "'": "'",
        "[": "]"
      },
      numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
      tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
      symbol: Symbol("formula"),
      settings: Symbol("settings")
    };
    exports2.Parser = class {
      constructor(string4, options3 = {}) {
        if (!options3[internals.settings] && options3.constants) {
          for (const constant in options3.constants) {
            const value = options3.constants[constant];
            if (value !== null && ![
              "boolean",
              "number",
              "string"
            ].includes(typeof value)) {
              throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
            }
          }
        }
        this.settings = options3[internals.settings] ? options3 : Object.assign({
          [internals.settings]: true,
          constants: {},
          functions: {}
        }, options3);
        this.single = null;
        this._parts = null;
        this._parse(string4);
      }
      _parse(string4) {
        let parts = [];
        let current = "";
        let parenthesis = 0;
        let literal2 = false;
        const flush = (inner) => {
          if (parenthesis) {
            throw new Error("Formula missing closing parenthesis");
          }
          const last = parts.length ? parts[parts.length - 1] : null;
          if (!literal2 && !current && !inner) {
            return;
          }
          if (last && last.type === "reference" && inner === ")") {
            last.type = "function";
            last.value = this._subFormula(current, last.value);
            current = "";
            return;
          }
          if (inner === ")") {
            const sub = new exports2.Parser(current, this.settings);
            parts.push({
              type: "segment",
              value: sub
            });
          } else if (literal2) {
            if (literal2 === "]") {
              parts.push({
                type: "reference",
                value: current
              });
              current = "";
              return;
            }
            parts.push({
              type: "literal",
              value: current
            });
          } else if (internals.operatorCharacters.includes(current)) {
            if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
              last.value += current;
            } else {
              parts.push({
                type: "operator",
                value: current
              });
            }
          } else if (current.match(internals.numberRx)) {
            parts.push({
              type: "constant",
              value: parseFloat(current)
            });
          } else if (this.settings.constants[current] !== void 0) {
            parts.push({
              type: "constant",
              value: this.settings.constants[current]
            });
          } else {
            if (!current.match(internals.tokenRx)) {
              throw new Error(`Formula contains invalid token: ${current}`);
            }
            parts.push({
              type: "reference",
              value: current
            });
          }
          current = "";
        };
        for (const c of string4) {
          if (literal2) {
            if (c === literal2) {
              flush();
              literal2 = false;
            } else {
              current += c;
            }
          } else if (parenthesis) {
            if (c === "(") {
              current += c;
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
              if (!parenthesis) {
                flush(c);
              } else {
                current += c;
              }
            } else {
              current += c;
            }
          } else if (c in internals.literals) {
            literal2 = internals.literals[c];
          } else if (c === "(") {
            flush();
            ++parenthesis;
          } else if (internals.operatorCharacters.includes(c)) {
            flush();
            current = c;
            flush();
          } else if (c !== " ") {
            current += c;
          } else {
            flush();
          }
        }
        flush();
        parts = parts.map((part, i2) => {
          if (part.type !== "operator" || part.value !== "-" || i2 && parts[i2 - 1].type !== "operator") {
            return part;
          }
          return {
            type: "operator",
            value: "n"
          };
        });
        let operator = false;
        for (const part of parts) {
          if (part.type === "operator") {
            if (internals.operatorsPrefix.includes(part.value)) {
              continue;
            }
            if (!operator) {
              throw new Error("Formula contains an operator in invalid position");
            }
            if (!internals.operators.includes(part.value)) {
              throw new Error(`Formula contains an unknown operator ${part.value}`);
            }
          } else if (operator) {
            throw new Error("Formula missing expected operator");
          }
          operator = !operator;
        }
        if (!operator) {
          throw new Error("Formula contains invalid trailing operator");
        }
        if (parts.length === 1 && [
          "reference",
          "literal",
          "constant"
        ].includes(parts[0].type)) {
          this.single = {
            type: parts[0].type === "reference" ? "reference" : "value",
            value: parts[0].value
          };
        }
        this._parts = parts.map((part) => {
          if (part.type === "operator") {
            return internals.operatorsPrefix.includes(part.value) ? part : part.value;
          }
          if (part.type !== "reference") {
            return part.value;
          }
          if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
            throw new Error(`Formula contains invalid reference ${part.value}`);
          }
          if (this.settings.reference) {
            return this.settings.reference(part.value);
          }
          return internals.reference(part.value);
        });
      }
      _subFormula(string4, name) {
        const method = this.settings.functions[name];
        if (typeof method !== "function") {
          throw new Error(`Formula contains unknown function ${name}`);
        }
        let args = [];
        if (string4) {
          let current = "";
          let parenthesis = 0;
          let literal2 = false;
          const flush = () => {
            if (!current) {
              throw new Error(`Formula contains function ${name} with invalid arguments ${string4}`);
            }
            args.push(current);
            current = "";
          };
          for (let i2 = 0; i2 < string4.length; ++i2) {
            const c = string4[i2];
            if (literal2) {
              current += c;
              if (c === literal2) {
                literal2 = false;
              }
            } else if (c in internals.literals && !parenthesis) {
              current += c;
              literal2 = internals.literals[c];
            } else if (c === "," && !parenthesis) {
              flush();
            } else {
              current += c;
              if (c === "(") {
                ++parenthesis;
              } else if (c === ")") {
                --parenthesis;
              }
            }
          }
          flush();
        }
        args = args.map((arg) => new exports2.Parser(arg, this.settings));
        return function(context) {
          const innerValues = [];
          for (const arg of args) {
            innerValues.push(arg.evaluate(context));
          }
          return method.call(context, ...innerValues);
        };
      }
      evaluate(context) {
        const parts = this._parts.slice();
        for (let i2 = parts.length - 2; i2 >= 0; --i2) {
          const part = parts[i2];
          if (part && part.type === "operator") {
            const current = parts[i2 + 1];
            parts.splice(i2 + 1, 1);
            const value = internals.evaluate(current, context);
            parts[i2] = internals.single(part.value, value);
          }
        }
        internals.operatorsOrder.forEach((set2) => {
          for (let i2 = 1; i2 < parts.length - 1; ) {
            if (set2.includes(parts[i2])) {
              const operator = parts[i2];
              const left = internals.evaluate(parts[i2 - 1], context);
              const right = internals.evaluate(parts[i2 + 1], context);
              parts.splice(i2, 2);
              const result = internals.calculate(operator, left, right);
              parts[i2 - 1] = result === 0 ? 0 : result;
            } else {
              i2 += 2;
            }
          }
        });
        return internals.evaluate(parts[0], context);
      }
    };
    exports2.Parser.prototype[internals.symbol] = true;
    internals.reference = function(name) {
      return function(context) {
        return context && context[name] !== void 0 ? context[name] : null;
      };
    };
    internals.evaluate = function(part, context) {
      if (part === null) {
        return null;
      }
      if (typeof part === "function") {
        return part(context);
      }
      if (part[internals.symbol]) {
        return part.evaluate(context);
      }
      return part;
    };
    internals.single = function(operator, value) {
      if (operator === "!") {
        return value ? false : true;
      }
      const negative = -value;
      if (negative === 0) {
        return 0;
      }
      return negative;
    };
    internals.calculate = function(operator, left, right) {
      if (operator === "??") {
        return internals.exists(left) ? left : right;
      }
      if (typeof left === "string" || typeof right === "string") {
        if (operator === "+") {
          left = internals.exists(left) ? left : "";
          right = internals.exists(right) ? right : "";
          return left + right;
        }
      } else {
        switch (operator) {
          case "^":
            return Math.pow(left, right);
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "+":
            return left + right;
          case "-":
            return left - right;
        }
      }
      switch (operator) {
        case "<":
          return left < right;
        case "<=":
          return left <= right;
        case ">":
          return left > right;
        case ">=":
          return left >= right;
        case "==":
          return left === right;
        case "!=":
          return left !== right;
        case "&&":
          return left && right;
        case "||":
          return left || right;
      }
      return null;
    };
    internals.exists = function(value) {
      return value !== null && value !== void 0;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/annotate.js
var require_annotate2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/annotate.js"(exports2) {
    "use strict";
    var { clone: clone2 } = require_lib();
    var Common = require_common2();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports2.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = clone2(this._original);
      for (let i2 = this.details.length - 1; i2 >= 0; --i2) {
        const pos = i2 + 1;
        const error40 = this.details[i2];
        const path = error40.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || {
              errors: {},
              missing: {}
            };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error40.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i2 = 0; i2 < this.details.length; ++i2) {
        const pos = i2 + 1;
        message = `${message}
[${pos}] ${this.details[i2].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = (key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i2 = 0; i2 < value.length; ++i2) {
                if (annotations.errors[i2]) {
                  annotated.push(`_$idx$_${annotations.errors[i2].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i2]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/errors.js"(exports2) {
    "use strict";
    var Annotate = require_annotate2();
    var Common = require_common2();
    var Template = require_template2();
    exports2.Report = class {
      constructor(code3, value, local, flags, messages, state, prefs) {
        this.code = code3;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.template = null;
        this.local = local || {};
        this.local.label = exports2.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      _setTemplate(template) {
        this.template = template;
        if (!this.flags.label && this.path.length === 0) {
          const localized = this._template(this.template, "root");
          if (localized) {
            this.local.label = localized;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code3 = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code3}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, {
          errors: this.prefs.errors,
          messages: [
            this.prefs.messages,
            this.messages
          ]
        });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages, code3) {
        return exports2.template(this.value, messages, code3 || this.code, this.state, this.prefs);
      }
    };
    exports2.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports2.template = function(value, messages, code3, state, prefs) {
      if (!messages) {
        return;
      }
      if (Template.isTemplate(messages)) {
        return code3 !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang]) {
        if (messages[lang][code3] !== void 0) {
          return messages[lang][code3];
        }
        if (messages[lang]["*"] !== void 0) {
          return messages[lang]["*"];
        }
      }
      if (!messages[code3]) {
        return messages["*"];
      }
      return messages[code3];
    };
    exports2.label = function(flags, state, prefs, messages) {
      if (!prefs.errors.label) {
        return "";
      }
      if (flags.label) {
        return flags.label;
      }
      let path = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path = state.path.slice(-1);
      }
      const normalized = exports2.path(path);
      if (normalized) {
        return normalized;
      }
      return exports2.template(null, prefs.messages, "root", state, prefs) || messages && exports2.template(null, messages, "root", state, prefs) || "value";
    };
    exports2.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports2.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports2.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports2.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports2.details = function(errors, options3 = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options3.override !== false) {
            return {
              override: item
            };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: {
              error: item
            }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v2) => typeof v2 !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [
          ...new Set(messages)
        ];
      }
      return {
        message: messages.join(". "),
        details
      };
    };
    exports2.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports2.ValidationError;
      }
    };
    exports2.ValidationError.prototype.isJoi = true;
    exports2.ValidationError.prototype.name = "ValidationError";
    exports2.ValidationError.prototype.annotate = Annotate.error;
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/ref.js
var require_ref2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/ref.js"(exports2) {
    "use strict";
    var { assert: assert4, clone: clone2, reach } = require_lib();
    var Common = require_common2();
    var Template;
    var internals = {
      symbol: Symbol("ref"),
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports2.create = function(key, options3 = {}) {
      assert4(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options3, [
        "adjust",
        "ancestor",
        "in",
        "iterables",
        "map",
        "prefix",
        "render",
        "separator"
      ]);
      assert4(!options3.prefix || typeof options3.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options3);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options3.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          assert4(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            assert4(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [
        key
      ];
      return new internals.Ref(ref);
    };
    exports2.in = function(key, options3 = {}) {
      return exports2.create(key, {
        ...options3,
        in: true
      });
    };
    exports2.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options3) {
        assert4(typeof options3 === "object", "Invalid reference construction");
        Common.assertOptions(options3, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "render",
          "separator",
          "type",
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        assert4([
          false,
          void 0
        ].includes(options3.separator) || typeof options3.separator === "string" && options3.separator.length === 1, "Invalid separator");
        assert4(!options3.adjust || typeof options3.adjust === "function", "options.adjust must be a function");
        assert4(!options3.map || Array.isArray(options3.map), "options.map must be an array");
        assert4(!options3.map || !options3.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options3);
        assert4(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local, options3 = {}) {
        assert4(!this.in || options3.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options3);
        }
        if (this.type === "local") {
          return this._resolve(local, state, options3);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options3);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options3);
        }
        assert4(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options3);
      }
      _resolve(target, state, options3) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options3.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = reach(target, this.path, {
            iterables: this.iterables,
            functions: true
          });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        if (state.mainstay) {
          state.mainstay.tracer.resolve(state, this, resolved);
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [
          ...state.path.slice(0, -this.ancestor),
          ...this.path
        ];
      }
      clone() {
        return new internals.Ref(this);
      }
      describe() {
        const ref = {
          path: this.path
        };
        if (this.type !== "value") {
          ref.type = this.type;
        }
        if (this.separator !== ".") {
          ref.separator = this.separator;
        }
        if (this.type === "value" && this.ancestor !== 1) {
          ref.ancestor = this.ancestor;
        }
        if (this.map) {
          ref.map = [
            ...this.map
          ];
        }
        for (const key of [
          "adjust",
          "iterables",
          "render"
        ]) {
          if (this[key] !== null && this[key] !== void 0) {
            ref[key] = this[key];
          }
        }
        if (this.in !== false) {
          ref.in = true;
        }
        return {
          ref
        };
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    exports2.build = function(desc) {
      desc = Object.assign({}, internals.defaults, desc);
      if (desc.type === "value" && desc.ancestor === void 0) {
        desc.ancestor = 1;
      }
      return new internals.Ref(desc);
    };
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return {
            key: key.slice(globalp.length),
            type: "global"
          };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return {
            key: key.slice(local.length),
            type: "local"
          };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return {
            key: key.slice(root.length),
            type: "value",
            root: true
          };
        }
      }
      return {
        key,
        type: "value"
      };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [
          1,
          0
        ];
      }
      if (key[0] !== separator) {
        return [
          1,
          0
        ];
      }
      if (key[1] !== separator) {
        return [
          0,
          1
        ];
      }
      let i2 = 2;
      while (key[i2] === separator) {
        ++i2;
      }
      return [
        i2 - 1,
        i2
      ];
    };
    exports2.toSibling = 0;
    exports2.toParent = 1;
    exports2.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports2.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({
                ancestor: item.ancestor - target,
                root: item.root
              });
            }
          }
          return;
        }
        if (exports2.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({
            ancestor: source.ancestor - target,
            root: source.root
          });
        }
        Template = Template || require_template2();
        if (Template.isTemplate(source)) {
          this.register(source.refs(), target);
        }
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const copy4 = new exports2.Manager();
        copy4.refs = clone2(this.refs);
        return copy4;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/template.js
var require_template2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/template.js"(exports2, module2) {
    "use strict";
    var { assert: assert4, clone: clone2, escapeHtml } = require_lib();
    var Formula = require_lib30();
    var Common = require_common2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module2.exports = exports2 = internals.Template = class {
      constructor(source, options3) {
        assert4(typeof source === "string", "Template source must be a string");
        assert4(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        if (options3) {
          const { functions, ...opts } = options3;
          this._settings = Object.keys(opts).length ? clone2(opts) : void 0;
          this._functions = functions;
          if (this._functions) {
            assert4(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
            assert4(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
          }
        } else {
          this._settings = void 0;
          this._functions = void 0;
        }
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          if (end === -1 || // Ignore non-matching closing
          part[1] === "{") {
            processed.push(`{${internals.decode(part)}`);
            continue;
          }
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), {
            raw,
            wrapped
          });
          processed.push(dynamic);
          if (typeof dynamic !== "string") {
            refs = true;
          }
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        if (!refs) {
          this.rendered = processed.join("");
          return;
        }
        this._template = processed;
      }
      static date(date5, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date5);
      }
      describe(options3 = {}) {
        if (!this._settings && options3.compact) {
          return this.source;
        }
        const desc = {
          template: this.source
        };
        if (this._settings) {
          desc.options = this._settings;
        }
        if (this._functions) {
          desc.functions = this._functions;
        }
        return desc;
      }
      static build(desc) {
        return new internals.Template(desc.template, desc.options || desc.functions ? {
          ...desc.options,
          functions: desc.functions
        } : void 0);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      refs() {
        if (!this._template) {
          return;
        }
        const refs = [];
        for (const part of this._template) {
          if (typeof part !== "string") {
            refs.push(...part.refs);
          }
        }
        return refs;
      }
      resolve(value, state, prefs, local) {
        if (this._template && this._template.length === 1) {
          return this._part(
            this._template[0],
            /* context -> [*/
            value,
            state,
            prefs,
            local,
            {}
            /*] */
          );
        }
        return this.render(value, state, prefs, local);
      }
      _part(part, ...args) {
        if (part.ref) {
          return part.ref.resolve(...args);
        }
        return part.formula.evaluate(args);
      }
      render(value, state, prefs, local, options3 = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = this._part(
              part,
              /* context -> [*/
              value,
              state,
              prefs,
              local,
              options3
              /*] */
            );
            const string4 = internals.stringify(rendered, value, state, prefs, local, options3);
            if (string4 !== void 0) {
              const result = part.raw || (options3.errors && options3.errors.escapeHtml) === false ? string4 : escapeHtml(string4);
              parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
            }
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const refs = [];
        const reference = (variable) => {
          const ref = Ref.create(variable, this._settings);
          refs.push(ref);
          return (context) => {
            const resolved = ref.resolve(...context);
            return resolved !== void 0 ? resolved : null;
          };
        };
        try {
          const functions = this._functions ? {
            ...internals.functions,
            ...this._functions
          } : internals.functions;
          var formula = new Formula.Parser(content, {
            reference,
            functions,
            constants: internals.constants
          });
        } catch (err) {
          err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
          throw err;
        }
        if (formula.single) {
          if (formula.single.type === "reference") {
            const ref = refs[0];
            return {
              ref,
              raw,
              refs,
              wrapped: wrapped || ref.type === "local" && ref.key === "label"
            };
          }
          return internals.stringify(formula.single.value);
        }
        return {
          formula,
          raw,
          refs
        };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string4) {
      return string4.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string4) {
      return string4.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string4) {
      const parts = [];
      let current = "";
      for (let i2 = 0; i2 < string4.length; ++i2) {
        const char = string4[i2];
        if (char === "{") {
          let next = "";
          while (i2 + 1 < string4.length && string4[i2 + 1] === "{") {
            next += "{";
            ++i2;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, original, state, prefs, local, options3 = {}) {
      const type = typeof value;
      const wrap2 = prefs && prefs.errors && prefs.errors.wrap || {};
      let skipWrap = false;
      if (Ref.isRef(value) && value.render) {
        skipWrap = value.in;
        value = value.resolve(original, state, prefs, local, {
          in: value.in,
          ...options3
        });
      }
      if (value === null) {
        return "null";
      }
      if (type === "string") {
        return internals.wrap(value, options3.arrayItems && wrap2.string);
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      const values = [];
      for (const item of value) {
        values.push(internals.stringify(item, original, state, prefs, local, {
          arrayItems: true,
          ...options3
        }));
      }
      return internals.wrap(values.join(", "), !skipWrap && wrap2.array);
    };
    internals.constants = {
      true: true,
      false: false,
      null: null,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 60 * 60 * 1e3,
      day: 24 * 60 * 60 * 1e3
    };
    internals.functions = {
      if(condition, then, otherwise) {
        return condition ? then : otherwise;
      },
      length(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (!item || typeof item !== "object") {
          return null;
        }
        if (Array.isArray(item)) {
          return item.length;
        }
        return Object.keys(item).length;
      },
      msg(code3) {
        const [value, state, prefs, local, options3] = this;
        const messages = options3.messages;
        if (!messages) {
          return "";
        }
        const template = Errors.template(value, messages[0], code3, state, prefs) || Errors.template(value, messages[1], code3, state, prefs);
        if (!template) {
          return "";
        }
        return template.render(value, state, prefs, local, options3);
      },
      number(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          return parseFloat(value);
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        if (value instanceof Date) {
          return value.getTime();
        }
        return null;
      }
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/messages.js
var require_messages2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/messages.js"(exports2) {
    "use strict";
    var { assert: assert4, clone: clone2 } = require_lib();
    var Template = require_template2();
    exports2.compile = function(messages, target) {
      if (typeof messages === "string") {
        assert4(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        assert4(!target, "Cannot set single message template");
        return messages;
      }
      assert4(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? clone2(target) : {};
      for (let code3 in messages) {
        const message = messages[code3];
        if (code3 === "root" || Template.isTemplate(message)) {
          target[code3] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code3] = new Template(message);
          continue;
        }
        assert4(typeof message === "object" && !Array.isArray(message), "Invalid message for", code3);
        const language = code3;
        target[language] = target[language] || {};
        for (code3 in message) {
          const localized = message[code3];
          if (code3 === "root" || Template.isTemplate(localized)) {
            target[language][code3] = localized;
            continue;
          }
          assert4(typeof localized === "string", "Invalid message for", code3, "in", language);
          target[language][code3] = new Template(localized);
        }
      }
      return target;
    };
    exports2.decompile = function(messages) {
      const target = {};
      for (let code3 in messages) {
        const message = messages[code3];
        if (code3 === "root") {
          target.root = message;
          continue;
        }
        if (Template.isTemplate(message)) {
          target[code3] = message.describe({
            compact: true
          });
          continue;
        }
        const language = code3;
        target[language] = {};
        for (code3 in message) {
          const localized = message[code3];
          if (code3 === "root") {
            target[language].root = localized;
            continue;
          }
          target[language][code3] = localized.describe({
            compact: true
          });
        }
      }
      return target;
    };
    exports2.merge = function(base4, extended) {
      if (!base4) {
        return exports2.compile(extended);
      }
      if (!extended) {
        return base4;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = clone2(base4);
      for (let code3 in extended) {
        const message = extended[code3];
        if (code3 === "root" || Template.isTemplate(message)) {
          target[code3] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code3] = new Template(message);
          continue;
        }
        assert4(typeof message === "object" && !Array.isArray(message), "Invalid message for", code3);
        const language = code3;
        target[language] = target[language] || {};
        for (code3 in message) {
          const localized = message[code3];
          if (code3 === "root" || Template.isTemplate(localized)) {
            target[language][code3] = localized;
            continue;
          }
          assert4(typeof localized === "string", "Invalid message for", code3, "in", language);
          target[language][code3] = new Template(localized);
        }
      }
      return target;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/common.js
var require_common2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/common.js"(exports2) {
    "use strict";
    var { assert: Assert, AssertError } = require_lib();
    var Pkg = require_package3();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports2.version = Pkg.version;
    exports2.defaults = {
      abortEarly: true,
      allowUnknown: false,
      artifacts: false,
      cache: true,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      externals: true,
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false,
      warnings: false
    };
    exports2.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports2.assertOptions = function(options3, keys, name = "Options") {
      Assert(options3 && typeof options3 === "object" && !Array.isArray(options3), "Options must be of type object");
      const unknownKeys = Object.keys(options3).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports2.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas2();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([
          result.error.details[0].message
        ]);
      }
    };
    exports2.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports2.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports2.isIsoDate = function(date5) {
      return internals.isoDate.test(date5);
    };
    exports2.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports2.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports2.symbols.ref] || obj[exports2.symbols.template];
    };
    exports2.isSchema = function(schema, options3 = {}) {
      const any2 = schema && schema[exports2.symbols.any];
      if (!any2) {
        return false;
      }
      Assert(options3.legacy || any2.version === exports2.version, "Cannot mix different versions of joi schemas");
      return true;
    };
    exports2.isValues = function(obj) {
      return obj[exports2.symbols.values];
    };
    exports2.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports2.preferences = function(target, source) {
      Messages = Messages || require_messages2();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports2.symbols.prefs];
      return merged;
    };
    exports2.tryWithPath = function(fn, key, options3 = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options3.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports2.validateArg = function(value, label, { assert: assert4, message }) {
      if (exports2.isSchema(assert4)) {
        const result = assert4.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert4(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports2.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/cache.js
var require_cache = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/cache.js"(exports2) {
    "use strict";
    var { assert: assert4, clone: clone2 } = require_lib();
    var Common = require_common2();
    var internals = {
      max: 1e3,
      supported: /* @__PURE__ */ new Set([
        "undefined",
        "boolean",
        "number",
        "string"
      ])
    };
    exports2.provider = {
      provision(options3) {
        return new internals.Cache(options3);
      }
    };
    internals.Cache = class {
      constructor(options3 = {}) {
        Common.assertOptions(options3, [
          "max"
        ]);
        assert4(options3.max === void 0 || options3.max && options3.max > 0 && isFinite(options3.max), "Invalid max cache size");
        this._max = options3.max || internals.max;
        this._map = /* @__PURE__ */ new Map();
        this._list = new internals.List();
      }
      get length() {
        return this._map.size;
      }
      set(key, value) {
        if (key !== null && !internals.supported.has(typeof key)) {
          return;
        }
        let node = this._map.get(key);
        if (node) {
          node.value = value;
          this._list.first(node);
          return;
        }
        node = this._list.unshift({
          key,
          value
        });
        this._map.set(key, node);
        this._compact();
      }
      get(key) {
        const node = this._map.get(key);
        if (node) {
          this._list.first(node);
          return clone2(node.value);
        }
      }
      _compact() {
        if (this._map.size > this._max) {
          const node = this._list.pop();
          this._map.delete(node.key);
        }
      }
    };
    internals.List = class {
      constructor() {
        this.tail = null;
        this.head = null;
      }
      unshift(node) {
        node.next = null;
        node.prev = this.head;
        if (this.head) {
          this.head.next = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        return node;
      }
      first(node) {
        if (node === this.head) {
          return;
        }
        this._remove(node);
        this.unshift(node);
      }
      pop() {
        return this._remove(this.tail);
      }
      _remove(node) {
        const { next, prev } = node;
        next.prev = prev;
        if (prev) {
          prev.next = next;
        }
        if (node === this.tail) {
          this.tail = next;
        }
        node.prev = null;
        node.next = null;
        return node;
      }
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/compile.js"(exports2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Common = require_common2();
    var Ref = require_ref2();
    var internals = {};
    exports2.schema = function(Joi, config2, options3 = {}) {
      Common.assertOptions(options3, [
        "appendPath",
        "override"
      ]);
      try {
        return internals.schema(Joi, config2, options3);
      } catch (err) {
        if (options3.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi, config2, options3) {
      assert4(config2 !== void 0, "Invalid undefined schema");
      if (Array.isArray(config2)) {
        assert4(config2.length, "Invalid empty array schema");
        if (config2.length === 1) {
          config2 = config2[0];
        }
      }
      const valid = (base4, ...values) => {
        if (options3.override !== false) {
          return base4.valid(Joi.override, ...values);
        }
        return base4.valid(...values);
      };
      if (internals.simple(config2)) {
        return valid(Joi, config2);
      }
      if (typeof config2 === "function") {
        return Joi.custom(config2);
      }
      assert4(typeof config2 === "object", "Invalid schema content:", typeof config2);
      if (Common.isResolvable(config2)) {
        return valid(Joi, config2);
      }
      if (Common.isSchema(config2)) {
        return config2;
      }
      if (Array.isArray(config2)) {
        for (const item of config2) {
          if (!internals.simple(item)) {
            return Joi.alternatives().try(...config2);
          }
        }
        return valid(Joi, ...config2);
      }
      if (config2 instanceof RegExp) {
        return Joi.string().regex(config2);
      }
      if (config2 instanceof Date) {
        return valid(Joi.date(), config2);
      }
      assert4(Object.getPrototypeOf(config2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi.object().keys(config2);
    };
    exports2.ref = function(id, options3) {
      return Ref.isRef(id) ? id : Ref.create(id, options3);
    };
    exports2.compile = function(root, schema, options3 = {}) {
      Common.assertOptions(options3, [
        "legacy"
      ]);
      const any2 = schema && schema[Common.symbols.any];
      if (any2) {
        assert4(options3.legacy || any2.version === Common.version, "Cannot mix different versions of joi schemas:", any2.version, Common.version);
        return schema;
      }
      if (typeof schema !== "object" || !options3.legacy) {
        return exports2.schema(root, schema, {
          appendPath: true
        });
      }
      const compiler = internals.walk(schema);
      if (!compiler) {
        return exports2.schema(root, schema, {
          appendPath: true
        });
      }
      return compiler.compile(compiler.root, schema);
    };
    internals.walk = function(schema) {
      if (typeof schema !== "object") {
        return null;
      }
      if (Array.isArray(schema)) {
        for (const item of schema) {
          const compiler = internals.walk(item);
          if (compiler) {
            return compiler;
          }
        }
        return null;
      }
      const any2 = schema[Common.symbols.any];
      if (any2) {
        return {
          root: schema[any2.root],
          compile: any2.compile
        };
      }
      assert4(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    };
    internals.simple = function(value) {
      return value === null || [
        "boolean",
        "string",
        "number"
      ].includes(typeof value);
    };
    exports2.when = function(schema, condition, options3) {
      if (options3 === void 0) {
        assert4(condition && typeof condition === "object", "Missing options");
        options3 = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options3)) {
        options3 = {
          switch: options3
        };
      }
      Common.assertOptions(options3, [
        "is",
        "not",
        "then",
        "otherwise",
        "switch",
        "break"
      ]);
      if (Common.isSchema(condition)) {
        assert4(options3.is === void 0, '"is" can not be used with a schema condition');
        assert4(options3.not === void 0, '"not" can not be used with a schema condition');
        assert4(options3.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema, {
          is: condition,
          then: options3.then,
          otherwise: options3.otherwise,
          break: options3.break
        });
      }
      assert4(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      assert4(options3.not === void 0 || options3.is === void 0, 'Cannot combine "is" with "not"');
      if (options3.switch === void 0) {
        let rule2 = options3;
        if (options3.not !== void 0) {
          rule2 = {
            is: options3.not,
            then: options3.otherwise,
            otherwise: options3.then,
            break: options3.break
          };
        }
        let is = rule2.is !== void 0 ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
        assert4(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        assert4(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options3.is !== void 0 && !Ref.isRef(options3.is) && !Common.isSchema(options3.is)) {
          is = is.required();
        }
        return internals.condition(schema, {
          ref: exports2.ref(condition),
          is,
          then: rule2.then,
          otherwise: rule2.otherwise,
          break: rule2.break
        });
      }
      assert4(Array.isArray(options3.switch), '"switch" must be an array');
      assert4(options3.is === void 0, 'Cannot combine "switch" with "is"');
      assert4(options3.not === void 0, 'Cannot combine "switch" with "not"');
      assert4(options3.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports2.ref(condition),
        switch: [],
        break: options3.break
      };
      for (let i2 = 0; i2 < options3.switch.length; ++i2) {
        const test = options3.switch[i2];
        const last = i2 === options3.switch.length - 1;
        Common.assertOptions(test, last ? [
          "is",
          "then",
          "otherwise"
        ] : [
          "is",
          "then"
        ]);
        assert4(test.is !== void 0, 'Switch statement missing "is"');
        assert4(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema.$_compile(test.is),
          then: schema.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          assert4(options3.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options3.otherwise !== void 0 ? options3.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            assert4(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema, condition) {
      for (const key of [
        "then",
        "otherwise"
      ]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/extend.js
var require_extend2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/extend.js"(exports2) {
    "use strict";
    var { assert: assert4, clone: clone2 } = require_lib();
    var Common = require_common2();
    var Messages = require_messages2();
    var internals = {};
    exports2.type = function(from6, options3) {
      const base4 = Object.getPrototypeOf(from6);
      const prototype = clone2(base4);
      const schema = from6._assign(Object.create(prototype));
      const def = Object.assign({}, options3);
      delete def.base;
      prototype._definition = def;
      const parent = base4._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          assert4(schema.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      def.prepare = internals.prepare(def.prepare, parent.prepare);
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = {
            method: def.coerce
          };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = {
            method: def.coerce.method,
            from: [].concat(def.coerce.from)
          };
        }
      }
      def.coerce = internals.coerce(def.coerce, parent.coerce);
      def.validate = internals.validate(def.validate, parent.validate);
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          assert4(typeof rule === "object", "Invalid rule definition for", def.type, name);
          let method = rule.method;
          if (method === void 0) {
            method = function() {
              return this.$_addRule(name);
            };
          }
          if (method) {
            assert4(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          assert4(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = {
                  name: arg
                };
              }
              assert4(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              if (Common.isSchema(arg.assert)) {
                arg.assert = arg.assert.strict().label(arg.name);
              }
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      const modifiers = Object.assign({}, parent.modifiers);
      if (def.modifiers) {
        for (const name in def.modifiers) {
          assert4(!prototype[name], "Rule conflict in", def.type, name);
          const modifier = def.modifiers[name];
          assert4(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
          const method = function(arg) {
            return this.rule({
              [name]: arg
            });
          };
          prototype[name] = method;
          modifiers[name] = modifier;
        }
      }
      def.modifiers = modifiers;
      if (def.overrides) {
        prototype._super = base4;
        schema.$_super = {};
        for (const override in def.overrides) {
          assert4(base4[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base4[override];
          schema.$_super[override] = base4[override].bind(schema);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      const manifest = Object.assign({}, parent.manifest, def.manifest);
      manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
      def.manifest = manifest;
      def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
      return schema;
    };
    internals.build = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(obj, desc) {
        return parent(child(obj, desc), desc);
      };
    };
    internals.coerce = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return {
        from: child.from && parent.from ? [
          .../* @__PURE__ */ new Set([
            ...child.from,
            ...parent.from
          ])
        ] : null,
        method(value, helpers) {
          let coerced;
          if (!parent.from || parent.from.includes(typeof value)) {
            coerced = parent.method(value, helpers);
            if (coerced) {
              if (coerced.errors || coerced.value === void 0) {
                return coerced;
              }
              value = coerced.value;
            }
          }
          if (!child.from || child.from.includes(typeof value)) {
            const own = child.method(value, helpers);
            if (own) {
              return own;
            }
          }
          return coerced;
        }
      };
    };
    internals.prepare = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const prepared = child(value, helpers);
        if (prepared) {
          if (prepared.errors || prepared.value === void 0) {
            return prepared;
          }
          value = prepared.value;
        }
        return parent(value, helpers) || prepared;
      };
    };
    internals.rebuild = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(schema) {
        parent(schema);
        child(schema);
      };
    };
    internals.validate = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const result = parent(value, helpers);
        if (result) {
          if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
            return result;
          }
          value = result.value;
        }
        return child(value, helpers) || result;
      };
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/manifest.js"(exports2) {
    "use strict";
    var { assert: assert4, clone: clone2 } = require_lib();
    var Common = require_common2();
    var Messages = require_messages2();
    var Ref = require_ref2();
    var Template = require_template2();
    var Schemas;
    var internals = {};
    exports2.describe = function(schema) {
      const def = schema._definition;
      const desc = {
        type: schema.type,
        flags: {},
        rules: []
      };
      for (const flag in schema._flags) {
        if (flag[0] !== "_") {
          desc.flags[flag] = internals.describe(schema._flags[flag]);
        }
      }
      if (!Object.keys(desc.flags).length) {
        delete desc.flags;
      }
      if (schema._preferences) {
        desc.preferences = clone2(schema._preferences, {
          shallow: [
            "messages"
          ]
        });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
          desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
      }
      if (schema._valids) {
        desc.allow = schema._valids.describe();
      }
      if (schema._invalids) {
        desc.invalid = schema._invalids.describe();
      }
      for (const rule of schema._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {
          continue;
        }
        const item = {
          name: rule.name
        };
        for (const custom2 in def.modifiers) {
          if (rule[custom2] !== void 0) {
            item[custom2] = internals.describe(rule[custom2]);
          }
        }
        if (rule.args) {
          item.args = {};
          for (const key in rule.args) {
            const arg = rule.args[key];
            if (key === "options" && !Object.keys(arg).length) {
              continue;
            }
            item.args[key] = internals.describe(arg, {
              assign: key
            });
          }
          if (!Object.keys(item.args).length) {
            delete item.args;
          }
        }
        desc.rules.push(item);
      }
      if (!desc.rules.length) {
        delete desc.rules;
      }
      for (const term in schema.$_terms) {
        if (term[0] === "_") {
          continue;
        }
        assert4(!desc[term], "Cannot describe schema due to internal name conflict with", term);
        const items = schema.$_terms[term];
        if (!items) {
          continue;
        }
        if (items instanceof Map) {
          if (items.size) {
            desc[term] = [
              ...items.entries()
            ];
          }
          continue;
        }
        if (Common.isValues(items)) {
          desc[term] = items.describe();
          continue;
        }
        assert4(def.terms[term], "Term", term, "missing configuration");
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === "object";
        if (!items.length && !mapped) {
          continue;
        }
        const normalized = [];
        for (const item of items) {
          normalized.push(internals.describe(item));
        }
        if (mapped) {
          const { from: from6, to } = manifest.mapped;
          desc[term] = {};
          for (const item of normalized) {
            desc[term][item[to]] = item[from6];
          }
          continue;
        }
        if (manifest === "single") {
          assert4(normalized.length === 1, "Term", term, "contains more than one item");
          desc[term] = normalized[0];
          continue;
        }
        desc[term] = normalized;
      }
      internals.validate(schema.$_root, desc);
      return desc;
    };
    internals.describe = function(item, options3 = {}) {
      if (Array.isArray(item)) {
        return item.map(internals.describe);
      }
      if (item === Common.symbols.deepDefault) {
        return {
          special: "deep"
        };
      }
      if (typeof item !== "object" || item === null) {
        return item;
      }
      if (options3.assign === "options") {
        return clone2(item);
      }
      if (Buffer && Buffer.isBuffer(item)) {
        return {
          buffer: item.toString("binary")
        };
      }
      if (item instanceof Date) {
        return item.toISOString();
      }
      if (item instanceof Error) {
        return item;
      }
      if (item instanceof RegExp) {
        if (options3.assign === "regex") {
          return item.toString();
        }
        return {
          regex: item.toString()
        };
      }
      if (item[Common.symbols.literal]) {
        return {
          function: item.literal
        };
      }
      if (typeof item.describe === "function") {
        if (options3.assign === "ref") {
          return item.describe().ref;
        }
        return item.describe();
      }
      const normalized = {};
      for (const key in item) {
        const value = item[key];
        if (value === void 0) {
          continue;
        }
        normalized[key] = internals.describe(value, {
          assign: key
        });
      }
      return normalized;
    };
    exports2.build = function(joi, desc) {
      const builder = new internals.Builder(joi);
      return builder.parse(desc);
    };
    internals.Builder = class {
      constructor(joi) {
        this.joi = joi;
      }
      parse(desc) {
        internals.validate(this.joi, desc);
        let schema = this.joi[desc.type]()._bare();
        const def = schema._definition;
        if (desc.flags) {
          for (const flag in desc.flags) {
            const setter = def.flags[flag] && def.flags[flag].setter || flag;
            assert4(typeof schema[setter] === "function", "Invalid flag", flag, "for type", desc.type);
            schema = schema[setter](this.build(desc.flags[flag]));
          }
        }
        if (desc.preferences) {
          schema = schema.preferences(this.build(desc.preferences));
        }
        if (desc.allow) {
          schema = schema.allow(...this.build(desc.allow));
        }
        if (desc.invalid) {
          schema = schema.invalid(...this.build(desc.invalid));
        }
        if (desc.rules) {
          for (const rule of desc.rules) {
            assert4(typeof schema[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
            const args = [];
            if (rule.args) {
              const built = {};
              for (const key in rule.args) {
                built[key] = this.build(rule.args[key], {
                  assign: key
                });
              }
              const keys = Object.keys(built);
              const definition = def.rules[rule.name].args;
              if (definition) {
                assert4(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
                for (const { name } of definition) {
                  args.push(built[name]);
                }
              } else {
                assert4(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
                args.push(built[keys[0]]);
              }
            }
            schema = schema[rule.name](...args);
            const options3 = {};
            for (const custom2 in def.modifiers) {
              if (rule[custom2] !== void 0) {
                options3[custom2] = this.build(rule[custom2]);
              }
            }
            if (Object.keys(options3).length) {
              schema = schema.rule(options3);
            }
          }
        }
        const terms = {};
        for (const key in desc) {
          if ([
            "allow",
            "flags",
            "invalid",
            "whens",
            "preferences",
            "rules",
            "type"
          ].includes(key)) {
            continue;
          }
          assert4(def.terms[key], "Term", key, "missing configuration");
          const manifest = def.terms[key].manifest;
          if (manifest === "schema") {
            terms[key] = desc[key].map((item) => this.parse(item));
            continue;
          }
          if (manifest === "values") {
            terms[key] = desc[key].map((item) => this.build(item));
            continue;
          }
          if (manifest === "single") {
            terms[key] = this.build(desc[key]);
            continue;
          }
          if (typeof manifest === "object") {
            terms[key] = {};
            for (const name in desc[key]) {
              const value = desc[key][name];
              terms[key][name] = this.parse(value);
            }
            continue;
          }
          terms[key] = this.build(desc[key]);
        }
        if (desc.whens) {
          terms.whens = desc.whens.map((when) => this.build(when));
        }
        schema = def.manifest.build(schema, terms);
        schema.$_temp.ruleset = false;
        return schema;
      }
      build(desc, options3 = {}) {
        if (desc === null) {
          return null;
        }
        if (Array.isArray(desc)) {
          return desc.map((item) => this.build(item));
        }
        if (desc instanceof Error) {
          return desc;
        }
        if (options3.assign === "options") {
          return clone2(desc);
        }
        if (options3.assign === "regex") {
          return internals.regex(desc);
        }
        if (options3.assign === "ref") {
          return Ref.build(desc);
        }
        if (typeof desc !== "object") {
          return desc;
        }
        if (Object.keys(desc).length === 1) {
          if (desc.buffer) {
            assert4(Buffer, "Buffers are not supported");
            return Buffer && Buffer.from(desc.buffer, "binary");
          }
          if (desc.function) {
            return {
              [Common.symbols.literal]: true,
              literal: desc.function
            };
          }
          if (desc.override) {
            return Common.symbols.override;
          }
          if (desc.ref) {
            return Ref.build(desc.ref);
          }
          if (desc.regex) {
            return internals.regex(desc.regex);
          }
          if (desc.special) {
            assert4([
              "deep"
            ].includes(desc.special), "Unknown special value", desc.special);
            return Common.symbols.deepDefault;
          }
          if (desc.value) {
            return clone2(desc.value);
          }
        }
        if (desc.type) {
          return this.parse(desc);
        }
        if (desc.template) {
          return Template.build(desc);
        }
        const normalized = {};
        for (const key in desc) {
          normalized[key] = this.build(desc[key], {
            assign: key
          });
        }
        return normalized;
      }
    };
    internals.regex = function(string4) {
      const end = string4.lastIndexOf("/");
      const exp = string4.slice(1, end);
      const flags = string4.slice(end + 1);
      return new RegExp(exp, flags);
    };
    internals.validate = function(joi, desc) {
      Schemas = Schemas || require_schemas2();
      joi.assert(desc, Schemas.description);
    };
  }
});

// node_modules/.deno/@hapi+pinpoint@2.0.1/node_modules/@hapi/pinpoint/lib/index.js
var require_lib31 = __commonJS({
  "node_modules/.deno/@hapi+pinpoint@2.0.1/node_modules/@hapi/pinpoint/lib/index.js"(exports2) {
    "use strict";
    exports2.location = function(depth = 0) {
      const orig = Error.prepareStackTrace;
      Error.prepareStackTrace = (ignore, stack) => stack;
      const capture = {};
      Error.captureStackTrace(capture, this);
      const line = capture.stack[depth + 1];
      Error.prepareStackTrace = orig;
      return {
        filename: line.getFileName(),
        line: line.getLineNumber()
      };
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/trace.js
var require_trace = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/trace.js"(exports2) {
    "use strict";
    var { deepEqual } = require_lib();
    var Pinpoint = require_lib31();
    var Errors = require_errors2();
    var internals = {
      codes: {
        error: 1,
        pass: 2,
        full: 3
      },
      labels: {
        0: "never used",
        1: "always error",
        2: "always pass"
      }
    };
    exports2.setup = function(root) {
      const trace = function() {
        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
      };
      root.trace = trace;
      root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
      root.untrace = () => {
        root._tracer = null;
      };
    };
    exports2.location = function(schema) {
      return schema.$_setFlag("_tracerLocation", Pinpoint.location(2));
    };
    internals.Tracer = class {
      constructor() {
        this.name = "Joi";
        this._schemas = /* @__PURE__ */ new Map();
      }
      _register(schema) {
        const existing = this._schemas.get(schema);
        if (existing) {
          return existing.store;
        }
        const store = new internals.Store(schema);
        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);
        this._schemas.set(schema, {
          filename,
          line,
          store
        });
        return store;
      }
      _combine(merged, sources) {
        for (const { store } of this._schemas.values()) {
          store._combine(merged, sources);
        }
      }
      report(file2) {
        const coverage = [];
        for (const { filename, line, store } of this._schemas.values()) {
          if (file2 && file2 !== filename) {
            continue;
          }
          const missing = [];
          const skipped = [];
          for (const [schema, log] of store._sources.entries()) {
            if (internals.sub(log.paths, skipped)) {
              continue;
            }
            if (!log.entry) {
              missing.push({
                status: "never reached",
                paths: [
                  ...log.paths
                ]
              });
              skipped.push(...log.paths);
              continue;
            }
            for (const type of [
              "valid",
              "invalid"
            ]) {
              const set2 = schema[`_${type}s`];
              if (!set2) {
                continue;
              }
              const values = new Set(set2._values);
              const refs = new Set(set2._refs);
              for (const { value, ref } of log[type]) {
                values.delete(value);
                refs.delete(ref);
              }
              if (values.size || refs.size) {
                missing.push({
                  status: [
                    ...values,
                    ...[
                      ...refs
                    ].map((ref) => ref.display)
                  ],
                  rule: `${type}s`
                });
              }
            }
            const rules = schema._rules.map((rule) => rule.name);
            for (const type of [
              "default",
              "failover"
            ]) {
              if (schema._flags[type] !== void 0) {
                rules.push(type);
              }
            }
            for (const name of rules) {
              const status = internals.labels[log.rule[name] || 0];
              if (status) {
                const report = {
                  rule: name,
                  status
                };
                if (log.paths.size) {
                  report.paths = [
                    ...log.paths
                  ];
                }
                missing.push(report);
              }
            }
          }
          if (missing.length) {
            coverage.push({
              filename,
              line,
              missing,
              severity: "error",
              message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
            });
          }
        }
        return coverage.length ? coverage : null;
      }
    };
    internals.Store = class {
      constructor(schema) {
        this.active = true;
        this._sources = /* @__PURE__ */ new Map();
        this._combos = /* @__PURE__ */ new Map();
        this._scan(schema);
      }
      debug(state, source, name, result) {
        state.mainstay.debug && state.mainstay.debug.push({
          type: source,
          name,
          result,
          path: state.path
        });
      }
      entry(schema, state) {
        internals.debug(state, {
          type: "entry"
        });
        this._record(schema, (log) => {
          log.entry = true;
        });
      }
      filter(schema, state, source, value) {
        internals.debug(state, {
          type: source,
          ...value
        });
        this._record(schema, (log) => {
          log[source].add(value);
        });
      }
      log(schema, state, source, name, result) {
        internals.debug(state, {
          type: source,
          name,
          result: result === "full" ? "pass" : result
        });
        this._record(schema, (log) => {
          log[source][name] = log[source][name] || 0;
          log[source][name] |= internals.codes[result];
        });
      }
      resolve(state, ref, to) {
        if (!state.mainstay.debug) {
          return;
        }
        const log = {
          type: "resolve",
          ref: ref.display,
          to,
          path: state.path
        };
        state.mainstay.debug.push(log);
      }
      value(state, by, from6, to, name) {
        if (!state.mainstay.debug || deepEqual(from6, to)) {
          return;
        }
        const log = {
          type: "value",
          by,
          from: from6,
          to,
          path: state.path
        };
        if (name) {
          log.name = name;
        }
        state.mainstay.debug.push(log);
      }
      _record(schema, each) {
        const log = this._sources.get(schema);
        if (log) {
          each(log);
          return;
        }
        const sources = this._combos.get(schema);
        for (const source of sources) {
          this._record(source, each);
        }
      }
      _scan(schema, _path) {
        const path = _path || [];
        let log = this._sources.get(schema);
        if (!log) {
          log = {
            paths: /* @__PURE__ */ new Set(),
            entry: false,
            rule: {},
            valid: /* @__PURE__ */ new Set(),
            invalid: /* @__PURE__ */ new Set()
          };
          this._sources.set(schema, log);
        }
        if (path.length) {
          log.paths.add(path);
        }
        const each = (sub, source) => {
          const subId = internals.id(sub, source);
          this._scan(sub, path.concat(subId));
        };
        schema.$_modify({
          each,
          ref: false
        });
      }
      _combine(merged, sources) {
        this._combos.set(merged, sources);
      }
    };
    internals.message = function(item) {
      const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
      return `${path}${item.rule || ""} (${item.status})`;
    };
    internals.id = function(schema, { source, name, path, key }) {
      if (schema._flags.id) {
        return schema._flags.id;
      }
      if (key) {
        return key;
      }
      name = `@${name}`;
      if (source === "terms") {
        return [
          name,
          path[Math.min(path.length - 1, 1)]
        ];
      }
      return name;
    };
    internals.sub = function(paths, skipped) {
      for (const path of paths) {
        for (const skip of skipped) {
          if (deepEqual(path.slice(0, skip.length), skip)) {
            return true;
          }
        }
      }
      return false;
    };
    internals.debug = function(state, event) {
      if (state.mainstay.debug) {
        event.path = state.debug ? [
          ...state.path,
          state.debug
        ] : state.path;
        state.mainstay.debug.push(event);
      }
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/modify.js
var require_modify2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/modify.js"(exports2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Common = require_common2();
    var Ref = require_ref2();
    var internals = {};
    exports2.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone2 = new internals.Ids();
        clone2._byId = new Map(this._byId);
        clone2._byKey = new Map(this._byKey);
        clone2._schemaChain = this._schemaChain;
        return clone2;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          assert4(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          assert4(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      fork(path, adjuster, root) {
        const chain = this._collect(path);
        chain.push({
          schema: root
        });
        const tail = chain.shift();
        let adjusted = {
          id: tail.id,
          schema: adjuster(tail.schema)
        };
        assert4(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
        for (const node of chain) {
          adjusted = {
            id: node.id,
            schema: internals.fork(node.schema, adjusted.id, adjusted.schema)
          };
        }
        return adjusted.schema;
      }
      labels(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        if (!node) {
          return [
            ...behind,
            ...path
          ].join(".");
        }
        const forward = path.slice(1);
        behind = [
          ...behind,
          node.schema._flags.label || current
        ];
        if (!forward.length) {
          return behind.join(".");
        }
        return node.schema._ids.labels(forward, behind);
      }
      reach(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        assert4(node, "Schema does not contain path", [
          ...behind,
          ...path
        ].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [
          ...behind,
          current
        ]);
      }
      register(schema, { key } = {}) {
        if (!schema || !Common.isSchema(schema)) {
          return;
        }
        if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          assert4(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
          assert4(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, {
            schema,
            id
          });
        }
        if (key) {
          assert4(!this._byKey.has(key), "Schema already contains key:", key);
          assert4(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, {
            schema,
            id: key
          });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _collect(path, behind = [], nodes = []) {
        const current = path[0];
        const node = this._get(current);
        assert4(node, "Schema does not contain path", [
          ...behind,
          ...path
        ].join("."));
        nodes = [
          node,
          ...nodes
        ];
        const forward = path.slice(1);
        if (!forward.length) {
          return nodes;
        }
        return node.schema._ids._collect(forward, [
          ...behind,
          current
        ], nodes);
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    internals.fork = function(schema, id, replacement) {
      const each = (item, { key }) => {
        if (id === (item._flags.id || key)) {
          return replacement;
        }
      };
      const obj = exports2.schema(schema, {
        each,
        ref: false
      });
      return obj ? obj.$_mutateRebuild() : schema;
    };
    exports2.schema = function(schema, options3) {
      let obj;
      for (const name in schema._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema._flags[name], {
          source: "flags",
          name
        }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj._flags[name] = result;
        }
      }
      for (let i2 = 0; i2 < schema._rules.length; ++i2) {
        const rule = schema._rules[i2];
        const result = internals.scan(rule.args, {
          source: "rules",
          name: rule.name
        }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          const clone2 = Object.assign({}, rule);
          clone2.args = result;
          obj._rules[i2] = clone2;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone2);
          }
        }
      }
      for (const name in schema.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema.$_terms[name], {
          source: "terms",
          name
        }, options3);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options3, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone2;
      if (Array.isArray(item)) {
        for (let i2 = 0; i2 < item.length; ++i2) {
          const key = source.source === "terms" && source.name === "keys" && item[i2].key;
          const result = internals.scan(item[i2], source, options3, [
            i2,
            ...path
          ], key);
          if (result !== void 0) {
            clone2 = clone2 || item.slice();
            clone2[i2] = result;
          }
        }
        return clone2;
      }
      if (options3.schema !== false && Common.isSchema(item) || options3.ref !== false && Ref.isRef(item)) {
        const result = options3.each(item, {
          ...source,
          path,
          key: _key
        });
        if (result === item) {
          return;
        }
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options3, [
          key,
          ...path
        ], _key);
        if (result !== void 0) {
          clone2 = clone2 || Object.assign({}, item);
          clone2[key] = result;
        }
      }
      return clone2;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/state.js
var require_state2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/state.js"(exports2, module2) {
    "use strict";
    var { clone: clone2, reach } = require_lib();
    var Common = require_common2();
    var internals = {
      value: Symbol("value")
    };
    module2.exports = internals.State = class {
      constructor(path, ancestors, state) {
        this.path = path;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
        this.debug = null;
      }
      localize(path, ancestors = null, schema = null) {
        const state = new internals.State(path, ancestors, this);
        if (schema && state.schemas) {
          state.schemas = [
            internals.schemas(schema),
            ...state.schemas
          ];
        }
        return state;
      }
      nest(schema, debug) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [
          internals.schemas(schema),
          ...state.schemas
        ];
        state.debug = debug;
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = clone2(this.mainstay.shadow.node(this.path));
        }
        this.mainstay.snapshot();
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.restore();
      }
      commit() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
        this.mainstay.commit();
      }
    };
    internals.schemas = function(schema) {
      if (Common.isSchema(schema)) {
        return {
          schema
        };
      }
      return schema;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path, value, reason) {
        if (!path.length) {
          return;
        }
        if (reason === "strip" && typeof path[path.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i2 = 0; i2 < path.length; ++i2) {
          const segment = path[i2];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path) {
        const node = this.node(path);
        if (node) {
          return node[internals.value];
        }
      }
      node(path) {
        if (!this._values) {
          return;
        }
        return reach(this._values, path, {
          iterables: true
        });
      }
      override(path, node) {
        if (!this._values) {
          return;
        }
        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = reach(this._values, parents, {
          iterables: true
        });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/validator.js
var require_validator2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/validator.js"(exports2) {
    "use strict";
    var { assert: assert4, clone: clone2, ignore, reach } = require_lib();
    var Common = require_common2();
    var Errors = require_errors2();
    var State = require_state2();
    var internals = {
      result: Symbol("result")
    };
    exports2.entry = function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        assert4(prefs.warnings === void 0, "Cannot override warnings preference in synchronous validation");
        assert4(prefs.artifacts === void 0, "Cannot override artifacts preference in synchronous validation");
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      assert4(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const outcome = {
        value: result.value
      };
      if (result.error) {
        outcome.error = result.error;
      }
      if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
      }
      if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
      }
      if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
      }
      return outcome;
    };
    exports2.entryAsync = async function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      const mainstay = result.mainstay;
      if (result.error) {
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
      if (mainstay.externals.length) {
        let root = result.value;
        const errors = [];
        for (const external of mainstay.externals) {
          const path = external.state.path;
          const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
          let node = root;
          let key;
          let parent;
          const ancestors = path.length ? [
            root
          ] : [];
          const original = path.length ? reach(value, path) : value;
          if (path.length) {
            key = path[path.length - 1];
            let current = root;
            for (const segment of path.slice(0, -1)) {
              current = current[segment];
              ancestors.unshift(current);
            }
            parent = ancestors[0];
            node = parent[key];
          }
          try {
            const createError = (code3, local) => (linked || external.schema).$_createError(code3, node, local, external.state, settings);
            const output = await external.method(node, {
              schema: external.schema,
              linked,
              state: external.state,
              prefs,
              original,
              error: createError,
              errorsArray: internals.errorsArray,
              warn: (code3, local) => mainstay.warnings.push((linked || external.schema).$_createError(code3, node, local, external.state, settings)),
              message: (messages, local) => (linked || external.schema).$_createError("external", node, local, external.state, settings, {
                messages
              })
            });
            if (output === void 0 || output === node) {
              continue;
            }
            if (output instanceof Errors.Report) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (Array.isArray(output) && output[Common.symbols.errors]) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors.push(...output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (parent) {
              mainstay.tracer.value(external.state, "rule", node, output, "external");
              parent[key] = output;
            } else {
              mainstay.tracer.value(external.state, "rule", root, output, "external");
              root = output;
            }
          } catch (err) {
            if (settings.errors.label) {
              err.message += ` (${external.label})`;
            }
            throw err;
          }
        }
        result.value = root;
        if (errors.length) {
          result.error = Errors.process(errors, value, settings);
          if (mainstay.debug) {
            result.error.debug = mainstay.debug;
          }
          throw result.error;
        }
      }
      if (!settings.warnings && !settings.debug && !settings.artifacts) {
        return result.value;
      }
      const outcome = {
        value: result.value
      };
      if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
      }
      if (mainstay.debug) {
        outcome.debug = mainstay.debug;
      }
      if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
      }
      return outcome;
    };
    exports2.standard = function(value, schema) {
      if (schema.isAsync()) {
        return exports2.entryAsync(value, schema);
      }
      return exports2.entry(value, schema);
    };
    internals.Mainstay = class {
      constructor(tracer, debug, links) {
        this.externals = [];
        this.warnings = [];
        this.tracer = tracer;
        this.debug = debug;
        this.links = links;
        this.shadow = null;
        this.artifacts = null;
        this._snapshots = [];
      }
      snapshot() {
        this._snapshots.push({
          externals: this.externals.slice(),
          warnings: this.warnings.slice()
        });
      }
      restore() {
        const snapshot = this._snapshots.pop();
        this.externals = snapshot.externals;
        this.warnings = snapshot.warnings;
      }
      commit() {
        this._snapshots.pop();
      }
    };
    internals.entry = function(value, schema, prefs) {
      const { tracer, cleanup } = internals.tracer(schema, prefs);
      const debug = prefs.debug ? [] : null;
      const links = schema._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = new internals.Mainstay(tracer, debug, links);
      const schemas = schema._ids._schemaChain ? [
        {
          schema
        }
      ] : null;
      const state = new State([], [], {
        mainstay,
        schemas
      });
      const result = exports2.validate(value, schema, state, prefs);
      if (cleanup) {
        schema.$_root.untrace();
      }
      const error40 = Errors.process(result.errors, value, prefs);
      return {
        value: result.value,
        error: error40,
        mainstay
      };
    };
    internals.tracer = function(schema, prefs) {
      if (schema.$_root._tracer) {
        return {
          tracer: schema.$_root._tracer._register(schema)
        };
      }
      if (prefs.debug) {
        assert4(schema.$_root.trace, "Debug mode not supported");
        return {
          tracer: schema.$_root.trace()._register(schema),
          cleanup: true
        };
      }
      return {
        tracer: internals.ignore
      };
    };
    exports2.validate = function(value, schema, state, prefs, overrides = {}) {
      if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
      }
      if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
      }
      if (schema._cache && prefs.cache) {
        const result = schema._cache.get(value);
        state.mainstay.tracer.debug(state, "validate", "cached", !!result);
        if (result) {
          return result;
        }
      }
      const createError = (code3, local, localState) => schema.$_createError(code3, value, local, localState || state, prefs);
      const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: (code3, local, localState) => state.mainstay.warnings.push(createError(code3, local, localState)),
        message: (messages, local) => schema.$_createError("custom", value, local, state, prefs, {
          messages
        })
      };
      state.mainstay.tracer.entry(schema, state);
      const def = schema._definition;
      if (def.prepare && value !== void 0 && prefs.convert) {
        const prepared = def.prepare(value, helpers);
        if (prepared) {
          state.mainstay.tracer.value(state, "prepare", value, prepared.value);
          if (prepared.errors) {
            return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
          }
          value = prepared.value;
        }
      }
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          state.mainstay.tracer.value(state, "coerced", value, coerced.value);
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty4 = schema._flags.empty;
      if (empty4 && empty4.$_match(internals.trim(value, schema), state.nest(empty4), Common.defaults)) {
        state.mainstay.tracer.value(state, "empty", value, void 0);
        value = void 0;
      }
      const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [
            schema.$_createError("any.required", value, null, state, prefs)
          ], helpers);
        }
        if (presence === "optional") {
          if (schema._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          state.mainstay.tracer.value(state, "default", value, {});
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [
          schema.$_createError("any.unknown", value, null, state, prefs)
        ], helpers);
      }
      const errors = [];
      if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            state.mainstay.tracer.value(state, "valids", value, match.value);
            value = match.value;
          }
          state.mainstay.tracer.filter(schema, state, "valid", match);
          return internals.finalize(value, null, helpers);
        }
        if (schema._flags.only) {
          const report = schema.$_createError("any.only", value, {
            valids: schema._valids.values({
              display: true
            })
          }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [
              report
            ], helpers);
          }
          errors.push(report);
        }
      }
      if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          state.mainstay.tracer.filter(schema, state, "invalid", match);
          const report = schema.$_createError("any.invalid", value, {
            invalids: schema._invalids.values({
              display: true
            })
          }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [
              report
            ], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base4 = def.validate(value, helpers);
        if (base4) {
          state.mainstay.tracer.value(state, "base", value, base4.value);
          value = base4.value;
          if (base4.errors) {
            if (!Array.isArray(base4.errors)) {
              errors.push(base4.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base4.errors.length) {
              errors.push(...base4.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "full");
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema.$_createError("any.ref", resolved, {
                arg: key,
                ref: args[key],
                reason: invalid
              }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "error");
          if (rule.warn) {
            state.mainstay.warnings.push(...result.errors);
            continue;
          }
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "pass");
          state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return {
          errors: [
            ret
          ],
          value: null
        };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        ret.forEach((report) => internals.error(report, rule));
        return {
          errors: ret,
          value: null
        };
      }
      return {
        errors: null,
        value: ret
      };
    };
    internals.error = function(report, rule) {
      if (rule.message) {
        report._setTemplate(rule.message);
      }
      return report;
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema, state, prefs } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          state.mainstay.tracer.value(state, "failover", value, failover);
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema._flags.error) {
        if (typeof schema._flags.error === "function") {
          errors = schema._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [
              errors
            ];
          }
          for (const error40 of errors) {
            assert4(error40 instanceof Error || error40 instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [
            schema._flags.error
          ];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        state.mainstay.tracer.value(state, "default", value, defaulted);
        value = defaulted;
      }
      if (schema._flags.cast && value !== void 0) {
        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          state.mainstay.tracer.value(state, "cast", value, casted, schema._flags.cast);
          value = casted;
        }
      }
      if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {
        for (const { method } of schema.$_terms.externals) {
          state.mainstay.externals.push({
            method,
            schema,
            state,
            label: Errors.label(schema._flags, state, prefs)
          });
        }
      }
      const result = {
        value,
        errors: errors.length ? errors : null
      };
      if (schema._flags.result) {
        result.value = schema._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
        state.shadow(value, schema._flags.result);
      }
      if (schema._cache && prefs.cache !== false && !schema._refs.length) {
        schema._cache.set(helpers.original, result);
      }
      if (value !== void 0 && !result.errors && schema._flags.artifact !== void 0) {
        state.mainstay.artifacts = state.mainstay.artifacts || /* @__PURE__ */ new Map();
        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {
          state.mainstay.artifacts.set(schema._flags.artifact, []);
        }
        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);
      }
      return result;
    };
    internals.prefs = function(schema, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
        return schema._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema._preferences);
      if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      const source = schema._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      state.mainstay.tracer.log(schema, state, "rule", flag, "full");
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [
          clone2(state.ancestors[0]),
          helpers
        ] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema.$_createError(`any.${flag}`, null, {
            error: err
          }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return clone2(source);
    };
    internals.trim = function(value, schema) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.ignore = {
      active: false,
      debug: ignore,
      entry: ignore,
      filter: ignore,
      log: ignore,
      resolve: ignore,
      value: ignore
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/values.js
var require_values2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/values.js"(exports2, module2) {
    "use strict";
    var { assert: assert4, deepEqual } = require_lib();
    var Common = require_common2();
    var internals = {};
    module2.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [
            ...source._values,
            ...source._refs
          ]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [
            ...remove._values,
            ...remove._refs
          ]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return {
            value
          };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return {
              value: found
            };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (deepEqual(item, value)) {
              return {
                value: item
              };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, {
              in: true
            });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [
              resolved
            ] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return {
                    value: item,
                    ref
                  };
                }
              } else {
                if (deepEqual(item, value)) {
                  return {
                    value: item,
                    ref
                  };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options3) {
        if (options3 && options3.display) {
          const values = [];
          for (const item of [
            ...this._values,
            ...this._refs
          ]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([
          ...this._values,
          ...this._refs
        ]);
      }
      clone() {
        const set2 = new internals.Values(this._values, this._refs);
        set2._override = this._override;
        return set2;
      }
      concat(source) {
        assert4(!source._override, "Cannot concat override set of values");
        const set2 = new internals.Values([
          ...this._values,
          ...source._values
        ], [
          ...this._refs,
          ...source._refs
        ]);
        set2._override = this._override;
        return set2;
      }
      describe() {
        const normalized = [];
        if (this._override) {
          normalized.push({
            override: true
          });
        }
        for (const value of this._values.values()) {
          normalized.push(value && typeof value === "object" ? {
            value
          } : value);
        }
        for (const value of this._refs.values()) {
          normalized.push(value.describe());
        }
        return normalized;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from6) {
      const map2 = /* @__PURE__ */ new Map();
      if (from6) {
        for (const value of from6) {
          if (typeof value === "string") {
            map2.set(value.toLowerCase(), value);
          }
        }
      }
      return map2;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/base.js
var require_base2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/base.js"(exports2, module2) {
    "use strict";
    var { assert: assert4, clone: clone2, deepEqual, merge: merge3 } = require_lib();
    var Cache = require_cache();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Extend = require_extend2();
    var Manifest = require_manifest();
    var Messages = require_messages2();
    var Modify = require_modify2();
    var Ref = require_ref2();
    var Trace = require_trace();
    var Validator = require_validator2();
    var Values = require_values2();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._reset();
      }
      _reset() {
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          ruleset: null,
          whens: {}
          // Runtime cache of generated whens
        };
      }
      // Manifest
      describe() {
        assert4(typeof Manifest.describe === "function", "Manifest functionality disabled");
        return Manifest.describe(this);
      }
      // Rules
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      alter(targets) {
        assert4(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
        assert4(!this._inRuleset(), "Cannot set alterations inside a ruleset");
        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
          const adjuster = targets[target];
          assert4(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
          obj.$_terms.alterations.push({
            target,
            adjuster
          });
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      artifact(id) {
        assert4(id !== void 0, "Artifact cannot be undefined");
        assert4(!this._cache, "Cannot set an artifact with a rule cache");
        return this.$_setFlag("artifact", id);
      }
      cast(to) {
        assert4(to === false || typeof to === "string", "Invalid to value");
        assert4(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options3) {
        return this._default("default", value, options3);
      }
      description(desc) {
        assert4(desc && typeof desc === "string", "Description must be a non-empty string");
        return this.$_setFlag("description", desc);
      }
      empty(schema) {
        const obj = this.clone();
        if (schema !== void 0) {
          schema = obj.$_compile(schema, {
            override: false
          });
        }
        return obj.$_setFlag("empty", schema, {
          clone: false
        });
      }
      error(err) {
        assert4(err, "Missing error");
        assert4(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      example(example, options3 = {}) {
        assert4(example !== void 0, "Missing example");
        Common.assertOptions(options3, [
          "override"
        ]);
        return this._inner("examples", example, {
          single: true,
          override: options3.override
        });
      }
      external(method, description) {
        if (typeof method === "object") {
          assert4(!description, "Cannot combine options with description");
          description = method.description;
          method = method.method;
        }
        assert4(typeof method === "function", "Method must be a function");
        assert4(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
        return this._inner("externals", {
          method,
          description
        }, {
          single: true
        });
      }
      failover(value, options3) {
        return this._default("failover", value, options3);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        assert4(typeof id === "string", "id must be a non-empty string");
        assert4(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      label(name) {
        assert4(name && typeof name === "string", "Label name must be a non-empty string");
        return this.$_setFlag("label", name);
      }
      meta(meta) {
        assert4(meta !== void 0, "Meta cannot be undefined");
        return this._inner("metas", meta, {
          single: true
        });
      }
      note(...notes) {
        assert4(notes.length, "Missing notes");
        for (const note of notes) {
          assert4(note && typeof note === "string", "Notes must be non-empty strings");
        }
        return this._inner("notes", notes);
      }
      only(mode = true) {
        assert4(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        assert4(prefs, "Missing preferences");
        assert4(prefs.context === void 0, "Cannot override context");
        assert4(prefs.externals === void 0, "Cannot override externals");
        assert4(prefs.warnings === void 0, "Cannot override warnings");
        assert4(prefs.debug === void 0, "Cannot override debug");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        assert4([
          "optional",
          "required",
          "forbidden"
        ].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled3 = true) {
        return this.$_setFlag("result", enabled3 ? "raw" : void 0);
      }
      result(mode) {
        assert4([
          "raw",
          "strip"
        ].includes(mode), "Unknown result mode", mode);
        return this.$_setFlag("result", mode);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled3) {
        const obj = this.clone();
        const convert = enabled3 === void 0 ? false : !enabled3;
        obj._preferences = Common.preferences(obj._preferences, {
          convert
        });
        return obj;
      }
      strip(enabled3 = true) {
        return this.$_setFlag("result", enabled3 ? "strip" : void 0);
      }
      tag(...tags) {
        assert4(tags.length, "Missing tags");
        for (const tag2 of tags) {
          assert4(tag2 && typeof tag2 === "string", "Tags must be non-empty strings");
        }
        return this._inner("tags", tags);
      }
      unit(name) {
        assert4(name && typeof name === "string", "Unit name must be a non-empty string");
        return this.$_setFlag("unit", name);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, {
          clone: false
        });
        return obj;
      }
      when(condition, options3) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options3);
        if (![
          "any",
          "link"
        ].includes(obj.type)) {
          const conditions = when.is ? [
            when
          ] : when.switch;
          for (const item of conditions) {
            assert4(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
            assert4(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      // Helpers
      cache(cache3) {
        assert4(!this._inRuleset(), "Cannot set caching inside a ruleset");
        assert4(!this._cache, "Cannot override schema cache");
        assert4(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
        const obj = this.clone();
        obj._cache = cache3 || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        assert4(Common.isSchema(source), "Invalid schema object");
        assert4(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        assert4(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
        assert4(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          merge3(obj._flags, flags);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          merge3(obj._flags, flags);
        } else {
          merge3(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [
            this,
            source
          ]);
        }
        return obj.$_mutateRebuild();
      }
      extend(options3) {
        assert4(!options3.base, "Cannot extend type with another base");
        return Extend.type(this, options3);
      }
      extract(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.reach(path);
      }
      fork(paths, adjuster) {
        assert4(!this._inRuleset(), "Cannot fork inside a ruleset");
        let obj = this;
        for (let path of [].concat(paths)) {
          path = Array.isArray(path) ? path : path.split(".");
          obj = obj._ids.fork(path, adjuster, obj);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      isAsync() {
        if (Boolean(this.$_terms.externals?.length)) {
          return true;
        }
        if (this.$_terms.whens) {
          for (const when of this.$_terms.whens) {
            if (when.then?.isAsync()) {
              return true;
            }
            if (when.otherwise?.isAsync()) {
              return true;
            }
            if (when.switch) {
              for (const item of when.switch) {
                if (item.then?.isAsync()) {
                  return true;
                }
                if (item.otherwise?.isAsync()) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }
      rule(options3) {
        const def = this._definition;
        Common.assertOptions(options3, Object.keys(def.modifiers));
        assert4(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        assert4(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
        const obj = this.clone();
        for (let i2 = start; i2 < obj._rules.length; ++i2) {
          const original = obj._rules[i2];
          const rule = clone2(original);
          for (const name in options3) {
            def.modifiers[name](rule, options3[name]);
            assert4(rule.name === original.name, "Cannot change rule name");
          }
          obj._rules[i2] = rule;
          if (obj._singleRules.get(rule.name) === original) {
            obj._singleRules.set(rule.name, rule);
          }
        }
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      get ruleset() {
        assert4(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
      }
      get $() {
        return this.ruleset;
      }
      tailor(targets) {
        targets = [].concat(targets);
        assert4(!this._inRuleset(), "Cannot tailor inside a ruleset");
        let obj = this;
        if (this.$_terms.alterations) {
          for (const { target, adjuster } of this.$_terms.alterations) {
            if (targets.includes(target)) {
              obj = adjuster(obj);
              assert4(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
            }
          }
        }
        obj = obj.$_modify({
          each: (item) => item.tailor(targets),
          ref: false
        });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      tracer() {
        return Trace.location ? Trace.location(this) : this;
      }
      validate(value, options3) {
        return Validator.entry(value, this, options3);
      }
      validateAsync(value, options3) {
        return Validator.entryAsync(value, this, options3);
      }
      // Extensions
      $_addRule(options3) {
        if (typeof options3 === "string") {
          options3 = {
            name: options3
          };
        }
        assert4(options3 && typeof options3 === "object", "Invalid options");
        assert4(options3.name && typeof options3.name === "string", "Invalid rule name");
        for (const key in options3) {
          assert4(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options3);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        assert4(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          assert4(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error40 = Common.validateArg(arg, key, resolver);
                  assert4(!error40, error40, "or reference");
                }
              }
            }
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name, {
            clone: false
          });
          obj._singleRules.set(rule.name, rule);
        }
        if (obj.$_temp.ruleset === false) {
          obj.$_temp.ruleset = null;
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema, options3) {
        return Compile.schema(this.$_root, schema, options3);
      }
      $_createError(code3, value, local, state, prefs, options3 = {}) {
        const flags = options3.flags !== false ? this._flags : {};
        const messages = options3.messages ? Messages.merge(this._definition.messages, options3.messages) : this._definition.messages;
        return new Errors.Report(code3, value, local, flags, messages, state, prefs);
      }
      $_getFlag(name) {
        return this._flags[name];
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_mapLabels(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.labels(path);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options3) {
        Common.assertOptions(options3, [
          "each",
          "once",
          "ref",
          "schema"
        ]);
        return Modify.schema(this, options3) || this;
      }
      $_mutateRebuild() {
        assert4(!this._inRuleset(), "Cannot add this rule inside a ruleset");
        this._refs.reset();
        this._ids.reset();
        const each = (item, { source, name, path, key }) => {
          const family = this._definition[source][name] && this._definition[source][name].register;
          if (family !== false) {
            this.$_mutateRegister(item, {
              family,
              key
            });
          }
        };
        this.$_modify({
          each
        });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        this.$_temp.ruleset = false;
        return this;
      }
      $_mutateRegister(schema, { family, key } = {}) {
        this._refs.register(schema, family);
        this._ids.register(schema, {
          key
        });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path) {
        return this._ids.reach(path);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options3 = {}) {
        assert4(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
        const flag = this._definition.flags[name] || {};
        if (deepEqual(value, flag.default)) {
          value = void 0;
        }
        if (deepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options3.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        if (name[0] !== "_") {
          obj.$_temp.ruleset = false;
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      // Internals
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = clone2(this._singleRules, {
          shallow: true
        });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _bare() {
        const obj = this.clone();
        obj._reset();
        const terms = obj._definition.terms;
        for (const name in terms) {
          const term = terms[name];
          obj.$_terms[name] = term.init;
        }
        return obj.$_mutateRebuild();
      }
      _default(flag, value, options3 = {}) {
        Common.assertOptions(options3, "literal");
        assert4(value !== void 0, "Missing", flag, "value");
        assert4(typeof value === "function" || !options3.literal, "Only function value supports literal option");
        if (typeof value === "function" && options3.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return {
            schema: this
          };
        }
        const whens = [];
        const ids = [];
        for (let i2 = 0; i2 < this.$_terms.whens.length; ++i2) {
          const when = this.$_terms.whens[i2];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i2}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [
            when
          ] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i2}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([
                  ...state.path,
                  `${baseId}.then`
                ], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([
                ...state.path,
                `${baseId}.otherwise`
              ], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        state.mainstay.tracer.debug(state, "rule", "when", id);
        if (!id) {
          return {
            schema: this
          };
        }
        if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
          return {
            schema: this.$_temp.whens[id],
            id
          };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [
            this,
            ...whens
          ]);
        }
        this.$_temp.whens[id] = obj;
        return {
          schema: obj,
          id
        };
      }
      _inner(type, values, options3 = {}) {
        assert4(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
        const obj = this.clone();
        if (!obj.$_terms[type] || options3.override) {
          obj.$_terms[type] = [];
        }
        if (options3.single) {
          obj.$_terms[type].push(values);
        } else {
          obj.$_terms[type].push(...values);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      _inRuleset() {
        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
      }
      _ruleRemove(name, options3 = {}) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        const obj = options3.clone !== false ? this.clone() : this;
        obj._singleRules.delete(name);
        const filtered = [];
        for (let i2 = 0; i2 < obj._rules.length; ++i2) {
          const test = obj._rules[i2];
          if (test.name === name && !test.keep) {
            if (obj._inRuleset() && i2 < obj.$_temp.ruleset) {
              --obj.$_temp.ruleset;
            }
            continue;
          }
          filtered.push(test);
        }
        obj._rules = filtered;
        return obj;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          assert4(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          assert4(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              assert4(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
      // Standard Schema
      get "~standard"() {
        const mapToStandardError = (error40) => {
          let issues;
          if (Errors.ValidationError.isError(error40)) {
            issues = error40.details.map(({ message, path }) => ({
              message,
              path
            }));
          } else {
            issues = [
              {
                message: error40.message
              }
            ];
          }
          return {
            issues
          };
        };
        const mapToStandardValue = (value) => ({
          value
        });
        return {
          version: 1,
          vendor: "joi",
          validate: (value) => {
            const result = Validator.standard(value, this);
            if (result instanceof Promise) {
              return result.then(mapToStandardValue, mapToStandardError);
            }
            if (!result.error) {
              return mapToStandardValue(result.value);
            }
            return mapToStandardError(result.error);
          }
        };
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module2.exports = new internals.Base();
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/any.js
var require_any2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/any.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Base = require_base2();
    var Common = require_common2();
    var Messages = require_messages2();
    module2.exports = Base.extend({
      type: "any",
      flags: {
        only: {
          default: false
        }
      },
      terms: {
        alterations: {
          init: null
        },
        examples: {
          init: null
        },
        externals: {
          init: null
        },
        metas: {
          init: []
        },
        notes: {
          init: []
        },
        shared: {
          init: null
        },
        tags: {
          init: []
        },
        whens: {
          init: null
        }
      },
      rules: {
        custom: {
          method(method, description) {
            assert4(typeof method === "function", "Method must be a function");
            assert4(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({
              name: "custom",
              args: {
                method,
                description
              }
            });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", {
                error: err
              });
            }
          },
          args: [
            "method",
            "description"
          ],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({
              messages
            });
          }
        },
        shared: {
          method(schema) {
            assert4(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        warning: {
          method(code3, local) {
            assert4(code3 && typeof code3 === "string", "Invalid warning code");
            return this.$_addRule({
              name: "warning",
              args: {
                code: code3,
                local
              },
              warn: true
            });
          },
          validate(value, helpers, { code: code3, local }) {
            return helpers.error(code3, local);
          },
          args: [
            "code",
            "local"
          ],
          multi: true
        }
      },
      modifiers: {
        keep(rule, enabled3 = true) {
          rule.keep = enabled3;
        },
        message(rule, message) {
          rule.message = Messages.compile(message);
        },
        warn(rule, enabled3 = true) {
          rule.warn = enabled3;
        }
      },
      manifest: {
        build(obj, desc) {
          for (const key in desc) {
            const values = desc[key];
            if ([
              "examples",
              "externals",
              "metas",
              "notes",
              "tags"
            ].includes(key)) {
              for (const value of values) {
                obj = obj[key.slice(0, -1)](value);
              }
              continue;
            }
            if (key === "alterations") {
              const alter = {};
              for (const { target, adjuster } of values) {
                alter[target] = adjuster;
              }
              obj = obj.alter(alter);
              continue;
            }
            if (key === "whens") {
              for (const value of values) {
                const { ref, is, not, then, otherwise, concat: concat2 } = value;
                if (concat2) {
                  obj = obj.concat(concat2);
                } else if (ref) {
                  obj = obj.when(ref, {
                    is,
                    not,
                    then,
                    otherwise,
                    switch: value.switch,
                    break: value.break
                  });
                } else {
                  obj = obj.when(is, {
                    then,
                    otherwise,
                    break: value.break
                  });
                }
              }
              continue;
            }
            if (key === "shared") {
              for (const value of values) {
                obj = obj.shared(value);
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/alternatives.js
var require_alternatives2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/alternatives.js"(exports2, module2) {
    "use strict";
    var { assert: assert4, merge: merge3 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var internals = {};
    module2.exports = Any.extend({
      type: "alternatives",
      flags: {
        match: {
          default: "any"
        }
        // 'any', 'one', 'all'
      },
      terms: {
        matches: {
          init: [],
          register: Ref.toSibling
        }
      },
      args(schema, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema.try(...schemas[0]);
          }
        }
        return schema.try(...schemas);
      },
      validate(value, helpers) {
        const { schema, error: error40, state, prefs } = helpers;
        if (schema._flags.match) {
          const matched = [];
          const failed = [];
          for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
            const item = schema.$_terms.matches[i2];
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              matched.push(result.value);
              localState.commit();
            } else {
              failed.push(result.errors);
              localState.restore();
            }
          }
          if (matched.length === 0) {
            const context = {
              details: failed.map((f) => Errors.details(f, {
                override: false
              }))
            };
            return {
              errors: error40("alternatives.any", context)
            };
          }
          if (schema._flags.match === "one") {
            return matched.length === 1 ? {
              value: matched[0]
            } : {
              errors: error40("alternatives.one")
            };
          }
          if (matched.length !== schema.$_terms.matches.length) {
            const context = {
              details: failed.map((f) => Errors.details(f, {
                override: false
              }))
            };
            return {
              errors: error40("alternatives.all", context)
            };
          }
          const isAnyObj = (alternative) => {
            return alternative.$_terms.matches.some((v2) => {
              return v2.schema.type === "object" || v2.schema.type === "alternatives" && isAnyObj(v2.schema);
            });
          };
          return isAnyObj(schema) ? {
            value: matched.reduce((acc, v2) => merge3(acc, v2, {
              mergeArrays: false
            }))
          } : {
            value: matched[matched.length - 1]
          };
        }
        const errors = [];
        for (let i2 = 0; i2 < schema.$_terms.matches.length; ++i2) {
          const item = schema.$_terms.matches[i2];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i2}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              localState.commit();
              return result;
            }
            localState.restore();
            errors.push({
              schema: item.schema,
              reports: result.errors
            });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [
            item
          ] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i2}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options3) {
            assert4(!this._flags._endedSwitch, "Unreachable condition");
            assert4(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            assert4(options3.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options3);
            const conditions = match.is ? [
              match
            ] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, {
                  clone: false
                });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            assert4([
              "any",
              "one",
              "all"
            ].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                assert4(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            assert4(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            assert4(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema of schemas) {
              obj.$_terms.matches.push({
                schema: obj.$_compile(schema)
              });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      overrides: {
        label(name) {
          const obj = this.$_parent("label", name);
          const each = (item, source) => {
            return source.path[0] !== "is" && typeof item._flags.label !== "string" ? item.label(name) : void 0;
          };
          return obj.$_modify({
            each,
            ref: false
          });
        },
        isAsync() {
          if (this.$_terms.externals?.length) {
            return true;
          }
          for (const match of this.$_terms.matches) {
            if (match.schema?.isAsync()) {
              return true;
            }
            if (match.then?.isAsync()) {
              return true;
            }
            if (match.otherwise?.isAsync()) {
              return true;
            }
          }
          return false;
        }
      },
      rebuild(schema) {
        const each = (item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema.$_setFlag("_arrayItems", true, {
              clone: false
            });
          }
        };
        schema.$_modify({
          each
        });
      },
      manifest: {
        build(obj, desc) {
          if (desc.matches) {
            for (const match of desc.matches) {
              const { schema, ref, is, not, then, otherwise } = match;
              if (schema) {
                obj = obj.try(schema);
              } else if (ref) {
                obj = obj.conditional(ref, {
                  is,
                  then,
                  not,
                  otherwise,
                  switch: match.switch
                });
              } else {
                obj = obj.conditional(is, {
                  then,
                  otherwise
                });
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error: error40, state }) {
      if (!failures.length) {
        return {
          errors: error40("alternatives.any")
        };
      }
      if (failures.length === 1) {
        return {
          errors: failures[0].reports
        };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error40);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error40);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({
            type: schema.type,
            report
          });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code3] = report.code.split(".");
        if (code3 !== "base") {
          complex.push({
            type: schema.type,
            report
          });
        } else if (report.code === "object.base") {
          valids.add(report.local.type);
        } else {
          valids.add(type);
        }
      }
      if (!complex.length) {
        return {
          errors: error40("alternatives.types", {
            types: [
              ...valids
            ]
          })
        };
      }
      if (complex.length === 1) {
        return {
          errors: complex[0].report
        };
      }
      return internals.unmatched(failures, error40);
    };
    internals.unmatched = function(failures, error40) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return {
        errors: error40("alternatives.match", Errors.details(errors, {
          override: false
        }))
      };
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/array.js
var require_array2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/array.js"(exports2, module2) {
    "use strict";
    var { assert: assert4, deepEqual, reach } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var internals = {};
    module2.exports = Any.extend({
      type: "array",
      flags: {
        single: {
          default: false
        },
        sparse: {
          default: false
        }
      },
      terms: {
        items: {
          init: [],
          manifest: "schema"
        },
        ordered: {
          init: [],
          manifest: "schema"
        },
        _exclusions: {
          init: []
        },
        _inclusions: {
          init: []
        },
        _requireds: {
          init: []
        }
      },
      coerce: {
        from: "object",
        method(value, { schema, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema, error: error40 }) {
        if (!Array.isArray(value)) {
          if (schema._flags.single) {
            const single = [
              value
            ];
            single[Common.symbols.arraySingle] = true;
            return {
              value: single
            };
          }
          return {
            errors: error40("array.base")
          };
        }
        if (!schema.$_getRule("items") && !schema.$_terms.externals) {
          return;
        }
        return {
          value: value.slice()
        };
      },
      rules: {
        has: {
          method(schema) {
            schema = this.$_compile(schema, {
              appendPath: true
            });
            const obj = this.$_addRule({
              name: "has",
              args: {
                schema
              }
            });
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { state, prefs, error: error40 }, { schema: has3 }) {
            const ancestors = [
              value,
              ...state.ancestors
            ];
            for (let i2 = 0; i2 < value.length; ++i2) {
              const localState = state.localize([
                ...state.path,
                i2
              ], ancestors, has3);
              if (has3.$_match(value[i2], localState, prefs)) {
                return value;
              }
            }
            const patternLabel = has3._flags.label;
            if (patternLabel) {
              return error40("array.hasKnown", {
                patternLabel
              });
            }
            return error40("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, {
                append: true
              });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema, error: error40, state, prefs, errorsArray }) {
            const requireds = schema.$_terms._requireds.slice();
            const ordereds = schema.$_terms.ordered.slice();
            const inclusions = [
              ...schema.$_terms._inclusions,
              ...requireds
            ];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i2 = 0; i2 < il; ++i2) {
              const item = value[i2];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i2 : new Number(i2);
              const path = [
                ...state.path,
                key
              ];
              if (!schema._flags.sparse && item === void 0) {
                errors.push(error40("array.sparse", {
                  key,
                  path,
                  pos: i2,
                  value: void 0
                }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [
                value,
                ...state.ancestors
              ];
              for (const exclusion of schema.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, {
                  presence: "ignore"
                })) {
                  continue;
                }
                errors.push(error40("array.excludes", {
                  pos: i2,
                  value: item
                }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error40("array.sparse", {
                        key,
                        path,
                        pos: i2,
                        value: void 0
                      }, state.localize(path)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i2] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema.$_terms.items.length) {
                  errors.push(error40("array.orderedLength", {
                    pos: i2,
                    limit: schema.$_terms.ordered.length
                  }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  localState.commit();
                  value[i2] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema._flags.sparse && res.value === void 0) {
                    errors.push(error40("array.sparse", {
                      key,
                      path,
                      pos: i2,
                      value: void 0
                    }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    localState.commit();
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i2);
                      --i2;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error40("array.sparse", {
                        key,
                        path,
                        pos: i2,
                        value: void 0
                      }, state.localize(path)));
                      errored = true;
                    } else {
                      value[i2] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i2);
                    --i2;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i2);
                  --i2;
                  --il;
                  continue;
                }
                errors.push(error40("array.includes", {
                  pos: i2,
                  value: item
                }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
              if (!errors.length) {
                internals.fillDefault(ordereds, value, state, prefs);
              }
            }
            return errors.length ? errors : value;
          },
          priority: true,
          manifest: false
        },
        length: {
          method(limit) {
            return this.$_addRule({
              name: "length",
              args: {
                limit
              },
              operator: "="
            });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "length",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "length",
              args: {
                limit
              },
              operator: ">="
            });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i2 = 0; i2 < schemas.length; ++i2) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i2]), i2, {
                append: true
              });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled3) {
            const value = enabled3 === void 0 ? true : !!enabled3;
            assert4(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "by",
              "order"
            ]);
            const settings = {
              order: options3.order || "ascending"
            };
            if (options3.by) {
              settings.by = Compile.ref(options3.by, {
                ancestor: 0
              });
              assert4(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({
              name: "sort",
              args: {
                options: settings
              }
            });
          },
          validate(value, { error: error40, state, prefs, schema }, { options: options3 }) {
            const { value: sorted, errors } = internals.sort(schema, value, options3, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i2 = 0; i2 < value.length; ++i2) {
              if (value[i2] !== sorted[i2]) {
                return error40("array.sort", {
                  order: options3.order,
                  by: options3.by ? options3.by.key : "value"
                });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled3) {
            const value = enabled3 === void 0 ? true : !!enabled3;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, {
              clone: false
            });
          }
        },
        unique: {
          method(comparator, options3 = {}) {
            assert4(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options3, [
              "ignoreUndefined",
              "separator"
            ]);
            const rule = {
              name: "unique",
              args: {
                options: options3,
                comparator
              }
            };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options3.separator, ".");
                rule.path = separator ? comparator.split(separator) : [
                  comparator
                ];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error: error40, schema }, { comparator: raw, options: options3 }, { comparator, path }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              bigint: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || deepEqual;
            const ignoreUndefined = options3.ignoreUndefined;
            for (let i2 = 0; i2 < value.length; ++i2) {
              const item = path ? reach(value[i2], path) : value[i2];
              const records = comparator ? found.custom : found[typeof item];
              assert4(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([
                      ...state.path,
                      i2
                    ], [
                      value,
                      ...state.ancestors
                    ]);
                    const context = {
                      pos: i2,
                      value: value[i2],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path) {
                      context.path = raw;
                    }
                    return error40("array.unique", context, localState);
                  }
                }
                records.set(item, i2);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i2,
                    value: value[i2],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  const localState = state.localize([
                    ...state.path,
                    i2
                  ], [
                    value,
                    ...state.ancestors
                  ]);
                  return error40("array.unique", context, localState);
                }
                records[item] = i2;
              }
            }
            return value;
          },
          args: [
            "comparator",
            "options"
          ],
          multi: true
        }
      },
      overrides: {
        isAsync() {
          if (this.$_terms.externals?.length) {
            return true;
          }
          for (const item of this.$_terms.items) {
            if (item.isAsync()) {
              return true;
            }
          }
          for (const item of this.$_terms.ordered) {
            if (item.isAsync()) {
              return true;
            }
          }
          return false;
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema) {
        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];
        for (const type of schema.$_terms.items) {
          internals.validateSingle(type, schema);
          if (type._flags.presence === "required") {
            schema.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema.$_terms._exclusions.push(type);
          } else {
            schema.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema.$_terms.ordered) {
          internals.validateSingle(type, schema);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.items) {
            obj = obj.items(...desc.items);
          }
          if (desc.ordered) {
            obj = obj.ordered(...desc.ordered);
          }
          return obj;
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
      const knownMisses = [];
      let unknownMisses = 0;
      for (const required2 of requireds) {
        const label = required2._flags.label;
        if (label) {
          knownMisses.push(label);
        } else {
          ++unknownMisses;
        }
      }
      if (knownMisses.length) {
        if (unknownMisses) {
          errors.push(schema.$_createError("array.includesRequiredBoth", value, {
            knownMisses,
            unknownMisses
          }, state, prefs));
        } else {
          errors.push(schema.$_createError("array.includesRequiredKnowns", value, {
            knownMisses
          }, state, prefs));
        }
      } else {
        errors.push(schema.$_createError("array.includesRequiredUnknowns", value, {
          unknownMisses
        }, state, prefs));
      }
    };
    internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fillDefault = function(ordereds, value, state, prefs) {
      const overrides = [];
      let trailingUndefined = true;
      for (let i2 = ordereds.length - 1; i2 >= 0; --i2) {
        const ordered = ordereds[i2];
        const ancestors = [
          value,
          ...state.ancestors
        ];
        const override = ordered.$_validate(void 0, state.localize(state.path, ancestors, ordered), prefs).value;
        if (trailingUndefined) {
          if (override === void 0) {
            continue;
          }
          trailingUndefined = false;
        }
        overrides.unshift(override);
      }
      if (overrides.length) {
        value.push(...overrides);
      }
    };
    internals.fastSplice = function(arr, i2) {
      let pos = i2;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        assert4(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, {
          clone: false
        });
      }
    };
    internals.sort = function(schema, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = (a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema.$_createError("array.sort.unsupported", value, {
            type
          }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      };
      try {
        return {
          value: value.slice().sort(sort)
        };
      } catch (err) {
        return {
          errors: err
        };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/boolean.js
var require_boolean2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/boolean.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Values = require_values2();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module2.exports = Any.extend({
      type: "boolean",
      flags: {
        sensitive: {
          default: false
        }
      },
      terms: {
        falsy: {
          init: null,
          manifest: "values"
        },
        truthy: {
          init: null,
          manifest: "values"
        }
      },
      coerce(value, { schema }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }
        return {
          value
        };
      },
      validate(value, { error: error40 }) {
        if (typeof value !== "boolean") {
          return {
            value,
            errors: error40("boolean.base")
          };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              assert4(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i2 = 0; i2 < values.length; ++i2) {
              const value = values[i2];
              assert4(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled3 = true) {
            return this.$_setFlag("sensitive", enabled3);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.truthy) {
            obj = obj.truthy(...desc.truthy);
          }
          if (desc.falsy) {
            obj = obj.falsy(...desc.falsy);
          }
          return obj;
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/date.js
var require_date2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/date.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Template = require_template2();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module2.exports = Any.extend({
      type: "date",
      coerce: {
        from: [
          "number",
          "string"
        ],
        method(value, { schema }) {
          return {
            value: internals.parse(value, schema._flags.format) || value
          };
        }
      },
      validate(value, { schema, error: error40, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format10 = schema._flags.format;
        if (!prefs.convert || !format10 || typeof value !== "string") {
          return {
            value,
            errors: error40("date.base")
          };
        }
        return {
          value,
          errors: error40("date.format", {
            format: format10
          })
        };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date: date5 }, { name, operator, args }) {
            const to = date5 === "now" ? Date.now() : date5.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, {
              limit: args.date,
              value
            });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date5) => {
                return date5 === "now" ? date5 : internals.parse(date5);
              },
              assert: (date5) => date5 !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format10) {
            assert4([
              "iso",
              "javascript",
              "unix"
            ].includes(format10), "Unknown date format", format10);
            return this.$_setFlag("format", format10);
          }
        },
        greater: {
          method(date5) {
            return this.$_addRule({
              name: "greater",
              method: "compare",
              args: {
                date: date5
              },
              operator: ">"
            });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date5) {
            return this.$_addRule({
              name: "less",
              method: "compare",
              args: {
                date: date5
              },
              operator: "<"
            });
          }
        },
        max: {
          method(date5) {
            return this.$_addRule({
              name: "max",
              method: "compare",
              args: {
                date: date5
              },
              operator: "<="
            });
          }
        },
        min: {
          method(date5) {
            return this.$_addRule({
              name: "min",
              method: "compare",
              args: {
                date: date5
              },
              operator: ">="
            });
          }
        },
        timestamp: {
          method(type = "javascript") {
            assert4([
              "javascript",
              "unix"
            ].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
        // Messages used in date.format
        "date.format.iso": "ISO 8601 date",
        "date.format.javascript": "timestamp or number of milliseconds",
        "date.format.unix": "timestamp or number of seconds"
      }
    });
    internals.parse = function(value, format10) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format10 === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format10) {
        if (format10 === "javascript") {
          return internals.date(1 * value);
        }
        if (format10 === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date5 = new Date(value);
      if (!isNaN(date5.getTime())) {
        return date5;
      }
      return null;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/keys.js
var require_keys2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/keys.js"(exports2, module2) {
    "use strict";
    var { applyToDefaults, assert: assert4, clone: Clone } = require_lib();
    var Topo = require_lib2();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var Template = require_template2();
    var internals = {
      renameDefaults: {
        alias: false,
        multiple: false,
        override: false
        // Overrides an existing key
      }
    };
    module2.exports = Any.extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: {
          default: void 0
        }
      },
      terms: {
        dependencies: {
          init: null
        },
        keys: {
          init: null,
          manifest: {
            mapped: {
              from: "schema",
              to: "key"
            }
          }
        },
        patterns: {
          init: null
        },
        renames: {
          init: null
        }
      },
      args(schema, keys) {
        return schema.keys(keys);
      },
      validate(value, { schema, error: error40, state, prefs }) {
        if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
          return {
            value,
            errors: error40("object.base", {
              type: schema.$_property("typeof")
            })
          };
        }
        if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns && !schema.$_terms.externals) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
          return {
            value,
            errors
          };
        }
        if (!schema.$_terms.keys && // null allows any keys
        !schema.$_terms.patterns && !schema.$_terms.dependencies) {
          return {
            value,
            errors
          };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema.$_terms.keys) {
          const ancestors = [
            value,
            ...state.ancestors
          ];
          for (const child of schema.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([
              ...state.path,
              key
            ], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: result.errors
                };
              }
              if (result.value !== void 0) {
                value[key] = result.value;
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema._flags._hasPatternMatch) {
          const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema.$_terms.dependencies) {
          for (const dep of schema.$_terms.dependencies) {
            if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, {
              shadow: false
            })) === false) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
            if (failed) {
              const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: report
                };
              }
              errors.push(report);
            }
          }
        }
        return {
          value,
          errors
        };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema) {
            if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
              return this;
            }
            return this.keys(schema);
          }
        },
        assert: {
          method(subject, schema, message) {
            if (!Template.isTemplate(subject)) {
              subject = Compile.ref(subject);
            }
            assert4(message === void 0 || typeof message === "string", "Message must be a string");
            schema = this.$_compile(schema, {
              appendPath: true
            });
            const obj = this.$_addRule({
              name: "assert",
              args: {
                subject,
                schema,
                message
              }
            });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { error: error40, prefs, state }, { subject, schema, message }) {
            const about = subject.resolve(value, state, prefs);
            const path = Ref.isRef(subject) ? subject.absolute(state) : [];
            if (schema.$_match(about, state.localize(path, [
              value,
              ...state.ancestors
            ], schema), prefs)) {
              return value;
            }
            return error40("object.assert", {
              subject,
              message
            });
          },
          args: [
            "subject",
            "schema",
            "message"
          ],
          multi: true
        },
        instance: {
          method(constructor, name) {
            assert4(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({
              name: "instance",
              args: {
                constructor,
                name
              }
            });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", {
              type: name,
              value
            });
          },
          args: [
            "constructor",
            "name"
          ]
        },
        keys: {
          method(schema) {
            assert4(schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
            assert4(!Common.isSchema(schema), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema) {
                Common.tryWithPath(() => obj.$_terms.keys.push({
                  key,
                  schema: this.$_compile(schema[key])
                }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({
              name: "length",
              args: {
                limit
              },
              operator: "="
            });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "length",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "length",
              args: {
                limit
              },
              operator: ">="
            });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema, options3 = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, {
                appendPath: true
              });
            }
            assert4(schema !== void 0, "Invalid rule");
            Common.assertOptions(options3, [
              "fallthrough",
              "matches"
            ]);
            if (isRegExp) {
              assert4(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema = this.$_compile(schema, {
              appendPath: true
            });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config2 = {
              [isRegExp ? "regex" : "schema"]: pattern,
              rule: schema
            };
            if (options3.matches) {
              config2.matches = this.$_compile(options3.matches);
              if (config2.matches.type !== "array") {
                config2.matches = config2.matches.$_root.array().items(config2.matches);
              }
              obj.$_mutateRegister(config2.matches);
              obj.$_setFlag("_hasPatternMatch", true, {
                clone: false
              });
            }
            if (options3.fallthrough) {
              config2.fallthrough = true;
            }
            obj.$_terms.patterns.push(config2);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", {
              value
            });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", {
              value
            });
          }
        },
        rename: {
          method(from6, to, options3 = {}) {
            assert4(typeof from6 === "string" || from6 instanceof RegExp, "Rename missing the from argument");
            assert4(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
            assert4(to !== from6, "Cannot rename key to same name:", from6);
            Common.assertOptions(options3, [
              "alias",
              "ignoreUndefined",
              "override",
              "multiple"
            ]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              assert4(rename.from !== from6, "Cannot rename the same key multiple times");
            }
            if (to instanceof Template) {
              obj.$_mutateRegister(to);
            }
            obj.$_terms.renames.push({
              from: from6,
              to,
              options: applyToDefaults(internals.renameDefaults, options3)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({
              name: "schema",
              args: {
                type
              }
            });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", {
              type
            });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "with", key, peers, options3);
          }
        },
        without: {
          method(key, peers, options3 = {}) {
            return internals.dependency(this, "without", key, peers, options3);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options3) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options3);
        },
        isAsync() {
          if (this.$_terms.externals?.length) {
            return true;
          }
          if (this.$_terms.keys?.length) {
            for (const key of this.$_terms.keys) {
              if (key.schema.isAsync()) {
                return true;
              }
            }
          }
          if (this.$_terms.patterns?.length) {
            for (const pattern of this.$_terms.patterns) {
              if (pattern.rule.isAsync()) {
                return true;
              }
            }
          }
          return false;
        }
      },
      rebuild(schema) {
        if (schema.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, {
              after: child.schema.$_rootReferences(),
              group: child.key
            }), child.key);
          }
          schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.keys) {
            obj = obj.keys(desc.keys);
          }
          if (desc.dependencies) {
            for (const { rel, key = null, peers, options: options3 } of desc.dependencies) {
              obj = internals.dependency(obj, rel, key, peers, options3);
            }
          }
          if (desc.patterns) {
            for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
              obj = obj.pattern(regex || schema, rule, {
                fallthrough,
                matches
              });
            }
          }
          if (desc.renames) {
            for (const { from: from6, to, options: options3 } of desc.renames) {
              obj = obj.rename(from6, to, options3);
            }
          }
          return obj;
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
        "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
        "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
        "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, {
            shallow: true
          });
        }
        const clone3 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone3, value);
        return clone3;
      }
      const clone2 = function(...args) {
        return value.apply(this, args);
      };
      clone2.prototype = Clone(value.prototype);
      Object.defineProperty(clone2, "name", {
        value: value.name,
        writable: false
      });
      Object.defineProperty(clone2, "length", {
        value: value.length,
        writable: false
      });
      Object.assign(clone2, value);
      return clone2;
    };
    internals.dependency = function(schema, rel, key, peers, options3) {
      assert4(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options3) {
        options3 = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options3, [
        "separator",
        "isPresent"
      ]);
      peers = [].concat(peers);
      const separator = Common.default(options3.separator, ".");
      const paths = [];
      for (const peer of peers) {
        assert4(typeof peer === "string", rel, "peers must be strings");
        paths.push(Compile.ref(peer, {
          separator,
          ancestor: 0,
          prefix: false
        }));
      }
      if (key !== null) {
        key = Compile.ref(key, {
          separator,
          ancestor: 0,
          prefix: false
        });
      }
      const obj = schema.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options3));
      return obj;
    };
    internals.dependencies = {
      and(schema, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count = dep.peers.length;
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, {
            shadow: false
          })) === false) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count && present.length !== count) {
          return {
            code: "object.and",
            context: {
              present,
              presentWithLabels: internals.keysToLabels(schema, present),
              missing,
              missingWithLabels: internals.keysToLabels(schema, missing)
            }
          };
        }
      },
      nand(schema, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, {
            shadow: false
          }))) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            mainWithLabel: internals.keysToLabels(schema, main),
            peers: values,
            peersWithLabels: internals.keysToLabels(schema, values)
          }
        };
      },
      or(schema, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, {
            shadow: false
          }))) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths,
            peersWithLabels: internals.keysToLabels(schema, dep.paths)
          }
        };
      },
      oxor(schema, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, {
            shadow: false
          }))) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = {
          peers: dep.paths,
          peersWithLabels: internals.keysToLabels(schema, dep.paths)
        };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return {
          code: "object.oxor",
          context
        };
      },
      with(schema, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, {
            shadow: false
          })) === false) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema, peer.key)
              }
            };
          }
        }
      },
      without(schema, dep, value, state, prefs) {
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, {
            shadow: false
          }))) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema, peer.key)
              }
            };
          }
        }
      },
      xor(schema, dep, value, state, prefs) {
        const present = [];
        const isPresent = internals.isPresent(dep.options);
        for (const peer of dep.peers) {
          if (isPresent(peer.resolve(value, state, prefs, null, {
            shadow: false
          }))) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = {
          peers: dep.paths,
          peersWithLabels: internals.keysToLabels(schema, dep.paths)
        };
        if (present.length === 0) {
          return {
            code: "object.missing",
            context
          };
        }
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return {
          code: "object.xor",
          context
        };
      }
    };
    internals.keysToLabels = function(schema, keys) {
      if (Array.isArray(keys)) {
        return keys.map((key) => schema.$_mapLabels(key));
      }
      return schema.$_mapLabels(keys);
    };
    internals.isPresent = function(options3) {
      return typeof options3.isPresent === "function" ? options3.isPresent : (resolved) => resolved !== void 0;
    };
    internals.rename = function(schema, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from6 in value) {
            if (value[from6] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from6 === rename.to) {
              continue;
            }
            const match = rename.from.exec(from6);
            if (!match) {
              continue;
            }
            matches.push({
              from: from6,
              to: rename.to,
              match
            });
          }
        }
        for (const match of matches) {
          const from6 = match.from;
          let to = match.to;
          if (to instanceof Template) {
            to = to.render(value, state, prefs, match.match);
          }
          if (from6 === to) {
            continue;
          }
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema.$_createError("object.rename.multiple", value, {
              from: from6,
              to,
              pattern
            }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema.$_createError("object.rename.override", value, {
              from: from6,
              to,
              pattern
            }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from6] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from6];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from6];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
      if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [
          value,
          ...state.ancestors
        ];
        for (const key of unprocessed) {
          const item = value[key];
          const path = [
            ...state.path,
            key
          ];
          for (let i2 = 0; i2 < schema.$_terms.patterns.length; ++i2) {
            const pattern = schema.$_terms.patterns[i2];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              state.mainstay.tracer.debug(state, "rule", `pattern.${i2}`, match ? "pass" : "error");
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i2}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path, ancestors, {
              schema: pattern.rule,
              key
            });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: result.errors
                };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i2].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i2 = 0; i2 < matches.length; ++i2) {
            const match = matches[i2];
            if (!match) {
              continue;
            }
            const stpm = schema.$_terms.patterns[i2].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, {
                override: false
              });
              details.matches = match;
              const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return {
                  value,
                  errors: report
                };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && typeof schema._flags.unknown === "undefined" || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([
            ...state.path,
            unprocessedKey
          ], []);
          const report = schema.$_createError("object.unknown", value[unprocessedKey], {
            child: unprocessedKey
          }, localState, prefs, {
            flags: false
          });
          if (prefs.abortEarly) {
            return {
              value,
              errors: report
            };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths, options3) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
        this.options = options3;
      }
      describe() {
        const desc = {
          rel: this.rel,
          peers: this.paths
        };
        if (this.key !== null) {
          desc.key = this.key.key;
        }
        if (this.peers[0].separator !== ".") {
          desc.options = {
            ...desc.options,
            separator: this.peers[0].separator
          };
        }
        if (this.options.isPresent) {
          desc.options = {
            ...desc.options,
            isPresent: this.options.isPresent
          };
        }
        return desc;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < result.length; ++i2) {
          keys.set(result[i2].key, i2);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = {
              key,
              schema: result[pos].schema.concat(item.schema)
            };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/function.js
var require_function2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/function.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Keys = require_keys2();
    module2.exports = Keys.extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            assert4(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({
              name: "arity",
              args: {
                n
              }
            });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", {
              n
            });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", {
              value
            });
          }
        },
        minArity: {
          method(n) {
            assert4(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({
              name: "minArity",
              args: {
                n
              }
            });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", {
              n
            });
          }
        },
        maxArity: {
          method(n) {
            assert4(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({
              name: "maxArity",
              args: {
                n
              }
            });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", {
              n
            });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/link.js
var require_link2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/link.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var internals = {};
    module2.exports = Any.extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: {
          init: null,
          manifest: "single",
          register: false
        }
      },
      args(schema, ref) {
        return schema.ref(ref);
      },
      validate(value, { schema, state, prefs }) {
        assert4(schema.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema, value, state, prefs) {
        return internals.generate(schema, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            assert4(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            assert4(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            assert4(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [
              {
                ref
              }
            ];
            return obj;
          }
        },
        relative: {
          method(enabled3 = true) {
            return this.$_setFlag("relative", enabled3);
          }
        }
      },
      overrides: {
        concat(source) {
          assert4(this.$_terms.link, "Uninitialized link schema");
          assert4(Common.isSchema(source), "Invalid schema object");
          assert4(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({
            concat: source
          });
          return obj.$_mutateRebuild();
        }
      },
      manifest: {
        build(obj, desc) {
          assert4(desc.link, "Invalid link description missing link");
          return obj.ref(desc.link);
        }
      }
    });
    internals.generate = function(schema, value, state, prefs) {
      let linked = state.mainstay.links.get(schema);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema.$_terms.link[0].ref;
      const { perspective, path } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
      try {
        linked = path.length ? perspective.$_reach(path) : perspective;
      } catch {
        internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
      if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema, key } of state.schemas) {
          const id = schema._flags.id || key;
          if (id === ref.path[0]) {
            return {
              perspective: schema,
              path: ref.path.slice(1)
            };
          }
          if (schema.$_terms.shared) {
            for (const shared of schema.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return {
                  perspective: shared,
                  path: ref.path.slice(1)
                };
              }
            }
          }
        }
        return {
          perspective: null,
          path: null
        };
      }
      if (ref.ancestor === "root") {
        return {
          perspective: state.schemas[state.schemas.length - 1].schema,
          path: ref.path
        };
      }
      return {
        perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema,
        path: ref.path
      };
    };
    internals.assert = function(condition, message, ref, schema, state, prefs) {
      if (condition) {
        return;
      }
      assert4(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/number.js
var require_number2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/number.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
      exponentialPartRegex: /[eE][+-]?\d+$/,
      leadingSignAndZerosRegex: /^[+-]?(0*)?/,
      dotRegex: /\./,
      trailingZerosRegex: /0+$/,
      decimalPlaces(value) {
        const str = value.toString();
        const dindex = str.indexOf(".");
        const eindex = str.indexOf("e");
        return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));
      }
    };
    module2.exports = Any.extend({
      type: "number",
      flags: {
        unsafe: {
          default: false
        }
      },
      coerce: {
        from: "string",
        method(value, { schema, error: error40 }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = {
            value: parseFloat(value)
          };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema._flags.unsafe) {
            if (value.match(/e/i)) {
              if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
                result.errors = error40("number.unsafe");
                return result;
              }
            } else {
              const string4 = result.value.toString();
              if (string4.match(/e/i)) {
                return result;
              }
              if (string4 !== internals.normalizeDecimal(value)) {
                result.errors = error40("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema, error: error40, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return {
            value,
            errors: error40("number.infinity")
          };
        }
        if (!Common.isNumber(value)) {
          return {
            value,
            errors: error40("number.base")
          };
        }
        const result = {
          value
        };
        if (prefs.convert) {
          const rule = schema.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error40("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({
              name: "greater",
              method: "compare",
              args: {
                limit
              },
              operator: ">"
            });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({
              name: "less",
              method: "compare",
              args: {
                limit
              },
              operator: "<"
            });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "compare",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "compare",
              args: {
                limit
              },
              operator: ">="
            });
          }
        },
        multiple: {
          method(base4) {
            const baseDecimalPlace = typeof base4 === "number" ? internals.decimalPlaces(base4) : null;
            const pfactor = Math.pow(10, baseDecimalPlace);
            return this.$_addRule({
              name: "multiple",
              args: {
                base: base4,
                baseDecimalPlace,
                pfactor
              }
            });
          },
          validate(value, helpers, { base: base4, baseDecimalPlace, pfactor }, options3) {
            const valueDecimalPlace = internals.decimalPlaces(value);
            if (valueDecimalPlace > baseDecimalPlace) {
              return helpers.error("number.multiple", {
                multiple: options3.args.base,
                value
              });
            }
            return Math.round(pfactor * value) % Math.round(pfactor * base4) === 0 ? value : helpers.error("number.multiple", {
              multiple: options3.args.base,
              value
            });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            },
            "baseDecimalPlace",
            "pfactor"
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            assert4(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({
              name: "precision",
              args: {
                limit
              }
            });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", {
              limit,
              value
            });
          },
          convert: true
        },
        sign: {
          method(sign2) {
            assert4([
              "negative",
              "positive"
            ].includes(sign2), "Invalid sign", sign2);
            return this.$_addRule({
              name: "sign",
              args: {
                sign: sign2
              }
            });
          },
          validate(value, helpers, { sign: sign2 }) {
            if (sign2 === "negative" && value < 0 || sign2 === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign2}`);
          }
        },
        unsafe: {
          method(enabled3 = true) {
            assert4(typeof enabled3 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled3);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.extractSignificantDigits = function(value) {
      return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/object.js
var require_object2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/object.js"(exports2, module2) {
    "use strict";
    var Keys = require_keys2();
    module2.exports = Keys.extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});

// node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/errors.js
function errorCode(code3) {
  return {
    code: code3,
    error: errorCodes[code3]
  };
}
var errorCodes;
var init_errors = __esm({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/errors.js"() {
    errorCodes = {
      EMPTY_STRING: "Address must be a non-empty string",
      FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
      MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
      MISSING_AT_CHAR: "Address must contain one @ character",
      EMPTY_LOCAL: "Address local part cannot be empty",
      ADDRESS_TOO_LONG: "Address too long",
      LOCAL_TOO_LONG: "Address local part too long",
      EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
      INVALID_LOCAL_CHARS: "Address local part contains invalid character",
      DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
      DOMAIN_TOO_LONG: "Domain too long",
      DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
      DOMAIN_INVALID_CHARS: "Domain contains invalid character",
      DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
      DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
      DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
      DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
      DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
      DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
    };
  }
});

// node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/domain.js
import * as Url from "node:url";
function isTldsAllow(tlds) {
  return !!tlds.allow;
}
function analyzeDomain(domain2, options3 = {}) {
  if (!domain2) {
    return errorCode("DOMAIN_NON_EMPTY_STRING");
  }
  if (typeof domain2 !== "string") {
    throw new Error("Invalid input: domain must be a string");
  }
  if (domain2.length > 256) {
    return errorCode("DOMAIN_TOO_LONG");
  }
  const ascii = !NON_ASCII_RX.test(domain2);
  if (!ascii) {
    if (options3.allowUnicode === false) {
      return errorCode("DOMAIN_INVALID_UNICODE_CHARS");
    }
    domain2 = domain2.normalize("NFC");
  }
  if (DOMAIN_CONTROL_RX.test(domain2)) {
    return errorCode("DOMAIN_INVALID_CHARS");
  }
  domain2 = punycode(domain2);
  if (options3.allowFullyQualified && domain2[domain2.length - 1] === ".") {
    domain2 = domain2.slice(0, -1);
  }
  const minDomainSegments = options3.minDomainSegments || MIN_DOMAIN_SEGMENTS;
  const segments = domain2.split(".");
  if (segments.length < minDomainSegments) {
    return errorCode("DOMAIN_SEGMENTS_COUNT");
  }
  if (options3.maxDomainSegments) {
    if (segments.length > options3.maxDomainSegments) {
      return errorCode("DOMAIN_SEGMENTS_COUNT_MAX");
    }
  }
  const tlds = options3.tlds;
  if (tlds) {
    const tld = segments[segments.length - 1].toLowerCase();
    if (isTldsAllow(tlds)) {
      if (!tlds.allow.has(tld)) {
        return errorCode("DOMAIN_FORBIDDEN_TLDS");
      }
    } else if (tlds.deny.has(tld)) {
      return errorCode("DOMAIN_FORBIDDEN_TLDS");
    }
  }
  for (let i2 = 0; i2 < segments.length; ++i2) {
    const segment = segments[i2];
    if (!segment.length) {
      return errorCode("DOMAIN_EMPTY_SEGMENT");
    }
    if (segment.length > 63) {
      return errorCode("DOMAIN_LONG_SEGMENT");
    }
    if (i2 < segments.length - 1) {
      if (options3.allowUnderscore) {
        if (!DOMAIN_UNDERSCORE_SEGMENT_RX.test(segment)) {
          return errorCode("DOMAIN_INVALID_CHARS");
        }
      } else {
        if (!DOMAIN_SEGMENT_RX.test(segment)) {
          return errorCode("DOMAIN_INVALID_CHARS");
        }
      }
    } else {
      if (!TLD_SEGMENT_RX.test(segment)) {
        return errorCode("DOMAIN_INVALID_TLDS_CHARS");
      }
    }
  }
  return null;
}
function isDomainValid(domain2, options3) {
  return !analyzeDomain(domain2, options3);
}
function punycode(domain2) {
  if (domain2.includes("%")) {
    domain2 = domain2.replace(/%/g, "%25");
  }
  try {
    return new URL_IMPL(`http://${domain2}`).host;
  } catch (err) {
    return domain2;
  }
}
function validateDomainOptions(options3) {
  if (!options3) {
    return;
  }
  if (typeof options3.tlds !== "object") {
    throw new Error("Invalid options: tlds must be a boolean or an object");
  }
  if (isTldsAllow(options3.tlds)) {
    if (options3.tlds.allow instanceof Set === false) {
      throw new Error("Invalid options: tlds.allow must be a Set object or true");
    }
    if (options3.tlds.deny) {
      throw new Error("Invalid options: cannot specify both tlds.allow and tlds.deny lists");
    }
  } else {
    if (options3.tlds.deny instanceof Set === false) {
      throw new Error("Invalid options: tlds.deny must be a Set object");
    }
  }
}
var MIN_DOMAIN_SEGMENTS, NON_ASCII_RX, DOMAIN_CONTROL_RX, TLD_SEGMENT_RX, DOMAIN_SEGMENT_RX, DOMAIN_UNDERSCORE_SEGMENT_RX, URL_IMPL;
var init_domain = __esm({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/domain.js"() {
    init_errors();
    MIN_DOMAIN_SEGMENTS = 2;
    NON_ASCII_RX = /[^\x00-\x7f]/;
    DOMAIN_CONTROL_RX = /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/;
    TLD_SEGMENT_RX = /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    DOMAIN_SEGMENT_RX = /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    DOMAIN_UNDERSCORE_SEGMENT_RX = /^[a-zA-Z0-9_](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    URL_IMPL = Url.URL || URL;
  }
});

// node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/email.js
import * as Util from "node:util";
function analyzeEmail(email3, options3) {
  return validateEmail(email3, options3);
}
function isEmailValid(email3, options3) {
  return !validateEmail(email3, options3);
}
function validateEmail(email3, options3 = {}) {
  if (typeof email3 !== "string") {
    throw new Error("Invalid input: email must be a string");
  }
  if (!email3) {
    return errorCode("EMPTY_STRING");
  }
  const ascii = !NON_ASCII_RX2.test(email3);
  if (!ascii) {
    if (options3.allowUnicode === false) {
      return errorCode("FORBIDDEN_UNICODE");
    }
    email3 = email3.normalize("NFC");
  }
  const parts = email3.split("@");
  if (parts.length !== 2) {
    return parts.length > 2 ? errorCode("MULTIPLE_AT_CHAR") : errorCode("MISSING_AT_CHAR");
  }
  const [local, domain2] = parts;
  if (!local) {
    return errorCode("EMPTY_LOCAL");
  }
  if (!options3.ignoreLength) {
    if (email3.length > 254) {
      return errorCode("ADDRESS_TOO_LONG");
    }
    if (ENCODER_IMPL.encode(local).length > 64) {
      return errorCode("LOCAL_TOO_LONG");
    }
  }
  return validateLocal(local, ascii) || analyzeDomain(domain2, options3);
}
function validateLocal(local, ascii) {
  const segments = local.split(".");
  for (const segment of segments) {
    if (!segment.length) {
      return errorCode("EMPTY_LOCAL_SEGMENT");
    }
    if (ascii) {
      if (!ATEXT_RX.test(segment)) {
        return errorCode("INVALID_LOCAL_CHARS");
      }
      continue;
    }
    for (const char of segment) {
      if (ATEXT_RX.test(char)) {
        continue;
      }
      const binary = toBinary(char);
      if (!ATOM_RX.test(binary)) {
        return errorCode("INVALID_LOCAL_CHARS");
      }
    }
  }
  return null;
}
function toBinary(char) {
  return Array.from(ENCODER_IMPL.encode(char), (v2) => String.fromCharCode(v2)).join("");
}
var NON_ASCII_RX2, ENCODER_IMPL, ATEXT_RX, ATOM_RX;
var init_email = __esm({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/email.js"() {
    init_domain();
    init_errors();
    NON_ASCII_RX2 = /[^\x00-\x7f]/;
    ENCODER_IMPL = new (Util.TextEncoder || TextEncoder)();
    ATEXT_RX = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
    ATOM_RX = new RegExp([
      //  %xC2-DF UTF8-tail
      "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
      //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
      "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
      //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
      "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
    ].join("|"));
  }
});

// node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/index.mjs
var import_applyToDefaults, import_assert2, import_bench, import_block, import_clone, import_contain, import_deepEqual, import_assertError, import_escapeHeaderAttribute, import_escapeHtml, import_escapeJson, import_escapeRegex, import_flatten, import_ignore, import_intersect, import_isPromise, import_merge, import_once, import_reach, import_reachTemplate, import_stringify, import_wait;
var init_lib = __esm({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/index.mjs"() {
    import_applyToDefaults = __toESM(require_applyToDefaults(), 1);
    import_assert2 = __toESM(require_assert(), 1);
    import_bench = __toESM(require_bench(), 1);
    import_block = __toESM(require_block(), 1);
    import_clone = __toESM(require_clone(), 1);
    import_contain = __toESM(require_contain(), 1);
    import_deepEqual = __toESM(require_deepEqual(), 1);
    import_assertError = __toESM(require_assertError(), 1);
    import_escapeHeaderAttribute = __toESM(require_escapeHeaderAttribute(), 1);
    import_escapeHtml = __toESM(require_escapeHtml(), 1);
    import_escapeJson = __toESM(require_escapeJson(), 1);
    import_escapeRegex = __toESM(require_escapeRegex(), 1);
    import_flatten = __toESM(require_flatten(), 1);
    import_ignore = __toESM(require_ignore(), 1);
    import_intersect = __toESM(require_intersect(), 1);
    import_isPromise = __toESM(require_isPromise(), 1);
    import_merge = __toESM(require_merge(), 1);
    import_once = __toESM(require_once(), 1);
    import_reach = __toESM(require_reach(), 1);
    import_reachTemplate = __toESM(require_reachTemplate(), 1);
    import_stringify = __toESM(require_stringify(), 1);
    import_wait = __toESM(require_wait(), 1);
  }
});

// node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/uri.js
function generate() {
  const rfc39862 = {};
  const hexDigit = "\\dA-Fa-f";
  const hexDigitOnly = "[" + hexDigit + "]";
  const unreserved = "\\w-\\.~";
  const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
  const pctEncoded = "%" + hexDigit;
  const pchar = unreserved + pctEncoded + subDelims + ":@";
  const pcharOnly = "[" + pchar + "]";
  const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
  rfc39862.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
  const h16 = hexDigitOnly + "{1,4}";
  const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc39862.ipv4address + ")";
  const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
  const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
  const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
  const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
  const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
  const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
  const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
  const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
  const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
  rfc39862.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
  rfc39862.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
  rfc39862.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
  rfc39862.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
  rfc39862.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
  rfc39862.schemeRegex = new RegExp(rfc39862.scheme);
  const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
  const IPLiteral = "\\[(?:" + rfc39862.ipv6address + "|" + rfc39862.ipvFuture + ")\\]";
  const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
  const host = "(?:" + IPLiteral + "|" + rfc39862.ipv4address + "|" + regName + ")";
  const port = "\\d*";
  const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
  const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
  const segment = pcharOnly + "*";
  const segmentNz = pcharOnly + "+";
  const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
  const pathEmpty = "";
  const pathAbEmpty = "(?:\\/" + segment + ")*";
  const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
  const pathRootless = segmentNz + pathAbEmpty;
  const pathNoScheme = segmentNzNc + pathAbEmpty;
  const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
  rfc39862.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
  rfc39862.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
  rfc39862.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
  rfc39862.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
  rfc39862.query = "[" + pchar + "\\/\\?]*(?=#|$)";
  rfc39862.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
  rfc39862.fragment = "[" + pchar + "\\/\\?]*";
  return rfc39862;
}
function createRegex(options3) {
  const rfc = rfc3986;
  const query = options3.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
  const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
  const relative6 = options3.domain ? rfc.relativeRefCapture : rfc.relativeRef;
  if (options3.relativeOnly) {
    return wrap(relative6 + suffix);
  }
  let customScheme = "";
  if (options3.scheme) {
    (0, import_assert2.default)(options3.scheme instanceof RegExp || typeof options3.scheme === "string" || Array.isArray(options3.scheme), "scheme must be a RegExp, String, or Array");
    const schemes = [].concat(options3.scheme);
    (0, import_assert2.default)(schemes.length >= 1, "scheme must have at least 1 scheme specified");
    const selections = [];
    for (let i2 = 0; i2 < schemes.length; ++i2) {
      const scheme2 = schemes[i2];
      (0, import_assert2.default)(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i2 + " must be a RegExp or String");
      if (scheme2 instanceof RegExp) {
        selections.push(scheme2.source.toString());
      } else {
        (0, import_assert2.default)(rfc.schemeRegex.test(scheme2), "scheme at position " + i2 + " must be a valid scheme");
        selections.push((0, import_escapeRegex.default)(scheme2));
      }
    }
    customScheme = selections.join("|");
  }
  const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
  const absolute = "(?:" + scheme + ":" + (options3.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
  const prefix = options3.allowRelative ? "(?:" + absolute + "|" + relative6 + ")" : absolute;
  return wrap(prefix + suffix, customScheme);
}
function wrap(raw, scheme = null) {
  raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
  return {
    raw,
    regex: new RegExp(`^${raw}$`),
    scheme
  };
}
function uriRegex(options3 = {}) {
  if (options3.scheme || options3.allowRelative || options3.relativeOnly || options3.allowQuerySquareBrackets || options3.domain) {
    return createRegex(options3);
  }
  return genericUriRegex;
}
var rfc3986, ipVersions, genericUriRegex;
var init_uri = __esm({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/uri.js"() {
    init_lib();
    rfc3986 = generate();
    ipVersions = {
      v4Cidr: rfc3986.ipv4Cidr,
      v6Cidr: rfc3986.ipv6Cidr,
      ipv4: rfc3986.ipv4address,
      ipv6: rfc3986.ipv6address,
      ipvfuture: rfc3986.ipvFuture
    };
    genericUriRegex = createRegex({});
  }
});

// node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/ip.js
function ipRegex(options3 = {}) {
  const cidr = options3.cidr || "optional";
  (0, import_assert2.default)([
    "required",
    "optional",
    "forbidden"
  ].includes(cidr), "options.cidr must be one of required, optional, forbidden");
  (0, import_assert2.default)(options3.version === void 0 || typeof options3.version === "string" || Array.isArray(options3.version), "options.version must be a string or an array of string");
  let versions = options3.version || [
    "ipv4",
    "ipv6",
    "ipvfuture"
  ];
  if (!Array.isArray(versions)) {
    versions = [
      versions
    ];
  }
  (0, import_assert2.default)(versions.length >= 1, "options.version must have at least 1 version specified");
  for (const version4 of versions) {
    (0, import_assert2.default)(typeof version4 === "string" && version4 === version4.toLowerCase(), "Invalid options.version value");
    (0, import_assert2.default)([
      "ipv4",
      "ipv6",
      "ipvfuture"
    ].includes(version4), "options.version contains unknown version " + version4 + " - must be one of ipv4, ipv6, ipvfuture");
  }
  versions = Array.from(new Set(versions));
  const parts = versions.map((version4) => {
    if (cidr === "forbidden") {
      return ipVersions[version4];
    }
    const cidrpart = `\\/${version4 === "ipv4" ? ipVersions.v4Cidr : ipVersions.v6Cidr}`;
    if (cidr === "required") {
      return `${ipVersions[version4]}${cidrpart}`;
    }
    return `${ipVersions[version4]}(?:${cidrpart})?`;
  });
  const raw = `(?:${parts.join("|")})`;
  const regex = new RegExp(`^${raw}$`);
  return {
    cidr,
    versions,
    regex,
    raw
  };
}
var init_ip = __esm({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/ip.js"() {
    init_lib();
    init_uri();
  }
});

// node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/decode.js
function uriDecode(string4) {
  let percentPos = string4.indexOf("%");
  if (percentPos === -1) {
    return string4;
  }
  let decoded = "";
  let last = 0;
  let codepoint = 0;
  let startOfOctets = percentPos;
  let state = UTF8.accept;
  while (percentPos > -1 && percentPos < string4.length) {
    const high = resolveHex(string4[percentPos + 1], 4);
    const low = resolveHex(string4[percentPos + 2], 0);
    const byte = high | low;
    const type = UTF8.data[byte];
    state = UTF8.data[256 + state + type];
    codepoint = codepoint << 6 | byte & UTF8.data[364 + type];
    if (state === UTF8.accept) {
      decoded += string4.slice(last, startOfOctets);
      decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
      codepoint = 0;
      last = percentPos + 3;
      percentPos = string4.indexOf("%", last);
      startOfOctets = percentPos;
      continue;
    }
    if (state === UTF8.reject) {
      return null;
    }
    percentPos += 3;
    if (percentPos >= string4.length || string4[percentPos] !== "%") {
      return null;
    }
  }
  return decoded + string4.slice(last);
}
function resolveHex(char, shift) {
  const i2 = HEX[char];
  return i2 === void 0 ? 255 : i2 << shift;
}
var HEX, UTF8;
var init_decode = __esm({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/decode.js"() {
    HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    UTF8 = {
      accept: 12,
      reject: 0,
      data: [
        // Maps bytes to character to a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // Maps a state to a new state when adding a transition
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // Maps the current transition to a mask that needs to apply to the byte
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ]
    };
  }
});

// node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  analyzeDomain: () => analyzeDomain,
  analyzeEmail: () => analyzeEmail,
  errorCodes: () => errorCodes,
  ipRegex: () => ipRegex,
  isDomainValid: () => isDomainValid,
  isEmailValid: () => isEmailValid,
  uriDecode: () => uriDecode,
  uriRegex: () => uriRegex,
  validateDomainOptions: () => validateDomainOptions
});
var init_esm = __esm({
  "node_modules/.deno/@hapi+address@5.1.1/node_modules/@hapi/address/esm/index.js"() {
    init_domain();
    init_email();
    init_errors();
    init_ip();
    init_uri();
    init_decode();
  }
});

// node_modules/.deno/@hapi+tlds@1.1.3/node_modules/@hapi/tlds/dist/commonjs/tlds.js
var require_tlds = __commonJS({
  "node_modules/.deno/@hapi+tlds@1.1.3/node_modules/@hapi/tlds/dist/commonjs/tlds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TLDS = void 0;
    exports2.TLDS = [
      "AAA",
      "AARP",
      "ABB",
      "ABBOTT",
      "ABBVIE",
      "ABC",
      "ABLE",
      "ABOGADO",
      "ABUDHABI",
      "AC",
      "ACADEMY",
      "ACCENTURE",
      "ACCOUNTANT",
      "ACCOUNTANTS",
      "ACO",
      "ACTOR",
      "AD",
      "ADS",
      "ADULT",
      "AE",
      "AEG",
      "AERO",
      "AETNA",
      "AF",
      "AFL",
      "AFRICA",
      "AG",
      "AGAKHAN",
      "AGENCY",
      "AI",
      "AIG",
      "AIRBUS",
      "AIRFORCE",
      "AIRTEL",
      "AKDN",
      "AL",
      "ALIBABA",
      "ALIPAY",
      "ALLFINANZ",
      "ALLSTATE",
      "ALLY",
      "ALSACE",
      "ALSTOM",
      "AM",
      "AMAZON",
      "AMERICANEXPRESS",
      "AMERICANFAMILY",
      "AMEX",
      "AMFAM",
      "AMICA",
      "AMSTERDAM",
      "ANALYTICS",
      "ANDROID",
      "ANQUAN",
      "ANZ",
      "AO",
      "AOL",
      "APARTMENTS",
      "APP",
      "APPLE",
      "AQ",
      "AQUARELLE",
      "AR",
      "ARAB",
      "ARAMCO",
      "ARCHI",
      "ARMY",
      "ARPA",
      "ART",
      "ARTE",
      "AS",
      "ASDA",
      "ASIA",
      "ASSOCIATES",
      "AT",
      "ATHLETA",
      "ATTORNEY",
      "AU",
      "AUCTION",
      "AUDI",
      "AUDIBLE",
      "AUDIO",
      "AUSPOST",
      "AUTHOR",
      "AUTO",
      "AUTOS",
      "AW",
      "AWS",
      "AX",
      "AXA",
      "AZ",
      "AZURE",
      "BA",
      "BABY",
      "BAIDU",
      "BANAMEX",
      "BAND",
      "BANK",
      "BAR",
      "BARCELONA",
      "BARCLAYCARD",
      "BARCLAYS",
      "BAREFOOT",
      "BARGAINS",
      "BASEBALL",
      "BASKETBALL",
      "BAUHAUS",
      "BAYERN",
      "BB",
      "BBC",
      "BBT",
      "BBVA",
      "BCG",
      "BCN",
      "BD",
      "BE",
      "BEATS",
      "BEAUTY",
      "BEER",
      "BERLIN",
      "BEST",
      "BESTBUY",
      "BET",
      "BF",
      "BG",
      "BH",
      "BHARTI",
      "BI",
      "BIBLE",
      "BID",
      "BIKE",
      "BING",
      "BINGO",
      "BIO",
      "BIZ",
      "BJ",
      "BLACK",
      "BLACKFRIDAY",
      "BLOCKBUSTER",
      "BLOG",
      "BLOOMBERG",
      "BLUE",
      "BM",
      "BMS",
      "BMW",
      "BN",
      "BNPPARIBAS",
      "BO",
      "BOATS",
      "BOEHRINGER",
      "BOFA",
      "BOM",
      "BOND",
      "BOO",
      "BOOK",
      "BOOKING",
      "BOSCH",
      "BOSTIK",
      "BOSTON",
      "BOT",
      "BOUTIQUE",
      "BOX",
      "BR",
      "BRADESCO",
      "BRIDGESTONE",
      "BROADWAY",
      "BROKER",
      "BROTHER",
      "BRUSSELS",
      "BS",
      "BT",
      "BUILD",
      "BUILDERS",
      "BUSINESS",
      "BUY",
      "BUZZ",
      "BV",
      "BW",
      "BY",
      "BZ",
      "BZH",
      "CA",
      "CAB",
      "CAFE",
      "CAL",
      "CALL",
      "CALVINKLEIN",
      "CAM",
      "CAMERA",
      "CAMP",
      "CANON",
      "CAPETOWN",
      "CAPITAL",
      "CAPITALONE",
      "CAR",
      "CARAVAN",
      "CARDS",
      "CARE",
      "CAREER",
      "CAREERS",
      "CARS",
      "CASA",
      "CASE",
      "CASH",
      "CASINO",
      "CAT",
      "CATERING",
      "CATHOLIC",
      "CBA",
      "CBN",
      "CBRE",
      "CC",
      "CD",
      "CENTER",
      "CEO",
      "CERN",
      "CF",
      "CFA",
      "CFD",
      "CG",
      "CH",
      "CHANEL",
      "CHANNEL",
      "CHARITY",
      "CHASE",
      "CHAT",
      "CHEAP",
      "CHINTAI",
      "CHRISTMAS",
      "CHROME",
      "CHURCH",
      "CI",
      "CIPRIANI",
      "CIRCLE",
      "CISCO",
      "CITADEL",
      "CITI",
      "CITIC",
      "CITY",
      "CK",
      "CL",
      "CLAIMS",
      "CLEANING",
      "CLICK",
      "CLINIC",
      "CLINIQUE",
      "CLOTHING",
      "CLOUD",
      "CLUB",
      "CLUBMED",
      "CM",
      "CN",
      "CO",
      "COACH",
      "CODES",
      "COFFEE",
      "COLLEGE",
      "COLOGNE",
      "COM",
      "COMMBANK",
      "COMMUNITY",
      "COMPANY",
      "COMPARE",
      "COMPUTER",
      "COMSEC",
      "CONDOS",
      "CONSTRUCTION",
      "CONSULTING",
      "CONTACT",
      "CONTRACTORS",
      "COOKING",
      "COOL",
      "COOP",
      "CORSICA",
      "COUNTRY",
      "COUPON",
      "COUPONS",
      "COURSES",
      "CPA",
      "CR",
      "CREDIT",
      "CREDITCARD",
      "CREDITUNION",
      "CRICKET",
      "CROWN",
      "CRS",
      "CRUISE",
      "CRUISES",
      "CU",
      "CUISINELLA",
      "CV",
      "CW",
      "CX",
      "CY",
      "CYMRU",
      "CYOU",
      "CZ",
      "DAD",
      "DANCE",
      "DATA",
      "DATE",
      "DATING",
      "DATSUN",
      "DAY",
      "DCLK",
      "DDS",
      "DE",
      "DEAL",
      "DEALER",
      "DEALS",
      "DEGREE",
      "DELIVERY",
      "DELL",
      "DELOITTE",
      "DELTA",
      "DEMOCRAT",
      "DENTAL",
      "DENTIST",
      "DESI",
      "DESIGN",
      "DEV",
      "DHL",
      "DIAMONDS",
      "DIET",
      "DIGITAL",
      "DIRECT",
      "DIRECTORY",
      "DISCOUNT",
      "DISCOVER",
      "DISH",
      "DIY",
      "DJ",
      "DK",
      "DM",
      "DNP",
      "DO",
      "DOCS",
      "DOCTOR",
      "DOG",
      "DOMAINS",
      "DOT",
      "DOWNLOAD",
      "DRIVE",
      "DTV",
      "DUBAI",
      "DUNLOP",
      "DUPONT",
      "DURBAN",
      "DVAG",
      "DVR",
      "DZ",
      "EARTH",
      "EAT",
      "EC",
      "ECO",
      "EDEKA",
      "EDU",
      "EDUCATION",
      "EE",
      "EG",
      "EMAIL",
      "EMERCK",
      "ENERGY",
      "ENGINEER",
      "ENGINEERING",
      "ENTERPRISES",
      "EPSON",
      "EQUIPMENT",
      "ER",
      "ERICSSON",
      "ERNI",
      "ES",
      "ESQ",
      "ESTATE",
      "ET",
      "EU",
      "EUROVISION",
      "EUS",
      "EVENTS",
      "EXCHANGE",
      "EXPERT",
      "EXPOSED",
      "EXPRESS",
      "EXTRASPACE",
      "FAGE",
      "FAIL",
      "FAIRWINDS",
      "FAITH",
      "FAMILY",
      "FAN",
      "FANS",
      "FARM",
      "FARMERS",
      "FASHION",
      "FAST",
      "FEDEX",
      "FEEDBACK",
      "FERRARI",
      "FERRERO",
      "FI",
      "FIDELITY",
      "FIDO",
      "FILM",
      "FINAL",
      "FINANCE",
      "FINANCIAL",
      "FIRE",
      "FIRESTONE",
      "FIRMDALE",
      "FISH",
      "FISHING",
      "FIT",
      "FITNESS",
      "FJ",
      "FK",
      "FLICKR",
      "FLIGHTS",
      "FLIR",
      "FLORIST",
      "FLOWERS",
      "FLY",
      "FM",
      "FO",
      "FOO",
      "FOOD",
      "FOOTBALL",
      "FORD",
      "FOREX",
      "FORSALE",
      "FORUM",
      "FOUNDATION",
      "FOX",
      "FR",
      "FREE",
      "FRESENIUS",
      "FRL",
      "FROGANS",
      "FRONTIER",
      "FTR",
      "FUJITSU",
      "FUN",
      "FUND",
      "FURNITURE",
      "FUTBOL",
      "FYI",
      "GA",
      "GAL",
      "GALLERY",
      "GALLO",
      "GALLUP",
      "GAME",
      "GAMES",
      "GAP",
      "GARDEN",
      "GAY",
      "GB",
      "GBIZ",
      "GD",
      "GDN",
      "GE",
      "GEA",
      "GENT",
      "GENTING",
      "GEORGE",
      "GF",
      "GG",
      "GGEE",
      "GH",
      "GI",
      "GIFT",
      "GIFTS",
      "GIVES",
      "GIVING",
      "GL",
      "GLASS",
      "GLE",
      "GLOBAL",
      "GLOBO",
      "GM",
      "GMAIL",
      "GMBH",
      "GMO",
      "GMX",
      "GN",
      "GODADDY",
      "GOLD",
      "GOLDPOINT",
      "GOLF",
      "GOO",
      "GOODYEAR",
      "GOOG",
      "GOOGLE",
      "GOP",
      "GOT",
      "GOV",
      "GP",
      "GQ",
      "GR",
      "GRAINGER",
      "GRAPHICS",
      "GRATIS",
      "GREEN",
      "GRIPE",
      "GROCERY",
      "GROUP",
      "GS",
      "GT",
      "GU",
      "GUCCI",
      "GUGE",
      "GUIDE",
      "GUITARS",
      "GURU",
      "GW",
      "GY",
      "HAIR",
      "HAMBURG",
      "HANGOUT",
      "HAUS",
      "HBO",
      "HDFC",
      "HDFCBANK",
      "HEALTH",
      "HEALTHCARE",
      "HELP",
      "HELSINKI",
      "HERE",
      "HERMES",
      "HIPHOP",
      "HISAMITSU",
      "HITACHI",
      "HIV",
      "HK",
      "HKT",
      "HM",
      "HN",
      "HOCKEY",
      "HOLDINGS",
      "HOLIDAY",
      "HOMEDEPOT",
      "HOMEGOODS",
      "HOMES",
      "HOMESENSE",
      "HONDA",
      "HORSE",
      "HOSPITAL",
      "HOST",
      "HOSTING",
      "HOT",
      "HOTELS",
      "HOTMAIL",
      "HOUSE",
      "HOW",
      "HR",
      "HSBC",
      "HT",
      "HU",
      "HUGHES",
      "HYATT",
      "HYUNDAI",
      "IBM",
      "ICBC",
      "ICE",
      "ICU",
      "ID",
      "IE",
      "IEEE",
      "IFM",
      "IKANO",
      "IL",
      "IM",
      "IMAMAT",
      "IMDB",
      "IMMO",
      "IMMOBILIEN",
      "IN",
      "INC",
      "INDUSTRIES",
      "INFINITI",
      "INFO",
      "ING",
      "INK",
      "INSTITUTE",
      "INSURANCE",
      "INSURE",
      "INT",
      "INTERNATIONAL",
      "INTUIT",
      "INVESTMENTS",
      "IO",
      "IPIRANGA",
      "IQ",
      "IR",
      "IRISH",
      "IS",
      "ISMAILI",
      "IST",
      "ISTANBUL",
      "IT",
      "ITAU",
      "ITV",
      "JAGUAR",
      "JAVA",
      "JCB",
      "JE",
      "JEEP",
      "JETZT",
      "JEWELRY",
      "JIO",
      "JLL",
      "JM",
      "JMP",
      "JNJ",
      "JO",
      "JOBS",
      "JOBURG",
      "JOT",
      "JOY",
      "JP",
      "JPMORGAN",
      "JPRS",
      "JUEGOS",
      "JUNIPER",
      "KAUFEN",
      "KDDI",
      "KE",
      "KERRYHOTELS",
      "KERRYPROPERTIES",
      "KFH",
      "KG",
      "KH",
      "KI",
      "KIA",
      "KIDS",
      "KIM",
      "KINDLE",
      "KITCHEN",
      "KIWI",
      "KM",
      "KN",
      "KOELN",
      "KOMATSU",
      "KOSHER",
      "KP",
      "KPMG",
      "KPN",
      "KR",
      "KRD",
      "KRED",
      "KUOKGROUP",
      "KW",
      "KY",
      "KYOTO",
      "KZ",
      "LA",
      "LACAIXA",
      "LAMBORGHINI",
      "LAMER",
      "LAND",
      "LANDROVER",
      "LANXESS",
      "LASALLE",
      "LAT",
      "LATINO",
      "LATROBE",
      "LAW",
      "LAWYER",
      "LB",
      "LC",
      "LDS",
      "LEASE",
      "LECLERC",
      "LEFRAK",
      "LEGAL",
      "LEGO",
      "LEXUS",
      "LGBT",
      "LI",
      "LIDL",
      "LIFE",
      "LIFEINSURANCE",
      "LIFESTYLE",
      "LIGHTING",
      "LIKE",
      "LILLY",
      "LIMITED",
      "LIMO",
      "LINCOLN",
      "LINK",
      "LIVE",
      "LIVING",
      "LK",
      "LLC",
      "LLP",
      "LOAN",
      "LOANS",
      "LOCKER",
      "LOCUS",
      "LOL",
      "LONDON",
      "LOTTE",
      "LOTTO",
      "LOVE",
      "LPL",
      "LPLFINANCIAL",
      "LR",
      "LS",
      "LT",
      "LTD",
      "LTDA",
      "LU",
      "LUNDBECK",
      "LUXE",
      "LUXURY",
      "LV",
      "LY",
      "MA",
      "MADRID",
      "MAIF",
      "MAISON",
      "MAKEUP",
      "MAN",
      "MANAGEMENT",
      "MANGO",
      "MAP",
      "MARKET",
      "MARKETING",
      "MARKETS",
      "MARRIOTT",
      "MARSHALLS",
      "MATTEL",
      "MBA",
      "MC",
      "MCKINSEY",
      "MD",
      "ME",
      "MED",
      "MEDIA",
      "MEET",
      "MELBOURNE",
      "MEME",
      "MEMORIAL",
      "MEN",
      "MENU",
      "MERCKMSD",
      "MG",
      "MH",
      "MIAMI",
      "MICROSOFT",
      "MIL",
      "MINI",
      "MINT",
      "MIT",
      "MITSUBISHI",
      "MK",
      "ML",
      "MLB",
      "MLS",
      "MM",
      "MMA",
      "MN",
      "MO",
      "MOBI",
      "MOBILE",
      "MODA",
      "MOE",
      "MOI",
      "MOM",
      "MONASH",
      "MONEY",
      "MONSTER",
      "MORMON",
      "MORTGAGE",
      "MOSCOW",
      "MOTO",
      "MOTORCYCLES",
      "MOV",
      "MOVIE",
      "MP",
      "MQ",
      "MR",
      "MS",
      "MSD",
      "MT",
      "MTN",
      "MTR",
      "MU",
      "MUSEUM",
      "MUSIC",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NAB",
      "NAGOYA",
      "NAME",
      "NAVY",
      "NBA",
      "NC",
      "NE",
      "NEC",
      "NET",
      "NETBANK",
      "NETFLIX",
      "NETWORK",
      "NEUSTAR",
      "NEW",
      "NEWS",
      "NEXT",
      "NEXTDIRECT",
      "NEXUS",
      "NF",
      "NFL",
      "NG",
      "NGO",
      "NHK",
      "NI",
      "NICO",
      "NIKE",
      "NIKON",
      "NINJA",
      "NISSAN",
      "NISSAY",
      "NL",
      "NO",
      "NOKIA",
      "NORTON",
      "NOW",
      "NOWRUZ",
      "NOWTV",
      "NP",
      "NR",
      "NRA",
      "NRW",
      "NTT",
      "NU",
      "NYC",
      "NZ",
      "OBI",
      "OBSERVER",
      "OFFICE",
      "OKINAWA",
      "OLAYAN",
      "OLAYANGROUP",
      "OLLO",
      "OM",
      "OMEGA",
      "ONE",
      "ONG",
      "ONL",
      "ONLINE",
      "OOO",
      "OPEN",
      "ORACLE",
      "ORANGE",
      "ORG",
      "ORGANIC",
      "ORIGINS",
      "OSAKA",
      "OTSUKA",
      "OTT",
      "OVH",
      "PA",
      "PAGE",
      "PANASONIC",
      "PARIS",
      "PARS",
      "PARTNERS",
      "PARTS",
      "PARTY",
      "PAY",
      "PCCW",
      "PE",
      "PET",
      "PF",
      "PFIZER",
      "PG",
      "PH",
      "PHARMACY",
      "PHD",
      "PHILIPS",
      "PHONE",
      "PHOTO",
      "PHOTOGRAPHY",
      "PHOTOS",
      "PHYSIO",
      "PICS",
      "PICTET",
      "PICTURES",
      "PID",
      "PIN",
      "PING",
      "PINK",
      "PIONEER",
      "PIZZA",
      "PK",
      "PL",
      "PLACE",
      "PLAY",
      "PLAYSTATION",
      "PLUMBING",
      "PLUS",
      "PM",
      "PN",
      "PNC",
      "POHL",
      "POKER",
      "POLITIE",
      "PORN",
      "POST",
      "PR",
      "PRAXI",
      "PRESS",
      "PRIME",
      "PRO",
      "PROD",
      "PRODUCTIONS",
      "PROF",
      "PROGRESSIVE",
      "PROMO",
      "PROPERTIES",
      "PROPERTY",
      "PROTECTION",
      "PRU",
      "PRUDENTIAL",
      "PS",
      "PT",
      "PUB",
      "PW",
      "PWC",
      "PY",
      "QA",
      "QPON",
      "QUEBEC",
      "QUEST",
      "RACING",
      "RADIO",
      "RE",
      "READ",
      "REALESTATE",
      "REALTOR",
      "REALTY",
      "RECIPES",
      "RED",
      "REDUMBRELLA",
      "REHAB",
      "REISE",
      "REISEN",
      "REIT",
      "RELIANCE",
      "REN",
      "RENT",
      "RENTALS",
      "REPAIR",
      "REPORT",
      "REPUBLICAN",
      "REST",
      "RESTAURANT",
      "REVIEW",
      "REVIEWS",
      "REXROTH",
      "RICH",
      "RICHARDLI",
      "RICOH",
      "RIL",
      "RIO",
      "RIP",
      "RO",
      "ROCKS",
      "RODEO",
      "ROGERS",
      "ROOM",
      "RS",
      "RSVP",
      "RU",
      "RUGBY",
      "RUHR",
      "RUN",
      "RW",
      "RWE",
      "RYUKYU",
      "SA",
      "SAARLAND",
      "SAFE",
      "SAFETY",
      "SAKURA",
      "SALE",
      "SALON",
      "SAMSCLUB",
      "SAMSUNG",
      "SANDVIK",
      "SANDVIKCOROMANT",
      "SANOFI",
      "SAP",
      "SARL",
      "SAS",
      "SAVE",
      "SAXO",
      "SB",
      "SBI",
      "SBS",
      "SC",
      "SCB",
      "SCHAEFFLER",
      "SCHMIDT",
      "SCHOLARSHIPS",
      "SCHOOL",
      "SCHULE",
      "SCHWARZ",
      "SCIENCE",
      "SCOT",
      "SD",
      "SE",
      "SEARCH",
      "SEAT",
      "SECURE",
      "SECURITY",
      "SEEK",
      "SELECT",
      "SENER",
      "SERVICES",
      "SEVEN",
      "SEW",
      "SEX",
      "SEXY",
      "SFR",
      "SG",
      "SH",
      "SHANGRILA",
      "SHARP",
      "SHELL",
      "SHIA",
      "SHIKSHA",
      "SHOES",
      "SHOP",
      "SHOPPING",
      "SHOUJI",
      "SHOW",
      "SI",
      "SILK",
      "SINA",
      "SINGLES",
      "SITE",
      "SJ",
      "SK",
      "SKI",
      "SKIN",
      "SKY",
      "SKYPE",
      "SL",
      "SLING",
      "SM",
      "SMART",
      "SMILE",
      "SN",
      "SNCF",
      "SO",
      "SOCCER",
      "SOCIAL",
      "SOFTBANK",
      "SOFTWARE",
      "SOHU",
      "SOLAR",
      "SOLUTIONS",
      "SONG",
      "SONY",
      "SOY",
      "SPA",
      "SPACE",
      "SPORT",
      "SPOT",
      "SR",
      "SRL",
      "SS",
      "ST",
      "STADA",
      "STAPLES",
      "STAR",
      "STATEBANK",
      "STATEFARM",
      "STC",
      "STCGROUP",
      "STOCKHOLM",
      "STORAGE",
      "STORE",
      "STREAM",
      "STUDIO",
      "STUDY",
      "STYLE",
      "SU",
      "SUCKS",
      "SUPPLIES",
      "SUPPLY",
      "SUPPORT",
      "SURF",
      "SURGERY",
      "SUZUKI",
      "SV",
      "SWATCH",
      "SWISS",
      "SX",
      "SY",
      "SYDNEY",
      "SYSTEMS",
      "SZ",
      "TAB",
      "TAIPEI",
      "TALK",
      "TAOBAO",
      "TARGET",
      "TATAMOTORS",
      "TATAR",
      "TATTOO",
      "TAX",
      "TAXI",
      "TC",
      "TCI",
      "TD",
      "TDK",
      "TEAM",
      "TECH",
      "TECHNOLOGY",
      "TEL",
      "TEMASEK",
      "TENNIS",
      "TEVA",
      "TF",
      "TG",
      "TH",
      "THD",
      "THEATER",
      "THEATRE",
      "TIAA",
      "TICKETS",
      "TIENDA",
      "TIPS",
      "TIRES",
      "TIROL",
      "TJ",
      "TJMAXX",
      "TJX",
      "TK",
      "TKMAXX",
      "TL",
      "TM",
      "TMALL",
      "TN",
      "TO",
      "TODAY",
      "TOKYO",
      "TOOLS",
      "TOP",
      "TORAY",
      "TOSHIBA",
      "TOTAL",
      "TOURS",
      "TOWN",
      "TOYOTA",
      "TOYS",
      "TR",
      "TRADE",
      "TRADING",
      "TRAINING",
      "TRAVEL",
      "TRAVELERS",
      "TRAVELERSINSURANCE",
      "TRUST",
      "TRV",
      "TT",
      "TUBE",
      "TUI",
      "TUNES",
      "TUSHU",
      "TV",
      "TVS",
      "TW",
      "TZ",
      "UA",
      "UBANK",
      "UBS",
      "UG",
      "UK",
      "UNICOM",
      "UNIVERSITY",
      "UNO",
      "UOL",
      "UPS",
      "US",
      "UY",
      "UZ",
      "VA",
      "VACATIONS",
      "VANA",
      "VANGUARD",
      "VC",
      "VE",
      "VEGAS",
      "VENTURES",
      "VERISIGN",
      "VERSICHERUNG",
      "VET",
      "VG",
      "VI",
      "VIAJES",
      "VIDEO",
      "VIG",
      "VIKING",
      "VILLAS",
      "VIN",
      "VIP",
      "VIRGIN",
      "VISA",
      "VISION",
      "VIVA",
      "VIVO",
      "VLAANDEREN",
      "VN",
      "VODKA",
      "VOLVO",
      "VOTE",
      "VOTING",
      "VOTO",
      "VOYAGE",
      "VU",
      "WALES",
      "WALMART",
      "WALTER",
      "WANG",
      "WANGGOU",
      "WATCH",
      "WATCHES",
      "WEATHER",
      "WEATHERCHANNEL",
      "WEBCAM",
      "WEBER",
      "WEBSITE",
      "WED",
      "WEDDING",
      "WEIBO",
      "WEIR",
      "WF",
      "WHOSWHO",
      "WIEN",
      "WIKI",
      "WILLIAMHILL",
      "WIN",
      "WINDOWS",
      "WINE",
      "WINNERS",
      "WME",
      "WOLTERSKLUWER",
      "WOODSIDE",
      "WORK",
      "WORKS",
      "WORLD",
      "WOW",
      "WS",
      "WTC",
      "WTF",
      "XBOX",
      "XEROX",
      "XIHUAN",
      "XIN",
      "XN--11B4C3D",
      "XN--1CK2E1B",
      "XN--1QQW23A",
      "XN--2SCRJ9C",
      "XN--30RR7Y",
      "XN--3BST00M",
      "XN--3DS443G",
      "XN--3E0B707E",
      "XN--3HCRJ9C",
      "XN--3PXU8K",
      "XN--42C2D9A",
      "XN--45BR5CYL",
      "XN--45BRJ9C",
      "XN--45Q11C",
      "XN--4DBRK0CE",
      "XN--4GBRIM",
      "XN--54B7FTA0CC",
      "XN--55QW42G",
      "XN--55QX5D",
      "XN--5SU34J936BGSG",
      "XN--5TZM5G",
      "XN--6FRZ82G",
      "XN--6QQ986B3XL",
      "XN--80ADXHKS",
      "XN--80AO21A",
      "XN--80AQECDR1A",
      "XN--80ASEHDB",
      "XN--80ASWG",
      "XN--8Y0A063A",
      "XN--90A3AC",
      "XN--90AE",
      "XN--90AIS",
      "XN--9DBQ2A",
      "XN--9ET52U",
      "XN--9KRT00A",
      "XN--B4W605FERD",
      "XN--BCK1B9A5DRE4C",
      "XN--C1AVG",
      "XN--C2BR7G",
      "XN--CCK2B3B",
      "XN--CCKWCXETD",
      "XN--CG4BKI",
      "XN--CLCHC0EA0B2G2A9GCD",
      "XN--CZR694B",
      "XN--CZRS0T",
      "XN--CZRU2D",
      "XN--D1ACJ3B",
      "XN--D1ALF",
      "XN--E1A4C",
      "XN--ECKVDTC9D",
      "XN--EFVY88H",
      "XN--FCT429K",
      "XN--FHBEI",
      "XN--FIQ228C5HS",
      "XN--FIQ64B",
      "XN--FIQS8S",
      "XN--FIQZ9S",
      "XN--FJQ720A",
      "XN--FLW351E",
      "XN--FPCRJ9C3D",
      "XN--FZC2C9E2C",
      "XN--FZYS8D69UVGM",
      "XN--G2XX48C",
      "XN--GCKR3F0F",
      "XN--GECRJ9C",
      "XN--GK3AT1E",
      "XN--H2BREG3EVE",
      "XN--H2BRJ9C",
      "XN--H2BRJ9C8C",
      "XN--HXT814E",
      "XN--I1B6B1A6A2E",
      "XN--IMR513N",
      "XN--IO0A7I",
      "XN--J1AEF",
      "XN--J1AMH",
      "XN--J6W193G",
      "XN--JLQ480N2RG",
      "XN--JVR189M",
      "XN--KCRX77D1X4A",
      "XN--KPRW13D",
      "XN--KPRY57D",
      "XN--KPUT3I",
      "XN--L1ACC",
      "XN--LGBBAT1AD8J",
      "XN--MGB9AWBF",
      "XN--MGBA3A3EJT",
      "XN--MGBA3A4F16A",
      "XN--MGBA7C0BBN0A",
      "XN--MGBAAM7A8H",
      "XN--MGBAB2BD",
      "XN--MGBAH1A3HJKRD",
      "XN--MGBAI9AZGQP6J",
      "XN--MGBAYH7GPA",
      "XN--MGBBH1A",
      "XN--MGBBH1A71E",
      "XN--MGBC0A9AZCG",
      "XN--MGBCA7DZDO",
      "XN--MGBCPQ6GPA1A",
      "XN--MGBERP4A5D4AR",
      "XN--MGBGU82A",
      "XN--MGBI4ECEXP",
      "XN--MGBPL2FH",
      "XN--MGBT3DHD",
      "XN--MGBTX2B",
      "XN--MGBX4CD0AB",
      "XN--MIX891F",
      "XN--MK1BU44C",
      "XN--MXTQ1M",
      "XN--NGBC5AZD",
      "XN--NGBE9E0A",
      "XN--NGBRX",
      "XN--NODE",
      "XN--NQV7F",
      "XN--NQV7FS00EMA",
      "XN--NYQY26A",
      "XN--O3CW4H",
      "XN--OGBPF8FL",
      "XN--OTU796D",
      "XN--P1ACF",
      "XN--P1AI",
      "XN--PGBS0DH",
      "XN--PSSY2U",
      "XN--Q7CE6A",
      "XN--Q9JYB4C",
      "XN--QCKA1PMC",
      "XN--QXA6A",
      "XN--QXAM",
      "XN--RHQV96G",
      "XN--ROVU88B",
      "XN--RVC1E0AM3E",
      "XN--S9BRJ9C",
      "XN--SES554G",
      "XN--T60B56A",
      "XN--TCKWE",
      "XN--TIQ49XQYJ",
      "XN--UNUP4Y",
      "XN--VERMGENSBERATER-CTB",
      "XN--VERMGENSBERATUNG-PWB",
      "XN--VHQUV",
      "XN--VUQ861B",
      "XN--W4R85EL8FHU5DNRA",
      "XN--W4RS40L",
      "XN--WGBH1C",
      "XN--WGBL6A",
      "XN--XHQ521B",
      "XN--XKC2AL3HYE2A",
      "XN--XKC2DL3A5EE0H",
      "XN--Y9A3AQ",
      "XN--YFRO4I67O",
      "XN--YGBI2AMMX",
      "XN--ZFR164B",
      "XXX",
      "XYZ",
      "YACHTS",
      "YAHOO",
      "YAMAXUN",
      "YANDEX",
      "YE",
      "YODOBASHI",
      "YOGA",
      "YOKOHAMA",
      "YOU",
      "YOUTUBE",
      "YT",
      "YUN",
      "ZA",
      "ZAPPOS",
      "ZARA",
      "ZERO",
      "ZIP",
      "ZM",
      "ZONE",
      "ZUERICH",
      "ZW"
    ];
  }
});

// node_modules/.deno/@hapi+tlds@1.1.3/node_modules/@hapi/tlds/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/.deno/@hapi+tlds@1.1.3/node_modules/@hapi/tlds/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.tlds = void 0;
    var tlds_js_1 = require_tlds();
    exports2.tlds = new Set(tlds_js_1.TLDS.map((tld) => tld.toLowerCase()));
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/string.js
var require_string2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/string.js"(exports2, module2) {
    "use strict";
    var { assert: assert4, escapeRegex: escapeRegex2 } = require_lib();
    var { isDomainValid: isDomainValid2, isEmailValid: isEmailValid2, ipRegex: ipRegex2, uriRegex: uriRegex2 } = (init_esm(), __toCommonJS(esm_exports));
    var Tlds = require_commonjs();
    var Any = require_any2();
    var Common = require_common2();
    var internals = {
      tlds: Tlds.tlds instanceof Set ? {
        tlds: {
          allow: Tlds.tlds,
          deny: null
        }
      } : false,
      base64Regex: {
        // paddingRequired
        true: {
          // urlSafe
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: {
        withPrefix: /^0x[0-9a-f]+$/i,
        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
        withoutPrefix: /^[0-9a-f]+$/i
      },
      ipRegex: ipRegex2({
        cidr: "forbidden"
      }).regex,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5",
        uuidv6: "6",
        uuidv7: "7",
        uuidv8: "8"
      },
      guidSeparators: /* @__PURE__ */ new Set([
        void 0,
        true,
        false,
        "-",
        ":"
      ]),
      normalizationForms: [
        "NFC",
        "NFD",
        "NFKC",
        "NFKD"
      ]
    };
    module2.exports = Any.extend({
      type: "string",
      flags: {
        insensitive: {
          default: false
        },
        truncate: {
          default: false
        }
      },
      terms: {
        replacements: {
          init: null
        }
      },
      coerce: {
        from: "string",
        method(value, { schema, state, prefs }) {
          const normalize7 = schema.$_getRule("normalize");
          if (normalize7) {
            value = value.normalize(normalize7.args.form);
          }
          const casing = schema.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema.$_terms.replacements) {
            for (const replacement of schema.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema._flags.truncate) {
            const rule = schema.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return {
                    value,
                    errors: schema.$_createError("any.ref", limit, {
                      ref: rule.args.limit,
                      arg: "limit",
                      reason: "must be a positive integer"
                    }, state, prefs)
                  };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return {
            value
          };
        }
      },
      validate(value, { schema, error: error40 }) {
        if (typeof value !== "string") {
          return {
            value,
            errors: error40("string.base")
          };
        }
        if (value === "") {
          const min = schema.$_getRule("min");
          if (min && min.args.limit === 0) {
            return;
          }
          return {
            value,
            errors: error40("string.empty")
          };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "paddingRequired",
              "urlSafe"
            ]);
            options3 = {
              urlSafe: false,
              paddingRequired: true,
              ...options3
            };
            assert4(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            assert4(typeof options3.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({
              name: "base64",
              args: {
                options: options3
              }
            });
          },
          validate(value, helpers, { options: options3 }) {
            const regex = internals.base64Regex[options3.paddingRequired][options3.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            assert4([
              "lower",
              "upper"
            ].includes(direction), "Invalid case:", direction);
            return this.$_addRule({
              name: "case",
              args: {
                direction
              }
            });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i2 = value.length;
            let sum = 0;
            let mul = 1;
            while (i2--) {
              const char = value.charAt(i2) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "paddingRequired"
            ]);
            options3 = {
              paddingRequired: true,
              ...options3
            };
            assert4(typeof options3.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({
              name: "dataUri",
              args: {
                options: options3
              }
            });
          },
          validate(value, helpers, { options: options3 }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options3.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        domain: {
          method(options3) {
            if (options3) {
              Common.assertOptions(options3, [
                "allowFullyQualified",
                "allowUnicode",
                "allowUnderscore",
                "maxDomainSegments",
                "minDomainSegments",
                "tlds"
              ]);
            }
            const address = internals.addressOptions(options3);
            return this.$_addRule({
              name: "domain",
              args: {
                options: options3
              },
              address
            });
          },
          validate(value, helpers, args, { address }) {
            if (isDomainValid2(value, address)) {
              return value;
            }
            return helpers.error("string.domain");
          }
        },
        email: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "allowFullyQualified",
              "allowUnicode",
              "ignoreLength",
              "maxDomainSegments",
              "minDomainSegments",
              "multiple",
              "separator",
              "tlds"
            ]);
            assert4(options3.multiple === void 0 || typeof options3.multiple === "boolean", "multiple option must be an boolean");
            const address = internals.addressOptions(options3);
            const regex = new RegExp(`\\s*[${options3.separator ? escapeRegex2(options3.separator) : ","}]\\s*`);
            return this.$_addRule({
              name: "email",
              args: {
                options: options3
              },
              regex,
              address
            });
          },
          validate(value, helpers, { options: options3 }, { regex, address }) {
            const emails = options3.multiple ? value.split(regex) : [
              value
            ];
            const invalids = [];
            for (const email3 of emails) {
              if (!isEmailValid2(email3, address)) {
                invalids.push(email3);
              }
            }
            if (!invalids.length) {
              return value;
            }
            return helpers.error("string.email", {
              value,
              invalids
            });
          }
        },
        guid: {
          alias: "uuid",
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "version",
              "separator",
              "wrapper"
            ]);
            assert4(options3.wrapper === void 0 || typeof options3.wrapper === "boolean" || typeof options3.wrapper === "string" && typeof internals.guidBrackets[options3.wrapper] === "string", `"wrapper" must be true, false, or one of "${Object.keys(internals.guidBrackets).filter(Boolean).join('", "')}"`);
            let versionNumbers = "";
            if (options3.version) {
              const versions = [].concat(options3.version);
              assert4(versions.length >= 1, "version must have at least 1 valid version specified");
              const set2 = /* @__PURE__ */ new Set();
              for (let i2 = 0; i2 < versions.length; ++i2) {
                const version4 = versions[i2];
                assert4(typeof version4 === "string", "version at position " + i2 + " must be a string");
                const versionNumber = internals.guidVersions[version4.toLowerCase()];
                assert4(versionNumber, "version at position " + i2 + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                assert4(!set2.has(versionNumber), "version at position " + i2 + " must not be a duplicate");
                versionNumbers += versionNumber;
                set2.add(versionNumber);
              }
            }
            assert4(internals.guidSeparators.has(options3.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options3.separator === void 0 ? "[:-]?" : options3.separator === true ? "[:-]" : options3.separator === false ? "[]?" : `\\${options3.separator}`;
            let wrapperStart;
            let wrapperEnd;
            if (options3.wrapper === void 0) {
              wrapperStart = "[\\[{\\(]?";
              wrapperEnd = "[\\]}\\)]?";
            } else if (options3.wrapper === true) {
              wrapperStart = "[\\[{\\(]";
              wrapperEnd = "[\\]}\\)]";
            } else if (options3.wrapper === false) {
              wrapperStart = "";
              wrapperEnd = "";
            } else {
              wrapperStart = escapeRegex2(options3.wrapper);
              wrapperEnd = escapeRegex2(internals.guidBrackets[options3.wrapper]);
            }
            const regex = new RegExp(`^(${wrapperStart})[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}(${wrapperEnd})$`, "i");
            return this.$_addRule({
              name: "guid",
              args: {
                options: options3
              },
              regex
            });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            const open = results[1];
            const close = results[results.length - 1];
            if ((open || close) && internals.guidBrackets[open] !== close) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "byteAligned",
              "prefix"
            ]);
            options3 = {
              byteAligned: false,
              prefix: false,
              ...options3
            };
            assert4(typeof options3.byteAligned === "boolean", "byteAligned must be boolean");
            assert4(typeof options3.prefix === "boolean" || options3.prefix === "optional", 'prefix must be boolean or "optional"');
            return this.$_addRule({
              name: "hex",
              args: {
                options: options3
              }
            });
          },
          validate(value, helpers, { options: options3 }) {
            const re = options3.prefix === "optional" ? internals.hexRegex.withOptionalPrefix : options3.prefix === true ? internals.hexRegex.withPrefix : internals.hexRegex.withoutPrefix;
            if (!re.test(value)) {
              return helpers.error("string.hex");
            }
            if (options3.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (isDomainValid2(value, {
              minDomainSegments: 1
            }) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        ip: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "cidr",
              "version"
            ]);
            const { cidr, versions, regex } = ipRegex2(options3);
            const version4 = options3.version ? versions : void 0;
            return this.$_addRule({
              name: "ip",
              args: {
                options: {
                  cidr,
                  version: version4
                }
              },
              regex
            });
          },
          validate(value, helpers, { options: options3 }, { regex }) {
            if (regex.test(value)) {
              return value;
            }
            if (options3.version) {
              return helpers.error("string.ipVersion", {
                value,
                cidr: options3.cidr,
                version: options3.version
              });
            }
            return helpers.error("string.ip", {
              value,
              cidr: options3.cidr
            });
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error: error40 }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error40("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length4 = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length4, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, {
              limit: args.limit,
              value,
              encoding
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: [
            "limit",
            "encoding"
          ]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: [
            "limit",
            "encoding"
          ]
        },
        normalize: {
          method(form = "NFC") {
            assert4(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({
              name: "normalize",
              args: {
                form
              }
            });
          },
          validate(value, { error: error40 }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error40("string.normalize", {
              value,
              form
            });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options3 = {}) {
            assert4(regex instanceof RegExp, "regex must be a RegExp");
            assert4(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options3 === "string") {
              options3 = {
                name: options3
              };
            }
            Common.assertOptions(options3, [
              "invert",
              "name"
            ]);
            const errorCode2 = [
              "string.pattern",
              options3.invert ? ".invert" : "",
              options3.name ? ".name" : ".base"
            ].join("");
            return this.$_addRule({
              name: "pattern",
              args: {
                regex,
                options: options3
              },
              errorCode: errorCode2
            });
          },
          validate(value, helpers, { regex, options: options3 }, { errorCode: errorCode2 }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options3.invert) {
              return value;
            }
            return helpers.error(errorCode2, {
              name: options3.name,
              regex,
              value
            });
          },
          args: [
            "regex",
            "options"
          ],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(escapeRegex2(pattern), "g");
            }
            assert4(pattern instanceof RegExp, "pattern must be a RegExp");
            assert4(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({
              pattern,
              replacement
            });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled3 = true) {
            assert4(typeof enabled3 === "boolean", "enabled must be a boolean");
            return this.$_addRule({
              name: "trim",
              args: {
                enabled: enabled3
              }
            });
          },
          validate(value, helpers, { enabled: enabled3 }) {
            if (!enabled3 || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled3 = true) {
            assert4(typeof enabled3 === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled3);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        },
        uri: {
          method(options3 = {}) {
            Common.assertOptions(options3, [
              "allowRelative",
              "allowQuerySquareBrackets",
              "domain",
              "relativeOnly",
              "scheme",
              "encodeUri"
            ]);
            if (options3.domain) {
              Common.assertOptions(options3.domain, [
                "allowFullyQualified",
                "allowUnicode",
                "maxDomainSegments",
                "minDomainSegments",
                "tlds"
              ]);
            }
            const { regex, scheme } = uriRegex2(options3);
            const domain2 = options3.domain ? internals.addressOptions(options3.domain) : null;
            return this.$_addRule({
              name: "uri",
              args: {
                options: options3
              },
              regex,
              domain: domain2,
              scheme
            });
          },
          validate(value, helpers, { options: options3 }, { regex, domain: domain2, scheme }) {
            if ([
              "http:/",
              "https:/"
            ].includes(value)) {
              return helpers.error("string.uri");
            }
            let match = regex.exec(value);
            if (!match && helpers.prefs.convert && options3.encodeUri) {
              const encoded = encodeURI(value);
              match = regex.exec(encoded);
              if (match) {
                value = encoded;
              }
            }
            if (match) {
              const matched = match[1] || match[2];
              if (domain2 && (!options3.allowRelative || matched) && !isDomainValid2(matched, domain2)) {
                return helpers.error("string.domain", {
                  value: matched
                });
              }
              return value;
            }
            if (options3.relativeOnly) {
              return helpers.error("string.uriRelativeOnly");
            }
            if (options3.scheme) {
              return helpers.error("string.uriCustomScheme", {
                scheme,
                value
              });
            }
            return helpers.error("string.uri");
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.replacements) {
            for (const { pattern, replacement } of desc.replacements) {
              obj = obj.replace(pattern, replacement);
            }
          }
          return obj;
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.domain": "{{#label}} must contain a valid domain name",
        "string.email": "{{#label}} must be a valid email",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
        "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uri": "{{#label}} must be a valid uri",
        "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
        "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.addressOptions = function(options3) {
      if (!options3) {
        return internals.tlds || options3;
      }
      assert4(options3.minDomainSegments === void 0 || Number.isSafeInteger(options3.minDomainSegments) && options3.minDomainSegments > 0, "minDomainSegments must be a positive integer");
      assert4(options3.maxDomainSegments === void 0 || Number.isSafeInteger(options3.maxDomainSegments) && options3.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
      if (options3.tlds === false) {
        return options3;
      }
      if (options3.tlds === true || options3.tlds === void 0) {
        assert4(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options3, internals.tlds);
      }
      assert4(typeof options3.tlds === "object", "tlds must be true, false, or an object");
      const deny = options3.tlds.deny;
      if (deny) {
        if (Array.isArray(deny)) {
          options3 = Object.assign({}, options3, {
            tlds: {
              deny: new Set(deny)
            }
          });
        }
        assert4(options3.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
        assert4(!options3.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
        internals.validateTlds(options3.tlds.deny, "tlds.deny");
        return options3;
      }
      const allow = options3.tlds.allow;
      if (!allow) {
        return {
          ...options3,
          tlds: false
        };
      }
      if (allow === true) {
        assert4(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options3, internals.tlds);
      }
      if (Array.isArray(allow)) {
        options3 = Object.assign({}, options3, {
          tlds: {
            allow: new Set(allow)
          }
        });
      }
      assert4(options3.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
      internals.validateTlds(options3.tlds.allow, "tlds.allow");
      return options3;
    };
    internals.validateTlds = function(set2, source) {
      for (const tld of set2) {
        assert4(isDomainValid2(tld, {
          minDomainSegments: 1,
          maxDomainSegments: 1
        }), `${source} must contain valid top level domain names`);
      }
    };
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      if (/.*T.*[+-]\d\d$/.test(value)) {
        value += "00";
      }
      const date5 = new Date(value);
      if (isNaN(date5.getTime())) {
        return null;
      }
      return date5.toISOString();
    };
    internals.length = function(schema, name, limit, operator, encoding) {
      assert4(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema.$_addRule({
        name,
        method: "length",
        args: {
          limit,
          encoding
        },
        operator
      });
    };
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/symbol.js
var require_symbol2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/symbol.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Any = require_any2();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module2.exports = Any.extend({
      type: "symbol",
      terms: {
        map: {
          init: new internals.Map()
        }
      },
      coerce: {
        method(value, { schema, error: error40 }) {
          const lookup = schema.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema._flags.only || typeof value === "symbol") {
            return {
              value
            };
          }
          return {
            value,
            errors: error40("symbol.map", {
              map: schema.$_terms.map
            })
          };
        }
      },
      validate(value, { error: error40 }) {
        if (typeof value !== "symbol") {
          return {
            value,
            errors: error40("symbol.base")
          };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            assert4(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols2 = [];
            for (const entry of iterable) {
              assert4(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              assert4(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              assert4(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols2.push(value);
            }
            return obj.valid(...symbols2);
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.map) {
            obj = obj.map(desc.map);
          }
          return obj;
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/binary.js
var require_binary2 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/types/binary.js"(exports2, module2) {
    "use strict";
    var { assert: assert4 } = require_lib();
    var Any = require_any2();
    var Common = require_common2();
    module2.exports = Any.extend({
      type: "binary",
      coerce: {
        from: [
          "string",
          "object"
        ],
        method(value, { schema }) {
          if (typeof value === "string" || value !== null && value.type === "Buffer") {
            try {
              return {
                value: Buffer.from(value, schema._flags.encoding)
              };
            } catch {
            }
          }
        }
      },
      validate(value, { error: error40 }) {
        if (!Buffer.isBuffer(value)) {
          return {
            value,
            errors: error40("binary.base")
          };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            assert4(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({
              name: "length",
              method: "length",
              args: {
                limit
              },
              operator: "="
            });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, {
              limit: args.limit,
              value
            });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({
              name: "max",
              method: "length",
              args: {
                limit
              },
              operator: "<="
            });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({
              name: "min",
              method: "length",
              args: {
                limit
              },
              operator: ">="
            });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});

// node_modules/.deno/joi@18.0.1/node_modules/joi/lib/index.js
var require_lib32 = __commonJS({
  "node_modules/.deno/joi@18.0.1/node_modules/joi/lib/index.js"(exports2, module2) {
    "use strict";
    var { assert: assert4, clone: clone2 } = require_lib();
    var Cache = require_cache();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Extend = require_extend2();
    var Manifest = require_manifest();
    var Ref = require_ref2();
    var Template = require_template2();
    var Trace = require_trace();
    var Schemas;
    var internals = {
      types: {
        alternatives: require_alternatives2(),
        any: require_any2(),
        array: require_array2(),
        boolean: require_boolean2(),
        date: require_date2(),
        function: require_function2(),
        link: require_link2(),
        number: require_number2(),
        object: require_object2(),
        string: require_string2(),
        symbol: require_symbol2()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary2();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          assert4(!args.length || [
            "alternatives",
            "link",
            "object"
          ].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of [
        "allow",
        "custom",
        "disallow",
        "equal",
        "exist",
        "forbidden",
        "invalid",
        "not",
        "only",
        "optional",
        "options",
        "prefs",
        "preferences",
        "required",
        "strip",
        "valid",
        "when"
      ]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      root.x = root.expression;
      if (Trace.setup) {
        Trace.setup(root);
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      cache: Cache.provider,
      assert(value, schema, ...args) {
        internals.assert(value, schema, true, args);
      },
      attempt(value, schema, ...args) {
        return internals.assert(value, schema, false, args);
      },
      build(desc) {
        assert4(typeof Manifest.build === "function", "Manifest functionality disabled");
        return Manifest.build(this, desc);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema, options3) {
        return Compile.compile(this, schema, options3);
      },
      defaults(modifier) {
        assert4(typeof modifier === "function", "modifier must be a function");
        const joi = Object.assign({}, this);
        for (const type of joi._types) {
          const schema = modifier(joi[type]());
          assert4(Common.isSchema(schema), "modifier must return a valid schema object");
          joi[type] = function(...args) {
            return internals.generate(this, schema, args);
          };
        }
        return joi;
      },
      expression(...args) {
        return new Template(...args);
      },
      extend(...extensions) {
        Common.verifyFlat(extensions, "extend");
        Schemas = Schemas || require_schemas2();
        assert4(extensions.length, "You need to provide at least one extension");
        this.assert(extensions, Schemas.extensions);
        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);
        for (let extension of extensions) {
          if (typeof extension === "function") {
            extension = extension(joi);
          }
          this.assert(extension, Schemas.extension);
          const expanded = internals.expandExtension(extension, joi);
          for (const item of expanded) {
            assert4(joi[item.type] === void 0 || joi._types.has(item.type), "Cannot override name", item.type);
            const base4 = item.base || this.any();
            const schema = Extend.type(base4, item);
            joi._types.add(item.type);
            joi[item.type] = function(...args) {
              return internals.generate(this, schema, args);
            };
          }
        }
        return joi;
      },
      isError: Errors.ValidationError.isError,
      isExpression: Template.isTemplate,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      },
      types() {
        const types = {};
        for (const type of this._types) {
          types[type] = this[type]();
        }
        for (const target in internals.aliases) {
          types[target] = this[target]();
        }
        return types;
      }
    };
    internals.assert = function(value, schema, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options3 = message !== null ? args[1] : args[0];
      const result = schema.validate(value, Common.preferences({
        errors: {
          stack: true
        }
      }, options3 || {}));
      let error40 = result.error;
      if (!error40) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error40.annotate === "function" ? error40.annotate() : error40.message;
      if (error40 instanceof Errors.ValidationError === false) {
        error40 = clone2(error40);
      }
      error40.message = message ? `${message} ${display}` : display;
      throw error40;
    };
    internals.generate = function(root, schema, args) {
      assert4(root, "Must be invoked on a Joi instance.");
      schema.$_root = root;
      if (!schema._definition.args || !args.length) {
        return schema;
      }
      return schema._definition.args(schema, ...args);
    };
    internals.expandExtension = function(extension, joi) {
      if (typeof extension.type === "string") {
        return [
          extension
        ];
      }
      const extended = [];
      for (const type of joi._types) {
        if (extension.type.test(type)) {
          const item = Object.assign({}, extension);
          item.type = type;
          item.base = joi[type]();
          extended.push(item);
        }
      }
      return extended;
    };
    module2.exports = internals.root();
  }
});

// node_modules/.deno/lru-cache@7.18.3/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/.deno/lru-cache@7.18.3/node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort(reason = new Error("This operation was aborted")) {
        this.signal.reason = this.signal.reason || reason;
        this.signal.aborted = true;
        this.signal.dispatchEvent({
          type: "abort",
          target: this.signal
        });
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.reason = void 0;
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(e2) {
        if (e2.type === "abort") {
          this.aborted = true;
          this.onabort(e2);
          this._listeners.forEach((f) => f(e2), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code3 = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code3)) {
        warn(code3, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code3 = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code3)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code3, `${method} method`, `cache.${instead}()`, get2);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code3 = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code3)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code3, `${field} property`, `cache.${instead}`, get2);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code3) => !warned.has(code3);
    var warn = (code3, what, instead, fn) => {
      warned.add(code3);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code3, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options3 = {}) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, fetchContext, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options3;
        const { length: length4, maxAge, stale } = options3 instanceof _LRUCache ? {} : options3;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length4;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError("cannot set fetchContext without fetchMethod");
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code3 = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code3)) {
            warned.add(code3);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code3, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length4) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, {
          updateAgeOnHas: false
        }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        this.statusTTL = (status, index) => {
          if (status) {
            status.ttl = this.ttls[index];
            status.start = this.starts[index];
            status.now = cachedNow || getNow();
            status.remainingTTL = status.now + status.ttl - status.start;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(_index) {
      }
      statusTTL(_status, _index) {
      }
      setItemTTL(_index, _ttl, _start) {
      }
      isStale(_index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v2, size, sizeCalculation) => {
          if (this.isBackgroundFetch(v2)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v2, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.addItemSize = (index, size, status) => {
          this.sizes[index] = size;
          if (this.maxSize) {
            const maxSize = this.maxSize - this.sizes[index];
            while (this.calculatedSize > maxSize) {
              this.evict(true);
            }
          }
          this.calculatedSize += this.sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.calculatedSize;
          }
        };
      }
      removeItemSize(_index) {
      }
      addItemSize(_index, _size2) {
      }
      requireSize(_k, _v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.tail; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.head) {
              break;
            } else {
              i2 = this.prev[i2];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.head; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.tail) {
              break;
            } else {
              i2 = this.next[i2];
            }
          }
        }
      }
      isValidIndex(index) {
        return index !== void 0 && this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i2 of this.indexes()) {
          if (this.valList[i2] !== void 0 && this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield [
              this.keyList[i2],
              this.valList[i2]
            ];
          }
        }
      }
      *rentries() {
        for (const i2 of this.rindexes()) {
          if (this.valList[i2] !== void 0 && this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield [
              this.keyList[i2],
              this.valList[i2]
            ];
          }
        }
      }
      *keys() {
        for (const i2 of this.indexes()) {
          if (this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.keyList[i2];
          }
        }
      }
      *rkeys() {
        for (const i2 of this.rindexes()) {
          if (this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.keyList[i2];
          }
        }
      }
      *values() {
        for (const i2 of this.indexes()) {
          if (this.valList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.valList[i2];
          }
        }
      }
      *rvalues() {
        for (const i2 of this.rindexes()) {
          if (this.valList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
            yield this.valList[i2];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions) {
        for (const i2 of this.indexes()) {
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          if (fn(value, this.keyList[i2], this)) {
            return this.get(this.keyList[i2], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i2 of this.indexes()) {
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i2], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i2 of this.rindexes()) {
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i2], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i2 of this.rindexes({
          allowStale: true
        })) {
          if (this.isStale(i2)) {
            this.delete(this.keyList[i2]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i2 of this.indexes({
          allowStale: true
        })) {
          const key = this.keyList[i2];
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          if (value === void 0) continue;
          const entry = {
            value
          };
          if (this.ttls) {
            entry.ttl = this.ttls[i2];
            const age = perf.now() - this.starts[i2];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i2];
          }
          arr.unshift([
            key,
            entry
          ]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(_v, _k, _reason) {
      }
      set(k, v2, { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, status } = {}) {
        size = this.requireSize(k, v2, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v2;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size, status);
          if (status) {
            status.set = "add";
          }
          noUpdateTTL = false;
        } else {
          this.moveToTail(index);
          const oldVal = this.valList[index];
          if (v2 !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([
                    oldVal,
                    k,
                    "set"
                  ]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v2;
            this.addItemSize(index, size, status);
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0) status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        this.statusTTL(status, index);
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v2 = this.valList[head];
        if (this.isBackgroundFetch(v2)) {
          v2.__abortController.abort(new Error("evicted"));
        } else {
          this.dispose(v2, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([
              v2,
              k,
              "evict"
            ]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            if (status) status.has = "hit";
            this.statusTTL(status, index);
            return true;
          } else if (status) {
            status.has = "stale";
            this.statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v2 = this.valList[index];
          return this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
        }
      }
      backgroundFetch(k, index, options3, context) {
        const v2 = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v2)) {
          return v2;
        }
        const ac = new AC();
        if (options3.signal) {
          options3.signal.addEventListener("abort", () => ac.abort(options3.signal.reason));
        }
        const fetchOpts = {
          signal: ac.signal,
          options: options3,
          context
        };
        const cb = (v6, updateCache = false) => {
          const { aborted: aborted2 } = ac.signal;
          const ignoreAbort = options3.ignoreFetchAbort && v6 !== void 0;
          if (options3.status) {
            if (aborted2 && !updateCache) {
              options3.status.fetchAborted = true;
              options3.status.fetchError = ac.signal.reason;
              if (ignoreAbort) options3.status.fetchAbortIgnored = true;
            } else {
              options3.status.fetchResolved = true;
            }
          }
          if (aborted2 && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          if (this.valList[index] === p) {
            if (v6 === void 0) {
              if (p.__staleWhileFetching) {
                this.valList[index] = p.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              if (options3.status) options3.status.fetchUpdated = true;
              this.set(k, v6, fetchOpts.options);
            }
          }
          return v6;
        };
        const eb = (er) => {
          if (options3.status) {
            options3.status.fetchRejected = true;
            options3.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted: aborted2 } = ac.signal;
          const allowStaleAborted = aborted2 && options3.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options3.allowStaleOnFetchRejection;
          const noDelete = allowStale || options3.noDeleteOnFetchRejection;
          if (this.valList[index] === p) {
            const del = !noDelete || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options3.status && p.__staleWhileFetching !== void 0) {
              options3.status.returnedStale = true;
            }
            return p.__staleWhileFetching;
          } else if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          this.fetchMethod(k, v2, fetchOpts).then((v6) => res(v6), rej);
          ac.signal.addEventListener("abort", () => {
            if (!options3.ignoreFetchAbort || options3.allowStaleOnFetchAbort) {
              res();
              if (options3.allowStaleOnFetchAbort) {
                res = (v6) => cb(v6, true);
              }
            }
          });
        };
        if (options3.status) options3.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v2;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, {
            ...fetchOpts.options,
            status: void 0
          });
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        fetchContext = this.fetchContext,
        forceRefresh = false,
        status,
        signal
      } = {}) {
        if (!this.fetchMethod) {
          if (status) status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options3 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          if (status) status.fetch = "miss";
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          return p.__returned = p;
        } else {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            const stale = allowStale && v2.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale) status.returnedStale = true;
            }
            return stale ? v2.__staleWhileFetching : v2.__returned = v2;
          }
          const isStale = this.isStale(index);
          if (!forceRefresh && !isStale) {
            if (status) status.fetch = "hit";
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            this.statusTTL(status, index);
            return v2;
          }
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = hasStale && isStale ? "stale" : "refresh";
            if (staleVal && isStale) status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          this.statusTTL(status, index);
          if (this.isStale(index)) {
            if (status) status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status) status.returnedStale = allowStale;
              return allowStale ? value : void 0;
            } else {
              if (status) {
                status.returnedStale = allowStale && value.__staleWhileFetching !== void 0;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status) status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v2 = this.valList[index];
              if (this.isBackgroundFetch(v2)) {
                v2.__abortController.abort(new Error("deleted"));
              } else {
                this.dispose(v2, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([
                    v2,
                    k,
                    "delete"
                  ]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({
          allowStale: true
        })) {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.keyList[index];
            this.dispose(v2, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([
                v2,
                k,
                "delete"
              ]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/etag.js
var require_etag = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/etag.js"(exports2) {
    "use strict";
    var Crypto = __require("node:crypto");
    var Stream = __require("node:stream");
    var Util2 = __require("node:util");
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var LruCache = require_lru_cache();
    var internals = {
      pendings: /* @__PURE__ */ new Map(),
      streamEnd: Util2.promisify(Stream.finished)
    };
    internals.computeHashed = async function(response, stat) {
      const etags = response.request.server.plugins.inert._etags;
      if (!etags) {
        return null;
      }
      const path = response.source.path;
      const cachekey = [
        path,
        stat.ino,
        stat.size,
        stat.mtime.getTime()
      ].join("-");
      const cachedEtag = etags.get(cachekey);
      if (cachedEtag) {
        return cachedEtag;
      }
      let promise2 = internals.pendings.get(cachekey);
      if (promise2) {
        return await promise2;
      }
      const compute = async () => {
        try {
          const hash3 = await internals.hashFile(response);
          etags.set(cachekey, hash3);
          return hash3;
        } finally {
          internals.pendings.delete(cachekey);
        }
      };
      internals.pendings.set(cachekey, promise2 = compute());
      return await promise2;
    };
    internals.hashFile = async function(response) {
      const hash3 = Crypto.createHash("sha1");
      hash3.setEncoding("hex");
      const fileStream2 = response.source.file.createReadStream({
        autoClose: false
      });
      fileStream2.pipe(hash3);
      try {
        await internals.streamEnd(fileStream2);
        return hash3.read();
      } catch (err) {
        Bounce.rethrow(err, "system");
        throw Boom.boomify(err, {
          message: "Failed to hash file",
          data: {
            path: response.source.path
          }
        });
      }
    };
    internals.computeSimple = function(response, stat) {
      const size = stat.size.toString(16);
      const mtime = stat.mtime.getTime().toString(16);
      return size + "-" + mtime;
    };
    exports2.apply = async function(response, stat) {
      const etagMethod = response.source.settings.etagMethod;
      if (etagMethod === false) {
        return;
      }
      let etag;
      if (etagMethod === "simple") {
        etag = internals.computeSimple(response, stat);
      } else {
        etag = await internals.computeHashed(response, stat);
      }
      if (etag !== null) {
        response.etag(etag, {
          vary: true
        });
      }
    };
    exports2.Cache = LruCache;
  }
});

// node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/fs.js
var require_fs = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/fs.js"(exports2) {
    "use strict";
    var Fs = __require("node:fs");
    var Util2 = __require("node:util");
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var internals = {
      methods: {
        promised: [
          "open",
          "close",
          "fstat",
          "readdir"
        ],
        raw: [
          "createReadStream"
        ]
      },
      notFound: /* @__PURE__ */ new Set([
        "ENOENT",
        "ENOTDIR"
      ])
    };
    exports2.File = class {
      constructor(path) {
        this.path = path;
        this.fd = null;
      }
      async open(mode) {
        Hoek.assert(this.fd === null);
        try {
          this.fd = await exports2.open(this.path, mode);
        } catch (err) {
          const data = {
            path: this.path
          };
          if (this.path.indexOf("\0") !== -1 || internals.notFound.has(err.code)) {
            throw Boom.notFound(null, data);
          }
          if (err.code === "EACCES" || err.code === "EPERM") {
            data.code = err.code;
            throw Boom.forbidden(null, data);
          }
          throw Boom.boomify(err, {
            message: "Failed to open file",
            data
          });
        }
      }
      close() {
        if (this.fd !== null) {
          Bounce.background(exports2.close(this.fd));
          this.fd = null;
        }
      }
      async stat() {
        Hoek.assert(this.fd !== null);
        try {
          const stat = await exports2.fstat(this.fd);
          if (stat.isDirectory()) {
            throw Boom.forbidden(null, {
              code: "EISDIR",
              path: this.path
            });
          }
          return stat;
        } catch (err) {
          this.close(this.fd);
          Bounce.rethrow(err, [
            "boom",
            "system"
          ]);
          throw Boom.boomify(err, {
            message: "Failed to stat file",
            data: {
              path: this.path
            }
          });
        }
      }
      async openStat(mode) {
        await this.open(mode);
        return this.stat();
      }
      createReadStream(options3) {
        Hoek.assert(this.fd !== null);
        options3 = Object.assign({
          fd: this.fd,
          start: 0
        }, options3);
        const stream = exports2.createReadStream(this.path, options3);
        if (options3.autoClose !== false) {
          this.fd = null;
        }
        return stream;
      }
    };
    for (const method of internals.methods.raw) {
      exports2[method] = Fs[method].bind(Fs);
    }
    for (const method of internals.methods.promised) {
      exports2[method] = Util2.promisify(Fs[method]);
    }
  }
});

// node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/file.js
var require_file = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/file.js"(exports2) {
    "use strict";
    var Path = __require("node:path");
    var Ammo = require_lib27();
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var Etag = require_etag();
    var Fs = require_fs();
    var internals = {};
    internals.defaultMap = {
      gzip: ".gz"
    };
    internals.schema = Validate.alternatives([
      Validate.string(),
      Validate.func(),
      Validate.object({
        path: Validate.alternatives(Validate.string(), Validate.func()).required(),
        confine: Validate.alternatives(Validate.string(), Validate.boolean()).default(true),
        filename: Validate.string(),
        mode: Validate.string().valid("attachment", "inline").allow(false),
        lookupCompressed: Validate.boolean(),
        lookupMap: Validate.object().min(1).pattern(/.+/, Validate.string()),
        etagMethod: Validate.string().valid("hash", "simple").allow(false),
        start: Validate.number().integer().min(0).default(0),
        end: Validate.number().integer().min(Validate.ref("start"))
      }).with("filename", "mode")
    ]);
    exports2.handler = function(route, options3) {
      let settings = Validate.attempt(options3, internals.schema, "Invalid file handler options (" + route.path + ")");
      settings = typeof options3 !== "object" ? {
        path: options3,
        confine: "."
      } : settings;
      settings.confine = settings.confine === true ? "." : settings.confine;
      Hoek.assert(typeof settings.path !== "string" || settings.path[settings.path.length - 1] !== "/", "File path cannot end with a '/':", route.path);
      const handler = (request) => {
        const path = typeof settings.path === "function" ? settings.path(request) : settings.path;
        return exports2.response(path, settings, request);
      };
      return handler;
    };
    exports2.load = function(path, request, options3) {
      const response = exports2.response(path, options3, request, true);
      return internals.prepare(response);
    };
    exports2.response = function(path, options3, request, _preloaded) {
      Hoek.assert(!options3.mode || [
        "attachment",
        "inline"
      ].indexOf(options3.mode) !== -1, "options.mode must be either false, attachment, or inline");
      if (options3.confine) {
        const confineDir = Path.resolve(request.route.settings.files.relativeTo, options3.confine);
        path = Path.isAbsolute(path) ? Path.normalize(path) : Path.join(confineDir, path);
        if (path.lastIndexOf(confineDir, 0) !== 0) {
          path = null;
        }
      } else {
        path = Path.isAbsolute(path) ? Path.normalize(path) : Path.join(request.route.settings.files.relativeTo, path);
      }
      const source = {
        path,
        settings: options3,
        stat: null,
        file: null
      };
      const prepare = _preloaded ? null : internals.prepare;
      return request.generateResponse(source, {
        variety: "file",
        marshal: internals.marshal,
        prepare,
        close: internals.close
      });
    };
    internals.prepare = async function(response) {
      const { request, source } = response;
      const { settings, path } = source;
      if (path === null) {
        throw Boom.forbidden(null, {
          code: "EACCES"
        });
      }
      const file2 = source.file = new Fs.File(path);
      try {
        const stat = await file2.openStat("r");
        const start = settings.start ?? 0;
        if (settings.end !== void 0) {
          response.bytes(settings.end - start + 1);
        } else {
          response.bytes(stat.size - start);
        }
        if (!response.headers["content-type"]) {
          response.type(request.server.mime.path(path).type ?? "application/octet-stream");
        }
        response.header("last-modified", stat.mtime.toUTCString());
        if (settings.mode) {
          const fileName = settings.filename ?? Path.basename(path);
          response.header("content-disposition", settings.mode + "; filename=" + encodeURIComponent(fileName));
        }
        await Etag.apply(response, stat);
        return response;
      } catch (err) {
        internals.close(response);
        throw err;
      }
    };
    internals.marshal = async function(response) {
      const { request, source } = response;
      const { settings } = source;
      if (settings.lookupCompressed && !settings.start && settings.end === void 0 && request.server.settings.compression !== false) {
        const lookupMap = settings.lookupMap ?? internals.defaultMap;
        const encoding = request.info.acceptEncoding;
        const extension = lookupMap.hasOwnProperty(encoding) ? lookupMap[encoding] : null;
        if (extension) {
          const precompressed = new Fs.File(`${source.path}${extension}`);
          try {
            var stat = await precompressed.openStat("r");
          } catch (err) {
            precompressed.close();
            Bounce.ignore(err, "boom");
          }
          if (stat) {
            source.file.close();
            source.file = precompressed;
            response.bytes(stat.size);
            response.header("content-encoding", encoding);
            response.vary("accept-encoding");
          }
        }
      }
      return internals.createStream(response);
    };
    internals.addContentRange = function(response) {
      const { request } = response;
      let range = null;
      if (request.route.settings.response.ranges) {
        const length4 = response.headers["content-length"];
        if (request.headers.range && length4) {
          if (!request.headers["if-range"] || request.headers["if-range"] === response.headers.etag) {
            const mime = request.server.mime.type(response.headers["content-type"] || "application/octet-stream");
            const encoding = request.server.settings.compression && mime.compressible && !response.headers["content-encoding"] ? request.info.acceptEncoding : null;
            if (encoding === "identity" || !encoding) {
              const ranges = Ammo.header(request.headers.range, length4);
              if (!ranges) {
                const error40 = Boom.rangeNotSatisfiable();
                error40.output.headers["content-range"] = "bytes */" + length4;
                throw error40;
              }
              if (ranges.length === 1) {
                range = ranges[0];
                response.code(206);
                response.bytes(range.to - range.from + 1);
                response.header("content-range", "bytes " + range.from + "-" + range.to + "/" + length4);
              }
            }
          }
        }
        response.header("accept-ranges", "bytes");
      }
      return range;
    };
    internals.createStream = function(response) {
      const { settings, file: file2 } = response.source;
      Hoek.assert(file2 !== null);
      const range = internals.addContentRange(response);
      const options3 = {
        start: settings.start ?? 0,
        end: settings.end
      };
      if (range) {
        options3.end = range.to + options3.start;
        options3.start = range.from + options3.start;
      }
      return file2.createReadStream(options3);
    };
    internals.close = function(response) {
      const { source } = response;
      if (source.file !== null) {
        source.file.close();
        source.file = null;
      }
    };
  }
});

// node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/directory.js
var require_directory = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/directory.js"(exports2) {
    "use strict";
    var Path = __require("node:path");
    var Boom = require_lib6();
    var Bounce = require_lib7();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var File2 = require_file();
    var Fs = require_fs();
    var internals = {};
    internals.schema = Validate.object({
      path: Validate.alternatives(Validate.array().items(Validate.string()).single(), Validate.func()).required(),
      index: Validate.alternatives(Validate.boolean(), Validate.array().items(Validate.string()).single()).default(true),
      listing: Validate.boolean(),
      showHidden: Validate.boolean(),
      redirectToSlash: Validate.boolean(),
      lookupCompressed: Validate.boolean(),
      lookupMap: Validate.object().min(1).pattern(/.+/, Validate.string()),
      etagMethod: Validate.string().valid("hash", "simple").allow(false),
      defaultExtension: Validate.string().alphanum()
    });
    internals.resolvePathOption = function(result) {
      if (result instanceof Error) {
        throw result;
      }
      if (typeof result === "string") {
        return [
          result
        ];
      }
      if (Array.isArray(result)) {
        return result;
      }
      throw Boom.internal("Invalid path function");
    };
    exports2.handler = function(route, options3) {
      const settings = Validate.attempt(options3, internals.schema, "Invalid directory handler options (" + route.path + ")");
      Hoek.assert(route.path[route.path.length - 1] === "}", "The route path for a directory handler must end with a parameter:", route.path);
      const paramName = /\w+/.exec(route.path.slice(route.path.lastIndexOf("{")))[0];
      const basePath = route.settings.files.relativeTo;
      const normalized = Array.isArray(settings.path) ? settings.path : null;
      const indexNames = settings.index === true ? [
        "index.html"
      ] : settings.index || [];
      const handler = async (request, reply) => {
        const paths = normalized ?? internals.resolvePathOption(settings.path.call(null, request));
        const selection = request.params[paramName] ?? "";
        if (Path.isAbsolute(selection)) {
          throw Boom.notFound(null, {});
        }
        if (selection && !settings.showHidden && internals.isFileHidden(selection)) {
          throw Boom.notFound(null, {});
        }
        if (!selection && (request.server.settings.router.stripTrailingSlash || !request.path.endsWith("/"))) {
          request.path += "/";
        }
        const resource = request.path;
        const hasTrailingSlash = resource.endsWith("/");
        const fileOptions = {
          confine: null,
          lookupCompressed: settings.lookupCompressed,
          lookupMap: settings.lookupMap,
          etagMethod: settings.etagMethod
        };
        const each = async (baseDir) => {
          fileOptions.confine = baseDir;
          let path = selection;
          let error40;
          try {
            return await File2.load(path, request, fileOptions);
          } catch (err) {
            Bounce.ignore(err, "boom");
            error40 = err;
          }
          if (internals.isNotFound(error40)) {
            if (!settings.defaultExtension) {
              throw error40;
            }
            if (hasTrailingSlash) {
              path = path.slice(0, -1);
            }
            return await File2.load(path + "." + settings.defaultExtension, request, fileOptions);
          }
          if (internals.isDirectory(error40)) {
            if (settings.redirectToSlash !== false && // Defaults to true
            !request.server.settings.router.stripTrailingSlash && !hasTrailingSlash) {
              return reply.redirect(resource + "/");
            }
            for (const indexName of indexNames) {
              const indexFile = Path.join(path, indexName);
              try {
                return await File2.load(indexFile, request, fileOptions);
              } catch (err) {
                Bounce.ignore(err, "boom");
                if (!internals.isNotFound(err)) {
                  throw Boom.internal(indexName + " is a directory", err);
                }
              }
            }
            if (settings.listing) {
              return internals.generateListing(Path.join(basePath, baseDir, path), resource, selection, hasTrailingSlash, settings, request);
            }
          }
          throw error40;
        };
        for (let i2 = 0; i2 < paths.length; ++i2) {
          try {
            return await each(paths[i2]);
          } catch (err) {
            Bounce.ignore(err, "boom");
            if (!internals.isNotFound(err) || i2 === paths.length - 1) {
              throw err;
            }
          }
        }
        throw Boom.notFound(null, {});
      };
      return handler;
    };
    internals.generateListing = async function(path, resource, selection, hasTrailingSlash, settings, request) {
      let files;
      try {
        files = await Fs.readdir(path);
      } catch (err) {
        Bounce.rethrow(err, "system");
        throw Boom.internal("Error accessing directory", err);
      }
      resource = decodeURIComponent(resource);
      const display = Hoek.escapeHtml(resource);
      let html = "<html><head><title>" + display + "</title></head><body><h1>Directory: " + display + "</h1><ul>";
      if (selection) {
        const parent = resource.substring(0, resource.lastIndexOf("/", resource.length - (hasTrailingSlash ? 2 : 1))) + "/";
        html = html + '<li><a href="' + internals.pathEncode(parent) + '">Parent Directory</a></li>';
      }
      for (const file2 of files) {
        if (settings.showHidden || !internals.isFileHidden(file2)) {
          html = html + '<li><a href="' + internals.pathEncode(resource + (!hasTrailingSlash ? "/" : "") + file2) + '">' + Hoek.escapeHtml(file2) + "</a></li>";
        }
      }
      html = html + "</ul></body></html>";
      return request.generateResponse(html);
    };
    internals.isFileHidden = function(path) {
      return /(^|[\\\/])\.([^.\\\/]|\.[^\\\/])/.test(path);
    };
    internals.pathEncode = function(path) {
      return encodeURIComponent(path).replace(/%2F/g, "/").replace(/%5C/g, "\\");
    };
    internals.isNotFound = function(boom) {
      return boom.output.statusCode === 404;
    };
    internals.isDirectory = function(boom) {
      return boom.output.statusCode === 403 && boom.data.code === "EISDIR";
    };
  }
});

// node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/package.json
var require_package4 = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/package.json"(exports2, module2) {
    module2.exports = {
      name: "@hapi/inert",
      description: "Static file and directory handlers plugin for hapi.js",
      version: "7.1.0",
      repository: "https://github.com/hapijs/inert.git",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      files: [
        "lib"
      ],
      keywords: [
        "file",
        "directory",
        "handler",
        "hapi",
        "plugin"
      ],
      eslintConfig: {
        extends: [
          "plugin:@hapi/module"
        ]
      },
      dependencies: {
        "@hapi/ammo": "^6.0.1",
        "@hapi/boom": "^10.0.1",
        "@hapi/bounce": "^3.0.1",
        "@hapi/hoek": "^11.0.2",
        "@hapi/validate": "^2.0.1",
        "lru-cache": "^7.14.1"
      },
      devDependencies: {
        "@hapi/code": "^9.0.3",
        "@hapi/eslint-plugin": "*",
        "@hapi/file": "^3.0.0",
        "@hapi/hapi": "^21.3.0",
        "@hapi/lab": "^25.1.2",
        "@types/node": "^14.18.37",
        joi: "^17.8.3",
        typescript: "^4.9.5"
      },
      scripts: {
        test: "lab -f -a @hapi/code -t 100 -L -Y",
        "test-cov-html": "lab -f -a @hapi/code -r html -o coverage.html"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/index.js
var require_lib33 = __commonJS({
  "node_modules/.deno/@hapi+inert@7.1.0/node_modules/@hapi/inert/lib/index.js"(exports2) {
    "use strict";
    var Hoek = require_lib();
    var Validate = require_lib3();
    var Directory = require_directory();
    var Etag = require_etag();
    var File2 = require_file();
    var internals = {
      schema: Validate.object({
        etagsCacheMaxSize: Validate.number().integer().min(0).default(1e3)
      }).required()
    };
    internals.fileMethod = function(path, responseOptions = {}) {
      if (typeof responseOptions.confine === "undefined" || responseOptions.confine === true) {
        responseOptions.confine = ".";
      }
      Hoek.assert(responseOptions.end === void 0 || +responseOptions.start <= +responseOptions.end, "options.start must be less than or equal to options.end");
      return this.response(File2.response(path, responseOptions, this.request));
    };
    exports2.plugin = {
      pkg: require_package4(),
      once: true,
      requirements: {
        hapi: ">=20.0.0"
      },
      register(server, options3) {
        Hoek.assert(Object.keys(options3).length === 0, "Inert does not support registration options");
        const settings = Validate.attempt(server.settings.plugins?.inert ?? {}, internals.schema, 'Invalid "inert" server options');
        server.expose("_etags", settings.etagsCacheMaxSize > 0 ? new Etag.Cache({
          max: settings.etagsCacheMaxSize
        }) : null);
        server.decorate("handler", "file", File2.handler);
        server.decorate("handler", "directory", Directory.handler);
        server.decorate("toolkit", "file", internals.fileMethod);
      }
    };
  }
});

// node_modules/.deno/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/.deno/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [
        240,
        248,
        255
      ],
      "antiquewhite": [
        250,
        235,
        215
      ],
      "aqua": [
        0,
        255,
        255
      ],
      "aquamarine": [
        127,
        255,
        212
      ],
      "azure": [
        240,
        255,
        255
      ],
      "beige": [
        245,
        245,
        220
      ],
      "bisque": [
        255,
        228,
        196
      ],
      "black": [
        0,
        0,
        0
      ],
      "blanchedalmond": [
        255,
        235,
        205
      ],
      "blue": [
        0,
        0,
        255
      ],
      "blueviolet": [
        138,
        43,
        226
      ],
      "brown": [
        165,
        42,
        42
      ],
      "burlywood": [
        222,
        184,
        135
      ],
      "cadetblue": [
        95,
        158,
        160
      ],
      "chartreuse": [
        127,
        255,
        0
      ],
      "chocolate": [
        210,
        105,
        30
      ],
      "coral": [
        255,
        127,
        80
      ],
      "cornflowerblue": [
        100,
        149,
        237
      ],
      "cornsilk": [
        255,
        248,
        220
      ],
      "crimson": [
        220,
        20,
        60
      ],
      "cyan": [
        0,
        255,
        255
      ],
      "darkblue": [
        0,
        0,
        139
      ],
      "darkcyan": [
        0,
        139,
        139
      ],
      "darkgoldenrod": [
        184,
        134,
        11
      ],
      "darkgray": [
        169,
        169,
        169
      ],
      "darkgreen": [
        0,
        100,
        0
      ],
      "darkgrey": [
        169,
        169,
        169
      ],
      "darkkhaki": [
        189,
        183,
        107
      ],
      "darkmagenta": [
        139,
        0,
        139
      ],
      "darkolivegreen": [
        85,
        107,
        47
      ],
      "darkorange": [
        255,
        140,
        0
      ],
      "darkorchid": [
        153,
        50,
        204
      ],
      "darkred": [
        139,
        0,
        0
      ],
      "darksalmon": [
        233,
        150,
        122
      ],
      "darkseagreen": [
        143,
        188,
        143
      ],
      "darkslateblue": [
        72,
        61,
        139
      ],
      "darkslategray": [
        47,
        79,
        79
      ],
      "darkslategrey": [
        47,
        79,
        79
      ],
      "darkturquoise": [
        0,
        206,
        209
      ],
      "darkviolet": [
        148,
        0,
        211
      ],
      "deeppink": [
        255,
        20,
        147
      ],
      "deepskyblue": [
        0,
        191,
        255
      ],
      "dimgray": [
        105,
        105,
        105
      ],
      "dimgrey": [
        105,
        105,
        105
      ],
      "dodgerblue": [
        30,
        144,
        255
      ],
      "firebrick": [
        178,
        34,
        34
      ],
      "floralwhite": [
        255,
        250,
        240
      ],
      "forestgreen": [
        34,
        139,
        34
      ],
      "fuchsia": [
        255,
        0,
        255
      ],
      "gainsboro": [
        220,
        220,
        220
      ],
      "ghostwhite": [
        248,
        248,
        255
      ],
      "gold": [
        255,
        215,
        0
      ],
      "goldenrod": [
        218,
        165,
        32
      ],
      "gray": [
        128,
        128,
        128
      ],
      "green": [
        0,
        128,
        0
      ],
      "greenyellow": [
        173,
        255,
        47
      ],
      "grey": [
        128,
        128,
        128
      ],
      "honeydew": [
        240,
        255,
        240
      ],
      "hotpink": [
        255,
        105,
        180
      ],
      "indianred": [
        205,
        92,
        92
      ],
      "indigo": [
        75,
        0,
        130
      ],
      "ivory": [
        255,
        255,
        240
      ],
      "khaki": [
        240,
        230,
        140
      ],
      "lavender": [
        230,
        230,
        250
      ],
      "lavenderblush": [
        255,
        240,
        245
      ],
      "lawngreen": [
        124,
        252,
        0
      ],
      "lemonchiffon": [
        255,
        250,
        205
      ],
      "lightblue": [
        173,
        216,
        230
      ],
      "lightcoral": [
        240,
        128,
        128
      ],
      "lightcyan": [
        224,
        255,
        255
      ],
      "lightgoldenrodyellow": [
        250,
        250,
        210
      ],
      "lightgray": [
        211,
        211,
        211
      ],
      "lightgreen": [
        144,
        238,
        144
      ],
      "lightgrey": [
        211,
        211,
        211
      ],
      "lightpink": [
        255,
        182,
        193
      ],
      "lightsalmon": [
        255,
        160,
        122
      ],
      "lightseagreen": [
        32,
        178,
        170
      ],
      "lightskyblue": [
        135,
        206,
        250
      ],
      "lightslategray": [
        119,
        136,
        153
      ],
      "lightslategrey": [
        119,
        136,
        153
      ],
      "lightsteelblue": [
        176,
        196,
        222
      ],
      "lightyellow": [
        255,
        255,
        224
      ],
      "lime": [
        0,
        255,
        0
      ],
      "limegreen": [
        50,
        205,
        50
      ],
      "linen": [
        250,
        240,
        230
      ],
      "magenta": [
        255,
        0,
        255
      ],
      "maroon": [
        128,
        0,
        0
      ],
      "mediumaquamarine": [
        102,
        205,
        170
      ],
      "mediumblue": [
        0,
        0,
        205
      ],
      "mediumorchid": [
        186,
        85,
        211
      ],
      "mediumpurple": [
        147,
        112,
        219
      ],
      "mediumseagreen": [
        60,
        179,
        113
      ],
      "mediumslateblue": [
        123,
        104,
        238
      ],
      "mediumspringgreen": [
        0,
        250,
        154
      ],
      "mediumturquoise": [
        72,
        209,
        204
      ],
      "mediumvioletred": [
        199,
        21,
        133
      ],
      "midnightblue": [
        25,
        25,
        112
      ],
      "mintcream": [
        245,
        255,
        250
      ],
      "mistyrose": [
        255,
        228,
        225
      ],
      "moccasin": [
        255,
        228,
        181
      ],
      "navajowhite": [
        255,
        222,
        173
      ],
      "navy": [
        0,
        0,
        128
      ],
      "oldlace": [
        253,
        245,
        230
      ],
      "olive": [
        128,
        128,
        0
      ],
      "olivedrab": [
        107,
        142,
        35
      ],
      "orange": [
        255,
        165,
        0
      ],
      "orangered": [
        255,
        69,
        0
      ],
      "orchid": [
        218,
        112,
        214
      ],
      "palegoldenrod": [
        238,
        232,
        170
      ],
      "palegreen": [
        152,
        251,
        152
      ],
      "paleturquoise": [
        175,
        238,
        238
      ],
      "palevioletred": [
        219,
        112,
        147
      ],
      "papayawhip": [
        255,
        239,
        213
      ],
      "peachpuff": [
        255,
        218,
        185
      ],
      "peru": [
        205,
        133,
        63
      ],
      "pink": [
        255,
        192,
        203
      ],
      "plum": [
        221,
        160,
        221
      ],
      "powderblue": [
        176,
        224,
        230
      ],
      "purple": [
        128,
        0,
        128
      ],
      "rebeccapurple": [
        102,
        51,
        153
      ],
      "red": [
        255,
        0,
        0
      ],
      "rosybrown": [
        188,
        143,
        143
      ],
      "royalblue": [
        65,
        105,
        225
      ],
      "saddlebrown": [
        139,
        69,
        19
      ],
      "salmon": [
        250,
        128,
        114
      ],
      "sandybrown": [
        244,
        164,
        96
      ],
      "seagreen": [
        46,
        139,
        87
      ],
      "seashell": [
        255,
        245,
        238
      ],
      "sienna": [
        160,
        82,
        45
      ],
      "silver": [
        192,
        192,
        192
      ],
      "skyblue": [
        135,
        206,
        235
      ],
      "slateblue": [
        106,
        90,
        205
      ],
      "slategray": [
        112,
        128,
        144
      ],
      "slategrey": [
        112,
        128,
        144
      ],
      "snow": [
        255,
        250,
        250
      ],
      "springgreen": [
        0,
        255,
        127
      ],
      "steelblue": [
        70,
        130,
        180
      ],
      "tan": [
        210,
        180,
        140
      ],
      "teal": [
        0,
        128,
        128
      ],
      "thistle": [
        216,
        191,
        216
      ],
      "tomato": [
        255,
        99,
        71
      ],
      "turquoise": [
        64,
        224,
        208
      ],
      "violet": [
        238,
        130,
        238
      ],
      "wheat": [
        245,
        222,
        179
      ],
      "white": [
        255,
        255,
        255
      ],
      "whitesmoke": [
        245,
        245,
        245
      ],
      "yellow": [
        255,
        255,
        0
      ],
      "yellowgreen": [
        154,
        205,
        50
      ]
    };
  }
});

// node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: {
        channels: 3,
        labels: "rgb"
      },
      hsl: {
        channels: 3,
        labels: "hsl"
      },
      hsv: {
        channels: 3,
        labels: "hsv"
      },
      hwb: {
        channels: 3,
        labels: "hwb"
      },
      cmyk: {
        channels: 4,
        labels: "cmyk"
      },
      xyz: {
        channels: 3,
        labels: "xyz"
      },
      lab: {
        channels: 3,
        labels: "lab"
      },
      lch: {
        channels: 3,
        labels: "lch"
      },
      hex: {
        channels: 1,
        labels: [
          "hex"
        ]
      },
      keyword: {
        channels: 1,
        labels: [
          "keyword"
        ]
      },
      ansi16: {
        channels: 1,
        labels: [
          "ansi16"
        ]
      },
      ansi256: {
        channels: 1,
        labels: [
          "ansi256"
        ]
      },
      hcg: {
        channels: 3,
        labels: [
          "h",
          "c",
          "g"
        ]
      },
      apple: {
        channels: 3,
        labels: [
          "r16",
          "g16",
          "b16"
        ]
      },
      gray: {
        channels: 1,
        labels: [
          "gray"
        ]
      }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {
        value: channels
      });
      Object.defineProperty(convert[model], "labels", {
        value: labels
      });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g2, b);
      const max = Math.max(r, g2, b);
      const delta = max - min;
      let h2;
      let s;
      if (max === min) {
        h2 = 0;
      } else if (r === max) {
        h2 = (g2 - b) / delta;
      } else if (g2 === max) {
        h2 = 2 + (b - r) / delta;
      } else if (b === max) {
        h2 = 4 + (r - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [
        h2,
        s * 100,
        l * 100
      ];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s;
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v2 = Math.max(r, g2, b);
      const diff2 = v2 - Math.min(r, g2, b);
      const diffc = function(c) {
        return (v2 - c) / 6 / diff2 + 1 / 2;
      };
      if (diff2 === 0) {
        h2 = 0;
        s = 0;
      } else {
        s = diff2 / v2;
        rdif = diffc(r);
        gdif = diffc(g2);
        bdif = diffc(b);
        if (r === v2) {
          h2 = bdif - gdif;
        } else if (g2 === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s * 100,
        v2 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g2 = rgb[1];
      let b = rgb[2];
      const h2 = convert.rgb.hsl(rgb)[0];
      const w4 = 1 / 255 * Math.min(r, Math.min(g2, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g2, b));
      return [
        h2,
        w4 * 100,
        b * 100
      ];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g2, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m3 = (1 - g2 - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [
        c * 100,
        m3 * 100,
        y * 100,
        k * 100
      ];
    };
    function comparativeDistance(x3, y) {
      return (x3[0] - y[0]) ** 2 + (x3[1] - y[1]) ** 2 + (x3[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g2 = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x3 = r * 0.4124 + g2 * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g2 * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g2 * 0.1192 + b * 0.9505;
      return [
        x3 * 100,
        y * 100,
        z * 100
      ];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x3 = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x3 /= 95.047;
      y /= 100;
      z /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x3 - y);
      const b = 200 * (y - z);
      return [
        l,
        a,
        b
      ];
    };
    convert.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [
          val,
          val,
          val
        ];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [
        0,
        0,
        0
      ];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h2 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v2 = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [
        h2,
        sv * 100,
        v2 * 100
      ];
    };
    convert.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v2 = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f = h2 - Math.floor(h2);
      const p = 255 * v2 * (1 - s);
      const q = 255 * v2 * (1 - s * f);
      const t = 255 * v2 * (1 - s * (1 - f));
      v2 *= 255;
      switch (hi) {
        case 0:
          return [
            v2,
            t,
            p
          ];
        case 1:
          return [
            q,
            v2,
            p
          ];
        case 2:
          return [
            p,
            v2,
            t
          ];
        case 3:
          return [
            p,
            q,
            v2
          ];
        case 4:
          return [
            t,
            p,
            v2
          ];
        case 5:
          return [
            v2,
            p,
            q
          ];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const vmin = Math.max(v2, 0.01);
      let sl;
      let l;
      l = (2 - s) * v2;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [
        h2,
        sl * 100,
        l * 100
      ];
    };
    convert.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h2);
      const v2 = 1 - bl;
      f = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v2 - wh);
      let r;
      let g2;
      let b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r = v2;
          g2 = n;
          b = wh;
          break;
        case 1:
          r = n;
          g2 = v2;
          b = wh;
          break;
        case 2:
          r = wh;
          g2 = v2;
          b = n;
          break;
        case 3:
          r = wh;
          g2 = n;
          b = v2;
          break;
        case 4:
          r = n;
          g2 = wh;
          b = v2;
          break;
        case 5:
          r = v2;
          g2 = wh;
          b = n;
          break;
      }
      return [
        r * 255,
        g2 * 255,
        b * 255
      ];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g2 = 1 - Math.min(1, m3 * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [
        r * 255,
        g2 * 255,
        b * 255
      ];
    };
    convert.xyz.rgb = function(xyz) {
      const x3 = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g2;
      let b;
      r = x3 * 3.2406 + y * -1.5372 + z * -0.4986;
      g2 = x3 * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x3 * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b = Math.min(Math.max(0, b), 1);
      return [
        r * 255,
        g2 * 255,
        b * 255
      ];
    };
    convert.xyz.lab = function(xyz) {
      let x3 = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x3 /= 95.047;
      y /= 100;
      z /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x3 - y);
      const b = 200 * (y - z);
      return [
        l,
        a,
        b
      ];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x3;
      let y;
      let z;
      y = (l + 16) / 116;
      x3 = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x22 = x3 ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x3 = x22 > 8856e-6 ? x22 : (x3 - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x3 *= 95.047;
      y *= 100;
      z *= 108.883;
      return [
        x3,
        y,
        z
      ];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [
        l,
        c,
        h2
      ];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [
        l,
        a,
        b
      ];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g2, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g2 = args[1];
      const b = args[2];
      if (r === g2 && g2 === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [
          color,
          color,
          color
        ];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g2 = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [
        r,
        g2,
        b
      ];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [
          c,
          c,
          c
        ];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [
        r,
        g2,
        b
      ];
    };
    convert.rgb.hex = function(args) {
      const integer2 = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string4 = integer2.toString(16).toUpperCase();
      return "000000".substring(string4.length) + string4;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [
          0,
          0,
          0
        ];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer2 = parseInt(colorString, 16);
      const r = integer2 >> 16 & 255;
      const g2 = integer2 >> 8 & 255;
      const b = integer2 & 255;
      return [
        r,
        g2,
        b
      ];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g2), b);
      const min = Math.min(Math.min(r, g2), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g2 - b) / chroma % 6;
      } else if (max === g2) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g2) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [
        hue * 360,
        chroma * 100,
        grayscale * 100
      ];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [
        hsl[0],
        c * 100,
        f * 100
      ];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const c = s * v2;
      let f = 0;
      if (c < 1) {
        f = (v2 - c) / (1 - c);
      }
      return [
        hsv[0],
        c * 100,
        f * 100
      ];
    };
    convert.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      if (c === 0) {
        return [
          g2 * 255,
          g2 * 255,
          g2 * 255
        ];
      }
      const pure = [
        0,
        0,
        0
      ];
      const hi = h2 % 1 * 6;
      const v2 = hi % 1;
      const w4 = 1 - v2;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w4;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w4;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w4;
      }
      mg = (1 - c) * g2;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c + g2 * (1 - c);
      let f = 0;
      if (v2 > 0) {
        f = c / v2;
      }
      return [
        hcg[0],
        f * 100,
        v2 * 100
      ];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const l = g2 * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [
        hcg[0],
        s * 100,
        l * 100
      ];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c + g2 * (1 - c);
      return [
        hcg[0],
        (v2 - c) * 100,
        (1 - v2) * 100
      ];
    };
    convert.hwb.hcg = function(hwb) {
      const w4 = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v2 = 1 - b;
      const c = v2 - w4;
      let g2 = 0;
      if (c < 1) {
        g2 = (v2 - c) / (1 - c);
      }
      return [
        hwb[0],
        c * 100,
        g2 * 100
      ];
    };
    convert.apple.rgb = function(apple) {
      return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
      ];
    };
    convert.rgb.apple = function(rgb) {
      return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
      ];
    };
    convert.gray.rgb = function(args) {
      return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
      ];
    };
    convert.gray.hsl = function(args) {
      return [
        0,
        0,
        args[0]
      ];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray3) {
      return [
        0,
        100,
        gray3[0]
      ];
    };
    convert.gray.cmyk = function(gray3) {
      return [
        0,
        0,
        0,
        gray3[0]
      ];
    };
    convert.gray.lab = function(gray3) {
      return [
        gray3[0],
        0,
        0
      ];
    };
    convert.gray.hex = function(gray3) {
      const val = Math.round(gray3[0] / 100 * 255) & 255;
      const integer2 = (val << 16) + (val << 8) + val;
      const string4 = integer2.toString(16).toUpperCase();
      return "000000".substring(string4.length) + string4;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [
        val / 255 * 100
      ];
    };
  }
});

// node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [
        fromModel
      ];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from6, to) {
      return function(args) {
        return to(from6(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [
        graph[toModel].parent,
        toModel
      ];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        const toModel = models[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/.deno/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {
        value: conversions[fromModel].channels
      });
      Object.defineProperty(convert[fromModel], "labels", {
        value: conversions[fromModel].labels
      });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/.deno/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/.deno/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code3 = fn(...args);
      return `\x1B[${code3 + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code3 = fn(...args);
      return `\x1B[${38 + offset};5;${code3}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g2, b) => [
      r,
      g2,
      b
    ];
    var setLazyProperty = (object2, property, get2) => {
      Object.defineProperty(object2, property, {
        get: () => {
          const value = get2();
          Object.defineProperty(object2, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [
            0,
            0
          ],
          // 21 isn't widely supported and 22 does the same thing
          bold: [
            1,
            22
          ],
          dim: [
            2,
            22
          ],
          italic: [
            3,
            23
          ],
          underline: [
            4,
            24
          ],
          inverse: [
            7,
            27
          ],
          hidden: [
            8,
            28
          ],
          strikethrough: [
            9,
            29
          ]
        },
        color: {
          black: [
            30,
            39
          ],
          red: [
            31,
            39
          ],
          green: [
            32,
            39
          ],
          yellow: [
            33,
            39
          ],
          blue: [
            34,
            39
          ],
          magenta: [
            35,
            39
          ],
          cyan: [
            36,
            39
          ],
          white: [
            37,
            39
          ],
          // Bright color
          blackBright: [
            90,
            39
          ],
          redBright: [
            91,
            39
          ],
          greenBright: [
            92,
            39
          ],
          yellowBright: [
            93,
            39
          ],
          blueBright: [
            94,
            39
          ],
          magentaBright: [
            95,
            39
          ],
          cyanBright: [
            96,
            39
          ],
          whiteBright: [
            97,
            39
          ]
        },
        bgColor: {
          bgBlack: [
            40,
            49
          ],
          bgRed: [
            41,
            49
          ],
          bgGreen: [
            42,
            49
          ],
          bgYellow: [
            43,
            49
          ],
          bgBlue: [
            44,
            49
          ],
          bgMagenta: [
            45,
            49
          ],
          bgCyan: [
            46,
            49
          ],
          bgWhite: [
            47,
            49
          ],
          // Bright color
          bgBlackBright: [
            100,
            49
          ],
          bgRedBright: [
            101,
            49
          ],
          bgGreenBright: [
            102,
            49
          ],
          bgYellowBright: [
            103,
            49
          ],
          bgBlueBright: [
            104,
            49
          ],
          bgMagentaBright: [
            105,
            49
          ],
          bgCyanBright: [
            106,
            49
          ],
          bgWhiteBright: [
            107,
            49
          ]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/.deno/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.deno/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.deno/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.deno/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = __require("node:os");
    var tty = __require("node:tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if ([
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI",
          "GITHUB_ACTIONS",
          "BUILDKITE"
        ].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version4 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version4 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/util.js
var require_util2 = __commonJS({
  "node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string4, substring, replacer) => {
      let index = string4.indexOf(substring);
      if (index === -1) {
        return string4;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string4.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string4.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string4.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string4, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string4[index - 1] === "\r";
        returnValue += string4.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string4.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string4.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      [
        "n",
        "\n"
      ],
      [
        "r",
        "\r"
      ],
      [
        "t",
        "	"
      ],
      [
        "b",
        "\b"
      ],
      [
        "f",
        "\f"
      ],
      [
        "v",
        "\v"
      ],
      [
        "0",
        "\0"
      ],
      [
        "\\",
        "\\"
      ],
      [
        "e",
        "\x1B"
      ],
      [
        "a",
        "\x07"
      ]
    ]);
    function unescape3(c) {
      const u2 = c[0] === "u";
      const bracket = c[1] === "{";
      if (u2 && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u2 && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number4 = Number(chunk);
        if (!Number.isNaN(number4)) {
          results.push(number4);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m3, escape, character) => escape ? unescape3(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([
            name
          ].concat(args));
        } else {
          results.push([
            name
          ]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled3 = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled3[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled3)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m3, escapeCharacter, inverse2, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape3(escapeCharacter));
        } else if (style) {
          const string4 = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string4 : buildStyle(chalk, styles)(string4));
          styles.push({
            inverse: inverse2,
            styles: parseStyle(style)
          });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/.deno/chalk@4.1.0/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = require_util2();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object2, options3 = {}) => {
      if (options3.level && !(Number.isInteger(options3.level) && options3.level >= 0 && options3.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object2.level = options3.level === void 0 ? colorLevel : options3.level;
    };
    var ChalkClass = class {
      constructor(options3) {
        return chalkFactory(options3);
      }
    };
    var chalkFactory = (options3) => {
      const chalk2 = {};
      applyOptions(chalk2, options3);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options3) {
      return chalkFactory(options3);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, {
            value: builder
          });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {
          value: builder
        });
        return builder;
      }
    };
    var usedModels = [
      "rgb",
      "hex",
      "keyword",
      "hsl",
      "hsv",
      "hwb",
      "ansi",
      "ansi256"
    ];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto3 = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto3);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string4) => {
      if (self2.level <= 0 || !string4) {
        return self2._isEmpty ? "" : string4;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string4;
      }
      const { openAll, closeAll } = styler;
      if (string4.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string4 = stringReplaceAll(string4, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string4.indexOf("\n");
      if (lfIndex !== -1) {
        string4 = stringEncaseCRLFWithFirstIndex(string4, closeAll, openAll, lfIndex);
      }
      return openAll + string4 + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [
        firstString.raw[0]
      ];
      for (let i2 = 1; i2 < firstString.length; i2++) {
        parts.push(String(arguments_[i2 - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i2]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({
      level: stderrColor ? stderrColor.level : 0
    });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js"(exports2, module2) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js"(exports2, module2) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module2.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString2 } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString2.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports2, module2) {
    "use strict";
    module2.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString2 } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString2.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path = req.path;
        _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/index.js"(exports2, module2) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/caller.js"(exports2, module2) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module2.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js
var require_validator3 = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validator;
    function validator(opts = {}) {
      const { ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings", ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})` } = opts;
      return function validate2({ paths }) {
        paths.forEach((s) => {
          if (typeof s !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (//.test(s)) throw Error();
            const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr)) throw Error();
            if (/\/\*/.test(expr)) throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e2) {
            throw Error(ERR_INVALID_PATH(s));
          }
        });
      };
    }
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js"(exports2, module2) {
    "use strict";
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = parse10;
    function parse10({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o2, strPath, ix) {
        var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path = path.map((p) => {
          if (p[0] === "[") return p.substr(1, p.length - 2);
          else return p;
        });
        const star = path.indexOf("*");
        if (star > -1) {
          const before = path.slice(0, star);
          const beforeStr = before.join(".");
          const after = path.slice(star + 1, path.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o2[strPath] = {
            path,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o2;
      }, {});
      return {
        wildcards,
        wcLen,
        secret
      };
    }
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);
      redact.state = state;
      if (serialize === false) {
        redact.restore = (o2) => state.restore(o2);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0) existence += `o${delim}${path} != null`;
        else existence += ` && o${delim}${path} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null || typeof target === "string") return;
      const length4 = keys.length;
      for (var i2 = 0; i2 < length4; i2++) {
        const k = keys[i2];
        target[k] = values[i2];
      }
    }
    function groupRedact(o2, path, censor, isCensorFct, censorFctTakesPath) {
      const target = get2(o2, path);
      if (target == null || typeof target === "string") return {
        keys: null,
        values: null,
        target,
        flat: true
      };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path.length;
      const pathWithKey = censorFctTakesPath ? [
        ...path
      ] : void 0;
      const values = new Array(keysLength);
      for (var i2 = 0; i2 < keysLength; i2++) {
        const key = keys[i2];
        values[i2] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return {
        keys,
        values,
        target,
        flat: true
      };
    }
    function nestedRestore(instructions) {
      for (let i2 = 0; i2 < instructions.length; i2++) {
        const { target, path, value } = instructions[i2];
        let current = target;
        for (let i3 = path.length - 1; i3 > 0; i3--) {
          current = current[path[i3]];
        }
        current[path[0]] = value;
      }
    }
    function nestedRedact(store, o2, path, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get2(o2, path);
      if (target == null) return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i2 = 0; i2 < keysLength; i2++) {
        const key = keys[i2];
        specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has3(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o2, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i2 = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n = o2[k];
      if (typeof n !== "object") return;
      while (n != null && ++i2 < afterPathLen) {
        depth += 1;
        k = afterPath[i2];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i2 !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i2;
              ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, o2[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [
                  ...path,
                  originalKey,
                  ...afterPath
                ]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o2[originalKey]);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has3(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o2[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [
            ...path,
            originalKey,
            ...afterPath
          ]) : censor(ov) : censor;
          if (has3(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o2[originalKey]);
            store.push(rv);
            n[k] = nv;
          }
          n = n[k];
        }
        if (typeof n !== "object") break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get2(o2, p) {
      var i2 = -1;
      var l = p.length;
      var n = o2;
      while (n != null && ++i2 < l) {
        n = n[p[i2]];
      }
      return n;
    }
    function iterateNthLevel(wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [
            ...path,
            originalKey,
            ...afterPath
          ]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has3(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return {
        parent: null,
        key: null,
        children: [],
        depth: 0
      };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path = [];
      do {
        path.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return {
        path,
        value,
        target
      };
    }
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js"(exports2, module2) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer() {
      return function compileRestore() {
        if (this.restore) {
          this.restore.state.secret = this.secret;
          return;
        }
        const { secret, wcLen } = this;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? {
          secret,
          groupRestore,
          nestedRestore
        } : {
          secret
        };
        this.restore = Function("o", restoreTmpl(resetters, paths, hasWildcards)).bind(state);
        this.restore.state = state;
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path) => {
        const { circle, escPath, leadingBracket } = secret[path];
        const delim = leadingBracket ? "" : ".";
        const reset2 = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset2} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js
var require_state3 = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(o2) {
      const { secret, censor, compileRestore, serialize, groupRedact, nestedRedact, wildcards, wcLen } = o2;
      const builder = [
        {
          secret,
          censor,
          compileRestore
        }
      ];
      if (serialize !== false) builder.push({
        serialize
      });
      if (wcLen > 0) builder.push({
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      });
      return Object.assign(...builder);
    }
  }
});

// node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/index.js"(exports2, module2) {
    "use strict";
    var validator = require_validator3();
    var parse10 = require_parse();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state3();
    var rx = require_rx();
    var validate2 = validator();
    var noop = (o2) => o2;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0) return serialize || noop;
      validate2({
        paths,
        serialize,
        censor
      });
      const { wildcards, wcLen, secret } = parse10({
        paths,
        censor
      });
      const compileRestore = restorer();
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({
        secret,
        wcLen,
        serialize,
        strict,
        isCensorFct,
        censorFctTakesPath
      }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/symbols.js"(exports2, module2) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var levelCompSym = Symbol("pino.levelComp");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/redaction.js"(exports2, module2) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols2();
    var { rx, validator } = fastRedact;
    var validate2 = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o2, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o2[ns] = null;
          return o2;
        }
        if (o2[ns] === null) {
          return o2;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o2[ns] = o2[ns] || [];
        if (ns !== wildcardFirstSym && o2[ns].length === 0) {
          o2[ns].push(...o2[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o2).forEach(function(k) {
            if (o2[k]) {
              o2[k].push(nextPath);
            }
          });
        }
        o2[ns].push(nextPath);
        return o2;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({
          paths,
          censor,
          serialize,
          strict
        })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [
        ...Object.keys(shape),
        ...Object.getOwnPropertySymbols(shape)
      ].reduce((o2, k) => {
        if (shape[k] === null) {
          o2[k] = (value) => topCensor(value, [
            k
          ]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            return censor(value, [
              k,
              ...path
            ]);
          } : censor;
          o2[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o2;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = {
          paths: opts,
          censor: CENSOR
        };
        validate2(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      validate2({
        paths,
        censor
      });
      return {
        paths,
        censor
      };
    }
    module2.exports = redaction;
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/time.js
var require_time = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/time.js"(exports2, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = {
      nullTime,
      epochTime,
      unixTime,
      isoTime
    };
  }
});

// node_modules/.deno/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/.deno/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o2) {
      try {
        return JSON.stringify(o2);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module2.exports = format10;
    function format10(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0) return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i2 = 0; i2 < flen; ) {
        if (f.charCodeAt(i2) === 37 && i2 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i2 + 1)) {
            case 100:
            case 102:
              if (a >= argLen) break;
              if (args[a] == null) break;
              if (lastPos < i2) str += f.slice(lastPos, i2);
              str += Number(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 105:
              if (a >= argLen) break;
              if (args[a] == null) break;
              if (lastPos < i2) str += f.slice(lastPos, i2);
              str += Math.floor(Number(args[a]));
              lastPos = i2 + 2;
              i2++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen) break;
              if (args[a] === void 0) break;
              if (lastPos < i2) str += f.slice(lastPos, i2);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              str += ss(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 115:
              if (a >= argLen) break;
              if (lastPos < i2) str += f.slice(lastPos, i2);
              str += String(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 37:
              if (lastPos < i2) str += f.slice(lastPos, i2);
              str += "%";
              lastPos = i2 + 2;
              i2++;
              a--;
              break;
          }
          ++a;
        }
        ++i2;
      }
      if (lastPos === -1) return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/.deno/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "node_modules/.deno/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports2, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep;
    }
  }
});

// node_modules/.deno/sonic-boom@3.8.1/node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "node_modules/.deno/sonic-boom@3.8.1/node_modules/sonic-boom/index.js"(exports2, module2) {
    "use strict";
    var fs = __require("node:fs");
    var EventEmitter = __require("node:events");
    var inherits = __require("node:util").inherits;
    var path = __require("node:path");
    var sleep = require_atomic_sleep();
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    function openFile(file2, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file2;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs.mkdirSync(path.dirname(file2), {
            recursive: true
          });
          const fd = fs.openSync(file2, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs.mkdir(path.dirname(file2), {
          recursive: true
        }, (err) => {
          if (err) return fileOpened(err);
          fs.open(file2, flags, mode, fileOpened);
        });
      } else {
        fs.open(file2, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, sync, append = true, mkdir: mkdir3, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir3 || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n2 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
    }
    function releaseWritingBuf(writingBuf, len, n) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
      }
      len = Math.max(len - n, 0);
      writingBuf = writingBuf.slice(n);
      return {
        writingBuf,
        len
      };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([
          data
        ]);
        lens.push(data.length);
      } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          fs.fsync(this.fd, (err) => {
            this._flushPending = false;
            cb(err);
          });
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error40 = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error40);
          return;
        }
        throw error40;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error40 = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error40);
          return;
        }
        throw error40;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file2) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file2);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file2) {
        this.file = file2;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf2 = "";
      while (this._bufs.length || buf2) {
        if (buf2.length <= 0) {
          buf2 = this._bufs[0];
        }
        try {
          const n = fs.writeSync(this.fd, buf2, "utf8");
          const releasedBufObj = releaseWritingBuf(buf2, this._len, n);
          buf2 = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf2.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([
          this._writingBuf
        ]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf2 = kEmptyBuffer;
      while (this._bufs.length || buf2.length) {
        if (buf2.length <= 0) {
          buf2 = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n = fs.writeSync(this.fd, buf2);
          buf2 = buf2.subarray(n);
          this._len = Math.max(this._len - n, 0);
          if (buf2.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      fs.fsync(sonic.fd, closeWrapped);
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module2.exports = SonicBoom;
  }
});

// node_modules/.deno/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "node_modules/.deno/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js"(exports2, module2) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry2;
    function ensureRegistry() {
      if (registry2 === void 0) {
        registry2 = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry2 = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of [
        "exit",
        "beforeExit"
      ]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry2.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry2 === void 0) {
        return;
      }
      registry2.unregister(obj);
      for (const event of [
        "exit",
        "beforeExit"
      ]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module2.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/package.json
var require_package5 = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/package.json"(exports2, module2) {
    module2.exports = {
      name: "thread-stream",
      version: "2.7.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^3.0.0",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        test: 'standard && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/wait.js
var require_wait2 = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/wait.js"(exports2, module2) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check2 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index);
            if (current === prior) {
              check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check2(1);
    }
    function waitDiff(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check2 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check2(1);
    }
    module2.exports = {
      wait,
      waitDiff
    };
  }
});

// node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/indexes.js"(exports2, module2) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module2.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/index.js"(exports2, module2) {
    "use strict";
    var { version: version4 } = require_package5();
    var { EventEmitter } = __require("node:events");
    var { Worker } = __require("node:worker_threads");
    var { join: join7 } = __require("node:path");
    var { pathToFileURL } = __require("node:url");
    var { wait } = require_wait2();
    var { WRITE_INDEX, READ_INDEX } = require_indexes();
    var buffer = __require("node:buffer");
    var assert4 = __require("node:assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry2 = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join7(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version4
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry2.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert4(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code3) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry2.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code3 !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error40(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error40(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error40(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error40(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length4 = Buffer.byteLength(data);
      stream[kImpl].data.write(data, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length4);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module2.exports = ThreadStream;
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/transport.js"(exports2, module2) {
    "use strict";
    var { createRequire } = __require("node:module");
    var getCallers = require_caller();
    var { join: join7, isAbsolute: isAbsolute6, sep } = __require("node:path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, options: options3 = {}, worker = {}, caller = getCallers() } = fullOptions;
      const callers = typeof caller === "string" ? [
        caller
      ] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join7(__dirname, "worker.js");
        options3.targets = targets.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-pipeline-worker"] || join7(__dirname, "worker-pipeline.js");
        options3.targets = pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      }
      if (levels) {
        options3.levels = levels;
      }
      if (dedupe) {
        options3.dedupe = dedupe;
      }
      return buildStream(fixTarget(target), options3, worker);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute6(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join7(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module2.exports = transport;
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/tools.js"(exports2, module2) {
    "use strict";
    var format10 = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var { lsCacheSym, chindingsSym, writeSym, serializersSym, formatOptsSym, endSym, stringifiersSym, stringifySym, stringifySafeSym, wildcardFirstSym, nestedKeySym, formattersSym, messageKeySym, errorKeySym, nestedKeyStrSym, msgPrefixSym } = require_symbols2();
    var { isMainThread } = __require("node:worker_threads");
    var transport = require_transport();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o2, ...n) {
        if (typeof o2 === "object") {
          let msg = o2;
          if (o2 !== null) {
            if (o2.method && o2.headers && o2.socket) {
              o2 = mapHttpRequest(o2);
            } else if (typeof o2.setHeader === "function") {
              o2 = mapHttpResponse(o2);
            }
          }
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [
              null
            ];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o2, format10(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o2 === void 0 ? n.shift() : o2;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format10(msg, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i2 = 0; i2 < l && point >= 32; i2++) {
        point = str.charCodeAt(i2);
        if (point === 34 || point === 92) {
          result += str.slice(last, i2) + "\\";
          last = i2;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time3) {
      const stringify3 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters2 = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time3;
      data = data + chindings;
      let value;
      if (formatters2.log) {
        obj = formatters2.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify3)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify3)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify3 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify3)(value, stringifySafe);
          if (value === void 0) continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions3) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({
            dest: opts
          });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({
            dest: stream
          });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({
            caller,
            ...opts.transport,
            levels: customLevels
          });
        }
        opts = Object.assign({}, defaultOptions3, opts);
        opts.serializers = Object.assign({}, defaultOptions3.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions3.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled: enabled3, onChild } = opts;
        if (enabled3 === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({
              fd: process.stdout.fd || 1
            });
          } else {
            stream = process.stdout;
          }
        }
        return {
          opts,
          stream
        };
      };
    }
    function stringify2(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify3 = stringifySafeFn || this[stringifySafeSym];
          return stringify3(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module2.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify: stringify2,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/constants.js
var require_constants = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/constants.js"(exports2, module2) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module2.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/levels.js"(exports2, module2) {
    "use strict";
    var { lsCacheSym, levelValSym, useOnlyCustomLevelsSym, streamSym, formattersSym, hooksSym, levelCompSym } = require_symbols2();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e2) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o2, k) => {
      o2[DEFAULT_LEVELS[k]] = k;
      return o2;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o2, k) => {
      o2[k] = '{"level":' + Number(k);
      return o2;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache3 = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache3[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache3;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit("level-change", level, levelVal, labels[preLevelVal], preLevelVal, this);
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel2) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel2];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o2, k) => {
        o2[customLevels[k]] = k;
        return o2;
      }, {}) : null;
      const labels = Object.assign(Object.create(Object.prototype, {
        Infinity: {
          value: "silent"
        }
      }), useOnlyCustomLevels ? null : nums, customNums);
      const values = Object.assign(Object.create(Object.prototype, {
        silent: {
          value: Infinity
        }
      }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
      return {
        labels,
        values
      };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level), Infinity);
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(Object.create(Object.prototype, {
        silent: {
          value: Infinity
        }
      }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/meta.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      version: "8.19.0"
    };
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/proto.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = __require("node:events");
    var { lsCacheSym, levelValSym, setLevelSym, getLevelSym, chindingsSym, parsedChindingsSym, mixinSym, asJsonSym, writeSym, mixinMergeStrategySym, timeSym, timeSliceIndexSym, streamSym, serializersSym, formattersSym, errorKeySym, messageKeySym, useOnlyCustomLevelsSym, needsMetadataGsym, redactFmtSym, stringifySym, formatOptsSym, stringifiersSym, msgPrefixSym } = require_symbols2();
    var { getLevel, setLevel, isLevelEnabled, mappings, initialLsCache, genLsCache, assertNoLevelCollisions } = require_levels();
    var { asChindings, asJson, buildFormatters, stringify: stringify2 } = require_tools();
    var { version: version4 } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version: version4,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options3) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options3 = options3 || {};
      const serializers = this[serializersSym];
      const formatters2 = this[formattersSym];
      const instance = Object.create(this);
      if (options3.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i2 = 0; i2 < parentSymbols.length; i2++) {
          const ks = parentSymbols[i2];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options3.serializers) {
          instance[serializersSym][bk] = options3.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options3.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options3.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options3.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options3.formatters;
        instance[formattersSym] = buildFormatters(level || formatters2.level, chindings || resetChildingsFormatter, log || formatters2.log);
      } else {
        instance[formattersSym] = buildFormatters(formatters2.level, resetChildingsFormatter, formatters2.log);
      }
      if (options3.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options3.customLevels);
        instance.levels = mappings(options3.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options3.redact === "object" && options3.redact !== null || Array.isArray(options3.redact)) {
        instance.redact = options3.redact;
        const stringifiers = redaction(instance.redact, stringify2);
        const formatOpts = {
          stringify: stringifiers[redactFmtSym]
        };
        instance[stringifySym] = stringify2;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options3.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options3.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options3.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = {
          [errorKey]: _obj
        };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(s);
    }
    function noop() {
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});

// node_modules/.deno/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/.deno/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify2 = configure();
    stringify2.configure = configure;
    stringify2.stringify = stringify2;
    stringify2.default = stringify2;
    exports2.stringify = stringify2;
    exports2.configure = configure;
    module2.exports = stringify2;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array2, comparator) {
      if (array2.length > 200 || comparator) {
        return array2.sort(comparator);
      }
      for (let i2 = 1; i2 < array2.length; i2++) {
        const currentValue = array2[i2];
        let position = i2;
        while (position !== 0 && array2[position - 1] > currentValue) {
          array2[position] = array2[position - 1];
          position--;
        }
        array2[position] = currentValue;
      }
      return array2;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array2, separator, maximumBreadth) {
      if (array2.length < maximumBreadth) {
        maximumBreadth = array2.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array2[0]}`;
      for (let i2 = 1; i2 < maximumBreadth; i2++) {
        res += `${separator}"${i2}":${whitespace}${array2[i2]}`;
      }
      return res;
    }
    function getCircularValueOption(options3) {
      if (hasOwnProperty.call(options3, "circularValue")) {
        const circularValue = options3.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options3) {
      let value;
      if (hasOwnProperty.call(options3, "deterministic")) {
        value = options3.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options3, key) {
      let value;
      if (hasOwnProperty.call(options3, key)) {
        value = options3[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options3, key) {
      let value;
      if (hasOwnProperty.call(options3, key)) {
        value = options3[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number4) {
      if (number4 === 1) {
        return "1 item";
      }
      return `${number4} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options3) {
      if (hasOwnProperty.call(options3, "strict")) {
        const value = options3.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options3) {
      options3 = {
        ...options3
      };
      const fail = getStrictOption(options3);
      if (fail) {
        if (options3.bigint === void 0) {
          options3.bigint = false;
        }
        if (!("circularValue" in options3)) {
          options3.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options3);
      const bigint4 = getBooleanOption(options3, "bigint");
      const deterministic = getDeterministicOption(options3);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options3, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options3, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join7 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join7 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyFnReplacer(String(i2), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join7;
              }
              const tmp = stringifyFnReplacer(String(i2), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join7}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join7 = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join7;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join7;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint4) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join7 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join7 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyArrayReplacer(String(i2), value[i2], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join7;
              }
              const tmp = stringifyArrayReplacer(String(i2), value[i2], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join7}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join7 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join7;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint4) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join8 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyIndent(String(i2), value[i2], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join8;
              }
              const tmp = stringifyIndent(String(i2), value[i2], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join8}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join7 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join7, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join7;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join7;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join7;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint4) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifySimple(String(i2), value[i2], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i2), value[i2], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint4) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify3(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", {
                "": value
              }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify3;
    }
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/multistream.js"(exports2, module2) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || {
        dedupe: false
      };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i2) => {
          streamLevels[i2] = opts.levels[i2];
        });
      }
      const res = {
        write,
        add,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone: clone2,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i2 = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i2, streams.length, opts.dedupe); i2 = adjustLoopVar(i2, opts.dedupe)) {
          dest = streams[i2];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone2(level) {
        const streams = new Array(this.streams.length);
        for (let i2 = 0; i2 < streams.length; i2++) {
          streams[i2] = {
            level,
            stream: this.streams[i2].stream
          };
        }
        return {
          write,
          add,
          minLevel: level,
          streams,
          clone: clone2,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a, b) {
      return a.level - b.level;
    }
    function initLoopVar(length4, dedupe) {
      return dedupe ? length4 - 1 : 0;
    }
    function adjustLoopVar(i2, dedupe) {
      return dedupe ? i2 - 1 : i2 + 1;
    }
    function checkLoopVar(i2, length4, dedupe) {
      return dedupe ? i2 >= 0 : i2 < length4;
    }
    module2.exports = multistream;
  }
});

// node_modules/.deno/pino@8.19.0/node_modules/pino/pino.js
var require_pino = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/pino.js"(exports2, module2) {
    "use strict";
    var os = __require("node:os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time3 = require_time();
    var proto3 = require_proto();
    var symbols2 = require_symbols2();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var { createArgsNormalizer, asChindings, buildSafeSonicBoom, buildFormatters, stringify: stringify2, normalizeDestFileDescriptor, noop } = require_tools();
    var { version: version4 } = require_meta();
    var { chindingsSym, redactFmtSym, serializersSym, timeSym, timeSliceIndexSym, streamSym, stringifySym, stringifySafeSym, stringifiersSym, setLevelSym, endSym, formatOptsSym, messageKeySym, errorKeySym, nestedKeySym, mixinSym, levelCompSym, useOnlyCustomLevelsSym, formattersSym, hooksSym, nestedKeyStrSym, mixinMergeStrategySym, msgPrefixSym } = symbols2;
    var { epochTime, nullTime } = time3;
    var { pid } = process;
    var hostname2 = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions3 = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: {
        pid,
        hostname: hostname2
      },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number4) {
          return {
            level: number4
          };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize7 = createArgsNormalizer(defaultOptions3);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino(...args) {
      const instance = {};
      const { opts, stream } = normalize7(instance, caller(), ...args);
      const { redact, crlf, serializers: serializers2, timestamp, messageKey, errorKey, nestedKey, base: base4, name, level, customLevels, levelComparison, mixin, mixinMergeStrategy, useOnlyCustomLevels, formatters: formatters2, hooks, depthLimit, edgeLimit, onChild, msgPrefix } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(formatters2.level, formatters2.bindings, formatters2.log);
      const stringifyFn = stringify2.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? {
        stringify: stringifiers[redactFmtSym]
      } : {
        stringify: stringifyFn
      };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify2,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base4 !== null) {
        if (name === void 0) {
          chindings = coreChindings(base4);
        } else {
          chindings = coreChindings(Object.assign({}, base4, {
            name
          }));
        }
      }
      const time4 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time4().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time4,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify2,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto3());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module2.exports = pino;
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({
          dest: normalizeDestFileDescriptor(dest),
          minLength: 0
        });
      }
    };
    module2.exports.transport = require_transport();
    module2.exports.multistream = require_multistream();
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time3);
    module2.exports.symbols = symbols2;
    module2.exports.version = version4;
    module2.exports.default = pino;
    module2.exports.pino = pino;
  }
});

// node_modules/.deno/lru-cache@7.14.0/node_modules/lru-cache/index.js
var require_lru_cache2 = __commonJS({
  "node_modules/.deno/lru-cache@7.14.0/node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e2 = {
            type,
            target: this
          };
          this.onabort(e2);
          this._listeners.forEach((f) => f(e2), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code3 = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code3)) {
        warn(code3, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code3 = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code3)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code3, `${method} method`, `cache.${instead}()`, get2);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code3 = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code3)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code3, `${field} property`, `cache.${instead}`, get2);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code3) => !warned.has(code3);
    var warn = (code3, what, instead, fn) => {
      warned.add(code3);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code3, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options3 = {}) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, fetchContext, noDeleteOnFetchRejection, noDeleteOnStaleGet } = options3;
        const { length: length4, maxAge, stale } = options3 instanceof _LRUCache ? {} : options3;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length4;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError("cannot set fetchContext without fetchMethod");
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code3 = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code3)) {
            warned.add(code3);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code3, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length4) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, {
          updateAgeOnHas: false
        }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v2, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v2, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer)");
            }
          }
          return size;
        };
        this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, size) {
      }
      requireSize(k, v2, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.tail; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.head) {
              break;
            } else {
              i2 = this.prev[i2];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.head; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.tail) {
              break;
            } else {
              i2 = this.next[i2];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i2 of this.indexes()) {
          yield [
            this.keyList[i2],
            this.valList[i2]
          ];
        }
      }
      *rentries() {
        for (const i2 of this.rindexes()) {
          yield [
            this.keyList[i2],
            this.valList[i2]
          ];
        }
      }
      *keys() {
        for (const i2 of this.indexes()) {
          yield this.keyList[i2];
        }
      }
      *rkeys() {
        for (const i2 of this.rindexes()) {
          yield this.keyList[i2];
        }
      }
      *values() {
        for (const i2 of this.indexes()) {
          yield this.valList[i2];
        }
      }
      *rvalues() {
        for (const i2 of this.rindexes()) {
          yield this.valList[i2];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i2 of this.indexes()) {
          if (fn(this.valList[i2], this.keyList[i2], this)) {
            return this.get(this.keyList[i2], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i2 of this.indexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i2 of this.rindexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i2 of this.rindexes({
          allowStale: true
        })) {
          if (this.isStale(i2)) {
            this.delete(this.keyList[i2]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i2 of this.indexes({
          allowStale: true
        })) {
          const key = this.keyList[i2];
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          const entry = {
            value
          };
          if (this.ttls) {
            entry.ttl = this.ttls[i2];
            const age = perf.now() - this.starts[i2];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i2];
          }
          arr.unshift([
            key,
            entry
          ]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v2, k, reason) {
      }
      set(k, v2, { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL } = {}) {
        size = this.requireSize(k, v2, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v2;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v2 !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([
                    oldVal,
                    k,
                    "set"
                  ]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v2;
            this.addItemSize(index, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v2 = this.valList[head];
        if (this.isBackgroundFetch(v2)) {
          v2.__abortController.abort();
        } else {
          this.dispose(v2, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([
              v2,
              k,
              "evict"
            ]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v2 = this.valList[index];
          return this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
        }
      }
      backgroundFetch(k, index, options3, context) {
        const v2 = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v2)) {
          return v2;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options: options3,
          context
        };
        const cb = (v6) => {
          if (!ac.signal.aborted) {
            this.set(k, v6, fetchOpts.options);
          }
          return v6;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options3.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v2, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v2;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = false
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet
          });
        }
        const options3 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          return p.__returned = p;
        } else {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            return allowStale && v2.__staleWhileFetching !== void 0 ? v2.__staleWhileFetching : v2.__returned = v2;
          }
          if (!forceRefresh && !this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v2;
          }
          const p = this.backgroundFetch(k, index, options3, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v2 = this.valList[index];
              if (this.isBackgroundFetch(v2)) {
                v2.__abortController.abort();
              } else {
                this.dispose(v2, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([
                    v2,
                    k,
                    "delete"
                  ]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({
          allowStale: true
        })) {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v2, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([
                v2,
                k,
                "delete"
              ]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = __require("node:stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options3) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options3,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary2) {
        const data = !isBinary2 && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error40(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error40(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: [
        "nodebuffer",
        "arraybuffer",
        "fragments"
      ],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    function concat2(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i2 = 0; i2 < list.length; i2++) {
        const buf2 = list[i2];
        target.set(buf2, offset);
        offset += buf2.length;
      }
      if (offset < totalLength) return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length4) {
      for (let i2 = 0; i2 < length4; i2++) {
        output[offset + i2] = source[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i2 = 0; i2 < buffer.length; i2++) {
        buffer[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer2(buf2) {
      if (buf2.byteLength === buf2.buffer.byteLength) {
        return buf2.buffer;
      }
      return buf2.buffer.slice(buf2.byteOffset, buf2.byteOffset + buf2.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf2;
      if (data instanceof ArrayBuffer) {
        buf2 = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf2 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf2 = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf2;
    }
    try {
      const bufferUtil = __require("bufferutil");
      module2.exports = {
        concat: concat2,
        mask(source, mask, output, offset, length4) {
          if (length4 < 48) _mask(source, mask, output, offset, length4);
          else bufferUtil.mask(source, mask, output, offset, length4);
        },
        toArrayBuffer: toArrayBuffer2,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        }
      };
    } catch (e2) {
      module2.exports = {
        concat: concat2,
        mask: _mask,
        toArrayBuffer: toArrayBuffer2,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = __require("node:zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var TRAILER = Buffer.from([
      0,
      0,
      255,
      255
    ]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options3, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options3 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin) data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/validation.js
var require_validation2 = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code3) {
      return code3 >= 1e3 && code3 <= 1014 && code3 !== 1004 && code3 !== 1005 && code3 !== 1006 || code3 >= 3e3 && code3 <= 4999;
    }
    function _isValidUTF8(buf2) {
      const len = buf2.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf2[i2] & 128) === 0) {
          i2++;
        } else if ((buf2[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf2[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2 + 2] & 192) !== 128 || buf2[i2] === 224 && (buf2[i2 + 1] & 224) === 128 || // Overlong
          buf2[i2] === 237 && (buf2[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf2[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf2[i2 + 1] & 192) !== 128 || (buf2[i2 + 2] & 192) !== 128 || (buf2[i2 + 3] & 192) !== 128 || buf2[i2] === 240 && (buf2[i2 + 1] & 240) === 128 || // Overlong
          buf2[i2] === 244 && buf2[i2 + 1] > 143 || buf2[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      const isValidUTF8 = __require("utf-8-validate");
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf2) {
          return buf2.length < 150 ? _isValidUTF8(buf2) : isValidUTF8(buf2);
        },
        tokenChars
      };
    } catch (e2) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8,
        tokenChars
      };
    }
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = __require("node:stream");
    var PerMessageDeflate = require_permessage_deflate();
    var { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = require_constants2();
    var { concat: concat2, toArrayBuffer: toArrayBuffer2, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation2();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options3 = {}) {
        super();
        this._binaryType = options3.binaryType || BINARY_TYPES[0];
        this._extensions = options3.extensions || {};
        this._isServer = !!options3.isServer;
        this._maxPayload = options3.maxPayload | 0;
        this._skipUTF8Validation = !!options3.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf2 = this._buffers[0];
          this._buffers[0] = buf2.slice(n);
          return buf2.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf2 = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf2.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf2.buffer, buf2.byteOffset, n), offset);
            this._buffers[0] = buf2.slice(n);
          }
          n -= buf2.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf2 = this.consume(2);
        if ((buf2[0] & 48) !== 0) {
          this._loop = false;
          return error40(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf2[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error40(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf2[0] & 128) === 128;
        this._opcode = buf2[0] & 15;
        this._payloadLength = buf2[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error40(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error40(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error40(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error40(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error40(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error40(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error40(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf2[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error40(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error40(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf2 = this.consume(8);
        const num = buf2.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error40(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf2.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error40(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf2) => {
          if (err) return cb(err);
          if (buf2.length) {
            this._messageLength += buf2.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error40(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf2);
          }
          const er = this.dataMessage();
          if (er) return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat2(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer2(concat2(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf2 = concat2(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf2)) {
              this._loop = false;
              return error40(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf2, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data.length === 1) {
            return error40(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code3 = data.readUInt16BE(0);
            if (!isValidStatusCode(code3)) {
              return error40(RangeError, `invalid status code ${code3}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf2 = data.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf2)) {
              return error40(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code3, buf2);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error40(ErrorCtor, message, prefix, statusCode, errorCode2) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error40);
      err.code = errorCode2;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = __require("node:net");
    var tls = __require("node:tls");
    var { randomFillSync } = __require("node:crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants2();
    var { isValidStatusCode } = require_validation2();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options3) {
        let mask;
        let merge3 = false;
        let offset = 2;
        let skipMasking = false;
        if (options3.mask) {
          mask = options3.maskBuffer || maskBuffer;
          if (options3.generateMask) {
            options3.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options3.mask || skipMasking) && options3[kByteLength] !== void 0) {
            dataLength = options3[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge3 = options3.mask && options3.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge3 ? dataLength + offset : offset);
        target[0] = options3.fin ? options3.opcode | 128 : options3.opcode;
        if (options3.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options3.mask) return [
          target,
          data
        ];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [
          target,
          data
        ];
        if (merge3) {
          applyMask(data, mask, target, offset, dataLength);
          return [
            target
          ];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [
          target,
          data
        ];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code3, data, mask, cb) {
        let buf2;
        if (code3 === void 0) {
          buf2 = EMPTY_BUFFER;
        } else if (typeof code3 !== "number" || !isValidStatusCode(code3)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf2 = Buffer.allocUnsafe(2);
          buf2.writeUInt16BE(code3, 0);
        } else {
          const length4 = Buffer.byteLength(data);
          if (length4 > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf2 = Buffer.allocUnsafe(2 + length4);
          buf2.writeUInt16BE(code3, 0);
          if (typeof data === "string") {
            buf2.write(data, 2);
          } else {
            buf2.set(data, 2);
          }
        }
        const options3 = {
          [kByteLength]: buf2.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([
            this.dispatch,
            buf2,
            false,
            options3,
            cb
          ]);
        } else {
          this.sendFrame(_Sender.frame(buf2, options3), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options3 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([
            this.dispatch,
            data,
            false,
            options3,
            cb
          ]);
        } else {
          this.sendFrame(_Sender.frame(data, options3), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options3 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([
            this.dispatch,
            data,
            false,
            options3,
            cb
          ]);
        } else {
          this.sendFrame(_Sender.frame(data, options3), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options3, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options3.binary ? 2 : 1;
        let rsv1 = options3.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options3.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options3.fin,
            generateMask: this._generateMask,
            mask: options3.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([
              this.dispatch,
              data,
              this._compress,
              opts,
              cb
            ]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(_Sender.frame(data, {
            [kByteLength]: byteLength,
            fin: options3.fin,
            generateMask: this._generateMask,
            mask: options3.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1: false
          }), cb);
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options3, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options3), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options3[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options3.fin, (_, buf2) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function") cb(err);
            for (let i2 = 0; i2 < this._queue.length; i2++) {
              const params = this._queue[i2];
              const callback = params[params.length - 1];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= options3[kByteLength];
          this._deflating = false;
          options3.readOnly = false;
          this.sendFrame(_Sender.frame(buf2, options3), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", {
      enumerable: true
    });
    Object.defineProperty(Event.prototype, "type", {
      enumerable: true
    });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options3 = {}) {
        super(type);
        this[kCode] = options3.code === void 0 ? 0 : options3.code;
        this[kReason] = options3.reason === void 0 ? "" : options3.reason;
        this[kWasClean] = options3.wasClean === void 0 ? false : options3.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", {
      enumerable: true
    });
    Object.defineProperty(CloseEvent.prototype, "reason", {
      enumerable: true
    });
    Object.defineProperty(CloseEvent.prototype, "wasClean", {
      enumerable: true
    });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options3 = {}) {
        super(type);
        this[kError] = options3.error === void 0 ? null : options3.error;
        this[kMessage] = options3.message === void 0 ? "" : options3.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", {
      enumerable: true
    });
    Object.defineProperty(ErrorEvent.prototype, "message", {
      enumerable: true
    });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options3 = {}) {
        super(type);
        this[kData] = options3.data === void 0 ? null : options3.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", {
      enumerable: true
    });
    var EventTarget2 = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, listener, options3 = {}) {
        let wrapper3;
        if (type === "message") {
          wrapper3 = function onMessage(data, isBinary2) {
            const event = new MessageEvent("message", {
              data: isBinary2 ? data : data.toString()
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "close") {
          wrapper3 = function onClose(code3, message) {
            const event = new CloseEvent("close", {
              code: code3,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "error") {
          wrapper3 = function onError(error40) {
            const event = new ErrorEvent("error", {
              error: error40,
              message: error40.message
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "open") {
          wrapper3 = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else {
          return;
        }
        wrapper3[kForOnEventAttribute] = !!options3[kForOnEventAttribute];
        wrapper3[kListener] = listener;
        if (options3.once) {
          this.once(type, wrapper3);
        } else {
          this.on(type, wrapper3);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget: EventTarget2,
      MessageEvent
    };
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [
        elem
      ];
      else dest[name].push(elem);
    }
    function parse10(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code3 = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        code3 = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code3] === 1) {
            if (start === -1) start = i2;
          } else if (i2 !== 0 && (code3 === 32 || code3 === 9)) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code3 === 59 || code3 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            const name = header.slice(start, end);
            if (code3 === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code3] === 1) {
            if (start === -1) start = i2;
          } else if (code3 === 32 || code3 === 9) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code3 === 59 || code3 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            push(params, header.slice(start, end), true);
            if (code3 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code3 === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code3] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1) start = i2;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code3] === 1) {
              if (start === -1) start = i2;
            } else if (code3 === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code3 === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code3 === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code3] === 1) {
            if (start === -1) start = i2;
          } else if (start !== -1 && (code3 === 32 || code3 === 9)) {
            if (end === -1) end = i2;
          } else if (code3 === 59 || code3 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code3 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes || code3 === 32 || code3 === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i2;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format10(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [
          configurations
        ];
        return configurations.map((params) => {
          return [
            extension
          ].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values)) values = [
              values
            ];
            return values.map((v2) => v2 === true ? k : `${k}=${v2}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = {
      format: format10,
      parse: parse10
    };
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require("node:events");
    var https = __require("node:https");
    var http = __require("node:http");
    var net = __require("node:net");
    var tls = __require("node:tls");
    var { randomBytes: randomBytes3, createHash } = __require("node:crypto");
    var { Readable: Readable2 } = __require("node:stream");
    var { URL: URL3 } = __require("node:url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = require_constants2();
    var { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
    var { format: format10, parse: parse10 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = [
      "CONNECTING",
      "OPEN",
      "CLOSING",
      "CLOSED"
    ];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var protocolVersions = [
      8,
      13
    ];
    var closeTimeout = 30 * 1e3;
    var WebSocket3 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options3) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options3 = protocols;
              protocols = [];
            } else {
              protocols = [
                protocols
              ];
            }
          }
          initAsClient(this, address, protocols, options3);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options3) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options3.maxPayload,
          skipUTF8Validation: options3.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options3.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code3, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code3, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options3, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options3 === "function") {
          cb = options3;
          options3 = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options3
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, {
        enumerable: true
      });
    });
    [
      "open",
      "error",
      "close",
      "message"
    ].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options3) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options3,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL3) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL3(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      let invalidURLMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
        invalidURLMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isUnixSocket && !parsedUrl.pathname) {
        invalidURLMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidURLMessage = "The URL contains a fragment identifier";
      }
      if (invalidURLMessage) {
        const err = new SyntaxError(invalidURLMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes3(16).toString("base64");
      const get2 = isSecure ? https.get : http.get;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format10({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalHost = parsedUrl.host;
          const headers = options3 && options3.headers;
          options3 = {
            ...options3,
            headers: {}
          };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options3.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (parsedUrl.host !== websocket._originalHost) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          delete opts.headers.host;
          opts.auth = void 0;
        }
        if (opts.auth && !options3.headers.authorization) {
          options3.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get2(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL3(location, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options3);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING) return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse10(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options3) {
      options3.path = options3.socketPath;
      return net.connect(options3);
    }
    function tlsConnect(options3) {
      options3.path = void 0;
      if (!options3.servername && options3.servername !== "") {
        options3.servername = net.isIP(options3.host) ? "" : options3.host;
      }
      return tls.connect(options3);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length4 = toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length4;
        else websocket._bufferedAmount += length4;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code3, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code3;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code3 === 1005) websocket.close();
      else websocket.close(code3, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary2) {
      this[kWebSocket].emit("message", data, isBinary2);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function parse10(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (i2; i2 < header.length; i2++) {
        const code3 = header.charCodeAt(i2);
        if (end === -1 && tokenChars[code3] === 1) {
          if (start === -1) start = i2;
        } else if (i2 !== 0 && (code3 === 32 || code3 === 9)) {
          if (end === -1 && start !== -1) end = i2;
        } else if (code3 === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1) end = i2;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i2);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = {
      parse: parse10
    };
  }
});

// node_modules/.deno/ws@8.5.0/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/.deno/ws@8.5.0/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require("node:events");
    var http = __require("node:http");
    var https = __require("node:https");
    var net = __require("node:net");
    var tls = __require("node:tls");
    var { createHash } = __require("node:crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options3, callback) {
        super();
        options3 = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options3
        };
        if (options3.port == null && !options3.server && !options3.noServer || options3.port != null && (options3.server || options3.noServer) || options3.server && options3.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options3.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options3.port, options3.host, options3.backlog, callback);
        } else if (options3.server) {
          this._server = options3.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options3.perMessageDeflate === true) options3.perMessageDeflate = {};
        if (options3.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options3;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"] : false;
        const version4 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version4 !== 8 && version4 !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version4 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code3, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code3 || 401, message, headers);
              }
              this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [
              params
            ]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map2) {
      for (const event of Object.keys(map2)) server.on(event, map2[event]);
      return function removeListeners() {
        for (const event of Object.keys(map2)) {
          server.removeListener(event, map2[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code3, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code3];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(`HTTP/1.1 ${code3} ${http.STATUS_CODES[code3]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(__require("node:crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/regex.js
var require_regex2 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default3 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex2 = _interopRequireDefault(require_regex2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function validate2(uuid5) {
      return typeof uuid5 === "string" && _regex2.default.test(uuid5);
    }
    var _default3 = validate2;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var byteToHex = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    function stringify2(arr, offset = 0) {
      const uuid5 = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid5)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid5;
    }
    var _default3 = stringify2;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v12(options3, buf2, offset) {
      let i2 = buf2 && offset || 0;
      const b = buf2 || new Array(16);
      options3 = options3 || {};
      let node = options3.node || _nodeId;
      let clockseq = options3.clockseq !== void 0 ? options3.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options3.random || (options3.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options3.msecs !== void 0 ? options3.msecs : Date.now();
      let nsecs = options3.nsecs !== void 0 ? options3.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options3.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options3.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i2++] = tl >>> 24 & 255;
      b[i2++] = tl >>> 16 & 255;
      b[i2++] = tl >>> 8 & 255;
      b[i2++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i2++] = tmh >>> 8 & 255;
      b[i2++] = tmh & 255;
      b[i2++] = tmh >>> 24 & 15 | 16;
      b[i2++] = tmh >>> 16 & 255;
      b[i2++] = clockseq >>> 8 | 128;
      b[i2++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i2 + n] = node[n];
      }
      return buf2 || (0, _stringify.unsafeStringify)(b);
    }
    var _default3 = v12;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function parse10(uuid5) {
      if (!(0, _validate.default)(uuid5)) {
        throw TypeError("Invalid UUID");
      }
      let v2;
      const arr = new Uint8Array(16);
      arr[0] = (v2 = parseInt(uuid5.slice(0, 8), 16)) >>> 24;
      arr[1] = v2 >>> 16 & 255;
      arr[2] = v2 >>> 8 & 255;
      arr[3] = v2 & 255;
      arr[4] = (v2 = parseInt(uuid5.slice(9, 13), 16)) >>> 8;
      arr[5] = v2 & 255;
      arr[6] = (v2 = parseInt(uuid5.slice(14, 18), 16)) >>> 8;
      arr[7] = v2 & 255;
      arr[8] = (v2 = parseInt(uuid5.slice(19, 23), 16)) >>> 8;
      arr[9] = v2 & 255;
      arr[10] = (v2 = parseInt(uuid5.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v2 / 4294967296 & 255;
      arr[12] = v2 >>> 24 & 255;
      arr[13] = v2 >>> 16 & 255;
      arr[14] = v2 >>> 8 & 255;
      arr[15] = v2 & 255;
      return arr;
    }
    var _default3 = parse10;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.URL = exports2.DNS = void 0;
    exports2.default = v35;
    var _stringify = require_stringify2();
    var _parse2 = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        bytes.push(str.charCodeAt(i2));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL3;
    function v35(name, version4, hashfunc) {
      function generateUUID(value, namespace, buf2, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse2.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version4;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf2) {
          offset = offset || 0;
          for (let i2 = 0; i2 < 16; ++i2) {
            buf2[offset + i2] = bytes[i2];
          }
          return buf2;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL3;
      return generateUUID;
    }
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(__require("node:crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default3 = md5;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var v32 = (0, _v.default)("v3", 48, _md.default);
    var _default3 = v32;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/native.js
var require_native = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(__require("node:crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default3 = {
      randomUUID: _crypto.default.randomUUID
    };
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function v42(options3, buf2, offset) {
      if (_native.default.randomUUID && !buf2 && !options3) {
        return _native.default.randomUUID();
      }
      options3 = options3 || {};
      const rnds = options3.random || (options3.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf2) {
        offset = offset || 0;
        for (let i2 = 0; i2 < 16; ++i2) {
          buf2[offset + i2] = rnds[i2];
        }
        return buf2;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default3 = v42;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(__require("node:crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default3 = sha1;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var v52 = (0, _v.default)("v5", 80, _sha.default);
    var _default3 = v52;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default3 = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function version4(uuid5) {
      if (!(0, _validate.default)(uuid5)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid5.slice(14, 15), 16);
    }
    var _default3 = version4;
    exports2.default = _default3;
  }
});

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  "node_modules/.deno/uuid@9.0.0/node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse2.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify2());
    var _parse2 = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/parser.js
var require_parser = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/parser.js"(exports2) {
    "use strict";
    exports2.load = function(received, defaults, onto = {}) {
      var k, ref, v2;
      for (k in defaults) {
        v2 = defaults[k];
        onto[k] = (ref = received[k]) != null ? ref : v2;
      }
      return onto;
    };
    exports2.overwrite = function(received, defaults, onto = {}) {
      var k, v2;
      for (k in received) {
        v2 = received[k];
        if (defaults[k] !== void 0) {
          onto[k] = v2;
        }
      }
      return onto;
    };
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/DLList.js
var require_DLList = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/DLList.js"(exports2, module2) {
    "use strict";
    var DLList;
    DLList = class DLList {
      constructor(incr, decr) {
        this.incr = incr;
        this.decr = decr;
        this._first = null;
        this._last = null;
        this.length = 0;
      }
      push(value) {
        var node;
        this.length++;
        if (typeof this.incr === "function") {
          this.incr();
        }
        node = {
          value,
          prev: this._last,
          next: null
        };
        if (this._last != null) {
          this._last.next = node;
          this._last = node;
        } else {
          this._first = this._last = node;
        }
        return void 0;
      }
      shift() {
        var value;
        if (this._first == null) {
          return;
        } else {
          this.length--;
          if (typeof this.decr === "function") {
            this.decr();
          }
        }
        value = this._first.value;
        if ((this._first = this._first.next) != null) {
          this._first.prev = null;
        } else {
          this._last = null;
        }
        return value;
      }
      first() {
        if (this._first != null) {
          return this._first.value;
        }
      }
      getArray() {
        var node, ref, results;
        node = this._first;
        results = [];
        while (node != null) {
          results.push((ref = node, node = node.next, ref.value));
        }
        return results;
      }
      forEachShift(cb) {
        var node;
        node = this.shift();
        while (node != null) {
          cb(node), node = this.shift();
        }
        return void 0;
      }
      debug() {
        var node, ref, ref1, ref2, results;
        node = this._first;
        results = [];
        while (node != null) {
          results.push((ref = node, node = node.next, {
            value: ref.value,
            prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
            next: (ref2 = ref.next) != null ? ref2.value : void 0
          }));
        }
        return results;
      }
    };
    module2.exports = DLList;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Events.js
var require_Events = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Events.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events2;
    Events2 = class Events {
      constructor(instance) {
        this.instance = instance;
        this._events = {};
        if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
          throw new Error("An Emitter already exists for this object");
        }
        this.instance.on = (name, cb) => {
          return this._addListener(name, "many", cb);
        };
        this.instance.once = (name, cb) => {
          return this._addListener(name, "once", cb);
        };
        this.instance.removeAllListeners = (name = null) => {
          if (name != null) {
            return delete this._events[name];
          } else {
            return this._events = {};
          }
        };
      }
      _addListener(name, status, cb) {
        var base4;
        if ((base4 = this._events)[name] == null) {
          base4[name] = [];
        }
        this._events[name].push({
          cb,
          status
        });
        return this.instance;
      }
      listenerCount(name) {
        if (this._events[name] != null) {
          return this._events[name].length;
        } else {
          return 0;
        }
      }
      trigger(name, ...args) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var e2, promises;
          try {
            if (name !== "debug") {
              _this.trigger("debug", `Event triggered: ${name}`, args);
            }
            if (_this._events[name] == null) {
              return;
            }
            _this._events[name] = _this._events[name].filter(function(listener) {
              return listener.status !== "none";
            });
            promises = _this._events[name].map(/* @__PURE__ */ function() {
              var _ref = _asyncToGenerator2(function* (listener) {
                var e3, returned;
                if (listener.status === "none") {
                  return;
                }
                if (listener.status === "once") {
                  listener.status = "none";
                }
                try {
                  returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
                  if (typeof (returned != null ? returned.then : void 0) === "function") {
                    return yield returned;
                  } else {
                    return returned;
                  }
                } catch (error40) {
                  e3 = error40;
                  if (true) {
                    _this.trigger("error", e3);
                  }
                  return null;
                }
              });
              return function(_x) {
                return _ref.apply(this, arguments);
              };
            }());
            return (yield Promise.all(promises)).find(function(x3) {
              return x3 != null;
            });
          } catch (error40) {
            e2 = error40;
            if (true) {
              _this.trigger("error", e2);
            }
            return null;
          }
        })();
      }
    };
    module2.exports = Events2;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Queues.js
var require_Queues = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Queues.js"(exports2, module2) {
    "use strict";
    var DLList;
    var Events2;
    var Queues;
    DLList = require_DLList();
    Events2 = require_Events();
    Queues = class Queues {
      constructor(num_priorities) {
        var i2;
        this.Events = new Events2(this);
        this._length = 0;
        this._lists = function() {
          var j, ref, results;
          results = [];
          for (i2 = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i2 = 1 <= ref ? ++j : --j) {
            results.push(new DLList(() => {
              return this.incr();
            }, () => {
              return this.decr();
            }));
          }
          return results;
        }.call(this);
      }
      incr() {
        if (this._length++ === 0) {
          return this.Events.trigger("leftzero");
        }
      }
      decr() {
        if (--this._length === 0) {
          return this.Events.trigger("zero");
        }
      }
      push(job) {
        return this._lists[job.options.priority].push(job);
      }
      queued(priority) {
        if (priority != null) {
          return this._lists[priority].length;
        } else {
          return this._length;
        }
      }
      shiftAll(fn) {
        return this._lists.forEach(function(list) {
          return list.forEachShift(fn);
        });
      }
      getFirst(arr = this._lists) {
        var j, len, list;
        for (j = 0, len = arr.length; j < len; j++) {
          list = arr[j];
          if (list.length > 0) {
            return list;
          }
        }
        return [];
      }
      shiftLastFrom(priority) {
        return this.getFirst(this._lists.slice(priority).reverse()).shift();
      }
    };
    module2.exports = Queues;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/BottleneckError.js
var require_BottleneckError = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/BottleneckError.js"(exports2, module2) {
    "use strict";
    var BottleneckError;
    BottleneckError = class BottleneckError extends Error {
    };
    module2.exports = BottleneckError;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Job.js
var require_Job = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Job.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var BottleneckError;
    var DEFAULT_PRIORITY;
    var Job;
    var NUM_PRIORITIES;
    var parser2;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser2 = require_parser();
    BottleneckError = require_BottleneckError();
    Job = class Job {
      constructor(task, args, options3, jobDefaults, rejectOnDrop, Events2, _states, Promise2) {
        this.task = task;
        this.args = args;
        this.rejectOnDrop = rejectOnDrop;
        this.Events = Events2;
        this._states = _states;
        this.Promise = Promise2;
        this.options = parser2.load(options3, jobDefaults);
        this.options.priority = this._sanitizePriority(this.options.priority);
        if (this.options.id === jobDefaults.id) {
          this.options.id = `${this.options.id}-${this._randomIndex()}`;
        }
        this.promise = new this.Promise((_resolve, _reject) => {
          this._resolve = _resolve;
          this._reject = _reject;
        });
        this.retryCount = 0;
      }
      _sanitizePriority(priority) {
        var sProperty;
        sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
        if (sProperty < 0) {
          return 0;
        } else if (sProperty > NUM_PRIORITIES - 1) {
          return NUM_PRIORITIES - 1;
        } else {
          return sProperty;
        }
      }
      _randomIndex() {
        return Math.random().toString(36).slice(2);
      }
      doDrop({ error: error40, message = "This job has been dropped by Bottleneck" } = {}) {
        if (this._states.remove(this.options.id)) {
          if (this.rejectOnDrop) {
            this._reject(error40 != null ? error40 : new BottleneckError(message));
          }
          this.Events.trigger("dropped", {
            args: this.args,
            options: this.options,
            task: this.task,
            promise: this.promise
          });
          return true;
        } else {
          return false;
        }
      }
      _assertStatus(expected) {
        var status;
        status = this._states.jobStatus(this.options.id);
        if (!(status === expected || expected === "DONE" && status === null)) {
          throw new BottleneckError(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
        }
      }
      doReceive() {
        this._states.start(this.options.id);
        return this.Events.trigger("received", {
          args: this.args,
          options: this.options
        });
      }
      doQueue(reachedHWM, blocked) {
        this._assertStatus("RECEIVED");
        this._states.next(this.options.id);
        return this.Events.trigger("queued", {
          args: this.args,
          options: this.options,
          reachedHWM,
          blocked
        });
      }
      doRun() {
        if (this.retryCount === 0) {
          this._assertStatus("QUEUED");
          this._states.next(this.options.id);
        } else {
          this._assertStatus("EXECUTING");
        }
        return this.Events.trigger("scheduled", {
          args: this.args,
          options: this.options
        });
      }
      doExecute(chained, clearGlobalState, run3, free) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var error40, eventInfo, passed;
          if (_this.retryCount === 0) {
            _this._assertStatus("RUNNING");
            _this._states.next(_this.options.id);
          } else {
            _this._assertStatus("EXECUTING");
          }
          eventInfo = {
            args: _this.args,
            options: _this.options,
            retryCount: _this.retryCount
          };
          _this.Events.trigger("executing", eventInfo);
          try {
            passed = yield chained != null ? chained.schedule(_this.options, _this.task, ..._this.args) : _this.task(..._this.args);
            if (clearGlobalState()) {
              _this.doDone(eventInfo);
              yield free(_this.options, eventInfo);
              _this._assertStatus("DONE");
              return _this._resolve(passed);
            }
          } catch (error1) {
            error40 = error1;
            return _this._onFailure(error40, eventInfo, clearGlobalState, run3, free);
          }
        })();
      }
      doExpire(clearGlobalState, run3, free) {
        var error40, eventInfo;
        if (this._states.jobStatus(this.options.id === "RUNNING")) {
          this._states.next(this.options.id);
        }
        this._assertStatus("EXECUTING");
        eventInfo = {
          args: this.args,
          options: this.options,
          retryCount: this.retryCount
        };
        error40 = new BottleneckError(`This job timed out after ${this.options.expiration} ms.`);
        return this._onFailure(error40, eventInfo, clearGlobalState, run3, free);
      }
      _onFailure(error40, eventInfo, clearGlobalState, run3, free) {
        var _this2 = this;
        return _asyncToGenerator2(function* () {
          var retry, retryAfter;
          if (clearGlobalState()) {
            retry = yield _this2.Events.trigger("failed", error40, eventInfo);
            if (retry != null) {
              retryAfter = ~~retry;
              _this2.Events.trigger("retry", `Retrying ${_this2.options.id} after ${retryAfter} ms`, eventInfo);
              _this2.retryCount++;
              return run3(retryAfter);
            } else {
              _this2.doDone(eventInfo);
              yield free(_this2.options, eventInfo);
              _this2._assertStatus("DONE");
              return _this2._reject(error40);
            }
          }
        })();
      }
      doDone(eventInfo) {
        this._assertStatus("EXECUTING");
        this._states.next(this.options.id);
        return this.Events.trigger("done", eventInfo);
      }
    };
    module2.exports = Job;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/LocalDatastore.js
var require_LocalDatastore = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/LocalDatastore.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var BottleneckError;
    var LocalDatastore;
    var parser2;
    parser2 = require_parser();
    BottleneckError = require_BottleneckError();
    LocalDatastore = class LocalDatastore {
      constructor(instance, storeOptions, storeInstanceOptions) {
        this.instance = instance;
        this.storeOptions = storeOptions;
        this.clientId = this.instance._randomIndex();
        parser2.load(storeInstanceOptions, storeInstanceOptions, this);
        this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
        this._running = 0;
        this._done = 0;
        this._unblockTime = 0;
        this.ready = this.Promise.resolve();
        this.clients = {};
        this._startHeartbeat();
      }
      _startHeartbeat() {
        var base4;
        if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
          return typeof (base4 = this.heartbeat = setInterval(() => {
            var amount, incr, maximum, now, reservoir;
            now = Date.now();
            if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
              this._lastReservoirRefresh = now;
              this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
              this.instance._drainAll(this.computeCapacity());
            }
            if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
              var _this$storeOptions = this.storeOptions;
              amount = _this$storeOptions.reservoirIncreaseAmount;
              maximum = _this$storeOptions.reservoirIncreaseMaximum;
              reservoir = _this$storeOptions.reservoir;
              this._lastReservoirIncrease = now;
              incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
              if (incr > 0) {
                this.storeOptions.reservoir += incr;
                return this.instance._drainAll(this.computeCapacity());
              }
            }
          }, this.heartbeatInterval)).unref === "function" ? base4.unref() : void 0;
        } else {
          return clearInterval(this.heartbeat);
        }
      }
      __publish__(message) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          yield _this.yieldLoop();
          return _this.instance.Events.trigger("message", message.toString());
        })();
      }
      __disconnect__(flush) {
        var _this2 = this;
        return _asyncToGenerator2(function* () {
          yield _this2.yieldLoop();
          clearInterval(_this2.heartbeat);
          return _this2.Promise.resolve();
        })();
      }
      yieldLoop(t = 0) {
        return new this.Promise(function(resolve7, reject) {
          return setTimeout(resolve7, t);
        });
      }
      computePenalty() {
        var ref;
        return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5e3;
      }
      __updateSettings__(options3) {
        var _this3 = this;
        return _asyncToGenerator2(function* () {
          yield _this3.yieldLoop();
          parser2.overwrite(options3, options3, _this3.storeOptions);
          _this3._startHeartbeat();
          _this3.instance._drainAll(_this3.computeCapacity());
          return true;
        })();
      }
      __running__() {
        var _this4 = this;
        return _asyncToGenerator2(function* () {
          yield _this4.yieldLoop();
          return _this4._running;
        })();
      }
      __queued__() {
        var _this5 = this;
        return _asyncToGenerator2(function* () {
          yield _this5.yieldLoop();
          return _this5.instance.queued();
        })();
      }
      __done__() {
        var _this6 = this;
        return _asyncToGenerator2(function* () {
          yield _this6.yieldLoop();
          return _this6._done;
        })();
      }
      __groupCheck__(time3) {
        var _this7 = this;
        return _asyncToGenerator2(function* () {
          yield _this7.yieldLoop();
          return _this7._nextRequest + _this7.timeout < time3;
        })();
      }
      computeCapacity() {
        var maxConcurrent, reservoir;
        var _this$storeOptions2 = this.storeOptions;
        maxConcurrent = _this$storeOptions2.maxConcurrent;
        reservoir = _this$storeOptions2.reservoir;
        if (maxConcurrent != null && reservoir != null) {
          return Math.min(maxConcurrent - this._running, reservoir);
        } else if (maxConcurrent != null) {
          return maxConcurrent - this._running;
        } else if (reservoir != null) {
          return reservoir;
        } else {
          return null;
        }
      }
      conditionsCheck(weight) {
        var capacity;
        capacity = this.computeCapacity();
        return capacity == null || weight <= capacity;
      }
      __incrementReservoir__(incr) {
        var _this8 = this;
        return _asyncToGenerator2(function* () {
          var reservoir;
          yield _this8.yieldLoop();
          reservoir = _this8.storeOptions.reservoir += incr;
          _this8.instance._drainAll(_this8.computeCapacity());
          return reservoir;
        })();
      }
      __currentReservoir__() {
        var _this9 = this;
        return _asyncToGenerator2(function* () {
          yield _this9.yieldLoop();
          return _this9.storeOptions.reservoir;
        })();
      }
      isBlocked(now) {
        return this._unblockTime >= now;
      }
      check(weight, now) {
        return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
      }
      __check__(weight) {
        var _this10 = this;
        return _asyncToGenerator2(function* () {
          var now;
          yield _this10.yieldLoop();
          now = Date.now();
          return _this10.check(weight, now);
        })();
      }
      __register__(index, weight, expiration) {
        var _this11 = this;
        return _asyncToGenerator2(function* () {
          var now, wait;
          yield _this11.yieldLoop();
          now = Date.now();
          if (_this11.conditionsCheck(weight)) {
            _this11._running += weight;
            if (_this11.storeOptions.reservoir != null) {
              _this11.storeOptions.reservoir -= weight;
            }
            wait = Math.max(_this11._nextRequest - now, 0);
            _this11._nextRequest = now + wait + _this11.storeOptions.minTime;
            return {
              success: true,
              wait,
              reservoir: _this11.storeOptions.reservoir
            };
          } else {
            return {
              success: false
            };
          }
        })();
      }
      strategyIsBlock() {
        return this.storeOptions.strategy === 3;
      }
      __submit__(queueLength, weight) {
        var _this12 = this;
        return _asyncToGenerator2(function* () {
          var blocked, now, reachedHWM;
          yield _this12.yieldLoop();
          if (_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent) {
            throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this12.storeOptions.maxConcurrent}`);
          }
          now = Date.now();
          reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);
          blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));
          if (blocked) {
            _this12._unblockTime = now + _this12.computePenalty();
            _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;
            _this12.instance._dropAllQueued();
          }
          return {
            reachedHWM,
            blocked,
            strategy: _this12.storeOptions.strategy
          };
        })();
      }
      __free__(index, weight) {
        var _this13 = this;
        return _asyncToGenerator2(function* () {
          yield _this13.yieldLoop();
          _this13._running -= weight;
          _this13._done += weight;
          _this13.instance._drainAll(_this13.computeCapacity());
          return {
            running: _this13._running
          };
        })();
      }
    };
    module2.exports = LocalDatastore;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/lua.json
var require_lua = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/lua.json"(exports2, module2) {
    module2.exports = {
      "blacklist_client.lua": "local blacklist = ARGV[num_static_argv + 1]\n\nif redis.call('zscore', client_last_seen_key, blacklist) then\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\nend\n\n\nreturn {}\n",
      "check.lua": "local weight = tonumber(ARGV[num_static_argv + 1])\n\nlocal capacity = process_tick(now, false)['capacity']\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\n\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\n",
      "conditions_check.lua": "local conditions_check = function (capacity, weight)\n  return capacity == nil or weight <= capacity\nend\n",
      "current_reservoir.lua": "return process_tick(now, false)['reservoir']\n",
      "done.lua": "process_tick(now, false)\n\nreturn tonumber(redis.call('hget', settings_key, 'done'))\n",
      "free.lua": "local index = ARGV[num_static_argv + 1]\n\nredis.call('zadd', job_expirations_key, 0, index)\n\nreturn process_tick(now, false)['running']\n",
      "get_time.lua": "redis.replicate_commands()\n\nlocal get_time = function ()\n  local time = redis.call('time')\n\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\nend\n",
      "group_check.lua": "return not (redis.call('exists', settings_key) == 1)\n",
      "heartbeat.lua": "process_tick(now, true)\n",
      "increment_reservoir.lua": "local incr = tonumber(ARGV[num_static_argv + 1])\n\nredis.call('hincrby', settings_key, 'reservoir', incr)\n\nlocal reservoir = process_tick(now, true)['reservoir']\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn reservoir\n",
      "init.lua": `local clear = tonumber(ARGV[num_static_argv + 1])
local limiter_version = ARGV[num_static_argv + 2]
local num_local_argv = num_static_argv + 2

if clear == 1 then
  redis.call('del', unpack(KEYS))
end

if redis.call('exists', settings_key) == 0 then
  -- Create
  local args = {'hmset', settings_key}

  for i = num_local_argv + 1, #ARGV do
    table.insert(args, ARGV[i])
  end

  redis.call(unpack(args))
  redis.call('hmset', settings_key,
    'nextRequest', now,
    'lastReservoirRefresh', now,
    'lastReservoirIncrease', now,
    'running', 0,
    'done', 0,
    'unblockTime', 0,
    'capacityPriorityCounter', 0
  )

else
  -- Apply migrations
  local settings = redis.call('hmget', settings_key,
    'id',
    'version'
  )
  local id = settings[1]
  local current_version = settings[2]

  if current_version ~= limiter_version then
    local version_digits = {}
    for k, v in string.gmatch(current_version, "([^.]+)") do
      table.insert(version_digits, tonumber(k))
    end

    -- 2.10.0
    if version_digits[2] < 10 then
      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')
      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')
      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')
      redis.call('hsetnx', settings_key, 'done', 0)
      redis.call('hset', settings_key, 'version', '2.10.0')
    end

    -- 2.11.1
    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then
      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then
        redis.call('hmset', settings_key,
          'lastReservoirRefresh', now,
          'version', '2.11.1'
        )
      end
    end

    -- 2.14.0
    if version_digits[2] < 14 then
      local old_running_key = 'b_'..id..'_running'
      local old_executing_key = 'b_'..id..'_executing'

      if redis.call('exists', old_running_key) == 1 then
        redis.call('rename', old_running_key, job_weights_key)
      end
      if redis.call('exists', old_executing_key) == 1 then
        redis.call('rename', old_executing_key, job_expirations_key)
      end
      redis.call('hset', settings_key, 'version', '2.14.0')
    end

    -- 2.15.2
    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then
      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)
      redis.call('hset', settings_key, 'version', '2.15.2')
    end

    -- 2.17.0
    if version_digits[2] < 17 then
      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)
      redis.call('hset', settings_key, 'version', '2.17.0')
    end

    -- 2.18.0
    if version_digits[2] < 18 then
      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')
      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')
      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')
      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)
      redis.call('hset', settings_key, 'version', '2.18.0')
    end

  end

  process_tick(now, false)
end

local groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))
refresh_expiration(0, 0, groupTimeout)

return {}
`,
      "process_tick.lua": "local process_tick = function (now, always_publish)\n\n  local compute_capacity = function (maxConcurrent, running, reservoir)\n    if maxConcurrent ~= nil and reservoir ~= nil then\n      return math.min((maxConcurrent - running), reservoir)\n    elseif maxConcurrent ~= nil then\n      return maxConcurrent - running\n    elseif reservoir ~= nil then\n      return reservoir\n    else\n      return nil\n    end\n  end\n\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'maxConcurrent',\n    'running',\n    'reservoir',\n    'reservoirRefreshInterval',\n    'reservoirRefreshAmount',\n    'lastReservoirRefresh',\n    'reservoirIncreaseInterval',\n    'reservoirIncreaseAmount',\n    'reservoirIncreaseMaximum',\n    'lastReservoirIncrease',\n    'capacityPriorityCounter',\n    'clientTimeout'\n  )\n  local id = settings[1]\n  local maxConcurrent = tonumber(settings[2])\n  local running = tonumber(settings[3])\n  local reservoir = tonumber(settings[4])\n  local reservoirRefreshInterval = tonumber(settings[5])\n  local reservoirRefreshAmount = tonumber(settings[6])\n  local lastReservoirRefresh = tonumber(settings[7])\n  local reservoirIncreaseInterval = tonumber(settings[8])\n  local reservoirIncreaseAmount = tonumber(settings[9])\n  local reservoirIncreaseMaximum = tonumber(settings[10])\n  local lastReservoirIncrease = tonumber(settings[11])\n  local capacityPriorityCounter = tonumber(settings[12])\n  local clientTimeout = tonumber(settings[13])\n\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  --\n  -- Process 'running' changes\n  --\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\n\n  if #expired > 0 then\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\n\n    local flush_batch = function (batch, acc)\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\n                      redis.call('hdel',  job_weights_key, unpack(batch))\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\n                      redis.call('hdel',  job_clients_key, unpack(batch))\n\n      -- Calculate sum of removed weights\n      for i = 1, #weights do\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\n      end\n\n      -- Calculate sum of removed weights by client\n      local client_weights = {}\n      for i = 1, #clients do\n        local removed = tonumber(weights[i]) or 0\n        if removed > 0 then\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\n        end\n      end\n    end\n\n    local acc = {\n      ['total'] = 0,\n      ['client_weights'] = {}\n    }\n    local batch_size = 1000\n\n    -- Compute changes to Zsets and apply changes to Hashes\n    for i = 1, #expired, batch_size do\n      local batch = {}\n      for j = i, math.min(i + batch_size - 1, #expired) do\n        table.insert(batch, expired[j])\n      end\n\n      flush_batch(batch, acc)\n    end\n\n    -- Apply changes to Zsets\n    if acc['total'] > 0 then\n      redis.call('hincrby', settings_key, 'done', acc['total'])\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\n    end\n\n    for client, weight in pairs(acc['client_weights']) do\n      redis.call('zincrby', client_running_key, -weight, client)\n    end\n  end\n\n  --\n  -- Process 'reservoir' changes\n  --\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\n    reservoir = reservoirRefreshAmount\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirRefresh', now\n    )\n  end\n\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\n    local incr = reservoirIncreaseAmount * num_intervals\n    if reservoirIncreaseMaximum ~= nil then\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\n    end\n    if incr > 0 then\n      reservoir = (reservoir or 0) + incr\n    end\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\n    )\n  end\n\n  --\n  -- Clear unresponsive clients\n  --\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\n  local unresponsive_lookup = {}\n  local terminated_clients = {}\n  for i = 1, #unresponsive do\n    unresponsive_lookup[unresponsive[i]] = true\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\n      table.insert(terminated_clients, unresponsive[i])\n    end\n  end\n  if #terminated_clients > 0 then\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\n  end\n\n  --\n  -- Broadcast capacity changes\n  --\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\n    -- always_publish or was not unlimited, now unlimited\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\n    -- capacity was increased\n    -- send the capacity message to the limiter having the lowest number of running jobs\n    -- the tiebreaker is the limiter having not registered a job in the longest time\n\n    local lowest_concurrency_value = nil\n    local lowest_concurrency_clients = {}\n    local lowest_concurrency_last_registered = {}\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\n\n    for i = 1, #client_concurrencies, 2 do\n      local client = client_concurrencies[i]\n      local concurrency = tonumber(client_concurrencies[i+1])\n\n      if (\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\n      ) and (\n        not unresponsive_lookup[client]\n      ) and (\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\n      ) then\n        lowest_concurrency_value = concurrency\n        table.insert(lowest_concurrency_clients, client)\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\n        table.insert(lowest_concurrency_last_registered, last_registered)\n      end\n    end\n\n    if #lowest_concurrency_clients > 0 then\n      local position = 1\n      local earliest = lowest_concurrency_last_registered[1]\n\n      for i,v in ipairs(lowest_concurrency_last_registered) do\n        if v < earliest then\n          position = i\n          earliest = v\n        end\n      end\n\n      local next_client = lowest_concurrency_clients[position]\n      redis.call('publish', 'b_'..id,\n        'capacity-priority:'..(final_capacity or '')..\n        ':'..next_client..\n        ':'..capacityPriorityCounter\n      )\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\n    else\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n    end\n  end\n\n  return {\n    ['capacity'] = final_capacity,\n    ['running'] = running,\n    ['reservoir'] = reservoir\n  }\nend\n",
      "queued.lua": "local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\n\nlocal sum = 0\nfor i = 1, #client_queued do\n  sum = sum + tonumber(client_queued[i])\nend\n\nreturn sum\n",
      "refresh_expiration.lua": "local refresh_expiration = function (now, nextRequest, groupTimeout)\n\n  if groupTimeout ~= nil then\n    local ttl = (nextRequest + groupTimeout) - now\n\n    for i = 1, #KEYS do\n      redis.call('pexpire', KEYS[i], ttl)\n    end\n  end\n\nend\n",
      "refs.lua": "local settings_key = KEYS[1]\nlocal job_weights_key = KEYS[2]\nlocal job_expirations_key = KEYS[3]\nlocal job_clients_key = KEYS[4]\nlocal client_running_key = KEYS[5]\nlocal client_num_queued_key = KEYS[6]\nlocal client_last_registered_key = KEYS[7]\nlocal client_last_seen_key = KEYS[8]\n\nlocal now = tonumber(ARGV[1])\nlocal client = ARGV[2]\n\nlocal num_static_argv = 2\n",
      "register.lua": "local index = ARGV[num_static_argv + 1]\nlocal weight = tonumber(ARGV[num_static_argv + 2])\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\n\nlocal state = process_tick(now, false)\nlocal capacity = state['capacity']\nlocal reservoir = state['reservoir']\n\nlocal settings = redis.call('hmget', settings_key,\n  'nextRequest',\n  'minTime',\n  'groupTimeout'\n)\nlocal nextRequest = tonumber(settings[1])\nlocal minTime = tonumber(settings[2])\nlocal groupTimeout = tonumber(settings[3])\n\nif conditions_check(capacity, weight) then\n\n  redis.call('hincrby', settings_key, 'running', weight)\n  redis.call('hset', job_weights_key, index, weight)\n  if expiration ~= nil then\n    redis.call('zadd', job_expirations_key, now + expiration, index)\n  end\n  redis.call('hset', job_clients_key, index, client)\n  redis.call('zincrby', client_running_key, weight, client)\n  redis.call('hincrby', client_num_queued_key, client, -1)\n  redis.call('zadd', client_last_registered_key, now, client)\n\n  local wait = math.max(nextRequest - now, 0)\n  local newNextRequest = now + wait + minTime\n\n  if reservoir == nil then\n    redis.call('hset', settings_key,\n      'nextRequest', newNextRequest\n    )\n  else\n    reservoir = reservoir - weight\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'nextRequest', newNextRequest\n    )\n  end\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\n\n  return {true, wait, reservoir}\n\nelse\n  return {false}\nend\n",
      "register_client.lua": "local queued = tonumber(ARGV[num_static_argv + 1])\n\n-- Could have been re-registered concurrently\nif not redis.call('zscore', client_last_seen_key, client) then\n  redis.call('zadd', client_running_key, 0, client)\n  redis.call('hset', client_num_queued_key, client, queued)\n  redis.call('zadd', client_last_registered_key, 0, client)\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n\nreturn {}\n",
      "running.lua": "return process_tick(now, false)['running']\n",
      "submit.lua": "local queueLength = tonumber(ARGV[num_static_argv + 1])\nlocal weight = tonumber(ARGV[num_static_argv + 2])\n\nlocal capacity = process_tick(now, false)['capacity']\n\nlocal settings = redis.call('hmget', settings_key,\n  'id',\n  'maxConcurrent',\n  'highWater',\n  'nextRequest',\n  'strategy',\n  'unblockTime',\n  'penalty',\n  'minTime',\n  'groupTimeout'\n)\nlocal id = settings[1]\nlocal maxConcurrent = tonumber(settings[2])\nlocal highWater = tonumber(settings[3])\nlocal nextRequest = tonumber(settings[4])\nlocal strategy = tonumber(settings[5])\nlocal unblockTime = tonumber(settings[6])\nlocal penalty = tonumber(settings[7])\nlocal minTime = tonumber(settings[8])\nlocal groupTimeout = tonumber(settings[9])\n\nif maxConcurrent ~= nil and weight > maxConcurrent then\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\nend\n\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\n  and not (\n    conditions_check(capacity, weight)\n    and nextRequest - now <= 0\n  )\n)\n\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\n\nif blocked then\n  local computedPenalty = penalty\n  if computedPenalty == nil then\n    if minTime == 0 then\n      computedPenalty = 5000\n    else\n      computedPenalty = 15 * minTime\n    end\n  end\n\n  local newNextRequest = now + computedPenalty + minTime\n\n  redis.call('hmset', settings_key,\n    'unblockTime', now + computedPenalty,\n    'nextRequest', newNextRequest\n  )\n\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\n  local queued_reset = {}\n  for i = 1, #clients_queued_reset do\n    table.insert(queued_reset, clients_queued_reset[i])\n    table.insert(queued_reset, 0)\n  end\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\n\n  redis.call('publish', 'b_'..id, 'blocked:')\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\nend\n\nif not blocked and not reachedHWM then\n  redis.call('hincrby', client_num_queued_key, client, 1)\nend\n\nreturn {reachedHWM, blocked, strategy}\n",
      "update_settings.lua": "local args = {'hmset', settings_key}\n\nfor i = num_static_argv + 1, #ARGV do\n  table.insert(args, ARGV[i])\nend\n\nredis.call(unpack(args))\n\nprocess_tick(now, true)\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n",
      "validate_client.lua": "if not redis.call('zscore', client_last_seen_key, client) then\n  return redis.error_reply('UNKNOWN_CLIENT')\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n",
      "validate_keys.lua": "if not (redis.call('exists', settings_key) == 1) then\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\nend\n"
    };
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Scripts.js
var require_Scripts = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Scripts.js"(exports2) {
    "use strict";
    var headers;
    var lua;
    var templates;
    lua = require_lua();
    headers = {
      refs: lua["refs.lua"],
      validate_keys: lua["validate_keys.lua"],
      validate_client: lua["validate_client.lua"],
      refresh_expiration: lua["refresh_expiration.lua"],
      process_tick: lua["process_tick.lua"],
      conditions_check: lua["conditions_check.lua"],
      get_time: lua["get_time.lua"]
    };
    exports2.allKeys = function(id) {
      return [
        /*
        HASH
        */
        `b_${id}_settings`,
        /*
        HASH
        job index -> weight
        */
        `b_${id}_job_weights`,
        /*
        ZSET
        job index -> expiration
        */
        `b_${id}_job_expirations`,
        /*
        HASH
        job index -> client
        */
        `b_${id}_job_clients`,
        /*
        ZSET
        client -> sum running
        */
        `b_${id}_client_running`,
        /*
        HASH
        client -> num queued
        */
        `b_${id}_client_num_queued`,
        /*
        ZSET
        client -> last job registered
        */
        `b_${id}_client_last_registered`,
        /*
        ZSET
        client -> last seen
        */
        `b_${id}_client_last_seen`
      ];
    };
    templates = {
      init: {
        keys: exports2.allKeys,
        headers: [
          "process_tick"
        ],
        refresh_expiration: true,
        code: lua["init.lua"]
      },
      group_check: {
        keys: exports2.allKeys,
        headers: [],
        refresh_expiration: false,
        code: lua["group_check.lua"]
      },
      register_client: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys"
        ],
        refresh_expiration: false,
        code: lua["register_client.lua"]
      },
      blacklist_client: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client"
        ],
        refresh_expiration: false,
        code: lua["blacklist_client.lua"]
      },
      heartbeat: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick"
        ],
        refresh_expiration: false,
        code: lua["heartbeat.lua"]
      },
      update_settings: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick"
        ],
        refresh_expiration: true,
        code: lua["update_settings.lua"]
      },
      running: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick"
        ],
        refresh_expiration: false,
        code: lua["running.lua"]
      },
      queued: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client"
        ],
        refresh_expiration: false,
        code: lua["queued.lua"]
      },
      done: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick"
        ],
        refresh_expiration: false,
        code: lua["done.lua"]
      },
      check: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick",
          "conditions_check"
        ],
        refresh_expiration: false,
        code: lua["check.lua"]
      },
      submit: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick",
          "conditions_check"
        ],
        refresh_expiration: true,
        code: lua["submit.lua"]
      },
      register: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick",
          "conditions_check"
        ],
        refresh_expiration: true,
        code: lua["register.lua"]
      },
      free: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick"
        ],
        refresh_expiration: true,
        code: lua["free.lua"]
      },
      current_reservoir: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick"
        ],
        refresh_expiration: false,
        code: lua["current_reservoir.lua"]
      },
      increment_reservoir: {
        keys: exports2.allKeys,
        headers: [
          "validate_keys",
          "validate_client",
          "process_tick"
        ],
        refresh_expiration: true,
        code: lua["increment_reservoir.lua"]
      }
    };
    exports2.names = Object.keys(templates);
    exports2.keys = function(name, id) {
      return templates[name].keys(id);
    };
    exports2.payload = function(name) {
      var template;
      template = templates[name];
      return Array.prototype.concat(headers.refs, template.headers.map(function(h2) {
        return headers[h2];
      }), template.refresh_expiration ? headers.refresh_expiration : "", template.code).join("\n");
    };
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/RedisConnection.js
var require_RedisConnection = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/RedisConnection.js"(exports, module) {
    "use strict";
    function asyncGeneratorStep(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events;
    var RedisConnection;
    var Scripts;
    var parser;
    parser = require_parser();
    Events = require_Events();
    Scripts = require_Scripts();
    RedisConnection = function() {
      class RedisConnection {
        constructor(options = {}) {
          parser.load(options, this.defaults, this);
          if (this.Redis == null) {
            this.Redis = eval("require")("redis");
          }
          if (this.Events == null) {
            this.Events = new Events(this);
          }
          this.terminated = false;
          if (this.client == null) {
            this.client = this.Redis.createClient(this.clientOptions);
          }
          this.subscriber = this.client.duplicate();
          this.limiters = {};
          this.shas = {};
          this.ready = this.Promise.all([
            this._setup(this.client, false),
            this._setup(this.subscriber, true)
          ]).then(() => {
            return this._loadScripts();
          }).then(() => {
            return {
              client: this.client,
              subscriber: this.subscriber
            };
          });
        }
        _setup(client, sub) {
          client.setMaxListeners(0);
          return new this.Promise((resolve7, reject) => {
            client.on("error", (e2) => {
              return this.Events.trigger("error", e2);
            });
            if (sub) {
              client.on("message", (channel, message) => {
                var ref;
                return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;
              });
            }
            if (client.ready) {
              return resolve7();
            } else {
              return client.once("ready", resolve7);
            }
          });
        }
        _loadScript(name) {
          return new this.Promise((resolve7, reject) => {
            var payload;
            payload = Scripts.payload(name);
            return this.client.multi([
              [
                "script",
                "load",
                payload
              ]
            ]).exec((err, replies) => {
              if (err != null) {
                return reject(err);
              }
              this.shas[name] = replies[0];
              return resolve7(replies[0]);
            });
          });
        }
        _loadScripts() {
          return this.Promise.all(Scripts.names.map((k) => {
            return this._loadScript(k);
          }));
        }
        __runCommand__(cmd) {
          var _this = this;
          return _asyncToGenerator(function* () {
            yield _this.ready;
            return new _this.Promise((resolve7, reject) => {
              return _this.client.multi([
                cmd
              ]).exec_atomic(function(err, replies) {
                if (err != null) {
                  return reject(err);
                } else {
                  return resolve7(replies[0]);
                }
              });
            });
          })();
        }
        __addLimiter__(instance) {
          return this.Promise.all([
            instance.channel(),
            instance.channel_client()
          ].map((channel) => {
            return new this.Promise((resolve7, reject) => {
              var handler;
              handler = (chan) => {
                if (chan === channel) {
                  this.subscriber.removeListener("subscribe", handler);
                  this.limiters[channel] = instance;
                  return resolve7();
                }
              };
              this.subscriber.on("subscribe", handler);
              return this.subscriber.subscribe(channel);
            });
          }));
        }
        __removeLimiter__(instance) {
          var _this2 = this;
          return this.Promise.all([
            instance.channel(),
            instance.channel_client()
          ].map(/* @__PURE__ */ function() {
            var _ref = _asyncToGenerator(function* (channel) {
              if (!_this2.terminated) {
                yield new _this2.Promise((resolve7, reject) => {
                  return _this2.subscriber.unsubscribe(channel, function(err, chan) {
                    if (err != null) {
                      return reject(err);
                    }
                    if (chan === channel) {
                      return resolve7();
                    }
                  });
                });
              }
              return delete _this2.limiters[channel];
            });
            return function(_x) {
              return _ref.apply(this, arguments);
            };
          }()));
        }
        __scriptArgs__(name, id, args, cb) {
          var keys;
          keys = Scripts.keys(name, id);
          return [
            this.shas[name],
            keys.length
          ].concat(keys, args, cb);
        }
        __scriptFn__(name) {
          return this.client.evalsha.bind(this.client);
        }
        disconnect(flush = true) {
          var i2, k, len, ref;
          ref = Object.keys(this.limiters);
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            k = ref[i2];
            clearInterval(this.limiters[k]._store.heartbeat);
          }
          this.limiters = {};
          this.terminated = true;
          this.client.end(flush);
          this.subscriber.end(flush);
          return this.Promise.resolve();
        }
      }
      ;
      RedisConnection.prototype.datastore = "redis";
      RedisConnection.prototype.defaults = {
        Redis: null,
        clientOptions: {},
        client: null,
        Promise,
        Events: null
      };
      return RedisConnection;
    }.call(void 0);
    module.exports = RedisConnection;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/IORedisConnection.js
var require_IORedisConnection = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/IORedisConnection.js"(exports, module) {
    "use strict";
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events;
    var IORedisConnection;
    var Scripts;
    var parser;
    parser = require_parser();
    Events = require_Events();
    Scripts = require_Scripts();
    IORedisConnection = function() {
      class IORedisConnection {
        constructor(options = {}) {
          parser.load(options, this.defaults, this);
          if (this.Redis == null) {
            this.Redis = eval("require")("ioredis");
          }
          if (this.Events == null) {
            this.Events = new Events(this);
          }
          this.terminated = false;
          if (this.clusterNodes != null) {
            this.client = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);
            this.subscriber = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);
          } else if (this.client != null && this.client.duplicate == null) {
            this.subscriber = new this.Redis.Cluster(this.client.startupNodes, this.client.options);
          } else {
            if (this.client == null) {
              this.client = new this.Redis(this.clientOptions);
            }
            this.subscriber = this.client.duplicate();
          }
          this.limiters = {};
          this.ready = this.Promise.all([
            this._setup(this.client, false),
            this._setup(this.subscriber, true)
          ]).then(() => {
            this._loadScripts();
            return {
              client: this.client,
              subscriber: this.subscriber
            };
          });
        }
        _setup(client, sub) {
          client.setMaxListeners(0);
          return new this.Promise((resolve7, reject) => {
            client.on("error", (e2) => {
              return this.Events.trigger("error", e2);
            });
            if (sub) {
              client.on("message", (channel, message) => {
                var ref;
                return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;
              });
            }
            if (client.status === "ready") {
              return resolve7();
            } else {
              return client.once("ready", resolve7);
            }
          });
        }
        _loadScripts() {
          return Scripts.names.forEach((name) => {
            return this.client.defineCommand(name, {
              lua: Scripts.payload(name)
            });
          });
        }
        __runCommand__(cmd) {
          var _this = this;
          return _asyncToGenerator(function* () {
            var _, deleted;
            yield _this.ready;
            var _ref = yield _this.client.pipeline([
              cmd
            ]).exec();
            var _ref2 = _slicedToArray(_ref, 1);
            var _ref2$ = _slicedToArray(_ref2[0], 2);
            _ = _ref2$[0];
            deleted = _ref2$[1];
            return deleted;
          })();
        }
        __addLimiter__(instance) {
          return this.Promise.all([
            instance.channel(),
            instance.channel_client()
          ].map((channel) => {
            return new this.Promise((resolve7, reject) => {
              return this.subscriber.subscribe(channel, () => {
                this.limiters[channel] = instance;
                return resolve7();
              });
            });
          }));
        }
        __removeLimiter__(instance) {
          var _this2 = this;
          return [
            instance.channel(),
            instance.channel_client()
          ].forEach(/* @__PURE__ */ function() {
            var _ref3 = _asyncToGenerator(function* (channel) {
              if (!_this2.terminated) {
                yield _this2.subscriber.unsubscribe(channel);
              }
              return delete _this2.limiters[channel];
            });
            return function(_x) {
              return _ref3.apply(this, arguments);
            };
          }());
        }
        __scriptArgs__(name, id, args, cb) {
          var keys;
          keys = Scripts.keys(name, id);
          return [
            keys.length
          ].concat(keys, args, cb);
        }
        __scriptFn__(name) {
          return this.client[name].bind(this.client);
        }
        disconnect(flush = true) {
          var i2, k, len, ref;
          ref = Object.keys(this.limiters);
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            k = ref[i2];
            clearInterval(this.limiters[k]._store.heartbeat);
          }
          this.limiters = {};
          this.terminated = true;
          if (flush) {
            return this.Promise.all([
              this.client.quit(),
              this.subscriber.quit()
            ]);
          } else {
            this.client.disconnect();
            this.subscriber.disconnect();
            return this.Promise.resolve();
          }
        }
      }
      ;
      IORedisConnection.prototype.datastore = "ioredis";
      IORedisConnection.prototype.defaults = {
        Redis: null,
        clientOptions: {},
        clusterNodes: null,
        client: null,
        Promise,
        Events: null
      };
      return IORedisConnection;
    }.call(void 0);
    module.exports = IORedisConnection;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/RedisDatastore.js
var require_RedisDatastore = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/RedisDatastore.js"(exports2, module2) {
    "use strict";
    function _slicedToArray2(arr, i2) {
      return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _nonIterableRest2();
    }
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit2(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var BottleneckError;
    var IORedisConnection2;
    var RedisConnection2;
    var RedisDatastore;
    var parser2;
    parser2 = require_parser();
    BottleneckError = require_BottleneckError();
    RedisConnection2 = require_RedisConnection();
    IORedisConnection2 = require_IORedisConnection();
    RedisDatastore = class RedisDatastore {
      constructor(instance, storeOptions, storeInstanceOptions) {
        this.instance = instance;
        this.storeOptions = storeOptions;
        this.originalId = this.instance.id;
        this.clientId = this.instance._randomIndex();
        parser2.load(storeInstanceOptions, storeInstanceOptions, this);
        this.clients = {};
        this.capacityPriorityCounters = {};
        this.sharedConnection = this.connection != null;
        if (this.connection == null) {
          this.connection = this.instance.datastore === "redis" ? new RedisConnection2({
            Redis: this.Redis,
            clientOptions: this.clientOptions,
            Promise: this.Promise,
            Events: this.instance.Events
          }) : this.instance.datastore === "ioredis" ? new IORedisConnection2({
            Redis: this.Redis,
            clientOptions: this.clientOptions,
            clusterNodes: this.clusterNodes,
            Promise: this.Promise,
            Events: this.instance.Events
          }) : void 0;
        }
        this.instance.connection = this.connection;
        this.instance.datastore = this.connection.datastore;
        this.ready = this.connection.ready.then((clients) => {
          this.clients = clients;
          return this.runScript("init", this.prepareInitSettings(this.clearDatastore));
        }).then(() => {
          return this.connection.__addLimiter__(this.instance);
        }).then(() => {
          return this.runScript("register_client", [
            this.instance.queued()
          ]);
        }).then(() => {
          var base4;
          if (typeof (base4 = this.heartbeat = setInterval(() => {
            return this.runScript("heartbeat", []).catch((e2) => {
              return this.instance.Events.trigger("error", e2);
            });
          }, this.heartbeatInterval)).unref === "function") {
            base4.unref();
          }
          return this.clients;
        });
      }
      __publish__(message) {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var client;
          var _ref = yield _this.ready;
          client = _ref.client;
          return client.publish(_this.instance.channel(), `message:${message.toString()}`);
        })();
      }
      onMessage(channel, message) {
        var _this2 = this;
        return _asyncToGenerator2(function* () {
          var capacity, counter, data, drained, e2, newCapacity, pos, priorityClient, rawCapacity, type;
          try {
            pos = message.indexOf(":");
            var _ref2 = [
              message.slice(0, pos),
              message.slice(pos + 1)
            ];
            type = _ref2[0];
            data = _ref2[1];
            if (type === "capacity") {
              return yield _this2.instance._drainAll(data.length > 0 ? ~~data : void 0);
            } else if (type === "capacity-priority") {
              var _data$split = data.split(":");
              var _data$split2 = _slicedToArray2(_data$split, 3);
              rawCapacity = _data$split2[0];
              priorityClient = _data$split2[1];
              counter = _data$split2[2];
              capacity = rawCapacity.length > 0 ? ~~rawCapacity : void 0;
              if (priorityClient === _this2.clientId) {
                drained = yield _this2.instance._drainAll(capacity);
                newCapacity = capacity != null ? capacity - (drained || 0) : "";
                return yield _this2.clients.client.publish(_this2.instance.channel(), `capacity-priority:${newCapacity}::${counter}`);
              } else if (priorityClient === "") {
                clearTimeout(_this2.capacityPriorityCounters[counter]);
                delete _this2.capacityPriorityCounters[counter];
                return _this2.instance._drainAll(capacity);
              } else {
                return _this2.capacityPriorityCounters[counter] = setTimeout(/* @__PURE__ */ _asyncToGenerator2(function* () {
                  var e3;
                  try {
                    delete _this2.capacityPriorityCounters[counter];
                    yield _this2.runScript("blacklist_client", [
                      priorityClient
                    ]);
                    return yield _this2.instance._drainAll(capacity);
                  } catch (error40) {
                    e3 = error40;
                    return _this2.instance.Events.trigger("error", e3);
                  }
                }), 1e3);
              }
            } else if (type === "message") {
              return _this2.instance.Events.trigger("message", data);
            } else if (type === "blocked") {
              return yield _this2.instance._dropAllQueued();
            }
          } catch (error40) {
            e2 = error40;
            return _this2.instance.Events.trigger("error", e2);
          }
        })();
      }
      __disconnect__(flush) {
        clearInterval(this.heartbeat);
        if (this.sharedConnection) {
          return this.connection.__removeLimiter__(this.instance);
        } else {
          return this.connection.disconnect(flush);
        }
      }
      runScript(name, args) {
        var _this3 = this;
        return _asyncToGenerator2(function* () {
          if (!(name === "init" || name === "register_client")) {
            yield _this3.ready;
          }
          return new _this3.Promise((resolve7, reject) => {
            var all_args, arr;
            all_args = [
              Date.now(),
              _this3.clientId
            ].concat(args);
            _this3.instance.Events.trigger("debug", `Calling Redis script: ${name}.lua`, all_args);
            arr = _this3.connection.__scriptArgs__(name, _this3.originalId, all_args, function(err, replies) {
              if (err != null) {
                return reject(err);
              }
              return resolve7(replies);
            });
            return _this3.connection.__scriptFn__(name)(...arr);
          }).catch((e2) => {
            if (e2.message === "SETTINGS_KEY_NOT_FOUND") {
              if (name === "heartbeat") {
                return _this3.Promise.resolve();
              } else {
                return _this3.runScript("init", _this3.prepareInitSettings(false)).then(() => {
                  return _this3.runScript(name, args);
                });
              }
            } else if (e2.message === "UNKNOWN_CLIENT") {
              return _this3.runScript("register_client", [
                _this3.instance.queued()
              ]).then(() => {
                return _this3.runScript(name, args);
              });
            } else {
              return _this3.Promise.reject(e2);
            }
          });
        })();
      }
      prepareArray(arr) {
        var i2, len, results, x3;
        results = [];
        for (i2 = 0, len = arr.length; i2 < len; i2++) {
          x3 = arr[i2];
          results.push(x3 != null ? x3.toString() : "");
        }
        return results;
      }
      prepareObject(obj) {
        var arr, k, v2;
        arr = [];
        for (k in obj) {
          v2 = obj[k];
          arr.push(k, v2 != null ? v2.toString() : "");
        }
        return arr;
      }
      prepareInitSettings(clear) {
        var args;
        args = this.prepareObject(Object.assign({}, this.storeOptions, {
          id: this.originalId,
          version: this.instance.version,
          groupTimeout: this.timeout,
          clientTimeout: this.clientTimeout
        }));
        args.unshift(clear ? 1 : 0, this.instance.version);
        return args;
      }
      convertBool(b) {
        return !!b;
      }
      __updateSettings__(options3) {
        var _this4 = this;
        return _asyncToGenerator2(function* () {
          yield _this4.runScript("update_settings", _this4.prepareObject(options3));
          return parser2.overwrite(options3, options3, _this4.storeOptions);
        })();
      }
      __running__() {
        return this.runScript("running", []);
      }
      __queued__() {
        return this.runScript("queued", []);
      }
      __done__() {
        return this.runScript("done", []);
      }
      __groupCheck__() {
        var _this5 = this;
        return _asyncToGenerator2(function* () {
          return _this5.convertBool(yield _this5.runScript("group_check", []));
        })();
      }
      __incrementReservoir__(incr) {
        return this.runScript("increment_reservoir", [
          incr
        ]);
      }
      __currentReservoir__() {
        return this.runScript("current_reservoir", []);
      }
      __check__(weight) {
        var _this6 = this;
        return _asyncToGenerator2(function* () {
          return _this6.convertBool(yield _this6.runScript("check", _this6.prepareArray([
            weight
          ])));
        })();
      }
      __register__(index, weight, expiration) {
        var _this7 = this;
        return _asyncToGenerator2(function* () {
          var reservoir, success2, wait;
          var _ref4 = yield _this7.runScript("register", _this7.prepareArray([
            index,
            weight,
            expiration
          ]));
          var _ref5 = _slicedToArray2(_ref4, 3);
          success2 = _ref5[0];
          wait = _ref5[1];
          reservoir = _ref5[2];
          return {
            success: _this7.convertBool(success2),
            wait,
            reservoir
          };
        })();
      }
      __submit__(queueLength, weight) {
        var _this8 = this;
        return _asyncToGenerator2(function* () {
          var blocked, e2, maxConcurrent, overweight, reachedHWM, strategy;
          try {
            var _ref6 = yield _this8.runScript("submit", _this8.prepareArray([
              queueLength,
              weight
            ]));
            var _ref7 = _slicedToArray2(_ref6, 3);
            reachedHWM = _ref7[0];
            blocked = _ref7[1];
            strategy = _ref7[2];
            return {
              reachedHWM: _this8.convertBool(reachedHWM),
              blocked: _this8.convertBool(blocked),
              strategy
            };
          } catch (error40) {
            e2 = error40;
            if (e2.message.indexOf("OVERWEIGHT") === 0) {
              var _e$message$split = e2.message.split(":");
              var _e$message$split2 = _slicedToArray2(_e$message$split, 3);
              overweight = _e$message$split2[0];
              weight = _e$message$split2[1];
              maxConcurrent = _e$message$split2[2];
              throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${maxConcurrent}`);
            } else {
              throw e2;
            }
          }
        })();
      }
      __free__(index, weight) {
        var _this9 = this;
        return _asyncToGenerator2(function* () {
          var running;
          running = yield _this9.runScript("free", _this9.prepareArray([
            index
          ]));
          return {
            running
          };
        })();
      }
    };
    module2.exports = RedisDatastore;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/States.js
var require_States = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/States.js"(exports2, module2) {
    "use strict";
    var BottleneckError;
    var States;
    BottleneckError = require_BottleneckError();
    States = class States {
      constructor(status1) {
        this.status = status1;
        this._jobs = {};
        this.counts = this.status.map(function() {
          return 0;
        });
      }
      next(id) {
        var current, next;
        current = this._jobs[id];
        next = current + 1;
        if (current != null && next < this.status.length) {
          this.counts[current]--;
          this.counts[next]++;
          return this._jobs[id]++;
        } else if (current != null) {
          this.counts[current]--;
          return delete this._jobs[id];
        }
      }
      start(id) {
        var initial;
        initial = 0;
        this._jobs[id] = initial;
        return this.counts[initial]++;
      }
      remove(id) {
        var current;
        current = this._jobs[id];
        if (current != null) {
          this.counts[current]--;
          delete this._jobs[id];
        }
        return current != null;
      }
      jobStatus(id) {
        var ref;
        return (ref = this.status[this._jobs[id]]) != null ? ref : null;
      }
      statusJobs(status) {
        var k, pos, ref, results, v2;
        if (status != null) {
          pos = this.status.indexOf(status);
          if (pos < 0) {
            throw new BottleneckError(`status must be one of ${this.status.join(", ")}`);
          }
          ref = this._jobs;
          results = [];
          for (k in ref) {
            v2 = ref[k];
            if (v2 === pos) {
              results.push(k);
            }
          }
          return results;
        } else {
          return Object.keys(this._jobs);
        }
      }
      statusCounts() {
        return this.counts.reduce((acc, v2, i2) => {
          acc[this.status[i2]] = v2;
          return acc;
        }, {});
      }
    };
    module2.exports = States;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Sync.js
var require_Sync = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Sync.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var DLList;
    var Sync;
    DLList = require_DLList();
    Sync = class Sync {
      constructor(name, Promise2) {
        this.schedule = this.schedule.bind(this);
        this.name = name;
        this.Promise = Promise2;
        this._running = 0;
        this._queue = new DLList();
      }
      isEmpty() {
        return this._queue.length === 0;
      }
      _tryToRun() {
        var _this = this;
        return _asyncToGenerator2(function* () {
          var args, cb, error40, reject, resolve7, returned, task;
          if (_this._running < 1 && _this._queue.length > 0) {
            _this._running++;
            var _this$_queue$shift = _this._queue.shift();
            task = _this$_queue$shift.task;
            args = _this$_queue$shift.args;
            resolve7 = _this$_queue$shift.resolve;
            reject = _this$_queue$shift.reject;
            cb = yield _asyncToGenerator2(function* () {
              try {
                returned = yield task(...args);
                return function() {
                  return resolve7(returned);
                };
              } catch (error1) {
                error40 = error1;
                return function() {
                  return reject(error40);
                };
              }
            })();
            _this._running--;
            _this._tryToRun();
            return cb();
          }
        })();
      }
      schedule(task, ...args) {
        var promise2, reject, resolve7;
        resolve7 = reject = null;
        promise2 = new this.Promise(function(_resolve, _reject) {
          resolve7 = _resolve;
          return reject = _reject;
        });
        this._queue.push({
          task,
          args,
          resolve: resolve7,
          reject
        });
        this._tryToRun();
        return promise2;
      }
    };
    module2.exports = Sync;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/version.json
var require_version2 = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/version.json"(exports2, module2) {
    module2.exports = { version: "2.19.5" };
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Group.js
var require_Group = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Group.js"(exports2, module2) {
    "use strict";
    function _slicedToArray2(arr, i2) {
      return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _nonIterableRest2();
    }
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit2(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Events2;
    var Group;
    var IORedisConnection2;
    var RedisConnection2;
    var Scripts2;
    var parser2;
    parser2 = require_parser();
    Events2 = require_Events();
    RedisConnection2 = require_RedisConnection();
    IORedisConnection2 = require_IORedisConnection();
    Scripts2 = require_Scripts();
    Group = function() {
      class Group2 {
        constructor(limiterOptions = {}) {
          this.deleteKey = this.deleteKey.bind(this);
          this.limiterOptions = limiterOptions;
          parser2.load(this.limiterOptions, this.defaults, this);
          this.Events = new Events2(this);
          this.instances = {};
          this.Bottleneck = require_Bottleneck();
          this._startAutoCleanup();
          this.sharedConnection = this.connection != null;
          if (this.connection == null) {
            if (this.limiterOptions.datastore === "redis") {
              this.connection = new RedisConnection2(Object.assign({}, this.limiterOptions, {
                Events: this.Events
              }));
            } else if (this.limiterOptions.datastore === "ioredis") {
              this.connection = new IORedisConnection2(Object.assign({}, this.limiterOptions, {
                Events: this.Events
              }));
            }
          }
        }
        key(key = "") {
          var ref;
          return (ref = this.instances[key]) != null ? ref : (() => {
            var limiter;
            limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
              id: `${this.id}-${key}`,
              timeout: this.timeout,
              connection: this.connection
            }));
            this.Events.trigger("created", limiter, key);
            return limiter;
          })();
        }
        deleteKey(key = "") {
          var _this = this;
          return _asyncToGenerator2(function* () {
            var deleted, instance;
            instance = _this.instances[key];
            if (_this.connection) {
              deleted = yield _this.connection.__runCommand__([
                "del",
                ...Scripts2.allKeys(`${_this.id}-${key}`)
              ]);
            }
            if (instance != null) {
              delete _this.instances[key];
              yield instance.disconnect();
            }
            return instance != null || deleted > 0;
          })();
        }
        limiters() {
          var k, ref, results, v2;
          ref = this.instances;
          results = [];
          for (k in ref) {
            v2 = ref[k];
            results.push({
              key: k,
              limiter: v2
            });
          }
          return results;
        }
        keys() {
          return Object.keys(this.instances);
        }
        clusterKeys() {
          var _this2 = this;
          return _asyncToGenerator2(function* () {
            var cursor, end, found, i2, k, keys, len, next, start;
            if (_this2.connection == null) {
              return _this2.Promise.resolve(_this2.keys());
            }
            keys = [];
            cursor = null;
            start = `b_${_this2.id}-`.length;
            end = "_settings".length;
            while (cursor !== 0) {
              var _ref = yield _this2.connection.__runCommand__([
                "scan",
                cursor != null ? cursor : 0,
                "match",
                `b_${_this2.id}-*_settings`,
                "count",
                1e4
              ]);
              var _ref2 = _slicedToArray2(_ref, 2);
              next = _ref2[0];
              found = _ref2[1];
              cursor = ~~next;
              for (i2 = 0, len = found.length; i2 < len; i2++) {
                k = found[i2];
                keys.push(k.slice(start, -end));
              }
            }
            return keys;
          })();
        }
        _startAutoCleanup() {
          var _this3 = this;
          var base4;
          clearInterval(this.interval);
          return typeof (base4 = this.interval = setInterval(/* @__PURE__ */ _asyncToGenerator2(function* () {
            var e2, k, ref, results, time3, v2;
            time3 = Date.now();
            ref = _this3.instances;
            results = [];
            for (k in ref) {
              v2 = ref[k];
              try {
                if (yield v2._store.__groupCheck__(time3)) {
                  results.push(_this3.deleteKey(k));
                } else {
                  results.push(void 0);
                }
              } catch (error40) {
                e2 = error40;
                results.push(v2.Events.trigger("error", e2));
              }
            }
            return results;
          }), this.timeout / 2)).unref === "function" ? base4.unref() : void 0;
        }
        updateSettings(options3 = {}) {
          parser2.overwrite(options3, this.defaults, this);
          parser2.overwrite(options3, options3, this.limiterOptions);
          if (options3.timeout != null) {
            return this._startAutoCleanup();
          }
        }
        disconnect(flush = true) {
          var ref;
          if (!this.sharedConnection) {
            return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
          }
        }
      }
      ;
      Group2.prototype.defaults = {
        timeout: 1e3 * 60 * 5,
        connection: null,
        Promise,
        id: "group-key"
      };
      return Group2;
    }.call(void 0);
    module2.exports = Group;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Batcher.js
var require_Batcher = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Batcher.js"(exports2, module2) {
    "use strict";
    var Batcher;
    var Events2;
    var parser2;
    parser2 = require_parser();
    Events2 = require_Events();
    Batcher = function() {
      class Batcher2 {
        constructor(options3 = {}) {
          this.options = options3;
          parser2.load(this.options, this.defaults, this);
          this.Events = new Events2(this);
          this._arr = [];
          this._resetPromise();
          this._lastFlush = Date.now();
        }
        _resetPromise() {
          return this._promise = new this.Promise((res, rej) => {
            return this._resolve = res;
          });
        }
        _flush() {
          clearTimeout(this._timeout);
          this._lastFlush = Date.now();
          this._resolve();
          this.Events.trigger("batch", this._arr);
          this._arr = [];
          return this._resetPromise();
        }
        add(data) {
          var ret;
          this._arr.push(data);
          ret = this._promise;
          if (this._arr.length === this.maxSize) {
            this._flush();
          } else if (this.maxTime != null && this._arr.length === 1) {
            this._timeout = setTimeout(() => {
              return this._flush();
            }, this.maxTime);
          }
          return ret;
        }
      }
      ;
      Batcher2.prototype.defaults = {
        maxTime: null,
        maxSize: null,
        Promise
      };
      return Batcher2;
    }.call(void 0);
    module2.exports = Batcher;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Bottleneck.js
var require_Bottleneck = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/Bottleneck.js"(exports2, module2) {
    "use strict";
    function _slicedToArray2(arr, i2) {
      return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _nonIterableRest2();
    }
    function _iterableToArrayLimit2(arr, i2) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _toArray(arr) {
      return _arrayWithHoles2(arr) || _iterableToArray(arr) || _nonIterableRest2();
    }
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error40) {
        reject(error40);
        return;
      }
      if (info.done) {
        resolve7(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator2(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep2(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var Bottleneck;
    var DEFAULT_PRIORITY;
    var Events2;
    var Job;
    var LocalDatastore;
    var NUM_PRIORITIES;
    var Queues;
    var RedisDatastore;
    var States;
    var Sync;
    var parser2;
    var splice = [].splice;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser2 = require_parser();
    Queues = require_Queues();
    Job = require_Job();
    LocalDatastore = require_LocalDatastore();
    RedisDatastore = require_RedisDatastore();
    Events2 = require_Events();
    States = require_States();
    Sync = require_Sync();
    Bottleneck = function() {
      class Bottleneck2 {
        constructor(options3 = {}, ...invalid) {
          var storeInstanceOptions, storeOptions;
          this._addToQueue = this._addToQueue.bind(this);
          this._validateOptions(options3, invalid);
          parser2.load(options3, this.instanceDefaults, this);
          this._queues = new Queues(NUM_PRIORITIES);
          this._scheduled = {};
          this._states = new States([
            "RECEIVED",
            "QUEUED",
            "RUNNING",
            "EXECUTING"
          ].concat(this.trackDoneStatus ? [
            "DONE"
          ] : []));
          this._limiter = null;
          this.Events = new Events2(this);
          this._submitLock = new Sync("submit", this.Promise);
          this._registerLock = new Sync("register", this.Promise);
          storeOptions = parser2.load(options3, this.storeDefaults, {});
          this._store = function() {
            if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
              storeInstanceOptions = parser2.load(options3, this.redisStoreDefaults, {});
              return new RedisDatastore(this, storeOptions, storeInstanceOptions);
            } else if (this.datastore === "local") {
              storeInstanceOptions = parser2.load(options3, this.localStoreDefaults, {});
              return new LocalDatastore(this, storeOptions, storeInstanceOptions);
            } else {
              throw new Bottleneck2.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
            }
          }.call(this);
          this._queues.on("leftzero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
          });
          this._queues.on("zero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
          });
        }
        _validateOptions(options3, invalid) {
          if (!(options3 != null && typeof options3 === "object" && invalid.length === 0)) {
            throw new Bottleneck2.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
          }
        }
        ready() {
          return this._store.ready;
        }
        clients() {
          return this._store.clients;
        }
        channel() {
          return `b_${this.id}`;
        }
        channel_client() {
          return `b_${this.id}_${this._store.clientId}`;
        }
        publish(message) {
          return this._store.__publish__(message);
        }
        disconnect(flush = true) {
          return this._store.__disconnect__(flush);
        }
        chain(_limiter) {
          this._limiter = _limiter;
          return this;
        }
        queued(priority) {
          return this._queues.queued(priority);
        }
        clusterQueued() {
          return this._store.__queued__();
        }
        empty() {
          return this.queued() === 0 && this._submitLock.isEmpty();
        }
        running() {
          return this._store.__running__();
        }
        done() {
          return this._store.__done__();
        }
        jobStatus(id) {
          return this._states.jobStatus(id);
        }
        jobs(status) {
          return this._states.statusJobs(status);
        }
        counts() {
          return this._states.statusCounts();
        }
        _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
        check(weight = 1) {
          return this._store.__check__(weight);
        }
        _clearGlobalState(index) {
          if (this._scheduled[index] != null) {
            clearTimeout(this._scheduled[index].expiration);
            delete this._scheduled[index];
            return true;
          } else {
            return false;
          }
        }
        _free(index, job, options3, eventInfo) {
          var _this = this;
          return _asyncToGenerator2(function* () {
            var e2, running;
            try {
              var _ref = yield _this._store.__free__(index, options3.weight);
              running = _ref.running;
              _this.Events.trigger("debug", `Freed ${options3.id}`, eventInfo);
              if (running === 0 && _this.empty()) {
                return _this.Events.trigger("idle");
              }
            } catch (error1) {
              e2 = error1;
              return _this.Events.trigger("error", e2);
            }
          })();
        }
        _run(index, job, wait) {
          var clearGlobalState, free, run3;
          job.doRun();
          clearGlobalState = this._clearGlobalState.bind(this, index);
          run3 = this._run.bind(this, index, job);
          free = this._free.bind(this, index, job);
          return this._scheduled[index] = {
            timeout: setTimeout(() => {
              return job.doExecute(this._limiter, clearGlobalState, run3, free);
            }, wait),
            expiration: job.options.expiration != null ? setTimeout(function() {
              return job.doExpire(clearGlobalState, run3, free);
            }, wait + job.options.expiration) : void 0,
            job
          };
        }
        _drainOne(capacity) {
          return this._registerLock.schedule(() => {
            var args, index, next, options3, queue;
            if (this.queued() === 0) {
              return this.Promise.resolve(null);
            }
            queue = this._queues.getFirst();
            var _next2 = next = queue.first();
            options3 = _next2.options;
            args = _next2.args;
            if (capacity != null && options3.weight > capacity) {
              return this.Promise.resolve(null);
            }
            this.Events.trigger("debug", `Draining ${options3.id}`, {
              args,
              options: options3
            });
            index = this._randomIndex();
            return this._store.__register__(index, options3.weight, options3.expiration).then(({ success: success2, wait, reservoir }) => {
              var empty4;
              this.Events.trigger("debug", `Drained ${options3.id}`, {
                success: success2,
                args,
                options: options3
              });
              if (success2) {
                queue.shift();
                empty4 = this.empty();
                if (empty4) {
                  this.Events.trigger("empty");
                }
                if (reservoir === 0) {
                  this.Events.trigger("depleted", empty4);
                }
                this._run(index, next, wait);
                return this.Promise.resolve(options3.weight);
              } else {
                return this.Promise.resolve(null);
              }
            });
          });
        }
        _drainAll(capacity, total = 0) {
          return this._drainOne(capacity).then((drained) => {
            var newCapacity;
            if (drained != null) {
              newCapacity = capacity != null ? capacity - drained : capacity;
              return this._drainAll(newCapacity, total + drained);
            } else {
              return this.Promise.resolve(total);
            }
          }).catch((e2) => {
            return this.Events.trigger("error", e2);
          });
        }
        _dropAllQueued(message) {
          return this._queues.shiftAll(function(job) {
            return job.doDrop({
              message
            });
          });
        }
        stop(options3 = {}) {
          var done, waitForExecuting;
          options3 = parser2.load(options3, this.stopDefaults);
          waitForExecuting = (at) => {
            var finished;
            finished = () => {
              var counts;
              counts = this._states.counts;
              return counts[0] + counts[1] + counts[2] + counts[3] === at;
            };
            return new this.Promise((resolve7, reject) => {
              if (finished()) {
                return resolve7();
              } else {
                return this.on("done", () => {
                  if (finished()) {
                    this.removeAllListeners("done");
                    return resolve7();
                  }
                });
              }
            });
          };
          done = options3.dropWaitingJobs ? (this._run = function(index, next) {
            return next.doDrop({
              message: options3.dropErrorMessage
            });
          }, this._drainOne = () => {
            return this.Promise.resolve(null);
          }, this._registerLock.schedule(() => {
            return this._submitLock.schedule(() => {
              var k, ref, v2;
              ref = this._scheduled;
              for (k in ref) {
                v2 = ref[k];
                if (this.jobStatus(v2.job.options.id) === "RUNNING") {
                  clearTimeout(v2.timeout);
                  clearTimeout(v2.expiration);
                  v2.job.doDrop({
                    message: options3.dropErrorMessage
                  });
                }
              }
              this._dropAllQueued(options3.dropErrorMessage);
              return waitForExecuting(0);
            });
          })) : this.schedule({
            priority: NUM_PRIORITIES - 1,
            weight: 0
          }, () => {
            return waitForExecuting(1);
          });
          this._receive = function(job) {
            return job._reject(new Bottleneck2.prototype.BottleneckError(options3.enqueueErrorMessage));
          };
          this.stop = () => {
            return this.Promise.reject(new Bottleneck2.prototype.BottleneckError("stop() has already been called"));
          };
          return done;
        }
        _addToQueue(job) {
          var _this2 = this;
          return _asyncToGenerator2(function* () {
            var args, blocked, error40, options3, reachedHWM, shifted, strategy;
            args = job.args;
            options3 = job.options;
            try {
              var _ref2 = yield _this2._store.__submit__(_this2.queued(), options3.weight);
              reachedHWM = _ref2.reachedHWM;
              blocked = _ref2.blocked;
              strategy = _ref2.strategy;
            } catch (error1) {
              error40 = error1;
              _this2.Events.trigger("debug", `Could not queue ${options3.id}`, {
                args,
                options: options3,
                error: error40
              });
              job.doDrop({
                error: error40
              });
              return false;
            }
            if (blocked) {
              job.doDrop();
              return true;
            } else if (reachedHWM) {
              shifted = strategy === Bottleneck2.prototype.strategy.LEAK ? _this2._queues.shiftLastFrom(options3.priority) : strategy === Bottleneck2.prototype.strategy.OVERFLOW_PRIORITY ? _this2._queues.shiftLastFrom(options3.priority + 1) : strategy === Bottleneck2.prototype.strategy.OVERFLOW ? job : void 0;
              if (shifted != null) {
                shifted.doDrop();
              }
              if (shifted == null || strategy === Bottleneck2.prototype.strategy.OVERFLOW) {
                if (shifted == null) {
                  job.doDrop();
                }
                return reachedHWM;
              }
            }
            job.doQueue(reachedHWM, blocked);
            _this2._queues.push(job);
            yield _this2._drainAll();
            return reachedHWM;
          })();
        }
        _receive(job) {
          if (this._states.jobStatus(job.options.id) != null) {
            job._reject(new Bottleneck2.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
            return false;
          } else {
            job.doReceive();
            return this._submitLock.schedule(this._addToQueue, job);
          }
        }
        submit(...args) {
          var cb, fn, job, options3, ref, ref1, task;
          if (typeof args[0] === "function") {
            var _ref3, _ref4, _splice$call, _splice$call2;
            ref = args, _ref3 = ref, _ref4 = _toArray(_ref3), fn = _ref4[0], args = _ref4.slice(1), _ref3, _splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray2(_splice$call, 1), cb = _splice$call2[0], _splice$call;
            options3 = parser2.load({}, this.jobDefaults);
          } else {
            var _ref5, _ref6, _splice$call3, _splice$call4;
            ref1 = args, _ref5 = ref1, _ref6 = _toArray(_ref5), options3 = _ref6[0], fn = _ref6[1], args = _ref6.slice(2), _ref5, _splice$call3 = splice.call(args, -1), _splice$call4 = _slicedToArray2(_splice$call3, 1), cb = _splice$call4[0], _splice$call3;
            options3 = parser2.load(options3, this.jobDefaults);
          }
          task = (...args2) => {
            return new this.Promise(function(resolve7, reject) {
              return fn(...args2, function(...args3) {
                return (args3[0] != null ? reject : resolve7)(args3);
              });
            });
          };
          job = new Job(task, args, options3, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          job.promise.then(function(args2) {
            return typeof cb === "function" ? cb(...args2) : void 0;
          }).catch(function(args2) {
            if (Array.isArray(args2)) {
              return typeof cb === "function" ? cb(...args2) : void 0;
            } else {
              return typeof cb === "function" ? cb(args2) : void 0;
            }
          });
          return this._receive(job);
        }
        schedule(...args) {
          var job, options3, task;
          if (typeof args[0] === "function") {
            var _args = args;
            var _args2 = _toArray(_args);
            task = _args2[0];
            args = _args2.slice(1);
            options3 = {};
          } else {
            var _args3 = args;
            var _args4 = _toArray(_args3);
            options3 = _args4[0];
            task = _args4[1];
            args = _args4.slice(2);
          }
          job = new Job(task, args, options3, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
          this._receive(job);
          return job.promise;
        }
        wrap(fn) {
          var schedule, wrapped;
          schedule = this.schedule.bind(this);
          wrapped = function wrapped2(...args) {
            return schedule(fn.bind(this), ...args);
          };
          wrapped.withOptions = function(options3, ...args) {
            return schedule(options3, fn, ...args);
          };
          return wrapped;
        }
        updateSettings(options3 = {}) {
          var _this3 = this;
          return _asyncToGenerator2(function* () {
            yield _this3._store.__updateSettings__(parser2.overwrite(options3, _this3.storeDefaults));
            parser2.overwrite(options3, _this3.instanceDefaults, _this3);
            return _this3;
          })();
        }
        currentReservoir() {
          return this._store.__currentReservoir__();
        }
        incrementReservoir(incr = 0) {
          return this._store.__incrementReservoir__(incr);
        }
      }
      ;
      Bottleneck2.default = Bottleneck2;
      Bottleneck2.Events = Events2;
      Bottleneck2.version = Bottleneck2.prototype.version = require_version2().version;
      Bottleneck2.strategy = Bottleneck2.prototype.strategy = {
        LEAK: 1,
        OVERFLOW: 2,
        OVERFLOW_PRIORITY: 4,
        BLOCK: 3
      };
      Bottleneck2.BottleneckError = Bottleneck2.prototype.BottleneckError = require_BottleneckError();
      Bottleneck2.Group = Bottleneck2.prototype.Group = require_Group();
      Bottleneck2.RedisConnection = Bottleneck2.prototype.RedisConnection = require_RedisConnection();
      Bottleneck2.IORedisConnection = Bottleneck2.prototype.IORedisConnection = require_IORedisConnection();
      Bottleneck2.Batcher = Bottleneck2.prototype.Batcher = require_Batcher();
      Bottleneck2.prototype.jobDefaults = {
        priority: DEFAULT_PRIORITY,
        weight: 1,
        expiration: null,
        id: "<no-id>"
      };
      Bottleneck2.prototype.storeDefaults = {
        maxConcurrent: null,
        minTime: 0,
        highWater: null,
        strategy: Bottleneck2.prototype.strategy.LEAK,
        penalty: null,
        reservoir: null,
        reservoirRefreshInterval: null,
        reservoirRefreshAmount: null,
        reservoirIncreaseInterval: null,
        reservoirIncreaseAmount: null,
        reservoirIncreaseMaximum: null
      };
      Bottleneck2.prototype.localStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 250
      };
      Bottleneck2.prototype.redisStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 5e3,
        clientTimeout: 1e4,
        Redis: null,
        clientOptions: {},
        clusterNodes: null,
        clearDatastore: false,
        connection: null
      };
      Bottleneck2.prototype.instanceDefaults = {
        datastore: "local",
        connection: null,
        id: "<no-id>",
        rejectOnDrop: true,
        trackDoneStatus: false,
        Promise
      };
      Bottleneck2.prototype.stopDefaults = {
        enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
        dropWaitingJobs: true,
        dropErrorMessage: "This limiter has been stopped."
      };
      return Bottleneck2;
    }.call(void 0);
    module2.exports = Bottleneck;
  }
});

// node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/index.js
var require_lib34 = __commonJS({
  "node_modules/.deno/bottleneck@2.19.5/node_modules/bottleneck/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_Bottleneck();
  }
});

// node_modules/.deno/scrypt-async@2.0.1/node_modules/scrypt-async/scrypt-async.js
var require_scrypt_async = __commonJS({
  "node_modules/.deno/scrypt-async@2.0.1/node_modules/scrypt-async/scrypt-async.js"(exports2, module2) {
    function scrypt3(password, salt, logN, r, dkLen, interruptStep, callback, encoding) {
      "use strict";
      function SHA256(m3) {
        var K3 = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225, w4 = new Array(64);
        function blocks(p3) {
          var off = 0, len = p3.length;
          while (len >= 64) {
            var a = h0, b = h1, c = h2, d = h3, e2 = h4, f = h5, g2 = h6, h8 = h7, u2, i3, j, t1, t2;
            for (i3 = 0; i3 < 16; i3++) {
              j = off + i3 * 4;
              w4[i3] = (p3[j] & 255) << 24 | (p3[j + 1] & 255) << 16 | (p3[j + 2] & 255) << 8 | p3[j + 3] & 255;
            }
            for (i3 = 16; i3 < 64; i3++) {
              u2 = w4[i3 - 2];
              t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
              u2 = w4[i3 - 15];
              t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
              w4[i3] = (t1 + w4[i3 - 7] | 0) + (t2 + w4[i3 - 16] | 0) | 0;
            }
            for (i3 = 0; i3 < 64; i3++) {
              t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f ^ ~e2 & g2) | 0) + (h8 + (K3[i3] + w4[i3] | 0) | 0) | 0;
              t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
              h8 = g2;
              g2 = f;
              f = e2;
              e2 = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            h0 = h0 + a | 0;
            h1 = h1 + b | 0;
            h2 = h2 + c | 0;
            h3 = h3 + d | 0;
            h4 = h4 + e2 | 0;
            h5 = h5 + f | 0;
            h6 = h6 + g2 | 0;
            h7 = h7 + h8 | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m3);
        var i2, bytesLeft = m3.length % 64, bitLenHi = m3.length / 536870912 | 0, bitLenLo = m3.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m3.slice(m3.length - bytesLeft, m3.length);
        p2.push(128);
        for (i2 = bytesLeft + 1; i2 < numZeros; i2++) p2.push(0);
        p2.push(bitLenHi >>> 24 & 255);
        p2.push(bitLenHi >>> 16 & 255);
        p2.push(bitLenHi >>> 8 & 255);
        p2.push(bitLenHi >>> 0 & 255);
        p2.push(bitLenLo >>> 24 & 255);
        p2.push(bitLenLo >>> 16 & 255);
        p2.push(bitLenLo >>> 8 & 255);
        p2.push(bitLenLo >>> 0 & 255);
        blocks(p2);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password2, salt2, dkLen2) {
        if (password2.length > 64) {
          password2 = SHA256(password2.push ? password2 : Array.prototype.slice.call(password2, 0));
        }
        var i2, innerLen = 64 + salt2.length + 4, inner = new Array(innerLen), outerKey = new Array(64), dk = [];
        for (i2 = 0; i2 < 64; i2++) inner[i2] = 54;
        for (i2 = 0; i2 < password2.length; i2++) inner[i2] ^= password2[i2];
        for (i2 = 0; i2 < salt2.length; i2++) inner[64 + i2] = salt2[i2];
        for (i2 = innerLen - 4; i2 < innerLen; i2++) inner[i2] = 0;
        for (i2 = 0; i2 < 64; i2++) outerKey[i2] = 92;
        for (i2 = 0; i2 < password2.length; i2++) outerKey[i2] ^= password2[i2];
        function incrementCounter() {
          for (var i3 = innerLen - 1; i3 >= innerLen - 4; i3--) {
            inner[i3]++;
            if (inner[i3] <= 255) return;
            inner[i3] = 0;
          }
        }
        while (dkLen2 >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen2 -= 32;
        }
        if (dkLen2 > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen2));
        }
        return dk;
      }
      function salsaXOR(tmp2, B5, bin, bout) {
        var j0 = tmp2[0] ^ B5[bin++], j1 = tmp2[1] ^ B5[bin++], j2 = tmp2[2] ^ B5[bin++], j3 = tmp2[3] ^ B5[bin++], j4 = tmp2[4] ^ B5[bin++], j5 = tmp2[5] ^ B5[bin++], j6 = tmp2[6] ^ B5[bin++], j7 = tmp2[7] ^ B5[bin++], j8 = tmp2[8] ^ B5[bin++], j9 = tmp2[9] ^ B5[bin++], j10 = tmp2[10] ^ B5[bin++], j11 = tmp2[11] ^ B5[bin++], j12 = tmp2[12] ^ B5[bin++], j13 = tmp2[13] ^ B5[bin++], j14 = tmp2[14] ^ B5[bin++], j15 = tmp2[15] ^ B5[bin++], u2, i2;
        var x0 = j0, x1 = j1, x22 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15;
        for (i2 = 0; i2 < 8; i2 += 2) {
          u2 = x0 + x12;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x22;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        B5[bout++] = tmp2[0] = x0 + j0 | 0;
        B5[bout++] = tmp2[1] = x1 + j1 | 0;
        B5[bout++] = tmp2[2] = x22 + j2 | 0;
        B5[bout++] = tmp2[3] = x3 + j3 | 0;
        B5[bout++] = tmp2[4] = x4 + j4 | 0;
        B5[bout++] = tmp2[5] = x5 + j5 | 0;
        B5[bout++] = tmp2[6] = x6 + j6 | 0;
        B5[bout++] = tmp2[7] = x7 + j7 | 0;
        B5[bout++] = tmp2[8] = x8 + j8 | 0;
        B5[bout++] = tmp2[9] = x9 + j9 | 0;
        B5[bout++] = tmp2[10] = x10 + j10 | 0;
        B5[bout++] = tmp2[11] = x11 + j11 | 0;
        B5[bout++] = tmp2[12] = x12 + j12 | 0;
        B5[bout++] = tmp2[13] = x13 + j13 | 0;
        B5[bout++] = tmp2[14] = x14 + j14 | 0;
        B5[bout++] = tmp2[15] = x15 + j15 | 0;
      }
      function blockCopy(dst, di, src4, si, len) {
        while (len--) dst[di++] = src4[si++];
      }
      function blockXOR(dst, di, src4, si, len) {
        while (len--) dst[di++] ^= src4[si++];
      }
      function blockMix(tmp2, B5, bin, bout, r2) {
        blockCopy(tmp2, 0, B5, bin + (2 * r2 - 1) * 16, 16);
        for (var i2 = 0; i2 < 2 * r2; i2 += 2) {
          salsaXOR(tmp2, B5, bin + i2 * 16, bout + i2 * 8);
          salsaXOR(tmp2, B5, bin + i2 * 16 + 16, bout + i2 * 8 + r2 * 16);
        }
      }
      function integerify(B5, bi, r2) {
        return B5[bi + (2 * r2 - 1) * 16];
      }
      function stringToUTF8Bytes(s) {
        var arr = [];
        for (var i2 = 0; i2 < s.length; i2++) {
          var c = s.charCodeAt(i2);
          if (c < 128) {
            arr.push(c);
          } else if (c < 2048) {
            arr.push(192 | c >> 6);
            arr.push(128 | c & 63);
          } else if (c < 55296) {
            arr.push(224 | c >> 12);
            arr.push(128 | c >> 6 & 63);
            arr.push(128 | c & 63);
          } else {
            if (i2 >= s.length - 1) {
              throw new Error("invalid string");
            }
            i2++;
            c = (c & 1023) << 10;
            c |= s.charCodeAt(i2) & 1023;
            c += 65536;
            arr.push(240 | c >> 18);
            arr.push(128 | c >> 12 & 63);
            arr.push(128 | c >> 6 & 63);
            arr.push(128 | c & 63);
          }
        }
        return arr;
      }
      function bytesToHex(p2) {
        var enc = "0123456789abcdef".split("");
        var len = p2.length, arr = [], i2 = 0;
        for (; i2 < len; i2++) {
          arr.push(enc[p2[i2] >>> 4 & 15]);
          arr.push(enc[p2[i2] >>> 0 & 15]);
        }
        return arr.join("");
      }
      function bytesToBase64(p2) {
        var enc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        var len = p2.length, arr = [], i2 = 0, a, b, c, t;
        while (i2 < len) {
          a = i2 < len ? p2[i2++] : 0;
          b = i2 < len ? p2[i2++] : 0;
          c = i2 < len ? p2[i2++] : 0;
          t = (a << 16) + (b << 8) + c;
          arr.push(enc[t >>> 3 * 6 & 63]);
          arr.push(enc[t >>> 2 * 6 & 63]);
          arr.push(enc[t >>> 1 * 6 & 63]);
          arr.push(enc[t >>> 0 * 6 & 63]);
        }
        if (len % 3 > 0) {
          arr[arr.length - 1] = "=";
          if (len % 3 === 1) arr[arr.length - 2] = "=";
        }
        return arr.join("");
      }
      var MAX_UINT = -1 >>> 0, p = 1;
      if (typeof logN === "object") {
        if (arguments.length > 4) {
          throw new Error("scrypt: incorrect number of arguments");
        }
        var opts = logN;
        callback = r;
        logN = opts.logN;
        if (typeof logN === "undefined") {
          if (typeof opts.N !== "undefined") {
            if (opts.N < 2 || opts.N > MAX_UINT) throw new Error("scrypt: N is out of range");
            if ((opts.N & opts.N - 1) !== 0) throw new Error("scrypt: N is not a power of 2");
            logN = Math.log(opts.N) / Math.LN2;
          } else {
            throw new Error("scrypt: missing N parameter");
          }
        }
        p = opts.p || 1;
        r = opts.r;
        dkLen = opts.dkLen || 32;
        interruptStep = opts.interruptStep || 0;
        encoding = opts.encoding;
      }
      if (p < 1) throw new Error("scrypt: invalid p");
      if (r <= 0) throw new Error("scrypt: invalid r");
      if (logN < 1 || logN > 31) throw new Error("scrypt: logN must be between 1 and 31");
      var N11 = 1 << logN >>> 0, XY, V, B4, tmp;
      if (r * p >= 1 << 30 || r > MAX_UINT / 128 / p || r > MAX_UINT / 256 || N11 > MAX_UINT / 128 / r) throw new Error("scrypt: parameters are too large");
      if (typeof password === "string") password = stringToUTF8Bytes(password);
      if (typeof salt === "string") salt = stringToUTF8Bytes(salt);
      if (typeof Int32Array !== "undefined") {
        XY = new Int32Array(64 * r);
        V = new Int32Array(32 * N11 * r);
        tmp = new Int32Array(16);
      } else {
        XY = [];
        V = [];
        tmp = new Array(16);
      }
      B4 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
      var xi = 0, yi = 32 * r;
      function smixStart(pos) {
        for (var i2 = 0; i2 < 32 * r; i2++) {
          var j = pos + i2 * 4;
          XY[xi + i2] = (B4[j + 3] & 255) << 24 | (B4[j + 2] & 255) << 16 | (B4[j + 1] & 255) << 8 | (B4[j + 0] & 255) << 0;
        }
      }
      function smixStep1(start, end) {
        for (var i2 = start; i2 < end; i2 += 2) {
          blockCopy(V, i2 * (32 * r), XY, xi, 32 * r);
          blockMix(tmp, XY, xi, yi, r);
          blockCopy(V, (i2 + 1) * (32 * r), XY, yi, 32 * r);
          blockMix(tmp, XY, yi, xi, r);
        }
      }
      function smixStep2(start, end) {
        for (var i2 = start; i2 < end; i2 += 2) {
          var j = integerify(XY, xi, r) & N11 - 1;
          blockXOR(XY, xi, V, j * (32 * r), 32 * r);
          blockMix(tmp, XY, xi, yi, r);
          j = integerify(XY, yi, r) & N11 - 1;
          blockXOR(XY, yi, V, j * (32 * r), 32 * r);
          blockMix(tmp, XY, yi, xi, r);
        }
      }
      function smixFinish(pos) {
        for (var i2 = 0; i2 < 32 * r; i2++) {
          var j = XY[xi + i2];
          B4[pos + i2 * 4 + 0] = j >>> 0 & 255;
          B4[pos + i2 * 4 + 1] = j >>> 8 & 255;
          B4[pos + i2 * 4 + 2] = j >>> 16 & 255;
          B4[pos + i2 * 4 + 3] = j >>> 24 & 255;
        }
      }
      var nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      function interruptedFor(start, end, step, fn, donefn) {
        (function performStep() {
          nextTick(function() {
            fn(start, start + step < end ? start + step : end);
            start += step;
            if (start < end) performStep();
            else donefn();
          });
        })();
      }
      function getResult(enc) {
        var result = PBKDF2_HMAC_SHA256_OneIter(password, B4, dkLen);
        if (enc === "base64") return bytesToBase64(result);
        else if (enc === "hex") return bytesToHex(result);
        else if (enc === "binary") return new Uint8Array(result);
        else return result;
      }
      function calculateSync() {
        for (var i2 = 0; i2 < p; i2++) {
          smixStart(i2 * 128 * r);
          smixStep1(0, N11);
          smixStep2(0, N11);
          smixFinish(i2 * 128 * r);
        }
        callback(getResult(encoding));
      }
      function calculateAsync(i2) {
        smixStart(i2 * 128 * r);
        interruptedFor(0, N11, interruptStep * 2, smixStep1, function() {
          interruptedFor(0, N11, interruptStep * 2, smixStep2, function() {
            smixFinish(i2 * 128 * r);
            if (i2 + 1 < p) {
              nextTick(function() {
                calculateAsync(i2 + 1);
              });
            } else {
              callback(getResult(encoding));
            }
          });
        });
      }
      if (typeof interruptStep === "function") {
        encoding = callback;
        callback = interruptStep;
        interruptStep = 1e3;
      }
      if (interruptStep <= 0) {
        calculateSync();
      } else {
        calculateAsync(0);
      }
    }
    if (typeof module2 !== "undefined") module2.exports = scrypt3;
  }
});

// node_modules/.deno/vuelidate@0.7.6/node_modules/vuelidate/lib/vval.js
var require_vval = __commonJS({
  "node_modules/.deno/vuelidate@0.7.6/node_modules/vuelidate/lib/vval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.patchChildren = patchChildren;
    exports2.h = h2;
    function isUndef(v2) {
      return v2 === null || v2 === void 0;
    }
    function isDef(v2) {
      return v2 !== null && v2 !== void 0;
    }
    function sameVval(oldVval, vval) {
      return vval.tag === oldVval.tag && vval.key === oldVval.key;
    }
    function createVm(vval) {
      var Vm = vval.tag;
      vval.vm = new Vm({
        data: vval.args
      });
    }
    function updateVval(vval) {
      var keys = Object.keys(vval.args);
      for (var i2 = 0; i2 < keys.length; i2++) {
        keys.forEach(function(k) {
          vval.vm[k] = vval.args[k];
        });
      }
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
      var i2, key;
      var map2 = {};
      for (i2 = beginIdx; i2 <= endIdx; ++i2) {
        key = children[i2].key;
        if (isDef(key)) map2[key] = i2;
      }
      return map2;
    }
    function updateChildren(oldCh, newCh) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVval = oldCh[0];
      var oldEndVval = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVval = newCh[0];
      var newEndVval = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, elmToMove;
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVval)) {
          oldStartVval = oldCh[++oldStartIdx];
        } else if (isUndef(oldEndVval)) {
          oldEndVval = oldCh[--oldEndIdx];
        } else if (sameVval(oldStartVval, newStartVval)) {
          patchVval(oldStartVval, newStartVval);
          oldStartVval = oldCh[++oldStartIdx];
          newStartVval = newCh[++newStartIdx];
        } else if (sameVval(oldEndVval, newEndVval)) {
          patchVval(oldEndVval, newEndVval);
          oldEndVval = oldCh[--oldEndIdx];
          newEndVval = newCh[--newEndIdx];
        } else if (sameVval(oldStartVval, newEndVval)) {
          patchVval(oldStartVval, newEndVval);
          oldStartVval = oldCh[++oldStartIdx];
          newEndVval = newCh[--newEndIdx];
        } else if (sameVval(oldEndVval, newStartVval)) {
          patchVval(oldEndVval, newStartVval);
          oldEndVval = oldCh[--oldEndIdx];
          newStartVval = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          idxInOld = isDef(newStartVval.key) ? oldKeyToIdx[newStartVval.key] : null;
          if (isUndef(idxInOld)) {
            createVm(newStartVval);
            newStartVval = newCh[++newStartIdx];
          } else {
            elmToMove = oldCh[idxInOld];
            if (sameVval(elmToMove, newStartVval)) {
              patchVval(elmToMove, newStartVval);
              oldCh[idxInOld] = void 0;
              newStartVval = newCh[++newStartIdx];
            } else {
              createVm(newStartVval);
              newStartVval = newCh[++newStartIdx];
            }
          }
        }
      }
      if (oldStartIdx > oldEndIdx) {
        addVvals(newCh, newStartIdx, newEndIdx);
      } else if (newStartIdx > newEndIdx) {
        removeVvals(oldCh, oldStartIdx, oldEndIdx);
      }
    }
    function addVvals(vvals, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        createVm(vvals[startIdx]);
      }
    }
    function removeVvals(vvals, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vvals[startIdx];
        if (isDef(ch)) {
          ch.vm.$destroy();
          ch.vm = null;
        }
      }
    }
    function patchVval(oldVval, vval) {
      if (oldVval === vval) {
        return;
      }
      vval.vm = oldVval.vm;
      updateVval(vval);
    }
    function patchChildren(oldCh, ch) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(oldCh, ch);
      } else if (isDef(ch)) {
        addVvals(ch, 0, ch.length - 1);
      } else if (isDef(oldCh)) {
        removeVvals(oldCh, 0, oldCh.length - 1);
      }
    }
    function h2(tag2, key, args) {
      return {
        tag: tag2,
        key,
        args
      };
    }
  }
});

// node_modules/.deno/vuelidate@0.7.6/node_modules/vuelidate/lib/params.js
var require_params = __commonJS({
  "node_modules/.deno/vuelidate@0.7.6/node_modules/vuelidate/lib/params.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.pushParams = pushParams;
    exports2.popParams = popParams;
    exports2.withParams = withParams;
    exports2._setTarget = exports2.target = void 0;
    function _objectSpread(target2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty(target2, key, source[key]);
        });
      }
      return target2;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var stack = [];
    var target = null;
    exports2.target = target;
    var _setTarget = function _setTarget2(x3) {
      exports2.target = target = x3;
    };
    exports2._setTarget = _setTarget;
    function pushParams() {
      if (target !== null) {
        stack.push(target);
      }
      exports2.target = target = {};
    }
    function popParams() {
      var lastTarget = target;
      var newTarget = exports2.target = target = stack.pop() || null;
      if (newTarget) {
        if (!Array.isArray(newTarget.$sub)) {
          newTarget.$sub = [];
        }
        newTarget.$sub.push(lastTarget);
      }
      return lastTarget;
    }
    function addParams(params) {
      if (_typeof(params) === "object" && !Array.isArray(params)) {
        exports2.target = target = _objectSpread({}, target, params);
      } else {
        throw new Error("params must be an object");
      }
    }
    function withParamsDirect(params, validator) {
      return withParamsClosure(function(add) {
        return function() {
          add(params);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return validator.apply(this, args);
        };
      });
    }
    function withParamsClosure(closure) {
      var validator = closure(addParams);
      return function() {
        pushParams();
        try {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return validator.apply(this, args);
        } finally {
          popParams();
        }
      };
    }
    function withParams(paramsOrClosure, maybeValidator) {
      if (_typeof(paramsOrClosure) === "object" && maybeValidator !== void 0) {
        return withParamsDirect(paramsOrClosure, maybeValidator);
      }
      return withParamsClosure(paramsOrClosure);
    }
  }
});

// node_modules/.deno/vuelidate@0.7.6/node_modules/vuelidate/lib/index.js
var require_lib35 = __commonJS({
  "node_modules/.deno/vuelidate@0.7.6/node_modules/vuelidate/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Vuelidate = Vuelidate;
    Object.defineProperty(exports2, "withParams", {
      enumerable: true,
      get: function get2() {
        return _params.withParams;
      }
    });
    exports2.default = exports2.validationMixin = void 0;
    var _vval = require_vval();
    var _params = require_params();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i2 = 0, arr2 = new Array(arr.length); i2 < arr.length; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var NIL2 = function NIL3() {
      return null;
    };
    var buildFromKeys = function buildFromKeys2(keys, fn, keyFn) {
      return keys.reduce(function(build, key) {
        build[keyFn ? keyFn(key) : key] = fn(key);
        return build;
      }, {});
    };
    function isFunction(val) {
      return typeof val === "function";
    }
    function isObject2(val) {
      return val !== null && (_typeof(val) === "object" || isFunction(val));
    }
    function isPromise(object2) {
      return isObject2(object2) && isFunction(object2.then);
    }
    var getPath = function getPath2(ctx, obj, path, fallback) {
      if (typeof path === "function") {
        return path.call(ctx, obj, fallback);
      }
      path = Array.isArray(path) ? path : path.split(".");
      for (var i2 = 0; i2 < path.length; i2++) {
        if (obj && _typeof(obj) === "object") {
          obj = obj[path[i2]];
        } else {
          return fallback;
        }
      }
      return typeof obj === "undefined" ? fallback : obj;
    };
    var __isVuelidateAsyncVm = "__isVuelidateAsyncVm";
    function makePendingAsyncVm(Vue, promise2) {
      var asyncVm = new Vue({
        data: {
          p: true,
          v: false
        }
      });
      promise2.then(function(value) {
        asyncVm.p = false;
        asyncVm.v = value;
      }, function(error40) {
        asyncVm.p = false;
        asyncVm.v = false;
        throw error40;
      });
      asyncVm[__isVuelidateAsyncVm] = true;
      return asyncVm;
    }
    var validationGetters = {
      $invalid: function $invalid() {
        var _this = this;
        var proxy = this.proxy;
        return this.nestedKeys.some(function(nested) {
          return _this.refProxy(nested).$invalid;
        }) || this.ruleKeys.some(function(rule) {
          return !proxy[rule];
        });
      },
      $dirty: function $dirty() {
        var _this2 = this;
        if (this.dirty) {
          return true;
        }
        if (this.nestedKeys.length === 0) {
          return false;
        }
        return this.nestedKeys.every(function(key) {
          return _this2.refProxy(key).$dirty;
        });
      },
      $anyDirty: function $anyDirty() {
        var _this3 = this;
        if (this.dirty) {
          return true;
        }
        if (this.nestedKeys.length === 0) {
          return false;
        }
        return this.nestedKeys.some(function(key) {
          return _this3.refProxy(key).$anyDirty;
        });
      },
      $error: function $error() {
        return this.$dirty && !this.$pending && this.$invalid;
      },
      $anyError: function $anyError() {
        var _this4 = this;
        if (this.$error) return true;
        return this.nestedKeys.some(function(key) {
          return _this4.refProxy(key).$anyError;
        });
      },
      $pending: function $pending() {
        var _this5 = this;
        return this.ruleKeys.some(function(key) {
          return _this5.getRef(key).$pending;
        }) || this.nestedKeys.some(function(key) {
          return _this5.refProxy(key).$pending;
        });
      },
      $params: function $params() {
        var _this6 = this;
        var vals = this.validations;
        return _objectSpread({}, buildFromKeys(this.nestedKeys, function(key) {
          return vals[key] && vals[key].$params || null;
        }), buildFromKeys(this.ruleKeys, function(key) {
          return _this6.getRef(key).$params;
        }));
      }
    };
    function setDirtyRecursive(newState) {
      this.dirty = newState;
      var proxy = this.proxy;
      var method = newState ? "$touch" : "$reset";
      this.nestedKeys.forEach(function(key) {
        proxy[key][method]();
      });
    }
    var validationMethods = {
      $touch: function $touch() {
        setDirtyRecursive.call(this, true);
      },
      $reset: function $reset() {
        setDirtyRecursive.call(this, false);
      },
      $flattenParams: function $flattenParams() {
        var proxy = this.proxy;
        var params = [];
        for (var key in this.$params) {
          if (this.isNested(key)) {
            var childParams = proxy[key].$flattenParams();
            for (var j = 0; j < childParams.length; j++) {
              childParams[j].path.unshift(key);
            }
            params = params.concat(childParams);
          } else {
            params.push({
              path: [],
              name: key,
              params: this.$params[key]
            });
          }
        }
        return params;
      }
    };
    var getterNames = Object.keys(validationGetters);
    var methodNames = Object.keys(validationMethods);
    var _cachedComponent = null;
    var getComponent = function getComponent2(Vue) {
      if (_cachedComponent) {
        return _cachedComponent;
      }
      var VBase = Vue.extend({
        computed: {
          refs: function refs() {
            var oldVval = this._vval;
            this._vval = this.children;
            (0, _vval.patchChildren)(oldVval, this._vval);
            var refs2 = {};
            this._vval.forEach(function(c) {
              refs2[c.key] = c.vm;
            });
            return refs2;
          }
        },
        beforeCreate: function beforeCreate() {
          this._vval = null;
        },
        beforeDestroy: function beforeDestroy() {
          if (this._vval) {
            (0, _vval.patchChildren)(this._vval);
            this._vval = null;
          }
        },
        methods: {
          getModel: function getModel() {
            return this.lazyModel ? this.lazyModel(this.prop) : this.model;
          },
          getModelKey: function getModelKey(key) {
            var model = this.getModel();
            if (model) {
              return model[key];
            }
          },
          hasIter: function hasIter() {
            return false;
          }
        }
      });
      var ValidationRule = VBase.extend({
        data: function data() {
          return {
            rule: null,
            lazyModel: null,
            model: null,
            lazyParentModel: null,
            rootModel: null
          };
        },
        methods: {
          runRule: function runRule(parent) {
            var model = this.getModel();
            (0, _params.pushParams)();
            var rawOutput = this.rule.call(this.rootModel, model, parent);
            var output = isPromise(rawOutput) ? makePendingAsyncVm(Vue, rawOutput) : rawOutput;
            var rawParams = (0, _params.popParams)();
            var params = rawParams && rawParams.$sub ? rawParams.$sub.length > 1 ? rawParams : rawParams.$sub[0] : null;
            return {
              output,
              params
            };
          }
        },
        computed: {
          run: function run3() {
            var _this7 = this;
            var parent = this.lazyParentModel();
            var isArrayDependant = Array.isArray(parent) && parent.__ob__;
            if (isArrayDependant) {
              var arrayDep = parent.__ob__.dep;
              arrayDep.depend();
              var target = arrayDep.constructor.target;
              if (!this._indirectWatcher) {
                var Watcher = target.constructor;
                this._indirectWatcher = new Watcher(this, function() {
                  return _this7.runRule(parent);
                }, null, {
                  lazy: true
                });
              }
              var model = this.getModel();
              if (!this._indirectWatcher.dirty && this._lastModel === model) {
                this._indirectWatcher.depend();
                return target.value;
              }
              this._lastModel = model;
              this._indirectWatcher.evaluate();
              this._indirectWatcher.depend();
            } else if (this._indirectWatcher) {
              this._indirectWatcher.teardown();
              this._indirectWatcher = null;
            }
            return this._indirectWatcher ? this._indirectWatcher.value : this.runRule(parent);
          },
          $params: function $params() {
            return this.run.params;
          },
          proxy: function proxy() {
            var output = this.run.output;
            if (output[__isVuelidateAsyncVm]) {
              return !!output.v;
            }
            return !!output;
          },
          $pending: function $pending() {
            var output = this.run.output;
            if (output[__isVuelidateAsyncVm]) {
              return output.p;
            }
            return false;
          }
        },
        destroyed: function destroyed() {
          if (this._indirectWatcher) {
            this._indirectWatcher.teardown();
            this._indirectWatcher = null;
          }
        }
      });
      var Validation = VBase.extend({
        data: function data() {
          return {
            dirty: false,
            validations: null,
            lazyModel: null,
            model: null,
            prop: null,
            lazyParentModel: null,
            rootModel: null
          };
        },
        methods: _objectSpread({}, validationMethods, {
          refProxy: function refProxy(key) {
            return this.getRef(key).proxy;
          },
          getRef: function getRef(key) {
            return this.refs[key];
          },
          isNested: function isNested(key) {
            return typeof this.validations[key] !== "function";
          }
        }),
        computed: _objectSpread({}, validationGetters, {
          nestedKeys: function nestedKeys() {
            return this.keys.filter(this.isNested);
          },
          ruleKeys: function ruleKeys() {
            var _this8 = this;
            return this.keys.filter(function(k) {
              return !_this8.isNested(k);
            });
          },
          keys: function keys() {
            return Object.keys(this.validations).filter(function(k) {
              return k !== "$params";
            });
          },
          proxy: function proxy() {
            var _this9 = this;
            var keyDefs = buildFromKeys(this.keys, function(key) {
              return {
                enumerable: true,
                configurable: true,
                get: function get2() {
                  return _this9.refProxy(key);
                }
              };
            });
            var getterDefs = buildFromKeys(getterNames, function(key) {
              return {
                enumerable: true,
                configurable: true,
                get: function get2() {
                  return _this9[key];
                }
              };
            });
            var methodDefs = buildFromKeys(methodNames, function(key) {
              return {
                enumerable: false,
                configurable: true,
                get: function get2() {
                  return _this9[key];
                }
              };
            });
            var iterDefs = this.hasIter() ? {
              $iter: {
                enumerable: true,
                value: Object.defineProperties({}, _objectSpread({}, keyDefs))
              }
            } : {};
            return Object.defineProperties({}, _objectSpread({}, keyDefs, iterDefs, {
              $model: {
                enumerable: true,
                get: function get2() {
                  var parent = _this9.lazyParentModel();
                  if (parent != null) {
                    return parent[_this9.prop];
                  } else {
                    return null;
                  }
                },
                set: function set2(value) {
                  var parent = _this9.lazyParentModel();
                  if (parent != null) {
                    parent[_this9.prop] = value;
                    _this9.$touch();
                  }
                }
              }
            }, getterDefs, methodDefs));
          },
          children: function children() {
            var _this10 = this;
            return _toConsumableArray(this.nestedKeys.map(function(key) {
              return renderNested(_this10, key);
            })).concat(_toConsumableArray(this.ruleKeys.map(function(key) {
              return renderRule(_this10, key);
            }))).filter(Boolean);
          }
        })
      });
      var GroupValidation = Validation.extend({
        methods: {
          isNested: function isNested(key) {
            return typeof this.validations[key]() !== "undefined";
          },
          getRef: function getRef(key) {
            var vm = this;
            return {
              get proxy() {
                return vm.validations[key]() || false;
              }
            };
          }
        }
      });
      var EachValidation = Validation.extend({
        computed: {
          keys: function keys() {
            var model = this.getModel();
            if (isObject2(model)) {
              return Object.keys(model);
            } else {
              return [];
            }
          },
          tracker: function tracker() {
            var _this11 = this;
            var trackBy = this.validations.$trackBy;
            return trackBy ? function(key) {
              return "".concat(getPath(_this11.rootModel, _this11.getModelKey(key), trackBy));
            } : function(x3) {
              return "".concat(x3);
            };
          },
          getModelLazy: function getModelLazy() {
            var _this12 = this;
            return function() {
              return _this12.getModel();
            };
          },
          children: function children() {
            var _this13 = this;
            var def = this.validations;
            var model = this.getModel();
            var validations = _objectSpread({}, def);
            delete validations["$trackBy"];
            var usedTracks = {};
            return this.keys.map(function(key) {
              var track = _this13.tracker(key);
              if (usedTracks.hasOwnProperty(track)) {
                return null;
              }
              usedTracks[track] = true;
              return (0, _vval.h)(Validation, track, {
                validations,
                prop: key,
                lazyParentModel: _this13.getModelLazy,
                model: model[key],
                rootModel: _this13.rootModel
              });
            }).filter(Boolean);
          }
        },
        methods: {
          isNested: function isNested() {
            return true;
          },
          getRef: function getRef(key) {
            return this.refs[this.tracker(key)];
          },
          hasIter: function hasIter() {
            return true;
          }
        }
      });
      var renderNested = function renderNested2(vm, key) {
        if (key === "$each") {
          return (0, _vval.h)(EachValidation, key, {
            validations: vm.validations[key],
            lazyParentModel: vm.lazyParentModel,
            prop: key,
            lazyModel: vm.getModel,
            rootModel: vm.rootModel
          });
        }
        var validations = vm.validations[key];
        if (Array.isArray(validations)) {
          var root = vm.rootModel;
          var refVals = buildFromKeys(validations, function(path) {
            return function() {
              return getPath(root, root.$v, path);
            };
          }, function(v2) {
            return Array.isArray(v2) ? v2.join(".") : v2;
          });
          return (0, _vval.h)(GroupValidation, key, {
            validations: refVals,
            lazyParentModel: NIL2,
            prop: key,
            lazyModel: NIL2,
            rootModel: root
          });
        }
        return (0, _vval.h)(Validation, key, {
          validations,
          lazyParentModel: vm.getModel,
          prop: key,
          lazyModel: vm.getModelKey,
          rootModel: vm.rootModel
        });
      };
      var renderRule = function renderRule2(vm, key) {
        return (0, _vval.h)(ValidationRule, key, {
          rule: vm.validations[key],
          lazyParentModel: vm.lazyParentModel,
          lazyModel: vm.getModel,
          rootModel: vm.rootModel
        });
      };
      _cachedComponent = {
        VBase,
        Validation
      };
      return _cachedComponent;
    };
    var _cachedVue = null;
    function getVue(rootVm) {
      if (_cachedVue) return _cachedVue;
      var Vue = rootVm.constructor;
      while (Vue.super) {
        Vue = Vue.super;
      }
      _cachedVue = Vue;
      return Vue;
    }
    var validateModel = function validateModel2(model, validations) {
      var Vue = getVue(model);
      var _getComponent = getComponent(Vue), Validation = _getComponent.Validation, VBase = _getComponent.VBase;
      var root = new VBase({
        computed: {
          children: function children() {
            var vals = typeof validations === "function" ? validations.call(model) : validations;
            return [
              (0, _vval.h)(Validation, "$v", {
                validations: vals,
                lazyParentModel: NIL2,
                prop: "$v",
                model,
                rootModel: model
              })
            ];
          }
        }
      });
      return root;
    };
    var validationMixin2 = {
      data: function data() {
        var vals = this.$options.validations;
        if (vals) {
          this._vuelidate = validateModel(this, vals);
        }
        return {};
      },
      beforeCreate: function beforeCreate() {
        var options3 = this.$options;
        var vals = options3.validations;
        if (!vals) return;
        if (!options3.computed) options3.computed = {};
        if (options3.computed.$v) return;
        options3.computed.$v = function() {
          return this._vuelidate ? this._vuelidate.refs.$v.proxy : null;
        };
      },
      beforeDestroy: function beforeDestroy() {
        if (this._vuelidate) {
          this._vuelidate.$destroy();
          this._vuelidate = null;
        }
      }
    };
    exports2.validationMixin = validationMixin2;
    function Vuelidate(Vue) {
      Vue.mixin(validationMixin2);
    }
    var _default3 = Vuelidate;
    exports2.default = _default3;
  }
});

// deno:https://jsr.io/@std/assert/1.0.13/assertion_error.ts
var AssertionError = class extends Error {
  /** Constructs a new instance.
   *
   * @param message The error message.
   * @param options Additional options. This argument is still unstable. It may change in the future release.
   */
  constructor(message, options3) {
    super(message, options3);
    this.name = "AssertionError";
  }
};

// deno:https://jsr.io/@std/assert/1.0.13/equal.ts
function isKeyedCollection(x3) {
  return x3 instanceof Set || x3 instanceof Map;
}
function prototypesEqual(a, b) {
  const pa = Object.getPrototypeOf(a);
  const pb = Object.getPrototypeOf(b);
  return pa === pb || pa === Object.prototype && pb === null || pa === null && pb === Object.prototype;
}
function isBasicObjectOrArray(obj) {
  const proto3 = Object.getPrototypeOf(obj);
  return proto3 === null || proto3 === Object.prototype || proto3 === Array.prototype;
}
function ownKeys(obj) {
  return [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj)
  ];
}
function getKeysDeep(obj) {
  const keys = /* @__PURE__ */ new Set();
  while (obj !== Object.prototype && obj !== Array.prototype && obj != null) {
    for (const key of ownKeys(obj)) {
      keys.add(key);
    }
    obj = Object.getPrototypeOf(obj);
  }
  return keys;
}
var Temporal = globalThis.Temporal ?? new Proxy({}, {
  get: () => {
  }
});
var stringComparablePrototypes = new Set([
  Intl.Locale,
  RegExp,
  Temporal.Duration,
  Temporal.Instant,
  Temporal.PlainDate,
  Temporal.PlainDateTime,
  Temporal.PlainTime,
  Temporal.PlainYearMonth,
  Temporal.PlainMonthDay,
  Temporal.ZonedDateTime,
  URL,
  URLSearchParams
].filter((x3) => x3 != null).map((x3) => x3.prototype));
function isPrimitive(x3) {
  return typeof x3 === "string" || typeof x3 === "number" || typeof x3 === "boolean" || typeof x3 === "bigint" || typeof x3 === "symbol" || x3 == null;
}
var TypedArray = Object.getPrototypeOf(Uint8Array);
function compareTypedArrays(a, b) {
  if (a.length !== b.length) return false;
  for (let i2 = 0; i2 < b.length; i2++) {
    if (!sameValueZero(a[i2], b[i2])) return false;
  }
  return true;
}
function sameValueZero(a, b) {
  return a === b || Object.is(a, b);
}
function equal(a, b) {
  const seen = /* @__PURE__ */ new Map();
  return function compare(a2, b2) {
    if (sameValueZero(a2, b2)) return true;
    if (isPrimitive(a2) || isPrimitive(b2)) return false;
    if (a2 instanceof Date && b2 instanceof Date) {
      return Object.is(a2.getTime(), b2.getTime());
    }
    if (a2 && typeof a2 === "object" && b2 && typeof b2 === "object") {
      if (!prototypesEqual(a2, b2)) {
        return false;
      }
      if (a2 instanceof TypedArray) {
        return compareTypedArrays(a2, b2);
      }
      if (a2 instanceof WeakMap) {
        throw new TypeError("Cannot compare WeakMap instances");
      }
      if (a2 instanceof WeakSet) {
        throw new TypeError("Cannot compare WeakSet instances");
      }
      if (a2 instanceof WeakRef) {
        return compare(a2.deref(), b2.deref());
      }
      if (seen.get(a2) === b2) {
        return true;
      }
      if (Object.keys(a2).length !== Object.keys(b2).length) {
        return false;
      }
      seen.set(a2, b2);
      if (isKeyedCollection(a2) && isKeyedCollection(b2)) {
        if (a2.size !== b2.size) {
          return false;
        }
        const aKeys = [
          ...a2.keys()
        ];
        const primitiveKeysFastPath = aKeys.every(isPrimitive);
        if (primitiveKeysFastPath) {
          if (a2 instanceof Set) {
            return a2.symmetricDifference(b2).size === 0;
          }
          for (const key of aKeys) {
            if (!b2.has(key) || !compare(a2.get(key), b2.get(key))) {
              return false;
            }
          }
          return true;
        }
        let unmatchedEntries = a2.size;
        for (const [aKey, aValue] of a2.entries()) {
          for (const [bKey, bValue] of b2.entries()) {
            if (!compare(aKey, bKey)) continue;
            if (aKey === aValue && bKey === bValue || compare(aValue, bValue)) {
              unmatchedEntries--;
              break;
            }
          }
        }
        return unmatchedEntries === 0;
      }
      let keys;
      if (isBasicObjectOrArray(a2)) {
        keys = ownKeys({
          ...a2,
          ...b2
        });
      } else if (stringComparablePrototypes.has(Object.getPrototypeOf(a2))) {
        return String(a2) === String(b2);
      } else {
        keys = getKeysDeep(a2).union(getKeysDeep(b2));
      }
      for (const key of keys) {
        if (!compare(a2[key], b2[key])) {
          return false;
        }
        if (key in a2 && !(key in b2) || key in b2 && !(key in a2)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }(a, b);
}

// deno:https://jsr.io/@std/internal/1.0.10/format.ts
function format(v2) {
  const { Deno: Deno4, process: process6 } = globalThis;
  const inspect = Deno4?.inspect ?? process6?.getBuiltinModule?.("node:util")?.inspect;
  return typeof inspect === "function" ? inspect(v2, {
    depth: Infinity,
    sorted: true,
    trailingComma: true,
    compact: false,
    iterableLimit: Infinity,
    // getters should be true in assertEquals.
    getters: true,
    strAbbreviateSize: Infinity
  }) : basicInspect(v2);
}
var formatters = [
  (v2) => {
    if (typeof v2 === "undefined") return "undefined";
    if (typeof v2 === "bigint") return `${v2}n`;
    if (typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || v2 === null || Array.isArray(v2) || [
      null,
      Object.prototype
    ].includes(Object.getPrototypeOf(v2))) {
      return JSON.stringify(v2, null, 2);
    }
  },
  (v2) => String(v2),
  (v2) => Object.prototype.toString.call(v2)
];
function basicInspect(v2) {
  for (const fmt of formatters) {
    try {
      const result = fmt(v2);
      if (typeof result === "string") return result;
    } catch {
    }
  }
  return "[[Unable to format value]]";
}

// deno:https://jsr.io/@std/internal/1.0.10/styles.ts
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : false;
var enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code3) {
  return enabled ? `${code3.open}${str.replace(code3.regexp, code3.open)}${code3.close}` : str;
}
function bold(str) {
  return run(str, code([
    1
  ], 22));
}
function red(str) {
  return run(str, code([
    31
  ], 39));
}
function green(str) {
  return run(str, code([
    32
  ], 39));
}
function white(str) {
  return run(str, code([
    37
  ], 39));
}
function gray(str) {
  return brightBlack(str);
}
function brightBlack(str) {
  return run(str, code([
    90
  ], 39));
}
function bgRed(str) {
  return run(str, code([
    41
  ], 49));
}
function bgGreen(str) {
  return run(str, code([
    42
  ], 49));
}
var ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
].join("|"), "g");
function stripAnsiCode(string4) {
  return string4.replace(ANSI_PATTERN, "");
}

// deno:https://jsr.io/@std/internal/1.0.10/build_message.ts
function createColor(diffType, background = false) {
  switch (diffType) {
    case "added":
      return (s) => background ? bgGreen(white(s)) : green(bold(s));
    case "removed":
      return (s) => background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
function createSign(diffType) {
  switch (diffType) {
    case "added":
      return "+   ";
    case "removed":
      return "-   ";
    default:
      return "    ";
  }
}
function buildMessage(diffResult, options3 = {}) {
  const { stringDiff = false } = options3;
  const messages = [
    "",
    "",
    `    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`,
    "",
    ""
  ];
  const diffMessages = diffResult.map((result) => {
    const color = createColor(result.type);
    const line = result.details?.map((detail) => detail.type !== "common" ? createColor(detail.type, true)(detail.value) : detail.value).join("") ?? result.value;
    return color(`${createSign(result.type)}${line}`);
  });
  messages.push(...stringDiff ? [
    diffMessages.join("")
  ] : diffMessages, "");
  return messages;
}

// deno:https://jsr.io/@std/internal/1.0.10/diff.ts
var REMOVED = 1;
var COMMON = 2;
var ADDED = 3;
function createCommon(A2, B4) {
  const common3 = [];
  if (A2.length === 0 || B4.length === 0) return [];
  for (let i2 = 0; i2 < Math.min(A2.length, B4.length); i2 += 1) {
    const a = A2[i2];
    const b = B4[i2];
    if (a !== void 0 && a === b) {
      common3.push(a);
    } else {
      return common3;
    }
  }
  return common3;
}
function assertFp(value) {
  if (value == null || typeof value !== "object" || typeof value?.y !== "number" || typeof value?.id !== "number") {
    throw new Error(`Unexpected value, expected 'FarthestPoint': received ${typeof value}`);
  }
}
function backTrace(A2, B4, current, swapped, routes, diffTypesPtrOffset) {
  const M2 = A2.length;
  const N11 = B4.length;
  const result = [];
  let a = M2 - 1;
  let b = N11 - 1;
  let j = routes[current.id];
  let type = routes[current.id + diffTypesPtrOffset];
  while (true) {
    if (!j && !type) break;
    const prev = j;
    if (type === REMOVED) {
      result.unshift({
        type: swapped ? "removed" : "added",
        value: B4[b]
      });
      b -= 1;
    } else if (type === ADDED) {
      result.unshift({
        type: swapped ? "added" : "removed",
        value: A2[a]
      });
      a -= 1;
    } else {
      result.unshift({
        type: "common",
        value: A2[a]
      });
      a -= 1;
      b -= 1;
    }
    j = routes[prev];
    type = routes[prev + diffTypesPtrOffset];
  }
  return result;
}
function createFp(k, M2, routes, diffTypesPtrOffset, ptr, slide, down) {
  if (slide && slide.y === -1 && down && down.y === -1) {
    return {
      y: 0,
      id: 0
    };
  }
  const isAdding = down?.y === -1 || k === M2 || (slide?.y ?? 0) > (down?.y ?? 0) + 1;
  if (slide && isAdding) {
    const prev = slide.id;
    ptr++;
    routes[ptr] = prev;
    routes[ptr + diffTypesPtrOffset] = ADDED;
    return {
      y: slide.y,
      id: ptr
    };
  }
  if (down && !isAdding) {
    const prev = down.id;
    ptr++;
    routes[ptr] = prev;
    routes[ptr + diffTypesPtrOffset] = REMOVED;
    return {
      y: down.y + 1,
      id: ptr
    };
  }
  throw new Error("Unexpected missing FarthestPoint");
}
function diff(A2, B4) {
  const prefixCommon = createCommon(A2, B4);
  A2 = A2.slice(prefixCommon.length);
  B4 = B4.slice(prefixCommon.length);
  const swapped = B4.length > A2.length;
  [A2, B4] = swapped ? [
    B4,
    A2
  ] : [
    A2,
    B4
  ];
  const M2 = A2.length;
  const N11 = B4.length;
  if (!M2 && !N11 && !prefixCommon.length) return [];
  if (!N11) {
    return [
      ...prefixCommon.map((value) => ({
        type: "common",
        value
      })),
      ...A2.map((value) => ({
        type: swapped ? "added" : "removed",
        value
      }))
    ];
  }
  const offset = N11;
  const delta = M2 - N11;
  const length4 = M2 + N11 + 1;
  const fp = Array.from({
    length: length4
  }, () => ({
    y: -1,
    id: -1
  }));
  const routes = new Uint32Array((M2 * N11 + length4 + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  function snake(k, A3, B5, slide, down) {
    const M3 = A3.length;
    const N14 = B5.length;
    const fp2 = createFp(k, M3, routes, diffTypesPtrOffset, ptr, slide, down);
    ptr = fp2.id;
    while (fp2.y + k < M3 && fp2.y < N14 && A3[fp2.y + k] === B5[fp2.y]) {
      const prev = fp2.id;
      ptr++;
      fp2.id = ptr;
      fp2.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp2;
  }
  let currentFp = fp[delta + offset];
  assertFp(currentFp);
  let p = -1;
  while (currentFp.y < N11) {
    p = p + 1;
    for (let k = -p; k < delta; ++k) {
      const index2 = k + offset;
      fp[index2] = snake(k, A2, B4, fp[index2 - 1], fp[index2 + 1]);
    }
    for (let k = delta + p; k > delta; --k) {
      const index2 = k + offset;
      fp[index2] = snake(k, A2, B4, fp[index2 - 1], fp[index2 + 1]);
    }
    const index = delta + offset;
    fp[delta + offset] = snake(delta, A2, B4, fp[index - 1], fp[index + 1]);
    currentFp = fp[delta + offset];
    assertFp(currentFp);
  }
  return [
    ...prefixCommon.map((value) => ({
      type: "common",
      value
    })),
    ...backTrace(A2, B4, currentFp, swapped, routes, diffTypesPtrOffset)
  ];
}

// deno:https://jsr.io/@std/internal/1.0.10/diff_str.ts
function unescape2(string4) {
  return string4.replaceAll("\\", "\\\\").replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("	", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str) => str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
}
var WHITESPACE_SYMBOLS = /((?:\\[bftv]|[^\S\r\n])+|\\[rn\\]|[()[\]{}'"\r\n]|\b)/;
function tokenize(string4, wordDiff = false) {
  if (wordDiff) {
    return string4.split(WHITESPACE_SYMBOLS).filter((token) => token);
  }
  const tokens = [];
  const lines = string4.split(/(\n|\r\n)/).filter((line) => line);
  for (const [i2, line] of lines.entries()) {
    if (i2 % 2) {
      tokens[tokens.length - 1] += line;
    } else {
      tokens.push(line);
    }
  }
  return tokens;
}
function createDetails(line, tokens) {
  return tokens.filter(({ type }) => type === line.type || type === "common").map((result, i2, t) => {
    const token = t[i2 - 1];
    if (result.type === "common" && token && token.type === t[i2 + 1]?.type && /\s+/.test(result.value)) {
      return {
        ...result,
        type: token.type
      };
    }
    return result;
  });
}
var NON_WHITESPACE_REGEXP = /\S/;
function diffStr(A2, B4) {
  const diffResult = diff(tokenize(`${unescape2(A2)}
`), tokenize(`${unescape2(B4)}
`));
  const added = [];
  const removed = [];
  for (const result of diffResult) {
    if (result.type === "added") {
      added.push(result);
    }
    if (result.type === "removed") {
      removed.push(result);
    }
  }
  const hasMoreRemovedLines = added.length < removed.length;
  const aLines = hasMoreRemovedLines ? added : removed;
  const bLines = hasMoreRemovedLines ? removed : added;
  for (const a of aLines) {
    let tokens = [];
    let b;
    while (bLines.length) {
      b = bLines.shift();
      const tokenized = [
        tokenize(a.value, true),
        tokenize(b.value, true)
      ];
      if (hasMoreRemovedLines) tokenized.reverse();
      tokens = diff(tokenized[0], tokenized[1]);
      if (tokens.some(({ type, value }) => type === "common" && NON_WHITESPACE_REGEXP.test(value))) {
        break;
      }
    }
    a.details = createDetails(a, tokens);
    if (b) {
      b.details = createDetails(b, tokens);
    }
  }
  return diffResult;
}

// deno:https://jsr.io/@std/assert/1.0.13/equals.ts
function assertEquals(actual, expected, msg) {
  if (equal(actual, expected)) {
    return;
  }
  const msgSuffix = msg ? `: ${msg}` : ".";
  let message = `Values are not equal${msgSuffix}`;
  const actualString = format(actual);
  const expectedString = format(expected);
  const stringDiff = typeof actual === "string" && typeof expected === "string";
  const diffResult = stringDiff ? diffStr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
  const diffMsg = buildMessage(diffResult, {
    stringDiff
  }).join("\n");
  message = `${message}
${diffMsg}`;
  throw new AssertionError(message);
}

// deno:https://jsr.io/@std/assert/1.0.13/is_error.ts
function assertIsError(error40, ErrorClass, msgMatches, msg) {
  const msgSuffix = msg ? `: ${msg}` : ".";
  if (!(error40 instanceof Error)) {
    throw new AssertionError(`Expected "error" to be an Error object${msgSuffix}`);
  }
  if (ErrorClass && !(error40 instanceof ErrorClass)) {
    msg = `Expected error to be instance of "${ErrorClass.name}", but was "${error40?.constructor?.name}"${msgSuffix}`;
    throw new AssertionError(msg);
  }
  let msgCheck;
  if (typeof msgMatches === "string") {
    msgCheck = stripAnsiCode(error40.message).includes(stripAnsiCode(msgMatches));
  }
  if (msgMatches instanceof RegExp) {
    msgCheck = msgMatches.test(stripAnsiCode(error40.message));
  }
  if (msgMatches && !msgCheck) {
    msg = `Expected error message to include ${msgMatches instanceof RegExp ? msgMatches.toString() : JSON.stringify(msgMatches)}, but got ${JSON.stringify(error40?.message)}${msgSuffix}`;
    throw new AssertionError(msg);
  }
}

// deno:https://jsr.io/@std/assert/1.0.13/rejects.ts
async function assertRejects(fn, errorClassOrMsg, msgIncludesOrMsg, msg) {
  let ErrorClass;
  let msgIncludes;
  let err;
  if (typeof errorClassOrMsg !== "string") {
    if (errorClassOrMsg === void 0 || errorClassOrMsg.prototype instanceof Error || errorClassOrMsg.prototype === Error.prototype) {
      ErrorClass = errorClassOrMsg;
      msgIncludes = msgIncludesOrMsg;
    }
  } else {
    msg = errorClassOrMsg;
  }
  let doesThrow = false;
  let isPromiseReturned = false;
  const msgSuffix = msg ? `: ${msg}` : ".";
  try {
    const possiblePromise = fn();
    if (possiblePromise && typeof possiblePromise === "object" && typeof possiblePromise.then === "function") {
      isPromiseReturned = true;
      await possiblePromise;
    } else {
      throw new Error();
    }
  } catch (error40) {
    if (!isPromiseReturned) {
      throw new AssertionError(`Function throws when expected to reject${msgSuffix}`);
    }
    if (ErrorClass) {
      if (!(error40 instanceof Error)) {
        throw new AssertionError(`A non-Error object was rejected${msgSuffix}`);
      }
      assertIsError(error40, ErrorClass, msgIncludes, msg);
    }
    err = error40;
    doesThrow = true;
  }
  if (!doesThrow) {
    throw new AssertionError(`Expected function to reject${msgSuffix}`);
  }
  return err;
}

// deno:https://jsr.io/@std/assert/1.0.13/throws.ts
function assertThrows(fn, errorClassOrMsg, msgIncludesOrMsg, msg) {
  let ErrorClass;
  let msgIncludes;
  let err;
  if (typeof errorClassOrMsg !== "string") {
    if (errorClassOrMsg === void 0 || errorClassOrMsg?.prototype instanceof Error || errorClassOrMsg?.prototype === Error.prototype) {
      ErrorClass = errorClassOrMsg;
      msgIncludes = msgIncludesOrMsg;
    } else {
      msg = msgIncludesOrMsg;
    }
  } else {
    msg = errorClassOrMsg;
  }
  let doesThrow = false;
  const msgSuffix = msg ? `: ${msg}` : ".";
  try {
    fn();
  } catch (error40) {
    if (ErrorClass) {
      if (error40 instanceof Error === false) {
        throw new AssertionError(`A non-Error object was thrown${msgSuffix}`);
      }
      assertIsError(error40, ErrorClass, msgIncludes, msg);
    }
    err = error40;
    doesThrow = true;
  }
  if (!doesThrow) {
    msg = `Expected function to throw${msgSuffix}`;
    throw new AssertionError(msg);
  }
  return err;
}

// deno:https://jsr.io/@std/assert/1.0.13/assert.ts
function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}

// deno:https://jsr.io/@std/encoding/1.0.10/base64.ts
var base64_exports = {};
__export(base64_exports, {
  decodeBase64: () => decodeBase64,
  encodeBase64: () => encodeBase64
});

// deno:https://jsr.io/@std/encoding/1.0.10/_common64.ts
var padding = "=".charCodeAt(0);
var alphabet = {
  base64: new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
  base64url: new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")
};
var rAlphabet = {
  base64: new Uint8Array(128).fill(64),
  base64url: new Uint8Array(128).fill(64)
};
alphabet.base64.forEach((byte, i2) => rAlphabet.base64[byte] = i2);
alphabet.base64url.forEach((byte, i2) => rAlphabet.base64url[byte] = i2);
function calcSizeBase64(originalSize) {
  return ((originalSize + 2) / 3 | 0) * 4;
}
function encode(buffer, i2, o2, alphabet5, padding3) {
  i2 += 2;
  for (; i2 < buffer.length; i2 += 3) {
    const x3 = buffer[i2 - 2] << 16 | buffer[i2 - 1] << 8 | buffer[i2];
    buffer[o2++] = alphabet5[x3 >> 18];
    buffer[o2++] = alphabet5[x3 >> 12 & 63];
    buffer[o2++] = alphabet5[x3 >> 6 & 63];
    buffer[o2++] = alphabet5[x3 & 63];
  }
  switch (i2) {
    case buffer.length + 1: {
      const x3 = buffer[i2 - 2] << 16;
      buffer[o2++] = alphabet5[x3 >> 18];
      buffer[o2++] = alphabet5[x3 >> 12 & 63];
      buffer[o2++] = padding3;
      buffer[o2++] = padding3;
      break;
    }
    case buffer.length: {
      const x3 = buffer[i2 - 2] << 16 | buffer[i2 - 1] << 8;
      buffer[o2++] = alphabet5[x3 >> 18];
      buffer[o2++] = alphabet5[x3 >> 12 & 63];
      buffer[o2++] = alphabet5[x3 >> 6 & 63];
      buffer[o2++] = padding3;
      break;
    }
  }
  return o2;
}
function decode(buffer, i2, o2, alphabet5, padding3) {
  for (let x3 = buffer.length - 2; x3 < buffer.length; ++x3) {
    if (buffer[x3] === padding3) {
      for (let y = x3 + 1; y < buffer.length; ++y) {
        if (buffer[y] !== padding3) {
          throw new TypeError(`Cannot decode input as base64: Invalid character (${String.fromCharCode(buffer[y])})`);
        }
      }
      buffer = buffer.subarray(0, x3);
      break;
    }
  }
  if ((buffer.length - o2) % 4 === 1) {
    throw new RangeError(`Cannot decode input as base64: Length (${buffer.length - o2}), excluding padding, must not have a remainder of 1 when divided by 4`);
  }
  i2 += 3;
  for (; i2 < buffer.length; i2 += 4) {
    const x3 = getByte(buffer[i2 - 3], alphabet5) << 18 | getByte(buffer[i2 - 2], alphabet5) << 12 | getByte(buffer[i2 - 1], alphabet5) << 6 | getByte(buffer[i2], alphabet5);
    buffer[o2++] = x3 >> 16;
    buffer[o2++] = x3 >> 8 & 255;
    buffer[o2++] = x3 & 255;
  }
  switch (i2) {
    case buffer.length + 1: {
      const x3 = getByte(buffer[i2 - 3], alphabet5) << 18 | getByte(buffer[i2 - 2], alphabet5) << 12;
      buffer[o2++] = x3 >> 16;
      break;
    }
    case buffer.length: {
      const x3 = getByte(buffer[i2 - 3], alphabet5) << 18 | getByte(buffer[i2 - 2], alphabet5) << 12 | getByte(buffer[i2 - 1], alphabet5) << 6;
      buffer[o2++] = x3 >> 16;
      buffer[o2++] = x3 >> 8 & 255;
      break;
    }
  }
  return o2;
}
function getByte(char, alphabet5) {
  const byte = alphabet5[char] ?? 64;
  if (byte === 64) {
    throw new TypeError(`Cannot decode input as base64: Invalid character (${String.fromCharCode(char)})`);
  }
  return byte;
}

// deno:https://jsr.io/@std/encoding/1.0.10/_common_detach.ts
function detach(buffer, maxSize) {
  const originalSize = buffer.length;
  if (buffer.byteOffset) {
    const b = new Uint8Array(buffer.buffer);
    b.set(buffer);
    buffer = b.subarray(0, originalSize);
  }
  buffer = new Uint8Array(buffer.buffer.transfer(maxSize));
  buffer.set(buffer.subarray(0, originalSize), maxSize - originalSize);
  return [
    buffer,
    maxSize - originalSize
  ];
}

// deno:https://jsr.io/@std/encoding/1.0.10/base64.ts
var padding2 = "=".charCodeAt(0);
var alphabet2 = new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var rAlphabet2 = new Uint8Array(128).fill(64);
alphabet2.forEach((byte, i2) => rAlphabet2[byte] = i2);
function encodeBase64(data) {
  if (typeof data === "string") {
    data = new TextEncoder().encode(data);
  } else if (data instanceof ArrayBuffer) data = new Uint8Array(data).slice();
  else data = data.slice();
  const [output, i2] = detach(data, calcSizeBase64(data.length));
  encode(output, i2, 0, alphabet2, padding2);
  return new TextDecoder().decode(output);
}
function decodeBase64(b64) {
  const output = new TextEncoder().encode(b64);
  return new Uint8Array(output.buffer.transfer(decode(output, 0, 0, rAlphabet2, padding2)));
}

// deno:https://jsr.io/@std/flags/0.224.0/mod.ts
var mod_exports = {};
__export(mod_exports, {
  parse: () => parse
});

// deno:https://jsr.io/@std/assert/0.224.0/assertion_error.ts
var AssertionError2 = class extends Error {
  /** Constructs a new instance. */
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};

// deno:https://jsr.io/@std/assert/0.224.0/assert_exists.ts
function assertExists(actual, msg) {
  if (actual === void 0 || actual === null) {
    const msgSuffix = msg ? `: ${msg}` : ".";
    msg = `Expected actual: "${actual}" to not be null or undefined${msgSuffix}`;
    throw new AssertionError2(msg);
  }
}

// deno:https://jsr.io/@std/flags/0.224.0/mod.ts
var { hasOwn } = Object;
function get(obj, key) {
  if (hasOwn(obj, key)) {
    return obj[key];
  }
}
function getForce(obj, key) {
  const v2 = get(obj, key);
  assertExists(v2);
  return v2;
}
function isNumber(x3) {
  if (typeof x3 === "number") return true;
  if (/^0x[0-9a-f]+$/i.test(String(x3))) return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x3));
}
function hasKey(obj, keys) {
  let o2 = obj;
  keys.slice(0, -1).forEach((key2) => {
    o2 = get(o2, key2) ?? {};
  });
  const key = keys.at(-1);
  return key !== void 0 && hasOwn(o2, key);
}
function parse(args, { "--": doubleDash = false, alias = {}, boolean: boolean4 = false, default: defaults = {}, stopEarly = false, string: string4 = [], collect = [], negatable = [], unknown: unknown2 = (i2) => i2 } = {}) {
  const aliases = {};
  const flags = {
    bools: {},
    strings: {},
    unknownFn: unknown2,
    allBools: false,
    collect: {},
    negatable: {}
  };
  if (alias !== void 0) {
    for (const key in alias) {
      const val = getForce(alias, key);
      if (typeof val === "string") {
        aliases[key] = [
          val
        ];
      } else {
        aliases[key] = val;
      }
      const aliasesForKey = getForce(aliases, key);
      for (const alias2 of aliasesForKey) {
        aliases[alias2] = [
          key
        ].concat(aliasesForKey.filter((y) => alias2 !== y));
      }
    }
  }
  if (boolean4 !== void 0) {
    if (typeof boolean4 === "boolean") {
      flags.allBools = !!boolean4;
    } else {
      const booleanArgs = typeof boolean4 === "string" ? [
        boolean4
      ] : boolean4;
      for (const key of booleanArgs.filter(Boolean)) {
        flags.bools[key] = true;
        const alias2 = get(aliases, key);
        if (alias2) {
          for (const al of alias2) {
            flags.bools[al] = true;
          }
        }
      }
    }
  }
  if (string4 !== void 0) {
    const stringArgs = typeof string4 === "string" ? [
      string4
    ] : string4;
    for (const key of stringArgs.filter(Boolean)) {
      flags.strings[key] = true;
      const alias2 = get(aliases, key);
      if (alias2) {
        for (const al of alias2) {
          flags.strings[al] = true;
        }
      }
    }
  }
  if (collect !== void 0) {
    const collectArgs = typeof collect === "string" ? [
      collect
    ] : collect;
    for (const key of collectArgs.filter(Boolean)) {
      flags.collect[key] = true;
      const alias2 = get(aliases, key);
      if (alias2) {
        for (const al of alias2) {
          flags.collect[al] = true;
        }
      }
    }
  }
  if (negatable !== void 0) {
    const negatableArgs = typeof negatable === "string" ? [
      negatable
    ] : negatable;
    for (const key of negatableArgs.filter(Boolean)) {
      flags.negatable[key] = true;
      const alias2 = get(aliases, key);
      if (alias2) {
        for (const al of alias2) {
          flags.negatable[al] = true;
        }
      }
    }
  }
  const argv = {
    _: []
  };
  function argDefined(key, arg) {
    return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
  }
  function setKey(obj, name, value, collect2 = true) {
    let o2 = obj;
    const keys = name.split(".");
    keys.slice(0, -1).forEach(function(key2) {
      if (get(o2, key2) === void 0) {
        o2[key2] = {};
      }
      o2 = get(o2, key2);
    });
    const key = keys.at(-1);
    const collectable = collect2 && !!get(flags.collect, name);
    if (!collectable) {
      o2[key] = value;
    } else if (get(o2, key) === void 0) {
      o2[key] = [
        value
      ];
    } else if (Array.isArray(get(o2, key))) {
      o2[key].push(value);
    } else {
      o2[key] = [
        get(o2, key),
        value
      ];
    }
  }
  function setArg(key, val, arg = void 0, collect2) {
    if (arg && flags.unknownFn && !argDefined(key, arg)) {
      if (flags.unknownFn(arg, key, val) === false) return;
    }
    const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
    setKey(argv, key, value, collect2);
    const alias2 = get(aliases, key);
    if (alias2) {
      for (const x3 of alias2) {
        setKey(argv, x3, value, collect2);
      }
    }
  }
  function aliasIsBoolean(key) {
    return getForce(aliases, key).some((x3) => typeof get(flags.bools, x3) === "boolean");
  }
  let notFlags = [];
  if (args.includes("--")) {
    notFlags = args.slice(args.indexOf("--") + 1);
    args = args.slice(0, args.indexOf("--"));
  }
  for (let i2 = 0; i2 < args.length; i2++) {
    const arg = args[i2];
    assertExists(arg);
    if (/^--.+=/.test(arg)) {
      const m3 = arg.match(/^--([^=]+)=(.*)$/s);
      assertExists(m3);
      const [, key, value] = m3;
      assertExists(key);
      if (flags.bools[key]) {
        const booleanValue = value !== "false";
        setArg(key, booleanValue, arg);
      } else {
        setArg(key, value, arg);
      }
    } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
      const m3 = arg.match(/^--no-(.+)/);
      assertExists(m3);
      assertExists(m3[1]);
      setArg(m3[1], false, arg, false);
    } else if (/^--.+/.test(arg)) {
      const m3 = arg.match(/^--(.+)/);
      assertExists(m3);
      assertExists(m3[1]);
      const [, key] = m3;
      const next = args[i2 + 1];
      if (next !== void 0 && !/^-/.test(next) && !get(flags.bools, key) && !flags.allBools && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
        setArg(key, next, arg);
        i2++;
      } else if (next !== void 0 && (next === "true" || next === "false")) {
        setArg(key, next === "true", arg);
        i2++;
      } else {
        setArg(key, get(flags.strings, key) ? "" : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      const letters = arg.slice(1, -1).split("");
      let broken = false;
      for (const [j, letter] of letters.entries()) {
        const next = arg.slice(j + 2);
        if (next === "-") {
          setArg(letter, next, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letter) && next.includes("=")) {
          setArg(letter, next.split(/=(.+)/)[1], arg);
          broken = true;
          break;
        }
        if (/[A-Za-z]/.test(letter) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letter, next, arg);
          broken = true;
          break;
        }
        if (letters[j + 1]?.match(/\W/)) {
          setArg(letter, arg.slice(j + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letter, get(flags.strings, letter) ? "" : true, arg);
        }
      }
      const key = arg.at(-1);
      if (!broken && key !== "-") {
        const nextArg = args[i2 + 1];
        if (nextArg && !/^(-|--)[^-]/.test(nextArg) && !get(flags.bools, key) && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
          setArg(key, nextArg, arg);
          i2++;
        } else if (nextArg && (nextArg === "true" || nextArg === "false")) {
          setArg(key, nextArg === "true", arg);
          i2++;
        } else {
          setArg(key, get(flags.strings, key) ? "" : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
      }
      if (stopEarly) {
        argv._.push(...args.slice(i2 + 1));
        break;
      }
    }
  }
  for (const [key, value] of Object.entries(defaults)) {
    if (!hasKey(argv, key.split("."))) {
      setKey(argv, key, value, false);
      const alias2 = aliases[key];
      if (alias2 !== void 0) {
        for (const x3 of alias2) {
          setKey(argv, x3, value, false);
        }
      }
    }
  }
  for (const key of Object.keys(flags.bools)) {
    if (!hasKey(argv, key.split("."))) {
      const value = get(flags.collect, key) ? [] : false;
      setKey(argv, key, value, false);
    }
  }
  for (const key of Object.keys(flags.strings)) {
    if (!hasKey(argv, key.split(".")) && get(flags.collect, key)) {
      setKey(argv, key, [], false);
    }
  }
  if (doubleDash) {
    argv["--"] = [];
    for (const key of notFlags) {
      argv["--"].push(key);
    }
  } else {
    for (const key of notFlags) {
      argv._.push(key);
    }
  }
  return argv;
}

// deno:https://jsr.io/@std/fmt/1.0.8/colors.ts
var colors_exports = {};
__export(colors_exports, {
  bgBlack: () => bgBlack,
  bgBlue: () => bgBlue,
  bgBrightBlack: () => bgBrightBlack,
  bgBrightBlue: () => bgBrightBlue,
  bgBrightCyan: () => bgBrightCyan,
  bgBrightGreen: () => bgBrightGreen,
  bgBrightMagenta: () => bgBrightMagenta,
  bgBrightRed: () => bgBrightRed,
  bgBrightWhite: () => bgBrightWhite,
  bgBrightYellow: () => bgBrightYellow,
  bgCyan: () => bgCyan,
  bgGreen: () => bgGreen2,
  bgMagenta: () => bgMagenta,
  bgRed: () => bgRed2,
  bgRgb24: () => bgRgb24,
  bgRgb8: () => bgRgb8,
  bgWhite: () => bgWhite,
  bgYellow: () => bgYellow,
  black: () => black,
  blue: () => blue,
  bold: () => bold2,
  brightBlack: () => brightBlack2,
  brightBlue: () => brightBlue,
  brightCyan: () => brightCyan,
  brightGreen: () => brightGreen,
  brightMagenta: () => brightMagenta,
  brightRed: () => brightRed,
  brightWhite: () => brightWhite,
  brightYellow: () => brightYellow,
  cyan: () => cyan,
  dim: () => dim,
  getColorEnabled: () => getColorEnabled,
  gray: () => gray2,
  green: () => green2,
  hidden: () => hidden,
  inverse: () => inverse,
  italic: () => italic,
  magenta: () => magenta,
  red: () => red2,
  reset: () => reset,
  rgb24: () => rgb24,
  rgb8: () => rgb8,
  setColorEnabled: () => setColorEnabled,
  strikethrough: () => strikethrough,
  stripAnsiCode: () => stripAnsiCode2,
  underline: () => underline,
  white: () => white2,
  yellow: () => yellow
});
var { Deno: Deno3 } = globalThis;
var noColor2 = typeof Deno3?.noColor === "boolean" ? Deno3.noColor : false;
var enabled2 = !noColor2;
function setColorEnabled(value) {
  if (Deno3?.noColor) {
    return;
  }
  enabled2 = value;
}
function getColorEnabled() {
  return enabled2;
}
function code2(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run2(str, code3) {
  return enabled2 ? `${code3.open}${str.replace(code3.regexp, code3.open)}${code3.close}` : str;
}
function reset(str) {
  return run2(str, code2([
    0
  ], 0));
}
function bold2(str) {
  return run2(str, code2([
    1
  ], 22));
}
function dim(str) {
  return run2(str, code2([
    2
  ], 22));
}
function italic(str) {
  return run2(str, code2([
    3
  ], 23));
}
function underline(str) {
  return run2(str, code2([
    4
  ], 24));
}
function inverse(str) {
  return run2(str, code2([
    7
  ], 27));
}
function hidden(str) {
  return run2(str, code2([
    8
  ], 28));
}
function strikethrough(str) {
  return run2(str, code2([
    9
  ], 29));
}
function black(str) {
  return run2(str, code2([
    30
  ], 39));
}
function red2(str) {
  return run2(str, code2([
    31
  ], 39));
}
function green2(str) {
  return run2(str, code2([
    32
  ], 39));
}
function yellow(str) {
  return run2(str, code2([
    33
  ], 39));
}
function blue(str) {
  return run2(str, code2([
    34
  ], 39));
}
function magenta(str) {
  return run2(str, code2([
    35
  ], 39));
}
function cyan(str) {
  return run2(str, code2([
    36
  ], 39));
}
function white2(str) {
  return run2(str, code2([
    37
  ], 39));
}
function gray2(str) {
  return brightBlack2(str);
}
function brightBlack2(str) {
  return run2(str, code2([
    90
  ], 39));
}
function brightRed(str) {
  return run2(str, code2([
    91
  ], 39));
}
function brightGreen(str) {
  return run2(str, code2([
    92
  ], 39));
}
function brightYellow(str) {
  return run2(str, code2([
    93
  ], 39));
}
function brightBlue(str) {
  return run2(str, code2([
    94
  ], 39));
}
function brightMagenta(str) {
  return run2(str, code2([
    95
  ], 39));
}
function brightCyan(str) {
  return run2(str, code2([
    96
  ], 39));
}
function brightWhite(str) {
  return run2(str, code2([
    97
  ], 39));
}
function bgBlack(str) {
  return run2(str, code2([
    40
  ], 49));
}
function bgRed2(str) {
  return run2(str, code2([
    41
  ], 49));
}
function bgGreen2(str) {
  return run2(str, code2([
    42
  ], 49));
}
function bgYellow(str) {
  return run2(str, code2([
    43
  ], 49));
}
function bgBlue(str) {
  return run2(str, code2([
    44
  ], 49));
}
function bgMagenta(str) {
  return run2(str, code2([
    45
  ], 49));
}
function bgCyan(str) {
  return run2(str, code2([
    46
  ], 49));
}
function bgWhite(str) {
  return run2(str, code2([
    47
  ], 49));
}
function bgBrightBlack(str) {
  return run2(str, code2([
    100
  ], 49));
}
function bgBrightRed(str) {
  return run2(str, code2([
    101
  ], 49));
}
function bgBrightGreen(str) {
  return run2(str, code2([
    102
  ], 49));
}
function bgBrightYellow(str) {
  return run2(str, code2([
    103
  ], 49));
}
function bgBrightBlue(str) {
  return run2(str, code2([
    104
  ], 49));
}
function bgBrightMagenta(str) {
  return run2(str, code2([
    105
  ], 49));
}
function bgBrightCyan(str) {
  return run2(str, code2([
    106
  ], 49));
}
function bgBrightWhite(str) {
  return run2(str, code2([
    107
  ], 49));
}
function clampAndTruncate(n, max = 255, min = 0) {
  return Math.trunc(Math.max(Math.min(n, max), min));
}
function rgb8(str, color) {
  return run2(str, code2([
    38,
    5,
    clampAndTruncate(color)
  ], 39));
}
function bgRgb8(str, color) {
  return run2(str, code2([
    48,
    5,
    clampAndTruncate(color)
  ], 49));
}
function rgb24(str, color) {
  if (typeof color === "number") {
    return run2(str, code2([
      38,
      2,
      color >> 16 & 255,
      color >> 8 & 255,
      color & 255
    ], 39));
  }
  return run2(str, code2([
    38,
    2,
    clampAndTruncate(color.r),
    clampAndTruncate(color.g),
    clampAndTruncate(color.b)
  ], 39));
}
function bgRgb24(str, color) {
  if (typeof color === "number") {
    return run2(str, code2([
      48,
      2,
      color >> 16 & 255,
      color >> 8 & 255,
      color & 255
    ], 49));
  }
  return run2(str, code2([
    48,
    2,
    clampAndTruncate(color.r),
    clampAndTruncate(color.g),
    clampAndTruncate(color.b)
  ], 49));
}
var ANSI_PATTERN2 = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
].join("|"), "g");
function stripAnsiCode2(string4) {
  return string4.replace(ANSI_PATTERN2, "");
}

// deno:https://jsr.io/@std/fs/1.0.19/mod.ts
var mod_exports2 = {};
__export(mod_exports2, {
  CRLF: () => CRLF,
  EOL: () => EOL,
  LF: () => LF,
  copy: () => copy,
  copySync: () => copySync,
  detect: () => detect,
  emptyDir: () => emptyDir,
  emptyDirSync: () => emptyDirSync,
  ensureDir: () => ensureDir,
  ensureDirSync: () => ensureDirSync,
  ensureFile: () => ensureFile,
  ensureFileSync: () => ensureFileSync,
  ensureLink: () => ensureLink,
  ensureLinkSync: () => ensureLinkSync,
  ensureSymlink: () => ensureSymlink,
  ensureSymlinkSync: () => ensureSymlinkSync,
  exists: () => exists,
  existsSync: () => existsSync,
  expandGlob: () => expandGlob,
  expandGlobSync: () => expandGlobSync,
  format: () => format2,
  move: () => move,
  moveSync: () => moveSync,
  walk: () => walk,
  walkSync: () => walkSync
});

// deno:https://jsr.io/@std/internal/1.0.10/_os.ts
function checkWindows() {
  const global2 = globalThis;
  const os = global2.Deno?.build?.os;
  return typeof os === "string" ? os === "windows" : global2.navigator?.platform?.startsWith("Win") ?? global2.process?.platform?.startsWith("win") ?? false;
}

// deno:https://jsr.io/@std/internal/1.0.10/os.ts
var isWindows = checkWindows();

// deno:https://jsr.io/@std/path/1.1.1/_common/assert_path.ts
function assertPath(path) {
  if (typeof path !== "string") {
    throw new TypeError(`Path must be a string, received "${JSON.stringify(path)}"`);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/_common/from_file_url.ts
function assertArg(url2) {
  url2 = url2 instanceof URL ? url2 : new URL(url2);
  if (url2.protocol !== "file:") {
    throw new TypeError(`URL must be a file URL: received "${url2.protocol}"`);
  }
  return url2;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/from_file_url.ts
function fromFileUrl(url2) {
  url2 = assertArg(url2);
  return decodeURIComponent(url2.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

// deno:https://jsr.io/@std/path/1.1.1/_common/normalize.ts
function assertArg2(path) {
  assertPath(path);
  if (path.length === 0) return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/_common/constants.ts
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;

// deno:https://jsr.io/@std/path/1.1.1/_common/normalize_string.ts
function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code3;
  for (let i2 = 0; i2 <= path.length; ++i2) {
    if (i2 < path.length) code3 = path.charCodeAt(i2);
    else if (isPathSeparator3(code3)) break;
    else code3 = CHAR_FORWARD_SLASH;
    if (isPathSeparator3(code3)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) res += `${separator}..`;
          else res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i2);
        else res = path.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code3 === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/_util.ts
function isPosixPathSeparator(code3) {
  return code3 === CHAR_FORWARD_SLASH;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/normalize.ts
function normalize(path) {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertArg2(path);
  const isAbsolute6 = isPosixPathSeparator(path.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));
  path = normalizeString(path, !isAbsolute6, "/", isPosixPathSeparator);
  if (path.length === 0 && !isAbsolute6) path = ".";
  if (path.length > 0 && trailingSeparator) path += "/";
  if (isAbsolute6) return `/${path}`;
  return path;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/join.ts
function join(path, ...paths) {
  if (path === void 0) return ".";
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  paths = path ? [
    path,
    ...paths
  ] : paths;
  paths.forEach((path3) => assertPath(path3));
  const joined = paths.filter((path3) => path3.length > 0).join("/");
  return joined === "" ? "." : normalize(joined);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/_util.ts
function isPosixPathSeparator2(code3) {
  return code3 === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code3) {
  return code3 === CHAR_FORWARD_SLASH || code3 === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code3) {
  return code3 >= CHAR_LOWERCASE_A && code3 <= CHAR_LOWERCASE_Z || code3 >= CHAR_UPPERCASE_A && code3 <= CHAR_UPPERCASE_Z;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/from_file_url.ts
function fromFileUrl2(url2) {
  url2 = assertArg(url2);
  let path = decodeURIComponent(url2.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url2.hostname !== "") {
    path = `\\\\${url2.hostname}${path}`;
  }
  return path;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/normalize.ts
function normalize2(path) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertArg2(path);
  const len = path.length;
  let rootEnd = 0;
  let device;
  let isAbsolute6 = false;
  const code3 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code3)) {
      isAbsolute6 = true;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code3)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) {
            isAbsolute6 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code3)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(path.slice(rootEnd), !isAbsolute6, "\\", isPathSeparator);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute6) tail = ".";
  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute6) {
      if (tail.length > 0) return `\\${tail}`;
      else return "\\";
    }
    return tail;
  } else if (isAbsolute6) {
    if (tail.length > 0) return `${device}\\${tail}`;
    else return `${device}\\`;
  }
  return device + tail;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/join.ts
function join2(path, ...paths) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  paths = path ? [
    path,
    ...paths
  ] : paths;
  paths.forEach((path3) => assertPath(path3));
  paths = paths.filter((path3) => path3.length > 0);
  if (paths.length === 0) return ".";
  let needsReplace = true;
  let slashCount = 0;
  const firstPart = paths[0];
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  let joined = paths.join("\\");
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
    }
    if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize2(joined);
}

// deno:https://jsr.io/@std/path/1.1.1/join.ts
function join3(path, ...paths) {
  return isWindows ? join2(path, ...paths) : join(path, ...paths);
}

// deno:https://jsr.io/@std/path/1.1.1/from_file_url.ts
function fromFileUrl3(url2) {
  return isWindows ? fromFileUrl2(url2) : fromFileUrl(url2);
}

// deno:https://jsr.io/@std/fs/1.0.19/_to_path_string.ts
function toPathString(pathUrl) {
  return pathUrl instanceof URL ? fromFileUrl3(pathUrl) : pathUrl;
}

// deno:https://jsr.io/@std/fs/1.0.19/empty_dir.ts
async function emptyDir(dir) {
  try {
    const items = await Array.fromAsync(Deno.readDir(dir));
    await Promise.all(items.map((item) => {
      if (item && item.name) {
        const filepath = join3(toPathString(dir), item.name);
        return Deno.remove(filepath, {
          recursive: true
        });
      }
    }));
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    await Deno.mkdir(dir, {
      recursive: true
    });
  }
}
function emptyDirSync(dir) {
  try {
    const items = [
      ...Deno.readDirSync(dir)
    ];
    while (items.length) {
      const item = items.shift();
      if (item && item.name) {
        const filepath = join3(toPathString(dir), item.name);
        Deno.removeSync(filepath, {
          recursive: true
        });
      }
    }
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    Deno.mkdirSync(dir, {
      recursive: true
    });
  }
}

// deno:https://jsr.io/@std/fs/1.0.19/_get_file_info_type.ts
function getFileInfoType(fileInfo) {
  return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : void 0;
}

// deno:https://jsr.io/@std/fs/1.0.19/ensure_dir.ts
async function ensureDir(dir) {
  try {
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    await Deno.mkdir(dir, {
      recursive: true
    });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
  }
}
function ensureDirSync(dir) {
  try {
    const fileInfo = Deno.statSync(dir);
    throwIfNotDirectory(fileInfo);
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    Deno.mkdirSync(dir, {
      recursive: true
    });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = Deno.statSync(dir);
    throwIfNotDirectory(fileInfo);
  }
}
function throwIfNotDirectory(fileInfo) {
  if (!fileInfo.isDirectory) {
    throw new Error(`Failed to ensure directory exists: expected 'dir', got '${getFileInfoType(fileInfo)}'`);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/_common/dirname.ts
function assertArg3(path) {
  assertPath(path);
  if (path.length === 0) return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/_common/strip_trailing_separators.ts
function stripTrailingSeparators(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i2 = segment.length - 1; i2 > 0; i2--) {
    if (isSep(segment.charCodeAt(i2))) {
      end = i2;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/dirname.ts
function dirname(path) {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertArg3(path);
  let end = -1;
  let matchedNonSeparator = false;
  for (let i2 = path.length - 1; i2 >= 1; --i2) {
    if (isPosixPathSeparator(path.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        end = i2;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/dirname.ts
function dirname2(path) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertArg3(path);
  const len = path.length;
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code3 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code3)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code3)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code3)) {
    return path;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator(path.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1) return ".";
    else end = rootEnd;
  }
  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator2);
}

// deno:https://jsr.io/@std/path/1.1.1/dirname.ts
function dirname3(path) {
  return isWindows ? dirname2(path) : dirname(path);
}

// deno:https://jsr.io/@std/fs/1.0.19/ensure_file.ts
async function ensureFile(filePath) {
  try {
    const stat = await Deno.lstat(filePath);
    if (!stat.isFile) {
      throw new Error(`Failed to ensure file exists: expected 'file', got '${getFileInfoType(stat)}'`);
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      await ensureDir(dirname3(toPathString(filePath)));
      await Deno.writeFile(filePath, new Uint8Array());
      return;
    }
    throw err;
  }
}
function ensureFileSync(filePath) {
  try {
    const stat = Deno.lstatSync(filePath);
    if (!stat.isFile) {
      throw new Error(`Failed to ensure file exists: expected 'file', got '${getFileInfoType(stat)}'`);
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      ensureDirSync(dirname3(toPathString(filePath)));
      Deno.writeFileSync(filePath, new Uint8Array());
      return;
    }
    throw err;
  }
}

// deno:https://jsr.io/@std/fs/1.0.19/ensure_link.ts
async function ensureLink(src4, dest) {
  dest = toPathString(dest);
  await ensureDir(dirname3(dest));
  await Deno.link(toPathString(src4), dest);
}
function ensureLinkSync(src4, dest) {
  dest = toPathString(dest);
  ensureDirSync(dirname3(dest));
  Deno.linkSync(toPathString(src4), dest);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/resolve.ts
function resolve(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path;
    if (i2 >= 0) path = pathSegments[i2];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path = Deno4.cwd();
    }
    assertPath(path);
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) return `/${resolvedPath}`;
    else return "/";
  } else if (resolvedPath.length > 0) return resolvedPath;
  else return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/windows/resolve.ts
function resolve2(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path;
    const { Deno: Deno4 } = globalThis;
    if (i2 >= 0) {
      path = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a current working directory (CWD)");
      }
      path = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path = Deno4.cwd();
      if (path === void 0 || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path = `${resolvedDevice}\\`;
      }
    }
    assertPath(path);
    const len = path.length;
    if (len === 0) continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute6 = false;
    const code3 = path.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code3)) {
        isAbsolute6 = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path.charCodeAt(j))) break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code3)) {
        if (path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path.charCodeAt(2))) {
              isAbsolute6 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code3)) {
      rootEnd = 1;
      isAbsolute6 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute6;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0) break;
  }
  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}

// deno:https://jsr.io/@std/path/1.1.1/resolve.ts
function resolve3(...pathSegments) {
  return isWindows ? resolve2(...pathSegments) : resolve(...pathSegments);
}

// deno:https://jsr.io/@std/fs/1.0.19/ensure_symlink.ts
function resolveSymlinkTarget(target, linkName) {
  if (typeof target !== "string") return target;
  if (typeof linkName === "string") {
    return resolve3(dirname3(linkName), target);
  } else {
    return new URL(target, linkName);
  }
}
function getSymlinkOption(type) {
  return isWindows ? {
    type: type === "dir" ? "dir" : "file"
  } : void 0;
}
async function ensureSymlink(target, linkName) {
  const targetRealPath = resolveSymlinkTarget(target, linkName);
  let srcStatInfo;
  try {
    srcStatInfo = await Deno.lstat(targetRealPath);
  } catch (error40) {
    if (error40 instanceof Deno.errors.NotFound) {
      throw new Deno.errors.NotFound(`Cannot ensure symlink as the target path does not exist: ${targetRealPath}`);
    }
    throw error40;
  }
  const srcFilePathType = getFileInfoType(srcStatInfo);
  await ensureDir(dirname3(toPathString(linkName)));
  const options3 = getSymlinkOption(srcFilePathType);
  try {
    await Deno.symlink(target, linkName, options3);
  } catch (error40) {
    if (!(error40 instanceof Deno.errors.AlreadyExists)) {
      throw error40;
    }
    const linkStatInfo = await Deno.lstat(linkName);
    if (!linkStatInfo.isSymlink) {
      const type = getFileInfoType(linkStatInfo);
      throw new Deno.errors.AlreadyExists(`A '${type}' already exists at the path: ${linkName}`);
    }
    const linkPath = await Deno.readLink(linkName);
    const linkRealPath = resolve3(linkPath);
    if (linkRealPath !== targetRealPath) {
      throw new Deno.errors.AlreadyExists(`A symlink targeting to an undesired path already exists: ${linkName} -> ${linkRealPath}`);
    }
  }
}
function ensureSymlinkSync(target, linkName) {
  const targetRealPath = resolveSymlinkTarget(target, linkName);
  let srcStatInfo;
  try {
    srcStatInfo = Deno.lstatSync(targetRealPath);
  } catch (error40) {
    if (error40 instanceof Deno.errors.NotFound) {
      throw new Deno.errors.NotFound(`Cannot ensure symlink as the target path does not exist: ${targetRealPath}`);
    }
    throw error40;
  }
  const srcFilePathType = getFileInfoType(srcStatInfo);
  ensureDirSync(dirname3(toPathString(linkName)));
  const options3 = getSymlinkOption(srcFilePathType);
  try {
    Deno.symlinkSync(target, linkName, options3);
  } catch (error40) {
    if (!(error40 instanceof Deno.errors.AlreadyExists)) {
      throw error40;
    }
    const linkStatInfo = Deno.lstatSync(linkName);
    if (!linkStatInfo.isSymlink) {
      const type = getFileInfoType(linkStatInfo);
      throw new Deno.errors.AlreadyExists(`A '${type}' already exists at the path: ${linkName}`);
    }
    const linkPath = Deno.readLinkSync(linkName);
    const linkRealPath = resolve3(linkPath);
    if (linkRealPath !== targetRealPath) {
      throw new Deno.errors.AlreadyExists(`A symlink targeting to an undesired path already exists: ${linkName} -> ${linkRealPath}`);
    }
  }
}

// deno:https://jsr.io/@std/fs/1.0.19/exists.ts
async function exists(path, options3) {
  try {
    const stat = await Deno.stat(path);
    if (options3 && (options3.isReadable || options3.isDirectory || options3.isFile)) {
      if (options3.isDirectory && options3.isFile) {
        throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together");
      }
      if (options3.isDirectory && !stat.isDirectory || options3.isFile && !stat.isFile) {
        return false;
      }
      if (options3.isReadable) {
        return fileIsReadable(stat);
      }
    }
    return true;
  } catch (error40) {
    if (error40 instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error40 instanceof Deno.errors.PermissionDenied) {
      if ((await Deno.permissions.query({
        name: "read",
        path
      })).state === "granted") {
        return !options3?.isReadable;
      }
    }
    throw error40;
  }
}
function existsSync(path, options3) {
  try {
    const stat = Deno.statSync(path);
    if (options3 && (options3.isReadable || options3.isDirectory || options3.isFile)) {
      if (options3.isDirectory && options3.isFile) {
        throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together");
      }
      if (options3.isDirectory && !stat.isDirectory || options3.isFile && !stat.isFile) {
        return false;
      }
      if (options3.isReadable) {
        return fileIsReadable(stat);
      }
    }
    return true;
  } catch (error40) {
    if (error40 instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error40 instanceof Deno.errors.PermissionDenied) {
      if (Deno.permissions.querySync({
        name: "read",
        path
      }).state === "granted") {
        return !options3?.isReadable;
      }
    }
    throw error40;
  }
}
function fileIsReadable(stat) {
  if (stat.mode === null) {
    return true;
  } else if (Deno.uid() === stat.uid) {
    return (stat.mode & 256) === 256;
  } else if (Deno.gid() === stat.gid) {
    return (stat.mode & 32) === 32;
  }
  return (stat.mode & 4) === 4;
}

// deno:https://jsr.io/@std/path/1.1.1/_common/glob_to_reg_exp.ts
var REG_EXP_ESCAPE_CHARS = [
  "!",
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "=",
  "?",
  "[",
  "\\",
  "^",
  "{",
  "|"
];
var RANGE_ESCAPE_CHARS = [
  "-",
  "\\",
  "]"
];
function _globToRegExp(c, glob, { extended = true, globstar: globstarOption = true, caseInsensitive = false } = {}) {
  if (glob === "") {
    return /(?!)/;
  }
  let newLength = glob.length;
  for (; newLength > 1 && c.seps.includes(glob[newLength - 1]); newLength--) ;
  glob = glob.slice(0, newLength);
  let regExpString = "";
  for (let j = 0; j < glob.length; ) {
    let segment = "";
    const groupStack = [];
    let inRange = false;
    let inEscape = false;
    let endsWithSep = false;
    let i2 = j;
    for (; i2 < glob.length && !c.seps.includes(glob[i2]); i2++) {
      if (inEscape) {
        inEscape = false;
        const escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;
        segment += escapeChars.includes(glob[i2]) ? `\\${glob[i2]}` : glob[i2];
        continue;
      }
      if (glob[i2] === c.escapePrefix) {
        inEscape = true;
        continue;
      }
      if (glob[i2] === "[") {
        if (!inRange) {
          inRange = true;
          segment += "[";
          if (glob[i2 + 1] === "!") {
            i2++;
            segment += "^";
          } else if (glob[i2 + 1] === "^") {
            i2++;
            segment += "\\^";
          }
          continue;
        } else if (glob[i2 + 1] === ":") {
          let k = i2 + 1;
          let value = "";
          while (glob[k + 1] !== void 0 && glob[k + 1] !== ":") {
            value += glob[k + 1];
            k++;
          }
          if (glob[k + 1] === ":" && glob[k + 2] === "]") {
            i2 = k + 2;
            if (value === "alnum") segment += "\\dA-Za-z";
            else if (value === "alpha") segment += "A-Za-z";
            else if (value === "ascii") segment += "\0-\x7F";
            else if (value === "blank") segment += "	 ";
            else if (value === "cntrl") segment += "\0-\x7F";
            else if (value === "digit") segment += "\\d";
            else if (value === "graph") segment += "!-~";
            else if (value === "lower") segment += "a-z";
            else if (value === "print") segment += " -~";
            else if (value === "punct") {
              segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_\u2018{|}~`;
            } else if (value === "space") segment += "\\s\v";
            else if (value === "upper") segment += "A-Z";
            else if (value === "word") segment += "\\w";
            else if (value === "xdigit") segment += "\\dA-Fa-f";
            continue;
          }
        }
      }
      if (glob[i2] === "]" && inRange) {
        inRange = false;
        segment += "]";
        continue;
      }
      if (inRange) {
        segment += glob[i2];
        continue;
      }
      if (glob[i2] === ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
        segment += ")";
        const type = groupStack.pop();
        if (type === "!") {
          segment += c.wildcard;
        } else if (type !== "@") {
          segment += type;
        }
        continue;
      }
      if (glob[i2] === "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i2] === "+" && extended && glob[i2 + 1] === "(") {
        i2++;
        groupStack.push("+");
        segment += "(?:";
        continue;
      }
      if (glob[i2] === "@" && extended && glob[i2 + 1] === "(") {
        i2++;
        groupStack.push("@");
        segment += "(?:";
        continue;
      }
      if (glob[i2] === "?") {
        if (extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("?");
          segment += "(?:";
        } else {
          segment += ".";
        }
        continue;
      }
      if (glob[i2] === "!" && extended && glob[i2 + 1] === "(") {
        i2++;
        groupStack.push("!");
        segment += "(?!";
        continue;
      }
      if (glob[i2] === "{") {
        groupStack.push("BRACE");
        segment += "(?:";
        continue;
      }
      if (glob[i2] === "}" && groupStack[groupStack.length - 1] === "BRACE") {
        groupStack.pop();
        segment += ")";
        continue;
      }
      if (glob[i2] === "," && groupStack[groupStack.length - 1] === "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i2] === "*") {
        if (extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("*");
          segment += "(?:";
        } else {
          const prevChar = glob[i2 - 1];
          let numStars = 1;
          while (glob[i2 + 1] === "*") {
            i2++;
            numStars++;
          }
          const nextChar = glob[i2 + 1];
          if (globstarOption && numStars === 2 && [
            ...c.seps,
            void 0
          ].includes(prevChar) && [
            ...c.seps,
            void 0
          ].includes(nextChar)) {
            segment += c.globstar;
            endsWithSep = true;
          } else {
            segment += c.wildcard;
          }
        }
        continue;
      }
      segment += REG_EXP_ESCAPE_CHARS.includes(glob[i2]) ? `\\${glob[i2]}` : glob[i2];
    }
    if (groupStack.length > 0 || inRange || inEscape) {
      segment = "";
      for (const c2 of glob.slice(j, i2)) {
        segment += REG_EXP_ESCAPE_CHARS.includes(c2) ? `\\${c2}` : c2;
        endsWithSep = false;
      }
    }
    regExpString += segment;
    if (!endsWithSep) {
      regExpString += i2 < glob.length ? c.sep : c.sepMaybe;
      endsWithSep = true;
    }
    while (c.seps.includes(glob[i2])) i2++;
    j = i2;
  }
  regExpString = `^${regExpString}$`;
  return new RegExp(regExpString, caseInsensitive ? "i" : "");
}

// deno:https://jsr.io/@std/path/1.1.1/posix/glob_to_regexp.ts
var constants = {
  sep: "/+",
  sepMaybe: "/*",
  seps: [
    "/"
  ],
  globstar: "(?:[^/]*(?:/|$)+)*",
  wildcard: "[^/]*",
  escapePrefix: "\\"
};
function globToRegExp(glob, options3 = {}) {
  return _globToRegExp(constants, glob, options3);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/glob_to_regexp.ts
var constants2 = {
  sep: "(?:\\\\|/)+",
  sepMaybe: "(?:\\\\|/)*",
  seps: [
    "\\",
    "/"
  ],
  globstar: "(?:[^\\\\/]*(?:\\\\|/|$)+)*",
  wildcard: "[^\\\\/]*",
  escapePrefix: "`"
};
function globToRegExp2(glob, options3 = {}) {
  return _globToRegExp(constants2, glob, options3);
}

// deno:https://jsr.io/@std/path/1.1.1/glob_to_regexp.ts
function globToRegExp3(glob, options3 = {}) {
  return isWindows ? globToRegExp2(glob, options3) : globToRegExp(glob, options3);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/constants.ts
var SEPARATOR = "/";
var SEPARATOR_PATTERN = /\/+/;

// deno:https://jsr.io/@std/path/1.1.1/posix/normalize_glob.ts
function normalizeGlob(glob, options3 = {}) {
  const { globstar = false } = options3;
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize(glob);
  }
  const s = SEPARATOR_PATTERN.source;
  const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
  return normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}

// deno:https://jsr.io/@std/path/1.1.1/posix/join_globs.ts
function joinGlobs(globs, options3 = {}) {
  const { globstar = false } = options3;
  if (!globstar || globs.length === 0) {
    return join(...globs);
  }
  let joined;
  for (const glob of globs) {
    const path = glob;
    if (path.length > 0) {
      if (!joined) joined = path;
      else joined += `${SEPARATOR}${path}`;
    }
  }
  if (!joined) return ".";
  return normalizeGlob(joined, {
    globstar
  });
}

// deno:https://jsr.io/@std/path/1.1.1/windows/constants.ts
var SEPARATOR2 = "\\";
var SEPARATOR_PATTERN2 = /[\\/]+/;

// deno:https://jsr.io/@std/path/1.1.1/windows/normalize_glob.ts
function normalizeGlob2(glob, options3 = {}) {
  const { globstar = false } = options3;
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize2(glob);
  }
  const s = SEPARATOR_PATTERN2.source;
  const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
  return normalize2(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}

// deno:https://jsr.io/@std/path/1.1.1/windows/join_globs.ts
function joinGlobs2(globs, options3 = {}) {
  const { globstar = false } = options3;
  if (!globstar || globs.length === 0) {
    return join2(...globs);
  }
  let joined;
  for (const glob of globs) {
    const path = glob;
    if (path.length > 0) {
      if (!joined) joined = path;
      else joined += `${SEPARATOR2}${path}`;
    }
  }
  if (!joined) return ".";
  return normalizeGlob2(joined, {
    globstar
  });
}

// deno:https://jsr.io/@std/path/1.1.1/join_globs.ts
function joinGlobs3(globs, options3 = {}) {
  return isWindows ? joinGlobs2(globs, options3) : joinGlobs(globs, options3);
}

// deno:https://jsr.io/@std/path/1.1.1/is_glob.ts
function isGlob(str) {
  const chars = {
    "{": "}",
    "(": ")",
    "[": "]"
  };
  const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  if (str === "") {
    return false;
  }
  let match;
  while (match = regex.exec(str)) {
    if (match[2]) return true;
    let idx = match.index + match[0].length;
    const open = match[1];
    const close = open ? chars[open] : null;
    if (open && close) {
      const n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }
    str = str.slice(idx);
  }
  return false;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/is_absolute.ts
function isAbsolute(path) {
  assertPath(path);
  return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));
}

// deno:https://jsr.io/@std/path/1.1.1/windows/is_absolute.ts
function isAbsolute2(path) {
  assertPath(path);
  const len = path.length;
  if (len === 0) return false;
  const code3 = path.charCodeAt(0);
  if (isPathSeparator(code3)) {
    return true;
  } else if (isWindowsDeviceRoot(code3)) {
    if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {
      if (isPathSeparator(path.charCodeAt(2))) return true;
    }
  }
  return false;
}

// deno:https://jsr.io/@std/path/1.1.1/is_absolute.ts
function isAbsolute3(path) {
  return isWindows ? isAbsolute2(path) : isAbsolute(path);
}

// deno:https://jsr.io/@std/path/1.1.1/constants.ts
var DELIMITER = isWindows ? ";" : ":";
var SEPARATOR3 = isWindows ? "\\" : "/";
var SEPARATOR_PATTERN3 = isWindows ? /[\\/]+/ : /\/+/;

// deno:https://jsr.io/@std/path/1.1.1/_common/basename.ts
function stripSuffix(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i2 = suffix.length - 1; i2 >= 0; --i2) {
    if (name.charCodeAt(lenDiff + i2) !== suffix.charCodeAt(i2)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}
function lastPathSegment(path, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path.length;
  for (let i2 = path.length - 1; i2 >= start; --i2) {
    if (isSep(path.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        start = i2 + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i2 + 1;
    }
  }
  return path.slice(start, end);
}
function assertArgs(path, suffix) {
  assertPath(path);
  if (path.length === 0) return path;
  if (typeof suffix !== "string") {
    throw new TypeError(`Suffix must be a string, received "${JSON.stringify(suffix)}"`);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/posix/basename.ts
function basename(path, suffix = "") {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertArgs(path, suffix);
  const lastSegment = lastPathSegment(path, isPosixPathSeparator);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/basename.ts
function basename2(path, suffix = "") {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertArgs(path, suffix);
  let start = 0;
  if (path.length >= 2) {
    const drive = path.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path.charCodeAt(1) === CHAR_COLON) start = 2;
    }
  }
  const lastSegment = lastPathSegment(path, isPathSeparator, start);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}

// deno:https://jsr.io/@std/path/1.1.1/basename.ts
function basename3(path, suffix = "") {
  return isWindows ? basename2(path, suffix) : basename(path, suffix);
}

// deno:https://jsr.io/@std/path/1.1.1/normalize.ts
function normalize3(path) {
  return isWindows ? normalize2(path) : normalize(path);
}

// deno:https://jsr.io/@std/fs/1.0.19/_create_walk_entry.ts
function createWalkEntrySync(path) {
  path = toPathString(path);
  path = normalize3(path);
  const name = basename3(path);
  const info = Deno.statSync(path);
  return {
    path,
    name,
    isFile: info.isFile,
    isDirectory: info.isDirectory,
    isSymlink: info.isSymlink
  };
}
async function createWalkEntry(path) {
  path = toPathString(path);
  path = normalize3(path);
  const name = basename3(path);
  const info = await Deno.stat(path);
  return {
    path,
    name,
    isFile: info.isFile,
    isDirectory: info.isDirectory,
    isSymlink: info.isSymlink
  };
}

// deno:https://jsr.io/@std/fs/1.0.19/walk.ts
function include(path, exts, match, skip) {
  if (exts && !exts.some((ext) => path.endsWith(ext))) {
    return false;
  }
  if (match && !match.some((pattern) => !!path.match(pattern))) {
    return false;
  }
  if (skip && skip.some((pattern) => !!path.match(pattern))) {
    return false;
  }
  return true;
}
async function* walk(root, options3) {
  let { maxDepth = Infinity, includeFiles = true, includeDirs = true, includeSymlinks = true, followSymlinks = false, canonicalize = true, exts = void 0, match = void 0, skip = void 0 } = options3 ?? {};
  if (maxDepth < 0) {
    return;
  }
  root = toPathString(root);
  if (exts) {
    exts = exts.map((ext) => ext.startsWith(".") ? ext : `.${ext}`);
  }
  if (includeDirs && include(root, exts, match, skip)) {
    yield await createWalkEntry(root);
  }
  if (maxDepth < 1 || !include(root, void 0, void 0, skip)) {
    return;
  }
  for await (const entry of Deno.readDir(root)) {
    let path = join3(root, entry.name);
    let { isSymlink, isDirectory } = entry;
    if (isSymlink) {
      if (!followSymlinks) {
        if (includeSymlinks && include(path, exts, match, skip)) {
          yield {
            path,
            ...entry
          };
        }
        continue;
      }
      const realPath = await Deno.realPath(path);
      if (canonicalize) {
        path = realPath;
      }
      ({ isSymlink, isDirectory } = await Deno.lstat(realPath));
    }
    if (isSymlink || isDirectory) {
      const opts = {
        maxDepth: maxDepth - 1,
        includeFiles,
        includeDirs,
        includeSymlinks,
        followSymlinks
      };
      if (exts !== void 0) {
        opts.exts = exts;
      }
      if (match !== void 0) {
        opts.match = match;
      }
      if (skip !== void 0) {
        opts.skip = skip;
      }
      yield* walk(path, opts);
    } else if (includeFiles && include(path, exts, match, skip)) {
      yield {
        path,
        ...entry
      };
    }
  }
}
function* walkSync(root, options3) {
  let { maxDepth = Infinity, includeFiles = true, includeDirs = true, includeSymlinks = true, followSymlinks = false, canonicalize = true, exts = void 0, match = void 0, skip = void 0 } = options3 ?? {};
  root = toPathString(root);
  if (exts) {
    exts = exts.map((ext) => ext.startsWith(".") ? ext : `.${ext}`);
  }
  if (maxDepth < 0) {
    return;
  }
  if (includeDirs && include(root, exts, match, skip)) {
    yield createWalkEntrySync(root);
  }
  if (maxDepth < 1 || !include(root, void 0, void 0, skip)) {
    return;
  }
  const entries = Deno.readDirSync(root);
  for (const entry of entries) {
    let path = join3(root, entry.name);
    let { isSymlink, isDirectory } = entry;
    if (isSymlink) {
      if (!followSymlinks) {
        if (includeSymlinks && include(path, exts, match, skip)) {
          yield {
            path,
            ...entry
          };
        }
        continue;
      }
      const realPath = Deno.realPathSync(path);
      if (canonicalize) {
        path = realPath;
      }
      ({ isSymlink, isDirectory } = Deno.lstatSync(realPath));
    }
    if (isSymlink || isDirectory) {
      const opts = {
        maxDepth: maxDepth - 1,
        includeFiles,
        includeDirs,
        includeSymlinks,
        followSymlinks
      };
      if (exts !== void 0) {
        opts.exts = exts;
      }
      if (match !== void 0) {
        opts.match = match;
      }
      if (skip !== void 0) {
        opts.skip = skip;
      }
      yield* walkSync(path, opts);
    } else if (includeFiles && include(path, exts, match, skip)) {
      yield {
        path,
        ...entry
      };
    }
  }
}

// deno:https://jsr.io/@std/fs/1.0.19/expand_glob.ts
function split(path) {
  const s = SEPARATOR_PATTERN3.source;
  const segments = path.replace(new RegExp(`^${s}|${s}$`, "g"), "").split(SEPARATOR_PATTERN3);
  const isAbsolute_ = isAbsolute3(path);
  const split2 = {
    segments,
    isAbsolute: isAbsolute_,
    hasTrailingSep: path.match(new RegExp(`${s}$`)) !== null
  };
  if (isWindows && isAbsolute_) {
    split2.winRoot = segments.shift();
  }
  return split2;
}
function throwUnlessNotFound(error40) {
  if (!(error40 instanceof Deno.errors.NotFound)) {
    throw error40;
  }
}
function comparePath(a, b) {
  if (a.path < b.path) return -1;
  if (a.path > b.path) return 1;
  return 0;
}
async function* expandGlob(glob, options3) {
  let { root, exclude = [], includeDirs = true, extended = true, globstar = true, caseInsensitive = false, followSymlinks = false, canonicalize = true } = options3 ?? {};
  const { segments, isAbsolute: isGlobAbsolute, hasTrailingSep, winRoot } = split(toPathString(glob));
  root ??= isGlobAbsolute ? winRoot ?? "/" : Deno.cwd();
  const globOptions = {
    extended,
    globstar,
    caseInsensitive
  };
  const absRoot = isGlobAbsolute ? root : resolve3(root);
  const resolveFromRoot = (path) => resolve3(absRoot, path);
  const excludePatterns = exclude.map(resolveFromRoot).map((s) => globToRegExp3(s, globOptions));
  const shouldInclude = (path) => !excludePatterns.some((p) => !!path.match(p));
  let fixedRoot = isGlobAbsolute ? winRoot ?? "/" : absRoot;
  while (segments.length > 0 && !isGlob(segments[0])) {
    const seg = segments.shift();
    fixedRoot = joinGlobs3([
      fixedRoot,
      seg
    ], globOptions);
  }
  let fixedRootInfo;
  try {
    fixedRootInfo = await createWalkEntry(fixedRoot);
  } catch (error40) {
    return throwUnlessNotFound(error40);
  }
  async function* advanceMatch(walkInfo, globSegment) {
    if (!walkInfo.isDirectory) {
      return;
    } else if (globSegment === "..") {
      const parentPath = joinGlobs3([
        walkInfo.path,
        ".."
      ], globOptions);
      if (shouldInclude(parentPath)) {
        return yield await createWalkEntry(parentPath);
      }
      return;
    } else if (globSegment === "**") {
      return yield* walk(walkInfo.path, {
        skip: excludePatterns,
        maxDepth: globstar ? Infinity : 1,
        followSymlinks,
        canonicalize
      });
    }
    const globPattern = globToRegExp3(globSegment, globOptions);
    for await (const walkEntry of walk(walkInfo.path, {
      maxDepth: 1,
      skip: excludePatterns,
      followSymlinks
    })) {
      if (walkEntry.path !== walkInfo.path && walkEntry.name.match(globPattern)) {
        yield walkEntry;
      }
    }
  }
  let currentMatches = [
    fixedRootInfo
  ];
  for (const segment of segments) {
    const nextMatchMap = /* @__PURE__ */ new Map();
    await Promise.all(currentMatches.map(async (currentMatch) => {
      for await (const nextMatch of advanceMatch(currentMatch, segment)) {
        nextMatchMap.set(nextMatch.path, nextMatch);
      }
    }));
    currentMatches = [
      ...nextMatchMap.values()
    ].sort(comparePath);
  }
  if (hasTrailingSep) {
    currentMatches = currentMatches.filter((entry) => entry.isDirectory);
  }
  if (!includeDirs) {
    currentMatches = currentMatches.filter((entry) => !entry.isDirectory);
  }
  yield* currentMatches;
}
function* expandGlobSync(glob, options3) {
  let { root, exclude = [], includeDirs = true, extended = true, globstar = true, caseInsensitive = false, followSymlinks = false, canonicalize = true } = options3 ?? {};
  const { segments, isAbsolute: isGlobAbsolute, hasTrailingSep, winRoot } = split(toPathString(glob));
  root ??= isGlobAbsolute ? winRoot ?? "/" : Deno.cwd();
  const globOptions = {
    extended,
    globstar,
    caseInsensitive
  };
  const absRoot = isGlobAbsolute ? root : resolve3(root);
  const resolveFromRoot = (path) => resolve3(absRoot, path);
  const excludePatterns = exclude.map(resolveFromRoot).map((s) => globToRegExp3(s, globOptions));
  const shouldInclude = (path) => !excludePatterns.some((p) => !!path.match(p));
  let fixedRoot = isGlobAbsolute ? winRoot ?? "/" : absRoot;
  while (segments.length > 0 && !isGlob(segments[0])) {
    const seg = segments.shift();
    fixedRoot = joinGlobs3([
      fixedRoot,
      seg
    ], globOptions);
  }
  let fixedRootInfo;
  try {
    fixedRootInfo = createWalkEntrySync(fixedRoot);
  } catch (error40) {
    return throwUnlessNotFound(error40);
  }
  function* advanceMatch(walkInfo, globSegment) {
    if (!walkInfo.isDirectory) {
      return;
    } else if (globSegment === "..") {
      const parentPath = joinGlobs3([
        walkInfo.path,
        ".."
      ], globOptions);
      if (shouldInclude(parentPath)) {
        return yield createWalkEntrySync(parentPath);
      }
      return;
    } else if (globSegment === "**") {
      return yield* walkSync(walkInfo.path, {
        skip: excludePatterns,
        maxDepth: globstar ? Infinity : 1,
        followSymlinks,
        canonicalize
      });
    }
    const globPattern = globToRegExp3(globSegment, globOptions);
    for (const walkEntry of walkSync(walkInfo.path, {
      maxDepth: 1,
      skip: excludePatterns,
      followSymlinks
    })) {
      if (walkEntry.path !== walkInfo.path && walkEntry.name.match(globPattern)) {
        yield walkEntry;
      }
    }
  }
  let currentMatches = [
    fixedRootInfo
  ];
  for (const segment of segments) {
    const nextMatchMap = /* @__PURE__ */ new Map();
    for (const currentMatch of currentMatches) {
      for (const nextMatch of advanceMatch(currentMatch, segment)) {
        nextMatchMap.set(nextMatch.path, nextMatch);
      }
    }
    currentMatches = [
      ...nextMatchMap.values()
    ].sort(comparePath);
  }
  if (hasTrailingSep) {
    currentMatches = currentMatches.filter((entry) => entry.isDirectory);
  }
  if (!includeDirs) {
    currentMatches = currentMatches.filter((entry) => !entry.isDirectory);
  }
  yield* currentMatches;
}

// deno:https://jsr.io/@std/fs/1.0.19/_is_subdir.ts
function isSubdir(src4, dest, sep = SEPARATOR3) {
  src4 = toPathString(src4);
  dest = toPathString(dest);
  if (resolve3(src4) === resolve3(dest)) {
    return false;
  }
  const srcArray = src4.split(sep);
  const destArray = dest.split(sep);
  return srcArray.every((current, i2) => destArray[i2] === current);
}

// deno:https://jsr.io/@std/fs/1.0.19/_is_same_path.ts
function isSamePath(src4, dest) {
  src4 = toPathString(src4);
  dest = toPathString(dest);
  return resolve3(src4) === resolve3(dest);
}

// deno:https://jsr.io/@std/fs/1.0.19/move.ts
var EXISTS_ERROR = new Deno.errors.AlreadyExists("dest already exists.");
async function move(src4, dest, options3) {
  const { overwrite = false } = options3 ?? {};
  const srcStat = await Deno.stat(src4);
  if (srcStat.isDirectory && (isSubdir(src4, dest) || isSamePath(src4, dest))) {
    throw new Deno.errors.NotSupported(`Cannot move '${src4}' to a subdirectory of itself, '${dest}'.`);
  }
  if (overwrite) {
    if (isSamePath(src4, dest)) return;
    try {
      await Deno.remove(dest, {
        recursive: true
      });
    } catch (error40) {
      if (!(error40 instanceof Deno.errors.NotFound)) {
        throw error40;
      }
    }
  } else {
    try {
      await Deno.lstat(dest);
      return Promise.reject(EXISTS_ERROR);
    } catch {
    }
  }
  await Deno.rename(src4, dest);
}
function moveSync(src4, dest, options3) {
  const { overwrite = false } = options3 ?? {};
  const srcStat = Deno.statSync(src4);
  if (srcStat.isDirectory && (isSubdir(src4, dest) || isSamePath(src4, dest))) {
    throw new Deno.errors.NotSupported(`Cannot move '${src4}' to a subdirectory of itself, '${dest}'.`);
  }
  if (overwrite) {
    if (isSamePath(src4, dest)) return;
    try {
      Deno.removeSync(dest, {
        recursive: true
      });
    } catch (error40) {
      if (!(error40 instanceof Deno.errors.NotFound)) {
        throw error40;
      }
    }
  } else {
    try {
      Deno.lstatSync(dest);
      throw EXISTS_ERROR;
    } catch (error40) {
      if (error40 === EXISTS_ERROR) {
        throw error40;
      }
    }
  }
  Deno.renameSync(src4, dest);
}

// deno:https://jsr.io/@std/fs/1.0.19/copy.ts
function assertIsDate(date5, name) {
  if (date5 === null) {
    throw new Error(`${name} is unavailable`);
  }
}
async function ensureValidCopy(src4, dest, options3) {
  let destStat;
  try {
    destStat = await Deno.lstat(dest);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return;
    }
    throw err;
  }
  if (options3.isFolder && !destStat.isDirectory) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src4}'`);
  }
  if (!options3.overwrite) {
    throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
  }
  return destStat;
}
function ensureValidCopySync(src4, dest, options3) {
  let destStat;
  try {
    destStat = Deno.lstatSync(dest);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return;
    }
    throw err;
  }
  if (options3.isFolder && !destStat.isDirectory) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src4}'`);
  }
  if (!options3.overwrite) {
    throw new Deno.errors.AlreadyExists(`'${dest}' already exists`);
  }
  return destStat;
}
async function copyFile(src4, dest, options3) {
  await ensureValidCopy(src4, dest, options3);
  await Deno.copyFile(src4, dest);
  if (options3.preserveTimestamps) {
    const statInfo = await Deno.stat(src4);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    await Deno.utime(dest, statInfo.atime, statInfo.mtime);
  }
}
function copyFileSync(src4, dest, options3) {
  ensureValidCopySync(src4, dest, options3);
  Deno.copyFileSync(src4, dest);
  if (options3.preserveTimestamps) {
    const statInfo = Deno.statSync(src4);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copySymLink(src4, dest, options3) {
  await ensureValidCopy(src4, dest, options3);
  const originSrcFilePath = await Deno.readLink(src4);
  const type = getFileInfoType(await Deno.lstat(src4));
  if (isWindows) {
    await Deno.symlink(originSrcFilePath, dest, {
      type: type === "dir" ? "dir" : "file"
    });
  } else {
    await Deno.symlink(originSrcFilePath, dest);
  }
  if (options3.preserveTimestamps) {
    const statInfo = await Deno.lstat(src4);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    await Deno.utime(dest, statInfo.atime, statInfo.mtime);
  }
}
function copySymlinkSync(src4, dest, options3) {
  ensureValidCopySync(src4, dest, options3);
  const originSrcFilePath = Deno.readLinkSync(src4);
  const type = getFileInfoType(Deno.lstatSync(src4));
  if (isWindows) {
    Deno.symlinkSync(originSrcFilePath, dest, {
      type: type === "dir" ? "dir" : "file"
    });
  } else {
    Deno.symlinkSync(originSrcFilePath, dest);
  }
  if (options3.preserveTimestamps) {
    const statInfo = Deno.lstatSync(src4);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copyDir(src4, dest, options3) {
  const destStat = await ensureValidCopy(src4, dest, {
    ...options3,
    isFolder: true
  });
  if (!destStat) {
    await ensureDir(dest);
  }
  if (options3.preserveTimestamps) {
    const srcStatInfo = await Deno.stat(src4);
    assertIsDate(srcStatInfo.atime, "statInfo.atime");
    assertIsDate(srcStatInfo.mtime, "statInfo.mtime");
    await Deno.utime(dest, srcStatInfo.atime, srcStatInfo.mtime);
  }
  src4 = toPathString(src4);
  dest = toPathString(dest);
  const promises = [];
  for await (const entry of Deno.readDir(src4)) {
    const srcPath = join3(src4, entry.name);
    const destPath = join3(dest, basename3(srcPath));
    if (entry.isSymlink) {
      promises.push(copySymLink(srcPath, destPath, options3));
    } else if (entry.isDirectory) {
      promises.push(copyDir(srcPath, destPath, options3));
    } else if (entry.isFile) {
      promises.push(copyFile(srcPath, destPath, options3));
    }
  }
  await Promise.all(promises);
}
function copyDirSync(src4, dest, options3) {
  const destStat = ensureValidCopySync(src4, dest, {
    ...options3,
    isFolder: true
  });
  if (!destStat) {
    ensureDirSync(dest);
  }
  if (options3.preserveTimestamps) {
    const srcStatInfo = Deno.statSync(src4);
    assertIsDate(srcStatInfo.atime, "statInfo.atime");
    assertIsDate(srcStatInfo.mtime, "statInfo.mtime");
    Deno.utimeSync(dest, srcStatInfo.atime, srcStatInfo.mtime);
  }
  src4 = toPathString(src4);
  dest = toPathString(dest);
  for (const entry of Deno.readDirSync(src4)) {
    const srcPath = join3(src4, entry.name);
    const destPath = join3(dest, basename3(srcPath));
    if (entry.isSymlink) {
      copySymlinkSync(srcPath, destPath, options3);
    } else if (entry.isDirectory) {
      copyDirSync(srcPath, destPath, options3);
    } else if (entry.isFile) {
      copyFileSync(srcPath, destPath, options3);
    }
  }
}
async function copy(src4, dest, options3 = {}) {
  src4 = resolve3(toPathString(src4));
  dest = resolve3(toPathString(dest));
  if (src4 === dest) {
    throw new Error("Source and destination cannot be the same");
  }
  const srcStat = await Deno.lstat(src4);
  if (srcStat.isDirectory && isSubdir(src4, dest)) {
    throw new Error(`Cannot copy '${src4}' to a subdirectory of itself: '${dest}'`);
  }
  if (srcStat.isSymlink) {
    await copySymLink(src4, dest, options3);
  } else if (srcStat.isDirectory) {
    await copyDir(src4, dest, options3);
  } else if (srcStat.isFile) {
    await copyFile(src4, dest, options3);
  }
}
function copySync(src4, dest, options3 = {}) {
  src4 = resolve3(toPathString(src4));
  dest = resolve3(toPathString(dest));
  if (src4 === dest) {
    throw new Error("Source and destination cannot be the same");
  }
  const srcStat = Deno.lstatSync(src4);
  if (srcStat.isDirectory && isSubdir(src4, dest)) {
    throw new Error(`Cannot copy '${src4}' to a subdirectory of itself: '${dest}'`);
  }
  if (srcStat.isSymlink) {
    copySymlinkSync(src4, dest, options3);
  } else if (srcStat.isDirectory) {
    copyDirSync(src4, dest, options3);
  } else if (srcStat.isFile) {
    copyFileSync(src4, dest, options3);
  }
}

// deno:https://jsr.io/@std/fs/1.0.19/eol.ts
var LF = "\n";
var CRLF = "\r\n";
var EOL = globalThis.Deno?.build.os === "windows" ? CRLF : LF;
var regDetect = /(?:\r?\n)/g;
function detect(content) {
  const d = content.match(regDetect);
  if (!d || d.length === 0) {
    return null;
  }
  const hasCRLF = d.some((x3) => x3 === CRLF);
  return hasCRLF ? CRLF : LF;
}
function format2(content, eol) {
  return content.replace(regDetect, eol);
}

// deno:https://jsr.io/@std/path/1.1.1/mod.ts
var mod_exports3 = {};
__export(mod_exports3, {
  DELIMITER: () => DELIMITER,
  SEPARATOR: () => SEPARATOR3,
  SEPARATOR_PATTERN: () => SEPARATOR_PATTERN3,
  basename: () => basename3,
  common: () => common2,
  dirname: () => dirname3,
  extname: () => extname3,
  format: () => format5,
  fromFileUrl: () => fromFileUrl3,
  globToRegExp: () => globToRegExp3,
  isAbsolute: () => isAbsolute3,
  isGlob: () => isGlob,
  join: () => join3,
  joinGlobs: () => joinGlobs3,
  normalize: () => normalize3,
  normalizeGlob: () => normalizeGlob3,
  parse: () => parse4,
  relative: () => relative3,
  resolve: () => resolve3,
  toFileUrl: () => toFileUrl3,
  toNamespacedPath: () => toNamespacedPath3
});

// deno:https://jsr.io/@std/path/1.1.1/posix/extname.ts
function extname(path) {
  if (path instanceof URL) {
    path = fromFileUrl(path);
  }
  assertPath(path);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path.length - 1; i2 >= 0; --i2) {
    const code3 = path.charCodeAt(i2);
    if (isPosixPathSeparator(code3)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code3 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/extname.ts
function extname2(path) {
  if (path instanceof URL) {
    path = fromFileUrl2(path);
  }
  assertPath(path);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path.length - 1; i2 >= start; --i2) {
    const code3 = path.charCodeAt(i2);
    if (isPathSeparator(code3)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code3 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}

// deno:https://jsr.io/@std/path/1.1.1/extname.ts
function extname3(path) {
  return isWindows ? extname2(path) : extname(path);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/format.ts
function _format(sep, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base4 = pathObject.base || (pathObject.name ?? "") + (pathObject.ext ?? "");
  if (!dir) return base4;
  if (base4 === sep) return dir;
  if (dir === pathObject.root) return dir + base4;
  return dir + sep + base4;
}
function assertArg4(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object, received type "${typeof pathObject}"`);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/posix/format.ts
function format3(pathObject) {
  assertArg4(pathObject);
  return _format("/", pathObject);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/format.ts
function format4(pathObject) {
  assertArg4(pathObject);
  return _format("\\", pathObject);
}

// deno:https://jsr.io/@std/path/1.1.1/format.ts
function format5(pathObject) {
  return isWindows ? format4(pathObject) : format3(pathObject);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/parse.ts
function parse2(path) {
  assertPath(path);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  if (path.length === 0) return ret;
  const isAbsolute6 = isPosixPathSeparator(path.charCodeAt(0));
  let start;
  if (isAbsolute6) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i2 = path.length - 1;
  let preDotState = 0;
  for (; i2 >= start; --i2) {
    const code3 = path.charCodeAt(i2);
    if (isPosixPathSeparator(code3)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code3 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute6) {
        ret.base = ret.name = path.slice(1, end);
      } else {
        ret.base = ret.name = path.slice(startPart, end);
      }
    }
    ret.base = ret.base || "/";
  } else {
    if (startPart === 0 && isAbsolute6) {
      ret.name = path.slice(1, startDot);
      ret.base = path.slice(1, end);
    } else {
      ret.name = path.slice(startPart, startDot);
      ret.base = path.slice(startPart, end);
    }
    ret.ext = path.slice(startDot, end);
  }
  if (startPart > 0) {
    ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);
  } else if (isAbsolute6) ret.dir = "/";
  return ret;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/parse.ts
function parse3(path) {
  assertPath(path);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  const len = path.length;
  if (len === 0) return ret;
  let rootEnd = 0;
  let code3 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code3)) {
      rootEnd = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code3)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path;
              ret.base = "\\";
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path;
          return ret;
        }
      }
    }
  } else if (isPathSeparator(code3)) {
    ret.root = ret.dir = path;
    ret.base = "\\";
    return ret;
  }
  if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i2 = path.length - 1;
  let preDotState = 0;
  for (; i2 >= rootEnd; --i2) {
    code3 = path.charCodeAt(i2);
    if (isPathSeparator(code3)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code3 === CHAR_DOT) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path.slice(startPart, end);
    }
  } else {
    ret.name = path.slice(startPart, startDot);
    ret.base = path.slice(startPart, end);
    ret.ext = path.slice(startDot, end);
  }
  ret.base = ret.base || "\\";
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path.slice(0, startPart - 1);
  } else ret.dir = ret.root;
  return ret;
}

// deno:https://jsr.io/@std/path/1.1.1/parse.ts
function parse4(path) {
  return isWindows ? parse3(path) : parse2(path);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/relative.ts
function assertArgs2(from6, to) {
  assertPath(from6);
  assertPath(to);
  if (from6 === to) return "";
}

// deno:https://jsr.io/@std/path/1.1.1/posix/relative.ts
function relative(from6, to) {
  assertArgs2(from6, to);
  from6 = resolve(from6);
  to = resolve(to);
  if (from6 === to) return "";
  let fromStart = 1;
  const fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (!isPosixPathSeparator(from6.charCodeAt(fromStart))) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;
  }
  const toLen = toEnd - toStart;
  const length4 = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length4; ++i2) {
    if (i2 === length4) {
      if (toLen > length4) {
        if (isPosixPathSeparator(to.charCodeAt(toStart + i2))) {
          return to.slice(toStart + i2 + 1);
        } else if (i2 === 0) {
          return to.slice(toStart + i2);
        }
      } else if (fromLen > length4) {
        if (isPosixPathSeparator(from6.charCodeAt(fromStart + i2))) {
          lastCommonSep = i2;
        } else if (i2 === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode) break;
    else if (isPosixPathSeparator(fromCode)) lastCommonSep = i2;
  }
  let out = "";
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || isPosixPathSeparator(from6.charCodeAt(i2))) {
      if (out.length === 0) out += "..";
      else out += "/..";
    }
  }
  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;
    return to.slice(toStart);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/windows/relative.ts
function relative2(from6, to) {
  assertArgs2(from6, to);
  const fromOrig = resolve2(from6);
  const toOrig = resolve2(to);
  if (fromOrig === toOrig) return "";
  from6 = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from6 === to) return "";
  let fromStart = 0;
  let fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from6.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;
  }
  const toLen = toEnd - toStart;
  const length4 = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length4; ++i2) {
    if (i2 === length4) {
      if (toLen > length4) {
        if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i2 + 1);
        } else if (i2 === 2) {
          return toOrig.slice(toStart + i2);
        }
      }
      if (fromLen > length4) {
        if (from6.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i2;
        } else if (i2 === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode) break;
    else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i2;
  }
  if (i2 !== length4 && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1) lastCommonSep = 0;
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from6.charCodeAt(i2) === CHAR_BACKWARD_SLASH) {
      if (out.length === 0) out += "..";
      else out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/relative.ts
function relative3(from6, to) {
  return isWindows ? relative2(from6, to) : relative(from6, to);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/to_file_url.ts
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string4) {
  return string4.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS[c] ?? c;
  });
}

// deno:https://jsr.io/@std/path/1.1.1/posix/to_file_url.ts
function toFileUrl(path) {
  if (!isAbsolute(path)) {
    throw new TypeError(`Path must be absolute: received "${path}"`);
  }
  const url2 = new URL("file:///");
  url2.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url2;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/to_file_url.ts
function toFileUrl2(path) {
  if (!isAbsolute2(path)) {
    throw new TypeError(`Path must be absolute: received "${path}"`);
  }
  const [, hostname2, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url2 = new URL("file:///");
  url2.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname2 !== void 0 && hostname2 !== "localhost") {
    url2.hostname = hostname2;
    if (!url2.hostname) {
      throw new TypeError(`Invalid hostname: "${url2.hostname}"`);
    }
  }
  return url2;
}

// deno:https://jsr.io/@std/path/1.1.1/to_file_url.ts
function toFileUrl3(path) {
  return isWindows ? toFileUrl2(path) : toFileUrl(path);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/to_namespaced_path.ts
function toNamespacedPath(path) {
  return path;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/to_namespaced_path.ts
function toNamespacedPath2(path) {
  if (typeof path !== "string") return path;
  if (path.length === 0) return "";
  const resolvedPath = resolve2(path);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code3 = resolvedPath.charCodeAt(2);
        if (code3 !== CHAR_QUESTION_MARK && code3 !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path;
}

// deno:https://jsr.io/@std/path/1.1.1/to_namespaced_path.ts
function toNamespacedPath3(path) {
  return isWindows ? toNamespacedPath2(path) : toNamespacedPath(path);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/common.ts
function common(paths, sep) {
  const [first = "", ...remaining] = paths;
  const parts = first.split(sep);
  let endOfPrefix = parts.length;
  let append = "";
  for (const path of remaining) {
    const compare = path.split(sep);
    if (compare.length <= endOfPrefix) {
      endOfPrefix = compare.length;
      append = "";
    }
    for (let i2 = 0; i2 < endOfPrefix; i2++) {
      if (compare[i2] !== parts[i2]) {
        endOfPrefix = i2;
        append = i2 === 0 ? "" : sep;
        break;
      }
    }
  }
  return parts.slice(0, endOfPrefix).join(sep) + append;
}

// deno:https://jsr.io/@std/path/1.1.1/common.ts
function common2(paths) {
  return common(paths, SEPARATOR3);
}

// deno:https://jsr.io/@std/path/1.1.1/normalize_glob.ts
function normalizeGlob3(glob, options3 = {}) {
  return isWindows ? normalizeGlob2(glob, options3) : normalizeGlob(glob, options3);
}

// deno:https://jsr.io/@std/streams/1.0.10/mod.ts
var mod_exports4 = {};
__export(mod_exports4, {
  Buffer: () => Buffer2,
  ByteSliceStream: () => ByteSliceStream,
  DelimiterStream: () => DelimiterStream,
  LimitedBytesTransformStream: () => LimitedBytesTransformStream,
  LimitedTransformStream: () => LimitedTransformStream,
  TextDelimiterStream: () => TextDelimiterStream,
  TextLineStream: () => TextLineStream,
  concatReadableStreams: () => concatReadableStreams,
  earlyZipReadableStreams: () => earlyZipReadableStreams,
  mergeReadableStreams: () => mergeReadableStreams,
  toArrayBuffer: () => toArrayBuffer,
  toBlob: () => toBlob,
  toJson: () => toJson,
  toText: () => toText,
  toTransformStream: () => toTransformStream,
  zipReadableStreams: () => zipReadableStreams
});

// deno:https://jsr.io/@std/bytes/1.0.6/copy.ts
function copy2(src4, dst, offset = 0) {
  offset = Math.max(0, Math.min(offset, dst.byteLength));
  const dstBytesAvailable = dst.byteLength - offset;
  if (src4.byteLength > dstBytesAvailable) {
    src4 = src4.subarray(0, dstBytesAvailable);
  }
  dst.set(src4, offset);
  return src4.byteLength;
}

// deno:https://jsr.io/@std/streams/1.0.10/buffer.ts
var MAX_SIZE = 2 ** 32 - 2;
var DEFAULT_CHUNK_SIZE = 16640;
var Buffer2 = class {
  #buf;
  #off = 0;
  #readable = new ReadableStream({
    type: "bytes",
    pull: (controller) => {
      const view = new Uint8Array(controller.byobRequest.view.buffer);
      if (this.empty()) {
        this.reset();
        controller.close();
        controller.byobRequest.respond(0);
        return;
      }
      const nread = copy2(this.#buf.subarray(this.#off), view);
      this.#off += nread;
      controller.byobRequest.respond(nread);
    },
    autoAllocateChunkSize: DEFAULT_CHUNK_SIZE
  });
  /**
   * Getter returning the instance's {@linkcode ReadableStream}.
   *
   * @returns A `ReadableStream` of the buffer.
   *
   * @example Read the content out of the buffer to stdout
   * ```ts ignore
   * import { Buffer } from "@std/streams/buffer";
   *
   * const buf = new Buffer();
   * await buf.readable.pipeTo(Deno.stdout.writable);
   * ```
   */
  get readable() {
    return this.#readable;
  }
  #writable = new WritableStream({
    write: (chunk) => {
      const m3 = this.#grow(chunk.byteLength);
      copy2(chunk, this.#buf, m3);
    }
  });
  /**
   * Getter returning the instance's {@linkcode WritableStream}.
   *
   * @returns A `WritableStream` of the buffer.
   *
   * @example Write the data from stdin to the buffer
   * ```ts ignore
   * import { Buffer } from "@std/streams/buffer";
   *
   * const buf = new Buffer();
   * await Deno.stdin.readable.pipeTo(buf.writable);
   * ```
   */
  get writable() {
    return this.#writable;
  }
  /**
   * Constructs a new instance.
   *
   * @param ab An optional buffer to use as the initial buffer.
   */
  constructor(ab) {
    if (ab === void 0) {
      this.#buf = new Uint8Array(0);
    } else if (ab instanceof SharedArrayBuffer) {
      this.#buf = new Uint8Array(ab);
    } else {
      this.#buf = new Uint8Array(ab);
    }
  }
  /**
   * Returns a slice holding the unread portion of the buffer.
   *
   * The slice is valid for use only until the next buffer modification (that
   * is, only until the next call to a method that mutates or consumes the
   * buffer, like reading data out via `readable`, `reset()`, or `truncate()`).
   *
   * If `options.copy` is false the slice aliases the buffer content at least
   * until the next buffer modification, so immediate changes to the slice will
   * affect the result of future reads. If `options` is not provided,
   * `options.copy` defaults to `true`.
   *
   * @param options Options for the bytes method.
   * @returns A copy or a slice of the buffer.
   *
   * @example Copy the buffer
   * ```ts
   * import { assertEquals } from "@std/assert";
   * import { assertNotEquals } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([0, 1, 2]);
   * const buf = new Buffer(array.buffer);
   * const copied = buf.bytes();
   * assertEquals(copied.length, array.length);
   *
   * // Modify an element in the original array
   * array[1] = 99;
   * assertEquals(copied[0], array[0]);
   * // The copied buffer is not affected by the modification
   * assertNotEquals(copied[1], array[1]);
   * assertEquals(copied[2], array[2]);
   * ```
   *
   * @example Get a slice to the buffer
   * ```ts
   * import { assertEquals } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([0, 1, 2]);
   * const buf = new Buffer(array.buffer);
   * const slice = buf.bytes({ copy: false });
   * assertEquals(slice.length, array.length);
   *
   * // Modify an element in the original array
   * array[1] = 99;
   * assertEquals(slice[0], array[0]);
   * // The slice _is_ affected by the modification
   * assertEquals(slice[1], array[1]);
   * assertEquals(slice[2], array[2]);
   * ```
   */
  bytes(options3 = {
    copy: true
  }) {
    if (options3.copy === false) return this.#buf.subarray(this.#off);
    return this.#buf.slice(this.#off);
  }
  /**
   * Returns whether the unread portion of the buffer is empty.
   *
   * @returns Whether the buffer is empty.
   *
   * @example Empty buffer
   * ```ts
   * import { assert } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const buf = new Buffer();
   * assert(buf.empty());
   * ```
   *
   * @example Non-empty buffer
   * ```ts
   * import { assert } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([42]);
   * const buf = new Buffer(array.buffer);
   * assert(!buf.empty());
   * ```
   *
   * @example Non-empty, but the content was already read
   * ```ts ignore
   * import { assert } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([42]);
   * const buf = new Buffer(array.buffer);
   * assert(!buf.empty());
   * // Read the content out of the buffer
   * await buf.readable.pipeTo(Deno.stdout.writable);
   * // The buffer is now empty
   * assert(buf.empty());
   * ```
   */
  empty() {
    return this.#buf.byteLength <= this.#off;
  }
  /**
   * A read only number of bytes of the unread portion of the buffer.
   *
   * @returns The number of bytes in the unread portion of the buffer.
   *
   * @example Basic usage
   * ```ts
   * import { assertEquals } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([0, 1, 2]);
   * const buf = new Buffer(array.buffer);
   * assertEquals(buf.length, 3);
   * ```
   *
   * @example Length becomes 0 after the content is read
   * ```ts ignore
   * import { assertEquals } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([42]);
   * const buf = new Buffer(array.buffer);
   * assertEquals(buf.length, 1);
   * // Read the content out of the buffer
   * await buf.readable.pipeTo(Deno.stdout.writable);
   * // The length is now 0
   * assertEquals(buf.length, 0);
   * ```
   */
  get length() {
    return this.#buf.byteLength - this.#off;
  }
  /**
   * The read only capacity of the buffer's underlying byte slice, that is,
   * the total space allocated for the buffer's data.
   *
   * @returns The number of allocated bytes for the buffer.
   *
   * @example Basic usage
   * ```ts
   * import { assertEquals } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const arrayBuffer = new ArrayBuffer(256);
   * const buf = new Buffer(arrayBuffer);
   * assertEquals(buf.capacity, 256);
   * ```
   */
  get capacity() {
    return this.#buf.buffer.byteLength;
  }
  /**
   * Discards all but the first `n` unread bytes from the buffer but
   * continues to use the same allocated storage. It throws if `n` is
   * negative or greater than the length of the buffer.
   *
   * @param n The number of bytes to keep.
   *
   * @example Basic usage
   * ```ts
   * import { assertEquals } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([0, 1, 2]);
   * const buf = new Buffer(array.buffer);
   * assertEquals(buf.bytes(), array);
   *
   * // Discard all but the first 2 bytes
   * buf.truncate(2);
   * assertEquals(buf.bytes(), array.slice(0, 2));
   * ```
   */
  truncate(n) {
    if (n === 0) {
      this.reset();
      return;
    }
    if (n < 0 || n > this.length) {
      throw new RangeError(`Buffer truncation value "${n}" is not between 0 and ${this.length}`);
    }
    this.#reslice(this.#off + n);
  }
  /**
   * Resets to an empty buffer.
   *
   * @example Basic usage
   * ```ts
   * import { assert } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const array = new Uint8Array([0, 1, 2]);
   * const buf = new Buffer(array.buffer);
   * assert(!buf.empty());
   *
   * // Reset
   * buf.reset();
   * assert(buf.empty());
   * ```
   */
  reset() {
    this.#reslice(0);
    this.#off = 0;
  }
  #tryGrowByReslice(n) {
    const l = this.#buf.byteLength;
    if (n <= this.capacity - l) {
      this.#reslice(l + n);
      return l;
    }
    return -1;
  }
  #reslice(len) {
    this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
  }
  #grow(n) {
    const m3 = this.length;
    if (m3 === 0 && this.#off !== 0) {
      this.reset();
    }
    const i2 = this.#tryGrowByReslice(n);
    if (i2 >= 0) {
      return i2;
    }
    const c = this.capacity;
    if (n <= Math.floor(c / 2) - m3) {
      copy2(this.#buf.subarray(this.#off), this.#buf);
    } else if (c + n > MAX_SIZE) {
      throw new RangeError(`The buffer cannot grow beyond the maximum size of ${MAX_SIZE}`);
    } else {
      const buf2 = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));
      copy2(this.#buf.subarray(this.#off), buf2);
      this.#buf = buf2;
    }
    this.#off = 0;
    this.#reslice(Math.min(m3 + n, MAX_SIZE));
    return m3;
  }
  /**
   * Grows the buffer's capacity, if necessary, to guarantee space for
   * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to
   * the buffer without another allocation. If `n` is negative, `.grow()` will
   * throw. If the buffer can't grow it will throw an error.
   *
   * @param n The number of bytes to grow the buffer by.
   *
   * Based on Go Lang's
   * {@link https://golang.org/pkg/bytes/#Buffer.Grow | Buffer.Grow}.
   *
   * @example Basic usage
   * ```ts
   * import { assert } from "@std/assert";
   * import { assertEquals } from "@std/assert";
   * import { Buffer } from "@std/streams/buffer";
   *
   * const buf = new Buffer();
   * assertEquals(buf.capacity, 0);
   *
   * buf.grow(200);
   * assert(buf.capacity >= 200);
   * ```
   */
  grow(n) {
    if (n < 0) {
      throw new RangeError(`Cannot grow buffer as growth must be positive: received ${n}`);
    }
    const m3 = this.#grow(n);
    this.#reslice(m3);
  }
};

// deno:https://jsr.io/@std/streams/1.0.10/byte_slice_stream.ts
var ByteSliceStream = class extends TransformStream {
  #offsetStart = 0;
  #offsetEnd = 0;
  /**
   * Constructs a new instance.
   *
   * @param start The zero-indexed byte index to start reading from.
   * @param end The zero-indexed byte index to stop reading at. Inclusive.
   */
  constructor(start = 0, end = Infinity) {
    super({
      start: () => {
        if (start < 0) {
          throw new RangeError(`Cannot construct ByteSliceStream as start must be >= 0: received ${start}`);
        }
        end += 1;
      },
      transform: (chunk, controller) => {
        this.#offsetStart = this.#offsetEnd;
        this.#offsetEnd += chunk.byteLength;
        if (this.#offsetEnd > start) {
          if (this.#offsetStart < start) {
            chunk = chunk.slice(start - this.#offsetStart);
          }
          if (this.#offsetEnd >= end) {
            chunk = chunk.slice(0, chunk.byteLength - this.#offsetEnd + end);
            controller.enqueue(chunk);
            controller.terminate();
          } else {
            controller.enqueue(chunk);
          }
        }
      }
    });
  }
};

// deno:https://jsr.io/@std/streams/1.0.10/concat_readable_streams.ts
function concatReadableStreams(...streams) {
  let i2 = 0;
  return new ReadableStream({
    async pull(controller) {
      const reader = streams[i2].getReader();
      const { done, value } = await reader.read();
      if (done) {
        if (streams.length === ++i2) {
          return controller.close();
        }
        return await this.pull(controller);
      }
      controller.enqueue(value);
      reader.releaseLock();
    },
    async cancel(reason) {
      const promises = streams.map((stream) => stream.cancel(reason));
      await Promise.allSettled(promises);
    }
  });
}

// deno:https://jsr.io/@std/bytes/1.0.6/concat.ts
function concat(buffers) {
  let length4 = 0;
  for (const buffer of buffers) {
    length4 += buffer.length;
  }
  const output = new Uint8Array(length4);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}

// deno:https://jsr.io/@std/streams/1.0.10/_common.ts
var DEFAULT_BUFFER_SIZE = 32 * 1024;
function createLPS(pat) {
  const length4 = pat.length;
  const lps = new Uint8Array(length4);
  lps[0] = 0;
  let prefixEnd = 0;
  let i2 = 1;
  while (i2 < length4) {
    if (pat[i2] === pat[prefixEnd]) {
      prefixEnd++;
      lps[i2] = prefixEnd;
      i2++;
    } else if (prefixEnd === 0) {
      lps[i2] = 0;
      i2++;
    } else {
      prefixEnd = lps[prefixEnd - 1];
    }
  }
  return lps;
}

// deno:https://jsr.io/@std/streams/1.0.10/delimiter_stream.ts
var DelimiterStream = class extends TransformStream {
  #bufs = [];
  #delimiter;
  #matchIndex = 0;
  #delimLPS;
  #disp;
  /**
   * Constructs a new instance.
   *
   * @param delimiter A delimiter to split the stream by.
   * @param options Options for the delimiter stream.
   */
  constructor(delimiter, options3 = {}) {
    super({
      transform: (chunk, controller) => delimiter.length === 1 ? this.#handleChar(chunk, controller) : this.#handle(chunk, controller),
      flush: (controller) => this.#flush(controller)
    });
    this.#delimiter = delimiter;
    this.#delimLPS = delimiter.length > 1 ? createLPS(delimiter) : null;
    this.#disp = options3.disposition ?? "discard";
  }
  #handle(chunk, controller) {
    const bufs = this.#bufs;
    const length4 = chunk.byteLength;
    const disposition = this.#disp;
    const delimiter = this.#delimiter;
    const delimLen = delimiter.length;
    const lps = this.#delimLPS;
    let chunkStart = 0;
    let matchIndex = this.#matchIndex;
    let inspectIndex = 0;
    while (inspectIndex < length4) {
      if (chunk[inspectIndex] === delimiter[matchIndex]) {
        inspectIndex++;
        matchIndex++;
        if (matchIndex === delimLen) {
          matchIndex = 0;
          const delimiterStartIndex = inspectIndex - delimLen;
          const delimitedChunkEnd = disposition === "suffix" ? inspectIndex : delimiterStartIndex;
          if (delimitedChunkEnd <= 0 && bufs.length === 0) {
            controller.enqueue(new Uint8Array());
            chunkStart = disposition === "prefix" ? 0 : inspectIndex;
          } else if (delimitedChunkEnd > 0 && bufs.length === 0) {
            controller.enqueue(chunk.subarray(chunkStart, delimitedChunkEnd));
            chunkStart = disposition === "prefix" ? delimiterStartIndex : inspectIndex;
          } else if (delimitedChunkEnd === 0 && bufs.length > 0) {
            if (bufs.length === 1) {
              controller.enqueue(bufs[0]);
            } else {
              controller.enqueue(concat(bufs));
            }
            bufs.length = 0;
            if (disposition !== "prefix") {
              chunkStart = inspectIndex;
            } else {
              chunkStart = 0;
            }
          } else if (delimitedChunkEnd < 0 && bufs.length > 0) {
            const lastIndex = bufs.length - 1;
            const last = bufs[lastIndex];
            const lastSliceIndex = last.byteLength + delimitedChunkEnd;
            const lastSliced = last.subarray(0, lastSliceIndex);
            if (lastIndex === 0) {
              controller.enqueue(lastSliced);
            } else {
              bufs[lastIndex] = lastSliced;
              controller.enqueue(concat(bufs));
            }
            bufs.length = 0;
            if (disposition === "prefix") {
              bufs.push(last.subarray(lastSliceIndex));
              chunkStart = 0;
            } else {
              chunkStart = inspectIndex;
            }
          } else if (delimitedChunkEnd > 0 && bufs.length > 0) {
            const chunkSliced = chunk.subarray(chunkStart, delimitedChunkEnd);
            const result = concat([
              ...bufs,
              chunkSliced
            ]);
            bufs.length = 0;
            controller.enqueue(result);
            chunkStart = disposition === "prefix" ? delimitedChunkEnd : inspectIndex;
          } else {
            throw new Error("This should be unreachable, please file a bug report against Deno at https://github.com/denoland/std/issues");
          }
        }
      } else if (matchIndex === 0) {
        inspectIndex++;
      } else {
        matchIndex = lps[matchIndex - 1];
      }
    }
    this.#matchIndex = matchIndex;
    if (chunkStart === 0) {
      bufs.push(chunk);
    } else if (chunkStart < length4) {
      bufs.push(chunk.subarray(chunkStart));
    }
  }
  /**
   * Optimized handler for a char delimited stream:
   *
   * For char delimited streams we do not need to keep track of
   * the match index, removing the need for a fair bit of work.
   */
  #handleChar(chunk, controller) {
    const bufs = this.#bufs;
    const length4 = chunk.byteLength;
    const disposition = this.#disp;
    const delimiter = this.#delimiter[0];
    let chunkStart = 0;
    let inspectIndex = 0;
    while (inspectIndex < length4) {
      if (chunk[inspectIndex] === delimiter) {
        inspectIndex++;
        const delimitedChunkEnd = disposition === "suffix" ? inspectIndex : inspectIndex - 1;
        if (delimitedChunkEnd === 0 && bufs.length === 0) {
          controller.enqueue(new Uint8Array());
          chunkStart = disposition === "prefix" ? 0 : 1;
        } else if (delimitedChunkEnd > 0 && bufs.length === 0) {
          controller.enqueue(chunk.subarray(chunkStart, delimitedChunkEnd));
          chunkStart = disposition === "prefix" ? inspectIndex - 1 : inspectIndex;
        } else if (delimitedChunkEnd === 0 && bufs.length > 0) {
          if (bufs.length === 1) {
            controller.enqueue(bufs[0]);
          } else {
            controller.enqueue(concat(bufs));
          }
          bufs.length = 0;
          if (disposition !== "prefix") {
            chunkStart = inspectIndex;
          }
        } else if (delimitedChunkEnd > 0 && bufs.length > 0) {
          const chunkSliced = chunk.subarray(chunkStart, delimitedChunkEnd);
          const result = concat([
            ...bufs,
            chunkSliced
          ]);
          bufs.length = 0;
          chunkStart = disposition === "prefix" ? delimitedChunkEnd : inspectIndex;
          controller.enqueue(result);
        } else {
          throw new Error("This should be unreachable, please file a bug report against Deno at https://github.com/denoland/std/issues");
        }
      } else {
        inspectIndex++;
      }
    }
    if (chunkStart === 0) {
      bufs.push(chunk);
    } else if (chunkStart < length4) {
      bufs.push(chunk.subarray(chunkStart));
    }
  }
  #flush(controller) {
    const bufs = this.#bufs;
    const length4 = bufs.length;
    if (length4 === 0) {
      controller.enqueue(new Uint8Array());
    } else if (length4 === 1) {
      controller.enqueue(bufs[0]);
    } else {
      controller.enqueue(concat(bufs));
    }
  }
};

// deno:https://jsr.io/@std/streams/1.0.10/early_zip_readable_streams.ts
function earlyZipReadableStreams(...streams) {
  const readers = streams.map((stream) => stream.getReader());
  return new ReadableStream({
    async pull(controller) {
      for (let i2 = 0; i2 < readers.length; ++i2) {
        const { done, value } = await readers[i2].read();
        if (done) {
          await Promise.all(readers.map((reader) => reader.cancel(`Stream at index ${i2} ended`)));
          controller.close();
          return;
        }
        controller.enqueue(value);
      }
    },
    async cancel(reason) {
      await Promise.all(readers.map((reader) => reader.cancel(reason)));
    }
  });
}

// deno:https://jsr.io/@std/streams/1.0.10/limited_bytes_transform_stream.ts
var LimitedBytesTransformStream = class extends TransformStream {
  #read = 0;
  /**
   * Constructs a new instance.
   *
   * @param size A size limit in bytes.
   * @param options Options for the stream.
   */
  constructor(size, options3 = {
    error: false
  }) {
    super({
      transform: (chunk, controller) => {
        if (this.#read + chunk.byteLength > size) {
          if (options3.error) {
            throw new RangeError(`Exceeded byte size limit of '${size}'`);
          } else {
            controller.terminate();
          }
        } else {
          this.#read += chunk.byteLength;
          controller.enqueue(chunk);
        }
      }
    });
  }
};

// deno:https://jsr.io/@std/streams/1.0.10/limited_transform_stream.ts
var LimitedTransformStream = class extends TransformStream {
  #read = 0;
  /**
   * Constructs a new instance.
   *
   * @param size The maximum number of chunks to read.
   * @param options Options for the stream.
   */
  constructor(size, options3 = {
    error: false
  }) {
    super({
      transform: (chunk, controller) => {
        if (this.#read + 1 > size) {
          if (options3.error) {
            throw new RangeError(`Exceeded chunk limit of '${size}'`);
          } else {
            controller.terminate();
          }
        } else {
          this.#read++;
          controller.enqueue(chunk);
        }
      }
    });
  }
};

// deno:https://jsr.io/@std/streams/1.0.10/merge_readable_streams.ts
function mergeReadableStreams(...streams) {
  const resolvePromises = streams.map(() => Promise.withResolvers());
  return new ReadableStream({
    start(controller) {
      let mustClose = false;
      Promise.all(resolvePromises.map(({ promise: promise2 }) => promise2)).then(() => {
        controller.close();
      }).catch((error40) => {
        mustClose = true;
        controller.error(error40);
      });
      for (const [index, stream] of streams.entries()) {
        (async () => {
          try {
            for await (const data of stream) {
              if (mustClose) {
                break;
              }
              controller.enqueue(data);
            }
            resolvePromises[index].resolve();
          } catch (error40) {
            resolvePromises[index].reject(error40);
          }
        })();
      }
    }
  });
}

// deno:https://jsr.io/@std/streams/1.0.10/text_delimiter_stream.ts
var TextDelimiterStream = class extends TransformStream {
  #buf = "";
  #delimiter;
  #inspectIndex = 0;
  #matchIndex = 0;
  #delimLPS;
  #disp;
  /**
   * Constructs a new instance.
   *
   * @param delimiter A delimiter to split the stream by.
   * @param options Options for the stream.
   */
  constructor(delimiter, options3) {
    super({
      transform: (chunk, controller) => {
        this.#handle(chunk, controller);
      },
      flush: (controller) => {
        controller.enqueue(this.#buf);
      }
    });
    this.#delimiter = delimiter;
    this.#delimLPS = createLPS(new TextEncoder().encode(delimiter));
    this.#disp = options3?.disposition ?? "discard";
  }
  #handle(chunk, controller) {
    this.#buf += chunk;
    let localIndex = 0;
    while (this.#inspectIndex < this.#buf.length) {
      if (chunk[localIndex] === this.#delimiter[this.#matchIndex]) {
        this.#inspectIndex++;
        localIndex++;
        this.#matchIndex++;
        if (this.#matchIndex === this.#delimiter.length) {
          const start = this.#inspectIndex - this.#delimiter.length;
          const end = this.#disp === "suffix" ? this.#inspectIndex : start;
          const copy4 = this.#buf.slice(0, end);
          controller.enqueue(copy4);
          const shift = this.#disp === "prefix" ? start : this.#inspectIndex;
          this.#buf = this.#buf.slice(shift);
          this.#inspectIndex = this.#disp === "prefix" ? this.#delimiter.length : 0;
          this.#matchIndex = 0;
        }
      } else {
        if (this.#matchIndex === 0) {
          this.#inspectIndex++;
          localIndex++;
        } else {
          this.#matchIndex = this.#delimLPS[this.#matchIndex - 1];
        }
      }
    }
  }
};

// deno:https://jsr.io/@std/streams/1.0.10/text_line_stream.ts
var TextLineStream = class extends TransformStream {
  #currentLine = "";
  /**
   * Constructs a new instance.
   *
   * @param options Options for the stream.
   */
  constructor(options3 = {
    allowCR: false
  }) {
    super({
      transform: (chars, controller) => {
        chars = this.#currentLine + chars;
        while (true) {
          const lfIndex = chars.indexOf("\n");
          const crIndex = options3.allowCR ? chars.indexOf("\r") : -1;
          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {
            controller.enqueue(chars.slice(0, crIndex));
            chars = chars.slice(crIndex + 1);
            continue;
          }
          if (lfIndex === -1) break;
          const endIndex = chars[lfIndex - 1] === "\r" ? lfIndex - 1 : lfIndex;
          controller.enqueue(chars.slice(0, endIndex));
          chars = chars.slice(lfIndex + 1);
        }
        this.#currentLine = chars;
      },
      flush: (controller) => {
        if (this.#currentLine === "") return;
        const currentLine = options3.allowCR && this.#currentLine.endsWith("\r") ? this.#currentLine.slice(0, -1) : this.#currentLine;
        controller.enqueue(currentLine);
      }
    });
  }
};

// deno:https://jsr.io/@std/streams/1.0.10/to_array_buffer.ts
async function toArrayBuffer(readableStream) {
  const reader = readableStream.getReader();
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    chunks.push(value);
  }
  return concat(chunks).buffer;
}

// deno:https://jsr.io/@std/streams/1.0.10/to_blob.ts
async function toBlob(stream) {
  return await new Response(stream).blob();
}

// deno:https://jsr.io/@std/streams/1.0.10/to_text.ts
async function toText(stream) {
  const textDecoder = new TextDecoder();
  const reader = stream.getReader();
  let result = "";
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += typeof value === "string" ? value : textDecoder.decode(value, {
      stream: true
    });
  }
  result += textDecoder.decode();
  return result;
}

// deno:https://jsr.io/@std/streams/1.0.10/to_json.ts
function toJson(stream) {
  return toText(stream).then(JSON.parse);
}

// deno:https://jsr.io/@std/streams/1.0.10/to_transform_stream.ts
function toTransformStream(transformer, writableStrategy, readableStrategy) {
  const { writable, readable } = new TransformStream(void 0, writableStrategy);
  const iterable = transformer(readable);
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  return {
    writable,
    readable: new ReadableStream({
      async pull(controller) {
        let result;
        try {
          result = await iterator.next();
        } catch (error40) {
          await readable.cancel(error40).catch(() => {
          });
          controller.error(error40);
          return;
        }
        if (result.done) {
          controller.close();
          return;
        }
        controller.enqueue(result.value);
      },
      async cancel(reason) {
        if (typeof iterator.throw === "function") {
          try {
            await iterator.throw(reason);
          } catch {
          }
        }
        await readable.cancel(reason);
      }
    }, readableStrategy)
  };
}

// deno:https://jsr.io/@std/streams/1.0.10/zip_readable_streams.ts
function zipReadableStreams(...streams) {
  const readers = new Set(streams.map((s) => s.getReader()));
  return new ReadableStream({
    async start(controller) {
      try {
        let resolved = 0;
        while (resolved !== streams.length) {
          for (const reader of readers) {
            const { value, done } = await reader.read();
            if (!done) {
              controller.enqueue(value);
            } else {
              resolved++;
              readers.delete(reader);
            }
          }
        }
        controller.close();
      } catch (e2) {
        controller.error(e2);
      }
    }
  });
}

// deno:https://jsr.io/@std/io/0.225.2/mod.ts
var mod_exports5 = {};
__export(mod_exports5, {
  Buffer: () => Buffer3,
  SeekMode: () => SeekMode,
  copy: () => copy3,
  iterateReader: () => iterateReader,
  iterateReaderSync: () => iterateReaderSync,
  readAll: () => readAll,
  readAllSync: () => readAllSync,
  readerFromStreamReader: () => readerFromStreamReader,
  toReadableStream: () => toReadableStream,
  toWritableStream: () => toWritableStream,
  writeAll: () => writeAll,
  writeAllSync: () => writeAllSync
});

// deno:https://jsr.io/@std/io/0.225.2/buffer.ts
var MIN_READ = 32 * 1024;
var MAX_SIZE2 = 2 ** 32 - 2;
var Buffer3 = class {
  #buf;
  #off = 0;
  /**
   * Constructs a new instance with the specified {@linkcode ArrayBuffer} as its
   * initial contents.
   *
   * @param ab The ArrayBuffer to use as the initial contents of the buffer.
   */
  constructor(ab) {
    if (ab === void 0) {
      this.#buf = new Uint8Array(0);
    } else if (ab instanceof SharedArrayBuffer) {
      this.#buf = new Uint8Array(ab);
    } else {
      this.#buf = new Uint8Array(ab);
    }
  }
  /**
   * Returns a slice holding the unread portion of the buffer.
   *
   * The slice is valid for use only until the next buffer modification (that
   * is, only until the next call to a method like `read()`, `write()`,
   * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases the buffer content at
   * least until the next buffer modification, so immediate changes to the
   * slice will affect the result of future reads.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   *
   * const slice = buf.bytes();
   * assertEquals(new TextDecoder().decode(slice), "Hello, world!");
   * ```
   *
   * @param options The options for the slice.
   * @returns A slice holding the unread portion of the buffer.
   */
  bytes(options3 = {
    copy: true
  }) {
    if (options3.copy === false) return this.#buf.subarray(this.#off);
    return this.#buf.slice(this.#off);
  }
  /**
   * Returns whether the unread portion of the buffer is empty.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * assertEquals(buf.empty(), true);
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   * assertEquals(buf.empty(), false);
   * ```
   *
   * @returns `true` if the unread portion of the buffer is empty, `false`
   *          otherwise.
   */
  empty() {
    return this.#buf.byteLength <= this.#off;
  }
  /**
   * A read only number of bytes of the unread portion of the buffer.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   *
   * assertEquals(buf.length, 13);
   * ```
   *
   * @returns The number of bytes of the unread portion of the buffer.
   */
  get length() {
    return this.#buf.byteLength - this.#off;
  }
  /**
   * The read only capacity of the buffer's underlying byte slice, that is,
   * the total space allocated for the buffer's data.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * assertEquals(buf.capacity, 0);
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   * assertEquals(buf.capacity, 13);
   * ```
   *
   * @returns The capacity of the buffer.
   */
  get capacity() {
    return this.#buf.buffer.byteLength;
  }
  /**
   * Discards all but the first `n` unread bytes from the buffer but
   * continues to use the same allocated storage. It throws if `n` is
   * negative or greater than the length of the buffer.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   * buf.truncate(6);
   * assertEquals(buf.length, 6);
   * ```
   *
   * @param n The number of bytes to keep.
   */
  truncate(n) {
    if (n === 0) {
      this.reset();
      return;
    }
    if (n < 0 || n > this.length) {
      throw new Error("Buffer truncation out of range");
    }
    this.#reslice(this.#off + n);
  }
  /**
   * Resets the contents
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   * buf.reset();
   * assertEquals(buf.length, 0);
   * ```
   */
  reset() {
    this.#reslice(0);
    this.#off = 0;
  }
  #tryGrowByReslice(n) {
    const l = this.#buf.byteLength;
    if (n <= this.capacity - l) {
      this.#reslice(l + n);
      return l;
    }
    return -1;
  }
  #reslice(len) {
    if (len > this.#buf.buffer.byteLength) {
      throw new RangeError("Length is greater than buffer capacity");
    }
    this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
  }
  /**
   * Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Returns the number of bytes read. If the buffer has no data to
   * return, the return is EOF (`null`).
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   *
   * const data = new Uint8Array(5);
   * const res = await buf.read(data);
   *
   * assertEquals(res, 5);
   * assertEquals(new TextDecoder().decode(data), "Hello");
   * ```
   *
   * @param p The buffer to read data into.
   * @returns The number of bytes read.
   */
  readSync(p) {
    if (this.empty()) {
      this.reset();
      if (p.byteLength === 0) {
        return 0;
      }
      return null;
    }
    const nread = copy2(this.#buf.subarray(this.#off), p);
    this.#off += nread;
    return nread;
  }
  /**
   * Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Resolves to the number of bytes read. If the buffer has no
   * data to return, resolves to EOF (`null`).
   *
   * NOTE: This methods reads bytes synchronously; it's provided for
   * compatibility with `Reader` interfaces.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * await buf.write(new TextEncoder().encode("Hello, world!"));
   *
   * const data = new Uint8Array(5);
   * const res = await buf.read(data);
   *
   * assertEquals(res, 5);
   * assertEquals(new TextDecoder().decode(data), "Hello");
   * ```
   *
   * @param p The buffer to read data into.
   * @returns The number of bytes read.
   */
  read(p) {
    const rr = this.readSync(p);
    return Promise.resolve(rr);
  }
  /**
   * Writes the given data to the buffer.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * const data = new TextEncoder().encode("Hello, world!");
   * buf.writeSync(data);
   *
   * const slice = buf.bytes();
   * assertEquals(new TextDecoder().decode(slice), "Hello, world!");
   * ```
   *
   * @param p The data to write to the buffer.
   * @returns The number of bytes written.
   */
  writeSync(p) {
    const m3 = this.#grow(p.byteLength);
    return copy2(p, this.#buf, m3);
  }
  /**
   * Writes the given data to the buffer. Resolves to the number of bytes
   * written.
   *
   * > [!NOTE]
   * > This methods writes bytes synchronously; it's provided for compatibility
   * > with the {@linkcode Writer} interface.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * const data = new TextEncoder().encode("Hello, world!");
   * await buf.write(data);
   *
   * const slice = buf.bytes();
   * assertEquals(new TextDecoder().decode(slice), "Hello, world!");
   * ```
   *
   * @param p The data to write to the buffer.
   * @returns The number of bytes written.
   */
  write(p) {
    const n = this.writeSync(p);
    return Promise.resolve(n);
  }
  #grow(n) {
    const m3 = this.length;
    if (m3 === 0 && this.#off !== 0) {
      this.reset();
    }
    const i2 = this.#tryGrowByReslice(n);
    if (i2 >= 0) {
      return i2;
    }
    const c = this.capacity;
    if (n <= Math.floor(c / 2) - m3) {
      copy2(this.#buf.subarray(this.#off), this.#buf);
    } else if (c + n > MAX_SIZE2) {
      throw new Error(`The buffer cannot be grown beyond the maximum size of "${MAX_SIZE2}"`);
    } else {
      const buf2 = new Uint8Array(Math.min(2 * c + n, MAX_SIZE2));
      copy2(this.#buf.subarray(this.#off), buf2);
      this.#buf = buf2;
    }
    this.#off = 0;
    this.#reslice(Math.min(m3 + n, MAX_SIZE2));
    return m3;
  }
  /** Grows the buffer's capacity, if necessary, to guarantee space for
   * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to
   * the buffer without another allocation. If `n` is negative, `.grow()` will
   * throw. If the buffer can't grow it will throw an error.
   *
   * Based on Go Lang's
   * {@link https://golang.org/pkg/bytes/#Buffer.Grow | Buffer.Grow}.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * buf.grow(10);
   * assertEquals(buf.capacity, 10);
   * ```
   *
   * @param n The number of bytes to grow the buffer by.
   */
  grow(n) {
    if (n < 0) {
      throw new Error("Buffer growth cannot be negative");
    }
    const m3 = this.#grow(n);
    this.#reslice(m3);
  }
  /**
   * Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It resolves to the number of bytes read.
   * If the buffer becomes too large, `.readFrom()` will reject with an error.
   *
   * Based on Go Lang's
   * {@link https://golang.org/pkg/bytes/#Buffer.ReadFrom | Buffer.ReadFrom}.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * const r = new Buffer(new TextEncoder().encode("Hello, world!"));
   * const n = await buf.readFrom(r);
   *
   * assertEquals(n, 13);
   * ```
   *
   * @param r The reader to read from.
   * @returns The number of bytes read.
   */
  async readFrom(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ;
      const buf2 = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = await r.read(buf2);
      if (nread === null) {
        return n;
      }
      if (shouldGrow) this.writeSync(buf2.subarray(0, nread));
      else this.#reslice(this.length + nread);
      n += nread;
    }
  }
  /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It returns the number of bytes read. If the
   * buffer becomes too large, `.readFromSync()` will throw an error.
   *
   * Based on Go Lang's
   * {@link https://golang.org/pkg/bytes/#Buffer.ReadFrom | Buffer.ReadFrom}.
   *
   * @example Usage
   * ```ts
   * import { Buffer } from "@std/io/buffer";
   * import { assertEquals } from "@std/assert/equals";
   *
   * const buf = new Buffer();
   * const r = new Buffer(new TextEncoder().encode("Hello, world!"));
   * const n = buf.readFromSync(r);
   *
   * assertEquals(n, 13);
   * ```
   *
   * @param r The reader to read from.
   * @returns The number of bytes read.
   */
  readFromSync(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ;
      const buf2 = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = r.readSync(buf2);
      if (nread === null) {
        return n;
      }
      if (shouldGrow) this.writeSync(buf2.subarray(0, nread));
      else this.#reslice(this.length + nread);
      n += nread;
    }
  }
};

// deno:https://jsr.io/@std/io/0.225.2/_constants.ts
var DEFAULT_CHUNK_SIZE2 = 16640;
var DEFAULT_BUFFER_SIZE2 = 32 * 1024;

// deno:https://jsr.io/@std/io/0.225.2/write_all.ts
async function writeAll(writer, data) {
  let nwritten = 0;
  while (nwritten < data.length) {
    nwritten += await writer.write(data.subarray(nwritten));
  }
}
function writeAllSync(writer, data) {
  let nwritten = 0;
  while (nwritten < data.length) {
    nwritten += writer.writeSync(data.subarray(nwritten));
  }
}

// deno:https://jsr.io/@std/io/0.225.2/copy.ts
async function copy3(src4, dst, options3) {
  let n = 0;
  const b = new Uint8Array(options3?.bufSize ?? DEFAULT_BUFFER_SIZE2);
  while (true) {
    const result = await src4.read(b);
    if (result === null) break;
    await writeAll(dst, b.subarray(0, result));
    n += result;
  }
  return n;
}

// deno:https://jsr.io/@std/io/0.225.2/iterate_reader.ts
async function* iterateReader(reader, options3) {
  const bufSize = options3?.bufSize ?? DEFAULT_BUFFER_SIZE2;
  const b = new Uint8Array(bufSize);
  while (true) {
    const result = await reader.read(b);
    if (result === null) {
      break;
    }
    yield b.slice(0, result);
  }
}
function* iterateReaderSync(reader, options3) {
  const bufSize = options3?.bufSize ?? DEFAULT_BUFFER_SIZE2;
  const b = new Uint8Array(bufSize);
  while (true) {
    const result = reader.readSync(b);
    if (result === null) {
      break;
    }
    yield b.slice(0, result);
  }
}

// deno:https://jsr.io/@std/io/0.225.2/read_all.ts
async function readAll(reader) {
  const chunks = [];
  while (true) {
    let chunk = new Uint8Array(DEFAULT_CHUNK_SIZE2);
    const n = await reader.read(chunk);
    if (n === null) {
      break;
    }
    if (n < DEFAULT_CHUNK_SIZE2) {
      chunk = chunk.subarray(0, n);
    }
    chunks.push(chunk);
  }
  return concat(chunks);
}
function readAllSync(reader) {
  const chunks = [];
  while (true) {
    let chunk = new Uint8Array(DEFAULT_CHUNK_SIZE2);
    const n = reader.readSync(chunk);
    if (n === null) {
      break;
    }
    if (n < DEFAULT_CHUNK_SIZE2) {
      chunk = chunk.subarray(0, n);
    }
    chunks.push(chunk);
  }
  return concat(chunks);
}

// deno:https://jsr.io/@std/io/0.225.2/reader_from_stream_reader.ts
function readerFromStreamReader(streamReader) {
  const buffer = new Buffer3();
  return {
    async read(p) {
      if (buffer.empty()) {
        const res = await streamReader.read();
        if (res.done) {
          return null;
        }
        await writeAll(buffer, res.value);
      }
      return buffer.read(p);
    }
  };
}

// deno:https://jsr.io/@std/io/0.225.2/_common.ts
function isCloser(value) {
  return typeof value === "object" && value !== null && value !== void 0 && "close" in value && // deno-lint-ignore no-explicit-any
  typeof value["close"] === "function";
}

// deno:https://jsr.io/@std/io/0.225.2/to_readable_stream.ts
function toReadableStream(reader, options3) {
  const { autoClose = true, chunkSize = DEFAULT_CHUNK_SIZE2, strategy } = options3 ?? {};
  return new ReadableStream({
    async pull(controller) {
      const chunk = new Uint8Array(chunkSize);
      try {
        const read4 = await reader.read(chunk);
        if (read4 === null) {
          if (isCloser(reader) && autoClose) {
            reader.close();
          }
          controller.close();
          return;
        }
        controller.enqueue(chunk.subarray(0, read4));
      } catch (e2) {
        controller.error(e2);
        if (isCloser(reader)) {
          reader.close();
        }
      }
    },
    cancel() {
      if (isCloser(reader) && autoClose) {
        reader.close();
      }
    }
  }, strategy);
}

// deno:https://jsr.io/@std/io/0.225.2/to_writable_stream.ts
function toWritableStream(writer, options3) {
  const { autoClose = true } = options3 ?? {};
  return new WritableStream({
    async write(chunk, controller) {
      try {
        await writeAll(writer, chunk);
      } catch (e2) {
        controller.error(e2);
        if (isCloser(writer) && autoClose) {
          writer.close();
        }
      }
    },
    close() {
      if (isCloser(writer) && autoClose) {
        writer.close();
      }
    },
    abort() {
      if (isCloser(writer) && autoClose) {
        writer.close();
      }
    }
  });
}

// deno:https://jsr.io/@std/io/0.225.2/types.ts
var SeekMode = /* @__PURE__ */ function(SeekMode2) {
  SeekMode2[SeekMode2["Start"] = 0] = "Start";
  SeekMode2[SeekMode2["Current"] = 1] = "Current";
  SeekMode2[SeekMode2["End"] = 2] = "End";
  return SeekMode2;
}({});

// deno:https://jsr.io/@db/sqlite/0.12.0/mod.ts
var mod_exports8 = {};
__export(mod_exports8, {
  Database: () => Database,
  SQLBlob: () => SQLBlob,
  SQLITE_SOURCEID: () => SQLITE_SOURCEID,
  SQLITE_VERSION: () => SQLITE_VERSION,
  SqliteError: () => SqliteError,
  Statement: () => Statement,
  isComplete: () => isComplete
});

// deno:https://jsr.io/@db/sqlite/0.12.0/deno.json
var deno_default = {
  name: "@db/sqlite",
  version: "0.12.0",
  github: "https://github.com/denodrivers/sqlite3",
  exports: "./mod.ts",
  exclude: [
    "sqlite",
    "scripts"
  ],
  tasks: {
    test: "deno test --unstable-ffi -A test/test.ts",
    build: "deno run -A scripts/build.ts",
    "bench-deno": "deno run -A --unstable-ffi bench/bench_deno.js 50 1000000",
    "bench-deno-ffi": "deno run -A --unstable-ffi bench/bench_deno_ffi.js 50 1000000",
    "bench-deno-wasm": "deno run -A --unstable-ffi bench/bench_deno_wasm.js 50 1000000",
    "bench-node": "node bench/bench_node.js 50 1000000",
    "bench-bun": "bun run bench/bench_bun.js 50 1000000",
    "bench-bun-ffi": "bun run bench/bench_bun_ffi.js 50 1000000",
    "bench-c": "./bench/bench 50 1000000",
    "bench-python": "python ./bench/bench_python.py",
    "bench:northwind": "deno bench -A --unstable-ffi bench/northwind/deno.js",
    "bench-wasm:northwind": "deno run -A --unstable-ffi bench/northwind/deno_wasm.js",
    "bench-node:northwind": "node bench/northwind/node.mjs",
    "bench-bun:northwind": "bun run bench/northwind/bun.js"
  },
  fmt: {
    exclude: [
      "sqlite"
    ]
  },
  lint: {
    rules: {
      exclude: [
        "camelcase",
        "no-explicit-any"
      ],
      include: [
        "explicit-function-return-type",
        "eqeqeq",
        "explicit-module-boundary-types"
      ]
    }
  }
};

// deno:https://jsr.io/@std/path/0.217.0/_common/from_file_url.ts
function assertArg7(url2) {
  url2 = url2 instanceof URL ? url2 : new URL(url2);
  if (url2.protocol !== "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return url2;
}

// deno:https://jsr.io/@std/path/0.217.0/windows/from_file_url.ts
function fromFileUrl4(url2) {
  url2 = assertArg7(url2);
  let path = decodeURIComponent(url2.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url2.hostname !== "") {
    path = `\\\\${url2.hostname}${path}`;
  }
  return path;
}

// deno:https://jsr.io/@std/path/0.217.0/posix/from_file_url.ts
function fromFileUrl5(url2) {
  url2 = assertArg7(url2);
  return decodeURIComponent(url2.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

// deno:https://jsr.io/@std/path/0.217.0/_os.ts
var osType = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator: navigator2 } = globalThis;
  if (navigator2?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows2 = osType === "windows";

// deno:https://jsr.io/@std/path/0.217.0/from_file_url.ts
function fromFileUrl6(url2) {
  return isWindows2 ? fromFileUrl4(url2) : fromFileUrl5(url2);
}

// deno:https://jsr.io/@std/encoding/1.0.10/_common16.ts
var alphabet3 = new TextEncoder().encode("0123456789abcdef");
var rAlphabet3 = new Uint8Array(128).fill(16);
alphabet3.forEach((byte, i2) => rAlphabet3[byte] = i2);
new TextEncoder().encode("ABCDEF").forEach((byte, i2) => rAlphabet3[byte] = i2 + 10);
function calcSizeHex(originalSize) {
  return originalSize * 2;
}
function encode2(buffer, i2, o2, alphabet5) {
  for (; i2 < buffer.length; ++i2) {
    const x3 = buffer[i2];
    buffer[o2++] = alphabet5[x3 >> 4];
    buffer[o2++] = alphabet5[x3 & 15];
  }
  return o2;
}

// deno:https://jsr.io/@std/encoding/1.0.10/hex.ts
var alphabet4 = new TextEncoder().encode("0123456789abcdef");
var rAlphabet4 = new Uint8Array(128).fill(16);
alphabet4.forEach((byte, i2) => rAlphabet4[byte] = i2);
new TextEncoder().encode("ABCDEF").forEach((byte, i2) => rAlphabet4[byte] = i2 + 10);
function encodeHex(src4) {
  if (typeof src4 === "string") {
    src4 = new TextEncoder().encode(src4);
  } else if (src4 instanceof ArrayBuffer) src4 = new Uint8Array(src4).slice();
  else src4 = src4.slice();
  const [output, i2] = detach(src4, calcSizeHex(src4.length));
  encode2(output, i2, 0, alphabet4);
  return new TextDecoder().decode(output);
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/util.ts
var encoder = new TextEncoder();
function baseUrlToFilename(url2) {
  const out = [];
  const protocol = url2.protocol.replace(":", "");
  out.push(protocol);
  switch (protocol) {
    case "http":
    case "https": {
      const host = url2.hostname;
      const hostPort = url2.port;
      out.push(hostPort ? `${host}_PORT${hostPort}` : host);
      break;
    }
    case "file":
    case "data":
    case "blob":
      break;
    default:
      throw new TypeError(`Don't know how to create cache name for protocol: ${protocol}`);
  }
  return join3(...out);
}
function stringToURL(url2) {
  return url2.startsWith("file://") || url2.startsWith("http://") || url2.startsWith("https://") ? new URL(url2) : toFileUrl3(resolve3(url2));
}
async function hash(value) {
  return encodeHex(new Uint8Array(await crypto.subtle.digest("SHA-256", encoder.encode(value))));
}
async function urlToFilename(url2) {
  const cacheFilename = baseUrlToFilename(url2);
  const hashedFilename = await hash(url2.pathname + url2.search);
  return join3(cacheFilename, hashedFilename);
}
async function isFile(filePath) {
  try {
    const stats = await Deno.lstat(filePath);
    return stats.isFile;
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    }
    throw err;
  }
}
function homeDir() {
  switch (Deno.build.os) {
    case "windows":
      return Deno.env.get("USERPROFILE");
    case "linux":
    case "darwin":
    case "freebsd":
    case "netbsd":
    case "aix":
    case "solaris":
    case "illumos":
    case "android":
      return Deno.env.get("HOME");
    default:
      throw Error("unreachable");
  }
}
function cacheDir() {
  if (Deno.build.os === "darwin") {
    const home = homeDir();
    if (home) {
      return join3(home, "Library/Caches");
    }
  } else if (Deno.build.os === "windows") {
    return Deno.env.get("LOCALAPPDATA");
  } else {
    const cacheHome = Deno.env.get("XDG_CACHE_HOME");
    if (cacheHome) {
      return cacheHome;
    } else {
      const home = homeDir();
      if (home) {
        return join3(home, ".cache");
      }
    }
  }
}
function denoCacheDir() {
  const dd = Deno.env.get("DENO_DIR");
  let root;
  if (dd) {
    root = normalize3(isAbsolute3(dd) ? dd : join3(Deno.cwd(), dd));
  } else {
    const cd = cacheDir();
    if (cd) {
      root = join3(cd, "deno");
    } else {
      const hd = homeDir();
      if (hd) {
        root = join3(hd, ".deno");
      }
    }
  }
  return root;
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/download.ts
var ALL_ARCHS = [
  "x86_64",
  "aarch64"
];
var ALL_OSS = [
  "darwin",
  "linux",
  "android",
  "windows",
  "freebsd",
  "netbsd",
  "aix",
  "solaris",
  "illumos"
];
var defaultExtensions = {
  darwin: "dylib",
  linux: "so",
  windows: "dll",
  freebsd: "so",
  netbsd: "so",
  aix: "so",
  solaris: "so",
  illumos: "so",
  android: "so"
};
var defaultPrefixes = {
  darwin: "lib",
  linux: "lib",
  netbsd: "lib",
  freebsd: "lib",
  aix: "lib",
  solaris: "lib",
  illumos: "lib",
  windows: "",
  android: "lib"
};
function getCrossOption(record2) {
  if (record2 === void 0) {
    return;
  }
  if (ALL_OSS.some((os) => os in record2)) {
    const subrecord = record2[Deno.build.os];
    if (subrecord && typeof subrecord === "object" && ALL_ARCHS.some((arch) => arch in subrecord)) {
      return subrecord[Deno.build.arch];
    } else {
      return subrecord;
    }
  }
  if (ALL_ARCHS.some((arch) => arch in record2)) {
    const subrecord = record2[Deno.build.arch];
    if (subrecord && typeof subrecord === "object" && ALL_OSS.some((os) => os in subrecord)) {
      return subrecord[Deno.build.os];
    } else {
      return subrecord;
    }
  }
}
function createDownloadURL(options3) {
  if (typeof options3 === "string" || options3 instanceof URL) {
    options3 = {
      url: options3
    };
  }
  options3.extensions ??= defaultExtensions;
  options3.prefixes ??= defaultPrefixes;
  for (const key in options3.extensions) {
    const os = key;
    if (options3.extensions[os] !== void 0) {
      options3.extensions[os] = options3.extensions[os].replace(/\.?(.+)/, "$1");
    }
  }
  let url2;
  if (options3.url instanceof URL) {
    url2 = options3.url;
  } else if (typeof options3.url === "string") {
    url2 = stringToURL(options3.url);
  } else {
    const tmpUrl = getCrossOption(options3.url);
    if (tmpUrl === void 0) {
      throw new TypeError(`An URL for the "${Deno.build.os}-${Deno.build.arch}" target was not provided.`);
    }
    if (typeof tmpUrl === "string") {
      url2 = stringToURL(tmpUrl);
    } else {
      url2 = tmpUrl;
    }
  }
  if ("name" in options3 && !Object.values(options3.extensions).includes(extname3(url2.pathname))) {
    if (!url2.pathname.endsWith("/")) {
      url2.pathname = `${url2.pathname}/`;
    }
    const prefix = getCrossOption(options3.prefixes) ?? "";
    const suffix = getCrossOption(options3.suffixes) ?? "";
    const extension = options3.extensions[Deno.build.os];
    if (options3.name === void 0) {
      throw new TypeError(`Expected the "name" property for an automatically assembled URL.`);
    }
    const filename = `${prefix}${options3.name}${suffix}.${extension}`;
    url2 = new URL(filename, url2);
  }
  return url2;
}
async function ensureCacheLocation(location = "deno") {
  if (location === "deno") {
    const dir = denoCacheDir();
    if (dir === void 0) {
      throw new Error("Could not get the deno cache directory, try using another CacheLocation in the plug options.");
    }
    location = join3(dir, "plug");
  } else if (location === "cache") {
    const dir = cacheDir();
    if (dir === void 0) {
      throw new Error("Could not get the cache directory, try using another CacheLocation in the plug options.");
    }
    location = join3(dir, "plug");
  } else if (location === "cwd") {
    location = join3(Deno.cwd(), "plug");
  } else if (location === "tmp") {
    location = await Deno.makeTempDir({
      prefix: "plug"
    });
  } else if (typeof location === "string" && location.startsWith("file://")) {
    location = fromFileUrl3(location);
  } else if (location instanceof URL) {
    if (location?.protocol !== "file:") {
      throw new TypeError("Cannot use any other protocol than file:// for an URL cache location.");
    }
    location = fromFileUrl3(location);
  }
  location = resolve3(normalize3(location));
  await ensureDir(location);
  return location;
}
async function download(options3) {
  const location = (typeof options3 === "object" && "location" in options3 ? options3.location : void 0) ?? "deno";
  const setting = (typeof options3 === "object" && "cache" in options3 ? options3.cache : void 0) ?? "use";
  const url2 = createDownloadURL(options3);
  const directory = await ensureCacheLocation(location);
  const cacheBasePath = join3(directory, await urlToFilename(url2));
  const cacheFilePath = `${cacheBasePath}${extname3(url2.pathname)}`;
  const cacheMetaPath = `${cacheBasePath}.metadata.json`;
  const cached2 = setting === "use" ? await isFile(cacheFilePath) : setting === "only" || setting !== "reloadAll";
  await ensureDir(dirname3(cacheBasePath));
  if (!cached2) {
    const meta = {
      url: url2
    };
    switch (url2.protocol) {
      case "http:":
      case "https:": {
        console.log(`${green2("Downloading")} ${url2}`);
        const response = await fetch(url2.toString());
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error(`Could not find ${url2}`);
          } else {
            throw new Deno.errors.Http(`${response.status} ${response.statusText}`);
          }
        }
        await Deno.writeFile(cacheFilePath, new Uint8Array(await response.arrayBuffer()));
        break;
      }
      case "file:": {
        console.log(`${green2("Copying")} ${url2}`);
        await Deno.copyFile(fromFileUrl3(url2), cacheFilePath);
        if (Deno.build.os !== "windows") {
          await Deno.chmod(cacheFilePath, 420);
        }
        break;
      }
      default: {
        throw new TypeError(`Cannot fetch to cache using the "${url2.protocol}" protocol`);
      }
    }
    await Deno.writeTextFile(cacheMetaPath, JSON.stringify(meta));
  }
  if (!await isFile(cacheFilePath)) {
    throw new Error(`Could not find "${url2}" in cache.`);
  }
  return cacheFilePath;
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/mod.ts
async function dlopen(options3, symbols2) {
  if (Deno.dlopen === void 0) {
    throw new Error("`--unstable-ffi` is required");
  }
  return Deno.dlopen(await download(options3), symbols2);
}

// deno:https://jsr.io/@db/sqlite/0.12.0/src/ffi.ts
var symbols = {
  sqlite3_open_v2: {
    parameters: [
      "buffer",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_close_v2: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_changes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_total_changes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_last_insert_rowid: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_get_autocommit: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_prepare_v2: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "buffer",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_reset: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_clear_bindings: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_step: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_column_count: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_column_type: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_text: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_value: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_finalize: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_exec: {
    parameters: [
      "pointer",
      "buffer",
      "pointer",
      "pointer",
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_free: {
    parameters: [
      "pointer"
    ],
    result: "void"
  },
  sqlite3_column_int: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_double: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "f64"
  },
  sqlite3_column_blob: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_bytes: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_name: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_decltype: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "u64"
  },
  sqlite3_bind_parameter_index: {
    parameters: [
      "pointer",
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_bind_text: {
    parameters: [
      "pointer",
      "i32",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_blob: {
    parameters: [
      "pointer",
      "i32",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_double: {
    parameters: [
      "pointer",
      "i32",
      "f64"
    ],
    result: "i32"
  },
  sqlite3_bind_int: {
    parameters: [
      "pointer",
      "i32",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_bind_int64: {
    parameters: [
      "pointer",
      "i32",
      "i64"
    ],
    result: "i32"
  },
  sqlite3_bind_null: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_expanded_sql: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_bind_parameter_count: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_complete: {
    parameters: [
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_sourceid: {
    parameters: [],
    result: "pointer"
  },
  sqlite3_libversion: {
    parameters: [],
    result: "pointer"
  },
  sqlite3_blob_open: {
    parameters: [
      "pointer",
      /* sqlite3 *db */
      "buffer",
      /* const char *zDb */
      "buffer",
      /* const char *zTable */
      "buffer",
      /* const char *zColumn */
      "i64",
      /* sqlite3_int64 iRow */
      "i32",
      /* int flags */
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_blob_read: {
    parameters: [
      "pointer",
      /* sqlite3_blob *blob */
      "buffer",
      /* void *Z */
      "i32",
      /* int N */
      "i32"
    ],
    result: "i32"
  },
  sqlite3_blob_write: {
    parameters: [
      "pointer",
      /* sqlite3_blob *blob */
      "buffer",
      /* const void *z */
      "i32",
      /* int n */
      "i32"
    ],
    result: "i32"
  },
  sqlite3_blob_bytes: {
    parameters: [
      "pointer"
      /* sqlite3_blob *blob */
    ],
    result: "i32"
  },
  sqlite3_blob_close: {
    parameters: [
      "pointer"
      /* sqlite3_blob *blob */
    ],
    result: "i32"
  },
  sqlite3_sql: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_stmt_readonly: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_parameter_name: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_errcode: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_errmsg: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_errstr: {
    parameters: [
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_int64: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i64"
  },
  sqlite3_backup_init: {
    parameters: [
      "pointer",
      "buffer",
      "pointer",
      "buffer"
    ],
    result: "pointer"
  },
  sqlite3_backup_step: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_backup_finish: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_backup_remaining: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_backup_pagecount: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_create_function: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "i32",
      "pointer",
      "pointer",
      "pointer",
      "pointer"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_result_blob: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "isize"
    ],
    result: "void"
  },
  sqlite3_result_double: {
    parameters: [
      "pointer",
      "f64"
    ],
    result: "void"
  },
  sqlite3_result_error: {
    parameters: [
      "pointer",
      "buffer",
      "i32"
    ],
    result: "void"
  },
  sqlite3_result_int: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "void"
  },
  sqlite3_result_int64: {
    parameters: [
      "pointer",
      "i64"
    ],
    result: "void"
  },
  sqlite3_result_null: {
    parameters: [
      "pointer"
    ],
    result: "void"
  },
  sqlite3_result_text: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "isize"
    ],
    result: "void"
  },
  sqlite3_value_type: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_subtype: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_blob: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_value_double: {
    parameters: [
      "pointer"
    ],
    result: "f64"
  },
  sqlite3_value_int: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_int64: {
    parameters: [
      "pointer"
    ],
    result: "i64"
  },
  sqlite3_value_text: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_value_bytes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_aggregate_context: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer",
    optional: true
  },
  sqlite3_enable_load_extension: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_load_extension: {
    parameters: [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_initialize: {
    parameters: [],
    result: "i32"
  }
};
var lib;
function tryGetEnv(key) {
  try {
    return Deno.env.get(key);
  } catch (e2) {
    if (e2 instanceof Deno.errors.PermissionDenied) {
      return void 0;
    }
    throw e2;
  }
}
try {
  const customPath = tryGetEnv("DENO_SQLITE_PATH");
  const sqliteLocal = tryGetEnv("DENO_SQLITE_LOCAL");
  if (sqliteLocal === "1") {
    lib = Deno.dlopen(new URL(`../build/${Deno.build.os === "windows" ? "" : "lib"}sqlite3${Deno.build.arch !== "x86_64" ? `_${Deno.build.arch}` : ""}.${Deno.build.os === "windows" ? "dll" : Deno.build.os === "darwin" ? "dylib" : "so"}`, import.meta.url), symbols).symbols;
  } else if (customPath) {
    lib = Deno.dlopen(customPath, symbols).symbols;
  } else {
    lib = (await dlopen({
      name: "sqlite3",
      url: `${deno_default.github}/releases/download/${deno_default.version}/`,
      suffixes: {
        aarch64: "_aarch64"
      }
    }, symbols)).symbols;
  }
} catch (e2) {
  if (e2 instanceof Deno.errors.PermissionDenied) {
    throw e2;
  }
  throw new Error("Failed to load SQLite3 Dynamic Library", {
    cause: e2
  });
}
var init = lib.sqlite3_initialize();
if (init !== 0) {
  throw new Error(`Failed to initialize SQLite3: ${init}`);
}
var ffi_default = lib;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/constants.ts
var SQLITE3_OK = 0;
var SQLITE3_MISUSE = 21;
var SQLITE3_ROW = 100;
var SQLITE3_DONE = 101;
var SQLITE3_OPEN_READONLY = 1;
var SQLITE3_OPEN_READWRITE = 2;
var SQLITE3_OPEN_CREATE = 4;
var SQLITE3_OPEN_MEMORY = 128;
var SQLITE_INTEGER = 1;
var SQLITE_FLOAT = 2;
var SQLITE_TEXT = 3;
var SQLITE_BLOB = 4;
var SQLITE_NULL = 5;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/util.ts
var { sqlite3_errmsg, sqlite3_errstr } = ffi_default;
var encoder2 = new TextEncoder();
function toCString(str) {
  return encoder2.encode(str + "\0");
}
var SqliteError = class extends Error {
  code;
  name;
  constructor(code3 = 1, message = "Unknown Error") {
    super(`${code3}: ${message}`), this.code = code3, this.name = "SqliteError";
  }
};
function unwrap(code3, db2) {
  if (code3 === SQLITE3_OK || code3 === SQLITE3_DONE) return;
  if (code3 === SQLITE3_MISUSE) {
    throw new SqliteError(code3, "SQLite3 API misuse");
  } else if (db2 !== void 0) {
    const errmsg = sqlite3_errmsg(db2);
    if (errmsg === null) throw new SqliteError(code3);
    throw new Error(Deno.UnsafePointerView.getCString(errmsg));
  } else {
    throw new SqliteError(code3, Deno.UnsafePointerView.getCString(sqlite3_errstr(code3)));
  }
}
var buf = Deno.UnsafePointerView.getArrayBuffer;
var readCstr = Deno.UnsafePointerView.getCString;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/statement.ts
var _computedKey;
var _computedKey1;
var _computedKey2;
var { sqlite3_prepare_v2, sqlite3_reset, sqlite3_clear_bindings, sqlite3_step, sqlite3_column_count, sqlite3_column_type, sqlite3_column_value, sqlite3_value_subtype, sqlite3_column_text, sqlite3_finalize, sqlite3_column_int64, sqlite3_column_double, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_name, sqlite3_expanded_sql, sqlite3_bind_parameter_count, sqlite3_bind_int, sqlite3_bind_int64, sqlite3_bind_text, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_parameter_index, sqlite3_sql, sqlite3_stmt_readonly, sqlite3_bind_parameter_name, sqlite3_changes, sqlite3_column_int } = ffi_default;
var STATEMENTS_TO_DB = /* @__PURE__ */ new Map();
var emptyStringBuffer = new Uint8Array(1);
var statementFinalizer = new FinalizationRegistry((ptr) => {
  if (STATEMENTS_TO_DB.has(ptr)) {
    sqlite3_finalize(ptr);
    STATEMENTS_TO_DB.delete(ptr);
  }
});
var JSON_SUBTYPE = 74;
var BIG_MAX = BigInt(Number.MAX_SAFE_INTEGER);
function getColumn(handle, i2, int642) {
  const ty = sqlite3_column_type(handle, i2);
  if (ty === SQLITE_INTEGER && !int642) return sqlite3_column_int(handle, i2);
  switch (ty) {
    case SQLITE_TEXT: {
      const ptr = sqlite3_column_text(handle, i2);
      if (ptr === null) return null;
      const text = readCstr(ptr, 0);
      const value = sqlite3_column_value(handle, i2);
      const subtype = sqlite3_value_subtype(value);
      if (subtype === JSON_SUBTYPE) {
        try {
          return JSON.parse(text);
        } catch (_error) {
          return text;
        }
      }
      return text;
    }
    case SQLITE_INTEGER: {
      const val = sqlite3_column_int64(handle, i2);
      if (val < -BIG_MAX || val > BIG_MAX) {
        return val;
      }
      return Number(val);
    }
    case SQLITE_FLOAT: {
      return sqlite3_column_double(handle, i2);
    }
    case SQLITE_BLOB: {
      const ptr = sqlite3_column_blob(handle, i2);
      if (ptr === null) {
        return new Uint8Array();
      }
      const bytes = sqlite3_column_bytes(handle, i2);
      return new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(ptr, bytes).slice(0));
    }
    default: {
      return null;
    }
  }
}
_computedKey = Symbol.iterator, _computedKey1 = Symbol.dispose, _computedKey2 = Symbol.for("Deno.customInspect");
var Statement = class {
  db;
  #handle;
  #finalizerToken;
  #bound;
  #hasNoArgs;
  #unsafeConcurrency;
  /**
   * Whether the query might call into JavaScript or not.
   *
   * Must enable if the query makes use of user defined functions,
   * otherwise there can be V8 crashes.
   *
   * Off by default. Causes performance degradation.
   */
  callback;
  /** Unsafe Raw (pointer) to the sqlite object */
  get unsafeHandle() {
    return this.#handle;
  }
  /** SQL string including bindings */
  get expandedSql() {
    return readCstr(sqlite3_expanded_sql(this.#handle));
  }
  /** The SQL string that we passed when creating statement */
  get sql() {
    return readCstr(sqlite3_sql(this.#handle));
  }
  /** Whether this statement doesn't make any direct changes to the DB */
  get readonly() {
    return sqlite3_stmt_readonly(this.#handle) !== 0;
  }
  /** Simply run the query without retrieving any output there may be. */
  run(...args) {
    return this.#runWithArgs(...args);
  }
  /**
   * Run the query and return the resulting rows where rows are array of columns.
   */
  values(...args) {
    return this.#valuesWithArgs(...args);
  }
  /**
   * Run the query and return the resulting rows where rows are objects
   * mapping column name to their corresponding values.
   */
  all(...args) {
    return this.#allWithArgs(...args);
  }
  #bindParameterCount;
  /** Number of parameters (to be) bound */
  get bindParameterCount() {
    return this.#bindParameterCount;
  }
  constructor(db2, sql) {
    this.db = db2;
    this.#bound = false;
    this.#hasNoArgs = false;
    this.callback = false;
    this.#bindRefs = /* @__PURE__ */ new Set();
    this.#rowObject = {};
    const pHandle = new BigUint64Array(1);
    unwrap(sqlite3_prepare_v2(db2.unsafeHandle, toCString(sql), sql.length, pHandle, null), db2.unsafeHandle);
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
    STATEMENTS_TO_DB.set(this.#handle, db2.unsafeHandle);
    this.#unsafeConcurrency = db2.unsafeConcurrency;
    this.#finalizerToken = {
      handle: this.#handle
    };
    statementFinalizer.register(this, this.#handle, this.#finalizerToken);
    if ((this.#bindParameterCount = sqlite3_bind_parameter_count(this.#handle)) === 0) {
      this.#hasNoArgs = true;
      this.all = this.#allNoArgs;
      this.values = this.#valuesNoArgs;
      this.run = this.#runNoArgs;
      this.value = this.#valueNoArgs;
      this.get = this.#getNoArgs;
    }
  }
  /** Shorthand for `this.callback = true`. Enables calling user defined functions. */
  enableCallback() {
    this.callback = true;
    return this;
  }
  /** Get bind parameter name by index */
  bindParameterName(i2) {
    return readCstr(sqlite3_bind_parameter_name(this.#handle, i2));
  }
  /** Get bind parameter index by name */
  bindParameterIndex(name) {
    if (name[0] !== ":" && name[0] !== "@" && name[0] !== "$") {
      name = ":" + name;
    }
    return sqlite3_bind_parameter_index(this.#handle, toCString(name));
  }
  #begin() {
    sqlite3_reset(this.#handle);
    if (!this.#bound && !this.#hasNoArgs) {
      sqlite3_clear_bindings(this.#handle);
      this.#bindRefs.clear();
    }
  }
  #bindRefs;
  #bind(i2, param) {
    switch (typeof param) {
      case "number": {
        if (Number.isInteger(param)) {
          if (Number.isSafeInteger(param) && param >= -(2 ** 31) && param < 2 ** 31) {
            unwrap(sqlite3_bind_int(this.#handle, i2 + 1, param));
          } else {
            unwrap(sqlite3_bind_int64(this.#handle, i2 + 1, BigInt(param)));
          }
        } else {
          unwrap(sqlite3_bind_double(this.#handle, i2 + 1, param));
        }
        break;
      }
      case "string": {
        if (param === "") {
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, emptyStringBuffer, 0, null));
        } else {
          const str = new TextEncoder().encode(param);
          this.#bindRefs.add(str);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, str, str.byteLength, null));
        }
        break;
      }
      case "object": {
        if (param === null) {
        } else if (param instanceof Uint8Array) {
          this.#bindRefs.add(param);
          unwrap(sqlite3_bind_blob(this.#handle, i2 + 1, param.byteLength === 0 ? emptyStringBuffer : param, param.byteLength, null));
        } else if (param instanceof Date) {
          const cstring = toCString(param.toISOString());
          this.#bindRefs.add(cstring);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, cstring, -1, null));
        } else {
          const cstring = toCString(JSON.stringify(param));
          this.#bindRefs.add(cstring);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, cstring, -1, null));
        }
        break;
      }
      case "bigint": {
        unwrap(sqlite3_bind_int64(this.#handle, i2 + 1, param));
        break;
      }
      case "boolean":
        unwrap(sqlite3_bind_int(this.#handle, i2 + 1, param ? 1 : 0));
        break;
      default: {
        throw new Error(`Value of unsupported type: ${Deno.inspect(param)}`);
      }
    }
  }
  /**
   * Bind parameters to the statement. This method can only be called once
   * to set the parameters to be same throughout the statement. You cannot
   * change the parameters after this method is called.
   *
   * This method is merely just for optimization to avoid binding parameters
   * each time in prepared statement.
   */
  bind(...params) {
    this.#bindAll(params);
    this.#bound = true;
    return this;
  }
  #bindAll(params) {
    if (this.#bound) throw new Error("Statement already bound to values");
    if (typeof params[0] === "object" && params[0] !== null && !(params[0] instanceof Uint8Array) && !(params[0] instanceof Date)) {
      params = params[0];
    }
    if (Array.isArray(params)) {
      for (let i2 = 0; i2 < params.length; i2++) {
        this.#bind(i2, params[i2]);
      }
    } else {
      for (const [name, param] of Object.entries(params)) {
        const i2 = this.bindParameterIndex(name);
        if (i2 === 0) {
          throw new Error(`No such parameter "${name}"`);
        }
        this.#bind(i2 - 1, param);
      }
    }
  }
  #runNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const status = sqlite3_step(handle);
    if (status !== SQLITE3_ROW && status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return sqlite3_changes(this.db.unsafeHandle);
  }
  #runWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_ROW && status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return sqlite3_changes(this.db.unsafeHandle);
  }
  #valuesNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const columnCount = sqlite3_column_count(handle);
    const result = [];
    const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
      length: columnCount
    }).map((_, i2) => `getColumn(h, ${i2}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowArray(handle));
      status = sqlite3_step(handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #valuesWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const columnCount = sqlite3_column_count(handle);
    const result = [];
    const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
      length: columnCount
    }).map((_, i2) => `getColumn(h, ${i2}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowArray(handle));
      status = sqlite3_step(handle);
    }
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #rowObjectFn;
  getRowObject() {
    if (!this.#rowObjectFn || !this.#unsafeConcurrency) {
      const columnNames = this.columnNames();
      const getRowObject = new Function("getColumn", `
        return function(h) {
          return {
            ${columnNames.map((name, i2) => `"${name}": getColumn(h, ${i2}, ${this.db.int64})`).join(",\n")}
          };
        };
        `)(getColumn);
      this.#rowObjectFn = getRowObject;
    }
    return this.#rowObjectFn;
  }
  #allNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const getRowObject = this.getRowObject();
    const result = [];
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowObject(handle));
      status = sqlite3_step(handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #allWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const getRowObject = this.getRowObject();
    const result = [];
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowObject(handle));
      status = sqlite3_step(handle);
    }
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  /** Fetch only first row as an array, if any. */
  value(...params) {
    const handle = this.#handle;
    const int642 = this.db.int64;
    const arr = new Array(sqlite3_column_count(handle));
    sqlite3_reset(handle);
    if (!this.#hasNoArgs && !this.#bound) {
      sqlite3_clear_bindings(handle);
      this.#bindRefs.clear();
      if (params.length) {
        this.#bindAll(params);
      }
    }
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        arr[i2] = getColumn(handle, i2, int642);
      }
      sqlite3_reset(this.#handle);
      return arr;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #valueNoArgs() {
    const handle = this.#handle;
    const int642 = this.db.int64;
    const cc = sqlite3_column_count(handle);
    const arr = new Array(cc);
    sqlite3_reset(handle);
    const status = sqlite3_step(handle);
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < cc; i2++) {
        arr[i2] = getColumn(handle, i2, int642);
      }
      sqlite3_reset(this.#handle);
      return arr;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #columnNames;
  #rowObject;
  columnNames() {
    if (!this.#columnNames || !this.#unsafeConcurrency) {
      const columnCount = sqlite3_column_count(this.#handle);
      const columnNames = new Array(columnCount);
      for (let i2 = 0; i2 < columnCount; i2++) {
        columnNames[i2] = readCstr(sqlite3_column_name(this.#handle, i2));
      }
      this.#columnNames = columnNames;
      this.#rowObject = {};
      for (const name of columnNames) {
        this.#rowObject[name] = void 0;
      }
    }
    return this.#columnNames;
  }
  /** Fetch only first row as an object, if any. */
  get(...params) {
    const handle = this.#handle;
    const int642 = this.db.int64;
    const columnNames = this.columnNames();
    const row = {};
    sqlite3_reset(handle);
    if (!this.#hasNoArgs && !this.#bound) {
      sqlite3_clear_bindings(handle);
      this.#bindRefs.clear();
      if (params.length) {
        this.#bindAll(params);
      }
    }
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < columnNames.length; i2++) {
        row[columnNames[i2]] = getColumn(handle, i2, int642);
      }
      sqlite3_reset(this.#handle);
      return row;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #getNoArgs() {
    const handle = this.#handle;
    const int642 = this.db.int64;
    const columnNames = this.columnNames();
    const row = this.#rowObject;
    sqlite3_reset(handle);
    const status = sqlite3_step(handle);
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < columnNames?.length; i2++) {
        row[columnNames[i2]] = getColumn(handle, i2, int642);
      }
      sqlite3_reset(handle);
      return row;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  /** Free up the statement object. */
  finalize() {
    if (!STATEMENTS_TO_DB.has(this.#handle)) return;
    this.#bindRefs.clear();
    statementFinalizer.unregister(this.#finalizerToken);
    STATEMENTS_TO_DB.delete(this.#handle);
    unwrap(sqlite3_finalize(this.#handle));
  }
  /** Coerces the statement to a string, which in this case is expanded SQL. */
  toString() {
    return readCstr(sqlite3_expanded_sql(this.#handle));
  }
  /** Iterate over resultant rows from query. */
  *iter(...params) {
    this.#begin();
    this.#bindAll(params);
    const getRowObject = this.getRowObject();
    let status = sqlite3_step(this.#handle);
    while (status === SQLITE3_ROW) {
      yield getRowObject(this.#handle);
      status = sqlite3_step(this.#handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(this.#handle);
  }
  [_computedKey]() {
    return this.iter();
  }
  [_computedKey1]() {
    this.finalize();
  }
  [_computedKey2]() {
    return `Statement { ${this.expandedSql} }`;
  }
};

// deno:https://jsr.io/@db/sqlite/0.12.0/src/blob.ts
var _computedKey3;
var _computedKey12;
var { sqlite3_blob_open, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_read, sqlite3_blob_write } = ffi_default;
_computedKey3 = Symbol.iterator, _computedKey12 = Symbol.for("Deno.customInspect");
var SQLBlob = class {
  #handle;
  constructor(db2, options3) {
    options3 = Object.assign({
      readonly: true,
      db: "main"
    }, options3);
    const pHandle = new BigUint64Array(1);
    unwrap(sqlite3_blob_open(db2.unsafeHandle, toCString(options3.db ?? "main"), toCString(options3.table), toCString(options3.column), BigInt(options3.row), options3.readonly === false ? 1 : 0, pHandle));
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
  }
  /** Byte size of the Blob */
  get byteLength() {
    return sqlite3_blob_bytes(this.#handle);
  }
  /** Read from the Blob at given offset into a buffer (Uint8Array) */
  readSync(offset, p) {
    unwrap(sqlite3_blob_read(this.#handle, p, p.byteLength, offset));
  }
  /** Write a buffer (Uint8Array) at given offset in the Blob */
  writeSync(offset, p) {
    unwrap(sqlite3_blob_write(this.#handle, p, p.byteLength, offset));
  }
  /** Close the Blob. It **must** be called to prevent leaks. */
  close() {
    unwrap(sqlite3_blob_close(this.#handle));
  }
  /** Obtains Web Stream for reading the Blob */
  get readable() {
    const length4 = this.byteLength;
    let offset = 0;
    return new ReadableStream({
      type: "bytes",
      pull: (ctx) => {
        try {
          const byob = ctx.byobRequest;
          if (byob) {
            const toRead = Math.min(length4 - offset, byob.view.byteLength);
            this.readSync(offset, byob.view.subarray(0, toRead));
            offset += toRead;
            byob.respond(toRead);
          } else {
            const toRead = Math.min(length4 - offset, ctx.desiredSize || 1024 * 16);
            if (toRead === 0) {
              ctx.close();
              return;
            }
            const buffer = new Uint8Array(toRead);
            this.readSync(offset, buffer);
            offset += toRead;
            ctx.enqueue(buffer);
          }
        } catch (e2) {
          ctx.error(e2);
          ctx.byobRequest?.respond(0);
        }
      }
    });
  }
  /** Obtains Web Stream for writing to the Blob */
  get writable() {
    const length4 = this.byteLength;
    let offset = 0;
    return new WritableStream({
      write: (chunk, ctx) => {
        if (offset + chunk.byteLength > length4) {
          ctx.error(new Error("Write exceeds blob length"));
          return;
        }
        this.writeSync(offset, chunk);
        offset += chunk.byteLength;
      }
    });
  }
  *[_computedKey3]() {
    const length4 = this.byteLength;
    let offset = 0;
    while (offset < length4) {
      const toRead = Math.min(length4 - offset, 1024 * 16);
      const buffer = new Uint8Array(toRead);
      this.readSync(offset, buffer);
      offset += toRead;
      yield buffer;
    }
  }
  [_computedKey12]() {
    return `SQLite3.Blob(0x${this.byteLength.toString(16)})`;
  }
};

// deno:https://jsr.io/@db/sqlite/0.12.0/src/database.ts
var _computedKey4;
var { sqlite3_open_v2, sqlite3_close_v2, sqlite3_changes: sqlite3_changes2, sqlite3_total_changes, sqlite3_last_insert_rowid, sqlite3_get_autocommit, sqlite3_exec, sqlite3_free, sqlite3_libversion, sqlite3_sourceid, sqlite3_complete, sqlite3_finalize: sqlite3_finalize2, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_error, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double, sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type, sqlite3_create_function, sqlite3_result_int, sqlite3_aggregate_context, sqlite3_enable_load_extension, sqlite3_load_extension, sqlite3_backup_init, sqlite3_backup_step, sqlite3_backup_finish, sqlite3_errcode } = ffi_default;
var SQLITE_VERSION = readCstr(sqlite3_libversion());
var SQLITE_SOURCEID = readCstr(sqlite3_sourceid());
function isComplete(statement) {
  return Boolean(sqlite3_complete(toCString(statement)));
}
var BIG_MAX2 = BigInt(Number.MAX_SAFE_INTEGER);
_computedKey4 = Symbol.for("Deno.customInspect");
var Database = class {
  #path;
  #handle;
  #open = true;
  #enableLoadExtension = false;
  /** Whether to support BigInt columns. False by default, integers larger than 32 bit will be inaccurate. */
  int64;
  unsafeConcurrency;
  /** Whether DB connection is open */
  get open() {
    return this.#open;
  }
  /** Unsafe Raw (pointer) to the sqlite object */
  get unsafeHandle() {
    return this.#handle;
  }
  /** Path of the database file. */
  get path() {
    return this.#path;
  }
  /** Number of rows changed by the last executed statement. */
  get changes() {
    return sqlite3_changes2(this.#handle);
  }
  /** Number of rows changed since the database connection was opened. */
  get totalChanges() {
    return sqlite3_total_changes(this.#handle);
  }
  /** Gets last inserted Row ID */
  get lastInsertRowId() {
    return Number(sqlite3_last_insert_rowid(this.#handle));
  }
  /** Whether autocommit is enabled. Enabled by default, can be disabled using BEGIN statement. */
  get autocommit() {
    return sqlite3_get_autocommit(this.#handle) === 1;
  }
  /** Whether DB is in mid of a transaction */
  get inTransaction() {
    return this.#open && !this.autocommit;
  }
  get enableLoadExtension() {
    return this.#enableLoadExtension;
  }
  set enableLoadExtension(enabled3) {
    if (sqlite3_enable_load_extension === null) {
      throw new Error("Extension loading is not supported by the shared library that was used.");
    }
    const result = sqlite3_enable_load_extension(this.#handle, Number(enabled3));
    unwrap(result, this.#handle);
    this.#enableLoadExtension = enabled3;
  }
  constructor(path, options3 = {}) {
    this.#path = path instanceof URL ? fromFileUrl6(path) : path;
    let flags = 0;
    this.int64 = options3.int64 ?? false;
    this.unsafeConcurrency = options3.unsafeConcurrency ?? false;
    if (options3.flags !== void 0) {
      flags = options3.flags;
    } else {
      if (options3.memory) {
        flags |= SQLITE3_OPEN_MEMORY;
      }
      if (options3.readonly ?? false) {
        flags |= SQLITE3_OPEN_READONLY;
      } else {
        flags |= SQLITE3_OPEN_READWRITE;
      }
      if ((options3.create ?? true) && !options3.readonly) {
        flags |= SQLITE3_OPEN_CREATE;
      }
    }
    const pHandle = new BigUint64Array(1);
    const result = sqlite3_open_v2(toCString(this.#path), pHandle, flags, null);
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
    if (result !== 0) sqlite3_close_v2(this.#handle);
    unwrap(result);
    if (options3.enableLoadExtension) {
      this.enableLoadExtension = options3.enableLoadExtension;
    }
  }
  /**
   * Creates a new Prepared Statement from the given SQL statement.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = ?");
   *
   * for (const row of stmt.all(1)) {
   *   console.log(row);
   * }
   * ```
   *
   * Bind parameters can be either provided as an array of values, or as an object
   * mapping the parameter name to the value.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = ?");
   * const row = stmt.get(1);
   *
   * // or
   *
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = :id");
   * const row = stmt.get({ id: 1 });
   * ```
   *
   * Statements are automatically freed once GC catches them, however
   * you can also manually free using `finalize` method.
   *
   * @param sql SQL statement string
   * @returns Statement object
   */
  prepare(sql) {
    return new Statement(this, sql);
  }
  /**
   * Open a Blob for incremental I/O.
   *
   * Make sure to close the blob after you are done with it,
   * otherwise you will have memory leaks.
   */
  openBlob(options3) {
    return new SQLBlob(this, options3);
  }
  /**
   * Simply executes the SQL statement (supports multiple statements separated by semicolon).
   * Returns the number of changes made by last statement.
   *
   * Example:
   * ```ts
   * // Create table
   * db.exec("create table users (id integer not null, username varchar(20) not null)");
   *
   * // Inserts
   * db.exec("insert into users (id, username) values(?, ?)", id, username);
   *
   * // Insert with named parameters
   * db.exec("insert into users (id, username) values(:id, :username)", { id, username });
   *
   * // Pragma statements
   * db.exec("pragma journal_mode = WAL");
   * db.exec("pragma synchronous = normal");
   * db.exec("pragma temp_store = memory");
   * ```
   *
   * Under the hood, it uses `sqlite3_exec` if no parameters are given to bind
   * with the SQL statement, a prepared statement otherwise.
   */
  exec(sql, ...params) {
    if (params.length === 0) {
      const pErr = new BigUint64Array(1);
      sqlite3_exec(this.#handle, toCString(sql), null, null, new Uint8Array(pErr.buffer));
      const errPtr = Deno.UnsafePointer.create(pErr[0]);
      if (errPtr !== null) {
        const err = readCstr(errPtr);
        sqlite3_free(errPtr);
        throw new Error(err);
      }
      return sqlite3_changes2(this.#handle);
    }
    const stmt = this.prepare(sql);
    stmt.run(...params);
    return sqlite3_changes2(this.#handle);
  }
  /** Alias for `exec`. */
  run(sql, ...params) {
    return this.exec(sql, ...params);
  }
  /** Safely execute SQL with parameters using a tagged template */
  sql(strings, ...parameters) {
    const sql = strings.join("?");
    const stmt = this.prepare(sql);
    return stmt.all(...parameters);
  }
  /**
   * Wraps a callback function in a transaction.
   *
   * - When function is called, the transaction is started.
   * - When function returns, the transaction is committed.
   * - When function throws an error, the transaction is rolled back.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("insert into users (id, username) values(?, ?)");
   *
   * interface User {
   *   id: number;
   *   username: string;
   * }
   *
   * const insertUsers = db.transaction((data: User[]) => {
   *   for (const user of data) {
   *     stmt.run(user);
   *   }
   * });
   *
   * insertUsers([
   *   { id: 1, username: "alice" },
   *   { id: 2, username: "bob" },
   * ]);
   *
   * // May also use `insertUsers.deferred`, `immediate`, or `exclusive`.
   * // They corresspond to using `BEGIN DEFERRED`, `BEGIN IMMEDIATE`, and `BEGIN EXCLUSIVE`.
   * // For eg.
   *
   * insertUsers.deferred([
   *   { id: 1, username: "alice" },
   *   { id: 2, username: "bob" },
   * ]);
   * ```
   */
  transaction(fn) {
    const controller = getController(this);
    const properties = {
      default: {
        value: wrapTransaction(fn, this, controller.default)
      },
      deferred: {
        value: wrapTransaction(fn, this, controller.deferred)
      },
      immediate: {
        value: wrapTransaction(fn, this, controller.immediate)
      },
      exclusive: {
        value: wrapTransaction(fn, this, controller.exclusive)
      },
      database: {
        value: this,
        enumerable: true
      }
    };
    Object.defineProperties(properties.default.value, properties);
    Object.defineProperties(properties.deferred.value, properties);
    Object.defineProperties(properties.immediate.value, properties);
    Object.defineProperties(properties.exclusive.value, properties);
    return properties.default.value;
  }
  #callbacks = /* @__PURE__ */ new Set();
  /**
   * Creates a new user-defined function.
   *
   * Example:
   * ```ts
   * db.function("add", (a: number, b: number) => a + b);
   * db.prepare("select add(1, 2)").value<[number]>()!; // [3]
   * ```
   */
  function(name, fn, options3) {
    if (sqlite3_create_function === null) {
      throw new Error("User-defined functions are not supported by the shared library that was used.");
    }
    const cb = new Deno.UnsafeCallback({
      parameters: [
        "pointer",
        "i32",
        "pointer"
      ],
      result: "void"
    }, (ctx, nArgs, pArgs) => {
      const argptr = new Deno.UnsafePointerView(pArgs);
      const args = [];
      for (let i2 = 0; i2 < nArgs; i2++) {
        const arg = Deno.UnsafePointer.create(argptr.getBigUint64(i2 * 8));
        const type = sqlite3_value_type(arg);
        switch (type) {
          case SQLITE_INTEGER: {
            const value = sqlite3_value_int64(arg);
            if (value < -BIG_MAX2 || value > BIG_MAX2) {
              args.push(value);
            } else {
              args.push(Number(value));
            }
            break;
          }
          case SQLITE_FLOAT:
            args.push(sqlite3_value_double(arg));
            break;
          case SQLITE_TEXT:
            args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
            break;
          case SQLITE_BLOB:
            args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
            break;
          case SQLITE_NULL:
            args.push(null);
            break;
          default:
            throw new Error(`Unknown type: ${type}`);
        }
      }
      let result;
      try {
        result = fn(...args);
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      if (result === void 0 || result === null) {
        sqlite3_result_null(ctx);
      } else if (typeof result === "boolean") {
        sqlite3_result_int(ctx, result ? 1 : 0);
      } else if (typeof result === "number") {
        if (Number.isSafeInteger(result)) {
          sqlite3_result_int64(ctx, BigInt(result));
        } else sqlite3_result_double(ctx, result);
      } else if (typeof result === "bigint") {
        sqlite3_result_int64(ctx, result);
      } else if (typeof result === "string") {
        const buffer = new TextEncoder().encode(result);
        sqlite3_result_text(ctx, buffer, buffer.byteLength, 0n);
      } else if (result instanceof Uint8Array) {
        sqlite3_result_blob(ctx, result, result.length, -1n);
      } else {
        const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
        sqlite3_result_error(ctx, buffer, buffer.byteLength);
      }
    });
    let flags = 1;
    if (options3?.deterministic) {
      flags |= 2048;
    }
    if (options3?.directOnly) {
      flags |= 524288;
    }
    if (options3?.subtype) {
      flags |= 1048576;
    }
    if (options3?.directOnly) {
      flags |= 2097152;
    }
    const err = sqlite3_create_function(this.#handle, toCString(name), options3?.varargs ? -1 : fn.length, flags, null, cb.pointer, null, null);
    unwrap(err, this.#handle);
    this.#callbacks.add(cb);
  }
  /**
   * Creates a new user-defined aggregate function.
   */
  aggregate(name, options3) {
    if (sqlite3_aggregate_context === null || sqlite3_create_function === null) {
      throw new Error("User-defined functions are not supported by the shared library that was used.");
    }
    const contexts = /* @__PURE__ */ new Map();
    const cb = new Deno.UnsafeCallback({
      parameters: [
        "pointer",
        "i32",
        "pointer"
      ],
      result: "void"
    }, (ctx, nArgs, pArgs) => {
      const aggrCtx = sqlite3_aggregate_context(ctx, 8);
      const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
      let aggregate;
      if (contexts.has(aggrPtr)) {
        aggregate = contexts.get(aggrPtr);
      } else {
        aggregate = typeof options3.start === "function" ? options3.start() : options3.start;
        contexts.set(aggrPtr, aggregate);
      }
      const argptr = new Deno.UnsafePointerView(pArgs);
      const args = [];
      for (let i2 = 0; i2 < nArgs; i2++) {
        const arg = Deno.UnsafePointer.create(argptr.getBigUint64(i2 * 8));
        const type = sqlite3_value_type(arg);
        switch (type) {
          case SQLITE_INTEGER: {
            const value = sqlite3_value_int64(arg);
            if (value < -BIG_MAX2 || value > BIG_MAX2) {
              args.push(value);
            } else {
              args.push(Number(value));
            }
            break;
          }
          case SQLITE_FLOAT:
            args.push(sqlite3_value_double(arg));
            break;
          case SQLITE_TEXT:
            args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
            break;
          case SQLITE_BLOB:
            args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
            break;
          case SQLITE_NULL:
            args.push(null);
            break;
          default:
            throw new Error(`Unknown type: ${type}`);
        }
      }
      let result;
      try {
        result = options3.step(aggregate, ...args);
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      contexts.set(aggrPtr, result);
    });
    const cbFinal = new Deno.UnsafeCallback({
      parameters: [
        "pointer"
      ],
      result: "void"
    }, (ctx) => {
      const aggrCtx = sqlite3_aggregate_context(ctx, 0);
      const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
      const aggregate = contexts.get(aggrPtr);
      contexts.delete(aggrPtr);
      let result;
      try {
        result = options3.final ? options3.final(aggregate) : aggregate;
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      if (result === void 0 || result === null) {
        sqlite3_result_null(ctx);
      } else if (typeof result === "boolean") {
        sqlite3_result_int(ctx, result ? 1 : 0);
      } else if (typeof result === "number") {
        if (Number.isSafeInteger(result)) {
          sqlite3_result_int64(ctx, BigInt(result));
        } else sqlite3_result_double(ctx, result);
      } else if (typeof result === "bigint") {
        sqlite3_result_int64(ctx, result);
      } else if (typeof result === "string") {
        const buffer = new TextEncoder().encode(result);
        sqlite3_result_text(ctx, buffer, buffer.byteLength, 0n);
      } else if (result instanceof Uint8Array) {
        sqlite3_result_blob(ctx, result, result.length, -1n);
      } else {
        const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
        sqlite3_result_error(ctx, buffer, buffer.byteLength);
      }
    });
    let flags = 1;
    if (options3?.deterministic) {
      flags |= 2048;
    }
    if (options3?.directOnly) {
      flags |= 524288;
    }
    if (options3?.subtype) {
      flags |= 1048576;
    }
    if (options3?.directOnly) {
      flags |= 2097152;
    }
    const err = sqlite3_create_function(this.#handle, toCString(name), options3?.varargs ? -1 : options3.step.length - 1, flags, null, null, cb.pointer, cbFinal.pointer);
    unwrap(err, this.#handle);
    this.#callbacks.add(cb);
    this.#callbacks.add(cbFinal);
  }
  /**
   * Loads an SQLite extension library from the named file.
   */
  loadExtension(file2, entryPoint) {
    if (sqlite3_load_extension === null) {
      throw new Error("Extension loading is not supported by the shared library that was used.");
    }
    if (!this.enableLoadExtension) {
      throw new Error("Extension loading is not enabled");
    }
    const pzErrMsg = new BigUint64Array(1);
    const result = sqlite3_load_extension(this.#handle, toCString(file2), entryPoint ? toCString(entryPoint) : null, pzErrMsg);
    const pzErrPtr = Deno.UnsafePointer.create(pzErrMsg[0]);
    if (pzErrPtr !== null) {
      const pzErr = readCstr(pzErrPtr);
      sqlite3_free(pzErrPtr);
      throw new Error(pzErr);
    }
    unwrap(result, this.#handle);
  }
  /**
   * Closes the database connection.
   *
   * Calling this method more than once is no-op.
   */
  close() {
    if (!this.#open) return;
    for (const [stmt, db2] of STATEMENTS_TO_DB) {
      if (db2 === this.#handle) {
        sqlite3_finalize2(stmt);
        STATEMENTS_TO_DB.delete(stmt);
      }
    }
    for (const cb of this.#callbacks) {
      cb.close();
    }
    unwrap(sqlite3_close_v2(this.#handle));
    this.#open = false;
  }
  /**
   * @param dest The destination database connection.
   * @param name Destination database name. "main" for main database, "temp" for temporary database, or the name specified after the AS keyword in an ATTACH statement for an attached database.
   * @param pages The number of pages to copy. If it is negative, all remaining pages are copied (default).
   */
  backup(dest, name = "main", pages = -1) {
    const backup = sqlite3_backup_init(dest.#handle, toCString(name), this.#handle, toCString("main"));
    if (backup) {
      unwrap(sqlite3_backup_step(backup, pages));
      unwrap(sqlite3_backup_finish(backup));
    } else {
      unwrap(sqlite3_errcode(dest.#handle), dest.#handle);
    }
  }
  [_computedKey4]() {
    return `SQLite3.Database { path: ${this.path} }`;
  }
};
var controllers = /* @__PURE__ */ new WeakMap();
var getController = (db2) => {
  let controller = controllers.get(db2);
  if (!controller) {
    const shared = {
      commit: db2.prepare("COMMIT"),
      rollback: db2.prepare("ROLLBACK"),
      savepoint: db2.prepare("SAVEPOINT `	_bs3.	`"),
      release: db2.prepare("RELEASE `	_bs3.	`"),
      rollbackTo: db2.prepare("ROLLBACK TO `	_bs3.	`")
    };
    controllers.set(db2, controller = {
      default: Object.assign({
        begin: db2.prepare("BEGIN")
      }, shared),
      deferred: Object.assign({
        begin: db2.prepare("BEGIN DEFERRED")
      }, shared),
      immediate: Object.assign({
        begin: db2.prepare("BEGIN IMMEDIATE")
      }, shared),
      exclusive: Object.assign({
        begin: db2.prepare("BEGIN EXCLUSIVE")
      }, shared)
    });
  }
  return controller;
};
var wrapTransaction = (fn, db2, { begin, commit, rollback, savepoint, release, rollbackTo }) => function sqliteTransaction(...args) {
  const { apply } = Function.prototype;
  let before, after, undo;
  if (db2.inTransaction) {
    before = savepoint;
    after = release;
    undo = rollbackTo;
  } else {
    before = begin;
    after = commit;
    undo = rollback;
  }
  before.run();
  try {
    const result = apply.call(fn, this, args);
    after.run();
    return result;
  } catch (ex) {
    if (!db2.autocommit) {
      undo.run();
      if (undo !== rollback) after.run();
    }
    throw ex;
  }
};

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse8,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  flattenError: () => flattenError,
  formatError: () => formatError,
  function: () => _function,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse7,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init2(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst)) Object.defineProperty(inst, k, {
        value: _.prototype[k].bind(inst)
      });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", {
    value: name
  });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init2(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", {
    value: init2
  });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent) return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", {
    value: name
  });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig) Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert3,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert3(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v2) => typeof v2 === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v2]) => v2);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint") return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", {
          value
        });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  const set2 = false;
  Object.defineProperty(object2, key, {
    get() {
      if (!set2) {
        const value = getter();
        object2[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v2) {
      Object.defineProperty(object2, key, {
        value: v2
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path) {
  if (!path) return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      resolvedObj[keys[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
function randomString(length4 = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i2 = 0; i2 < length4; i2++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o2) {
  if (isObject(o2) === false) return false;
  const ctor = o2.constructor;
  if (ctor === void 0) return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set([
  "string",
  "number",
  "symbol"
]);
var primitiveTypes = /* @__PURE__ */ new Set([
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol",
  "undefined"
]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent) cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params) return {};
  if (typeof params === "string") return {
    error: () => params
  };
  if (params?.message !== void 0) {
    if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string") return {
    ...params,
    error: () => params.error
  };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint") return value.toString() + "n";
  if (typeof value === "string") return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [
    Number.MIN_SAFE_INTEGER,
    Number.MAX_SAFE_INTEGER
  ],
  int32: [
    -2147483648,
    2147483647
  ],
  uint32: [
    0,
    4294967295
  ],
  float32: [
    -34028234663852886e22,
    34028234663852886e22
  ],
  float64: [
    -Number.MAX_VALUE,
    Number.MAX_VALUE
  ]
};
var BIGINT_FORMAT_RANGES = {
  int64: [
    /* @__PURE__ */ BigInt("-9223372036854775808"),
    /* @__PURE__ */ BigInt("9223372036854775807")
  ],
  uint64: [
    /* @__PURE__ */ BigInt(0),
    /* @__PURE__ */ BigInt("18446744073709551615")
  ]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key]) continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = {
    ...schema._zod.def.shape
  };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key]) continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = {
        ...schema._zod.def.shape,
        ...shape
      };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = {
        ...a._zod.def.shape,
        ...b._zod.def.shape
      };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = {
    ...oldShape
  };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key]) continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = {
    ...oldShape
  };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key]) continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x3, startIndex = 0) {
  for (let i2 = startIndex; i2 < x3.issues.length; i2++) {
    if (x3.issues[i2]?.continue !== true) return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = {
    ...iss,
    path: iss.path ?? []
  };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set) return "set";
  if (input instanceof Map) return "map";
  if (input instanceof File) return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input)) return "array";
  if (typeof input === "string") return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return {
    ...iss
  };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, {
  Parent: Error
});
function flattenError(error40, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error40.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return {
    formErrors,
    fieldErrors
  };
}
function formatError(error40, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = {
    _errors: []
  };
  const processError = (error41) => {
    for (const issue2 of error41.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({
          issues
        }));
      } else if (issue2.code === "invalid_key") {
        processError({
          issues: issue2.issues
        });
      } else if (issue2.code === "invalid_element") {
        processError({
          issues: issue2.issues
        });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || {
              _errors: []
            };
          } else {
            curr[el] = curr[el] || {
              _errors: []
            };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error40);
  return fieldErrors;
}
function treeifyError(error40, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = {
    errors: []
  };
  const processError = (error41, path = []) => {
    var _a2, _b;
    for (const issue2 of error41.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({
          issues
        }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({
          issues: issue2.issues
        }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({
          issues: issue2.issues
        }, issue2.path);
      } else {
        const fullpath = [
          ...path,
          ...issue2.path
        ];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i2 = 0;
        while (i2 < fullpath.length) {
          const el = fullpath[i2];
          const terminal = i2 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = {
              errors: []
            });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = {
              errors: []
            });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i2++;
        }
      }
    }
  };
  processError(error40);
  return result;
}
function toDotPath(path) {
  const segs = [];
  for (const seg of path) {
    if (typeof seg === "number") segs.push(`[${seg}]`);
    else if (typeof seg === "symbol") segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length) segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error40) {
  const lines = [];
  const issues = [
    ...error40.issues
  ].sort((a, b) => a.path.length - b.path.length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length) lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    async: false
  }) : {
    async: false
  };
  const result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
var parse7 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    async: true
  }) : {
    async: true
  };
  let result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? {
    ..._ctx,
    async: false
  } : {
    async: false
  };
  const result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : {
    success: true,
    data: result.value
  };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    async: true
  }) : {
    async: true
  };
  let result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : {
    success: true,
    data: result.value
  };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hostname: () => hostname,
  html5Email: () => html5Email,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version4) => {
  if (!version4) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version4}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({
    precision: args.precision
  });
  const opts = [
    "Z"
  ];
  if (args.local) opts.push("");
  if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive) bag.maximum = def.value;
      else bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive) bag.minimum = def.value;
      else bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple) return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt) bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum) return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum) return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size) return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? {
        code: "too_big",
        maximum: def.size
      } : {
        code: "too_small",
        minimum: def.size
      },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 <= def.maximum) return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 >= def.minimum) return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 === def.length) return;
    const origin = getLengthableOrigin(input);
    const tooBig = length4 > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? {
        code: "too_big",
        maximum: def.length
      } : {
        code: "too_small",
        minimum: def.length
      },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern) (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      ...def.pattern ? {
        pattern: def.pattern.toString()
      } : {},
      inst,
      continue: !def.abort
    });
  });
  else (_b = inst._zod).check ?? (_b.check = () => {
  });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type)) return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this) this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, {
        execution: "sync"
      });
      arg(this, {
        execution: "async"
      });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x3) => x3);
    const minIndent = Math.min(...lines.map((x3) => x3.length - x3.trimStart().length));
    const dedented = lines.map((x3) => x3.slice(minIndent)).map((x3) => " ".repeat(this.indent * 2) + x3);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [
      ``
    ];
    const lines = [
      ...content.map((x3) => `  ${x3}`)
    ];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 0,
  patch: 5
};

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [
    ...inst._zod.def.checks ?? []
  ];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun) continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen) return;
            if (!isAborted) isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen) continue;
          if (!isAborted) isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? {
          value: r.data
        } : {
          issues: r.error?.issues
        };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? {
          value: r.data
        } : {
          issues: r.error?.issues
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [
    ...inst?._zod.bag?.patterns ?? []
  ].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce) try {
      payload.value = String(payload.value);
    } catch (_2) {
    }
    if (typeof payload.value === "string") return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v2 = versionMap[def.version];
    if (v2 === void 0) throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url2 = new URL(orig);
      const href = url2.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix) throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix) throw new Error();
      if (prefixNum < 0 || prefixNum > 128) throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "") return true;
  if (data.length % 4 !== 0) return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data)) return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3) return false;
    const [header] = tokensParts;
    if (!header) return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
    if (!parsedHeader.alg) return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) try {
      payload.value = Number(payload.value);
    } catch (_) {
    }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? {
        received
      } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) try {
      payload.value = Boolean(payload.value);
    } catch (_) {
    }
    const input = payload.value;
    if (typeof input === "boolean") return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) try {
      payload.value = BigInt(payload.value);
    } catch (_) {
    }
    if (typeof payload.value === "bigint") return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol") return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([
    void 0
  ]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined") return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([
    null
  ]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null) return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined") return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate) return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? {
        received: "Invalid Date"
      } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input) final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v2 of field.values) propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc([
      "shape",
      "payload",
      "ctx"
    ]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass) fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({
          value: input[key],
          issues: []
        }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key)) continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({
        value: input[key],
        issues: []
      }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length) return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0) return result;
        results.push(result);
      }
    }
    if (!async) return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v2] of Object.entries(pv)) {
        if (!propValues[k]) propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v2) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o2 of opts) {
      const values = o2._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o2)}"`);
      for (const v2 of values) {
        if (map2.has(v2)) {
          throw new Error(`Duplicate discriminator value "${String(v2)}"`);
        }
        map2.set(v2, o2);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [
        def.discriminator
      ],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({
      value: input,
      issues: []
    }, ctx);
    const right = def.right._zod.run({
      value: input,
      issues: []
    }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([
        left,
        right
      ]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return {
      valid: true,
      data: a
    };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return {
      valid: true,
      data: a
    };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = {
      ...a,
      ...b
    };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [
            key,
            ...sharedValue.mergeErrorPath
          ]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return {
      valid: true,
      data: newObj
    };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return {
        valid: false,
        mergeErrorPath: []
      };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [
            index,
            ...sharedValue.mergeErrorPath
          ]
        };
      }
      newArray.push(sharedValue.data);
    }
    return {
      valid: true,
      data: newArray
    };
  }
  return {
    valid: false,
    mergeErrorPath: []
  };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result)) return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [
    ...items
  ].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? {
            code: "too_big",
            maximum: items.length
          } : {
            code: "too_small",
            minimum: items.length
          }
        });
        return payload;
      }
    }
    let i2 = -1;
    for (const item of items) {
      i2++;
      if (i2 >= input.length) {
        if (i2 >= optStart) continue;
      }
      const result = item._zod.run({
        value: input[i2],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
      } else {
        handleTupleResult(result, payload, i2);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i2++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
        } else {
          handleTupleResult(result, payload, i2);
        }
      }
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({
            value: input[key],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__") continue;
        const keyResult = def.keyType._zod.run({
          value: key,
          issues: []
        }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [
              key
            ],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({
          value: input[key],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({
        value: key,
        issues: []
      }, ctx);
      const valueResult = def.valueType._zod.run({
        value,
        issues: []
      }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([
          keyResult,
          valueResult
        ]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else handleSetResult(result, payload);
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2 ? o2.toString() : String(o2)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File) return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([
      ...def.innerType._zod.values,
      void 0
    ]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([
      ...def.innerType._zod.values,
      null
    ]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null) return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v2 = def.innerType._zod.values;
    return v2 ? new Set([
      ...v2
    ].filter((x3) => x3 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({
    value: left.value,
    issues: left.issues
  }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[
          ...part._zod.traits
        ].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({
      value: inner,
      issues: []
    }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [
        ...inst._zod.def.path ?? []
      ],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params) _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  it: () => it_default,
  ja: () => ja_default,
  kh: () => kh_default,
  ko: () => ko_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  ur: () => ur_default,
  vi: () => vi_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: {
      unit: "\u062D\u0631\u0641",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    },
    file: {
      unit: "\u0628\u0627\u064A\u062A",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    },
    array: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    },
    set: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: {
      unit: "simvol",
      verb: "olmal\u0131d\u0131r"
    },
    file: {
      unit: "bayt",
      verb: "olmal\u0131d\u0131r"
    },
    array: {
      unit: "element",
      verb: "olmal\u0131d\u0131r"
    },
    set: {
      unit: "element",
      verb: "olmal\u0131d\u0131r"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with") return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes") return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex") return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: {
      unit: "car\xE0cters",
      verb: "contenir"
    },
    file: {
      unit: "bytes",
      verb: "contenir"
    },
    array: {
      unit: "elements",
      verb: "contenir"
    },
    set: {
      unit: "elements",
      verb: "contenir"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType4(issue2.input)}`;
      // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex") return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: {
      unit: "znak\u016F",
      verb: "m\xEDt"
    },
    file: {
      unit: "bajt\u016F",
      verb: "m\xEDt"
    },
    array: {
      unit: "prvk\u016F",
      verb: "m\xEDt"
    },
    set: {
      unit: "prvk\u016F",
      verb: "m\xEDt"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/de.js
var error6 = () => {
  const Sizable = {
    string: {
      unit: "Zeichen",
      verb: "zu haben"
    },
    file: {
      unit: "Bytes",
      verb: "zu haben"
    },
    array: {
      unit: "Elemente",
      verb: "zu haben"
    },
    set: {
      unit: "Elemente",
      verb: "zu haben"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with") return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes") return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex") return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error6()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error7 = () => {
  const Sizable = {
    string: {
      unit: "characters",
      verb: "to have"
    },
    file: {
      unit: "bytes",
      verb: "to have"
    },
    array: {
      unit: "items",
      verb: "to have"
    },
    set: {
      unit: "items",
      verb: "to have"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex") return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error7()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: {
      unit: "karaktrojn",
      verb: "havi"
    },
    file: {
      unit: "bajtojn",
      verb: "havi"
    },
    array: {
      unit: "elementojn",
      verb: "havi"
    },
    set: {
      unit: "elementojn",
      verb: "havi"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error8()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/es.js
var error9 = () => {
  const Sizable = {
    string: {
      unit: "caracteres",
      verb: "tener"
    },
    file: {
      unit: "bytes",
      verb: "tener"
    },
    array: {
      unit: "elementos",
      verb: "tener"
    },
    set: {
      unit: "elementos",
      verb: "tener"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${issue2.expected}, recibido ${parsedType4(issue2.input)}`;
      // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex") return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error9()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/fa.js
var error10 = () => {
  const Sizable = {
    string: {
      unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    },
    file: {
      unit: "\u0628\u0627\u06CC\u062A",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    },
    array: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    },
    set: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType4(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error10()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/fi.js
var error11 = () => {
  const Sizable = {
    string: {
      unit: "merkki\xE4",
      subject: "merkkijonon"
    },
    file: {
      unit: "tavua",
      subject: "tiedoston"
    },
    array: {
      unit: "alkiota",
      subject: "listan"
    },
    set: {
      unit: "alkiota",
      subject: "joukon"
    },
    number: {
      unit: "",
      subject: "luvun"
    },
    bigint: {
      unit: "",
      subject: "suuren kokonaisluvun"
    },
    int: {
      unit: "",
      subject: "kokonaisluvun"
    },
    date: {
      unit: "",
      subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error11()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/fr.js
var error12 = () => {
  const Sizable = {
    string: {
      unit: "caract\xE8res",
      verb: "avoir"
    },
    file: {
      unit: "octets",
      verb: "avoir"
    },
    array: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    },
    set: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex") return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error12()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/fr-CA.js
var error13 = () => {
  const Sizable = {
    string: {
      unit: "caract\xE8res",
      verb: "avoir"
    },
    file: {
      unit: "octets",
      verb: "avoir"
    },
    array: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    },
    set: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex") return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error13()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/he.js
var error14 = () => {
  const Sizable = {
    string: {
      unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    },
    file: {
      unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    },
    array: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    },
    set: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType4(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error14()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/hu.js
var error15 = () => {
  const Sizable = {
    string: {
      unit: "karakter",
      verb: "legyen"
    },
    file: {
      unit: "byte",
      verb: "legyen"
    },
    array: {
      unit: "elem",
      verb: "legyen"
    },
    set: {
      unit: "elem",
      verb: "legyen"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType4(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with") return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes") return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex") return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error15()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/id.js
var error16 = () => {
  const Sizable = {
    string: {
      unit: "karakter",
      verb: "memiliki"
    },
    file: {
      unit: "byte",
      verb: "memiliki"
    },
    array: {
      unit: "item",
      verb: "memiliki"
    },
    set: {
      unit: "item",
      verb: "memiliki"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes") return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex") return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error16()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/it.js
var error17 = () => {
  const Sizable = {
    string: {
      unit: "caratteri",
      verb: "avere"
    },
    file: {
      unit: "byte",
      verb: "avere"
    },
    array: {
      unit: "elementi",
      verb: "avere"
    },
    set: {
      unit: "elementi",
      verb: "avere"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error17()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ja.js
var error18 = () => {
  const Sizable = {
    string: {
      unit: "\u6587\u5B57",
      verb: "\u3067\u3042\u308B"
    },
    file: {
      unit: "\u30D0\u30A4\u30C8",
      verb: "\u3067\u3042\u308B"
    },
    array: {
      unit: "\u8981\u7D20",
      verb: "\u3067\u3042\u308B"
    },
    set: {
      unit: "\u8981\u7D20",
      verb: "\u3067\u3042\u308B"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType4(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error18()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/kh.js
var error19 = () => {
  const Sizable = {
    string: {
      unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    },
    file: {
      unit: "\u1794\u17C3",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    },
    array: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    },
    set: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function kh_default() {
  return {
    localeError: error19()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ko.js
var error20 = () => {
  const Sizable = {
    string: {
      unit: "\uBB38\uC790",
      verb: "to have"
    },
    file: {
      unit: "\uBC14\uC774\uD2B8",
      verb: "to have"
    },
    array: {
      unit: "\uAC1C",
      verb: "to have"
    },
    set: {
      unit: "\uAC1C",
      verb: "to have"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType4(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with") return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes") return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex") return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error20()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/mk.js
var error21 = () => {
  const Sizable = {
    string: {
      unit: "\u0437\u043D\u0430\u0446\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    },
    file: {
      unit: "\u0431\u0430\u0458\u0442\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    },
    array: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    },
    set: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType4(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error21()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ms.js
var error22 = () => {
  const Sizable = {
    string: {
      unit: "aksara",
      verb: "mempunyai"
    },
    file: {
      unit: "bait",
      verb: "mempunyai"
    },
    array: {
      unit: "elemen",
      verb: "mempunyai"
    },
    set: {
      unit: "elemen",
      verb: "mempunyai"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes") return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error22()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/nl.js
var error23 = () => {
  const Sizable = {
    string: {
      unit: "tekens"
    },
    file: {
      unit: "bytes"
    },
    array: {
      unit: "elementen"
    },
    set: {
      unit: "elementen"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with") return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes") return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error23()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/no.js
var error24 = () => {
  const Sizable = {
    string: {
      unit: "tegn",
      verb: "\xE5 ha"
    },
    file: {
      unit: "bytes",
      verb: "\xE5 ha"
    },
    array: {
      unit: "elementer",
      verb: "\xE5 inneholde"
    },
    set: {
      unit: "elementer",
      verb: "\xE5 inneholde"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex") return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error24()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ota.js
var error25 = () => {
  const Sizable = {
    string: {
      unit: "harf",
      verb: "olmal\u0131d\u0131r"
    },
    file: {
      unit: "bayt",
      verb: "olmal\u0131d\u0131r"
    },
    array: {
      unit: "unsur",
      verb: "olmal\u0131d\u0131r"
    },
    set: {
      unit: "unsur",
      verb: "olmal\u0131d\u0131r"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType4(issue2.input)}`;
      // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with") return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes") return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex") return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error25()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ps.js
var error26 = () => {
  const Sizable = {
    string: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A"
    },
    file: {
      unit: "\u0628\u0627\u06CC\u067C\u0633",
      verb: "\u0648\u0644\u0631\u064A"
    },
    array: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A"
    },
    set: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType4(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error26()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/pl.js
var error27 = () => {
  const Sizable = {
    string: {
      unit: "znak\xF3w",
      verb: "mie\u0107"
    },
    file: {
      unit: "bajt\xF3w",
      verb: "mie\u0107"
    },
    array: {
      unit: "element\xF3w",
      verb: "mie\u0107"
    },
    set: {
      unit: "element\xF3w",
      verb: "mie\u0107"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error27()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/pt.js
var error28 = () => {
  const Sizable = {
    string: {
      unit: "caracteres",
      verb: "ter"
    },
    file: {
      unit: "bytes",
      verb: "ter"
    },
    array: {
      unit: "itens",
      verb: "ter"
    },
    set: {
      unit: "itens",
      verb: "ter"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex") return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error28()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error29 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error29()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/sl.js
var error30 = () => {
  const Sizable = {
    string: {
      unit: "znakov",
      verb: "imeti"
    },
    file: {
      unit: "bajtov",
      verb: "imeti"
    },
    array: {
      unit: "elementov",
      verb: "imeti"
    },
    set: {
      unit: "elementov",
      verb: "imeti"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error30()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/sv.js
var error31 = () => {
  const Sizable = {
    string: {
      unit: "tecken",
      verb: "att ha"
    },
    file: {
      unit: "bytes",
      verb: "att ha"
    },
    array: {
      unit: "objekt",
      verb: "att inneh\xE5lla"
    },
    set: {
      unit: "objekt",
      verb: "att inneh\xE5lla"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex") return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error31()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ta.js
var error32 = () => {
  const Sizable = {
    string: {
      unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    },
    file: {
      unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    },
    array: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    },
    set: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error32()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/th.js
var error33 = () => {
  const Sizable = {
    string: {
      unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    },
    file: {
      unit: "\u0E44\u0E1A\u0E15\u0E4C",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    },
    array: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    },
    set: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex") return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error33()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/tr.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error34 = () => {
  const Sizable = {
    string: {
      unit: "karakter",
      verb: "olmal\u0131"
    },
    file: {
      unit: "bayt",
      verb: "olmal\u0131"
    },
    array: {
      unit: "\xF6\u011Fe",
      verb: "olmal\u0131"
    },
    set: {
      unit: "\xF6\u011Fe",
      verb: "olmal\u0131"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with") return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes") return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex") return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error34()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ua.js
var error35 = () => {
  const Sizable = {
    string: {
      unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    },
    file: {
      unit: "\u0431\u0430\u0439\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    },
    array: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    },
    set: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType4(issue2.input)}`;
      // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function ua_default() {
  return {
    localeError: error35()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/ur.js
var error36 = () => {
  const Sizable = {
    string: {
      unit: "\u062D\u0631\u0648\u0641",
      verb: "\u06C1\u0648\u0646\u0627"
    },
    file: {
      unit: "\u0628\u0627\u0626\u0679\u0633",
      verb: "\u06C1\u0648\u0646\u0627"
    },
    array: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627"
    },
    set: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType4(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with") return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes") return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex") return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error36()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/vi.js
var error37 = () => {
  const Sizable = {
    string: {
      unit: "k\xFD t\u1EF1",
      verb: "c\xF3"
    },
    file: {
      unit: "byte",
      verb: "c\xF3"
    },
    array: {
      unit: "ph\u1EA7n t\u1EED",
      verb: "c\xF3"
    },
    set: {
      unit: "ph\u1EA7n t\u1EED",
      verb: "c\xF3"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error37()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/zh-CN.js
var error38 = () => {
  const Sizable = {
    string: {
      unit: "\u5B57\u7B26",
      verb: "\u5305\u542B"
    },
    file: {
      unit: "\u5B57\u8282",
      verb: "\u5305\u542B"
    },
    array: {
      unit: "\u9879",
      verb: "\u5305\u542B"
    },
    set: {
      unit: "\u9879",
      verb: "\u5305\u542B"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error38()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/locales/zh-TW.js
var error39 = () => {
  const Sizable = {
    string: {
      unit: "\u5B57\u5143",
      verb: "\u64C1\u6709"
    },
    file: {
      unit: "\u4F4D\u5143\u7D44",
      verb: "\u64C1\u6709"
    },
    array: {
      unit: "\u9805\u76EE",
      verb: "\u64C1\u6709"
    },
    set: {
      unit: "\u9805\u76EE",
      verb: "\u64C1\u6709"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with") return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes") return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error39()
  };
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = {
        ...this.get(p) ?? {}
      };
      delete pm.id;
      return {
        ...pm,
        ...this._map.get(schema)
      };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = /* @__PURE__ */ registry();

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length4, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length: length4
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options3, params) {
  return new Class2({
    type: "union",
    options: options3,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options3, params) {
  return new Class2({
    type: "union",
    options: options3,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [
    v2,
    v2
  ])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [
      value
    ],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? [
    "true",
    "1",
    "yes",
    "on",
    "y",
    "enabled"
  ];
  let falsyArray = params.falsy ?? [
    "false",
    "0",
    "no",
    "off",
    "n",
    "disabled"
  ];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
    falsyArray = falsyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive") data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [
            ...truthySet,
            ...falsySet
          ],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({
      type: "string",
      error: params.error
    }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format10, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format: format10,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/function.js
var $ZodFunction = class {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (...args) => {
      const parsedArgs = this._def.input ? parse7(this._def.input, args, void 0, {
        callee: impl
      }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse7(this._def.output, output, void 0, {
        callee: impl
      }) : output;
    };
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, {
        callee: impl
      }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output, void 0, {
        callee: impl
      }) : output;
    };
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output
    });
  }
};
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = {
    path: [],
    schemaPath: []
  }) {
    var _a2;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = {
      schema: {},
      count: 1,
      cycle: void 0,
      path: _params.path
    };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [
          ..._params.schemaPath,
          schema
        ],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format: format10, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number") json2.minLength = minimum;
            if (typeof maximum === "number") json2.maxLength = maximum;
            if (format10) {
              json2.format = formatMap[format10] ?? format10;
              if (json2.format === "") delete json2.format;
            }
            if (contentEncoding) json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [
                ...patterns
              ];
              if (regexes.length === 1) json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? {
                      type: "string"
                    } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format: format10, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format10 === "string" && format10.includes("int")) json2.type = "integer";
            else json2.type = "number";
            if (typeof exclusiveMinimum === "number") json2.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum) delete json2.minimum;
                else delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") json2.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum) delete json2.maximum;
                else delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number") json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number") json2.minItems = minimum;
            if (typeof maximum === "number") json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, {
              ...params,
              path: [
                ...params.path,
                "items"
              ]
            });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [
                  ...params.path,
                  "properties",
                  key
                ]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([
              ...allKeys
            ].filter((key) => {
              const v2 = def.shape[key]._zod;
              if (this.io === "input") {
                return v2.optin === void 0;
              } else {
                return v2.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output") json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [
                  ...params.path,
                  "additionalProperties"
                ]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            json2.anyOf = def.options.map((x3, i2) => this.process(x3, {
              ...params,
              path: [
                ...params.path,
                "anyOf",
                i2
              ]
            }));
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [
                ...params.path,
                "allOf",
                0
              ]
            });
            const b = this.process(def.right, {
              ...params,
              path: [
                ...params.path,
                "allOf",
                1
              ]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [
                a
              ],
              ...isSimpleIntersection(b) ? b.allOf : [
                b
              ]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixItems = def.items.map((x3, i2) => this.process(x3, {
              ...params,
              path: [
                ...params.path,
                "prefixItems",
                i2
              ]
            }));
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
            } else {
              json2.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [
                  ...params.path,
                  "items"
                ]
              });
              if (this.target === "draft-2020-12") {
                json2.items = rest;
              } else {
                json2.additionalItems = rest;
              }
            }
            if (def.rest) {
              json2.items = this.process(def.rest, {
                ...params,
                path: [
                  ...params.path,
                  "items"
                ]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number") json2.minItems = minimum;
            if (typeof maximum === "number") json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            json2.propertyNames = this.process(def.keyType, {
              ...params,
              path: [
                ...params.path,
                "propertyNames"
              ]
            });
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [
                ...params.path,
                "additionalProperties"
              ]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v2) => typeof v2 === "number")) json2.type = "number";
            if (values.every((v2) => typeof v2 === "string")) json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              json2.const = val;
            } else {
              if (vals.every((v2) => typeof v2 === "number")) json2.type = "number";
              if (vals.every((v2) => typeof v2 === "string")) json2.type = "string";
              if (vals.every((v2) => typeof v2 === "boolean")) json2.type = "string";
              if (vals.every((v2) => v2 === null)) json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0) file2.minLength = minimum;
            if (maximum !== void 0) file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m3) => {
                  const mFile = {
                    ...file2,
                    contentMediaType: m3
                  };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [
              inner,
              {
                type: "null"
              }
            ];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern) throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta) Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault) (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return {
            ref: uriGenerator(externalId)
          };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return {
          defId: id,
          ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}`
        };
      }
      if (entry[1] === root) {
        return {
          ref: "#"
        };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return {
        defId,
        ref: defUriPrefix + defId
      };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = {
        ...seen.schema
      };
      if (defId) seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = {
        ...schema2
      };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent) this.override({
        zodSchema,
        jsonSchema: schema2,
        path: seen.path ?? []
      });
    };
    for (const entry of [
      ...this.seen.entries()
    ].reverse()) {
      flattenRef(entry[0], {
        target: this.target
      });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id) throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return {
      schemas
    };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? {
    seen: /* @__PURE__ */ new Set()
  };
  if (ctx.seen.has(_schema)) return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx)) return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx)) return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx)) return true;
      }
      if (def.rest && isTransforming(def.rest, ctx)) return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/parse.js
var parse8 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", {
    value: def
  });
  inst.check = (...checks) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? {
          _zod: {
            check: ch,
            def: {
              check: "custom"
            },
            onattach: []
          }
        } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse8(inst, data, params, {
    callee: inst.parse
  });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, {
    callee: inst.parseAsync
  });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([
    inst,
    arg
  ]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, {
      description
    });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format10, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format10, fnOrRegex, _params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return literal(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({
    ...inst._zod.def,
    catchall
  });
  inst.passthrough = () => inst.clone({
    ...inst._zod.def,
    catchall: unknown()
  });
  inst.loose = () => inst.clone({
    ...inst._zod.def,
    catchall: unknown()
  });
  inst.strict = () => inst.clone({
    ...inst._zod.def,
    catchall: never()
  });
  inst.strip = () => inst.clone({
    ...inst._zod.def,
    catchall: void 0
  });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", {
        ...shape
      });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", {
        ...shape
      });
      return this.shape;
    },
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", {
        ...shape
      });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options3, params) {
  return new ZodUnion({
    type: "union",
    options: options3,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options3, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options: options3,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([
      keyType,
      never()
    ]),
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = {
      ...def.entries
    };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [
    v2,
    v2
  ])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [
      value
    ],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [
    types
  ], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([
      string2(params),
      number2(),
      boolean2(),
      _null3(),
      array(jsonSchema),
      record(string2(), jsonSchema)
    ]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/.deno/zod@4.0.5/node_modules/zod/v4/classic/external.js
config(en_default());

// build/serve/ownerSizeTotalWorker.js-tmp
var import_npm_tweetnacl_1_0 = __toESM(require_nacl_fast());

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/vendor/base-x.js
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x3 = ALPHABET.charAt(i2);
    var xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode9(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode15(string4) {
    var buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode9,
    decodeUnsafe,
    decode: decode15
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") return o2;
  if (o2 instanceof ArrayBuffer) return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js
var Encoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || {
      [
        /** @type API.UnibaseDecoder<L> */
        left.prefix
      ]: left
    },
    ...right.decoders || {
      [
        /** @type API.UnibaseDecoder<R> */
        right.prefix
      ]: right
    }
  }
);
var Codec = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name, prefix, encode: encode9, decode: decode15 }) => new Codec(name, prefix, encode9, decode15);
var baseX = ({ prefix, name, alphabet: alphabet5 }) => {
  const { encode: encode9, decode: decode15 } = base_x_default(alphabet5, name);
  return from({
    prefix,
    name,
    encode: encode9,
    /**
     * @param {string} text
     */
    decode: (text) => coerce(decode15(text))
  });
};
var decode3 = (string4, alphabet5, bitsPerChar, name) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet5.length; ++i2) {
    codes[alphabet5[i2]] = i2;
  }
  let end = string4.length;
  while (string4[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string4[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode3 = (data, alphabet5, bitsPerChar) => {
  const pad = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet5[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name, prefix, bitsPerChar, alphabet: alphabet5 }) => {
  return from({
    prefix,
    name,
    encode(input) {
      return encode3(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode3(input, alphabet5, bitsPerChar, name);
    }
  });
};

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.deno/@multiformats+blake2@1.0.13/node_modules/@multiformats/blake2/esm/blake2b.js
var blake2b_exports = {};
__export(blake2b_exports, {
  blake2b104: () => blake2b104,
  blake2b112: () => blake2b112,
  blake2b120: () => blake2b120,
  blake2b128: () => blake2b128,
  blake2b136: () => blake2b136,
  blake2b144: () => blake2b144,
  blake2b152: () => blake2b152,
  blake2b16: () => blake2b16,
  blake2b160: () => blake2b160,
  blake2b168: () => blake2b168,
  blake2b176: () => blake2b176,
  blake2b184: () => blake2b184,
  blake2b192: () => blake2b192,
  blake2b200: () => blake2b200,
  blake2b208: () => blake2b208,
  blake2b216: () => blake2b216,
  blake2b224: () => blake2b224,
  blake2b232: () => blake2b232,
  blake2b24: () => blake2b24,
  blake2b240: () => blake2b240,
  blake2b248: () => blake2b248,
  blake2b256: () => blake2b256,
  blake2b264: () => blake2b264,
  blake2b272: () => blake2b272,
  blake2b280: () => blake2b280,
  blake2b288: () => blake2b288,
  blake2b296: () => blake2b296,
  blake2b304: () => blake2b304,
  blake2b312: () => blake2b312,
  blake2b32: () => blake2b32,
  blake2b320: () => blake2b320,
  blake2b328: () => blake2b328,
  blake2b336: () => blake2b336,
  blake2b344: () => blake2b344,
  blake2b352: () => blake2b352,
  blake2b360: () => blake2b360,
  blake2b368: () => blake2b368,
  blake2b376: () => blake2b376,
  blake2b384: () => blake2b384,
  blake2b392: () => blake2b392,
  blake2b40: () => blake2b40,
  blake2b400: () => blake2b400,
  blake2b408: () => blake2b408,
  blake2b416: () => blake2b416,
  blake2b424: () => blake2b424,
  blake2b432: () => blake2b432,
  blake2b440: () => blake2b440,
  blake2b448: () => blake2b448,
  blake2b456: () => blake2b456,
  blake2b464: () => blake2b464,
  blake2b472: () => blake2b472,
  blake2b48: () => blake2b48,
  blake2b480: () => blake2b480,
  blake2b488: () => blake2b488,
  blake2b496: () => blake2b496,
  blake2b504: () => blake2b504,
  blake2b512: () => blake2b512,
  blake2b56: () => blake2b56,
  blake2b64: () => blake2b64,
  blake2b72: () => blake2b72,
  blake2b8: () => blake2b8,
  blake2b80: () => blake2b80,
  blake2b88: () => blake2b88,
  blake2b96: () => blake2b96
});
var import_blakejs = __toESM(require_blakejs());

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce2,
  empty: () => empty2,
  equals: () => equals2,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty2 = new Uint8Array(0);
var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
var fromHex = (hex) => {
  const hexes = hex.match(/../g);
  return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty2;
};
var equals2 = (aa, bb) => {
  if (aa === bb) return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") return o2;
  if (o2 instanceof ArrayBuffer) return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var isBinary = (o2) => o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b) => new TextDecoder().decode(b);

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode4;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
var decode4 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode4,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode5 = (data, offset = 0) => {
  const code3 = varint_default.decode(data, offset);
  return [
    code3,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int2, target, offset = 0) => {
  varint_default.encode(int2, target, offset);
  return target;
};
var encodingLength = (int2) => {
  return varint_default.encodingLength(int2);
};

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code3, digest) => {
  const size = digest.byteLength;
  const sizeOffset = encodingLength(code3);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code3, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code3, size, digest, bytes);
};
var decode6 = (multihash) => {
  const bytes = coerce2(multihash);
  const [code3, sizeOffset] = decode5(bytes);
  const [size, digestOffset] = decode5(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code3, size, digest, bytes);
};
var equals3 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals2(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code3, size, digest, bytes) {
    this.code = code3;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
};

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name, code: code3, encode: encode9 }) => new Hasher(name, code3, encode9);
var Hasher = class {
  constructor(name, code3, encode9) {
    this.name = name;
    this.code = code3;
    this.encode = encode9;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest) => create(this.code, digest));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base2(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x3 = ALPHABET.charAt(i2);
    var xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode9(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode15(string4) {
    var buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode9,
    decodeUnsafe,
    decode: decode15
  };
}
var src2 = base2;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder2 = class {
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder2({
  ...left.decoders || {
    [left.prefix]: left
  },
  ...right.decoders || {
    [right.prefix]: right
  }
});
var Codec2 = class {
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name, prefix, baseEncode);
    this.decoder = new Decoder2(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from3 = ({ name, prefix, encode: encode9, decode: decode15 }) => new Codec2(name, prefix, encode9, decode15);
var baseX2 = ({ prefix, name, alphabet: alphabet5 }) => {
  const { encode: encode9, decode: decode15 } = base_x_default2(alphabet5, name);
  return from3({
    prefix,
    name,
    encode: encode9,
    decode: (text) => coerce2(decode15(text))
  });
};
var decode7 = (string4, alphabet5, bitsPerChar, name) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet5.length; ++i2) {
    codes[alphabet5[i2]] = i2;
  }
  let end = string4.length;
  while (string4[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string4[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode5 = (data, alphabet5, bitsPerChar) => {
  const pad = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet5[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46482 = ({ name, prefix, bitsPerChar, alphabet: alphabet5 }) => {
  return from3({
    prefix,
    name,
    encode(input) {
      return encode5(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode7(input, alphabet5, bitsPerChar, name);
    }
  });
};

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.deno/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version4, code3, multihash, bytes) {
    this.code = code3;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden2,
      byteLength: hidden2,
      code: readonly2,
      version: readonly2,
      multihash: readonly2,
      bytes: readonly2,
      _baseCache: hidden2,
      asCID: hidden2
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code3, multihash } = this;
        if (code3 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code3, digest } = this.multihash;
        const multihash = create(code3, digest);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals3(this.multihash, other.multihash);
  }
  toString(base4) {
    const { bytes, version: version4, _baseCache } = this;
    switch (version4) {
      case 0:
        return toStringV0(bytes, _baseCache, base4 || base58btc2.encoder);
      default:
        return toStringV1(bytes, _baseCache, base4 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version4, code: code3, multihash, bytes } = value;
      return new _CID(version4, code3, multihash, bytes || encodeCID(version4, code3, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version4, multihash, code: code3 } = value;
      const digest = decode6(multihash);
      return _CID.create(version4, code3, digest);
    } else {
      return null;
    }
  }
  static create(version4, code3, digest) {
    if (typeof code3 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version4) {
      case 0: {
        if (code3 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version4, code3, digest, digest.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version4, code3, digest.bytes);
        return new _CID(version4, code3, digest, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest) {
    return _CID.create(0, DAG_PB_CODE, digest);
  }
  static createV1(code3, digest) {
    return _CID.create(1, code3, digest);
  }
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length4] = decode5(initialBytes.subarray(offset));
      offset += length4;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else if (version4 === 1) {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version4,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base4) {
    const [prefix, bytes] = parseCIDtoBytes(source, base4);
    const cid = _CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base4) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base4 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base4 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base4 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base4.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache3, base4) => {
  const { prefix } = base4;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache3, base4) => {
  const { prefix } = base4;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version4, code3, multihash) => {
  const codeOffset = encodingLength(version4);
  const hashOffset = codeOffset + encodingLength(code3);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version4, bytes, 0);
  encodeTo(code3, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly2 = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden2 = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version2 = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version2)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/.deno/@multiformats+blake2@1.0.13/node_modules/@multiformats/blake2/esm/blake2b.js
var { blake2b } = import_blakejs.default;
var blake2b8 = from2({
  name: "blake2b-8",
  code: 45569,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 1))
});
var blake2b16 = from2({
  name: "blake2b-16",
  code: 45570,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 2))
});
var blake2b24 = from2({
  name: "blake2b-24",
  code: 45571,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 3))
});
var blake2b32 = from2({
  name: "blake2b-32",
  code: 45572,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 4))
});
var blake2b40 = from2({
  name: "blake2b-40",
  code: 45573,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 5))
});
var blake2b48 = from2({
  name: "blake2b-48",
  code: 45574,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 6))
});
var blake2b56 = from2({
  name: "blake2b-56",
  code: 45575,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 7))
});
var blake2b64 = from2({
  name: "blake2b-64",
  code: 45576,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 8))
});
var blake2b72 = from2({
  name: "blake2b-72",
  code: 45577,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 9))
});
var blake2b80 = from2({
  name: "blake2b-80",
  code: 45578,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 10))
});
var blake2b88 = from2({
  name: "blake2b-88",
  code: 45579,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 11))
});
var blake2b96 = from2({
  name: "blake2b-96",
  code: 45580,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 12))
});
var blake2b104 = from2({
  name: "blake2b-104",
  code: 45581,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 13))
});
var blake2b112 = from2({
  name: "blake2b-112",
  code: 45582,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 14))
});
var blake2b120 = from2({
  name: "blake2b-120",
  code: 45583,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 15))
});
var blake2b128 = from2({
  name: "blake2b-128",
  code: 45584,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 16))
});
var blake2b136 = from2({
  name: "blake2b-136",
  code: 45585,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 17))
});
var blake2b144 = from2({
  name: "blake2b-144",
  code: 45586,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 18))
});
var blake2b152 = from2({
  name: "blake2b-152",
  code: 45587,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 19))
});
var blake2b160 = from2({
  name: "blake2b-160",
  code: 45588,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 20))
});
var blake2b168 = from2({
  name: "blake2b-168",
  code: 45589,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 21))
});
var blake2b176 = from2({
  name: "blake2b-176",
  code: 45590,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 22))
});
var blake2b184 = from2({
  name: "blake2b-184",
  code: 45591,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 23))
});
var blake2b192 = from2({
  name: "blake2b-192",
  code: 45592,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 24))
});
var blake2b200 = from2({
  name: "blake2b-200",
  code: 45593,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 25))
});
var blake2b208 = from2({
  name: "blake2b-208",
  code: 45594,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 26))
});
var blake2b216 = from2({
  name: "blake2b-216",
  code: 45595,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 27))
});
var blake2b224 = from2({
  name: "blake2b-224",
  code: 45596,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 28))
});
var blake2b232 = from2({
  name: "blake2b-232",
  code: 45597,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 29))
});
var blake2b240 = from2({
  name: "blake2b-240",
  code: 45598,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 30))
});
var blake2b248 = from2({
  name: "blake2b-248",
  code: 45599,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 31))
});
var blake2b256 = from2({
  name: "blake2b-256",
  code: 45600,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 32))
});
var blake2b264 = from2({
  name: "blake2b-264",
  code: 45601,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 33))
});
var blake2b272 = from2({
  name: "blake2b-272",
  code: 45602,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 34))
});
var blake2b280 = from2({
  name: "blake2b-280",
  code: 45603,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 35))
});
var blake2b288 = from2({
  name: "blake2b-288",
  code: 45604,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 36))
});
var blake2b296 = from2({
  name: "blake2b-296",
  code: 45605,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 37))
});
var blake2b304 = from2({
  name: "blake2b-304",
  code: 45606,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 38))
});
var blake2b312 = from2({
  name: "blake2b-312",
  code: 45607,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 39))
});
var blake2b320 = from2({
  name: "blake2b-320",
  code: 45608,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 40))
});
var blake2b328 = from2({
  name: "blake2b-328",
  code: 45609,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 41))
});
var blake2b336 = from2({
  name: "blake2b-336",
  code: 45610,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 42))
});
var blake2b344 = from2({
  name: "blake2b-344",
  code: 45611,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 43))
});
var blake2b352 = from2({
  name: "blake2b-352",
  code: 45612,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 44))
});
var blake2b360 = from2({
  name: "blake2b-360",
  code: 45613,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 45))
});
var blake2b368 = from2({
  name: "blake2b-368",
  code: 45614,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 46))
});
var blake2b376 = from2({
  name: "blake2b-376",
  code: 45615,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 47))
});
var blake2b384 = from2({
  name: "blake2b-384",
  code: 45616,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 48))
});
var blake2b392 = from2({
  name: "blake2b-392",
  code: 45617,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 49))
});
var blake2b400 = from2({
  name: "blake2b-400",
  code: 45618,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 50))
});
var blake2b408 = from2({
  name: "blake2b-408",
  code: 45619,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 51))
});
var blake2b416 = from2({
  name: "blake2b-416",
  code: 45620,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 52))
});
var blake2b424 = from2({
  name: "blake2b-424",
  code: 45621,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 53))
});
var blake2b432 = from2({
  name: "blake2b-432",
  code: 45622,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 54))
});
var blake2b440 = from2({
  name: "blake2b-440",
  code: 45623,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 55))
});
var blake2b448 = from2({
  name: "blake2b-448",
  code: 45624,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 56))
});
var blake2b456 = from2({
  name: "blake2b-456",
  code: 45625,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 57))
});
var blake2b464 = from2({
  name: "blake2b-464",
  code: 45626,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 58))
});
var blake2b472 = from2({
  name: "blake2b-472",
  code: 45627,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 59))
});
var blake2b480 = from2({
  name: "blake2b-480",
  code: 45628,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 60))
});
var blake2b488 = from2({
  name: "blake2b-488",
  code: 45629,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 61))
});
var blake2b496 = from2({
  name: "blake2b-496",
  code: 45630,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 62))
});
var blake2b504 = from2({
  name: "blake2b-504",
  code: 45631,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 63))
});
var blake2b512 = from2({
  name: "blake2b-512",
  code: 45632,
  encode: (input) => bytes_exports.coerce(blake2b(input, void 0, 64))
});

// node_modules/.deno/@multiformats+blake2@1.0.13/node_modules/@multiformats/blake2/esm/blake2s.js
var blake2s_exports = {};
__export(blake2s_exports, {
  blake2s104: () => blake2s104,
  blake2s112: () => blake2s112,
  blake2s120: () => blake2s120,
  blake2s128: () => blake2s128,
  blake2s136: () => blake2s136,
  blake2s144: () => blake2s144,
  blake2s152: () => blake2s152,
  blake2s16: () => blake2s16,
  blake2s160: () => blake2s160,
  blake2s168: () => blake2s168,
  blake2s176: () => blake2s176,
  blake2s184: () => blake2s184,
  blake2s192: () => blake2s192,
  blake2s200: () => blake2s200,
  blake2s208: () => blake2s208,
  blake2s216: () => blake2s216,
  blake2s224: () => blake2s224,
  blake2s232: () => blake2s232,
  blake2s24: () => blake2s24,
  blake2s240: () => blake2s240,
  blake2s248: () => blake2s248,
  blake2s256: () => blake2s256,
  blake2s32: () => blake2s32,
  blake2s40: () => blake2s40,
  blake2s48: () => blake2s48,
  blake2s56: () => blake2s56,
  blake2s64: () => blake2s64,
  blake2s72: () => blake2s72,
  blake2s8: () => blake2s8,
  blake2s80: () => blake2s80,
  blake2s88: () => blake2s88,
  blake2s96: () => blake2s96
});
var import_blakejs2 = __toESM(require_blakejs());
var { blake2s } = import_blakejs2.default;
var blake2s8 = from2({
  name: "blake2s-8",
  code: 45633,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 1))
});
var blake2s16 = from2({
  name: "blake2s-16",
  code: 45634,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 2))
});
var blake2s24 = from2({
  name: "blake2s-24",
  code: 45635,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 3))
});
var blake2s32 = from2({
  name: "blake2s-32",
  code: 45636,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 4))
});
var blake2s40 = from2({
  name: "blake2s-40",
  code: 45637,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 5))
});
var blake2s48 = from2({
  name: "blake2s-48",
  code: 45638,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 6))
});
var blake2s56 = from2({
  name: "blake2s-56",
  code: 45639,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 7))
});
var blake2s64 = from2({
  name: "blake2s-64",
  code: 45640,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 8))
});
var blake2s72 = from2({
  name: "blake2s-72",
  code: 45641,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 9))
});
var blake2s80 = from2({
  name: "blake2s-80",
  code: 45642,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 10))
});
var blake2s88 = from2({
  name: "blake2s-88",
  code: 45643,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 11))
});
var blake2s96 = from2({
  name: "blake2s-96",
  code: 45644,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 12))
});
var blake2s104 = from2({
  name: "blake2s-104",
  code: 45645,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 13))
});
var blake2s112 = from2({
  name: "blake2s-112",
  code: 45646,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 14))
});
var blake2s120 = from2({
  name: "blake2s-120",
  code: 45647,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 15))
});
var blake2s128 = from2({
  name: "blake2s-128",
  code: 45648,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 16))
});
var blake2s136 = from2({
  name: "blake2s-136",
  code: 45649,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 17))
});
var blake2s144 = from2({
  name: "blake2s-144",
  code: 45650,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 18))
});
var blake2s152 = from2({
  name: "blake2s-152",
  code: 45651,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 19))
});
var blake2s160 = from2({
  name: "blake2s-160",
  code: 45652,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 20))
});
var blake2s168 = from2({
  name: "blake2s-168",
  code: 45653,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 21))
});
var blake2s176 = from2({
  name: "blake2s-176",
  code: 45654,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 22))
});
var blake2s184 = from2({
  name: "blake2s-184",
  code: 45655,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 23))
});
var blake2s192 = from2({
  name: "blake2s-192",
  code: 45656,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 24))
});
var blake2s200 = from2({
  name: "blake2s-200",
  code: 45657,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 25))
});
var blake2s208 = from2({
  name: "blake2s-208",
  code: 45658,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 26))
});
var blake2s216 = from2({
  name: "blake2s-216",
  code: 45659,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 27))
});
var blake2s224 = from2({
  name: "blake2s-224",
  code: 45660,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 28))
});
var blake2s232 = from2({
  name: "blake2s-232",
  code: 45661,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 29))
});
var blake2s240 = from2({
  name: "blake2s-240",
  code: 45662,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 30))
});
var blake2s248 = from2({
  name: "blake2s-248",
  code: 45663,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 31))
});
var blake2s256 = from2({
  name: "blake2s-256",
  code: 45664,
  encode: (input) => bytes_exports.coerce(blake2s(input, void 0, 32))
});

// node_modules/.deno/@multiformats+blake2@1.0.13/node_modules/@multiformats/blake2/esm/blake2.js
var blake2_default = {
  blake2b: blake2b_exports,
  blake2s: blake2s_exports
};

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/cid.js
var cid_exports = {};
__export(cid_exports, {
  CID: () => CID2,
  format: () => format8,
  fromJSON: () => fromJSON,
  toJSON: () => toJSON
});

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/vendor/varint.js
var encode_12 = encode6;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode6(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode6.bytes = offset - oldOffset + 1;
  return out;
}
var decode8 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode8,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/varint.js
var decode9 = (data, offset = 0) => {
  const code3 = varint_default2.decode(data, offset);
  return [
    code3,
    varint_default2.decode.bytes
  ];
};
var encodeTo2 = (int2, target, offset = 0) => {
  varint_default2.encode(int2, target, offset);
  return target;
};
var encodingLength2 = (int2) => {
  return varint_default2.encodingLength(int2);
};

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/hashes/digest.js
var create2 = (code3, digest) => {
  const size = digest.byteLength;
  const sizeOffset = encodingLength2(code3);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo2(code3, bytes, 0);
  encodeTo2(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest2(code3, size, digest, bytes);
};
var decode10 = (multihash) => {
  const bytes = coerce(multihash);
  const [code3, sizeOffset] = decode9(bytes);
  const [size, digestOffset] = decode9(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code3, size, digest, bytes);
};
var equals4 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
  }
};
var Digest2 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code3, size, digest, bytes) {
    this.code = code3;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
};

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/bases/base32.js
var base322 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.deno/multiformats@11.0.2/node_modules/multiformats/src/cid.js
__reExport(cid_exports, __toESM(require_interface()));
var format8 = (link, base4) => {
  const { bytes, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV02(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base4 || base58btc.encoder
      );
    default:
      return toStringV12(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base4 || base322.encoder
      );
  }
};
var toJSON = (link) => ({
  "/": format8(link)
});
var fromJSON = (json2) => CID2.parse(json2["/"]);
var cache = /* @__PURE__ */ new WeakMap();
var baseCache = (cid) => {
  const baseCache3 = cache.get(cid);
  if (baseCache3 == null) {
    const baseCache4 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache4);
    return baseCache4;
  }
  return baseCache3;
};
var CID2 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version4, code3, multihash, bytes) {
    this.code = code3;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code3, multihash } = this;
        if (code3 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code3, digest } = this.multihash;
        const multihash = create2(code3, digest);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown2 = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown2 && self2.code === unknown2.code && self2.version === unknown2.version && equals4(self2.multihash, unknown2.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base4) {
    return format8(this, base4);
  }
  toJSON() {
    return {
      "/": format8(this)
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code3, multihash, bytes } = value;
      return new _CID(
        version4,
        code3,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID2(version4, code3, multihash.bytes)
      );
    } else if (value[cidSymbol2] === true) {
      const { version: version4, multihash, code: code3 } = value;
      const digest = (
        /** @type {API.MultihashDigest<Alg>} */
        decode10(multihash)
      );
      return _CID.create(version4, code3, digest);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code3, digest) {
    if (typeof code3 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code3 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new _CID(version4, code3, digest, digest.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID2(version4, code3, digest.bytes);
        return new _CID(version4, code3, digest, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest) {
    return _CID.create(0, DAG_PB_CODE2, digest);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code3, digest) {
    return _CID.create(1, code3, digest);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest
    ) : _CID.createV1(specs.codec, digest);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length4] = decode9(initialBytes.subarray(offset));
      offset += length4;
      return i2;
    };
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE2
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version4,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base4) {
    const [prefix, bytes] = parseCIDtoBytes2(source, base4);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes2 = (source, base4) => {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base4 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base4 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base322.prefix: {
      const decoder = base4 || base322;
      return [
        /** @type {Prefix} */
        base322.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        /** @type {Prefix} */
        source[0],
        base4.decode(source)
      ];
    }
  }
};
var toStringV02 = (bytes, cache3, base4) => {
  const { prefix } = base4;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV12 = (bytes, cache3, base4) => {
  const { prefix } = base4;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
var encodeCID2 = (version4, code3, multihash) => {
  const codeOffset = encodingLength2(version4);
  const hashOffset = codeOffset + encodingLength2(code3);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version4, bytes, 0);
  encodeTo2(code3, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/.deno/@sbp+sbp@2.4.1/node_modules/@sbp/sbp/dist/esm/index.js
var selectors = /* @__PURE__ */ Object.create(null);
var domains = /* @__PURE__ */ Object.create(null);
var globalFilters = [];
var domainFilters = /* @__PURE__ */ Object.create(null);
var selectorFilters = /* @__PURE__ */ Object.create(null);
var unsafeSelectors = /* @__PURE__ */ Object.create(null);
var DOMAIN_REGEX = /^[^/]+/;
function sbp(selector, ...data) {
  const domain2 = domainFromSelector(selector);
  const starSelector = `${domain2}/*`;
  const selExists = !!selectors[selector];
  let sel = selector;
  if (!selExists) {
    if (selectors[starSelector]) {
      sel = starSelector;
    } else {
      throw new Error(`SBP: selector not registered: ${selector}`);
    }
  }
  for (const filters of [
    selectorFilters[selector],
    domainFilters[domain2],
    globalFilters
  ]) {
    if (filters) {
      for (const filter of filters) {
        if (filter(domain2, selector, data) === false) return;
      }
    }
  }
  if (!selExists) {
    data.unshift(selector);
  }
  return selectors[sel].apply(domains[domain2].state, data);
}
function domainFromSelector(selector) {
  const domainLookup = DOMAIN_REGEX.exec(selector);
  if (domainLookup === null) {
    throw new Error(`SBP: selector missing domain: ${selector}`);
  }
  return domainLookup[0];
}
var SBP_BASE_SELECTORS = {
  "sbp/selectors/register": (sels) => {
    const registered = [];
    for (const selector in sels) {
      const domainName = domainFromSelector(selector);
      const domain2 = domainName in domains ? domains[domainName] : domains[domainName] = {
        state: /* @__PURE__ */ Object.create(null),
        locked: false
      };
      if (domain2.locked) {
        (console.warn || console.log)(`[SBP WARN]: not registering selector on locked domain: '${selector}'`);
      } else if (selectors[selector]) {
        (console.warn || console.log)(`[SBP WARN]: not registering already registered selector: '${selector}'`);
      } else if (typeof sels[selector] === "function") {
        if (unsafeSelectors[selector]) {
          (console.warn || console.log)(`[SBP WARN]: registering unsafe selector: '${selector}' (remember to lock after overwriting)`);
        }
        const fn = selectors[selector] = sels[selector];
        registered.push(selector);
        if (selector === `${domainName}/_init`) {
          fn.call(domain2.state);
        }
      }
    }
    return registered;
  },
  "sbp/selectors/unregister": (sels) => {
    var _a2;
    for (const selector of sels) {
      if (!unsafeSelectors[selector]) {
        throw new Error(`SBP: can't unregister locked selector: ${selector}`);
      }
      if ((_a2 = domains[domainFromSelector(selector)]) === null || _a2 === void 0 ? void 0 : _a2.locked) {
        throw new Error(`SBP: can't unregister selector on a locked domain: '${selector}'`);
      }
      delete selectors[selector];
    }
  },
  "sbp/selectors/overwrite": (sels) => {
    sbp("sbp/selectors/unregister", Object.keys(sels));
    return sbp("sbp/selectors/register", sels);
  },
  "sbp/selectors/unsafe": (sels) => {
    for (const selector of sels) {
      if (selectors[selector]) {
        throw new Error("unsafe must be called before registering selector");
      }
      unsafeSelectors[selector] = true;
    }
  },
  "sbp/selectors/lock": (sels) => {
    for (const selector of sels) {
      delete unsafeSelectors[selector];
    }
  },
  "sbp/selectors/fn": (sel) => {
    return selectors[sel];
  },
  "sbp/filters/global/add": (filter) => {
    globalFilters.push(filter);
  },
  "sbp/filters/domain/add": (domain2, filter) => {
    if (!domainFilters[domain2]) domainFilters[domain2] = [];
    domainFilters[domain2].push(filter);
  },
  "sbp/filters/selector/add": (selector, filter) => {
    if (!selectorFilters[selector]) selectorFilters[selector] = [];
    selectorFilters[selector].push(filter);
  },
  "sbp/domains/lock": (domainNames) => {
    if (!domainNames) {
      for (const name in domains) {
        domains[name].locked = true;
      }
    } else {
      for (const name of domainNames) {
        if (!domains[name]) {
          throw new Error(`SBP: cannot lock non-existent domain: ${name}`);
        }
        domains[name].locked = true;
      }
    }
  }
};
SBP_BASE_SELECTORS["sbp/selectors/register"](SBP_BASE_SELECTORS);
var esm_default = sbp;

// build/serve/ownerSizeTotalWorker.js-tmp
var Hapi = __toESM(require_lib29());
var import_boom_10_0 = __toESM(require_lib6());
var import_npm_joi_18_0 = __toESM(require_lib32());
var import_inert_7_1 = __toESM(require_lib33());
var import_npm_chalk_4_1 = __toESM(require_source());
var import_npm_pino_8_19 = __toESM(require_pino());
var import_npm_lru_cache_7_14 = __toESM(require_lru_cache2());

// node_modules/.deno/ws@8.5.0/node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);
var wrapper_default = import_websocket.default;

// node_modules/.deno/uuid@9.0.0/node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist(), 1);
var v1 = import_dist.default.v1;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var NIL = import_dist.default.NIL;
var version3 = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse9 = import_dist.default.parse;

// node_modules/.deno/turtledash@1.0.3/node_modules/turtledash/dist/esm/index.js
function omit2(o2, props) {
  const x3 = /* @__PURE__ */ Object.create(null);
  for (const k in o2) {
    if (!props.includes(k)) {
      x3[k] = o2[k];
    }
  }
  return x3;
}
function cloneDeep(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var has = Function.prototype.call.bind(Object.prototype.hasOwnProperty);

// build/serve/ownerSizeTotalWorker.js-tmp
var import_npm_bottleneck_2_19 = __toESM(require_lib34());
var import_npm_scrypt_async_2_0 = __toESM(require_scrypt_async());

// node_modules/.deno/@apeleghq+rfc8188@1.0.7/node_modules/@apeleghq/rfc8188/dist/encodings.mjs
var x = {
  params: {
    name: "AES-GCM",
    length: 128
  },
  get cek_info() {
    return new Uint8Array([
      67,
      111,
      110,
      116,
      101,
      110,
      116,
      45,
      69,
      110,
      99,
      111,
      100,
      105,
      110,
      103,
      58,
      32,
      97,
      101,
      115,
      49,
      50,
      56,
      103,
      99,
      109,
      0
    ]);
  },
  get nonce_info() {
    return new Uint8Array([
      67,
      111,
      110,
      116,
      101,
      110,
      116,
      45,
      69,
      110,
      99,
      111,
      100,
      105,
      110,
      103,
      58,
      32,
      110,
      111,
      110,
      99,
      101,
      0
    ]);
  },
  block_size: 16,
  tag_length: 16,
  nonce_length: 12
};

// node_modules/.deno/@apeleghq+rfc8188@1.0.7/node_modules/@apeleghq/rfc8188/dist/encrypt.mjs
var R = async (e2, b, f, i2) => {
  let A2 = await globalThis.crypto.subtle.importKey("raw", b, "HKDF", false, [
    "deriveKey",
    "deriveBits"
  ]), y = await globalThis.crypto.subtle.deriveKey({
    name: "HKDF",
    hash: "SHA-256",
    info: e2.cek_info,
    salt: f
  }, A2, e2.params, false, i2), u2 = await globalThis.crypto.subtle.deriveBits({
    name: "HKDF",
    hash: "SHA-256",
    info: e2.nonce_info,
    salt: f
  }, A2, e2.nonce_length << 3);
  return [
    y,
    function* () {
      let L = new ArrayBuffer(e2.nonce_length), c = new DataView(L), h2 = new Uint8Array(L), a = new Uint8Array(u2), g2 = 4294967295, o2 = (e2.nonce_length >> 2) - 1, s = new Array(o2).fill(0);
      for (; ; ) {
        for (let t = 0; t <= g2; t++) {
          c.setUint32(c.byteLength - 4, t, false);
          let n = new Uint8Array(e2.nonce_length);
          for (let r = 0; r < n.length; r++) n[r] = a[r] ^ h2[r];
          yield n;
        }
        for (let t = 0; t < o2; t++) {
          if (t === o2 - 1 && s[t] === g2) throw new RangeError("Maximum number of segments exceeded");
          if (s[t] = (s[t] + 1) % (g2 + 1), c.setUint32(c.byteLength - 4 * (t + 2), s[t], false), s[t] !== 0) break;
        }
      }
    }()
  ];
};
var E = R;
var B = (e2) => ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer).subarray(e2.byteOffset, e2.byteOffset + e2.byteLength) : new Uint8Array(e2);
var w = B;
var N = () => {
  let e2 = new Uint8Array(16);
  return globalThis.crypto.getRandomValues(e2), e2;
};
var U = async (e2, b, f, i2, A2, y) => {
  if (f <= e2.tag_length + 1 || f > 4294967295) throw new RangeError("Invalid record size: " + f);
  if (i2.byteLength > 255) throw new RangeError("Key ID too long");
  if (y && y.byteLength !== 16) throw new RangeError("Invald salt length: " + y.byteLength);
  let u2 = f - e2.tag_length - 1, l = y ? w(y) : N(), [L, c] = await E(e2, A2, l, [
    "encrypt"
  ]);
  A2 = void 0;
  let h2 = new Uint8Array(u2), a = 0, g2 = new TransformStream({
    start: (o2) => {
      let s = l.byteLength + 4 + 1 + i2.byteLength, t = new ArrayBuffer(s);
      new Uint8Array(t, 0, l.byteLength).set(l);
      let r = new DataView(t, l.byteLength, 5);
      r.setUint32(0, f, false), r.setUint8(4, i2.byteLength);
      let d = new Uint8Array(t, l.byteLength + 4 + 1, i2.byteLength), m3 = w(i2);
      d.set(m3), o2.enqueue(t);
    },
    transform: async (o2, s) => {
      let t = w(o2), n = 0;
      for (; n < o2.byteLength; ) {
        let r = t.subarray(n, n + u2 - a);
        if (h2.set(r, a), a += r.byteLength, n += r.byteLength, a === u2) {
          let m3 = c.next().value, p = new Uint8Array(u2 + 1);
          p.set(h2.subarray(0, a)), p[a] = 1;
          let T2 = await globalThis.crypto.subtle.encrypt({
            name: e2.params.name,
            iv: m3,
            tagLength: e2.tag_length << 3
          }, L, p);
          s.enqueue(T2), a = 0;
        }
      }
    },
    flush: async (o2) => {
      let t = c.next().value, n = new Uint8Array(a + 1);
      n.set(h2.subarray(0, a)), n[a] = 2;
      let r = await globalThis.crypto.subtle.encrypt({
        name: e2.params.name,
        iv: t,
        tagLength: e2.tag_length << 3
      }, L, n);
      o2.enqueue(r), h2.fill(0), n.fill(0);
    }
  });
  return b.pipeThrough(g2), g2.readable;
};
var K = U;

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/chelonia.mjs
var chelonia_exports = {};
__export(chelonia_exports, {
  ACTION_REGEX: () => ACTION_REGEX,
  SPMessage: () => SPMessage,
  default: () => chelonia_default
});

// node_modules/.deno/@sbp+okturtles.eventqueue@1.2.1/node_modules/@sbp/okturtles.eventqueue/dist/esm/index.mjs
var isEventQueueSbpEvent = (e2) => {
  return Object.prototype.hasOwnProperty.call(e2, "sbpInvocation");
};
var esm_default2 = esm_default("sbp/selectors/register", {
  "okTurtles.eventQueue/_init": function() {
    this.eventQueues = /* @__PURE__ */ Object.create(null);
  },
  "okTurtles.eventQueue/isWaiting": function(name) {
    var _a2;
    return !!((_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.length);
  },
  "okTurtles.eventQueue/queuedInvocations": function(name) {
    var _a2, _b;
    if (name == null) {
      return Object.fromEntries(Object.entries(this.eventQueues).map(([name2, events]) => [
        name2,
        events.map((event) => {
          if (isEventQueueSbpEvent(event)) {
            return event.sbpInvocation;
          } else {
            return event.fn;
          }
        })
      ]));
    }
    return (_b = (_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.map((event) => {
      if (isEventQueueSbpEvent(event)) {
        return event.sbpInvocation;
      } else {
        return event.fn;
      }
    })) !== null && _b !== void 0 ? _b : [];
  },
  "okTurtles.eventQueue/queueEvent": async function(name, invocation) {
    if (!Object.prototype.hasOwnProperty.call(this.eventQueues, name)) {
      this.eventQueues[name] = [];
    }
    const events = this.eventQueues[name];
    let accept;
    const promise2 = new Promise((resolve7) => {
      accept = resolve7;
    });
    const thisEvent = typeof invocation === "function" ? {
      fn: invocation,
      promise: promise2
    } : {
      sbpInvocation: invocation,
      promise: promise2
    };
    events.push(thisEvent);
    while (events.length > 0) {
      const event = events[0];
      if (event === thisEvent) {
        try {
          if (typeof invocation === "function") {
            return await invocation();
          } else {
            return await esm_default(...invocation);
          }
        } finally {
          accept();
          events.shift();
        }
      } else {
        await event.promise;
      }
    }
  }
});

// node_modules/.deno/@sbp+okturtles.data@0.1.6/node_modules/@sbp/okturtles.data/dist/esm/index.mjs
var _store = /* @__PURE__ */ new Map();
var esm_default3 = esm_default("sbp/selectors/register", {
  "okTurtles.data/get": function(key) {
    return _store.get(key);
  },
  "okTurtles.data/set": function(key, data) {
    _store.set(key, data);
    return data;
  },
  "okTurtles.data/delete": function(key) {
    return _store.delete(key);
  },
  "okTurtles.data/add": function(key, data) {
    const array2 = _store.get(key);
    if (array2) {
      array2.push(data);
    } else {
      _store.set(key, [
        data
      ]);
    }
  },
  "okTurtles.data/remove": function(key, data) {
    const array2 = _store.get(key);
    if (array2) {
      const aLen = array2.length;
      const filtered = array2.filter((v2) => v2 !== data);
      _store.set(key, filtered);
      return aLen - filtered.length;
    }
  },
  "okTurtles.data/apply": function(key, fn) {
    return fn(_store.get(key));
  }
});

// node_modules/.deno/@sbp+okturtles.events@1.0.1/node_modules/@sbp/okturtles.events/dist/esm/index.mjs
var listenKey = (evt) => `events/${evt}/listeners`;
var esm_default4 = esm_default("sbp/selectors/register", {
  "okTurtles.events/_init": function() {
    this.errorHandler = (event, e2) => {
      console.error(`[okTurtles.events] Error at handler for ${event}`, e2);
    };
  },
  "okTurtles.events/on": function(event, handler) {
    esm_default("okTurtles.data/add", listenKey(event), handler);
    return () => esm_default("okTurtles.events/off", event, handler);
  },
  "okTurtles.events/once": function(event, handler) {
    const cbWithOff = (...args) => {
      handler(...args);
      esm_default("okTurtles.events/off", event, cbWithOff);
    };
    return esm_default("okTurtles.events/on", event, cbWithOff);
  },
  "okTurtles.events/emit": function(event, ...data) {
    var _a2;
    for (const listener of esm_default("okTurtles.data/get", listenKey(event)) || []) {
      try {
        listener(...data);
      } catch (e2) {
        (_a2 = this.errorHandler) === null || _a2 === void 0 ? void 0 : _a2.call(this, event, e2);
      }
    }
  },
  // almost identical to Vue.prototype.$off, except we require `event` argument
  "okTurtles.events/off": function(event, handler) {
    if (handler) {
      esm_default("okTurtles.data/remove", listenKey(event), handler);
    } else {
      esm_default("okTurtles.data/delete", listenKey(event));
    }
  },
  "okTurtles.events/setErrorHandler": function(errorHandler) {
    this.errorHandler = errorHandler;
  }
});

// node_modules/.deno/turtledash@1.0.2/node_modules/turtledash/dist/esm/index.js
function pick2(o2, props) {
  const x3 = /* @__PURE__ */ Object.create(null);
  for (const k of props) {
    if (has2(o2, k)) {
      x3[k] = o2[k];
    }
  }
  return x3;
}
function omit3(o2, props) {
  const x3 = /* @__PURE__ */ Object.create(null);
  for (const k in o2) {
    if (!props.includes(k)) {
      x3[k] = o2[k];
    }
  }
  return x3;
}
function cloneDeep2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function isMergeableObject(val) {
  const nonNullObject = val && typeof val === "object";
  return nonNullObject && Object.prototype.toString.call(val) !== "[object RegExp]" && Object.prototype.toString.call(val) !== "[object Date]";
}
function merge2(obj, src4) {
  const res = obj;
  for (const key in src4) {
    const clone2 = isMergeableObject(src4[key]) ? cloneDeep2(src4[key]) : void 0;
    let x3;
    if (clone2 && isMergeableObject(x3 = res[key])) {
      merge2(x3, clone2);
      continue;
    }
    res[key] = clone2 || src4[key];
  }
  return res;
}
function delay(msec) {
  return new Promise((resolve7) => {
    setTimeout(resolve7, msec);
  });
}
function randomBytes(length4) {
  return crypto.getRandomValues(new Uint8Array(length4));
}
function randomHexString(length4) {
  return Array.from(randomBytes(length4), (byte) => (byte % 16).toString(16)).join("");
}
function randomIntFromRange(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function uniq(array2) {
  return Array.from(new Set(array2));
}
function intersection2(a1, ...arrays) {
  return uniq(a1).filter((v12) => arrays.every((v2) => v2.indexOf(v12) >= 0));
}
function difference(a1, ...arrays) {
  const a2 = Array.prototype.concat.apply([], arrays);
  return a1.filter((v2) => a2.indexOf(v2) === -1);
}
function debounce(func, wait, immediate) {
  let timeout, args, context, timestamp, result;
  if (wait == null) wait = 100;
  function later() {
    const last = performance.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = void 0;
      if (!immediate) {
        result = func.apply(context, args);
        args = void 0;
        context = void 0;
      }
    }
  }
  const debounced = function(...args_) {
    args = args_;
    context = this;
    timestamp = performance.now();
    const callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      args = void 0;
      context = void 0;
    }
    return result;
  };
  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      args = void 0;
      context = void 0;
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debounced;
}
var has2 = Function.prototype.call.bind(Object.prototype.hasOwnProperty);

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bytes.mjs
var empty3 = new Uint8Array(0);
function equals5(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce3(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
    return o2;
  }
  if (o2 instanceof ArrayBuffer) {
    return new Uint8Array(o2);
  }
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/base-x.mjs
function base3(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x3 = ALPHABET.charAt(i2);
    var xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode9(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode15(string4) {
    var buffer = decodeUnsafe(string4);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode9,
    decodeUnsafe,
    decode: decode15
  };
}
var src3 = base3;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base.mjs
var Encoder3 = class {
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or3(left, right) {
  var _a2, _b;
  return new ComposedDecoder3(Object.assign(Object.assign({}, (_a2 = left.decoders) !== null && _a2 !== void 0 ? _a2 : {
    [left.prefix]: left
  }), (_b = right.decoders) !== null && _b !== void 0 ? _b : {
    [right.prefix]: right
  }));
}
var Codec3 = class {
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name, prefix, baseEncode);
    this.decoder = new Decoder3(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from4({ name, prefix, encode: encode9, decode: decode15 }) {
  return new Codec3(name, prefix, encode9, decode15);
}
function baseX3({ name, prefix, alphabet: alphabet5 }) {
  const { encode: encode9, decode: decode15 } = base_x_default3(alphabet5, name);
  return from4({
    prefix,
    name,
    encode: encode9,
    decode: (text) => coerce3(decode15(text))
  });
}
function decode11(string4, alphabet5, bitsPerChar, name) {
  const codes = {};
  for (let i2 = 0; i2 < alphabet5.length; ++i2) {
    codes[alphabet5[i2]] = i2;
  }
  let end = string4.length;
  while (string4[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string4[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode7(data, alphabet5, bitsPerChar) {
  const pad = alphabet5[alphabet5.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet5[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet5[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46483({ name, prefix, bitsPerChar, alphabet: alphabet5 }) {
  return from4({
    prefix,
    name,
    encode(input) {
      return encode7(input, alphabet5, bitsPerChar);
    },
    decode(input) {
      return decode11(input, alphabet5, bitsPerChar, name);
    }
  });
}

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base58.mjs
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/blake2b.mjs
var import_blakejs3 = __toESM(require_blakejs(), 1);

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/vendor/varint.mjs
var encode_13 = encode8;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode8(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode8.bytes = offset - oldOffset + 1;
  return out;
}
var decode12 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode12,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/varint.mjs
function decode13(data, offset = 0) {
  const code3 = varint_default3.decode(data, offset);
  return [
    code3,
    varint_default3.decode.bytes
  ];
}
function encodeTo3(int2, target, offset = 0) {
  varint_default3.encode(int2, target, offset);
  return target;
}
function encodingLength3(int2) {
  return varint_default3.encodingLength(int2);
}

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/hashes/digest.mjs
function create3(code3, digest) {
  const size = digest.byteLength;
  const sizeOffset = encodingLength3(code3);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo3(code3, bytes, 0);
  encodeTo3(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest3(code3, size, digest, bytes);
}
function decode14(multihash) {
  const bytes = coerce3(multihash);
  const [code3, sizeOffset] = decode13(bytes);
  const [size, digestOffset] = decode13(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code3, size, digest, bytes);
}
function equals6(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals5(a.bytes, data.bytes);
  }
}
var Digest3 = class {
  /**
     * Creates a multihash digest.
     */
  constructor(code3, size, digest, bytes) {
    this.code = code3;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
};

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/hasher.mjs
function from5({ name, code: code3, encode: encode9 }) {
  return new Hasher2(name, code3, encode9);
}
var Hasher2 = class {
  constructor(name, code3, encode9) {
    this.name = name;
    this.code = code3;
    this.encode = encode9;
  }
  digest(input) {
    if (input instanceof Uint8Array || input instanceof ReadableStream) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest) => create3(this.code, digest));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/blake2b.mjs
var { blake2b: blake2b2 } = import_blakejs3.default;
var blake2b82 = from5({
  name: "blake2b-8",
  code: 45569,
  encode: (input) => coerce3(blake2b2(input, void 0, 1))
});
var blake2b162 = from5({
  name: "blake2b-16",
  code: 45570,
  encode: (input) => coerce3(blake2b2(input, void 0, 2))
});
var blake2b242 = from5({
  name: "blake2b-24",
  code: 45571,
  encode: (input) => coerce3(blake2b2(input, void 0, 3))
});
var blake2b322 = from5({
  name: "blake2b-32",
  code: 45572,
  encode: (input) => coerce3(blake2b2(input, void 0, 4))
});
var blake2b402 = from5({
  name: "blake2b-40",
  code: 45573,
  encode: (input) => coerce3(blake2b2(input, void 0, 5))
});
var blake2b482 = from5({
  name: "blake2b-48",
  code: 45574,
  encode: (input) => coerce3(blake2b2(input, void 0, 6))
});
var blake2b562 = from5({
  name: "blake2b-56",
  code: 45575,
  encode: (input) => coerce3(blake2b2(input, void 0, 7))
});
var blake2b642 = from5({
  name: "blake2b-64",
  code: 45576,
  encode: (input) => coerce3(blake2b2(input, void 0, 8))
});
var blake2b722 = from5({
  name: "blake2b-72",
  code: 45577,
  encode: (input) => coerce3(blake2b2(input, void 0, 9))
});
var blake2b802 = from5({
  name: "blake2b-80",
  code: 45578,
  encode: (input) => coerce3(blake2b2(input, void 0, 10))
});
var blake2b882 = from5({
  name: "blake2b-88",
  code: 45579,
  encode: (input) => coerce3(blake2b2(input, void 0, 11))
});
var blake2b962 = from5({
  name: "blake2b-96",
  code: 45580,
  encode: (input) => coerce3(blake2b2(input, void 0, 12))
});
var blake2b1042 = from5({
  name: "blake2b-104",
  code: 45581,
  encode: (input) => coerce3(blake2b2(input, void 0, 13))
});
var blake2b1122 = from5({
  name: "blake2b-112",
  code: 45582,
  encode: (input) => coerce3(blake2b2(input, void 0, 14))
});
var blake2b1202 = from5({
  name: "blake2b-120",
  code: 45583,
  encode: (input) => coerce3(blake2b2(input, void 0, 15))
});
var blake2b1282 = from5({
  name: "blake2b-128",
  code: 45584,
  encode: (input) => coerce3(blake2b2(input, void 0, 16))
});
var blake2b1362 = from5({
  name: "blake2b-136",
  code: 45585,
  encode: (input) => coerce3(blake2b2(input, void 0, 17))
});
var blake2b1442 = from5({
  name: "blake2b-144",
  code: 45586,
  encode: (input) => coerce3(blake2b2(input, void 0, 18))
});
var blake2b1522 = from5({
  name: "blake2b-152",
  code: 45587,
  encode: (input) => coerce3(blake2b2(input, void 0, 19))
});
var blake2b1602 = from5({
  name: "blake2b-160",
  code: 45588,
  encode: (input) => coerce3(blake2b2(input, void 0, 20))
});
var blake2b1682 = from5({
  name: "blake2b-168",
  code: 45589,
  encode: (input) => coerce3(blake2b2(input, void 0, 21))
});
var blake2b1762 = from5({
  name: "blake2b-176",
  code: 45590,
  encode: (input) => coerce3(blake2b2(input, void 0, 22))
});
var blake2b1842 = from5({
  name: "blake2b-184",
  code: 45591,
  encode: (input) => coerce3(blake2b2(input, void 0, 23))
});
var blake2b1922 = from5({
  name: "blake2b-192",
  code: 45592,
  encode: (input) => coerce3(blake2b2(input, void 0, 24))
});
var blake2b2002 = from5({
  name: "blake2b-200",
  code: 45593,
  encode: (input) => coerce3(blake2b2(input, void 0, 25))
});
var blake2b2082 = from5({
  name: "blake2b-208",
  code: 45594,
  encode: (input) => coerce3(blake2b2(input, void 0, 26))
});
var blake2b2162 = from5({
  name: "blake2b-216",
  code: 45595,
  encode: (input) => coerce3(blake2b2(input, void 0, 27))
});
var blake2b2242 = from5({
  name: "blake2b-224",
  code: 45596,
  encode: (input) => coerce3(blake2b2(input, void 0, 28))
});
var blake2b2322 = from5({
  name: "blake2b-232",
  code: 45597,
  encode: (input) => coerce3(blake2b2(input, void 0, 29))
});
var blake2b2402 = from5({
  name: "blake2b-240",
  code: 45598,
  encode: (input) => coerce3(blake2b2(input, void 0, 30))
});
var blake2b2482 = from5({
  name: "blake2b-248",
  code: 45599,
  encode: (input) => coerce3(blake2b2(input, void 0, 31))
});
var blake2b2562 = from5({
  name: "blake2b-256",
  code: 45600,
  encode: (input) => coerce3(blake2b2(input, void 0, 32))
});
var blake2b2642 = from5({
  name: "blake2b-264",
  code: 45601,
  encode: (input) => coerce3(blake2b2(input, void 0, 33))
});
var blake2b2722 = from5({
  name: "blake2b-272",
  code: 45602,
  encode: (input) => coerce3(blake2b2(input, void 0, 34))
});
var blake2b2802 = from5({
  name: "blake2b-280",
  code: 45603,
  encode: (input) => coerce3(blake2b2(input, void 0, 35))
});
var blake2b2882 = from5({
  name: "blake2b-288",
  code: 45604,
  encode: (input) => coerce3(blake2b2(input, void 0, 36))
});
var blake2b2962 = from5({
  name: "blake2b-296",
  code: 45605,
  encode: (input) => coerce3(blake2b2(input, void 0, 37))
});
var blake2b3042 = from5({
  name: "blake2b-304",
  code: 45606,
  encode: (input) => coerce3(blake2b2(input, void 0, 38))
});
var blake2b3122 = from5({
  name: "blake2b-312",
  code: 45607,
  encode: (input) => coerce3(blake2b2(input, void 0, 39))
});
var blake2b3202 = from5({
  name: "blake2b-320",
  code: 45608,
  encode: (input) => coerce3(blake2b2(input, void 0, 40))
});
var blake2b3282 = from5({
  name: "blake2b-328",
  code: 45609,
  encode: (input) => coerce3(blake2b2(input, void 0, 41))
});
var blake2b3362 = from5({
  name: "blake2b-336",
  code: 45610,
  encode: (input) => coerce3(blake2b2(input, void 0, 42))
});
var blake2b3442 = from5({
  name: "blake2b-344",
  code: 45611,
  encode: (input) => coerce3(blake2b2(input, void 0, 43))
});
var blake2b3522 = from5({
  name: "blake2b-352",
  code: 45612,
  encode: (input) => coerce3(blake2b2(input, void 0, 44))
});
var blake2b3602 = from5({
  name: "blake2b-360",
  code: 45613,
  encode: (input) => coerce3(blake2b2(input, void 0, 45))
});
var blake2b3682 = from5({
  name: "blake2b-368",
  code: 45614,
  encode: (input) => coerce3(blake2b2(input, void 0, 46))
});
var blake2b3762 = from5({
  name: "blake2b-376",
  code: 45615,
  encode: (input) => coerce3(blake2b2(input, void 0, 47))
});
var blake2b3842 = from5({
  name: "blake2b-384",
  code: 45616,
  encode: (input) => coerce3(blake2b2(input, void 0, 48))
});
var blake2b3922 = from5({
  name: "blake2b-392",
  code: 45617,
  encode: (input) => coerce3(blake2b2(input, void 0, 49))
});
var blake2b4002 = from5({
  name: "blake2b-400",
  code: 45618,
  encode: (input) => coerce3(blake2b2(input, void 0, 50))
});
var blake2b4082 = from5({
  name: "blake2b-408",
  code: 45619,
  encode: (input) => coerce3(blake2b2(input, void 0, 51))
});
var blake2b4162 = from5({
  name: "blake2b-416",
  code: 45620,
  encode: (input) => coerce3(blake2b2(input, void 0, 52))
});
var blake2b4242 = from5({
  name: "blake2b-424",
  code: 45621,
  encode: (input) => coerce3(blake2b2(input, void 0, 53))
});
var blake2b4322 = from5({
  name: "blake2b-432",
  code: 45622,
  encode: (input) => coerce3(blake2b2(input, void 0, 54))
});
var blake2b4402 = from5({
  name: "blake2b-440",
  code: 45623,
  encode: (input) => coerce3(blake2b2(input, void 0, 55))
});
var blake2b4482 = from5({
  name: "blake2b-448",
  code: 45624,
  encode: (input) => coerce3(blake2b2(input, void 0, 56))
});
var blake2b4562 = from5({
  name: "blake2b-456",
  code: 45625,
  encode: (input) => coerce3(blake2b2(input, void 0, 57))
});
var blake2b4642 = from5({
  name: "blake2b-464",
  code: 45626,
  encode: (input) => coerce3(blake2b2(input, void 0, 58))
});
var blake2b4722 = from5({
  name: "blake2b-472",
  code: 45627,
  encode: (input) => coerce3(blake2b2(input, void 0, 59))
});
var blake2b4802 = from5({
  name: "blake2b-480",
  code: 45628,
  encode: (input) => coerce3(blake2b2(input, void 0, 60))
});
var blake2b4882 = from5({
  name: "blake2b-488",
  code: 45629,
  encode: (input) => coerce3(blake2b2(input, void 0, 61))
});
var blake2b4962 = from5({
  name: "blake2b-496",
  code: 45630,
  encode: (input) => coerce3(blake2b2(input, void 0, 62))
});
var blake2b5042 = from5({
  name: "blake2b-504",
  code: 45631,
  encode: (input) => coerce3(blake2b2(input, void 0, 63))
});
var blake2b5122 = from5({
  name: "blake2b-512",
  code: 45632,
  encode: (input) => coerce3(blake2b2(input, void 0, 64))
});

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/blake2bstream.mjs
var import_blakejs4 = __toESM(require_blakejs(), 1);
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve7) {
      resolve7(value);
    });
  }
  return new (P || (P = Promise))(function(resolve7, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve7(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var { blake2b: blake2b3, blake2bInit, blake2bUpdate, blake2bFinal } = import_blakejs4.default;
var blake2b256stream = from5({
  name: "blake2b-256",
  code: 45600,
  encode: (input) => __awaiter(void 0, void 0, void 0, function* () {
    if (input instanceof ReadableStream) {
      const ctx = blake2bInit(32);
      const reader = input.getReader();
      for (; ; ) {
        const result = yield reader.read();
        if (result.done) break;
        blake2bUpdate(ctx, coerce3(result.value));
      }
      return blake2bFinal(ctx);
    } else {
      return coerce3(blake2b3(input, void 0, 32));
    }
  })
});

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base32.mjs
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/cid.mjs
var _a;
function format9(link, base4) {
  const { bytes, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV03(bytes, baseCache2(link), base4 !== null && base4 !== void 0 ? base4 : base58btc3.encoder);
    default:
      return toStringV13(bytes, baseCache2(link), base4 !== null && base4 !== void 0 ? base4 : base323.encoder);
  }
}
var cache2 = /* @__PURE__ */ new WeakMap();
function baseCache2(cid) {
  const baseCache3 = cache2.get(cid);
  if (baseCache3 == null) {
    const baseCache4 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache4);
    return baseCache4;
  }
  return baseCache3;
}
var CID3 = class _CID {
  /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
  constructor(version4, code3, multihash, bytes) {
    this[_a] = "CID";
    this.code = code3;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code3, multihash } = this;
        if (code3 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code3, digest } = this.multihash;
        const multihash = create3(code3, digest);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown2 = other;
    return unknown2 != null && self2.code === unknown2.code && self2.version === unknown2.version && equals6(self2.multihash, unknown2.multihash);
  }
  toString(base4) {
    return format9(this, base4);
  }
  toJSON() {
    return {
      "/": format9(this)
    };
  }
  link() {
    return this;
  }
  // Legacy
  [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
    return `CID(${this.toString()})`;
  }
  /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code3, multihash, bytes } = value;
      return new _CID(version4, code3, multihash, bytes !== null && bytes !== void 0 ? bytes : encodeCID3(version4, code3, multihash.bytes));
    } else if (value[cidSymbol3] === true) {
      const { version: version4, multihash, code: code3 } = value;
      const digest = decode14(multihash);
      return _CID.create(version4, code3, digest);
    } else {
      return null;
    }
  }
  /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
  static create(version4, code3, digest) {
    if (typeof code3 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code3 !== DAG_PB_CODE3) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
        } else {
          return new _CID(version4, code3, digest, digest.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID3(version4, code3, digest.bytes);
        return new _CID(version4, code3, digest, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
     * Simplified version of `create` for CIDv0.
     */
  static createV0(digest) {
    return _CID.create(0, DAG_PB_CODE3, digest);
  }
  /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
  static createV1(code3, digest) {
    return _CID.create(1, code3, digest);
  }
  /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length4] = decode13(initialBytes.subarray(offset));
      offset += length4;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE3;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version4,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
  static parse(source, base4) {
    const [prefix, bytes] = parseCIDtoBytes3(source, base4);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes3(source, base4) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base4 !== null && base4 !== void 0 ? base4 : base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base4 !== null && base4 !== void 0 ? base4 : base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(source)
      ];
    }
    case base323.prefix: {
      const decoder = base4 !== null && base4 !== void 0 ? base4 : base323;
      return [
        base323.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base4.decode(source)
      ];
    }
  }
}
function toStringV03(bytes, cache3, base4) {
  const { prefix } = base4;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV13(bytes, cache3, base4) {
  const { prefix } = base4;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
function encodeCID3(version4, code3, multihash) {
  const codeOffset = encodingLength3(version4);
  const hashOffset = codeOffset + encodingLength3(code3);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version4, bytes, 0);
  encodeTo3(code3, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/functions.mjs
import { Buffer as Buffer4 } from "node:buffer";
var multicodes = {
  RAW: 0,
  JSON: 512,
  SHELTER_CONTRACT_MANIFEST: 5316096,
  SHELTER_CONTRACT_TEXT: 5316097,
  SHELTER_CONTRACT_DATA: 5316098,
  SHELTER_FILE_MANIFEST: 5316099,
  SHELTER_FILE_CHUNK: 5316100
};
var parseCID = (cid) => {
  if (!cid || cid.length < 52 || cid.length > 64) {
    throw new RangeError("CID length too short or too long");
  }
  const parsed = CID3.parse(cid, base58btc3);
  if (parsed.version !== 1 || parsed.multihash.code !== blake2b2562.code || !Object.values(multicodes).includes(parsed.code)) {
    throw new Error("Invalid CID");
  }
  return parsed;
};
var maybeParseCID = (cid) => {
  try {
    return parseCID(cid);
  } catch {
    return null;
  }
};
async function createCIDfromStream(data, multicode = multicodes.RAW) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = await blake2b256stream.digest(uint8array);
  return CID3.create(1, multicode, digest).toString(base58btc3);
}
function createCID(data, multicode = multicodes.RAW) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = blake2b2562.digest(uint8array);
  return CID3.create(1, multicode, digest).toString(base58btc3);
}
function blake32Hash(data) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = blake2b2562.digest(uint8array);
  return base58btc3.encode(digest.bytes);
}
var b64ToBuf = (b64) => Buffer4.from(b64, "base64");
var b64ToStr = (b64) => b64ToBuf(b64).toString("utf8");
var strToBuf = (str) => Buffer4.from(str, "utf8");
var strToB64 = (str) => strToBuf(str).toString("base64");
var getSubscriptionId = async (subscriptionInfo) => {
  const textEncoder = new TextEncoder();
  const endpoint = textEncoder.encode(subscriptionInfo.endpoint);
  const p256dh = textEncoder.encode(subscriptionInfo.keys.p256dh);
  const auth = textEncoder.encode(subscriptionInfo.keys.auth);
  const canonicalForm = new ArrayBuffer(8 + (4 + endpoint.byteLength) + (2 + p256dh.byteLength) + (2 + auth.byteLength));
  const canonicalFormU8 = new Uint8Array(canonicalForm);
  const canonicalFormDV = new DataView(canonicalForm);
  let offset = 0;
  canonicalFormDV.setFloat64(offset, subscriptionInfo.expirationTime == null ? NaN : subscriptionInfo.expirationTime, false);
  offset += 8;
  canonicalFormDV.setUint32(offset, endpoint.byteLength, false);
  offset += 4;
  canonicalFormU8.set(endpoint, offset);
  offset += endpoint.byteLength;
  canonicalFormDV.setUint16(offset, p256dh.byteLength, false);
  offset += 2;
  canonicalFormU8.set(p256dh, offset);
  offset += p256dh.byteLength;
  canonicalFormDV.setUint16(offset, auth.byteLength, false);
  offset += 2;
  canonicalFormU8.set(auth, offset);
  const digest = await crypto.subtle.digest("SHA-384", canonicalForm);
  const id = Buffer4.from(digest.slice(0, 16));
  id[6] = 128 | id[6] & 15;
  id[8] = 128 | id[8] & 63;
  return [
    id.slice(0, 4),
    id.slice(4, 6),
    id.slice(6, 8),
    id.slice(8, 10),
    id.slice(10, 16)
  ].map((p) => p.toString("hex")).join("-");
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/chelonia.mjs
import { Buffer as Buffer8 } from "node:buffer";

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/pubsub/index.mjs
var NOTIFICATION_TYPE = Object.freeze({
  ENTRY: "entry",
  DELETION: "deletion",
  KV: "kv",
  KV_FILTER: "kv_filter",
  PING: "ping",
  PONG: "pong",
  PUB: "pub",
  SUB: "sub",
  UNSUB: "unsub",
  VERSION_INFO: "version_info"
});
var REQUEST_TYPE = Object.freeze({
  PUB: "pub",
  SUB: "sub",
  UNSUB: "unsub",
  PUSH_ACTION: "push_action",
  KV_FILTER: "kv_filter"
});
var RESPONSE_TYPE = Object.freeze({
  ERROR: "error",
  OK: "ok"
});
var PUSH_SERVER_ACTION_TYPE = Object.freeze({
  SEND_PUBLIC_KEY: "send-public-key",
  STORE_SUBSCRIPTION: "store-subscription",
  DELETE_SUBSCRIPTION: "delete-subscription",
  SEND_PUSH_NOTIFICATION: "send-push-notification"
});
var defaultOptions = {
  logPingMessages: !process.env.CI,
  pingTimeout: 45e3,
  maxReconnectionDelay: 6e4,
  maxRetries: 10,
  minReconnectionDelay: 500,
  reconnectOnDisconnection: true,
  reconnectOnOnline: true,
  // Defaults to false to avoid reconnection attempts in case the server doesn't
  // respond because of a failed authentication.
  reconnectOnTimeout: false,
  reconnectionDelayGrowFactor: 2,
  timeout: 6e4
};
var PUBSUB_ERROR = "pubsub-error";
var PUBSUB_RECONNECTION_ATTEMPT = "pubsub-reconnection-attempt";
var PUBSUB_RECONNECTION_FAILED = "pubsub-reconnection-failed";
var PUBSUB_RECONNECTION_SCHEDULED = "pubsub-reconnection-scheduled";
var PUBSUB_RECONNECTION_SUCCEEDED = "pubsub-reconnection-succeeded";
var PUBSUB_SUBSCRIPTION_SUCCEEDED = "pubsub-subscription-succeeded";
function createClient(url2, options3 = {}) {
  const client = {
    customEventHandlers: options3.handlers || {},
    // The current number of connection attempts that failed.
    // Reset to 0 upon successful connection.
    // Used to compute how long to wait before the next reconnection attempt.
    failedConnectionAttempts: 0,
    isLocal: /\/\/(localhost|127\.0\.0\.1)([:?/]|$)/.test(url2),
    // True if this client has never been connected yet.
    isNew: true,
    listeners: /* @__PURE__ */ Object.create(null),
    messageHandlers: {
      ...defaultMessageHandlers,
      ...options3.messageHandlers
    },
    nextConnectionAttemptDelayID: void 0,
    options: {
      ...defaultOptions,
      ...options3
    },
    // Requested subscriptions for which we didn't receive a response yet.
    pendingSubscriptionSet: /* @__PURE__ */ new Set(),
    pendingUnsubscriptionSet: /* @__PURE__ */ new Set(),
    pingTimeoutID: void 0,
    shouldReconnect: true,
    // The underlying WebSocket object.
    // A new one is necessary for every connection or reconnection attempt.
    socket: null,
    subscriptionSet: /* @__PURE__ */ new Set(),
    kvFilter: /* @__PURE__ */ new Map(),
    connectionTimeoutID: void 0,
    url: url2.replace(/^http/, "ws"),
    ...publicMethods
  };
  for (const name of Object.keys(defaultClientEventHandlers)) {
    client.listeners[name] = (event) => {
      try {
        ;
        defaultClientEventHandlers[name].call(client, event);
        client.customEventHandlers[name]?.call(client, event);
      } catch (error40) {
        esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, error40?.message);
      }
    };
  }
  if (typeof self === "object" && self instanceof EventTarget) {
    for (const name of globalEventNames) {
      globalEventMap.set(name, client.listeners[name]);
    }
  }
  if (!client.options.manual) {
    client.connect();
  }
  return client;
}
function createMessage(type, data, meta) {
  const message = {
    ...meta,
    type,
    data
  };
  let string4;
  const stringify2 = function() {
    if (!string4) string4 = JSON.stringify(this);
    return string4;
  };
  Object.defineProperties(message, {
    [Symbol.toPrimitive]: {
      value: stringify2
    }
  });
  return message;
}
function createKvMessage(channelID, key, data) {
  return JSON.stringify({
    type: NOTIFICATION_TYPE.KV,
    channelID,
    key,
    data
  });
}
function createPubMessage(channelID, data) {
  return JSON.stringify({
    type: NOTIFICATION_TYPE.PUB,
    channelID,
    data
  });
}
function createRequest(type, data) {
  return JSON.stringify(Object.assign({
    type
  }, data));
}
var defaultClientEventHandlers = {
  // Emitted when the connection is closed.
  close(event) {
    const client = this;
    console.debug("[pubsub] Event: close", event.code, event.reason);
    client.failedConnectionAttempts++;
    if (client.socket) {
      for (const name of socketEventNames) {
        client.socket.removeEventListener(name, client.listeners[name]);
      }
    }
    client.socket = null;
    client.clearAllTimers();
    if (client.shouldReconnect) {
      client.subscriptionSet.forEach((channelID) => {
        if (!client.pendingUnsubscriptionSet.has(channelID)) {
          client.pendingSubscriptionSet.add(channelID);
        }
      });
    }
    client.subscriptionSet.clear();
    client.pendingUnsubscriptionSet.clear();
    if (client.shouldReconnect && client.options.reconnectOnDisconnection) {
      if (client.failedConnectionAttempts > client.options.maxRetries) {
        esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_FAILED, client);
      } else {
        if (!isDefinetelyOffline() || client.isLocal) {
          client.scheduleConnectionAttempt();
        }
      }
    }
  },
  // Emitted when an error has occured.
  // The socket will be closed automatically by the engine if necessary.
  error(event) {
    const client = this;
    console.warn("[pubsub] Event: error", event);
    clearTimeout(client.pingTimeoutID);
  },
  // Emitted when a message is received.
  // The connection will be terminated if the message is malformed or has an
  // unexpected data type (e.g. binary instead of text).
  message(event) {
    const client = this;
    const { data } = event;
    if (typeof data !== "string") {
      esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, {
        message: `Wrong data type: ${typeof data}`
      });
      return client.destroy();
    }
    let msg = {
      type: ""
    };
    try {
      msg = messageParser(data);
    } catch (error40) {
      esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, {
        message: `Malformed message: ${error40?.message}`
      });
      return client.destroy();
    }
    const handler = client.messageHandlers[msg.type];
    if (handler) {
      handler.call(client, msg);
    } else {
      throw new Error(`Unhandled message type: ${msg.type}`);
    }
  },
  offline() {
    console.info("[pubsub] Event: offline");
    const client = this;
    client.clearAllTimers();
    client.failedConnectionAttempts = 0;
    client.socket?.close();
  },
  online() {
    console.info("[pubsub] Event: online");
    const client = this;
    if (client.options.reconnectOnOnline && client.shouldReconnect) {
      if (!client.socket) {
        client.failedConnectionAttempts = 0;
        client.scheduleConnectionAttempt();
      }
    }
  },
  // Emitted when the connection is established.
  open() {
    console.debug("[pubsub] Event: open");
    const client = this;
    const { options: options3 } = this;
    client.connectionTimeUsed = void 0;
    client.clearAllTimers();
    esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_SUCCEEDED, client);
    client.failedConnectionAttempts = -1;
    client.isNew = false;
    if (options3.pingTimeout > 0 && options3.pingTimeout < Infinity) {
      client.pingTimeoutID = setTimeout(() => {
        client.socket?.close();
      }, options3.pingTimeout);
    }
    client.pendingSubscriptionSet.forEach((channelID) => {
      const kvFilter = this.kvFilter.get(channelID);
      client.socket?.send(createRequest(REQUEST_TYPE.SUB, kvFilter ? {
        channelID,
        kvFilter
      } : {
        channelID
      }));
    });
  },
  "reconnection-attempt"() {
    console.info("[pubsub] Trying to reconnect...");
  },
  "reconnection-succeeded"() {
    console.info("[pubsub] Connection re-established");
  },
  "reconnection-failed"() {
    console.warn("[pubsub] Reconnection failed");
    const client = this;
    client.destroy();
  },
  "reconnection-scheduled"(event) {
    const { delay: delay2, nth } = event.detail;
    console.info(`[pubsub] Scheduled connection attempt ${nth} in ~${delay2} ms`);
  },
  "subscription-succeeded"(event) {
    const { channelID } = event.detail;
    console.debug(`[pubsub] Subscribed to channel ${channelID}`);
  }
};
var defaultMessageHandlers = {
  [NOTIFICATION_TYPE.ENTRY](msg) {
    console.debug("[pubsub] Received ENTRY:", msg);
  },
  [NOTIFICATION_TYPE.PING]({ data }) {
    const client = this;
    if (client.options.logPingMessages) {
      console.debug(`[pubsub] Ping received in ${Date.now() - Number(data)} ms`);
    }
    client.socket?.send(createMessage(NOTIFICATION_TYPE.PONG, data));
    clearTimeout(client.pingTimeoutID);
    client.pingTimeoutID = setTimeout(() => {
      client.socket?.close();
    }, client.options.pingTimeout);
  },
  [NOTIFICATION_TYPE.PUB]({ channelID, data }) {
    console.log(`[pubsub] Received data from channel ${channelID}:`, data);
  },
  [NOTIFICATION_TYPE.KV]({ channelID, key, data }) {
    console.log(`[pubsub] Received KV update from channel ${channelID} ${key}:`, data);
  },
  [NOTIFICATION_TYPE.SUB](msg) {
    console.debug(`[pubsub] Ignoring ${msg.type} message:`, msg.data);
  },
  [NOTIFICATION_TYPE.UNSUB](msg) {
    console.debug(`[pubsub] Ignoring ${msg.type} message:`, msg.data);
  },
  [RESPONSE_TYPE.ERROR]({ data }) {
    const { type, channelID, reason } = data;
    console.warn(`[pubsub] Received ERROR response for ${type} request to ${channelID}`);
    const client = this;
    switch (type) {
      case REQUEST_TYPE.SUB: {
        console.warn(`[pubsub] Could not subscribe to ${channelID}: ${reason}`);
        client.pendingSubscriptionSet.delete(channelID);
        break;
      }
      case REQUEST_TYPE.UNSUB: {
        console.warn(`[pubsub] Could not unsubscribe from ${channelID}: ${reason}`);
        client.pendingUnsubscriptionSet.delete(channelID);
        break;
      }
      case REQUEST_TYPE.PUSH_ACTION: {
        const { actionType, message } = data;
        console.warn(`[pubsub] Received ERROR for PUSH_ACTION request with the action type '${actionType}' and the following message: ${message}`);
        break;
      }
      default: {
        console.error(`[pubsub] Malformed response: invalid request type ${type}`);
      }
    }
  },
  [RESPONSE_TYPE.OK]({ data: { type, channelID } }) {
    const client = this;
    switch (type) {
      case REQUEST_TYPE.SUB: {
        client.pendingSubscriptionSet.delete(channelID);
        client.subscriptionSet.add(channelID);
        esm_default("okTurtles.events/emit", PUBSUB_SUBSCRIPTION_SUCCEEDED, client, {
          channelID
        });
        break;
      }
      case REQUEST_TYPE.UNSUB: {
        console.debug(`[pubsub] Unsubscribed from ${channelID}`);
        client.pendingUnsubscriptionSet.delete(channelID);
        client.subscriptionSet.delete(channelID);
        client.kvFilter.delete(channelID);
        break;
      }
      case REQUEST_TYPE.KV_FILTER: {
        console.debug(`[pubsub] Set KV filter for ${channelID}`);
        break;
      }
      default: {
        console.error(`[pubsub] Malformed response: invalid request type ${type}`);
      }
    }
  }
};
var globalEventNames = [
  "offline",
  "online"
];
var socketEventNames = [
  "close",
  "error",
  "message",
  "open"
];
var globalEventMap = /* @__PURE__ */ new Map();
if (typeof self === "object" && self instanceof EventTarget) {
  for (const name of globalEventNames) {
    const handler = (ev) => {
      const h2 = globalEventMap.get(name);
      return h2?.(ev);
    };
    self.addEventListener(name, handler, false);
  }
}
var isDefinetelyOffline = () => typeof navigator === "object" && navigator.onLine === false;
var messageParser = (data) => {
  const msg = JSON.parse(data);
  if (typeof msg !== "object" || msg === null) {
    throw new TypeError("Message is null or not an object");
  }
  const { type } = msg;
  if (typeof type !== "string" || type === "") {
    throw new TypeError("Message type must be a non-empty string");
  }
  return msg;
};
var publicMethods = {
  clearAllTimers() {
    const client = this;
    clearTimeout(client.connectionTimeoutID);
    clearTimeout(client.nextConnectionAttemptDelayID);
    clearTimeout(client.pingTimeoutID);
    client.connectionTimeoutID = void 0;
    client.nextConnectionAttemptDelayID = void 0;
    client.pingTimeoutID = void 0;
  },
  // Performs a connection or reconnection attempt.
  connect() {
    const client = this;
    if (client.socket !== null) {
      throw new Error("connect() can only be called if there is no current socket.");
    }
    if (client.nextConnectionAttemptDelayID) {
      throw new Error("connect() must not be called during a reconnection delay.");
    }
    if (!client.shouldReconnect) {
      throw new Error("connect() should no longer be called on this instance.");
    }
    client.socket = new WebSocket(client.url);
    client.socket.send = function(data) {
      const send = WebSocket.prototype.send.bind(this);
      if (typeof data === "object" && typeof data[Symbol.toPrimitive] === "function") {
        return send(data[Symbol.toPrimitive]());
      }
      return send(data);
    };
    if (client.options.timeout) {
      const start = performance.now();
      client.connectionTimeoutID = setTimeout(() => {
        client.connectionTimeoutID = void 0;
        if (client.options.reconnectOnTimeout) {
          client.connectionTimeUsed = performance.now() - start;
        }
        client.socket?.close(4e3, "timeout");
      }, client.options.timeout);
    }
    for (const name of socketEventNames) {
      client.socket.addEventListener(name, client.listeners[name]);
    }
  },
  /**
     * Immediately close the socket, stop listening for events and clear any cache.
     *
     * This method is used in unit tests.
     * - In particular, no 'close' event handler will be called.
     * - Any incoming or outgoing buffered data will be discarded.
     * - Any pending messages will be discarded.
     */
  destroy() {
    const client = this;
    client.clearAllTimers();
    client.pendingSubscriptionSet.clear();
    client.pendingUnsubscriptionSet.clear();
    client.subscriptionSet.clear();
    if (typeof self === "object" && self instanceof EventTarget) {
      for (const name of globalEventNames) {
        globalEventMap.delete(name);
      }
    }
    if (client.socket) {
      for (const name of socketEventNames) {
        client.socket.removeEventListener(name, client.listeners[name]);
      }
      client.socket.close();
    }
    client.listeners = /* @__PURE__ */ Object.create(null);
    client.socket = null;
    client.shouldReconnect = false;
  },
  getNextRandomDelay() {
    const client = this;
    const { maxReconnectionDelay, minReconnectionDelay, reconnectionDelayGrowFactor } = client.options;
    const minDelay = minReconnectionDelay * reconnectionDelayGrowFactor ** client.failedConnectionAttempts;
    const maxDelay = minDelay * reconnectionDelayGrowFactor;
    const connectionTimeUsed = client.connectionTimeUsed;
    client.connectionTimeUsed = void 0;
    return Math.min(
      // See issue #1943: Have the connection time used 'eat into' the
      // reconnection time used
      Math.max(minReconnectionDelay, connectionTimeUsed ? maxReconnectionDelay - connectionTimeUsed : maxReconnectionDelay),
      Math.round(minDelay + (0, Math.random)() * (maxDelay - minDelay))
    );
  },
  // Schedules a connection attempt to happen after a delay computed according to
  // a randomized exponential backoff algorithm variant.
  scheduleConnectionAttempt() {
    const client = this;
    if (!client.shouldReconnect) {
      throw new Error("Cannot call `scheduleConnectionAttempt()` when `shouldReconnect` is false.");
    }
    if (client.nextConnectionAttemptDelayID) {
      return console.warn("[pubsub] A reconnection attempt is already scheduled.");
    }
    const delay2 = client.getNextRandomDelay();
    const nth = client.failedConnectionAttempts + 1;
    client.nextConnectionAttemptDelayID = setTimeout(() => {
      esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_ATTEMPT, client);
      client.nextConnectionAttemptDelayID = void 0;
      client.connect();
    }, delay2);
    esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_SCHEDULED, client, {
      delay: delay2,
      nth
    });
  },
  // Can be used to send ephemeral messages outside of any contract log.
  // Does nothing if the socket is not in the OPEN state.
  pub(channelID, data) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(createPubMessage(channelID, data));
    }
  },
  /**
     * Sends a SUB request to the server as soon as possible.
     *
     * - The given channel ID will be cached until we get a relevant server
     * response, allowing us to resend the same request if necessary.
     * - Any identical UNSUB request that has not been sent yet will be cancelled.
     * - Calling this method again before the server has responded has no effect.
     * @param channelID - The ID of the channel whose updates we want to subscribe to.
     */
  sub(channelID) {
    const client = this;
    const { socket } = this;
    if (!client.pendingSubscriptionSet.has(channelID)) {
      client.pendingSubscriptionSet.add(channelID);
      client.pendingUnsubscriptionSet.delete(channelID);
      if (socket?.readyState === WebSocket.OPEN) {
        const kvFilter = client.kvFilter.get(channelID);
        socket.send(createRequest(REQUEST_TYPE.SUB, kvFilter ? {
          channelID,
          kvFilter
        } : {
          channelID
        }));
      }
    }
  },
  /**
     * Sends a KV_FILTER request to the server as soon as possible.
     */
  setKvFilter(channelID, kvFilter) {
    const client = this;
    const { socket } = this;
    if (kvFilter) {
      client.kvFilter.set(channelID, kvFilter);
    } else {
      client.kvFilter.delete(channelID);
    }
    if (client.subscriptionSet.has(channelID)) {
      if (socket?.readyState === WebSocket.OPEN) {
        socket.send(createRequest(REQUEST_TYPE.KV_FILTER, kvFilter ? {
          channelID,
          kvFilter
        } : {
          channelID
        }));
      }
    }
  },
  /**
     * Sends an UNSUB request to the server as soon as possible.
     *
     * - The given channel ID will be cached until we get a relevant server
     * response, allowing us to resend the same request if necessary.
     * - Any identical SUB request that has not been sent yet will be cancelled.
     * - Calling this method again before the server has responded has no effect.
     * @param channelID - The ID of the channel whose updates we want to unsubscribe from.
     */
  unsub(channelID) {
    const client = this;
    const { socket } = this;
    if (!client.pendingUnsubscriptionSet.has(channelID)) {
      client.pendingSubscriptionSet.delete(channelID);
      client.pendingUnsubscriptionSet.add(channelID);
      if (socket?.readyState === WebSocket.OPEN) {
        socket.send(createRequest(REQUEST_TYPE.UNSUB, {
          channelID
        }));
      }
    }
  }
};
for (const name of Object.keys(defaultClientEventHandlers)) {
  if (name === "error" || !socketEventNames.includes(name)) {
    esm_default("okTurtles.events/on", `pubsub-${name}`, (target, detail) => {
      const ev = new CustomEvent(name, {
        detail
      });
      target.listeners[name].call(target, ev);
    });
  }
}

// node_modules/.deno/@chelonia+crypto@1.0.1/node_modules/@chelonia/crypto/dist/esm/index.mjs
var import_scrypt_async = __toESM(require_scrypt_async(), 1);
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var bufToStr = (() => {
  const textDecoder = new TextDecoder();
  return (buf2) => {
    return textDecoder.decode(buf2);
  };
})();
var strToBuf2 = (() => {
  const textEncoder = new TextEncoder();
  return (str) => {
    return textEncoder.encode(str);
  };
})();
var blake32Hash2 = (data) => {
  const uint8array = typeof data === "string" ? strToBuf2(data) : data;
  const digest = blake2b2562.digest(uint8array);
  return base58btc3.encode(digest.bytes);
};
var b64ToBuf2 = (data) => new Uint8Array(atob(data).split("").map((b) => b.charCodeAt(0)));
var ENULL = "eNULL";
var SNULL = "sNULL";
var EDWARDS25519SHA512BATCH = "edwards25519sha512batch";
var CURVE25519XSALSA20POLY1305 = "curve25519xsalsa20poly1305";
var XSALSA20POLY1305 = "xsalsa20poly1305";
var EXTERNALKM32 = "externalkm32";
if (false) {
  throw new Error("ENABLE_UNSAFE_NULL_CRYPTO cannot be enabled in production mode");
}
var bytesOrObjectToB64 = (ary) => {
  if (!(ary instanceof Uint8Array)) {
    throw TypeError("Unsupported type");
  }
  return btoa(Array.from(ary).map((c) => String.fromCharCode(c)).join(""));
};
var keygen = (type) => {
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (type === ENULL || type === SNULL)) {
    const res = {
      type,
      publicKey: bytesOrObjectToB64(import_tweetnacl.default.randomBytes(18))
    };
    Object.defineProperty(res, "secretKey", {
      value: res.publicKey
    });
    return res;
  }
  if (type === EDWARDS25519SHA512BATCH) {
    const key = import_tweetnacl.default.sign.keyPair();
    const res = {
      type,
      publicKey: key.publicKey
    };
    Object.defineProperty(res, "secretKey", {
      value: key.secretKey
    });
    return res;
  } else if (type === CURVE25519XSALSA20POLY1305) {
    const key = import_tweetnacl.default.box.keyPair();
    const res = {
      type,
      publicKey: key.publicKey
    };
    Object.defineProperty(res, "secretKey", {
      value: key.secretKey
    });
    return res;
  } else if (type === XSALSA20POLY1305) {
    const res = {
      type
    };
    Object.defineProperty(res, "secretKey", {
      value: import_tweetnacl.default.randomBytes(import_tweetnacl.default.secretbox.keyLength)
    });
    return res;
  } else if (type === EXTERNALKM32) {
    const res = {
      type
    };
    Object.defineProperty(res, "secretKey", {
      value: import_tweetnacl.default.randomBytes(32)
    });
    return res;
  }
  throw new Error("Unsupported key type");
};
var generateSalt = () => {
  return bytesOrObjectToB64(import_tweetnacl.default.randomBytes(18));
};
var deriveKeyFromPassword = (type, password, salt) => {
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (type === ENULL || type === SNULL)) {
    const v2 = blake32Hash2(blake32Hash2(salt) + blake32Hash2(password));
    return Promise.resolve({
      type,
      secretKey: v2,
      publicKey: v2
    });
  }
  if (![
    EDWARDS25519SHA512BATCH,
    CURVE25519XSALSA20POLY1305,
    XSALSA20POLY1305
  ].includes(type)) {
    return Promise.reject(new Error("Unsupported type"));
  }
  return new Promise((resolve7) => {
    (0, import_scrypt_async.default)(password, salt, {
      N: 16384,
      r: 8,
      p: 1,
      dkLen: type === EDWARDS25519SHA512BATCH ? import_tweetnacl.default.sign.seedLength : type === CURVE25519XSALSA20POLY1305 ? import_tweetnacl.default.box.secretKeyLength : type === XSALSA20POLY1305 ? import_tweetnacl.default.secretbox.keyLength : 0,
      encoding: "binary"
    }, (derivedKey) => {
      const buffer = new Uint8Array(derivedKey);
      if (type === EDWARDS25519SHA512BATCH) {
        const key = import_tweetnacl.default.sign.keyPair.fromSeed(buffer);
        resolve7({
          type,
          secretKey: key.secretKey,
          publicKey: key.publicKey
        });
      } else if (type === CURVE25519XSALSA20POLY1305) {
        const key = import_tweetnacl.default.box.keyPair.fromSecretKey(buffer);
        resolve7({
          type,
          secretKey: key.secretKey,
          publicKey: key.publicKey
        });
      } else if (type === XSALSA20POLY1305) {
        resolve7({
          type,
          secretKey: buffer
        });
      }
    });
  });
};
var serializeKey = (key, saveSecretKey) => {
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (key.type === ENULL || key.type === SNULL)) {
    return JSON.stringify([
      key.type,
      saveSecretKey ? null : key.publicKey,
      saveSecretKey ? key.secretKey : null
    ], void 0, 0);
  }
  if (key.type === EDWARDS25519SHA512BATCH || key.type === CURVE25519XSALSA20POLY1305) {
    if (!saveSecretKey) {
      if (!key.publicKey) {
        throw new Error("Unsupported operation: no public key to export");
      }
      return JSON.stringify([
        key.type,
        bytesOrObjectToB64(key.publicKey),
        null
      ], void 0, 0);
    }
    if (!key.secretKey) {
      throw new Error("Unsupported operation: no secret key to export");
    }
    return JSON.stringify([
      key.type,
      null,
      bytesOrObjectToB64(key.secretKey)
    ], void 0, 0);
  } else if (key.type === XSALSA20POLY1305) {
    if (!saveSecretKey) {
      throw new Error("Unsupported operation: no public key to export");
    }
    if (!key.secretKey) {
      throw new Error("Unsupported operation: no secret key to export");
    }
    return JSON.stringify([
      key.type,
      null,
      bytesOrObjectToB64(key.secretKey)
    ], void 0, 0);
  }
  throw new Error("Unsupported key type");
};
var deserializeKey = (data) => {
  const keyData = JSON.parse(data);
  if (!keyData || keyData.length !== 3) {
    throw new Error("Invalid key object");
  }
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (keyData[0] === ENULL || keyData[0] === SNULL)) {
    const res = {
      type: keyData[0]
    };
    if (keyData[2]) {
      Object.defineProperty(res, "secretKey", {
        value: keyData[2]
      });
      res.publicKey = keyData[2];
    } else {
      res.publicKey = keyData[1];
    }
    return res;
  }
  if (keyData[0] === EDWARDS25519SHA512BATCH) {
    if (keyData[2]) {
      const key = import_tweetnacl.default.sign.keyPair.fromSecretKey(b64ToBuf2(keyData[2]));
      const res = {
        type: keyData[0],
        publicKey: key.publicKey
      };
      Object.defineProperty(res, "secretKey", {
        value: key.secretKey
      });
      return res;
    } else if (keyData[1]) {
      return {
        type: keyData[0],
        publicKey: new Uint8Array(b64ToBuf2(keyData[1]))
      };
    }
    throw new Error("Missing secret or public key");
  } else if (keyData[0] === CURVE25519XSALSA20POLY1305) {
    if (keyData[2]) {
      const key = import_tweetnacl.default.box.keyPair.fromSecretKey(b64ToBuf2(keyData[2]));
      const res = {
        type: keyData[0],
        publicKey: key.publicKey
      };
      Object.defineProperty(res, "secretKey", {
        value: key.secretKey
      });
      return res;
    } else if (keyData[1]) {
      return {
        type: keyData[0],
        publicKey: new Uint8Array(b64ToBuf2(keyData[1]))
      };
    }
    throw new Error("Missing secret or public key");
  } else if (keyData[0] === XSALSA20POLY1305) {
    if (!keyData[2]) {
      throw new Error("Secret key missing");
    }
    const res = {
      type: keyData[0]
    };
    Object.defineProperty(res, "secretKey", {
      value: new Uint8Array(b64ToBuf2(keyData[2]))
    });
    return res;
  }
  throw new Error("Unsupported key type");
};
var keygenOfSameType = (inKey) => {
  const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
  return keygen(key.type);
};
var keyId = (inKey) => {
  const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
  const serializedKey = serializeKey(key, !key.publicKey);
  return blake32Hash2(serializedKey);
};
var sign = (inKey, data) => {
  const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === SNULL) {
    if (!key.secretKey) {
      throw new Error("Secret key missing");
    }
    return key.secretKey + ";" + blake32Hash2(data);
  }
  if (key.type !== EDWARDS25519SHA512BATCH) {
    throw new Error("Unsupported algorithm");
  }
  if (!key.secretKey) {
    throw new Error("Secret key missing");
  }
  const messageUint8 = strToBuf2(data);
  const signature = import_tweetnacl.default.sign.detached(messageUint8, key.secretKey);
  const base64Signature = bytesOrObjectToB64(signature);
  return base64Signature;
};
var verifySignature = (inKey, data, signature) => {
  const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === SNULL) {
    if (!key.publicKey) {
      throw new Error("Public key missing");
    }
    if (key.publicKey + ";" + blake32Hash2(data) !== signature) {
      throw new Error("Invalid signature");
    }
    return;
  }
  if (key.type !== EDWARDS25519SHA512BATCH) {
    throw new Error("Unsupported algorithm");
  }
  if (!key.publicKey) {
    throw new Error("Public key missing");
  }
  const decodedSignature = b64ToBuf2(signature);
  const messageUint8 = strToBuf2(data);
  const result = import_tweetnacl.default.sign.detached.verify(messageUint8, decodedSignature, key.publicKey);
  if (!result) {
    throw new Error("Invalid signature");
  }
};
var encrypt = (inKey, data, ad) => {
  const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === ENULL) {
    if (!key.publicKey) {
      throw new Error("Public key missing");
    }
    return `${key.publicKey};${data};${ad !== null && ad !== void 0 ? ad : ""}`;
  }
  if (key.type === XSALSA20POLY1305) {
    if (!key.secretKey) {
      throw new Error("Secret key missing");
    }
    const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.secretbox.nonceLength);
    let encryptionNonce;
    if (ad) {
      encryptionNonce = new Uint8Array(nonce);
      const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
      const len = Math.min(adHash.length, nonce.length);
      for (let i2 = 0; i2 < len; i2++) {
        encryptionNonce[i2] ^= adHash[i2];
      }
    } else {
      encryptionNonce = nonce;
    }
    const messageUint8 = strToBuf2(data);
    const box = import_tweetnacl.default.secretbox(messageUint8, encryptionNonce, key.secretKey);
    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);
    const base64FullMessage = bytesOrObjectToB64(fullMessage);
    return base64FullMessage;
  } else if (key.type === CURVE25519XSALSA20POLY1305) {
    if (!key.publicKey) {
      throw new Error("Public key missing");
    }
    const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
    let encryptionNonce;
    if (ad) {
      encryptionNonce = new Uint8Array(nonce);
      const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
      const len = Math.min(adHash.length, nonce.length);
      for (let i2 = 0; i2 < len; i2++) {
        encryptionNonce[i2] ^= adHash[i2];
      }
    } else {
      encryptionNonce = nonce;
    }
    const messageUint8 = strToBuf2(data);
    const ephemeralKey = import_tweetnacl.default.box.keyPair();
    const box = import_tweetnacl.default.box(messageUint8, encryptionNonce, key.publicKey, ephemeralKey.secretKey);
    crypto.getRandomValues(ephemeralKey.secretKey);
    ephemeralKey.secretKey.fill(0);
    const fullMessage = new Uint8Array(import_tweetnacl.default.box.publicKeyLength + nonce.length + box.length);
    fullMessage.set(ephemeralKey.publicKey);
    fullMessage.set(nonce, import_tweetnacl.default.box.publicKeyLength);
    fullMessage.set(box, import_tweetnacl.default.box.publicKeyLength + nonce.length);
    const base64FullMessage = bytesOrObjectToB64(fullMessage);
    return base64FullMessage;
  }
  throw new Error("Unsupported algorithm");
};
var decrypt = (inKey, data, ad) => {
  const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
  if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === ENULL) {
    if (!key.secretKey) {
      throw new Error("Secret key missing");
    }
    if (!data.startsWith(key.secretKey + ";") || !data.endsWith(";" + (ad !== null && ad !== void 0 ? ad : ""))) {
      throw new Error("Additional data mismatch");
    }
    return data.slice(String(key.secretKey).length + 1, data.length - 1 - (ad !== null && ad !== void 0 ? ad : "").length);
  }
  if (key.type === XSALSA20POLY1305) {
    if (!key.secretKey) {
      throw new Error("Secret key missing");
    }
    const messageWithNonceAsUint8Array = b64ToBuf2(data);
    const nonce = messageWithNonceAsUint8Array.slice(0, import_tweetnacl.default.secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.secretbox.nonceLength, messageWithNonceAsUint8Array.length);
    if (ad) {
      const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
      const len = Math.min(adHash.length, nonce.length);
      for (let i2 = 0; i2 < len; i2++) {
        nonce[i2] ^= adHash[i2];
      }
    }
    const decrypted = import_tweetnacl.default.secretbox.open(message, nonce, key.secretKey);
    if (!decrypted) {
      throw new Error("Could not decrypt message");
    }
    return bufToStr(decrypted);
  } else if (key.type === CURVE25519XSALSA20POLY1305) {
    if (!key.secretKey) {
      throw new Error("Secret key missing");
    }
    const messageWithNonceAsUint8Array = b64ToBuf2(data);
    const ephemeralPublicKey = messageWithNonceAsUint8Array.slice(0, import_tweetnacl.default.box.publicKeyLength);
    const nonce = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.box.publicKeyLength, import_tweetnacl.default.box.publicKeyLength + import_tweetnacl.default.box.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.box.publicKeyLength + import_tweetnacl.default.box.nonceLength);
    if (ad) {
      const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
      const len = Math.min(adHash.length, nonce.length);
      for (let i2 = 0; i2 < len; i2++) {
        nonce[i2] ^= adHash[i2];
      }
    }
    const decrypted = import_tweetnacl.default.box.open(message, nonce, ephemeralPublicKey, key.secretKey);
    if (!decrypted) {
      throw new Error("Could not decrypt message");
    }
    return bufToStr(decrypted);
  }
  throw new Error("Unsupported algorithm");
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/errors.mjs
var ChelErrorGenerator = (name, base4 = Error) => class extends base4 {
  constructor(...params) {
    super(...params);
    this.name = name;
    if (params[1]?.cause !== this.cause) {
      Object.defineProperty(this, "cause", {
        configurable: true,
        writable: true,
        value: params[1]?.cause
      });
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var ChelErrorWarning = ChelErrorGenerator("ChelErrorWarning");
var ChelErrorAlreadyProcessed = ChelErrorGenerator("ChelErrorAlreadyProcessed");
var ChelErrorDBBadPreviousHEAD = ChelErrorGenerator("ChelErrorDBBadPreviousHEAD");
var ChelErrorDBConnection = ChelErrorGenerator("ChelErrorDBConnection");
var ChelErrorUnexpected = ChelErrorGenerator("ChelErrorUnexpected");
var ChelErrorKeyAlreadyExists = ChelErrorGenerator("ChelErrorKeyAlreadyExists");
var ChelErrorUnrecoverable = ChelErrorGenerator("ChelErrorUnrecoverable");
var ChelErrorForkedChain = ChelErrorGenerator("ChelErrorForkedChain");
var ChelErrorDecryptionError = ChelErrorGenerator("ChelErrorDecryptionError");
var ChelErrorDecryptionKeyNotFound = ChelErrorGenerator("ChelErrorDecryptionKeyNotFound", ChelErrorDecryptionError);
var ChelErrorSignatureError = ChelErrorGenerator("ChelErrorSignatureError");
var ChelErrorSignatureKeyUnauthorized = ChelErrorGenerator("ChelErrorSignatureKeyUnauthorized", ChelErrorSignatureError);
var ChelErrorSignatureKeyNotFound = ChelErrorGenerator("ChelErrorSignatureKeyNotFound", ChelErrorSignatureError);
var ChelErrorFetchServerTimeFailed = ChelErrorGenerator("ChelErrorFetchServerTimeFailed");
var ChelErrorUnexpectedHttpResponseCode = ChelErrorGenerator("ChelErrorUnexpectedHttpResponseCode");
var ChelErrorResourceGone = ChelErrorGenerator("ChelErrorResourceGone", ChelErrorUnexpectedHttpResponseCode);

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/events.mjs
var CHELONIA_RESET = "chelonia-reset";
var CONTRACT_IS_SYNCING = "contract-is-syncing";
var CONTRACTS_MODIFIED = "contracts-modified";
var EVENT_HANDLED = "event-handled";
var EVENT_PUBLISHED = "event-published";
var EVENT_PUBLISHING_ERROR = "event-publishing-error";
var CONTRACT_REGISTERED = "contract-registered";
var CONTRACT_IS_PENDING_KEY_REQUESTS = "contract-is-pending-key-requests";
var CONTRACT_HAS_RECEIVED_KEYS = "contract-has-received-keys";
var PERSISTENT_ACTION_FAILURE = "persistent-action-failure";
var PERSISTENT_ACTION_SUCCESS = "persistent-action-success";
var PERSISTENT_ACTION_TOTAL_FAILURE = "persistent-action-total_failure";

// node_modules/.deno/@chelonia+serdes@1.0.0/node_modules/@chelonia/serdes/dist/esm/index.js
var serdesTagSymbol = Symbol("tag");
var serdesSerializeSymbol = Symbol("serialize");
var serdesDeserializeSymbol = Symbol("deserialize");
var rawResult = (rawResultSet, obj) => {
  rawResultSet.add(obj);
  return obj;
};
var serializer = (data) => {
  const rawResultSet = /* @__PURE__ */ new WeakSet();
  const verbatim = [];
  const transferables = /* @__PURE__ */ new Set();
  const revokables = /* @__PURE__ */ new Set();
  const result = JSON.parse(JSON.stringify(data, (_key, value) => {
    if (value && typeof value === "object" && rawResultSet.has(value)) return value;
    if (value === void 0) return rawResult(rawResultSet, [
      "_",
      "_"
    ]);
    if (!value) return value;
    if (Array.isArray(value) && value[0] === "_") return rawResult(rawResultSet, [
      "_",
      "_",
      ...value
    ]);
    if (value instanceof Map) {
      return rawResult(rawResultSet, [
        "_",
        "Map",
        Array.from(value.entries())
      ]);
    }
    if (value instanceof Set) {
      return rawResult(rawResultSet, [
        "_",
        "Set",
        Array.from(value.values())
      ]);
    }
    if (value instanceof Blob || value instanceof File) {
      const pos = verbatim.length;
      verbatim[verbatim.length] = value;
      return rawResult(rawResultSet, [
        "_",
        "_ref",
        pos
      ]);
    }
    if (value instanceof Error) {
      const pos = verbatim.length;
      verbatim[verbatim.length] = value;
      if (value.cause) {
        value.cause = serializer(value.cause).data;
      }
      return rawResult(rawResultSet, [
        "_",
        "_err",
        rawResult(rawResultSet, [
          "_",
          "_ref",
          pos
        ]),
        value.name
      ]);
    }
    if (value instanceof MessagePort || value instanceof ReadableStream || value instanceof WritableStream || value instanceof ArrayBuffer) {
      const pos = verbatim.length;
      verbatim[verbatim.length] = value;
      transferables.add(value);
      return rawResult(rawResultSet, [
        "_",
        "_ref",
        pos
      ]);
    }
    if (ArrayBuffer.isView(value)) {
      const pos = verbatim.length;
      verbatim[verbatim.length] = value;
      transferables.add(value.buffer);
      return rawResult(rawResultSet, [
        "_",
        "_ref",
        pos
      ]);
    }
    if (typeof value === "function") {
      const mc = new MessageChannel();
      mc.port1.onmessage = async (ev) => {
        try {
          try {
            const result2 = await value(...deserializer(ev.data[1]));
            const { data: data2, transferables: transferables2 } = serializer(result2);
            ev.data[0].postMessage([
              true,
              data2
            ], transferables2);
          } catch (e2) {
            const { data: data2, transferables: transferables2 } = serializer(e2);
            ev.data[0].postMessage([
              false,
              data2
            ], transferables2);
          }
        } catch (e2) {
          console.error("Async error on onmessage handler", e2);
        }
      };
      transferables.add(mc.port2);
      revokables.add(mc.port1);
      return rawResult(rawResultSet, [
        "_",
        "_fn",
        mc.port2
      ]);
    }
    const proto3 = Object.getPrototypeOf(value);
    if (proto3?.constructor?.[serdesTagSymbol] && proto3.constructor[serdesSerializeSymbol]) {
      return rawResult(rawResultSet, [
        "_",
        "_custom",
        proto3.constructor[serdesTagSymbol],
        proto3.constructor[serdesSerializeSymbol](value)
      ]);
    }
    return value;
  }), (_key, value) => {
    if (Array.isArray(value) && value[0] === "_" && value[1] === "_ref") {
      return verbatim[value[2]];
    }
    return value;
  });
  return {
    data: result,
    transferables: Array.from(transferables),
    revokables: Array.from(revokables)
  };
};
var deserializerTable = /* @__PURE__ */ Object.create(null);
var deserializer = (data) => {
  const rawResultSet = /* @__PURE__ */ new WeakSet();
  const verbatim = [];
  return JSON.parse(JSON.stringify(data, (_key, value) => {
    if (value && typeof value === "object" && !rawResultSet.has(value) && !Array.isArray(value) && Object.getPrototypeOf(value) !== Object.prototype) {
      const pos = verbatim.length;
      verbatim[verbatim.length] = value;
      return rawResult(rawResultSet, [
        "_",
        "_ref",
        pos
      ]);
    }
    return value;
  }), (_key, value) => {
    if (Array.isArray(value) && value[0] === "_") {
      switch (value[1]) {
        case "_":
          if (value.length >= 3) {
            return value.slice(2);
          } else {
            return;
          }
        // Map input (reconstruct Map)
        case "Map":
          return new Map(value[2]);
        // Set input (reconstruct Set)
        case "Set":
          return new Set(value[2]);
        // Custom object type (reconstruct if possible, otherwise throw an error)
        case "_custom":
          if (deserializerTable[value[2]]) {
            return deserializerTable[value[2]](value[3]);
          } else {
            throw new Error("Invalid or unknown tag: " + value[2]);
          }
        // These are literal values, return them
        case "_ref":
          return verbatim[value[2]];
        case "_err": {
          if (value[2].name !== value[3]) {
            value[2].name = value[3];
          }
          if (value[2].cause) {
            value[2].cause = deserializer(value[2].cause);
          }
          return value[2];
        }
        // These were functions converted to a MessagePort. Convert them on this
        // end back into functions using that port.
        case "_fn": {
          const mp = value[2];
          return (...args) => {
            return new Promise((resolve7, reject) => {
              const mc = new MessageChannel();
              const { data: data2, transferables } = serializer(args);
              mc.port1.onmessage = (ev) => {
                if (ev.data[0]) {
                  resolve7(deserializer(ev.data[1]));
                } else {
                  reject(deserializer(ev.data[1]));
                }
              };
              mp.postMessage([
                mc.port2,
                data2
              ], [
                mc.port2,
                ...transferables
              ]);
            });
          };
        }
      }
    }
    return value;
  });
};
deserializer.register = (ctor) => {
  if (typeof ctor === "function" && typeof ctor[serdesTagSymbol] === "string" && typeof ctor[serdesDeserializeSymbol] === "function") {
    deserializerTable[ctor[serdesTagSymbol]] = ctor[serdesDeserializeSymbol].bind(ctor);
  }
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/signedData.mjs
var rootStateFn = () => esm_default("chelonia/rootState");
var proto = Object.create(null, {
  _isSignedData: {
    value: true
  }
});
var wrapper = (o2) => {
  return Object.setPrototypeOf(o2, proto);
};
var isSignedData = (o2) => {
  return !!o2 && !!Object.getPrototypeOf(o2)?._isSignedData;
};
var signData = function(stateOrContractID, sKeyId, data, extraFields, additionalKeys, additionalData) {
  const state = typeof stateOrContractID === "string" ? rootStateFn()[stateOrContractID] : stateOrContractID;
  if (!additionalData) {
    throw new ChelErrorSignatureError("Signature additional data must be provided");
  }
  const designatedKey = state?._vm?.authorizedKeys?.[sKeyId];
  if (!designatedKey?.purpose.includes("sig")) {
    throw new ChelErrorSignatureKeyNotFound(`Signing key ID ${sKeyId} is missing or is missing signing purpose`);
  }
  if (designatedKey._notAfterHeight != null) {
    const name = state._vm.authorizedKeys[sKeyId].name;
    const newKeyId = Object.values(state._vm?.authorizedKeys).find((v2) => v2._notAfterHeight == null && v2.name === name && v2.purpose.includes("sig"))?.id;
    if (!newKeyId) {
      throw new ChelErrorSignatureKeyNotFound(`Signing key ID ${sKeyId} has been revoked and no new key exists by the same name (${name})`);
    }
    sKeyId = newKeyId;
  }
  const key = additionalKeys[sKeyId];
  if (!key) {
    throw new ChelErrorSignatureKeyNotFound(`Missing signing key ${sKeyId}`);
  }
  const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
  const serializedData = JSON.stringify(data, (_, v2) => {
    if (v2 && has2(v2, "serialize") && typeof v2.serialize === "function") {
      if (v2.serialize.length === 1) {
        return v2.serialize(additionalData);
      } else {
        return v2.serialize();
      }
    }
    return v2;
  });
  const payloadToSign = blake32Hash(`${blake32Hash(additionalData)}${blake32Hash(serializedData)}`);
  return {
    ...extraFields,
    _signedData: [
      serializedData,
      keyId(deserializedKey),
      sign(deserializedKey, payloadToSign)
    ]
  };
};
var verifySignatureData = function(state, height, data, additionalData) {
  if (!state) {
    throw new ChelErrorSignatureError("Missing contract state");
  }
  if (!isRawSignedData(data)) {
    throw new ChelErrorSignatureError("Invalid message format");
  }
  if (!Number.isSafeInteger(height) || height < 0) {
    throw new ChelErrorSignatureError(`Height ${height} is invalid or out of range`);
  }
  const [serializedMessage, sKeyId, signature] = data._signedData;
  const designatedKey = state._vm?.authorizedKeys?.[sKeyId];
  if (!designatedKey || height > designatedKey._notAfterHeight || height < designatedKey._notBeforeHeight || !designatedKey.purpose.includes("sig")) {
    if (process.env.CI) {
      console.error(`Key ${sKeyId} is unauthorized or expired for the current contract`, {
        designatedKey,
        height,
        state: JSON.parse(JSON.stringify(esm_default("state/vuex/state")))
      });
      Promise.reject(new ChelErrorSignatureKeyUnauthorized(`Key ${sKeyId} is unauthorized or expired for the current contract`));
    }
    throw new ChelErrorSignatureKeyUnauthorized(`Key ${sKeyId} is unauthorized or expired for the current contract`);
  }
  const deserializedKey = designatedKey.data;
  const payloadToSign = blake32Hash(`${blake32Hash(additionalData)}${blake32Hash(serializedMessage)}`);
  try {
    verifySignature(deserializedKey, payloadToSign, signature);
    const message = JSON.parse(serializedMessage);
    return [
      sKeyId,
      message
    ];
  } catch (e2) {
    throw new ChelErrorSignatureError(e2?.message || e2);
  }
};
var signedOutgoingData = (stateOrContractID, sKeyId, data, additionalKeys) => {
  if (!stateOrContractID || data === void 0 || !sKeyId) throw new TypeError("Invalid invocation");
  if (!additionalKeys) {
    additionalKeys = rootStateFn().secretKeys;
  }
  const extraFields = /* @__PURE__ */ Object.create(null);
  const boundStringValueFn = signData.bind(null, stateOrContractID, sKeyId, data, extraFields, additionalKeys);
  const serializefn = (additionalData) => boundStringValueFn(additionalData || "");
  return wrapper({
    get signingKeyId() {
      return sKeyId;
    },
    get serialize() {
      return serializefn;
    },
    get toString() {
      return (additionalData) => JSON.stringify(this.serialize(additionalData));
    },
    get valueOf() {
      return () => data;
    },
    get recreate() {
      return (data2) => signedOutgoingData(stateOrContractID, sKeyId, data2, additionalKeys);
    },
    get get() {
      return (k) => extraFields[k];
    },
    get set() {
      return (k, v2) => {
        extraFields[k] = v2;
      };
    }
  });
};
var signedOutgoingDataWithRawKey = (key, data) => {
  const sKeyId = keyId(key);
  const state = {
    _vm: {
      authorizedKeys: {
        [sKeyId]: {
          purpose: [
            "sig"
          ],
          data: serializeKey(key, false),
          _notBeforeHeight: 0,
          _notAfterHeight: void 0
        }
      }
    }
  };
  const extraFields = /* @__PURE__ */ Object.create(null);
  const boundStringValueFn = signData.bind(null, state, sKeyId, data, extraFields, {
    [sKeyId]: key
  });
  const serializefn = (additionalData) => boundStringValueFn(additionalData || "");
  return wrapper({
    get signingKeyId() {
      return sKeyId;
    },
    get serialize() {
      return serializefn;
    },
    get toString() {
      return (additionalData) => JSON.stringify(this.serialize(additionalData));
    },
    get valueOf() {
      return () => data;
    },
    get recreate() {
      return (data2) => signedOutgoingDataWithRawKey(key, data2);
    },
    get get() {
      return (k) => extraFields[k];
    },
    get set() {
      return (k, v2) => {
        extraFields[k] = v2;
      };
    }
  });
};
var signedIncomingData = (contractID, state, data, height, additionalData, mapperFn) => {
  const stringValueFn = () => data;
  let verifySignedValue;
  const verifySignedValueFn = () => {
    if (verifySignedValue) {
      return verifySignedValue[1];
    }
    verifySignedValue = verifySignatureData(state || rootStateFn()[contractID], height, data, additionalData);
    if (mapperFn) verifySignedValue[1] = mapperFn(verifySignedValue[1]);
    return verifySignedValue[1];
  };
  return wrapper({
    get signingKeyId() {
      if (verifySignedValue) return verifySignedValue[0];
      return signedDataKeyId(data);
    },
    get serialize() {
      return stringValueFn;
    },
    get context() {
      return [
        contractID,
        data,
        height,
        additionalData
      ];
    },
    get toString() {
      return () => JSON.stringify(this.serialize());
    },
    get valueOf() {
      return verifySignedValueFn;
    },
    get toJSON() {
      return this.serialize;
    },
    get get() {
      return (k) => k !== "_signedData" ? data[k] : void 0;
    }
  });
};
var signedDataKeyId = (data) => {
  if (!isRawSignedData(data)) {
    throw new ChelErrorSignatureError("Invalid message format");
  }
  return data._signedData[1];
};
var isRawSignedData = (data) => {
  if (!data || typeof data !== "object" || !has2(data, "_signedData") || !Array.isArray(data._signedData) || data._signedData.length !== 3 || data._signedData.map((v2) => typeof v2).filter((v2) => v2 !== "string").length !== 0) {
    return false;
  }
  return true;
};
var rawSignedIncomingData = (data) => {
  if (!isRawSignedData(data)) {
    throw new ChelErrorSignatureError("Invalid message format");
  }
  const stringValueFn = () => data;
  let verifySignedValue;
  const verifySignedValueFn = () => {
    if (verifySignedValue) {
      return verifySignedValue[1];
    }
    verifySignedValue = [
      data._signedData[1],
      JSON.parse(data._signedData[0])
    ];
    return verifySignedValue[1];
  };
  return wrapper({
    get signingKeyId() {
      if (verifySignedValue) return verifySignedValue[0];
      return signedDataKeyId(data);
    },
    get serialize() {
      return stringValueFn;
    },
    get toString() {
      return () => JSON.stringify(this.serialize());
    },
    get valueOf() {
      return verifySignedValueFn;
    },
    get toJSON() {
      return this.serialize;
    },
    get get() {
      return (k) => k !== "_signedData" ? data[k] : void 0;
    }
  });
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/encryptedData.mjs
var rootStateFn2 = () => esm_default("chelonia/rootState");
var proto2 = Object.create(null, {
  _isEncryptedData: {
    value: true
  }
});
var wrapper2 = (o2) => {
  return Object.setPrototypeOf(o2, proto2);
};
var isEncryptedData = (o2) => {
  return !!o2 && !!Object.getPrototypeOf(o2)?._isEncryptedData;
};
var encryptData = function(stateOrContractID, eKeyId, data, additionalData) {
  const state = typeof stateOrContractID === "string" ? rootStateFn2()[stateOrContractID] : stateOrContractID;
  const designatedKey = state?._vm?.authorizedKeys?.[eKeyId];
  if (!designatedKey?.purpose.includes("enc")) {
    throw new Error(`Encryption key ID ${eKeyId} is missing or is missing encryption purpose`);
  }
  if (designatedKey._notAfterHeight != null) {
    const name = state._vm.authorizedKeys[eKeyId].name;
    const newKeyId = Object.values(state._vm?.authorizedKeys).find((v2) => v2._notAfterHeight == null && v2.name === name && v2.purpose.includes("enc"))?.id;
    if (!newKeyId) {
      throw new Error(`Encryption key ID ${eKeyId} has been revoked and no new key exists by the same name (${name})`);
    }
    eKeyId = newKeyId;
  }
  const key = state._vm?.authorizedKeys?.[eKeyId].data;
  if (!key) {
    throw new Error(`Missing encryption key ${eKeyId}`);
  }
  const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
  return [
    keyId(deserializedKey),
    encrypt(deserializedKey, JSON.stringify(data, (_, v2) => {
      if (v2 && has2(v2, "serialize") && typeof v2.serialize === "function") {
        if (v2.serialize.length === 1) {
          return v2.serialize(additionalData);
        } else {
          return v2.serialize();
        }
      }
      return v2;
    }), additionalData)
  ];
};
var decryptData = function(state, height, data, additionalKeys, additionalData, validatorFn) {
  if (!state) {
    throw new ChelErrorDecryptionError("Missing contract state");
  }
  if (typeof data.valueOf === "function") data = data.valueOf();
  if (!isRawEncryptedData(data)) {
    throw new ChelErrorDecryptionError("Invalid message format");
  }
  const [eKeyId, message] = data;
  const key = additionalKeys[eKeyId];
  if (!key) {
    throw new ChelErrorDecryptionKeyNotFound(`Key ${eKeyId} not found`, {
      cause: eKeyId
    });
  }
  const designatedKey = state._vm?.authorizedKeys?.[eKeyId];
  if (!designatedKey || height > designatedKey._notAfterHeight || height < designatedKey._notBeforeHeight || !designatedKey.purpose.includes("enc")) {
    throw new ChelErrorUnexpected(`Key ${eKeyId} is unauthorized or expired for the current contract`);
  }
  const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
  try {
    const result = JSON.parse(decrypt(deserializedKey, message, additionalData));
    if (typeof validatorFn === "function") validatorFn(result, eKeyId);
    return result;
  } catch (e2) {
    throw new ChelErrorDecryptionError(e2?.message || e2);
  }
};
var encryptedOutgoingData = (stateOrContractID, eKeyId, data) => {
  if (!stateOrContractID || data === void 0 || !eKeyId) throw new TypeError("Invalid invocation");
  const boundStringValueFn = encryptData.bind(null, stateOrContractID, eKeyId, data);
  return wrapper2({
    get encryptionKeyId() {
      return eKeyId;
    },
    get serialize() {
      return (additionalData) => boundStringValueFn(additionalData || "");
    },
    get toString() {
      return (additionalData) => JSON.stringify(this.serialize(additionalData));
    },
    get valueOf() {
      return () => data;
    }
  });
};
var encryptedOutgoingDataWithRawKey = (key, data) => {
  if (data === void 0 || !key) throw new TypeError("Invalid invocation");
  const eKeyId = keyId(key);
  const state = {
    _vm: {
      authorizedKeys: {
        [eKeyId]: {
          purpose: [
            "enc"
          ],
          data: serializeKey(key, false),
          _notBeforeHeight: 0,
          _notAfterHeight: void 0
        }
      }
    }
  };
  const boundStringValueFn = encryptData.bind(null, state, eKeyId, data);
  return wrapper2({
    get encryptionKeyId() {
      return eKeyId;
    },
    get serialize() {
      return (additionalData) => boundStringValueFn(additionalData || "");
    },
    get toString() {
      return (additionalData) => JSON.stringify(this.serialize(additionalData));
    },
    get valueOf() {
      return () => data;
    }
  });
};
var encryptedIncomingData = (contractID, state, data, height, additionalKeys, additionalData, validatorFn) => {
  let decryptedValue;
  const decryptedValueFn = () => {
    if (decryptedValue) {
      return decryptedValue;
    }
    if (!state || !additionalKeys) {
      const rootState = rootStateFn2();
      state = state || rootState[contractID];
      additionalKeys = additionalKeys ?? rootState.secretKeys;
    }
    decryptedValue = decryptData(state, height, data, additionalKeys, additionalData || "", validatorFn);
    if (isRawSignedData(decryptedValue)) {
      decryptedValue = signedIncomingData(contractID, state, decryptedValue, height, additionalData || "");
    }
    return decryptedValue;
  };
  return wrapper2({
    get encryptionKeyId() {
      return encryptedDataKeyId(data);
    },
    get serialize() {
      return () => data;
    },
    get toString() {
      return () => JSON.stringify(this.serialize());
    },
    get valueOf() {
      return decryptedValueFn;
    },
    get toJSON() {
      return this.serialize;
    }
  });
};
var encryptedIncomingForeignData = (contractID, _0, data, _1, additionalKeys, additionalData, validatorFn) => {
  let decryptedValue;
  const decryptedValueFn = () => {
    if (decryptedValue) {
      return decryptedValue;
    }
    const rootState = rootStateFn2();
    const state = rootState[contractID];
    decryptedValue = decryptData(state, NaN, data, additionalKeys ?? rootState.secretKeys, additionalData || "", validatorFn);
    if (isRawSignedData(decryptedValue)) {
      return signedIncomingData(contractID, state, decryptedValue, NaN, additionalData || "");
    }
    return decryptedValue;
  };
  return wrapper2({
    get encryptionKeyId() {
      return encryptedDataKeyId(data);
    },
    get serialize() {
      return () => data;
    },
    get toString() {
      return () => JSON.stringify(this.serialize());
    },
    get valueOf() {
      return decryptedValueFn;
    },
    get toJSON() {
      return this.serialize;
    }
  });
};
var encryptedDataKeyId = (data) => {
  if (!isRawEncryptedData(data)) {
    throw new ChelErrorDecryptionError("Invalid message format");
  }
  return data[0];
};
var isRawEncryptedData = (data) => {
  if (!Array.isArray(data) || data.length !== 2 || data.map((v2) => typeof v2).filter((v2) => v2 !== "string").length !== 0) {
    return false;
  }
  return true;
};
var unwrapMaybeEncryptedData = (data) => {
  if (data == null) return;
  if (isEncryptedData(data)) {
    try {
      return {
        encryptionKeyId: data.encryptionKeyId,
        data: data.valueOf()
      };
    } catch (e2) {
      console.warn("unwrapMaybeEncryptedData: Unable to decrypt", e2);
    }
  } else {
    return {
      encryptionKeyId: null,
      data
    };
  }
};
var maybeEncryptedIncomingData = (contractID, state, data, height, additionalKeys, additionalData, validatorFn) => {
  if (isRawEncryptedData(data)) {
    return encryptedIncomingData(contractID, state, data, height, additionalKeys, additionalData, validatorFn);
  } else {
    validatorFn?.(data, "");
    return data;
  }
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/SPMessage.mjs
var decryptedAndVerifiedDeserializedMessage = (head, headJSON, contractID, parsedMessage, additionalKeys, state) => {
  const op = head.op;
  const height = head.height;
  const message = op === SPMessage.OP_ACTION_ENCRYPTED ? encryptedIncomingData(contractID, state, parsedMessage, height, additionalKeys, headJSON, void 0) : parsedMessage;
  if ([
    SPMessage.OP_KEY_ADD,
    SPMessage.OP_KEY_UPDATE
  ].includes(op)) {
    return message.map((key) => {
      return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, (key2) => {
        if (key2.meta?.private?.content) {
          key2.meta.private.content = encryptedIncomingData(contractID, state, key2.meta.private.content, height, additionalKeys, headJSON, (value) => {
            const computedKeyId = keyId(value);
            if (computedKeyId !== key2.id) {
              throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key2.id} but got ${computedKeyId}`);
            }
          });
        }
        if (key2.meta?.keyRequest?.reference) {
          try {
            key2.meta.keyRequest.reference = maybeEncryptedIncomingData(contractID, state, key2.meta.keyRequest.reference, height, additionalKeys, headJSON)?.valueOf();
          } catch {
            delete key2.meta.keyRequest.reference;
          }
        }
        if (key2.meta?.keyRequest?.contractID) {
          try {
            key2.meta.keyRequest.contractID = maybeEncryptedIncomingData(contractID, state, key2.meta.keyRequest.contractID, height, additionalKeys, headJSON)?.valueOf();
          } catch {
            delete key2.meta.keyRequest.contractID;
          }
        }
      });
    });
  }
  if (op === SPMessage.OP_CONTRACT) {
    message.keys = message.keys?.map((key) => {
      return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, (key2) => {
        if (!key2.meta?.private?.content) return;
        const decryptionFn = encryptedIncomingData;
        const decryptionContract = contractID;
        key2.meta.private.content = decryptionFn(decryptionContract, state, key2.meta.private.content, height, additionalKeys, headJSON, (value) => {
          const computedKeyId = keyId(value);
          if (computedKeyId !== key2.id) {
            throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key2.id} but got ${computedKeyId}`);
          }
        });
      });
    });
  }
  if (op === SPMessage.OP_KEY_SHARE) {
    return maybeEncryptedIncomingData(contractID, state, message, height, additionalKeys, headJSON, (message2) => {
      message2.keys?.forEach((key) => {
        if (!key.meta?.private?.content) return;
        const decryptionFn = message2.foreignContractID ? encryptedIncomingForeignData : encryptedIncomingData;
        const decryptionContract = message2.foreignContractID || contractID;
        key.meta.private.content = decryptionFn(decryptionContract, state, key.meta.private.content, height, additionalKeys, headJSON, (value) => {
          const computedKeyId = keyId(value);
          if (computedKeyId !== key.id) {
            throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key.id} but got ${computedKeyId}`);
          }
        });
      });
    });
  }
  if (op === SPMessage.OP_KEY_REQUEST) {
    return maybeEncryptedIncomingData(contractID, state, message, height, additionalKeys, headJSON, (msg) => {
      msg.replyWith = signedIncomingData(msg.contractID, void 0, msg.replyWith, msg.height, headJSON);
    });
  }
  if (op === SPMessage.OP_ACTION_UNENCRYPTED && isRawSignedData(message)) {
    return signedIncomingData(contractID, state, message, height, headJSON);
  }
  if (op === SPMessage.OP_ACTION_ENCRYPTED) {
    return message;
  }
  if (op === SPMessage.OP_KEY_DEL) {
    return message.map((key) => {
      return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, void 0);
    });
  }
  if (op === SPMessage.OP_KEY_REQUEST_SEEN) {
    return maybeEncryptedIncomingData(contractID, state, parsedMessage, height, additionalKeys, headJSON, void 0);
  }
  if (op === SPMessage.OP_ATOMIC) {
    return message.map(([opT, opV]) => [
      opT,
      decryptedAndVerifiedDeserializedMessage({
        ...head,
        op: opT
      }, headJSON, contractID, opV, additionalKeys, state)
    ]);
  }
  return message;
};
var SPMessage = class _SPMessage {
  // flow type annotations to make flow happy
  _mapping;
  _head;
  _message;
  _signedMessageData;
  _direction;
  _decryptedValue;
  _innerSigningKeyId;
  static OP_CONTRACT = "c";
  static OP_ACTION_ENCRYPTED = "ae";
  static OP_ACTION_UNENCRYPTED = "au";
  static OP_KEY_ADD = "ka";
  static OP_KEY_DEL = "kd";
  static OP_KEY_UPDATE = "ku";
  static OP_PROTOCOL_UPGRADE = "pu";
  static OP_PROP_SET = "ps";
  static OP_PROP_DEL = "pd";
  static OP_CONTRACT_AUTH = "ca";
  static OP_CONTRACT_DEAUTH = "cd";
  static OP_ATOMIC = "a";
  static OP_KEY_SHARE = "ks";
  static OP_KEY_REQUEST = "kr";
  static OP_KEY_REQUEST_SEEN = "krs";
  // eslint-disable-next-line camelcase
  static createV1_0({
    contractID,
    previousHEAD = null,
    previousKeyOp = null,
    // Height will be automatically set to the correct value when sending
    // The reason to set it to Number.MAX_SAFE_INTEGER is so that we can
    // temporarily process outgoing messages with signature validation
    // still working
    height = Number.MAX_SAFE_INTEGER,
    op,
    manifest
  }) {
    const head = {
      version: "1.0.0",
      previousHEAD,
      previousKeyOp,
      height,
      contractID,
      op: op[0],
      manifest
    };
    return new this(messageToParams(head, op[1]));
  }
  // SPMessage.cloneWith could be used when make a SPMessage object having the same id()
  // https://github.com/okTurtles/group-income/issues/1503
  static cloneWith(targetHead, targetOp, sources) {
    const head = Object.assign({}, targetHead, sources);
    return new this(messageToParams(head, targetOp[1]));
  }
  static deserialize(value, additionalKeys, state, unwrapMaybeEncryptedDataFn = unwrapMaybeEncryptedData) {
    if (!value) throw new Error(`deserialize bad value: ${value}`);
    const { head: headJSON, ...parsedValue } = JSON.parse(value);
    const head = JSON.parse(headJSON);
    const contractID = head.op === _SPMessage.OP_CONTRACT ? createCID(value, multicodes.SHELTER_CONTRACT_DATA) : head.contractID;
    if (!state?._vm?.authorizedKeys && head.op === _SPMessage.OP_CONTRACT) {
      const value2 = rawSignedIncomingData(parsedValue);
      const authorizedKeys = Object.fromEntries(value2.valueOf()?.keys.map((wk) => {
        const k = unwrapMaybeEncryptedDataFn(wk);
        if (!k) return null;
        return [
          k.data.id,
          k.data
        ];
      }).filter(Boolean));
      state = {
        _vm: {
          type: head.type,
          authorizedKeys
        }
      };
    }
    const signedMessageData = signedIncomingData(contractID, state, parsedValue, head.height, headJSON, (message) => decryptedAndVerifiedDeserializedMessage(head, headJSON, contractID, message, additionalKeys, state));
    return new this({
      direction: "incoming",
      mapping: {
        key: createCID(value, multicodes.SHELTER_CONTRACT_DATA),
        value
      },
      head,
      signedMessageData
    });
  }
  static deserializeHEAD(value) {
    if (!value) throw new Error(`deserialize bad value: ${value}`);
    let head, hash3;
    const result = {
      get head() {
        if (head === void 0) {
          head = JSON.parse(JSON.parse(value).head);
        }
        return head;
      },
      get hash() {
        if (!hash3) {
          hash3 = createCID(value, multicodes.SHELTER_CONTRACT_DATA);
        }
        return hash3;
      },
      get contractID() {
        return result.head?.contractID ?? result.hash;
      },
      // `description` is not a getter to prevent the value from being copied
      // if the object is cloned or serialized
      description() {
        const type = this.head.op;
        return `<op_${type}|${this.hash} of ${this.contractID}>`;
      },
      get isFirstMessage() {
        return !result.head?.contractID;
      }
    };
    return result;
  }
  constructor(params) {
    this._direction = params.direction;
    this._mapping = params.mapping;
    this._head = params.head;
    this._signedMessageData = params.signedMessageData;
    const type = this.opType();
    let atomicTopLevel = true;
    const validate2 = (type2, message) => {
      switch (type2) {
        case _SPMessage.OP_CONTRACT:
          if (!this.isFirstMessage() || !atomicTopLevel) throw new Error("OP_CONTRACT: must be first message");
          break;
        case _SPMessage.OP_ATOMIC:
          if (!atomicTopLevel) {
            throw new Error("OP_ATOMIC not allowed inside of OP_ATOMIC");
          }
          if (!Array.isArray(message)) {
            throw new TypeError("OP_ATOMIC must be of an array type");
          }
          atomicTopLevel = false;
          message.forEach(([t, m3]) => validate2(t, m3));
          break;
        case _SPMessage.OP_KEY_ADD:
        case _SPMessage.OP_KEY_DEL:
        case _SPMessage.OP_KEY_UPDATE:
          if (!Array.isArray(message)) throw new TypeError("OP_KEY_{ADD|DEL|UPDATE} must be of an array type");
          break;
        case _SPMessage.OP_KEY_SHARE:
        case _SPMessage.OP_KEY_REQUEST:
        case _SPMessage.OP_KEY_REQUEST_SEEN:
        case _SPMessage.OP_ACTION_ENCRYPTED:
        case _SPMessage.OP_ACTION_UNENCRYPTED:
          break;
        default:
          throw new Error(`unsupported op: ${type2}`);
      }
    };
    Object.defineProperty(this, "_message", {
      get: /* @__PURE__ */ ((validated) => () => {
        const message = this._signedMessageData.valueOf();
        if (!validated) {
          validate2(type, message);
          validated = true;
        }
        return message;
      })()
    });
  }
  decryptedValue() {
    if (this._decryptedValue) return this._decryptedValue;
    try {
      const value = this.message();
      const data = unwrapMaybeEncryptedData(value);
      if (data?.data) {
        if (isSignedData(data.data)) {
          this._innerSigningKeyId = data.data.signingKeyId;
          this._decryptedValue = data.data.valueOf();
        } else {
          this._decryptedValue = data.data;
        }
      }
      return this._decryptedValue;
    } catch {
      return void 0;
    }
  }
  innerSigningKeyId() {
    if (!this._decryptedValue) {
      this.decryptedValue();
    }
    return this._innerSigningKeyId;
  }
  head() {
    return this._head;
  }
  message() {
    return this._message;
  }
  op() {
    return [
      this.head().op,
      this.message()
    ];
  }
  rawOp() {
    return [
      this.head().op,
      this._signedMessageData
    ];
  }
  opType() {
    return this.head().op;
  }
  opValue() {
    return this.message();
  }
  signingKeyId() {
    return this._signedMessageData.signingKeyId;
  }
  manifest() {
    return this.head().manifest;
  }
  description() {
    const type = this.opType();
    let desc = `<op_${type}`;
    if (type === _SPMessage.OP_ACTION_UNENCRYPTED) {
      try {
        const value = this.opValue().valueOf();
        if (typeof value.action === "string") {
          desc += `|${value.action}`;
        }
      } catch (e2) {
        console.warn("Error on .description()", this.hash(), e2);
      }
    }
    return `${desc}|${this.hash()} of ${this.contractID()}>`;
  }
  isFirstMessage() {
    return !this.head().contractID;
  }
  contractID() {
    return this.head().contractID || this.hash();
  }
  serialize() {
    return this._mapping.value;
  }
  hash() {
    return this._mapping.key;
  }
  previousKeyOp() {
    return this._head.previousKeyOp;
  }
  height() {
    return this._head.height;
  }
  id() {
    throw new Error("SPMessage.id() was called but it has been removed");
  }
  direction() {
    return this._direction;
  }
  // `isKeyOp` is used to filter out non-key operations for providing an
  // abbreviated chain fo snapshot validation
  isKeyOp() {
    let value;
    return !!(keyOps.includes(this.opType()) || this.opType() === _SPMessage.OP_ATOMIC && Array.isArray(value = this.opValue()) && value.some(([opT]) => {
      return keyOps.includes(opT);
    }));
  }
  static get [serdesTagSymbol]() {
    return "SPMessage";
  }
  static [serdesSerializeSymbol](m3) {
    return [
      m3.serialize(),
      m3.direction(),
      m3.decryptedValue(),
      m3.innerSigningKeyId()
    ];
  }
  static [serdesDeserializeSymbol]([serialized, direction, decryptedValue, innerSigningKeyId]) {
    const m3 = _SPMessage.deserialize(serialized);
    m3._direction = direction;
    m3._decryptedValue = decryptedValue;
    m3._innerSigningKeyId = innerSigningKeyId;
    return m3;
  }
};
function messageToParams(head, message) {
  let mapping;
  return {
    direction: has2(message, "recreate") ? "outgoing" : "incoming",
    // Lazy computation of mapping to prevent us from serializing outgoing
    // atomic operations
    get mapping() {
      if (!mapping) {
        const headJSON = JSON.stringify(head);
        const messageJSON = {
          ...message.serialize(headJSON),
          head: headJSON
        };
        const value = JSON.stringify(messageJSON);
        mapping = {
          key: createCID(value, multicodes.SHELTER_CONTRACT_DATA),
          value
        };
      }
      return mapping;
    },
    head,
    signedMessageData: message
  };
}
var keyOps = [
  SPMessage.OP_CONTRACT,
  SPMessage.OP_KEY_ADD,
  SPMessage.OP_KEY_DEL,
  SPMessage.OP_KEY_UPDATE
];

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/chelonia-utils.mjs
var chelonia_utils_default = esm_default("sbp/selectors/register", {
  // This selector is a wrapper for the `chelonia/kv/set` selector that uses
  // the contract queue and allows referring to keys by name, with default key
  // names set to `csk` and `cek` for signatures and encryption, respectively.
  // For most 'simple' use cases, this selector is a better choice than
  // `chelonia/kv/set`. However, the `chelonia/kv/set` primitive is needed if
  // the queueing logic needs to be more advanced, the key to use requires
  // custom logic or _if the `onconflict` callback also needs to be queued_.
  "chelonia/kv/queuedSet": ({ contractID, key, data, onconflict, ifMatch, encryptionKeyName = "cek", signingKeyName = "csk" }) => {
    return esm_default("chelonia/queueInvocation", contractID, () => {
      return esm_default("chelonia/kv/set", contractID, key, data, {
        ifMatch,
        encryptionKeyId: esm_default("chelonia/contract/currentKeyIdByName", contractID, encryptionKeyName),
        signingKeyId: esm_default("chelonia/contract/currentKeyIdByName", contractID, signingKeyName),
        onconflict
      });
    });
  }
});

// node_modules/.deno/@apeleghq+multipart-parser@1.0.18/node_modules/@apeleghq/multipart-parser/dist/encodeMultipartMessage.mjs
var m = /;\s*boundary=(?:"([0-9a-zA-Z'()+_,\-./:=? ]{0,69}[0-9a-zA-Z'()+_,\-./:=?])"|([0-9a-zA-Z'+_\-.]{0,69}[0-9a-zA-Z'+_\-.]))/;
var M = (a) => new ReadableStream({
  pull(r) {
    if (ArrayBuffer.isView(a)) r.enqueue(a.buffer.slice(a.byteOffset, a.byteOffset + a.byteLength));
    else if (a instanceof ArrayBuffer) r.enqueue(a);
    else throw new TypeError("Expected ArrayBuffer or an ArrayBuffer view.");
    r.close();
  }
});
var u = M;
var T = /;\s*boundary=(?:"([^"]+)"|([^;",]+))/;
var h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_-.";
var A = () => {
  let a = new Uint8Array(24);
  return globalThis.crypto.getRandomValues(a), Array.from(a).map((s) => h[s % h.length]).join("");
};
var i = {
  preventClose: true
};
async function* g(a, s, r) {
  let d = new TextEncoder(), y = d.encode(`\r
--${a}`);
  if (Array.isArray(s) && s.length < 1) {
    await r.abort(Error("At least one part is required"));
    return;
  }
  let l = 0;
  for await (let e2 of s) {
    l++;
    let n, t;
    if (!e2.body && e2.parts) if (t = e2.headers.get("content-type"), !t) n = A(), t = `multipart/mixed; boundary="${n}"`;
    else if (!t.startsWith("multipart/") || !T.test(t)) {
      await r.abort(Error("Invalid multipart content type: " + t));
      return;
    } else {
      let o2 = t.match(m);
      (!o2 || !(n = o2[1] || o2[2])) && (n = A(), t = t.replace(T, `; boundary="${n}"`));
    }
    await u(y).pipeTo(r, i), yield;
    {
      let o2 = [
        ""
      ];
      if (t) {
        let p = false;
        e2.headers.forEach((f, c) => {
          c !== "content-type" ? o2.push(`${c}: ${f}`) : (p = true, o2.push(`${c}: ${t}`));
        }), p || o2.push(`content-type: ${t}`);
      } else e2.headers.forEach((p, f) => {
        o2.push(`${f}: ${p}`);
      });
      e2.parts || !e2.body ? o2.push("") : o2.push("", "");
      let B4 = d.encode(o2.join(`\r
`));
      o2.length = 0, await u(B4).pipeTo(r, i), yield;
    }
    if (e2.body) {
      if (e2.body instanceof ArrayBuffer || ArrayBuffer.isView(e2.body)) await u(e2.body).pipeTo(r, i);
      else if (e2.body instanceof Blob) await e2.body.stream().pipeTo(r, i);
      else if (e2.body instanceof ReadableStream) await e2.body.pipeTo(r, i);
      else {
        await r.abort(Error("Invalid body type"));
        return;
      }
      yield;
    } else if (e2.parts) {
      if (!n) {
        await r.abort(Error("Runtime exception: undefined part boundary"));
        return;
      }
      yield* g(n, e2.parts, r), yield;
    }
  }
  if (!l) {
    await r.abort(Error("At least one part is required"));
    return;
  }
  let b = d.encode(`\r
--${a}--`);
  await u(b).pipeTo(r, i);
}
var w2 = (a, s) => {
  let r = new TransformStream(), d = g(a, s, r.writable), y = false, l = r.readable.getReader();
  return new ReadableStream({
    start(e2) {
      (async () => {
        for (; ; ) try {
          let n = await l.read();
          if (n.done) {
            let t = new Uint8Array([
              13,
              10
            ]);
            e2.enqueue(t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)), e2.close();
            return;
          }
          e2.enqueue(n.value);
        } catch (n) {
          e2.error(n);
          return;
        }
      })().catch(() => {
      });
    },
    async pull() {
      if (y) return;
      (await d.next()).done && (y = true, await r.writable.close());
    }
  });
};
var x2 = w2;

// node_modules/.deno/@apeleghq+rfc8188@1.0.8/node_modules/@apeleghq/rfc8188/dist/decrypt.mjs
var v = async (n, T2, w4, L) => {
  let u2 = await globalThis.crypto.subtle.importKey("raw", T2, "HKDF", false, [
    "deriveKey",
    "deriveBits"
  ]), d = await globalThis.crypto.subtle.deriveKey({
    name: "HKDF",
    hash: "SHA-256",
    info: n.cek_info,
    salt: w4
  }, u2, n.params, false, L), A2 = await globalThis.crypto.subtle.deriveBits({
    name: "HKDF",
    hash: "SHA-256",
    info: n.nonce_info,
    salt: w4
  }, u2, n.nonce_length << 3);
  return [
    d,
    function* () {
      let s = new ArrayBuffer(n.nonce_length), e2 = new DataView(s), y = new Uint8Array(s), i2 = new Uint8Array(A2), b = 4294967295, f = (n.nonce_length >> 2) - 1, l = new Array(f).fill(0);
      for (; ; ) {
        for (let a = 0; a <= b; a++) {
          e2.setUint32(e2.byteLength - 4, a, false);
          let t = new Uint8Array(n.nonce_length);
          for (let r = 0; r < t.length; r++) t[r] = i2[r] ^ y[r];
          yield t;
        }
        for (let a = 0; a < f; a++) {
          if (a === f - 1 && l[a] === b) throw new RangeError("Maximum number of segments exceeded");
          if (l[a] = (l[a] + 1) % (b + 1), e2.setUint32(e2.byteLength - 4 * (a + 2), l[a], false), l[a] !== 0) break;
        }
      }
    }()
  ];
};
var I = v;
var B2 = (n) => ArrayBuffer.isView(n) ? new Uint8Array(n.buffer).subarray(n.byteOffset, n.byteOffset + n.byteLength) : new Uint8Array(n);
var m2 = B2;
var o = {
  salt: {},
  recordSize: {},
  keyIdLen: {},
  keyId: {},
  payload: {},
  done: {}
};
var R2 = (n, T2, w4, L) => {
  let u2 = new Uint8Array(16), d, A2, E3, s = 0, e2 = 0, y = new Uint8Array(256), i2 = o.salt, b = new TransformStream({
    start: () => {
    },
    transform: async (f, l) => {
      let a = m2(f), t = 0;
      for (; t < f.byteLength; ) switch (i2) {
        case o.salt: {
          let r = a.subarray(t, t + u2.byteLength - e2);
          if (u2.set(r, e2), e2 += r.byteLength, t += r.byteLength, e2 === u2.byteLength) {
            e2 = 0, i2 = o.recordSize;
            continue;
          }
          break;
        }
        case o.recordSize: {
          let r = a.subarray(t, t + 4 - e2), g2 = new ArrayBuffer(4), h2 = new Uint8Array(g2), c = new DataView(g2);
          if (h2.set(r, e2), s |= c.getUint32(0, false), e2 += r.byteLength, t += r.byteLength, e2 === 4) {
            if (s <= n.tag_length + 1 || s > (L == null ? 4294967295 : Math.min(4294967295, L))) throw new RangeError("Invalid record size: " + s);
            e2 = 0, i2 = o.keyIdLen;
            continue;
          }
          break;
        }
        case o.keyIdLen: {
          y[0] = a[t++], i2 = o.keyId;
          continue;
        }
        case o.keyId: {
          let r = a.subarray(t, t + y[0] - e2);
          if (y.set(r, 1 + e2), e2 += r.byteLength, t += r.byteLength, e2 === y[0]) {
            let g2 = await w4(y.subarray(1, 1 + y[0]));
            w4 = void 0;
            let h2 = await I(n, g2, u2, [
              "decrypt"
            ]);
            A2 = h2[0], E3 = h2[1], d = new Uint8Array(s), e2 = 0, i2 = o.payload;
            continue;
          }
          break;
        }
        case o.payload: {
          let r = a.subarray(t, t + s - e2);
          if (d.set(r, e2), e2 += r.byteLength, t += r.byteLength, e2 === s) {
            let h2 = E3.next().value, c = m2(await globalThis.crypto.subtle.decrypt({
              name: n.params.name,
              iv: h2,
              tagLength: n.tag_length << 3
            }, A2, d.subarray(0, e2))), p = c.byteLength - 1;
            for (; p > 0 && c[p] === 0; p--) ;
            if (c[p] === 2) {
              if (t !== f.byteLength) throw new Error("Unexpected terminal padding delimiter");
              i2 = o.done;
            } else if (c[p] !== 1) throw new Error("Invalid padding delimiter");
            l.enqueue(c.buffer.slice(0, p)), c.fill(0), e2 = 0;
            continue;
          }
          break;
        }
        default:
          throw new Error("Invalid state");
      }
    },
    flush: async (f) => {
      switch (i2) {
        case o.done:
          return;
        case o.payload: {
          if (e2 < 1 + n.tag_length) throw new Error("Unexpected end of data");
          let a = E3.next().value, t = m2(await globalThis.crypto.subtle.decrypt({
            name: n.params.name,
            iv: a,
            tagLength: n.tag_length << 3
          }, A2, d.subarray(0, e2))), r = t.byteLength - 1;
          for (; r > 0 && t[r] === 0; r--) ;
          if (t[r] !== 2) throw new Error("Unexpected non-terminal padding delimiter");
          f.enqueue(t.buffer.slice(0, r)), t.fill(0);
          return;
        }
        default:
          throw new Error("Invalid state");
      }
    }
  });
  return T2.pipeThrough(b), b.readable;
};
var S = R2;

// node_modules/.deno/@apeleghq+rfc8188@1.0.8/node_modules/@apeleghq/rfc8188/dist/encodings.mjs
var e = {
  params: {
    name: "AES-GCM",
    length: 256
  },
  get cek_info() {
    return new Uint8Array([
      67,
      111,
      110,
      116,
      101,
      110,
      116,
      45,
      69,
      110,
      99,
      111,
      100,
      105,
      110,
      103,
      58,
      32,
      97,
      101,
      115,
      50,
      53,
      54,
      103,
      99,
      109,
      0
    ]);
  },
  get nonce_info() {
    return new Uint8Array([
      67,
      111,
      110,
      116,
      101,
      110,
      116,
      45,
      69,
      110,
      99,
      111,
      100,
      105,
      110,
      103,
      58,
      32,
      110,
      111,
      110,
      99,
      101,
      0
    ]);
  },
  block_size: 16,
  tag_length: 16,
  nonce_length: 12
};

// node_modules/.deno/@apeleghq+rfc8188@1.0.8/node_modules/@apeleghq/rfc8188/dist/encrypt.mjs
var R3 = async (e2, b, f, i2) => {
  let A2 = await globalThis.crypto.subtle.importKey("raw", b, "HKDF", false, [
    "deriveKey",
    "deriveBits"
  ]), y = await globalThis.crypto.subtle.deriveKey({
    name: "HKDF",
    hash: "SHA-256",
    info: e2.cek_info,
    salt: f
  }, A2, e2.params, false, i2), u2 = await globalThis.crypto.subtle.deriveBits({
    name: "HKDF",
    hash: "SHA-256",
    info: e2.nonce_info,
    salt: f
  }, A2, e2.nonce_length << 3);
  return [
    y,
    function* () {
      let L = new ArrayBuffer(e2.nonce_length), c = new DataView(L), h2 = new Uint8Array(L), a = new Uint8Array(u2), g2 = 4294967295, o2 = (e2.nonce_length >> 2) - 1, s = new Array(o2).fill(0);
      for (; ; ) {
        for (let t = 0; t <= g2; t++) {
          c.setUint32(c.byteLength - 4, t, false);
          let n = new Uint8Array(e2.nonce_length);
          for (let r = 0; r < n.length; r++) n[r] = a[r] ^ h2[r];
          yield n;
        }
        for (let t = 0; t < o2; t++) {
          if (t === o2 - 1 && s[t] === g2) throw new RangeError("Maximum number of segments exceeded");
          if (s[t] = (s[t] + 1) % (g2 + 1), c.setUint32(c.byteLength - 4 * (t + 2), s[t], false), s[t] !== 0) break;
        }
      }
    }()
  ];
};
var E2 = R3;
var B3 = (e2) => ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer).subarray(e2.byteOffset, e2.byteOffset + e2.byteLength) : new Uint8Array(e2);
var w3 = B3;
var N10 = () => {
  let e2 = new Uint8Array(16);
  return globalThis.crypto.getRandomValues(e2), e2;
};
var U2 = async (e2, b, f, i2, A2, y) => {
  if (f <= e2.tag_length + 1 || f > 4294967295) throw new RangeError("Invalid record size: " + f);
  if (i2.byteLength > 255) throw new RangeError("Key ID too long");
  if (y && y.byteLength !== 16) throw new RangeError("Invald salt length: " + y.byteLength);
  let u2 = f - e2.tag_length - 1, l = y ? w3(y) : N10(), [L, c] = await E2(e2, A2, l, [
    "encrypt"
  ]);
  A2 = void 0;
  let h2 = new Uint8Array(u2), a = 0, g2 = new TransformStream({
    start: (o2) => {
      let s = l.byteLength + 4 + 1 + i2.byteLength, t = new ArrayBuffer(s);
      new Uint8Array(t, 0, l.byteLength).set(l);
      let r = new DataView(t, l.byteLength, 5);
      r.setUint32(0, f, false), r.setUint8(4, i2.byteLength);
      let d = new Uint8Array(t, l.byteLength + 4 + 1, i2.byteLength), m3 = w3(i2);
      d.set(m3), o2.enqueue(t);
    },
    transform: async (o2, s) => {
      let t = w3(o2), n = 0;
      for (; n < o2.byteLength; ) {
        let r = t.subarray(n, n + u2 - a);
        if (h2.set(r, a), a += r.byteLength, n += r.byteLength, a === u2) {
          let m3 = c.next().value, p = new Uint8Array(u2 + 1);
          p.set(h2.subarray(0, a)), p[a] = 1;
          let T2 = await globalThis.crypto.subtle.encrypt({
            name: e2.params.name,
            iv: m3,
            tagLength: e2.tag_length << 3
          }, L, p);
          s.enqueue(T2), a = 0;
        }
      }
    },
    flush: async (o2) => {
      let t = c.next().value, n = new Uint8Array(a + 1);
      n.set(h2.subarray(0, a)), n[a] = 2;
      let r = await globalThis.crypto.subtle.encrypt({
        name: e2.params.name,
        iv: t,
        tagLength: e2.tag_length << 3
      }, L, n);
      o2.enqueue(r), h2.fill(0), n.fill(0);
    }
  });
  return b.pipeThrough(g2), g2.readable;
};
var K2 = U2;

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/files.mjs
import { Buffer as Buffer6 } from "node:buffer";

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/utils.mjs
import { Buffer as Buffer5 } from "node:buffer";

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/Secret.mjs
var wm = /* @__PURE__ */ new WeakMap();
var Secret = class {
  static [serdesDeserializeSymbol](secret) {
    return new this(secret);
  }
  static [serdesSerializeSymbol](secret) {
    return wm.get(secret);
  }
  static get [serdesTagSymbol]() {
    return "__chelonia_Secret";
  }
  constructor(value) {
    wm.set(this, value);
  }
  valueOf() {
    return wm.get(this);
  }
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/constants.mjs
var INVITE_STATUS = {
  REVOKED: "revoked",
  VALID: "valid",
  USED: "used"
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/utils.mjs
var MAX_EVENTS_AFTER = Number.parseInt(process.env.MAX_EVENTS_AFTER || "", 10) || Infinity;
var findKeyIdByName = (state, name) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).find((k) => k.name === name && k._notAfterHeight == null)?.id;
var findForeignKeysByContractID = (state, contractID) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => k._notAfterHeight == null && k.foreignKey?.includes(contractID)).map((k) => k.id);
var findRevokedKeyIdsByName = (state, name) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys || {}).filter((k) => k.name === name && k._notAfterHeight != null).map((k) => k.id);
var findSuitableSecretKeyId = (state, permissions, purposes, ringLevel, allowedActions) => {
  return state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => {
    return k._notAfterHeight == null && k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY) && esm_default("chelonia/haveSecretKey", k.id) && (Array.isArray(permissions) ? permissions.reduce((acc, permission) => acc && (k.permissions === "*" || k.permissions.includes(permission)), true) : permissions === k.permissions) && purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true) && (Array.isArray(allowedActions) ? allowedActions.reduce((acc, action) => acc && (k.allowedActions === "*" || !!k.allowedActions?.includes(action)), true) : allowedActions ? allowedActions === k.allowedActions : true);
  }).sort((a, b) => b.ringLevel - a.ringLevel)[0]?.id;
};
var findSuitablePublicKeyIds = (state, permissions, purposes, ringLevel) => {
  return state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => k._notAfterHeight == null && k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY) && (Array.isArray(permissions) ? permissions.reduce((acc, permission) => acc && (k.permissions === "*" || k.permissions.includes(permission)), true) : permissions === k.permissions) && purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true)).sort((a, b) => b.ringLevel - a.ringLevel).map((k) => k.id);
};
var validateActionPermissions = (msg, signingKey, state, opT, opV) => {
  const data = isSignedData(opV) ? opV.valueOf() : opV;
  if (signingKey.allowedActions !== "*" && (!Array.isArray(signingKey.allowedActions) || !signingKey.allowedActions.includes(data.action))) {
    logEvtError(msg, `Signing key ${signingKey.id} is not allowed for action ${data.action}`);
    return false;
  }
  if (isSignedData(opV)) {
    const s = opV;
    const innerSigningKey = state._vm?.authorizedKeys?.[s.signingKeyId];
    if (!innerSigningKey && msg._direction === "outgoing") return true;
    if (!innerSigningKey || !Array.isArray(innerSigningKey.purpose) || !innerSigningKey.purpose.includes("sig") || innerSigningKey.permissions !== "*" && (!Array.isArray(innerSigningKey.permissions) || !innerSigningKey.permissions.includes(opT + "#inner"))) {
      logEvtError(msg, `Signing key ${s.signingKeyId} is missing permissions for operation ${opT}`);
      return false;
    }
    if (innerSigningKey.allowedActions !== "*" && (!Array.isArray(innerSigningKey.allowedActions) || !innerSigningKey.allowedActions.includes(data.action + "#inner"))) {
      logEvtError(msg, `Signing key ${innerSigningKey.id} is not allowed for action ${data.action}`);
      return false;
    }
  }
  return true;
};
var validateKeyPermissions = (msg, config2, state, signingKeyId, opT, opV) => {
  const signingKey = state._vm?.authorizedKeys?.[signingKeyId];
  if (!signingKey || !Array.isArray(signingKey.purpose) || !signingKey.purpose.includes("sig") || signingKey.permissions !== "*" && (!Array.isArray(signingKey.permissions) || !signingKey.permissions.includes(opT))) {
    logEvtError(msg, `Signing key ${signingKeyId} is missing permissions for operation ${opT}`);
    return false;
  }
  if (opT === SPMessage.OP_ACTION_UNENCRYPTED && !validateActionPermissions(msg, signingKey, state, opT, opV)) {
    return false;
  }
  if (!config2.skipActionProcessing && opT === SPMessage.OP_ACTION_ENCRYPTED && !validateActionPermissions(msg, signingKey, state, opT, opV.valueOf())) {
    return false;
  }
  return true;
};
var validateKeyAddPermissions = function(contractID, signingKey, state, v2, skipPrivateCheck) {
  const signingKeyPermissions = Array.isArray(signingKey.permissions) ? new Set(signingKey.permissions) : signingKey.permissions;
  const signingKeyAllowedActions = Array.isArray(signingKey.allowedActions) ? new Set(signingKey.allowedActions) : signingKey.allowedActions;
  if (!state._vm?.authorizedKeys?.[signingKey.id]) throw new Error("Singing key for OP_KEY_ADD or OP_KEY_UPDATE must exist in _vm.authorizedKeys. contractID=" + contractID + " signingKeyId=" + signingKey.id);
  const localSigningKey = state._vm.authorizedKeys[signingKey.id];
  v2.forEach((wk) => {
    const data = this.config.unwrapMaybeEncryptedData(wk);
    if (!data) return;
    const k = data.data;
    if (!skipPrivateCheck && signingKey._private && !data.encryptionKeyId) {
      throw new Error("Signing key is private but it tried adding a public key");
    }
    if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {
      throw new Error("Signing key has ringLevel " + localSigningKey.ringLevel + " but attempted to add or update a key with ringLevel " + k.ringLevel);
    }
    if (signingKeyPermissions !== "*") {
      if (!Array.isArray(k.permissions) || !k.permissions.reduce((acc, cv) => acc && signingKeyPermissions.has(cv), true)) {
        throw new Error("Unable to add or update a key with more permissions than the signing key. signingKey permissions: " + String(signingKey?.permissions) + "; key add permissions: " + String(k.permissions));
      }
    }
    if (signingKeyAllowedActions !== "*" && k.allowedActions) {
      if (!signingKeyAllowedActions || !Array.isArray(k.allowedActions) || !k.allowedActions.reduce((acc, cv) => acc && signingKeyAllowedActions.has(cv), true)) {
        throw new Error("Unable to add or update a key with more allowed actions than the signing key. signingKey allowed actions: " + String(signingKey?.allowedActions) + "; key add allowed actions: " + String(k.allowedActions));
      }
    }
  });
};
var validateKeyDelPermissions = function(contractID, signingKey, state, v2) {
  if (!state._vm?.authorizedKeys?.[signingKey.id]) throw new Error("Singing key for OP_KEY_DEL must exist in _vm.authorizedKeys. contractID=" + contractID + " signingKeyId=" + signingKey.id);
  const localSigningKey = state._vm.authorizedKeys[signingKey.id];
  v2.forEach((wid) => {
    const data = this.config.unwrapMaybeEncryptedData(wid);
    if (!data) return;
    const id = data.data;
    const k = state._vm.authorizedKeys[id];
    if (!k) {
      throw new Error("Nonexisting key ID " + id);
    }
    if (signingKey._private) {
      throw new Error("Signing key is private");
    }
    if (!k._private !== !data.encryptionKeyId) {
      throw new Error("_private attribute must be preserved");
    }
    if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {
      throw new Error("Signing key has ringLevel " + localSigningKey.ringLevel + " but attempted to remove a key with ringLevel " + k.ringLevel);
    }
  });
};
var validateKeyUpdatePermissions = function(contractID, signingKey, state, v2) {
  const updatedMap = /* @__PURE__ */ Object.create(null);
  const keys = v2.map((wuk) => {
    const data = this.config.unwrapMaybeEncryptedData(wuk);
    if (!data) return void 0;
    const uk = data.data;
    const existingKey = state._vm.authorizedKeys[uk.oldKeyId];
    if (!existingKey) {
      throw new ChelErrorWarning("Missing old key ID " + uk.oldKeyId);
    }
    if (!existingKey._private !== !data.encryptionKeyId) {
      throw new Error("_private attribute must be preserved");
    }
    if (uk.name !== existingKey.name) {
      throw new Error("Name cannot be updated");
    }
    if (!uk.id !== !uk.data) {
      throw new Error("Both or none of the id and data attributes must be provided. Old key ID: " + uk.oldKeyId);
    }
    if (uk.data && existingKey.meta?.private && !uk.meta?.private) {
      throw new Error("Missing private key. Old key ID: " + uk.oldKeyId);
    }
    if (uk.id && uk.id !== uk.oldKeyId) {
      updatedMap[uk.id] = uk.oldKeyId;
    }
    const updatedKey = omit3(existingKey, [
      "_notAfterHeight",
      "_notBeforeHeight"
    ]);
    if (uk.permissions) {
      updatedKey.permissions = uk.permissions;
    }
    if (uk.allowedActions) {
      updatedKey.allowedActions = uk.allowedActions;
    }
    if (uk.purpose) {
      updatedKey.purpose = uk.purpose;
    }
    if (uk.meta) {
      updatedKey.meta = uk.meta;
    }
    if (uk.id) {
      updatedKey.id = uk.id;
    }
    if (uk.data) {
      updatedKey.data = uk.data;
    }
    return updatedKey;
  }).filter(Boolean);
  validateKeyAddPermissions.call(this, contractID, signingKey, state, keys, true);
  return [
    keys,
    updatedMap
  ];
};
var keyAdditionProcessor = function(_msg, hash3, keys, state, contractID, _signingKey, internalSideEffectStack) {
  const decryptedKeys = [];
  const keysToPersist = [];
  const storeSecretKey = (key, decryptedKey) => {
    const decryptedDeserializedKey = deserializeKey(decryptedKey);
    const transient = !!key.meta?.private?.transient;
    esm_default("chelonia/storeSecretKeys", new Secret([
      {
        key: decryptedDeserializedKey,
        // We always set this to true because this could be done from
        // an outgoing message
        transient: true
      }
    ]));
    if (!transient) {
      keysToPersist.push({
        key: decryptedDeserializedKey,
        transient
      });
    }
  };
  for (const wkey of keys) {
    const data = this.config.unwrapMaybeEncryptedData(wkey);
    if (!data) continue;
    const key = data.data;
    let decryptedKey;
    if (key.meta?.private && key.meta.private.content) {
      if (key.id && key.meta.private.content && !esm_default("chelonia/haveSecretKey", key.id, !key.meta.private.transient)) {
        const decryptedKeyResult = this.config.unwrapMaybeEncryptedData(key.meta.private.content);
        if (decryptedKeyResult) {
          if (decryptedKeyResult.encryptionKeyId == null) {
            throw new Error("Expected encrypted data but got unencrypted data for key with ID: " + key.id);
          }
          decryptedKey = decryptedKeyResult.data;
          decryptedKeys.push([
            key.id,
            decryptedKey
          ]);
          storeSecretKey(key, decryptedKey);
        }
      }
    }
    if (key.name === "#sak") {
      if (data.encryptionKeyId) {
        throw new Error("#sak may not be encrypted");
      }
      if (key.permissions && (!Array.isArray(key.permissions) || key.permissions.length !== 0)) {
        throw new Error("#sak may not have permissions");
      }
      if (!Array.isArray(key.purpose) || key.purpose.length !== 1 || key.purpose[0] !== "sak") {
        throw new Error("#sak must have exactly one purpose: 'sak'");
      }
      if (key.ringLevel !== 0) {
        throw new Error("#sak must have ringLevel 0");
      }
    }
    if (key.name.startsWith("#inviteKey-")) {
      if (!state._vm.invites) state._vm.invites = /* @__PURE__ */ Object.create(null);
      const inviteSecret = decryptedKey || (has2(this.transientSecretKeys, key.id) ? serializeKey(this.transientSecretKeys[key.id], true) : void 0);
      state._vm.invites[key.id] = {
        status: INVITE_STATUS.VALID,
        initialQuantity: key.meta.quantity,
        quantity: key.meta.quantity,
        expires: key.meta.expires,
        inviteSecret,
        responses: []
      };
    }
    if (key.meta?.keyRequest?.contractID && findSuitableSecretKeyId(state, [
      SPMessage.OP_KEY_ADD
    ], [
      "sig"
    ])) {
      const data2 = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.contractID);
      if (data2 && internalSideEffectStack) {
        const keyRequestContractID = data2.data;
        const reference = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.reference);
        internalSideEffectStack.push(() => {
          esm_default("chelonia/private/queueEvent", keyRequestContractID, () => {
            const rootState = esm_default(this.config.stateSelector);
            const originatingContractState = rootState[contractID];
            if (esm_default("chelonia/contract/hasKeyShareBeenRespondedBy", originatingContractState, keyRequestContractID, reference)) {
              return;
            }
            if (!has2(rootState, keyRequestContractID)) this.config.reactiveSet(rootState, keyRequestContractID, /* @__PURE__ */ Object.create(null));
            const targetState = rootState[keyRequestContractID];
            if (!targetState._volatile) {
              this.config.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
            }
            if (!targetState._volatile.pendingKeyRequests) {
              this.config.reactiveSet(rootState[keyRequestContractID]._volatile, "pendingKeyRequests", []);
            }
            if (targetState._volatile.pendingKeyRequests.some((pkr) => {
              return pkr && pkr.contractID === contractID && pkr.hash === hash3;
            })) {
              return;
            }
            targetState._volatile.pendingKeyRequests.push({
              contractID,
              name: key.name,
              hash: hash3,
              reference: reference?.data
            });
            this.setPostSyncOp(contractID, "pending-keys-for-" + keyRequestContractID, [
              "okTurtles.events/emit",
              CONTRACT_IS_PENDING_KEY_REQUESTS,
              {
                contractID: keyRequestContractID
              }
            ]);
          }).catch((e2) => {
            console.error("Error while setting or updating pendingKeyRequests", {
              contractID,
              keyRequestContractID,
              reference
            }, e2);
          });
        });
      }
    }
  }
  if (keysToPersist.length) {
    internalSideEffectStack?.push(() => {
      esm_default("chelonia/storeSecretKeys", new Secret(keysToPersist));
    });
  }
  internalSideEffectStack?.push(() => subscribeToForeignKeyContracts.call(this, contractID, state));
};
var subscribeToForeignKeyContracts = function(contractID, state) {
  try {
    Object.values(state._vm.authorizedKeys).filter((key) => !!key.foreignKey && findKeyIdByName(state, key.name) != null).forEach((key) => {
      const foreignKey = String(key.foreignKey);
      const fkUrl = new URL(foreignKey);
      const foreignContract = fkUrl.pathname;
      const foreignKeyName = fkUrl.searchParams.get("keyName");
      if (!foreignContract || !foreignKeyName) {
        console.warn("Invalid foreign key: missing contract or key name", {
          contractID,
          keyId: key.id
        });
        return;
      }
      const rootState = esm_default(this.config.stateSelector);
      const signingKey = findSuitableSecretKeyId(state, [
        SPMessage.OP_KEY_DEL
      ], [
        "sig"
      ], key.ringLevel);
      const canMirrorOperations = !!signingKey;
      if (!canMirrorOperations) return;
      if (Array.isArray(rootState?.[foreignContract]?._volatile?.watch)) {
        if (rootState[foreignContract]._volatile.watch.find((v2) => v2[0] === key.name && v2[1] === contractID)) return;
      }
      if (!has2(state._vm, "pendingWatch")) this.config.reactiveSet(state._vm, "pendingWatch", /* @__PURE__ */ Object.create(null));
      if (!has2(state._vm.pendingWatch, foreignContract)) this.config.reactiveSet(state._vm.pendingWatch, foreignContract, []);
      if (!state._vm.pendingWatch[foreignContract].find(([n]) => n === foreignKeyName)) {
        state._vm.pendingWatch[foreignContract].push([
          foreignKeyName,
          key.id
        ]);
      }
      this.setPostSyncOp(contractID, `watchForeignKeys-${contractID}`, [
        "chelonia/private/watchForeignKeys",
        contractID
      ]);
    });
  } catch (e2) {
    console.warn("Error at subscribeToForeignKeyContracts: " + (e2.message || e2));
  }
};
var recreateEvent = (entry, state, contractsState, disableAutoDedup) => {
  const { HEAD: previousHEAD, height: previousHeight, previousKeyOp } = contractsState || {};
  if (!previousHEAD) {
    throw new Error("recreateEvent: Giving up because the contract has been removed");
  }
  const head = entry.head();
  const [opT, rawOpV] = entry.rawOp();
  const recreateOperation = (opT2, rawOpV2) => {
    const opV = rawOpV2.valueOf();
    const recreateOperationInternal = (opT3, opV2) => {
      let newOpV2;
      if (opT3 === SPMessage.OP_KEY_ADD) {
        if (!Array.isArray(opV2)) throw new Error("Invalid message format");
        newOpV2 = opV2.filter((k) => {
          const kId = k.valueOf().id;
          return !has2(state._vm.authorizedKeys, kId) || state._vm.authorizedKeys[kId]._notAfterHeight != null;
        });
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_KEY_ADD", {
            head
          });
        } else if (newOpV2.length === opV2.length) {
          return opV2;
        }
      } else if (opT3 === SPMessage.OP_KEY_DEL) {
        if (!Array.isArray(opV2)) throw new Error("Invalid message format");
        newOpV2 = opV2.filter((keyId2) => {
          const kId = Object(keyId2).valueOf();
          return has2(state._vm.authorizedKeys, kId) && state._vm.authorizedKeys[kId]._notAfterHeight == null;
        });
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_KEY_DEL", {
            head
          });
        } else if (newOpV2.length === opV2.length) {
          return opV2;
        }
      } else if (opT3 === SPMessage.OP_KEY_UPDATE) {
        if (!Array.isArray(opV2)) throw new Error("Invalid message format");
        newOpV2 = opV2.filter((k) => {
          const oKId = k.valueOf().oldKeyId;
          const nKId = k.valueOf().id;
          return nKId == null || has2(state._vm.authorizedKeys, oKId) && state._vm.authorizedKeys[oKId]._notAfterHeight == null;
        });
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_KEY_UPDATE", {
            head
          });
        } else if (newOpV2.length === opV2.length) {
          return opV2;
        }
      } else if (opT3 === SPMessage.OP_ATOMIC) {
        if (!Array.isArray(opV2)) throw new Error("Invalid message format");
        newOpV2 = opV2.map(([t, v2]) => [
          t,
          recreateOperationInternal(t, v2)
        ]).filter(([, v2]) => !!v2);
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_ATOMIC", {
            head
          });
        } else if (newOpV2.length === opV2.length && newOpV2.reduce((acc, cv, i2) => acc && cv === opV2[i2], true)) {
          return opV2;
        } else {
          return newOpV2;
        }
      } else {
        return opV2;
      }
    };
    const newOpV = recreateOperationInternal(opT2, opV);
    if (newOpV === opV) {
      return rawOpV2;
    } else if (newOpV === void 0) {
      return;
    }
    if (typeof rawOpV2.recreate !== "function") {
      throw new Error("Unable to recreate operation");
    }
    return rawOpV2.recreate(newOpV);
  };
  const newRawOpV = disableAutoDedup ? rawOpV : recreateOperation(opT, rawOpV);
  if (!newRawOpV) return;
  const newOp = [
    opT,
    newRawOpV
  ];
  entry = SPMessage.cloneWith(head, newOp, {
    previousKeyOp,
    previousHEAD,
    height: previousHeight + 1
  });
  return entry;
};
var getContractIDfromKeyId = (contractID, signingKeyId, state) => {
  if (!signingKeyId) return;
  return signingKeyId && state._vm?.authorizedKeys?.[signingKeyId]?.foreignKey ? new URL(state._vm.authorizedKeys[signingKeyId].foreignKey).pathname : contractID;
};
function eventsAfter(contractID, { sinceHeight, limit, sinceHash, stream = true }) {
  if (!contractID) {
    throw new Error("Missing contract ID");
  }
  let lastUrl;
  const fetchEventsStreamReader = async () => {
    requestLimit = Math.min(limit ?? MAX_EVENTS_AFTER, remainingEvents);
    lastUrl = `${this.config.connectionURL}/eventsAfter/${contractID}/${sinceHeight}${Number.isInteger(requestLimit) ? `/${requestLimit}` : ""}`;
    const eventsResponse = await this.config.fetch(lastUrl, {
      signal
    });
    if (!eventsResponse.ok) {
      const msg = `${eventsResponse.status}: ${eventsResponse.statusText}`;
      if (eventsResponse.status === 404 || eventsResponse.status === 410) throw new ChelErrorResourceGone(msg, {
        cause: eventsResponse.status
      });
      throw new ChelErrorUnexpectedHttpResponseCode(msg, {
        cause: eventsResponse.status
      });
    }
    if (!eventsResponse.body) throw new Error("Missing body");
    latestHeight = parseInt(eventsResponse.headers.get("shelter-headinfo-height"), 10);
    if (!Number.isSafeInteger(latestHeight)) throw new Error("Invalid latest height");
    requestCount++;
    return eventsResponse.body.getReader();
  };
  if (!Number.isSafeInteger(sinceHeight) || sinceHeight < 0) {
    throw new TypeError("Invalid since height value. Expected positive integer.");
  }
  const signal = this.abortController.signal;
  let requestCount = 0;
  let remainingEvents = limit ?? Number.POSITIVE_INFINITY;
  let eventsStreamReader;
  let latestHeight;
  let state = "fetch";
  let requestLimit;
  let count;
  let buffer = "";
  let currentEvent;
  const s = new ReadableStream({
    // The pull function is called whenever the internal buffer of the stream
    // becomes empty and needs more data.
    async pull(controller) {
      try {
        for (; ; ) {
          switch (state) {
            // When in 'fetch' state, initiate a new fetch request to obtain a
            // stream reader for events.
            case "fetch": {
              eventsStreamReader = await fetchEventsStreamReader();
              state = "read-new-response";
              count = 0;
              break;
            }
            case "read-eos":
            case "read-new-response":
            case "read": {
              const { done, value } = await eventsStreamReader.read();
              if (done) {
                if (remainingEvents === 0 || sinceHeight >= latestHeight) {
                  controller.close();
                  return;
                } else if (state === "read-new-response" || buffer) {
                  throw new Error("Invalid response: done too early");
                } else {
                  state = "fetch";
                  break;
                }
              }
              if (!value) {
                throw new Error("Invalid response: missing body");
              }
              buffer = buffer + Buffer5.from(value).toString().trim();
              if (!buffer) break;
              if (state === "read-new-response") {
                if (buffer[0] !== "[") {
                  throw new Error("Invalid response: no array start delimiter");
                }
                buffer = buffer.slice(1);
              } else if (state === "read-eos") {
                throw new Error("Invalid data at the end of response");
              }
              state = "events";
              break;
            }
            case "events": {
              const nextIdx = buffer.search(/(?<=\s*)[,\]]/);
              if (nextIdx < 0) {
                state = "read";
                break;
              }
              let enqueued = false;
              try {
                const eventValue = buffer.slice(0, nextIdx).trim();
                if (eventValue) {
                  if (count === requestLimit) {
                    throw new Error("Received too many events");
                  }
                  currentEvent = JSON.parse(b64ToStr(JSON.parse(eventValue))).message;
                  if (count === 0) {
                    const hash3 = SPMessage.deserializeHEAD(currentEvent).hash;
                    const height = SPMessage.deserializeHEAD(currentEvent).head.height;
                    if (height !== sinceHeight || sinceHash && sinceHash !== hash3) {
                      if (height === sinceHeight && sinceHash && sinceHash !== hash3) {
                        throw new ChelErrorForkedChain(`Forked chain: hash(${hash3}) !== since(${sinceHash})`);
                      } else {
                        throw new Error(`Unexpected data: hash(${hash3}) !== since(${sinceHash || ""}) or height(${height}) !== since(${sinceHeight})`);
                      }
                    }
                  }
                  if (count++ !== 0 || requestCount !== 0) {
                    controller.enqueue(currentEvent);
                    enqueued = true;
                    remainingEvents--;
                  }
                }
                if (buffer[nextIdx] === "]") {
                  if (currentEvent) {
                    const deserialized = SPMessage.deserializeHEAD(currentEvent);
                    sinceHeight = deserialized.head.height;
                    sinceHash = deserialized.hash;
                    state = "read-eos";
                  } else {
                    state = "eod";
                  }
                  buffer = buffer.slice(nextIdx + 1).trim();
                } else if (currentEvent) {
                  buffer = buffer.slice(nextIdx + 1).trimStart();
                } else {
                  throw new Error("Missing end delimiter");
                }
                if (enqueued) {
                  return;
                }
              } catch (e2) {
                console.error("[chelonia] Error during event parsing", e2);
                throw e2;
              }
              break;
            }
            case "eod": {
              if (remainingEvents === 0 || sinceHeight >= latestHeight) {
                controller.close();
              } else {
                throw new Error("Unexpected end of data");
              }
              return;
            }
          }
        }
      } catch (e2) {
        console.error("[eventsAfter] Error", {
          lastUrl
        }, e2);
        eventsStreamReader?.cancel("Error during pull").catch((e22) => {
          console.error("Error canceling underlying event stream reader on error", e2, e22);
        });
        throw e2;
      }
    }
  });
  if (stream) return s;
  return collectEventStream(s);
}
function buildShelterAuthorizationHeader(contractID, state) {
  if (!state) state = esm_default(this.config.stateSelector)[contractID];
  const SAKid = findKeyIdByName(state, "#sak");
  if (!SAKid) {
    throw new Error(`Missing #sak in ${contractID}`);
  }
  const SAK = this.transientSecretKeys[SAKid];
  if (!SAK) {
    throw new Error(`Missing secret #sak (${SAKid}) in ${contractID}`);
  }
  const deserializedSAK = typeof SAK === "string" ? deserializeKey(SAK) : SAK;
  const nonceBytes = new Uint8Array(15);
  globalThis.crypto.getRandomValues(nonceBytes);
  const data = `${contractID} ${esm_default("chelonia/time")}.${Buffer5.from(nonceBytes).toString("base64")}`;
  return `shelter ${data}.${sign(deserializedSAK, data)}`;
}
function verifyShelterAuthorizationHeader(authorization, rootState) {
  const regex = /^shelter (([a-zA-Z0-9]+) ([0-9]+)\.([a-zA-Z0-9+/=]{20}))\.([a-zA-Z0-9+/=]+)$/i;
  if (authorization.length > 1024) {
    throw new Error("Authorization header too long");
  }
  const matches = authorization.match(regex);
  if (!matches) {
    throw new Error("Unable to parse shelter authorization header");
  }
  const [, data, contractID, timestamp, , signature] = matches;
  if (Math.abs(parseInt(timestamp) - Date.now()) > 6e4) {
    throw new Error("Invalid signature time range");
  }
  if (!rootState) rootState = esm_default("chelonia/rootState");
  if (!has2(rootState, contractID)) {
    throw new Error(`Contract ${contractID} from shelter authorization header not found`);
  }
  const SAKid = findKeyIdByName(rootState[contractID], "#sak");
  if (!SAKid) {
    throw new Error(`Missing #sak in ${contractID}`);
  }
  const SAK = rootState[contractID]._vm.authorizedKeys[SAKid].data;
  if (!SAK) {
    throw new Error(`Missing secret #sak (${SAKid}) in ${contractID}`);
  }
  const deserializedSAK = deserializeKey(SAK);
  verifySignature(deserializedSAK, data, signature);
  return contractID;
}
var clearObject = (o2) => {
  Object.keys(o2).forEach((k) => delete o2[k]);
};
var reactiveClearObject = (o2, fn) => {
  Object.keys(o2).forEach((k) => fn(o2, k));
};
var checkCanBeGarbageCollected = function(id) {
  const rootState = esm_default(this.config.stateSelector);
  return (
    // Check persistent references
    (!has2(rootState.contracts, id) || !rootState.contracts[id] || !has2(rootState.contracts[id], "references")) && // Check ephemeral references
    !has2(this.ephemeralReferenceCount, id) && // Check foreign keys (i.e., that no keys from this contract are being watched)
    (!has2(rootState, id) || !has2(rootState[id], "_volatile") || !has2(rootState[id]._volatile, "watch") || rootState[id]._volatile.watch.length === 0 || rootState[id]._volatile.watch.filter(([, cID]) => this.subscriptionSet.has(cID)).length === 0)
  );
};
var collectEventStream = async (s) => {
  const reader = s.getReader();
  const r = [];
  for (; ; ) {
    const { done, value } = await reader.read();
    if (done) break;
    r.push(value);
  }
  return r;
};
var logEvtError = (msg, ...args) => {
  if (msg._direction === "outgoing") {
    console.warn(...args);
  } else {
    console.error(...args);
  }
};
var handleFetchResult = (type) => {
  return function(r) {
    if (!r.ok) {
      const msg = `${r.status}: ${r.statusText}`;
      if (r.status === 404 || r.status === 410) throw new ChelErrorResourceGone(msg, {
        cause: r.status
      });
      throw new ChelErrorUnexpectedHttpResponseCode(msg, {
        cause: r.status
      });
    }
    return r[type]();
  };
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/files.mjs
var supportsRequestStreams = typeof window !== "object" || (() => {
  let duplexAccessed = false;
  const hasContentType = new Request("", {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("content-type");
  return duplexAccessed && !hasContentType;
})();
var streamToUint8Array = async (s) => {
  const reader = s.getReader();
  const chunks = [];
  let length4 = 0;
  for (; ; ) {
    const result = await reader.read();
    if (result.done) break;
    chunks.push(coerce3(result.value));
    length4 += result.value.byteLength;
  }
  const body = new Uint8Array(length4);
  chunks.reduce((offset, chunk) => {
    body.set(chunk, offset);
    return offset + chunk.byteLength;
  }, 0);
  return body;
};
var ArrayBufferToUint8ArrayStream = async function(connectionURL, s) {
  if (supportsRequestStreams === true) {
    await this.config.fetch(`${connectionURL}/streams-test`, {
      method: "POST",
      body: new ReadableStream({
        start(c) {
          c.enqueue(Buffer6.from("ok"));
          c.close();
        }
      }),
      duplex: "half"
    }).then((r) => {
      if (!r.ok) throw new Error("Unexpected response");
      supportsRequestStreams = 2;
    }).catch(() => {
      console.info("files: Disabling streams support because the streams test failed");
      supportsRequestStreams = false;
    });
  }
  if (!supportsRequestStreams) {
    return await streamToUint8Array(s);
  }
  return s.pipeThrough(
    // eslint-disable-next-line no-undef
    new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(coerce3(chunk));
      }
    })
  );
};
var computeChunkDescriptors = (inStream) => {
  let length4 = 0;
  const [lengthStream, cidStream] = inStream.tee();
  const lengthPromise = new Promise((resolve7, reject) => {
    lengthStream.pipeTo(new WritableStream({
      write(chunk) {
        length4 += chunk.byteLength;
      },
      close() {
        resolve7(length4);
      },
      abort(reason) {
        reject(reason);
      }
    }));
  });
  const cidPromise = createCIDfromStream(cidStream, multicodes.SHELTER_FILE_CHUNK);
  return Promise.all([
    lengthPromise,
    cidPromise
  ]);
};
var fileStream = (chelonia, manifest) => {
  const dataGenerator = async function* () {
    let readSize = 0;
    for (const chunk of manifest.chunks) {
      if (!Array.isArray(chunk) || typeof chunk[0] !== "number" || typeof chunk[1] !== "string") {
        throw new Error("Invalid chunk descriptor");
      }
      const chunkResponse = await chelonia.config.fetch(`${chelonia.config.connectionURL}/file/${chunk[1]}`, {
        method: "GET",
        signal: chelonia.abortController.signal
      });
      if (!chunkResponse.ok) {
        throw new Error("Unable to retrieve manifest");
      }
      const chunkBinary = await chunkResponse.arrayBuffer();
      if (chunkBinary.byteLength !== chunk[0]) throw new Error("mismatched chunk size");
      readSize += chunkBinary.byteLength;
      if (readSize > manifest.size) throw new Error("read size exceeds declared size");
      if (createCID(coerce3(chunkBinary), multicodes.SHELTER_FILE_CHUNK) !== chunk[1]) throw new Error("mismatched chunk hash");
      yield chunkBinary;
    }
    if (readSize !== manifest.size) throw new Error("mismatched size");
  };
  const dataIterator = dataGenerator();
  return new ReadableStream({
    async pull(controller) {
      try {
        const chunk = await dataIterator.next();
        if (chunk.done) {
          controller.close();
          return;
        }
        controller.enqueue(chunk.value);
      } catch (e2) {
        controller.error(e2);
      }
    }
  });
};
var aes256gcmHandlers = {
  upload: (_chelonia, manifestOptions) => {
    const params = manifestOptions["cipher-params"];
    let IKM = params?.IKM;
    const recordSize = params?.rs ?? 1 << 16;
    if (!IKM) {
      IKM = new Uint8Array(33);
      self.crypto.getRandomValues(IKM);
    }
    const keyId2 = blake32Hash("aes256gcm-keyId" + blake32Hash(IKM)).slice(-8);
    const binaryKeyId = Buffer6.from(keyId2);
    return {
      cipherParams: {
        keyId: keyId2
      },
      streamHandler: async (stream) => {
        return await K2(e, stream, recordSize, binaryKeyId, IKM);
      },
      downloadParams: {
        IKM: Buffer6.from(IKM).toString("base64"),
        rs: recordSize
      }
    };
  },
  download: (chelonia, downloadParams, manifest) => {
    const IKMb64 = downloadParams.IKM;
    if (!IKMb64) {
      throw new Error("Missing IKM in downloadParams");
    }
    const IKM = Buffer6.from(IKMb64, "base64");
    const keyId2 = blake32Hash("aes256gcm-keyId" + blake32Hash(IKM)).slice(-8);
    if (!manifest["cipher-params"] || !manifest["cipher-params"].keyId) {
      throw new Error("Missing cipher-params");
    }
    if (keyId2 !== manifest["cipher-params"].keyId) {
      throw new Error("Key ID mismatch");
    }
    const maxRecordSize = downloadParams.rs ?? 1 << 27;
    return {
      payloadHandler: async () => {
        const bytes = await streamToUint8Array(S(e, fileStream(chelonia, manifest), (actualKeyId) => {
          if (Buffer6.from(actualKeyId).toString() !== keyId2) {
            throw new Error("Invalid key ID");
          }
          return IKM;
        }, maxRecordSize));
        return new Blob([
          bytes
        ], {
          type: manifest.type || "application/octet-stream"
        });
      }
    };
  }
};
var noneHandlers = {
  upload: () => {
    return {
      cipherParams: void 0,
      streamHandler: (stream) => {
        return stream;
      },
      downloadParams: void 0
    };
  },
  download: (chelonia, _downloadParams, manifest) => {
    return {
      payloadHandler: async () => {
        const bytes = await streamToUint8Array(fileStream(chelonia, manifest));
        return new Blob([
          bytes
        ], {
          type: manifest.type || "application/octet-stream"
        });
      }
    };
  }
};
var cipherHandlers = {
  aes256gcm: aes256gcmHandlers,
  none: noneHandlers
};
var files_default = esm_default("sbp/selectors/register", {
  "chelonia/fileUpload": async function(chunks, manifestOptions, { billableContractID } = {}) {
    if (!Array.isArray(chunks)) chunks = [
      chunks
    ];
    const chunkDescriptors = [];
    const cipherHandler = await cipherHandlers[manifestOptions.cipher]?.upload?.(this, manifestOptions);
    if (!cipherHandler) throw new Error("Unsupported cipher");
    const cipherParams = cipherHandler.cipherParams;
    const transferParts = await Promise.all(chunks.map(async (chunk, i2) => {
      const stream2 = chunk.stream();
      const encryptedStream = await cipherHandler.streamHandler(stream2);
      const [body, s] = encryptedStream.tee();
      chunkDescriptors.push(computeChunkDescriptors(s));
      return {
        headers: new Headers([
          [
            "content-disposition",
            `form-data; name="${i2}"; filename="${i2}"`
          ],
          [
            "content-type",
            "application/octet-stream"
          ]
        ]),
        body
      };
    }));
    transferParts.push({
      headers: new Headers([
        [
          "content-disposition",
          'form-data; name="manifest"; filename="manifest.json"'
        ],
        [
          "content-type",
          "application/vnd.shelter.filemanifest"
        ]
      ]),
      body: new ReadableStream({
        async start(controller) {
          const chunks2 = await Promise.all(chunkDescriptors);
          const manifest = {
            version: "1.0.0",
            // ?? undefined coerces null and undefined to undefined
            // This ensures that null or undefined values don't make it to the
            // JSON (otherwise, null values _would_ be stringified as 'null')
            type: manifestOptions.type ?? void 0,
            meta: manifestOptions.meta ?? void 0,
            cipher: manifestOptions.cipher,
            "cipher-params": cipherParams,
            size: chunks2.reduce((acc, [cv]) => acc + cv, 0),
            chunks: chunks2,
            "name-map": manifestOptions["name-map"] ?? void 0,
            alternatives: manifestOptions.alternatives ?? void 0
          };
          controller.enqueue(Buffer6.from(JSON.stringify(manifest)));
          controller.close();
        }
      })
    });
    const boundary = typeof self.crypto?.randomUUID === "function" ? self.crypto.randomUUID() : new Array(36).fill("").map(() => "abcdefghijklmnopqrstuvwxyz"[(0, Math.random)() * 26 | 0]).join("");
    const stream = x2(boundary, transferParts);
    const deletionToken = "deletionToken" + generateSalt();
    const deletionTokenHash = blake32Hash(deletionToken);
    const uploadResponse = await this.config.fetch(`${this.config.connectionURL}/file`, {
      method: "POST",
      signal: this.abortController.signal,
      body: await ArrayBufferToUint8ArrayStream.call(this, this.config.connectionURL, stream),
      headers: new Headers([
        ...billableContractID ? [
          [
            "authorization",
            buildShelterAuthorizationHeader.call(this, billableContractID)
          ]
        ] : [],
        [
          "content-type",
          `multipart/form-data; boundary=${boundary}`
        ],
        [
          "shelter-deletion-token-digest",
          deletionTokenHash
        ]
      ]),
      duplex: "half"
    });
    if (!uploadResponse.ok) throw new Error("Error uploading file");
    return {
      download: {
        manifestCid: await uploadResponse.text(),
        downloadParams: cipherHandler.downloadParams
      },
      delete: deletionToken
    };
  },
  "chelonia/fileDownload": async function(downloadOptions, manifestChecker) {
    const { manifestCid, downloadParams } = downloadOptions.valueOf();
    const manifestResponse = await this.config.fetch(`${this.config.connectionURL}/file/${manifestCid}`, {
      method: "GET",
      signal: this.abortController.signal
    });
    if (!manifestResponse.ok) {
      throw new Error("Unable to retrieve manifest");
    }
    const manifestBinary = await manifestResponse.arrayBuffer();
    if (createCID(coerce3(manifestBinary), multicodes.SHELTER_FILE_MANIFEST) !== manifestCid) throw new Error("mismatched manifest hash");
    const manifest = JSON.parse(Buffer6.from(manifestBinary).toString());
    if (typeof manifest !== "object") throw new Error("manifest format is invalid");
    if (manifest.version !== "1.0.0") throw new Error("unsupported manifest version");
    if (!Array.isArray(manifest.chunks)) throw new Error("missing required field: chunks");
    if (manifestChecker) {
      const proceed = await manifestChecker?.(manifest);
      if (!proceed) return false;
    }
    const cipherHandler = await cipherHandlers[manifest.cipher]?.download?.(this, downloadParams, manifest);
    if (!cipherHandler) throw new Error("Unsupported cipher");
    return cipherHandler.payloadHandler();
  },
  "chelonia/fileDelete": async function(manifestCid, credentials = {}) {
    if (!manifestCid) {
      throw new TypeError("A manifest CID must be provided");
    }
    if (!Array.isArray(manifestCid)) manifestCid = [
      manifestCid
    ];
    return await Promise.allSettled(manifestCid.map(async (cid) => {
      const hasCredential = has2(credentials, cid);
      const hasToken = has2(credentials[cid], "token") && credentials[cid].token;
      const hasBillableContractID = has2(credentials[cid], "billableContractID") && credentials[cid].billableContractID;
      if (!hasCredential || hasToken === hasBillableContractID) {
        throw new TypeError(`Either a token or a billable contract ID must be provided for ${cid}`);
      }
      const response = await this.config.fetch(`${this.config.connectionURL}/deleteFile/${cid}`, {
        method: "POST",
        signal: this.abortController.signal,
        headers: new Headers([
          [
            "authorization",
            hasToken ? `bearer ${credentials[cid].token.valueOf()}` : buildShelterAuthorizationHeader.call(this, credentials[cid].billableContractID)
          ]
        ])
      });
      if (!response.ok) {
        throw new Error(`Unable to delete file ${cid}`);
      }
    }));
  }
});

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/db.mjs
import { Buffer as Buffer7 } from "node:buffer";
var headPrefix = "head=";
var getContractIdFromLogHead = (key) => {
  if (!key.startsWith(headPrefix)) return;
  return key.slice(headPrefix.length);
};
var getLogHead = (contractID) => `${headPrefix}${contractID}`;
var checkKey = (key) => {
  if (/[\x00-\x1f\x7f\t\\/<>:"|?*]/.test(key)) {
    throw new Error(`bad key: ${JSON.stringify(key)}`);
  }
};
var parsePrefixableKey = (key) => {
  const i2 = key.indexOf(":");
  if (i2 === -1) {
    return [
      "",
      key
    ];
  }
  const prefix = key.slice(0, i2 + 1);
  if (prefix in prefixHandlers) {
    return [
      prefix,
      key.slice(prefix.length)
    ];
  }
  throw new ChelErrorDBConnection(`Unknown prefix in '${key}'.`);
};
var prefixHandlers = {
  // Decode buffers, but don't transform other values.
  "": (value) => Buffer7.isBuffer(value) ? value.toString("utf8") : value,
  "any:": (value) => value
};
esm_default("sbp/selectors/unsafe", [
  "chelonia.db/get",
  "chelonia.db/set",
  "chelonia.db/delete"
]);
var dbPrimitiveSelectors = process.env.LIGHTWEIGHT_CLIENT === "true" ? {
  "chelonia.db/get": function(key) {
    const id = getContractIdFromLogHead(key);
    if (!id) return Promise.resolve();
    const state = esm_default("chelonia/rootState").contracts[id];
    const value = state?.HEAD ? JSON.stringify({
      HEAD: state.HEAD,
      height: state.height,
      previousKeyOp: state.previousKeyOp
    }) : void 0;
    return Promise.resolve(value);
  },
  "chelonia.db/set": function() {
    return Promise.resolve();
  },
  "chelonia.db/delete": function() {
    return Promise.resolve(true);
  }
} : {
  // eslint-disable-next-line require-await
  "chelonia.db/get": async function(prefixableKey) {
    const [prefix, key] = parsePrefixableKey(prefixableKey);
    const value = esm_default("okTurtles.data/get", key);
    if (value === void 0) {
      return;
    }
    return prefixHandlers[prefix](value);
  },
  // eslint-disable-next-line require-await
  "chelonia.db/set": async function(key, value) {
    checkKey(key);
    return esm_default("okTurtles.data/set", key, value);
  },
  // eslint-disable-next-line require-await
  "chelonia.db/delete": async function(key) {
    return esm_default("okTurtles.data/delete", key);
  }
};
var db_default = esm_default("sbp/selectors/register", {
  ...dbPrimitiveSelectors,
  "chelonia/db/getEntryMeta": async (contractID, height) => {
    const entryMetaJson = await esm_default("chelonia.db/get", `_private_hidx=${contractID}#${height}`);
    if (!entryMetaJson) return;
    return JSON.parse(entryMetaJson);
  },
  "chelonia/db/setEntryMeta": async (contractID, height, entryMeta) => {
    const entryMetaJson = JSON.stringify(entryMeta);
    await esm_default("chelonia.db/set", `_private_hidx=${contractID}#${height}`, entryMetaJson);
  },
  "chelonia/db/latestHEADinfo": async (contractID) => {
    const r = await esm_default("chelonia.db/get", getLogHead(contractID));
    return r && JSON.parse(r);
  },
  "chelonia/db/deleteLatestHEADinfo": (contractID) => {
    return esm_default("chelonia.db/set", getLogHead(contractID), "");
  },
  "chelonia/db/getEntry": async function(hash3) {
    try {
      const value = await esm_default("chelonia.db/get", hash3);
      if (!value) throw new Error(`no entry for ${hash3}!`);
      return SPMessage.deserialize(value, this.transientSecretKeys, void 0, this.config.unwrapMaybeEncryptedData);
    } catch (e2) {
      throw new ChelErrorDBConnection(`${e2.name} during getEntry: ${e2.message}`);
    }
  },
  "chelonia/db/addEntry": function(entry) {
    return esm_default("okTurtles.eventQueue/queueEvent", `chelonia/db/${entry.contractID()}`, [
      "chelonia/private/db/addEntry",
      entry
    ]);
  },
  // NEVER call this directly yourself! _always_ call 'chelonia/db/addEntry' instead
  "chelonia/private/db/addEntry": async function(entry) {
    try {
      const { previousHEAD: entryPreviousHEAD, previousKeyOp: entryPreviousKeyOp, height: entryHeight } = entry.head();
      const contractID = entry.contractID();
      if (await esm_default("chelonia.db/get", entry.hash())) {
        console.warn(`[chelonia.db] entry exists: ${entry.hash()}`);
        return entry.hash();
      }
      const HEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
      if (!entry.isFirstMessage()) {
        if (!HEADinfo) {
          throw new Error(`No latest HEAD for ${contractID} when attempting to process entry with previous HEAD ${entryPreviousHEAD} at height ${entryHeight}`);
        }
        const { HEAD: contractHEAD, previousKeyOp: contractPreviousKeyOp, height: contractHeight } = HEADinfo;
        if (entryPreviousHEAD !== contractHEAD) {
          console.warn(`[chelonia.db] bad previousHEAD: ${entryPreviousHEAD}! Expected: ${contractHEAD} for contractID: ${contractID}`);
          throw new ChelErrorDBBadPreviousHEAD(`bad previousHEAD: ${entryPreviousHEAD}. Expected ${contractHEAD} for contractID: ${contractID}`);
        } else if (entryPreviousKeyOp !== contractPreviousKeyOp) {
          console.error(`[chelonia.db] bad previousKeyOp: ${entryPreviousKeyOp}! Expected: ${contractPreviousKeyOp} for contractID: ${contractID}`);
          throw new ChelErrorDBBadPreviousHEAD(`bad previousKeyOp: ${entryPreviousKeyOp}. Expected ${contractPreviousKeyOp} for contractID: ${contractID}`);
        } else if (!Number.isSafeInteger(entryHeight) || entryHeight !== contractHeight + 1) {
          console.error(`[chelonia.db] bad height: ${entryHeight}! Expected: ${contractHeight + 1} for contractID: ${contractID}`);
          throw new ChelErrorDBBadPreviousHEAD(`[chelonia.db] bad height: ${entryHeight}! Expected: ${contractHeight + 1} for contractID: ${contractID}`);
        }
      } else {
        if (HEADinfo) {
          console.error(`[chelonia.db] bad previousHEAD: ${entryPreviousHEAD}! Expected: <null> for contractID: ${contractID}`);
          throw new ChelErrorDBBadPreviousHEAD(`bad previousHEAD: ${entryPreviousHEAD}. Expected <null> for contractID: ${contractID}`);
        } else if (entryHeight !== 0) {
          console.error(`[chelonia.db] bad height: ${entryHeight}! Expected: 0 for contractID: ${contractID}`);
          throw new ChelErrorDBBadPreviousHEAD(`[chelonia.db] bad height: ${entryHeight}! Expected: 0 for contractID: ${contractID}`);
        }
      }
      await esm_default("chelonia.db/set", entry.hash(), entry.serialize());
      await esm_default("chelonia.db/set", getLogHead(contractID), JSON.stringify({
        HEAD: entry.hash(),
        previousKeyOp: entry.isKeyOp() ? entry.hash() : entry.previousKeyOp(),
        height: entry.height()
      }));
      console.debug(`[chelonia.db] HEAD for ${contractID} updated to:`, entry.hash());
      await esm_default("chelonia/db/setEntryMeta", contractID, entryHeight, {
        // The hash is used for reverse lookups (height to CID)
        hash: entry.hash(),
        // The date isn't currently used, but will be used for filtering messages
        date: (/* @__PURE__ */ new Date()).toISOString(),
        // isKeyOp is used for filtering messages (the actual filtering is
        // done more efficiently a separate index key, but `isKeyOp` allows
        // us to bootstrap this process without having to load the full message)
        // The separate index key bears the prefix `_private_keyop_idx_`.
        ...entry.isKeyOp() && {
          isKeyOp: true
        }
      });
      return entry.hash();
    } catch (e2) {
      if (e2.name.includes("ErrorDB")) {
        throw e2;
      }
      throw new ChelErrorDBConnection(`${e2.name} during addEntry: ${e2.message}`);
    }
  },
  "chelonia/db/lastEntry": async function(contractID) {
    try {
      const latestHEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
      if (!latestHEADinfo) throw new Error(`contract ${contractID} has no latest hash!`);
      return esm_default("chelonia/db/getEntry", latestHEADinfo.HEAD);
    } catch (e2) {
      throw new ChelErrorDBConnection(`${e2.name} during lastEntry: ${e2.message}`);
    }
  }
});

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/internals.mjs
var missingDecryptionKeyIdsMap = /* @__PURE__ */ new WeakMap();
var getMsgMeta = function(message, contractID, state, index) {
  const signingKeyId = message.signingKeyId();
  let innerSigningKeyId = null;
  const config2 = this.config;
  const result = {
    signingKeyId,
    get signingContractID() {
      return getContractIDfromKeyId(contractID, signingKeyId, state);
    },
    get innerSigningKeyId() {
      if (innerSigningKeyId === null) {
        const value = message.message();
        const data = config2.unwrapMaybeEncryptedData(value);
        if (data?.data && isSignedData(data.data)) {
          innerSigningKeyId = data.data.signingKeyId;
        } else {
          innerSigningKeyId = void 0;
        }
        return innerSigningKeyId;
      }
    },
    get innerSigningContractID() {
      return getContractIDfromKeyId(contractID, result.innerSigningKeyId, state);
    },
    index
  };
  return result;
};
var keysToMap = function(keys_, height, authorizedKeys) {
  const keys = keys_.map((key) => {
    const data = this.config.unwrapMaybeEncryptedData(key);
    if (!data) return void 0;
    if (data.encryptionKeyId) {
      data.data._private = data.encryptionKeyId;
    }
    return data.data;
  }).filter(Boolean);
  const keysCopy = cloneDeep2(keys);
  return Object.fromEntries(keysCopy.map((key) => {
    key._notBeforeHeight = height;
    if (authorizedKeys?.[key.id]) {
      if (authorizedKeys[key.id]._notAfterHeight == null) {
        throw new ChelErrorKeyAlreadyExists(`Cannot set existing unrevoked key: ${key.id}`);
      }
      key._notBeforeHeight = Math.min(height, authorizedKeys[key.id]._notBeforeHeight ?? 0);
    } else {
      key._notBeforeHeight = height;
    }
    delete key._notAfterHeight;
    return [
      key.id,
      key
    ];
  }));
};
var keyRotationHelper = (contractID, state, config2, updatedKeysMap, requiredPermissions, outputSelector, outputMapper, internalSideEffectStack) => {
  if (!internalSideEffectStack || !Array.isArray(state._volatile?.watch)) return;
  const rootState = esm_default(config2.stateSelector);
  const watchMap = /* @__PURE__ */ Object.create(null);
  state._volatile.watch.forEach(([name, cID]) => {
    if (!updatedKeysMap[name] || watchMap[cID] === null) {
      return;
    }
    if (!watchMap[cID]) {
      if (!rootState.contracts[cID]?.type || !findSuitableSecretKeyId(rootState[cID], [
        SPMessage.OP_KEY_UPDATE
      ], [
        "sig"
      ])) {
        watchMap[cID] = null;
        return;
      }
      watchMap[cID] = [];
    }
    watchMap[cID].push(name);
  });
  Object.entries(watchMap).forEach(([cID, names]) => {
    if (!Array.isArray(names) || !names.length) return;
    const [keyNamesToUpdate, signingKeyId] = names.map((name) => {
      const foreignContractKey = rootState[cID]?._vm?.authorizedKeys?.[updatedKeysMap[name].oldKeyId];
      if (!foreignContractKey) return void 0;
      const signingKeyId2 = findSuitableSecretKeyId(rootState[cID], requiredPermissions, [
        "sig"
      ], foreignContractKey.ringLevel);
      if (signingKeyId2) {
        return [
          [
            name,
            foreignContractKey.name
          ],
          signingKeyId2,
          rootState[cID]._vm.authorizedKeys[signingKeyId2].ringLevel
        ];
      }
      return void 0;
    }).filter(Boolean).reduce((acc, [name, signingKeyId2, ringLevel]) => {
      acc[0].push(name);
      return ringLevel < acc[2] ? [
        acc[0],
        signingKeyId2,
        ringLevel
      ] : acc;
    }, [
      [],
      void 0,
      Number.POSITIVE_INFINITY
    ]);
    if (!signingKeyId) return;
    const contractName = rootState.contracts[cID]?.type;
    internalSideEffectStack?.push(() => {
      esm_default(outputSelector, {
        contractID: cID,
        contractName,
        data: keyNamesToUpdate.map(outputMapper).map((v2) => {
          return v2;
        }),
        signingKeyId
      }).catch((e2) => {
        console.warn(`Error mirroring key operation (${outputSelector}) from ${contractID} to ${cID}: ${e2?.message || e2}`);
      });
    });
  });
};
var internals_default = esm_default("sbp/selectors/register", {
  //     DO NOT CALL ANY OF THESE YOURSELF!
  "chelonia/private/state": function() {
    return this.state;
  },
  "chelonia/private/invoke": function(instance, invocation) {
    if (this._instance !== instance) {
      console.info("['chelonia/private/invoke] Not proceeding with invocation as Chelonia was restarted", {
        invocation
      });
      return;
    }
    if (Array.isArray(invocation)) {
      return esm_default(...invocation);
    } else if (typeof invocation === "function") {
      return invocation();
    } else {
      throw new TypeError(`[chelonia/private/invoke] Expected invocation to be an array or a function. Saw ${typeof invocation} instead.`);
    }
  },
  "chelonia/private/queueEvent": function(queueName, invocation) {
    return esm_default("okTurtles.eventQueue/queueEvent", queueName, [
      "chelonia/private/invoke",
      this._instance,
      invocation
    ]);
  },
  "chelonia/private/verifyManifestSignature": function(contractName, manifestHash, manifest) {
    if (!has2(manifest, "signature") || typeof manifest.signature.keyId !== "string" || typeof manifest.signature.value !== "string") {
      throw new Error(`Invalid or missing signature field for manifest ${manifestHash} (named ${contractName})`);
    }
    const rootState = esm_default(this.config.stateSelector);
    if (!has2(rootState, "contractSigningKeys")) {
      this.config.reactiveSet(rootState, "contractSigningKeys", /* @__PURE__ */ Object.create(null));
    }
    const contractNameLookupKey = `name:${contractName}`;
    let signatureValidated = false;
    if (process.env.UNSAFE_TRUST_ALL_MANIFEST_SIGNING_KEYS !== "true" && has2(rootState.contractSigningKeys, contractNameLookupKey)) {
      console.info(`[chelonia] verifying signature for ${manifestHash} with an existing key`);
      if (!has2(rootState.contractSigningKeys[contractNameLookupKey], manifest.signature.keyId)) {
        console.error(`The manifest with ${manifestHash} (named ${contractName}) claims to be signed with a key with ID ${manifest.signature.keyId}, which is not trusted. The trusted key IDs for this name are:`, Object.keys(rootState.contractSigningKeys[contractNameLookupKey]));
        throw new Error(`Invalid or missing signature in manifest ${manifestHash} (named ${contractName}). It claims to be signed with a key with ID ${manifest.signature.keyId}, which has not been authorized for this contract before.`);
      }
      const signingKey = rootState.contractSigningKeys[contractNameLookupKey][manifest.signature.keyId];
      verifySignature(signingKey, manifest.body + manifest.head, manifest.signature.value);
      console.info(`[chelonia] successful signature verification for ${manifestHash} (named ${contractName}) using the already-trusted key ${manifest.signature.keyId}.`);
      signatureValidated = true;
    }
    const body = JSON.parse(manifest.body);
    if (!signatureValidated) {
      console.info(`[chelonia] verifying signature for ${manifestHash} (named ${contractName}) for the first time`);
      if (!has2(body, "signingKeys") || !Array.isArray(body.signingKeys)) {
        throw new Error(`Invalid manifest file ${manifestHash} (named ${contractName}). Its body doesn't contain a 'signingKeys' list'`);
      }
      let contractSigningKeys;
      try {
        contractSigningKeys = Object.fromEntries(body.signingKeys.map((serializedKey) => {
          return [
            keyId(serializedKey),
            serializedKey
          ];
        }));
      } catch (e2) {
        console.error(`[chelonia] Error parsing the public keys list for ${manifestHash} (named ${contractName})`, e2);
        throw e2;
      }
      if (!has2(contractSigningKeys, manifest.signature.keyId)) {
        throw new Error(`Invalid or missing signature in manifest ${manifestHash} (named ${contractName}). It claims to be signed with a key with ID ${manifest.signature.keyId}, which is not listed in its 'signingKeys' field.`);
      }
      verifySignature(contractSigningKeys[manifest.signature.keyId], manifest.body + manifest.head, manifest.signature.value);
      console.info(`[chelonia] successful signature verification for ${manifestHash} (named ${contractName}) using ${manifest.signature.keyId}. The following key IDs will now be trusted for this contract name`, Object.keys(contractSigningKeys));
      signatureValidated = true;
      rootState.contractSigningKeys[contractNameLookupKey] = contractSigningKeys;
    }
    return body;
  },
  "chelonia/private/loadManifest": async function(contractName, manifestHash) {
    if (!contractName || typeof contractName !== "string") {
      throw new Error("Invalid or missing contract name");
    }
    if (this.manifestToContract[manifestHash]) {
      console.warn("[chelonia]: already loaded manifest", manifestHash);
      return;
    }
    const manifestSource = await esm_default("chelonia/out/fetchResource", manifestHash, {
      code: multicodes.SHELTER_CONTRACT_MANIFEST
    });
    const manifest = JSON.parse(manifestSource);
    const body = esm_default("chelonia/private/verifyManifestSignature", contractName, manifestHash, manifest);
    if (body.name !== contractName) {
      throw new Error(`Mismatched contract name. Expected ${contractName} but got ${body.name}`);
    }
    const contractInfo = this.config.contracts.defaults.preferSlim && body.contractSlim || body.contract;
    console.info(`[chelonia] loading contract '${contractInfo.file}'@'${body.version}' from manifest: ${manifestHash}`);
    const source = await esm_default("chelonia/out/fetchResource", contractInfo.hash, {
      code: multicodes.SHELTER_CONTRACT_TEXT
    });
    const reduceAllow = (acc, v2) => {
      acc[v2] = true;
      return acc;
    };
    const allowedSels = [
      "okTurtles.events/on",
      "chelonia/defineContract",
      "chelonia/out/keyRequest"
    ].concat(this.config.contracts.defaults.allowedSelectors).reduce(reduceAllow, {});
    const allowedDoms = this.config.contracts.defaults.allowedDomains.reduce(reduceAllow, {});
    const contractSBP = (selector, ...args) => {
      const domain2 = domainFromSelector(selector);
      if (selector.startsWith(contractName + "/")) {
        selector = `${manifestHash}/${selector}`;
      }
      if (allowedSels[selector] || allowedDoms[domain2]) {
        return esm_default(selector, ...args);
      } else {
        console.error("[chelonia] selector not on allowlist", {
          selector,
          allowedSels,
          allowedDoms
        });
        throw new Error(`[chelonia] selector not on allowlist: '${selector}'`);
      }
    };
    const saferEval = new Function(`
      return function (globals) {
        // almost a real sandbox
        // stops (() => this)().fetch
        // needs additional step of locking down Function constructor to stop:
        // new (()=>{}).constructor("console.log(typeof this.fetch)")()
        globals.self = globals
        globals.globalThis = globals
        with (new Proxy(globals, {
          get (o, p) { return o[p] },
          has (o, p) { /* console.log('has', p); */ return true }
        })) {
          (function () {
            'use strict'
            ${source}
          })()
        }
      }
    `)();
    this.defContractSBP = contractSBP;
    this.defContractManifest = manifestHash;
    saferEval({
      // pass in globals that we want access to by default in the sandbox
      // note: you can undefine these by setting them to undefined in exposedGlobals
      crypto: {
        getRandomValues: (v2) => globalThis.crypto.getRandomValues(v2)
      },
      ...typeof window === "object" && window && {
        alert: window.alert.bind(window),
        confirm: window.confirm.bind(window),
        prompt: window.prompt.bind(window)
      },
      isNaN,
      console,
      Object,
      Error,
      TypeError,
      RangeError,
      Math,
      Symbol,
      Date,
      Array,
      BigInt,
      Boolean,
      String,
      Number,
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Float32Array,
      Float64Array,
      ArrayBuffer,
      JSON,
      RegExp,
      parseFloat,
      parseInt,
      Promise,
      Function,
      Map,
      WeakMap,
      ...this.config.contracts.defaults.exposedGlobals,
      require: (dep) => {
        return dep === "@sbp/sbp" ? contractSBP : this.config.contracts.defaults.modules[dep];
      },
      sbp: contractSBP,
      fetchServerTime: async (fallback = true) => {
        try {
          const response = await this.config.fetch(`${this.config.connectionURL}/time`, {
            signal: this.abortController.signal
          });
          return handleFetchResult("text")(response);
        } catch (e2) {
          console.warn("[fetchServerTime] Error", e2);
          if (fallback) {
            return new Date(esm_default("chelonia/time")).toISOString();
          }
          throw new ChelErrorFetchServerTimeFailed("Can not fetch server time. Please check your internet connection.");
        }
      }
    });
    if (contractName !== this.defContract.name) {
      throw new Error(`Invalid contract name for manifest ${manifestHash}. Expected ${contractName} but got ${this.defContract.name}`);
    }
    this.defContractSelectors.forEach((s) => {
      allowedSels[s] = true;
    });
    this.manifestToContract[manifestHash] = {
      slim: contractInfo === body.contractSlim,
      info: contractInfo,
      contract: this.defContract
    };
  },
  // Warning: avoid using this unless you know what you're doing. Prefer using /remove.
  "chelonia/private/removeImmediately": function(contractID, params) {
    const state = esm_default(this.config.stateSelector);
    const contractName = state.contracts[contractID]?.type;
    if (!contractName) {
      console.error("[chelonia/private/removeImmediately] Missing contract name for contract", {
        contractID
      });
      return;
    }
    const manifestHash = this.config.contracts.manifests[contractName];
    if (manifestHash) {
      const destructor = `${manifestHash}/${contractName}/_cleanup`;
      if (esm_default("sbp/selectors/fn", destructor)) {
        try {
          esm_default(destructor, {
            contractID,
            resync: !!params?.resync,
            state: state[contractID]
          });
        } catch (e2) {
          console.error(`[chelonia/private/removeImmediately] Error at destructor for ${contractID}`, e2);
        }
      }
    }
    if (params?.resync) {
      Object.keys(state.contracts[contractID]).filter((k) => k !== "references").forEach((k) => this.config.reactiveDel(state.contracts[contractID], k));
      Object.keys(state[contractID]).filter((k) => k !== "_volatile").forEach((k) => this.config.reactiveDel(state[contractID], k));
      if (state[contractID]._volatile) {
        Object.keys(state[contractID]._volatile).filter((k) => k !== "watch").forEach((k) => this.config.reactiveDel(state[contractID]._volatile, k));
      }
    } else {
      delete this.ephemeralReferenceCount[contractID];
      if (params?.permanent) {
        this.config.reactiveSet(state.contracts, contractID, null);
      } else {
        this.config.reactiveDel(state.contracts, contractID);
      }
      this.config.reactiveDel(state, contractID);
    }
    this.subscriptionSet.delete(contractID);
    esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
      added: [],
      removed: [
        contractID
      ],
      permanent: params?.permanent,
      resync: params?.resync
    });
  },
  // used by, e.g. 'chelonia/contract/wait'
  "chelonia/private/noop": function() {
  },
  "chelonia/private/out/sync": function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [
      contractIDs
    ] : contractIDs;
    const forcedSync = !!params?.force;
    return Promise.all(listOfIds.map((contractID) => {
      if (!forcedSync && this.subscriptionSet.has(contractID)) {
        const rootState = esm_default(this.config.stateSelector);
        if (!rootState[contractID]?._volatile?.dirty) {
          return esm_default("chelonia/private/queueEvent", contractID, [
            "chelonia/private/noop"
          ]);
        }
      }
      return esm_default("chelonia/private/queueEvent", contractID, [
        "chelonia/private/in/syncContract",
        contractID,
        params
      ]).catch((err) => {
        console.error(`[chelonia] failed to sync ${contractID}:`, err);
        throw err;
      });
    }));
  },
  "chelonia/private/out/publishEvent": function(entry, { maxAttempts = 5, headers, billableContractID, bearer, disableAutoDedup } = {}, hooks) {
    const contractID = entry.contractID();
    const originalEntry = entry;
    return esm_default("chelonia/private/queueEvent", `publish:${contractID}`, async () => {
      let attempt = 1;
      let lastAttemptedHeight;
      await hooks?.prepublish?.(entry);
      const onreceivedHandler = (_contractID, message) => {
        if (entry.hash() === message.hash()) {
          esm_default("okTurtles.events/off", EVENT_HANDLED, onreceivedHandler);
          hooks.onprocessed(entry);
        }
      };
      if (typeof hooks?.onprocessed === "function") {
        esm_default("okTurtles.events/on", EVENT_HANDLED, onreceivedHandler);
      }
      while (true) {
        lastAttemptedHeight = entry.height();
        const newEntry = await esm_default("chelonia/private/queueEvent", contractID, async () => {
          const rootState = esm_default(this.config.stateSelector);
          const state = rootState[contractID];
          const isFirstMessage = entry.isFirstMessage();
          if (!state && !isFirstMessage) {
            console.info(`[chelonia] Not sending message as contract state has been removed: ${entry.description()}`);
            return;
          }
          if (hooks?.preSendCheck) {
            if (!await hooks.preSendCheck(entry, state)) {
              console.info(`[chelonia] Not sending message as preSendCheck hook returned non-truish value: ${entry.description()}`);
              return;
            }
          }
          await esm_default("chelonia/private/in/processMessage", entry, cloneDeep2(state || {}));
          if (!isFirstMessage) {
            return recreateEvent(entry, state, rootState.contracts[contractID], disableAutoDedup);
          }
          return entry;
        });
        if (!newEntry) return;
        await hooks?.beforeRequest?.(newEntry, entry);
        entry = newEntry;
        const r = await this.config.fetch(`${this.config.connectionURL}/event`, {
          method: "POST",
          body: entry.serialize(),
          headers: {
            ...headers,
            ...bearer && {
              Authorization: `Bearer ${bearer}`
            },
            ...billableContractID && {
              Authorization: buildShelterAuthorizationHeader.call(this, billableContractID)
            },
            "Content-Type": "text/plain"
          },
          signal: this.abortController.signal
        });
        if (r.ok) {
          await hooks?.postpublish?.(entry);
          return entry;
        }
        try {
          if (r.status === 409) {
            if (attempt + 1 > maxAttempts) {
              console.error(`[chelonia] failed to publish ${entry.description()} after ${attempt} attempts`, entry);
              throw new Error(`publishEvent: ${r.status} - ${r.statusText}. attempt ${attempt}`);
            }
            const randDelay = randomIntFromRange(0, 1500);
            console.warn(`[chelonia] publish attempt ${attempt} of ${maxAttempts} failed. Waiting ${randDelay} msec before resending ${entry.description()}`);
            attempt += 1;
            await delay(randDelay);
            if (!entry.isFirstMessage() && entry.height() === lastAttemptedHeight) {
              await esm_default("chelonia/private/out/sync", contractID, {
                force: true
              });
            }
          } else {
            const message = (await r.json())?.message;
            console.error(`[chelonia] ERROR: failed to publish ${entry.description()}: ${r.status} - ${r.statusText}: ${message}`, entry);
            throw new Error(`publishEvent: ${r.status} - ${r.statusText}: ${message}`);
          }
        } catch (e2) {
          esm_default("okTurtles.events/off", EVENT_HANDLED, onreceivedHandler);
          throw e2;
        }
      }
    }).then((entry2) => {
      esm_default("okTurtles.events/emit", EVENT_PUBLISHED, {
        contractID,
        message: entry2,
        originalMessage: originalEntry
      });
      return entry2;
    }).catch((e2) => {
      esm_default("okTurtles.events/emit", EVENT_PUBLISHING_ERROR, {
        contractID,
        message: entry,
        originalMessage: originalEntry,
        error: e2
      });
      throw e2;
    });
  },
  "chelonia/private/out/latestHEADinfo": function(contractID) {
    return this.config.fetch(`${this.config.connectionURL}/latestHEADinfo/${contractID}`, {
      cache: "no-store",
      signal: this.abortController.signal
    }).then(handleFetchResult("json"));
  },
  "chelonia/private/postKeyShare": function(contractID, previousVolatileState, signingKey) {
    const cheloniaState = esm_default(this.config.stateSelector);
    const targetState = cheloniaState[contractID];
    if (!targetState) return;
    if (previousVolatileState && has2(previousVolatileState, "watch")) {
      if (!targetState._volatile) this.config.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
      if (!targetState._volatile.watch) {
        this.config.reactiveSet(targetState._volatile, "watch", previousVolatileState.watch);
      } else if (targetState._volatile.watch !== previousVolatileState.watch) {
        previousVolatileState.watch.forEach((pWatch) => {
          if (!targetState._volatile.watch.some((tWatch) => {
            return tWatch[0] === pWatch[0] && tWatch[1] === pWatch[1];
          })) {
            targetState._volatile.watch.push(pWatch);
          }
        });
      }
    }
    if (!Array.isArray(targetState._volatile?.pendingKeyRequests)) return;
    this.config.reactiveSet(targetState._volatile, "pendingKeyRequests", targetState._volatile.pendingKeyRequests.filter((pkr) => pkr?.name !== signingKey.name));
  },
  "chelonia/private/in/processMessage": async function(message, state, internalSideEffectStack, contractName) {
    const [opT, opV] = message.op();
    const hash3 = message.hash();
    const height = message.height();
    const contractID = message.contractID();
    const manifestHash = message.manifest();
    const signingKeyId = message.signingKeyId();
    const direction = message.direction();
    const config2 = this.config;
    const self2 = this;
    const opName = Object.entries(SPMessage).find(([, y]) => y === opT)?.[0];
    console.debug("PROCESSING OPCODE:", opName, "to", contractID);
    if (state?._volatile?.dirty) {
      console.debug("IGNORING OPCODE BECAUSE CONTRACT STATE IS MARKED AS DIRTY.", "OPCODE:", opName, "CONTRACT:", contractID);
      return;
    }
    if (!state._vm) state._vm = /* @__PURE__ */ Object.create(null);
    const opFns = {
      /*
              There are two types of "errors" that we need to consider:
              1. "Ignoring" errors
              2. "Failure" errors
              Example: OP_KEY_ADD
              1. IGNORING: an error is thrown because we wanted to add a key but the key we wanted to add is already there. This is not a hard error, it's an ignoring error. We don't care that the operation failed in this case because the intent was accomplished.
              2. FAILURE: an error is thrown while attempting to add a key that doesn't exist.
              Example: OP_ACTION_ENCRYPTED
              1. IGNORING: An error is thrown because we don't have the key to decrypt the action. We ignore it.
              2. FAILURE: An error is thrown by the process function during processing.
              Handling these in OP_ATOMIC
               ALL errors of class "IGNORING" should be ignored. They should not impact our ability to process the rest of the operations in the OP_ATOMIC. No matter how many of these are thrown, it doesn't affect the rest of the operations.
               ANY error of class "FAILURE" will call the rest of the operations to fail and the state to be reverted to prior to the OP_ATOMIC. No side-effects should be run. Because an intention failed.
            */
      async [SPMessage.OP_ATOMIC](v2) {
        for (let i2 = 0; i2 < v2.length; i2++) {
          const u2 = v2[i2];
          try {
            if (u2[0] === SPMessage.OP_ATOMIC) throw new Error("Cannot nest OP_ATOMIC");
            if (!validateKeyPermissions(message, config2, state, signingKeyId, u2[0], u2[1])) {
              throw new Error("Inside OP_ATOMIC: no matching signing key was defined");
            }
            await opFns[u2[0]](u2[1]);
          } catch (e_) {
            const e2 = e_;
            if (e2 && typeof e2 === "object") {
              if (e2.name === "ChelErrorDecryptionKeyNotFound") {
                console.warn(`[chelonia] [OP_ATOMIC] WARN '${e2.name}' in processMessage for ${message.description()}: ${e2.message}`, e2, message.serialize());
                if (e2.cause) {
                  const missingDecryptionKeyIds = missingDecryptionKeyIdsMap.get(message);
                  if (missingDecryptionKeyIds) {
                    missingDecryptionKeyIds.add(e2.cause);
                  } else {
                    missingDecryptionKeyIdsMap.set(message, /* @__PURE__ */ new Set([
                      e2.cause
                    ]));
                  }
                }
                continue;
              } else {
                logEvtError(message, `[chelonia] [OP_ATOMIC] ERROR '${e2.name}' in processMessage for ${message.description()}: ${e2.message || e2}`, e2, message.serialize());
              }
              console.warn(`[chelonia] [OP_ATOMIC] Error processing ${message.description()}: ${message.serialize()}. Any side effects will be skipped!`);
              if (config2.strictProcessing) {
                throw e2;
              }
              config2.hooks.processError?.(e2, message, getMsgMeta.call(self2, message, contractID, state));
              if (e2.name === "ChelErrorWarning") continue;
            } else {
              logEvtError(message, "Inside OP_ATOMIC: Non-object or null error thrown", contractID, message, i2, e2);
            }
            throw e2;
          }
        }
      },
      [SPMessage.OP_CONTRACT](v2) {
        state._vm.type = v2.type;
        const keys = keysToMap.call(self2, v2.keys, height);
        state._vm.authorizedKeys = keys;
        keyAdditionProcessor.call(self2, message, hash3, v2.keys, state, contractID, signingKey, internalSideEffectStack);
      },
      [SPMessage.OP_ACTION_ENCRYPTED](v2) {
        if (config2.skipActionProcessing) {
          if (!config2.skipDecryptionAttempts) {
            console.log("OP_ACTION_ENCRYPTED: skipped action processing");
          }
          return;
        }
        return opFns[SPMessage.OP_ACTION_UNENCRYPTED](v2.valueOf());
      },
      async [SPMessage.OP_ACTION_UNENCRYPTED](v2) {
        if (!config2.skipActionProcessing) {
          let innerSigningKeyId;
          if (isSignedData(v2)) {
            innerSigningKeyId = v2.signingKeyId;
            v2 = v2.valueOf();
          }
          const { data, meta, action } = v2;
          if (!config2.whitelisted(action)) {
            throw new Error(`chelonia: action not whitelisted: '${action}'`);
          }
          await esm_default(`${manifestHash}/${action}/process`, {
            data,
            meta,
            hash: hash3,
            height,
            contractID,
            direction: message.direction(),
            signingKeyId,
            get signingContractID() {
              return getContractIDfromKeyId(contractID, signingKeyId, state);
            },
            innerSigningKeyId,
            get innerSigningContractID() {
              return getContractIDfromKeyId(contractID, innerSigningKeyId, state);
            }
          }, state);
        }
      },
      [SPMessage.OP_KEY_SHARE](wv) {
        const data = config2.unwrapMaybeEncryptedData(wv);
        if (!data) return;
        const v2 = data.data;
        for (const key of v2.keys) {
          if (key.id && key.meta?.private?.content) {
            if (!has2(state._vm, "sharedKeyIds")) state._vm.sharedKeyIds = [];
            if (!state._vm.sharedKeyIds.some((sK) => sK.id === key.id)) state._vm.sharedKeyIds.push({
              id: key.id,
              contractID: v2.contractID,
              height,
              keyRequestHash: v2.keyRequestHash,
              keyRequestHeight: v2.keyRequestHeight
            });
          }
        }
        if (has2(v2, "keyRequestHash") && state._vm.authorizedKeys[signingKeyId].meta?.keyRequest) {
          state._vm.authorizedKeys[signingKeyId].meta.keyRequest.responded = hash3;
        }
        internalSideEffectStack?.push(async () => {
          delete self2.postSyncOperations[contractID]?.["pending-keys-for-" + v2.contractID];
          const cheloniaState = esm_default(self2.config.stateSelector);
          const targetState = cheloniaState[v2.contractID];
          const missingDecryptionKeyIds = cheloniaState.contracts[v2.contractID]?.missingDecryptionKeyIds;
          let newestEncryptionKeyHeight = Number.POSITIVE_INFINITY;
          for (const key of v2.keys) {
            if (key.id && key.meta?.private?.content) {
              const transient = direction === "outgoing" || key.meta.private.transient;
              if (!esm_default("chelonia/haveSecretKey", key.id, !transient)) {
                try {
                  const decrypted = key.meta.private.content.valueOf();
                  esm_default("chelonia/storeSecretKeys", new Secret([
                    {
                      key: deserializeKey(decrypted),
                      transient
                    }
                  ]));
                  if (missingDecryptionKeyIds?.includes(key.id)) {
                    newestEncryptionKeyHeight = Number.NEGATIVE_INFINITY;
                  } else if (
                    // Otherwise, we make an educated guess on whether a re-sync
                    // is needed based on the height.
                    targetState?._vm?.authorizedKeys?.[key.id]?._notBeforeHeight != null && Array.isArray(targetState._vm.authorizedKeys[key.id].purpose) && targetState._vm.authorizedKeys[key.id].purpose.includes("enc")
                  ) {
                    newestEncryptionKeyHeight = Math.min(newestEncryptionKeyHeight, targetState._vm.authorizedKeys[key.id]._notBeforeHeight);
                  }
                } catch (e_) {
                  const e2 = e_;
                  if (e2?.name === "ChelErrorDecryptionKeyNotFound") {
                    console.warn(`OP_KEY_SHARE (${hash3} of ${contractID}) missing secret key: ${e2.message}`, e2);
                  } else {
                    console.error(`OP_KEY_SHARE (${hash3} of ${contractID}) error '${e2.message || e2}':`, e2);
                  }
                }
              }
            }
          }
          const mustResync = !!(newestEncryptionKeyHeight < cheloniaState.contracts[v2.contractID]?.height);
          if (mustResync) {
            if (!has2(targetState, "_volatile")) config2.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
            config2.reactiveSet(targetState._volatile, "dirty", true);
            if (!Object.keys(targetState).some((k) => k !== "_volatile")) {
              return;
            }
            const keyDict = /* @__PURE__ */ Object.create(null);
            targetState._volatile?.watch?.forEach(([keyName, contractID2]) => {
              if (!keyDict[keyName]) {
                keyDict[keyName] = [
                  contractID2
                ];
                return;
              }
              keyDict[keyName].push(contractID2);
            });
            const contractIdsToUpdate = Array.from(new Set(Object.entries(keyDict).flatMap(([keyName, contractIDs]) => {
              const keyId2 = findKeyIdByName(targetState, keyName);
              if (
                // Does the key exist? (i.e., is it a current key)
                keyId2 && // Is it an encryption key? (signing keys don't build up a
                // potentially invalid state because the private key isn't
                // required for validation; however, missing encryption keys
                // prevent message processing)
                targetState._vm.authorizedKeys[keyId2].purpose.includes("enc") && // Is this a newly set key? (avoid re-syncing contracts that
                // haven't been affected by the `OP_KEY_SHARE`)
                targetState._vm.authorizedKeys[keyId2]._notBeforeHeight >= newestEncryptionKeyHeight
              ) {
                return contractIDs;
              }
              return [];
            })));
            contractIdsToUpdate.forEach((contractID2) => {
              const targetState2 = cheloniaState[contractID2];
              if (!targetState2) return;
              if (!has2(targetState2, "_volatile")) config2.reactiveSet(targetState2, "_volatile", /* @__PURE__ */ Object.create(null));
              config2.reactiveSet(targetState2._volatile, "dirty", true);
            });
            if (self2.subscriptionSet.has(v2.contractID)) {
              const resync = esm_default("chelonia/private/queueEvent", v2.contractID, [
                "chelonia/private/in/syncContract",
                v2.contractID
              ]).then(() => {
                esm_default("chelonia/private/out/sync", contractIdsToUpdate.filter((contractID2) => {
                  return self2.subscriptionSet.has(contractID2);
                }), {
                  force: true,
                  resync: true
                }).catch((e2) => {
                  console.error("[chelonia] Error resyncing contracts with foreign key references after key rotation", e2);
                });
              }).catch((e2) => {
                console.error(`[chelonia] Error during sync for ${v2.contractID} during OP_KEY_SHARE for ${contractID}`);
                if (v2.contractID === contractID) {
                  throw e2;
                }
              });
              if (v2.contractID !== contractID) {
                await resync;
              }
            }
          }
          const previousVolatileState = targetState?._volatile;
          esm_default("chelonia/private/queueEvent", v2.contractID, [
            "chelonia/private/postKeyShare",
            v2.contractID,
            mustResync ? previousVolatileState : null,
            signingKey
          ]).then(() => {
            esm_default("chelonia/private/queueEvent", contractID, () => {
              esm_default("okTurtles.events/emit", CONTRACT_HAS_RECEIVED_KEYS, {
                contractID: v2.contractID,
                sharedWithContractID: contractID,
                signingKeyId,
                get signingKeyName() {
                  return state._vm?.authorizedKeys?.[signingKeyId]?.name;
                }
              });
            }).catch((e2) => {
              console.error(`[chelonia] Error while emitting the CONTRACT_HAS_RECEIVED_KEYS event for ${contractID}`, e2);
            });
          });
        });
      },
      [SPMessage.OP_KEY_REQUEST](wv) {
        const data = config2.unwrapMaybeEncryptedData(wv);
        const v2 = data?.data || {
          contractID: "(private)",
          replyWith: {
            context: void 0
          },
          request: "*"
        };
        const originatingContractID = v2.contractID;
        if (state._vm?.invites?.[signingKeyId]?.quantity != null) {
          if (state._vm.invites[signingKeyId].quantity > 0) {
            if (--state._vm.invites[signingKeyId].quantity <= 0) {
              state._vm.invites[signingKeyId].status = INVITE_STATUS.USED;
            }
          } else {
            logEvtError(message, "Ignoring OP_KEY_REQUEST because it exceeds allowed quantity: " + originatingContractID);
            return;
          }
        }
        if (state._vm?.invites?.[signingKeyId]?.expires != null) {
          if (state._vm.invites[signingKeyId].expires < Date.now()) {
            logEvtError(message, "Ignoring OP_KEY_REQUEST because it expired at " + state._vm.invites[signingKeyId].expires + ": " + originatingContractID);
            return;
          }
        }
        if (config2.skipActionProcessing || direction === "outgoing") {
          return;
        }
        if (!has2(v2.replyWith, "context")) {
          logEvtError(message, "Ignoring OP_KEY_REQUEST because it is missing the context attribute");
          return;
        }
        const context = v2.replyWith.context;
        if (data && (!Array.isArray(context) || context[0] !== originatingContractID)) {
          logEvtError(message, "Ignoring OP_KEY_REQUEST because it is signed by the wrong contract");
          return;
        }
        if (v2.request !== "*") {
          logEvtError(message, "Ignoring OP_KEY_REQUEST because it has an unsupported request attribute", v2.request);
          return;
        }
        if (!state._vm.pendingKeyshares) state._vm.pendingKeyshares = /* @__PURE__ */ Object.create(null);
        state._vm.pendingKeyshares[message.hash()] = context ? [
          // Full-encryption (i.e., KRS encryption) requires that this request
          // was encrypted and that the invite is marked as private
          !!data?.encryptionKeyId,
          message.height(),
          signingKeyId,
          context
        ] : [
          !!data?.encryptionKeyId,
          message.height(),
          signingKeyId
        ];
        if (data) {
          internalSideEffectStack?.push(() => {
            self2.setPostSyncOp(contractID, "respondToAllKeyRequests-" + message.contractID(), [
              "chelonia/private/respondToAllKeyRequests",
              contractID
            ]);
          });
        }
      },
      [SPMessage.OP_KEY_REQUEST_SEEN](wv) {
        if (config2.skipActionProcessing) {
          return;
        }
        const data = config2.unwrapMaybeEncryptedData(wv);
        if (!data) return;
        const v2 = data.data;
        if (state._vm.pendingKeyshares && v2.keyRequestHash in state._vm.pendingKeyshares) {
          const hash4 = v2.keyRequestHash;
          const pending = state._vm.pendingKeyshares[hash4];
          delete state._vm.pendingKeyshares[hash4];
          if (pending.length !== 4) return;
          const keyId2 = pending[2];
          const originatingContractID = pending[3][0];
          if (Array.isArray(state._vm?.invites?.[keyId2]?.responses)) {
            state._vm?.invites?.[keyId2]?.responses.push(originatingContractID);
          }
          if (!has2(state._vm, "keyshares")) state._vm.keyshares = /* @__PURE__ */ Object.create(null);
          const success2 = v2.success;
          state._vm.keyshares[hash4] = {
            contractID: originatingContractID,
            height,
            success: success2,
            ...success2 && {
              hash: v2.keyShareHash
            }
          };
        }
      },
      [SPMessage.OP_PROP_DEL]: notImplemented,
      [SPMessage.OP_PROP_SET](v2) {
        if (!state._vm.props) state._vm.props = {};
        state._vm.props[v2.key] = v2.value;
      },
      [SPMessage.OP_KEY_ADD](v2) {
        const keys = keysToMap.call(self2, v2, height, state._vm.authorizedKeys);
        const keysArray = Object.values(v2);
        keysArray.forEach((k) => {
          if (has2(state._vm.authorizedKeys, k.id) && state._vm.authorizedKeys[k.id]._notAfterHeight == null) {
            throw new ChelErrorWarning("Cannot use OP_KEY_ADD on existing keys. Key ID: " + k.id);
          }
        });
        validateKeyAddPermissions.call(self2, contractID, signingKey, state, v2);
        state._vm.authorizedKeys = {
          ...state._vm.authorizedKeys,
          ...keys
        };
        keyAdditionProcessor.call(self2, message, hash3, v2, state, contractID, signingKey, internalSideEffectStack);
      },
      [SPMessage.OP_KEY_DEL](v2) {
        if (!state._vm.authorizedKeys) state._vm.authorizedKeys = /* @__PURE__ */ Object.create(null);
        if (!state._volatile) state._volatile = /* @__PURE__ */ Object.create(null);
        if (!state._volatile.pendingKeyRevocations) state._volatile.pendingKeyRevocations = /* @__PURE__ */ Object.create(null);
        validateKeyDelPermissions.call(self2, contractID, signingKey, state, v2);
        const keyIds = v2.map((k) => {
          const data = config2.unwrapMaybeEncryptedData(k);
          if (!data) return void 0;
          return data.data;
        }).filter((keyId2) => {
          if (!keyId2 || typeof keyId2 !== "string") return false;
          if (!has2(state._vm.authorizedKeys, keyId2) || state._vm.authorizedKeys[keyId2]._notAfterHeight != null) {
            console.warn("Attempted to delete non-existent key from contract", {
              contractID,
              keyId: keyId2
            });
            return false;
          }
          return true;
        });
        keyIds.forEach((keyId2) => {
          const key = state._vm.authorizedKeys[keyId2];
          state._vm.authorizedKeys[keyId2]._notAfterHeight = height;
          if (has2(state._volatile.pendingKeyRevocations, keyId2)) {
            delete state._volatile.pendingKeyRevocations[keyId2];
          }
          if (key.foreignKey) {
            const fkUrl = new URL(key.foreignKey);
            const foreignContract = fkUrl.pathname;
            const foreignKeyName = fkUrl.searchParams.get("keyName");
            if (!foreignContract || !foreignKeyName) throw new Error("Invalid foreign key: missing contract or key name");
            internalSideEffectStack?.push(() => {
              esm_default("chelonia/private/queueEvent", foreignContract, () => {
                const rootState = esm_default(config2.stateSelector);
                if (Array.isArray(rootState[foreignContract]?._volatile?.watch)) {
                  const oldWatch = rootState[foreignContract]._volatile.watch;
                  rootState[foreignContract]._volatile.watch = oldWatch.filter(([name, cID]) => name !== foreignKeyName || cID !== contractID);
                  if (oldWatch.length !== rootState[foreignContract]._volatile.watch.length) {
                    esm_default("chelonia/contract/release", foreignContract, {
                      try: true
                    }).catch((e2) => {
                      console.error(`[chelonia] Error at OP_KEY_DEL internalSideEffectStack while attempting to release foreign contract ${foreignContract}`, e2);
                    });
                  }
                }
              }).catch((e2) => {
                console.error("Error stopping watching events after removing key", {
                  contractID,
                  foreignContract,
                  foreignKeyName,
                  fkUrl
                }, e2);
              });
            });
            const pendingWatch = state._vm.pendingWatch?.[foreignContract];
            if (pendingWatch) {
              state._vm.pendingWatch[foreignContract] = pendingWatch.filter(([, kId]) => kId !== keyId2);
            }
          }
          if (key.name.startsWith("#inviteKey-") && state._vm.invites[key.id]) {
            state._vm.invites[key.id].status = INVITE_STATUS.REVOKED;
          }
        });
        if (Array.isArray(state._volatile?.watch)) {
          const updatedKeysMap = /* @__PURE__ */ Object.create(null);
          keyIds.forEach((keyId2) => {
            updatedKeysMap[state._vm.authorizedKeys[keyId2].name] = {
              name: state._vm.authorizedKeys[keyId2].name,
              oldKeyId: keyId2
            };
          });
          keyRotationHelper(contractID, state, config2, updatedKeysMap, [
            SPMessage.OP_KEY_DEL
          ], "chelonia/out/keyDel", (name) => updatedKeysMap[name[0]].oldKeyId, internalSideEffectStack);
        }
      },
      [SPMessage.OP_KEY_UPDATE](v2) {
        if (!state._volatile) state._volatile = /* @__PURE__ */ Object.create(null);
        if (!state._volatile.pendingKeyRevocations) state._volatile.pendingKeyRevocations = /* @__PURE__ */ Object.create(null);
        const [updatedKeys, updatedMap] = validateKeyUpdatePermissions.call(self2, contractID, signingKey, state, v2);
        const keysToDelete = Object.values(updatedMap);
        for (const keyId2 of keysToDelete) {
          if (has2(state._volatile.pendingKeyRevocations, keyId2)) {
            delete state._volatile.pendingKeyRevocations[keyId2];
          }
          state._vm.authorizedKeys[keyId2]._notAfterHeight = height;
        }
        for (const key of updatedKeys) {
          if (!has2(state._vm.authorizedKeys, key.id)) {
            key._notBeforeHeight = height;
            state._vm.authorizedKeys[key.id] = cloneDeep2(key);
          }
        }
        keyAdditionProcessor.call(self2, message, hash3, updatedKeys, state, contractID, signingKey, internalSideEffectStack);
        if (Array.isArray(state._volatile?.watch)) {
          const updatedKeysMap = /* @__PURE__ */ Object.create(null);
          updatedKeys.forEach((key) => {
            if (key.data) {
              updatedKeysMap[key.name] = cloneDeep2(key);
              updatedKeysMap[key.name].oldKeyId = updatedMap[key.id];
            }
          });
          keyRotationHelper(contractID, state, config2, updatedKeysMap, [
            SPMessage.OP_KEY_UPDATE
          ], "chelonia/out/keyUpdate", (name) => ({
            name: name[1],
            oldKeyId: updatedKeysMap[name[0]].oldKeyId,
            id: updatedKeysMap[name[0]].id,
            data: updatedKeysMap[name[0]].data
          }), internalSideEffectStack);
        }
      },
      [SPMessage.OP_PROTOCOL_UPGRADE]: notImplemented
    };
    if (!this.config.skipActionProcessing && !this.manifestToContract[manifestHash]) {
      const rootState = esm_default(this.config.stateSelector);
      if (!contractName) {
        contractName = has2(rootState.contracts, contractID) && rootState.contracts[contractID] && has2(rootState.contracts[contractID], "type") ? rootState.contracts[contractID].type : opT === SPMessage.OP_CONTRACT ? opV.type : "";
      }
      if (!contractName) {
        throw new Error(`Unable to determine the name for a contract and refusing to load it (contract ID was ${contractID} and its manifest hash was ${manifestHash})`);
      }
      await esm_default("chelonia/private/loadManifest", contractName, manifestHash);
    }
    let processOp = true;
    if (config2.preOp) {
      processOp = config2.preOp(message, state) !== false && processOp;
    }
    let signingKey;
    {
      const stateForValidation = opT === SPMessage.OP_CONTRACT && !state?._vm?.authorizedKeys ? {
        _vm: {
          authorizedKeys: keysToMap.call(this, opV.keys, height)
        }
      } : state;
      if (!validateKeyPermissions(message, config2, stateForValidation, signingKeyId, opT, opV)) {
        throw new Error("No matching signing key was defined");
      }
      signingKey = stateForValidation._vm.authorizedKeys[signingKeyId];
    }
    if (config2[`preOp_${opT}`]) {
      processOp = config2[`preOp_${opT}`](message, state) !== false && processOp;
    }
    if (processOp) {
      await opFns[opT](opV);
      config2.postOp?.(message, state);
      config2[`postOp_${opT}`]?.(message, state);
    }
  },
  "chelonia/private/in/enqueueHandleEvent": function(contractID, event) {
    return esm_default("chelonia/private/queueEvent", contractID, async () => {
      await esm_default("chelonia/private/in/handleEvent", contractID, event);
      esm_default("chelonia/private/enqueuePostSyncOps", contractID);
    });
  },
  "chelonia/private/in/syncContract": async function(contractID, params) {
    const state = esm_default(this.config.stateSelector);
    if (state.contracts[contractID] === null) {
      throw new ChelErrorResourceGone("Cannot sync permanently deleted contract " + contractID);
    }
    try {
      this.currentSyncs[contractID] = {
        firstSync: !state.contracts[contractID]?.type
      };
      esm_default("okTurtles.events/emit", CONTRACT_IS_SYNCING, contractID, true);
      const currentVolatileState = state[contractID]?._volatile || /* @__PURE__ */ Object.create(null);
      if (currentVolatileState?.dirty || params?.resync) {
        delete currentVolatileState.dirty;
        currentVolatileState.resyncing = true;
        esm_default("chelonia/private/removeImmediately", contractID, {
          resync: true
        });
        this.config.reactiveSet(state, contractID, /* @__PURE__ */ Object.create(null));
        this.config.reactiveSet(state[contractID], "_volatile", currentVolatileState);
      }
      const { HEAD: latestHEAD } = await esm_default("chelonia/out/latestHEADInfo", contractID);
      console.debug(`[chelonia] syncContract: ${contractID} latestHash is: ${latestHEAD}`);
      const { HEAD: recentHEAD, height: recentHeight } = state.contracts[contractID] || {};
      const isSubscribed = this.subscriptionSet.has(contractID);
      if (!isSubscribed) {
        const entry = this.pending.find((entry2) => entry2?.contractID === contractID);
        if (!entry) {
          this.pending.push({
            contractID
          });
        }
      }
      this.postSyncOperations[contractID] = this.postSyncOperations[contractID] ?? /* @__PURE__ */ Object.create(null);
      if (latestHEAD !== recentHEAD) {
        console.debug(`[chelonia] Synchronizing Contract ${contractID}: our recent was ${recentHEAD || "undefined"} but the latest is ${latestHEAD}`);
        const eventsStream = esm_default("chelonia/out/eventsAfter", contractID, {
          sinceHeight: recentHeight ?? 0,
          sinceHash: recentHEAD ?? contractID
        });
        let latestHashFound = false;
        const eventReader = eventsStream.getReader();
        for (let skip = has2(state.contracts, contractID) && has2(state.contracts[contractID], "HEAD"); ; skip = false) {
          const { done, value: event } = await eventReader.read();
          if (done) {
            if (!latestHashFound) {
              throw new ChelErrorForkedChain(`expected hash ${latestHEAD} in list of events for contract ${contractID}`);
            }
            break;
          }
          if (!latestHashFound) {
            latestHashFound = SPMessage.deserializeHEAD(event).hash === latestHEAD;
          }
          if (skip) continue;
          await esm_default("chelonia/private/in/handleEvent", contractID, event);
        }
      } else if (!isSubscribed) {
        this.subscriptionSet.add(contractID);
        esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
          added: [
            contractID
          ],
          removed: []
        });
        const entryIndex = this.pending.findIndex((entry) => entry?.contractID === contractID);
        if (entryIndex !== -1) {
          this.pending.splice(entryIndex, 1);
        }
        console.debug(`[chelonia] added already synchronized ${contractID} to subscription set`);
      } else {
        console.debug(`[chelonia] contract ${contractID} was already synchronized`);
      }
      esm_default("chelonia/private/enqueuePostSyncOps", contractID);
    } catch (e2) {
      console.error(`[chelonia] syncContract error: ${e2.message || e2}`, e2);
      this.config.hooks.syncContractError?.(e2, contractID);
      throw e2;
    } finally {
      if (state[contractID]?._volatile?.resyncing) {
        this.config.reactiveDel(state[contractID]._volatile, "resyncing");
      }
      delete this.currentSyncs[contractID];
      esm_default("okTurtles.events/emit", CONTRACT_IS_SYNCING, contractID, false);
    }
  },
  "chelonia/private/enqueuePostSyncOps": function(contractID) {
    if (!has2(this.postSyncOperations, contractID)) return;
    Object.entries(this.postSyncOperations[contractID]).forEach(([key, op]) => {
      delete this.postSyncOperations[contractID][key];
      esm_default("chelonia/private/queueEvent", contractID, op).catch((e2) => {
        console.error(`Post-sync operation for ${contractID} failed`, {
          contractID,
          op,
          error: e2
        });
      });
    });
  },
  "chelonia/private/watchForeignKeys": function(externalContractID) {
    const state = esm_default(this.config.stateSelector);
    const externalContractState = state[externalContractID];
    const pendingWatch = externalContractState?._vm?.pendingWatch;
    if (!pendingWatch || !Object.keys(pendingWatch).length) return;
    const signingKey = findSuitableSecretKeyId(externalContractState, [
      SPMessage.OP_KEY_DEL
    ], [
      "sig"
    ]);
    const canMirrorOperations = !!signingKey;
    if (!canMirrorOperations) {
      console.info("[chelonia/private/watchForeignKeys]: Returning as operations cannot be mirrored", {
        externalContractID
      });
      return;
    }
    Object.entries(pendingWatch).forEach(([contractID, keys]) => {
      if (!Array.isArray(keys) || // Check that the keys exist and haven't been revoked
      !keys.reduce((acc, [, id]) => {
        return acc || has2(externalContractState._vm.authorizedKeys, id);
      }, false)) {
        console.info("[chelonia/private/watchForeignKeys]: Skipping as none of the keys to watch exist", {
          externalContractID,
          contractID
        });
        return;
      }
      esm_default("chelonia/private/queueEvent", contractID, [
        "chelonia/private/in/syncContractAndWatchKeys",
        contractID,
        externalContractID
      ]).catch((e2) => {
        console.error(`Error at syncContractAndWatchKeys for contractID ${contractID} and externalContractID ${externalContractID}`, e2);
      });
    });
  },
  "chelonia/private/in/syncContractAndWatchKeys": async function(contractID, externalContractID) {
    const rootState = esm_default(this.config.stateSelector);
    const externalContractState = rootState[externalContractID];
    const pendingWatch = externalContractState?._vm?.pendingWatch?.[contractID]?.splice(0);
    if (!Array.isArray(pendingWatch) || // Check that the keys exist and haven't been revoked
    !pendingWatch.reduce((acc, [, id]) => {
      return acc || has2(externalContractState._vm.authorizedKeys, id) && findKeyIdByName(externalContractState, externalContractState._vm.authorizedKeys[id].name) != null;
    }, false)) {
      console.info("[chelonia/private/syncContractAndWatchKeys]: Skipping as none of the keys to watch exist", {
        externalContractID,
        contractID
      });
      return;
    }
    if (!this.subscriptionSet.has(contractID)) {
      await esm_default("chelonia/private/in/syncContract", contractID);
    }
    const contractState = rootState[contractID];
    const keysToDelete = [];
    const keysToUpdate = [];
    pendingWatch.forEach(([keyName, externalId]) => {
      const keyId2 = findKeyIdByName(contractState, keyName);
      if (!keyId2) {
        keysToDelete.push(externalId);
        return;
      } else if (keyId2 !== externalId) {
        keysToUpdate.push(externalId);
      }
      if (!contractState._volatile) {
        this.config.reactiveSet(contractState, "_volatile", Object.create(null, {
          watch: {
            value: [
              [
                keyName,
                externalContractID
              ]
            ],
            configurable: true,
            enumerable: true,
            writable: true
          }
        }));
      } else {
        if (!contractState._volatile.watch) this.config.reactiveSet(contractState._volatile, "watch", [
          [
            keyName,
            externalContractID
          ]
        ]);
        if (Array.isArray(contractState._volatile.watch) && !contractState._volatile.watch.find((v2) => v2[0] === keyName && v2[1] === externalContractID)) contractState._volatile.watch.push([
          keyName,
          externalContractID
        ]);
      }
    });
    if (keysToDelete.length || keysToUpdate.length) {
      if (!externalContractState._volatile) {
        this.config.reactiveSet(externalContractState, "_volatile", /* @__PURE__ */ Object.create(null));
      }
      if (!externalContractState._volatile.pendingKeyRevocations) {
        this.config.reactiveSet(externalContractState._volatile, "pendingKeyRevocations", /* @__PURE__ */ Object.create(null));
      }
      keysToDelete.forEach((id) => this.config.reactiveSet(externalContractState._volatile.pendingKeyRevocations, id, "del"));
      keysToUpdate.forEach((id) => this.config.reactiveSet(externalContractState._volatile.pendingKeyRevocations, id, true));
      esm_default("chelonia/private/queueEvent", externalContractID, [
        "chelonia/private/deleteOrRotateRevokedKeys",
        externalContractID
      ]).catch((e2) => {
        console.error(`Error at deleteOrRotateRevokedKeys for contractID ${contractID} and externalContractID ${externalContractID}`, e2);
      });
    }
  },
  // The following function gets called when we start watching a contract for
  // foreign keys for the first time, and it ensures that, at the point the
  // watching starts, keys are in sync between the two contracts (later on,
  // this will be handled automatically for incoming OP_KEY_DEL and
  // OP_KEY_UPDATE).
  // For any given foreign key, there are three possible states:
  //   1. The key is in sync with the foreign contract. In this case, there's
  //      nothing left to do.
  //   2. The key has been rotated in the foreign contract (replaced by another
  //      key of the same name). We need to mirror this operation manually
  //      since watching only affects new messages we receive.
  //   3. The key has been removed in the foreign contract. We also need to
  //      mirror the operation.
  "chelonia/private/deleteOrRotateRevokedKeys": function(contractID) {
    const rootState = esm_default(this.config.stateSelector);
    const contractState = rootState[contractID];
    const pendingKeyRevocations = contractState?._volatile?.pendingKeyRevocations;
    if (!pendingKeyRevocations || Object.keys(pendingKeyRevocations).length === 0) return;
    const keysToUpdate = Object.entries(pendingKeyRevocations).filter(([, v2]) => v2 === true).map(([id]) => id);
    const [, keyUpdateSigningKeyId, keyUpdateArgs] = keysToUpdate.reduce((acc, keyId2) => {
      const key = contractState._vm?.authorizedKeys?.[keyId2];
      if (!key || !key.foreignKey) return acc;
      const foreignKey = String(key.foreignKey);
      const fkUrl = new URL(foreignKey);
      const foreignContractID = fkUrl.pathname;
      const foreignKeyName = fkUrl.searchParams.get("keyName");
      if (!foreignKeyName) throw new Error("Missing foreign key name");
      const foreignState = rootState[foreignContractID];
      if (!foreignState) return acc;
      const fKeyId = findKeyIdByName(foreignState, foreignKeyName);
      if (!fKeyId) {
        if (pendingKeyRevocations[keyId2] === true) {
          this.config.reactiveSet(pendingKeyRevocations, keyId2, "del");
        }
        return acc;
      }
      const [currentRingLevel, currentSigningKeyId, currentKeyArgs] = acc;
      const ringLevel = Math.min(currentRingLevel, key.ringLevel ?? Number.POSITIVE_INFINITY);
      if (ringLevel >= currentRingLevel) {
        currentKeyArgs.push({
          name: key.name,
          oldKeyId: keyId2,
          id: fKeyId,
          data: foreignState._vm.authorizedKeys[fKeyId].data
        });
        return [
          currentRingLevel,
          currentSigningKeyId,
          currentKeyArgs
        ];
      } else if (Number.isFinite(ringLevel)) {
        const signingKeyId = findSuitableSecretKeyId(contractState, [
          SPMessage.OP_KEY_UPDATE
        ], [
          "sig"
        ], ringLevel);
        if (signingKeyId) {
          currentKeyArgs.push({
            name: key.name,
            oldKeyId: keyId2,
            id: fKeyId,
            data: foreignState._vm.authorizedKeys[fKeyId].data
          });
          return [
            ringLevel,
            signingKeyId,
            currentKeyArgs
          ];
        }
      }
      return acc;
    }, [
      Number.POSITIVE_INFINITY,
      "",
      []
    ]);
    if (keyUpdateArgs.length !== 0) {
      const contractName = contractState._vm.type;
      esm_default("chelonia/out/keyUpdate", {
        contractID,
        contractName,
        data: keyUpdateArgs,
        signingKeyId: keyUpdateSigningKeyId
      }).catch((e2) => {
        console.error(`[chelonia/private/deleteOrRotateRevokedKeys] Error sending OP_KEY_UPDATE for ${contractID}`, e2.message);
      });
    }
    const keysToDelete = Object.entries(pendingKeyRevocations).filter(([, v2]) => v2 === "del").map(([id]) => id);
    const [, keyDelSigningKeyId, keyIdsToDelete] = keysToDelete.reduce((acc, keyId2) => {
      const [currentRingLevel, currentSigningKeyId, currentKeyIds] = acc;
      const ringLevel = Math.min(currentRingLevel, contractState._vm?.authorizedKeys?.[keyId2]?.ringLevel ?? Number.POSITIVE_INFINITY);
      if (ringLevel >= currentRingLevel) {
        currentKeyIds.push(keyId2);
        return [
          currentRingLevel,
          currentSigningKeyId,
          currentKeyIds
        ];
      } else if (Number.isFinite(ringLevel)) {
        const signingKeyId = findSuitableSecretKeyId(contractState, [
          SPMessage.OP_KEY_DEL
        ], [
          "sig"
        ], ringLevel);
        if (signingKeyId) {
          currentKeyIds.push(keyId2);
          return [
            ringLevel,
            signingKeyId,
            currentKeyIds
          ];
        }
      }
      return acc;
    }, [
      Number.POSITIVE_INFINITY,
      "",
      []
    ]);
    if (keyIdsToDelete.length !== 0) {
      const contractName = contractState._vm.type;
      esm_default("chelonia/out/keyDel", {
        contractID,
        contractName,
        data: keyIdsToDelete,
        signingKeyId: keyDelSigningKeyId
      }).catch((e2) => {
        console.error(`[chelonia/private/deleteRevokedKeys] Error sending OP_KEY_DEL for ${contractID}`, e2.message);
      });
    }
  },
  "chelonia/private/respondToAllKeyRequests": function(contractID) {
    const state = esm_default(this.config.stateSelector);
    const contractState = state[contractID] ?? {};
    const pending = contractState?._vm?.pendingKeyshares;
    if (!pending) return;
    const signingKeyId = findSuitableSecretKeyId(contractState, [
      SPMessage.OP_ATOMIC,
      SPMessage.OP_KEY_REQUEST_SEEN,
      SPMessage.OP_KEY_SHARE
    ], [
      "sig"
    ]);
    if (!signingKeyId) {
      console.log("Unable to respond to key request because there is no suitable secret key with OP_KEY_REQUEST_SEEN permission");
      return;
    }
    Object.entries(pending).map(([hash3, entry]) => {
      if (!Array.isArray(entry) || entry.length !== 4) {
        return void 0;
      }
      const [, , , [originatingContractID]] = entry;
      return esm_default("chelonia/private/queueEvent", originatingContractID, [
        "chelonia/private/respondToKeyRequest",
        contractID,
        signingKeyId,
        hash3
      ]).catch((e2) => {
        console.error(`respondToAllKeyRequests: Error responding to key request ${hash3} from ${originatingContractID} to ${contractID}`, e2);
      });
    });
  },
  "chelonia/private/respondToKeyRequest": async function(contractID, signingKeyId, hash3) {
    const state = esm_default(this.config.stateSelector);
    const contractState = state[contractID];
    const entry = contractState?._vm?.pendingKeyshares?.[hash3];
    const instance = this._instance;
    if (!Array.isArray(entry) || entry.length !== 4) {
      return;
    }
    const [keyShareEncryption, height, , [originatingContractID, rv, originatingContractHeight, headJSON]] = entry;
    entry.pop();
    const krsEncryption = !!contractState._vm.authorizedKeys?.[signingKeyId]?._private;
    await esm_default("chelonia/private/in/syncContract", originatingContractID);
    if (instance !== this._instance) return;
    const originatingState = state[originatingContractID];
    const contractName = state.contracts[contractID].type;
    const originatingContractName = originatingState._vm.type;
    const v2 = signedIncomingData(originatingContractID, originatingState, rv, originatingContractHeight, headJSON).valueOf();
    const { encryptionKeyId } = v2;
    const responseKey = encryptedIncomingData(contractID, contractState, v2.responseKey, height, this.transientSecretKeys, headJSON).valueOf();
    const deserializedResponseKey = deserializeKey(responseKey);
    const responseKeyId = keyId(deserializedResponseKey);
    Promise.resolve().then(() => {
      if (instance !== this._instance) return;
      if (!has2(originatingState._vm.authorizedKeys, responseKeyId) || originatingState._vm.authorizedKeys[responseKeyId]._notAfterHeight != null) {
        throw new Error(`Unable to respond to key request for ${originatingContractID}. Key ${responseKeyId} is not valid.`);
      }
      esm_default("chelonia/storeSecretKeys", new Secret([
        {
          key: deserializedResponseKey
        }
      ]));
      const keys = pick2(state.secretKeys, Object.entries(contractState._vm.authorizedKeys).filter(([, key]) => !!key.meta?.private?.shareable).map(([kId]) => kId));
      if (!keys || Object.keys(keys).length === 0) {
        console.info("respondToAllKeyRequests: no keys to share", {
          contractID,
          originatingContractID
        });
        return;
      }
      const keySharePayload = {
        contractID,
        keys: Object.entries(keys).map(([keyId2, key]) => ({
          id: keyId2,
          meta: {
            private: {
              content: encryptedOutgoingData(originatingContractID, encryptionKeyId, key),
              shareable: true
            }
          }
        })),
        keyRequestHash: hash3,
        keyRequestHeight: height
      };
      if (!contractState?._vm?.pendingKeyshares?.[hash3]) {
        return;
      }
      return keySharePayload;
    }).then((keySharePayload) => {
      if (instance !== this._instance || !keySharePayload) return;
      return esm_default("chelonia/out/keyShare", {
        contractID: originatingContractID,
        contractName: originatingContractName,
        data: keyShareEncryption ? encryptedOutgoingData(originatingContractID, findSuitablePublicKeyIds(originatingState, [
          SPMessage.OP_KEY_SHARE
        ], [
          "enc"
        ])?.[0] || "", keySharePayload) : keySharePayload,
        signingKeyId: responseKeyId
      }).then((msg) => {
        if (instance !== this._instance) return;
        const payload = {
          keyRequestHash: hash3,
          keyShareHash: msg.hash(),
          success: true
        };
        const connectionKeyPayload = {
          contractID: originatingContractID,
          keys: [
            {
              id: responseKeyId,
              meta: {
                private: {
                  content: encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [
                    SPMessage.OP_KEY_REQUEST_SEEN
                  ], [
                    "enc"
                  ])?.[0] || "", responseKey),
                  shareable: true
                }
              }
            }
          ]
        };
        esm_default("chelonia/out/atomic", {
          contractID,
          contractName,
          signingKeyId,
          data: [
            [
              "chelonia/out/keyRequestResponse",
              {
                data: krsEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [
                  SPMessage.OP_KEY_REQUEST_SEEN
                ], [
                  "enc"
                ])?.[0] || "", payload) : payload
              }
            ],
            [
              // Upon successful key share, we want to share deserializedResponseKey
              // with ourselves
              "chelonia/out/keyShare",
              {
                data: keyShareEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [
                  SPMessage.OP_KEY_SHARE
                ], [
                  "enc"
                ])?.[0] || "", connectionKeyPayload) : connectionKeyPayload
              }
            ]
          ]
        }).catch((e2) => {
          console.error("Error at respondToKeyRequest while sending keyRequestResponse", e2);
        });
      });
    }).catch((e2) => {
      console.error("Error at respondToKeyRequest", e2);
      const payload = {
        keyRequestHash: hash3,
        success: false
      };
      if (!contractState?._vm?.pendingKeyshares?.[hash3]) {
        return;
      }
      esm_default("chelonia/out/keyRequestResponse", {
        contractID,
        contractName,
        signingKeyId,
        data: krsEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [
          SPMessage.OP_KEY_REQUEST_SEEN
        ], [
          "enc"
        ])?.[0] || "", payload) : payload
      }).catch((e3) => {
        console.error("Error at respondToKeyRequest while sending keyRequestResponse in error handler", e3);
      });
    });
  },
  "chelonia/private/in/handleEvent": async function(contractID, rawMessage) {
    const state = esm_default(this.config.stateSelector);
    const { preHandleEvent, postHandleEvent, handleEventError } = this.config.hooks;
    let processingErrored = false;
    let message;
    try {
      if (!this.config.acceptAllMessages && !this.pending.some((entry) => entry?.contractID === contractID) && !this.subscriptionSet.has(contractID)) {
        console.warn(`[chelonia] WARN: ignoring unexpected event for ${contractID}:`, rawMessage);
        return;
      }
      const contractStateCopy = state[contractID] ? cloneDeep2(state[contractID]) : /* @__PURE__ */ Object.create(null);
      message = SPMessage.deserialize(rawMessage, this.transientSecretKeys, contractStateCopy, this.config.unwrapMaybeEncryptedData);
      if (message.contractID() !== contractID) {
        throw new Error(`[chelonia] Wrong contract ID. Expected ${contractID} but got ${message.contractID()}`);
      }
      if (!message.isFirstMessage() && (!has2(state.contracts, contractID) || !has2(state, contractID))) {
        throw new ChelErrorUnrecoverable("The event is not for a first message but the contract state is missing");
      }
      preHandleEvent?.(message);
      const proceed = handleEvent.checkMessageOrdering.call(this, message);
      if (proceed === false) return;
      if (state[contractID]?._volatile?.dirty) {
        console.info(`[chelonia] Ignoring message ${message.description()} as the contract is marked as dirty`);
        return;
      }
      const internalSideEffectStack = !this.config.skipSideEffects ? [] : void 0;
      missingDecryptionKeyIdsMap.delete(message);
      try {
        await handleEvent.processMutation.call(this, message, contractStateCopy, internalSideEffectStack);
      } catch (e_) {
        const e2 = e_;
        if (e2?.name === "ChelErrorDecryptionKeyNotFound") {
          console.warn(`[chelonia] WARN '${e2.name}' in processMutation for ${message.description()}: ${e2.message}`, e2, message.serialize());
          if (e2.cause) {
            const missingDecryptionKeyIds = missingDecryptionKeyIdsMap.get(message);
            if (missingDecryptionKeyIds) {
              missingDecryptionKeyIds.add(e2.cause);
            } else {
              missingDecryptionKeyIdsMap.set(message, /* @__PURE__ */ new Set([
                e2.cause
              ]));
            }
          }
        } else {
          console.error(`[chelonia] ERROR '${e2.name}' in processMutation for ${message.description()}: ${e2.message || e2}`, e2, message.serialize());
        }
        console.warn(`[chelonia] Error processing ${message.description()}: ${message.serialize()}. Any side effects will be skipped!`);
        if (this.config.strictProcessing) {
          throw e2;
        }
        processingErrored = e2?.name !== "ChelErrorWarning";
        this.config.hooks.processError?.(e2, message, getMsgMeta.call(this, message, contractID, contractStateCopy));
        if (e2.name === "ChelErrorUnrecoverable" || e2.name === "ChelErrorForkedChain" || message.isFirstMessage()) {
          throw e2;
        }
      }
      if (!processingErrored) {
        if (Array.isArray(internalSideEffectStack) && internalSideEffectStack.length > 0) {
          await Promise.all(internalSideEffectStack.map((fn) => Promise.resolve(fn({
            state: contractStateCopy,
            message
          })).catch((e_) => {
            const e2 = e_;
            console.error(`[chelonia] ERROR '${e2.name}' in internal side effect for ${message.description()}: ${e2.message}`, e2, {
              message: message.serialize()
            });
          })));
        }
        if (!this.config.skipActionProcessing && !this.config.skipSideEffects) {
          await handleEvent.processSideEffects.call(this, message, contractStateCopy)?.catch((e_) => {
            const e2 = e_;
            console.error(`[chelonia] ERROR '${e2.name}' in sideEffect for ${message.description()}: ${e2.message}`, e2, {
              message: message.serialize()
            });
            this.config.hooks.sideEffectError?.(e2, message);
          });
        }
      }
      try {
        const state2 = esm_default(this.config.stateSelector);
        await handleEvent.applyProcessResult.call(this, {
          message,
          state: state2,
          contractState: contractStateCopy,
          processingErrored,
          postHandleEvent
        });
      } catch (e_) {
        const e2 = e_;
        console.error(`[chelonia] ERROR '${e2.name}' for ${message.description()} marking the event as processed: ${e2.message}`, e2, {
          message: message.serialize()
        });
      }
    } catch (e_) {
      const e2 = e_;
      console.error(`[chelonia] ERROR in handleEvent: ${e2.message || e2}`, e2);
      try {
        handleEventError?.(e2, message);
      } catch (e22) {
        console.error("[chelonia] Ignoring user error in handleEventError hook:", e22);
      }
      throw e2;
    } finally {
      if (message) {
        missingDecryptionKeyIdsMap.delete(message);
      }
    }
  }
});
var eventsToReingest = [];
var reprocessDebounced = debounce((contractID) => esm_default("chelonia/private/out/sync", contractID, {
  force: true
}).catch((e2) => {
  console.error(`[chelonia] Error at reprocessDebounced for ${contractID}`, e2);
}), 1e3);
var handleEvent = {
  checkMessageOrdering(message) {
    const contractID = message.contractID();
    const hash3 = message.hash();
    const height = message.height();
    const state = esm_default(this.config.stateSelector);
    const latestProcessedHeight = state.contracts[contractID]?.height;
    if (!Number.isSafeInteger(height)) {
      throw new ChelErrorDBBadPreviousHEAD(`Message ${hash3} in contract ${contractID} has an invalid height.`);
    }
    if (message.isFirstMessage() ? latestProcessedHeight != null : !(latestProcessedHeight < height)) {
      if (!this.config.strictOrdering) {
        return false;
      }
      throw new ChelErrorAlreadyProcessed(`Message ${hash3} with height ${height} in contract ${contractID} has already been processed. Current height: ${latestProcessedHeight}.`);
    }
    if (latestProcessedHeight + 1 < height) {
      if (this.config.strictOrdering) {
        throw new ChelErrorDBBadPreviousHEAD(`Unexpected message ${hash3} with height ${height} in contract ${contractID}: height is too high. Current height: ${latestProcessedHeight}.`);
      }
      if (eventsToReingest.length > 100) {
        throw new ChelErrorUnrecoverable("more than 100 different bad previousHEAD errors");
      }
      if (!eventsToReingest.includes(hash3)) {
        console.warn(`[chelonia] WARN bad previousHEAD for ${message.description()}, will attempt to re-sync contract to reingest message`);
        eventsToReingest.push(hash3);
        reprocessDebounced(contractID);
        return false;
      } else {
        console.error(`[chelonia] ERROR already attempted to reingest ${message.description()}, will not attempt again!`);
        throw new ChelErrorDBBadPreviousHEAD(`Already attempted to reingest ${hash3}`);
      }
    }
    const reprocessIdx = eventsToReingest.indexOf(hash3);
    if (reprocessIdx !== -1) {
      console.warn(`[chelonia] WARN: successfully reingested ${message.description()}`);
      eventsToReingest.splice(reprocessIdx, 1);
    }
  },
  async processMutation(message, state, internalSideEffectStack) {
    const contractID = message.contractID();
    if (message.isFirstMessage()) {
      if (Object.keys(state).some((k) => k !== "_volatile")) {
        throw new ChelErrorUnrecoverable(`state for ${contractID} is already set`);
      }
    }
    await esm_default("chelonia/private/in/processMessage", message, state, internalSideEffectStack);
  },
  processSideEffects(message, state) {
    const opT = message.opType();
    if (![
      SPMessage.OP_ATOMIC,
      SPMessage.OP_ACTION_ENCRYPTED,
      SPMessage.OP_ACTION_UNENCRYPTED
    ].includes(opT)) {
      return;
    }
    const contractID = message.contractID();
    const manifestHash = message.manifest();
    const hash3 = message.hash();
    const height = message.height();
    const signingKeyId = message.signingKeyId();
    const callSideEffect = async (field) => {
      const wv = this.config.unwrapMaybeEncryptedData(field);
      if (!wv) return;
      let v2 = wv.data;
      let innerSigningKeyId;
      if (isSignedData(v2)) {
        innerSigningKeyId = v2.signingKeyId;
        v2 = v2.valueOf();
      }
      const { action, data, meta } = v2;
      const mutation = {
        data,
        meta,
        hash: hash3,
        height,
        contractID,
        description: message.description(),
        direction: message.direction(),
        signingKeyId,
        get signingContractID() {
          return getContractIDfromKeyId(contractID, signingKeyId, state);
        },
        innerSigningKeyId,
        get innerSigningContractID() {
          return getContractIDfromKeyId(contractID, innerSigningKeyId, state);
        }
      };
      return await esm_default(`${manifestHash}/${action}/sideEffect`, mutation, state);
    };
    const msg = Object(message.message());
    if (opT !== SPMessage.OP_ATOMIC) {
      return callSideEffect(msg);
    }
    const reducer = (acc, [opT2, opV]) => {
      if ([
        SPMessage.OP_ACTION_ENCRYPTED,
        SPMessage.OP_ACTION_UNENCRYPTED
      ].includes(opT2)) {
        acc.push(Object(opV));
      }
      return acc;
    };
    const actionsOpV = msg.reduce(reducer, []);
    return Promise.allSettled(actionsOpV.map((action) => callSideEffect(action))).then((results) => {
      const errors = results.filter((r) => r.status === "rejected").map((r) => r.reason);
      if (errors.length > 0) {
        console.error("Side-effect errors", contractID, errors);
        throw new AggregateError(errors, `Error at side effects for ${contractID}`);
      }
    });
  },
  async applyProcessResult({ message, state, contractState, processingErrored, postHandleEvent }) {
    const contractID = message.contractID();
    const hash3 = message.hash();
    const height = message.height();
    await esm_default("chelonia/db/addEntry", message);
    if (!processingErrored) {
      this.config.reactiveSet(state, contractID, contractState);
      try {
        postHandleEvent?.(message);
      } catch (e2) {
        console.error(`[chelonia] ERROR '${e2.name}' for ${message.description()} in event post-handling: ${e2.message}`, e2, {
          message: message.serialize()
        });
      }
    }
    if (message.isFirstMessage()) {
      const { type } = message.opValue();
      if (!has2(state.contracts, contractID)) {
        this.config.reactiveSet(state.contracts, contractID, /* @__PURE__ */ Object.create(null));
      }
      this.config.reactiveSet(state.contracts[contractID], "type", type);
      console.debug(`contract ${type} registered for ${contractID}`);
    }
    if (message.isKeyOp()) {
      this.config.reactiveSet(state.contracts[contractID], "previousKeyOp", hash3);
    }
    this.config.reactiveSet(state.contracts[contractID], "HEAD", hash3);
    this.config.reactiveSet(state.contracts[contractID], "height", height);
    const missingDecryptionKeyIdsForMessage = missingDecryptionKeyIdsMap.get(message);
    if (missingDecryptionKeyIdsForMessage) {
      let missingDecryptionKeyIds = state.contracts[contractID].missingDecryptionKeyIds;
      if (!missingDecryptionKeyIds) {
        missingDecryptionKeyIds = [];
        this.config.reactiveSet(state.contracts[contractID], "missingDecryptionKeyIds", missingDecryptionKeyIds);
      }
      missingDecryptionKeyIdsForMessage.forEach((keyId2) => {
        if (missingDecryptionKeyIds.includes(keyId2)) return;
        missingDecryptionKeyIds.push(keyId2);
      });
    }
    if (!this.subscriptionSet.has(contractID)) {
      const entry = this.pending.find((entry2) => entry2?.contractID === contractID);
      if (entry) {
        const index = this.pending.indexOf(entry);
        if (index !== -1) {
          this.pending.splice(index, 1);
        }
      }
      this.subscriptionSet.add(contractID);
      esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
        added: [
          contractID
        ],
        removed: []
      });
    }
    if (!processingErrored) {
      esm_default("okTurtles.events/emit", hash3, contractID, message);
      esm_default("okTurtles.events/emit", EVENT_HANDLED, contractID, message);
    }
  }
};
var notImplemented = (v2) => {
  throw new Error(`chelonia: action not implemented to handle: ${JSON.stringify(v2)}.`);
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/time-sync.mjs
var wallBase = Date.now();
var monotonicBase = performance.now();
var resyncTimeout;
var watchdog;
var syncServerTime = async function() {
  const startTime = performance.now();
  const time3 = await this.config.fetch(`${this.config.connectionURL}/time`, {
    signal: this.abortController.signal
  });
  const requestTimeElapsed = performance.now();
  if (requestTimeElapsed - startTime > 8e3) {
    throw new Error("Error fetching server time: request took too long");
  }
  if (!time3.ok) throw new Error("Error fetching server time");
  const serverTime = new Date(await time3.text()).valueOf();
  if (Number.isNaN(serverTime)) throw new Error("Unable to parse server time");
  const newMonotonicBase = performance.now();
  wallBase = serverTime + (requestTimeElapsed - startTime) / 2 + // Also take into account the time elapsed between `requestTimeElapsed`
  // and this line (which should be very little)
  (newMonotonicBase - requestTimeElapsed);
  monotonicBase = newMonotonicBase;
};
var time_sync_default = esm_default("sbp/selectors/register", {
  "chelonia/private/startClockSync": function() {
    if (resyncTimeout !== void 0) {
      throw new Error("chelonia/private/startClockSync has already been called");
    }
    const resync = (delay2 = 3e5) => {
      if (resyncTimeout !== null) return;
      const timeout = setTimeout(() => {
        syncServerTime.call(this).then(() => {
          if (resyncTimeout === timeout) resyncTimeout = null;
          resync();
        }).catch((e2) => {
          if (resyncTimeout === timeout) {
            resyncTimeout = null;
            console.error("Error re-syncing server time; will re-attempt in 5s", e2);
            setTimeout(() => resync(0), 5e3);
          } else {
            console.error("Error re-syncing server time; another attempt is in progress", e2);
          }
        });
      }, delay2);
      resyncTimeout = timeout;
    };
    let wallLast = Date.now();
    let monotonicLast = performance.now();
    watchdog = setInterval(() => {
      const wallNow = Date.now();
      const monotonicNow = performance.now();
      const difference2 = Math.abs(Math.abs(wallNow - wallLast) - Math.abs(monotonicNow - monotonicLast));
      if (difference2 > 10) {
        if (resyncTimeout != null) clearTimeout(resyncTimeout);
        resyncTimeout = null;
        resync(0);
      }
      wallLast = wallNow;
      monotonicLast = monotonicNow;
    }, 1e4);
    resyncTimeout = null;
    resync(0);
  },
  "chelonia/private/stopClockSync": () => {
    if (resyncTimeout !== void 0) {
      if (watchdog != null) clearInterval(watchdog);
      if (resyncTimeout != null) clearTimeout(resyncTimeout);
      watchdog = void 0;
      resyncTimeout = void 0;
    }
  },
  // Get an estimate of the server's current time based on the time elapsed as
  // measured locally (using a monotonic clock), which is used as an offset, and
  // a previously retrieved server time. The time value is returned as a UNIX
  // _millisecond_ timestamp (milliseconds since 1 Jan 1970 00:00:00 UTC)
  "chelonia/time": function() {
    const monotonicNow = performance.now();
    const wallNow = wallBase - monotonicBase + monotonicNow;
    return Math.round(wallNow);
  }
});

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/chelonia.mjs
var ACTION_REGEX = /^((([\w.]+)\/([^/]+))(?:\/(?:([^/]+)\/)?)?)\w*/;
var chelonia_default = esm_default("sbp/selectors/register", {
  // https://www.wordnik.com/words/chelonia
  // https://gitlab.okturtles.org/okturtles/group-income/-/wikis/E2E-Protocol/Framework.md#alt-names
  "chelonia/_init": function() {
    this.config = {
      // TODO: handle connecting to multiple servers for federation
      get connectionURL() {
        throw new Error("Invalid use of connectionURL before initialization");
      },
      // override!
      set connectionURL(value) {
        Object.defineProperty(this, "connectionURL", {
          value,
          writable: true
        });
      },
      stateSelector: "chelonia/private/state",
      contracts: {
        defaults: {
          modules: {},
          exposedGlobals: {},
          allowedDomains: [],
          allowedSelectors: [],
          preferSlim: false
        },
        overrides: {},
        manifests: {}
        // override! contract names => manifest hashes
      },
      whitelisted: (action) => !!this.whitelistedActions[action],
      reactiveSet: (obj, key, value) => {
        obj[key] = value;
        return value;
      },
      fetch: (...args) => fetch(...args),
      reactiveDel: (obj, key) => {
        delete obj[key];
      },
      // acceptAllMessages disables checking whether we are expecting a message
      // or not for processing
      acceptAllMessages: false,
      skipActionProcessing: false,
      skipDecryptionAttempts: false,
      skipSideEffects: false,
      // Strict processing will treat all processing errors as unrecoverable
      // This is useful, e.g., in the server, to prevent invalid messages from
      // being added to the database
      strictProcessing: false,
      // Strict ordering will throw on past events with ChelErrorAlreadyProcessed
      // Similarly, future events will not be reingested and will throw
      // with ChelErrorDBBadPreviousHEAD
      strictOrdering: false,
      connectionOptions: {
        maxRetries: Infinity,
        reconnectOnTimeout: true
        // can be enabled since we are not doing auth via web sockets
      },
      hooks: {
        preHandleEvent: null,
        postHandleEvent: null,
        processError: null,
        sideEffectError: null,
        handleEventError: null,
        syncContractError: null,
        pubsubError: null
        // (e:Error, socket: Socket)
      },
      unwrapMaybeEncryptedData
    };
    this._instance = /* @__PURE__ */ Object.create(null);
    this.abortController = new AbortController();
    this.state = {
      contracts: {},
      pending: []
      // prevents processing unexpected data from a malicious server
    };
    this.manifestToContract = {};
    this.whitelistedActions = {};
    this.currentSyncs = /* @__PURE__ */ Object.create(null);
    this.postSyncOperations = /* @__PURE__ */ Object.create(null);
    this.sideEffectStacks = /* @__PURE__ */ Object.create(null);
    this.sideEffectStack = (contractID) => {
      let stack = this.sideEffectStacks[contractID];
      if (!stack) {
        this.sideEffectStacks[contractID] = stack = [];
      }
      return stack;
    };
    this.setPostSyncOp = (contractID, key, op) => {
      this.postSyncOperations[contractID] = this.postSyncOperations[contractID] || /* @__PURE__ */ Object.create(null);
      this.postSyncOperations[contractID][key] = op;
    };
    const secretKeyGetter = (o2, p) => {
      if (has2(o2, p)) return o2[p];
      const rootState = esm_default(this.config.stateSelector);
      if (rootState?.secretKeys && has2(rootState.secretKeys, p)) {
        const key = deserializeKey(rootState.secretKeys[p]);
        o2[p] = key;
        return key;
      }
    };
    const secretKeyList = (o2) => {
      const rootState = esm_default(this.config.stateSelector);
      const stateKeys = Object.keys(rootState?.secretKeys || {});
      return Array.from(/* @__PURE__ */ new Set([
        ...Object.keys(o2),
        ...stateKeys
      ]));
    };
    this.transientSecretKeys = new Proxy(/* @__PURE__ */ Object.create(null), {
      get: secretKeyGetter,
      ownKeys: secretKeyList
    });
    this.ephemeralReferenceCount = /* @__PURE__ */ Object.create(null);
    this.subscriptionSet = /* @__PURE__ */ new Set();
    this.pending = [];
  },
  "chelonia/config": function() {
    return {
      ...cloneDeep2(this.config),
      fetch: this.config.fetch,
      reactiveSet: this.config.reactiveSet,
      reactiveDel: this.config.reactiveDel
    };
  },
  "chelonia/configure": async function(config2) {
    merge2(this.config, config2);
    Object.assign(this.config.hooks, config2.hooks || {});
    if (config2.contracts) {
      Object.assign(this.config.contracts.defaults, config2.contracts.defaults || {});
      const manifests = this.config.contracts.manifests;
      console.debug("[chelonia] preloading manifests:", Object.keys(manifests));
      for (const contractName in manifests) {
        await esm_default("chelonia/private/loadManifest", contractName, manifests[contractName]);
      }
    }
    if (has2(config2, "skipDecryptionAttempts")) {
      if (config2.skipDecryptionAttempts) {
        this.config.unwrapMaybeEncryptedData = (data) => {
          if (!isEncryptedData(data)) {
            return {
              encryptionKeyId: null,
              data
            };
          }
        };
      } else {
        this.config.unwrapMaybeEncryptedData = unwrapMaybeEncryptedData;
      }
    }
  },
  "chelonia/reset": async function(newState, postCleanupFn) {
    if (typeof newState === "function" && typeof postCleanupFn === "undefined") {
      postCleanupFn = newState;
      newState = void 0;
    }
    if (this.pubsub) {
      esm_default("chelonia/private/stopClockSync");
    }
    Object.keys(this.postSyncOperations).forEach((cID) => {
      esm_default("chelonia/private/enqueuePostSyncOps", cID);
    });
    await esm_default("chelonia/contract/waitPublish");
    await esm_default("chelonia/contract/wait");
    Object.keys(this.postSyncOperations).forEach((cID) => {
      esm_default("chelonia/private/enqueuePostSyncOps", cID);
    });
    await esm_default("chelonia/contract/waitPublish");
    await esm_default("chelonia/contract/wait");
    const result = await postCleanupFn?.();
    const rootState = esm_default(this.config.stateSelector);
    this._instance = /* @__PURE__ */ Object.create(null);
    this.abortController.abort();
    this.abortController = new AbortController();
    reactiveClearObject(rootState, this.config.reactiveDel);
    this.config.reactiveSet(rootState, "contracts", /* @__PURE__ */ Object.create(null));
    clearObject(this.ephemeralReferenceCount);
    this.pending.splice(0);
    clearObject(this.currentSyncs);
    clearObject(this.postSyncOperations);
    clearObject(this.sideEffectStacks);
    const removedContractIDs = Array.from(this.subscriptionSet);
    this.subscriptionSet.clear();
    esm_default("chelonia/clearTransientSecretKeys");
    esm_default("okTurtles.events/emit", CHELONIA_RESET);
    esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
      added: [],
      removed: removedContractIDs
    });
    if (this.pubsub) {
      esm_default("chelonia/private/startClockSync");
    }
    if (newState) {
      Object.entries(newState).forEach(([key, value]) => {
        this.config.reactiveSet(rootState, key, value);
      });
    }
    return result;
  },
  "chelonia/storeSecretKeys": function(wkeys) {
    const rootState = esm_default(this.config.stateSelector);
    if (!rootState.secretKeys) this.config.reactiveSet(rootState, "secretKeys", /* @__PURE__ */ Object.create(null));
    let keys = wkeys.valueOf();
    if (!keys) return;
    if (!Array.isArray(keys)) keys = [
      keys
    ];
    keys.forEach(({ key, transient }) => {
      if (!key) return;
      if (typeof key === "string") {
        key = deserializeKey(key);
      }
      const id = keyId(key);
      if (!has2(this.transientSecretKeys, id)) {
        this.transientSecretKeys[id] = key;
      }
      if (transient) return;
      if (!has2(rootState.secretKeys, id)) {
        this.config.reactiveSet(rootState.secretKeys, id, serializeKey(key, true));
      }
    });
  },
  "chelonia/clearTransientSecretKeys": function(ids) {
    if (Array.isArray(ids)) {
      ids.forEach((id) => {
        delete this.transientSecretKeys[id];
      });
    } else {
      Object.keys(this.transientSecretKeys).forEach((id) => {
        delete this.transientSecretKeys[id];
      });
    }
  },
  "chelonia/haveSecretKey": function(keyId2, persistent) {
    if (!persistent && has2(this.transientSecretKeys, keyId2)) return true;
    const rootState = esm_default(this.config.stateSelector);
    return !!rootState?.secretKeys && has2(rootState.secretKeys, keyId2);
  },
  "chelonia/contract/isResyncing": function(contractIDOrState) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    return !!contractIDOrState?._volatile?.dirty || !!contractIDOrState?._volatile?.resyncing;
  },
  "chelonia/contract/hasKeyShareBeenRespondedBy": function(contractIDOrState, requestedToContractID, reference) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const result = Object.values(contractIDOrState?._vm.authorizedKeys || {}).some((r) => {
      return r?.meta?.keyRequest?.responded && r.meta.keyRequest.contractID === requestedToContractID && (!reference || r.meta.keyRequest.reference === reference);
    });
    return result;
  },
  "chelonia/contract/waitingForKeyShareTo": function(contractIDOrState, requestingContractID, reference) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const result = contractIDOrState._volatile?.pendingKeyRequests?.filter((r) => {
      return r && (!requestingContractID || r.contractID === requestingContractID) && (!reference || r.reference === reference);
    })?.map(({ name }) => name);
    if (!result?.length) return null;
    return result;
  },
  "chelonia/contract/successfulKeySharesByContractID": function(contractIDOrState, requestingContractID) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const keyShares = Object.values(contractIDOrState._vm.keyshares || {});
    if (!keyShares?.length) return;
    const result = /* @__PURE__ */ Object.create(null);
    keyShares.forEach((kS) => {
      if (!kS.success) return;
      if (requestingContractID && kS.contractID !== requestingContractID) return;
      if (!result[kS.contractID]) result[kS.contractID] = [];
      result[kS.contractID].push({
        height: kS.height,
        hash: kS.hash
      });
    });
    Object.keys(result).forEach((cID) => {
      result[cID].sort((a, b) => {
        return b.height - a.height;
      });
    });
    return result;
  },
  "chelonia/contract/hasKeysToPerformOperation": function(contractIDOrState, operation) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const op = operation !== "*" ? [
      operation
    ] : operation;
    return !!findSuitableSecretKeyId(contractIDOrState, op, [
      "sig"
    ]);
  },
  // Did sourceContractIDOrState receive an OP_KEY_SHARE to perform the given
  // operation on contractIDOrState?
  "chelonia/contract/receivedKeysToPerformOperation": function(sourceContractIDOrState, contractIDOrState, operation) {
    const rootState = esm_default(this.config.stateSelector);
    if (typeof sourceContractIDOrState === "string") {
      sourceContractIDOrState = rootState[sourceContractIDOrState];
    }
    if (typeof contractIDOrState === "string") {
      contractIDOrState = rootState[contractIDOrState];
    }
    const op = operation !== "*" ? [
      operation
    ] : operation;
    const keyId2 = findSuitableSecretKeyId(contractIDOrState, op, [
      "sig"
    ]);
    return sourceContractIDOrState?._vm?.sharedKeyIds?.some((sK) => sK.id === keyId2);
  },
  "chelonia/contract/currentKeyIdByName": function(contractIDOrState, name, requireSecretKey) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const currentKeyId = findKeyIdByName(contractIDOrState, name);
    if (requireSecretKey && !esm_default("chelonia/haveSecretKey", currentKeyId)) {
      return;
    }
    return currentKeyId;
  },
  "chelonia/contract/foreignKeysByContractID": function(contractIDOrState, foreignContractID) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    return findForeignKeysByContractID(contractIDOrState, foreignContractID);
  },
  "chelonia/contract/historicalKeyIdsByName": function(contractIDOrState, name) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const currentKeyId = findKeyIdByName(contractIDOrState, name);
    const revokedKeyIds = findRevokedKeyIdsByName(contractIDOrState, name);
    return currentKeyId ? [
      currentKeyId,
      ...revokedKeyIds
    ] : revokedKeyIds;
  },
  "chelonia/contract/suitableSigningKey": function(contractIDOrState, permissions, purposes, ringLevel, allowedActions) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const keyId2 = findSuitableSecretKeyId(contractIDOrState, permissions, purposes, ringLevel, allowedActions);
    return keyId2;
  },
  "chelonia/contract/setPendingKeyRevocation": function(contractID, names) {
    const rootState = esm_default(this.config.stateSelector);
    const state = rootState[contractID];
    if (!state._volatile) this.config.reactiveSet(state, "_volatile", /* @__PURE__ */ Object.create(null));
    if (!state._volatile.pendingKeyRevocations) this.config.reactiveSet(state._volatile, "pendingKeyRevocations", /* @__PURE__ */ Object.create(null));
    for (const name of names) {
      const keyId2 = findKeyIdByName(state, name);
      if (keyId2) {
        this.config.reactiveSet(state._volatile.pendingKeyRevocations, keyId2, true);
      } else {
        console.warn("[setPendingKeyRevocation] Unable to find keyId for name", {
          contractID,
          name
        });
      }
    }
  },
  "chelonia/shelterAuthorizationHeader"(contractID) {
    return buildShelterAuthorizationHeader.call(this, contractID);
  },
  // The purpose of the 'chelonia/crypto/*' selectors is so that they can be called
  // from contracts without including the crypto code (i.e., importing crypto.js)
  // This function takes a function as a parameter that returns a string
  // It does not a string directly to prevent accidentally logging the value,
  // which is a secret
  "chelonia/crypto/keyId": (inKey) => {
    return keyId(inKey.valueOf());
  },
  // TODO: allow connecting to multiple servers at once
  "chelonia/connect": function(options3 = {}) {
    if (!this.config.connectionURL) throw new Error("config.connectionURL missing");
    if (!this.config.connectionOptions) throw new Error("config.connectionOptions missing");
    if (this.pubsub) {
      this.pubsub.destroy();
    }
    let pubsubURL = this.config.connectionURL;
    if (true) {
      pubsubURL += `?debugID=${randomHexString(6)}`;
    }
    if (this.pubsub) {
      esm_default("chelonia/private/stopClockSync");
    }
    esm_default("chelonia/private/startClockSync");
    this.pubsub = createClient(pubsubURL, {
      ...this.config.connectionOptions,
      handlers: {
        ...options3.handlers,
        // Every time we get a REQUEST_TYPE.SUB response, which happens for
        // 'new' subscriptions as well as every time the connection is reset
        "subscription-succeeded": function(event) {
          const { channelID } = event.detail;
          if (this.subscriptionSet.has(channelID)) {
            esm_default("chelonia/private/out/sync", channelID, {
              force: true
            }).catch((err) => {
              console.warn(`[chelonia] Syncing contract ${channelID} failed: ${err.message}`);
            });
          }
          options3.handlers?.["subscription-succeeded"]?.call(this, event);
        }
      },
      // Map message handlers to transparently handle encryption and signatures
      messageHandlers: {
        ...Object.fromEntries(Object.entries(options3.messageHandlers || {}).map(([k, v2]) => {
          switch (k) {
            case NOTIFICATION_TYPE.PUB:
              return [
                k,
                (msg) => {
                  if (!msg.channelID) {
                    console.info("[chelonia] Discarding pub event without channelID");
                    return;
                  }
                  if (!this.subscriptionSet.has(msg.channelID)) {
                    console.info(`[chelonia] Discarding pub event for ${msg.channelID} because it's not in the current subscriptionSet`);
                    return;
                  }
                  esm_default("chelonia/queueInvocation", msg.channelID, () => {
                    v2.call(this.pubsub, parseEncryptedOrUnencryptedMessage(this, {
                      contractID: msg.channelID,
                      serializedData: msg.data
                    }));
                  }).catch((e2) => {
                    console.error(`[chelonia] Error processing pub event for ${msg.channelID}`, e2);
                  });
                }
              ];
            case NOTIFICATION_TYPE.KV:
              return [
                k,
                (msg) => {
                  if (!msg.channelID || !msg.key) {
                    console.info("[chelonia] Discarding kv event without channelID or key");
                    return;
                  }
                  if (!this.subscriptionSet.has(msg.channelID)) {
                    console.info(`[chelonia] Discarding kv event for ${msg.channelID} because it's not in the current subscriptionSet`);
                    return;
                  }
                  esm_default("chelonia/queueInvocation", msg.channelID, () => {
                    v2.call(this.pubsub, [
                      msg.key,
                      parseEncryptedOrUnencryptedMessage(this, {
                        contractID: msg.channelID,
                        meta: msg.key,
                        serializedData: JSON.parse(Buffer8.from(msg.data).toString())
                      })
                    ]);
                  }).catch((e2) => {
                    console.error(`[chelonia] Error processing kv event for ${msg.channelID} and key ${msg.key}`, msg, e2);
                  });
                }
              ];
            case NOTIFICATION_TYPE.DELETION:
              return [
                k,
                (msg) => v2.call(this.pubsub, msg.data)
              ];
            default:
              return [
                k,
                v2
              ];
          }
        })),
        [NOTIFICATION_TYPE.ENTRY](msg) {
          const { contractID } = SPMessage.deserializeHEAD(msg.data);
          esm_default("chelonia/private/in/enqueueHandleEvent", contractID, msg.data);
        }
      }
    });
    if (!this.contractsModifiedListener) {
      this.contractsModifiedListener = () => esm_default("chelonia/pubsub/update");
      esm_default("okTurtles.events/on", CONTRACTS_MODIFIED, this.contractsModifiedListener);
    }
    return this.pubsub;
  },
  // This selector is defined primarily for ingesting web push notifications,
  // although it can be used as a general-purpose API to process events received
  // from other external sources that are not managed by Chelonia itself (i.e. sources
  // other than the Chelonia-managed websocket connection and RESTful API).
  "chelonia/handleEvent": async function(event) {
    const { contractID } = SPMessage.deserializeHEAD(event);
    return await esm_default("chelonia/private/in/enqueueHandleEvent", contractID, event);
  },
  "chelonia/defineContract": function(contract) {
    if (!ACTION_REGEX.exec(contract.name)) throw new Error(`bad contract name: ${contract.name}`);
    if (!contract.metadata) contract.metadata = {
      validate() {
      },
      create: () => ({})
    };
    if (!contract.getters) contract.getters = {};
    contract.state = (contractID) => esm_default(this.config.stateSelector)[contractID];
    contract.manifest = this.defContractManifest;
    contract.sbp = this.defContractSBP;
    this.defContractSelectors = [];
    this.defContract = contract;
    this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
      // expose getters for Vuex integration and other conveniences
      [`${contract.manifest}/${contract.name}/getters`]: () => contract.getters,
      // 2 ways to cause sideEffects to happen: by defining a sideEffect function in the
      // contract, or by calling /pushSideEffect w/async SBP call. Can also do both.
      [`${contract.manifest}/${contract.name}/pushSideEffect`]: (contractID, asyncSbpCall) => {
        const [sel] = asyncSbpCall;
        if (sel.startsWith(contract.name + "/")) {
          asyncSbpCall[0] = `${contract.manifest}/${sel}`;
        }
        this.sideEffectStack(contractID).push(asyncSbpCall);
      }
    }));
    for (const action in contract.actions) {
      contractNameFromAction(action);
      this.whitelistedActions[action] = true;
      this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
        [`${contract.manifest}/${action}/process`]: async (message, state) => {
          const { meta, data, contractID } = message;
          state = state || contract.state(contractID);
          const gProxy = gettersProxy(state, contract.getters);
          await contract.metadata.validate(meta, {
            state,
            ...gProxy,
            contractID
          });
          await contract.actions[action].validate(data, {
            state,
            ...gProxy,
            meta,
            message,
            contractID
          });
          this.sideEffectStacks[contractID] = [];
          await contract.actions[action].process(message, {
            state,
            ...gProxy
          });
        },
        // 'mutation' is an object that's similar to 'message', but not identical
        [`${contract.manifest}/${action}/sideEffect`]: async (mutation, state) => {
          if (contract.actions[action].sideEffect) {
            state = state || contract.state(mutation.contractID);
            if (!state) {
              console.warn(`[${contract.manifest}/${action}/sideEffect]: Skipping side-effect since there is no contract state for contract ${mutation.contractID}`);
              return;
            }
            const stateCopy = cloneDeep2(state);
            const gProxy = gettersProxy(stateCopy, contract.getters);
            await contract.actions[action].sideEffect(mutation, {
              state: stateCopy,
              ...gProxy
            });
          }
          const sideEffects = this.sideEffectStack(mutation.contractID);
          while (sideEffects.length > 0) {
            const sideEffect = sideEffects.shift();
            try {
              await contract.sbp(...sideEffect);
            } catch (e_) {
              const e2 = e_;
              console.error(`[chelonia] ERROR: '${e2.name}' ${e2.message}, for pushed sideEffect of ${mutation.description}:`, sideEffect);
              this.sideEffectStacks[mutation.contractID] = [];
              throw e2;
            }
          }
        }
      }));
    }
    for (const method in contract.methods) {
      this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
        [`${contract.manifest}/${method}`]: contract.methods[method]
      }));
    }
    esm_default("okTurtles.events/emit", CONTRACT_REGISTERED, contract);
  },
  "chelonia/queueInvocation": (contractID, sbpInvocation) => {
    return esm_default("chelonia/private/queueEvent", contractID, [
      "chelonia/private/noop"
    ]).then(() => esm_default("chelonia/private/queueEvent", "public:" + contractID, sbpInvocation));
  },
  "chelonia/begin": async (...invocations) => {
    for (const invocation of invocations) {
      await esm_default(...invocation);
    }
  },
  // call this manually to resubscribe/unsubscribe from contracts as needed
  // if you are using a custom stateSelector and reload the state (e.g. upon login)
  "chelonia/pubsub/update": function() {
    const client = this.pubsub;
    const subscribedIDs = [
      ...client.subscriptionSet
    ];
    const currentIDs = Array.from(this.subscriptionSet);
    const leaveSubscribed = intersection2(subscribedIDs, currentIDs);
    const toUnsubscribe = difference(subscribedIDs, leaveSubscribed);
    const toSubscribe = difference(currentIDs, leaveSubscribed);
    try {
      for (const contractID of toUnsubscribe) {
        client.unsub(contractID);
      }
      for (const contractID of toSubscribe) {
        client.sub(contractID);
      }
    } catch (e2) {
      console.error(`[chelonia] pubsub/update: error ${e2.name}: ${e2.message}`, {
        toUnsubscribe,
        toSubscribe
      }, e2);
      this.config.hooks.pubsubError?.(e2, client);
    }
  },
  // resolves when all pending actions for these contractID(s) finish
  "chelonia/contract/wait": function(contractIDs) {
    const listOfIds = contractIDs ? typeof contractIDs === "string" ? [
      contractIDs
    ] : contractIDs : Object.keys(esm_default(this.config.stateSelector).contracts);
    return Promise.all(listOfIds.flatMap((cID) => {
      return esm_default("chelonia/queueInvocation", cID, [
        "chelonia/private/noop"
      ]);
    }));
  },
  // resolves when all pending *writes* for these contractID(s) finish
  "chelonia/contract/waitPublish": function(contractIDs) {
    const listOfIds = contractIDs ? typeof contractIDs === "string" ? [
      contractIDs
    ] : contractIDs : Object.keys(esm_default(this.config.stateSelector).contracts);
    return Promise.all(listOfIds.flatMap((cID) => {
      return esm_default("chelonia/private/queueEvent", `publish:${cID}`, [
        "chelonia/private/noop"
      ]);
    }));
  },
  // 'chelonia/contract' - selectors related to injecting remote data and monitoring contracts
  // TODO: add an optional parameter to "retain" the contract (see #828)
  // eslint-disable-next-line require-await
  "chelonia/contract/sync": async function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [
      contractIDs
    ] : contractIDs;
    listOfIds.forEach((id) => {
      if (checkCanBeGarbageCollected.call(this, id)) {
        if (process.env.CI) {
          Promise.reject(new Error("[chelonia] Missing reference count for contract " + id));
        }
        console.error("[chelonia] Missing reference count for contract " + id);
        throw new Error("Missing reference count for contract");
      }
    });
    return esm_default("chelonia/private/out/sync", listOfIds, {
      ...params,
      force: true
    });
  },
  "chelonia/contract/isSyncing": function(contractID, { firstSync = false } = {}) {
    const isSyncing = !!this.currentSyncs[contractID];
    return firstSync ? isSyncing && this.currentSyncs[contractID].firstSync : isSyncing;
  },
  "chelonia/contract/currentSyncs": function() {
    return Object.keys(this.currentSyncs);
  },
  // Because `/remove` is done asynchronously and a contract might be removed
  // much later than when the call to remove was made, an optional callback
  // can be passed to verify whether to proceed with removal. This is used as
  // part of the `/release` mechanism to prevent removing contracts that have
  // acquired new references since the call to `/remove`.
  "chelonia/contract/remove": function(contractIDs, { confirmRemovalCallback, permanent } = {}) {
    const rootState = esm_default(this.config.stateSelector);
    const listOfIds = typeof contractIDs === "string" ? [
      contractIDs
    ] : contractIDs;
    return Promise.all(listOfIds.map((contractID) => {
      if (!rootState?.contracts?.[contractID]) {
        return void 0;
      }
      return esm_default("chelonia/private/queueEvent", contractID, () => {
        if (confirmRemovalCallback && !confirmRemovalCallback(contractID)) {
          return;
        }
        const rootState2 = esm_default(this.config.stateSelector);
        const fkContractIDs = Array.from(new Set(Object.values(rootState2[contractID]?._vm?.authorizedKeys ?? {}).filter((k) => {
          return !!k.foreignKey;
        }).map((k) => {
          try {
            const fkUrl = new URL(k.foreignKey);
            return fkUrl.pathname;
          } catch {
            return void 0;
          }
        }).filter(Boolean)));
        esm_default("chelonia/private/removeImmediately", contractID, {
          permanent
        });
        if (fkContractIDs.length) {
          esm_default("chelonia/contract/release", fkContractIDs, {
            try: true
          }).catch((e2) => {
            console.error("[chelonia] Error attempting to release foreign key contracts", e2);
          });
        }
      });
    }));
  },
  "chelonia/contract/retain": async function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [
      contractIDs
    ] : contractIDs;
    const rootState = esm_default(this.config.stateSelector);
    if (listOfIds.length === 0) return Promise.resolve();
    const checkIfDeleted = (id) => {
      if (rootState.contracts[id] === null) {
        console.error("[chelonia/contract/retain] Called /retain on permanently deleted contract.", id);
        throw new ChelErrorResourceGone("Unable to retain permanently deleted contract " + id);
      }
    };
    if (!params?.ephemeral) {
      listOfIds.forEach((id) => {
        checkIfDeleted(id);
        if (!has2(rootState.contracts, id)) {
          this.config.reactiveSet(rootState.contracts, id, /* @__PURE__ */ Object.create(null));
        }
        this.config.reactiveSet(rootState.contracts[id], "references", (rootState.contracts[id].references ?? 0) + 1);
      });
    } else {
      listOfIds.forEach((id) => {
        checkIfDeleted(id);
        if (!has2(this.ephemeralReferenceCount, id)) {
          this.ephemeralReferenceCount[id] = 1;
        } else {
          this.ephemeralReferenceCount[id] = this.ephemeralReferenceCount[id] + 1;
        }
      });
    }
    return await esm_default("chelonia/private/out/sync", listOfIds);
  },
  // the `try` parameter does not affect (ephemeral or persistent) reference
  // counts, but rather removes a contract if the reference count is zero
  // and the contract isn't being monitored for foreign keys. This parameter
  // is meant mostly for internal chelonia use, so that removing or releasing
  // a contract can also remove other contracts that this first contract
  // was monitoring.
  "chelonia/contract/release": async function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [
      contractIDs
    ] : contractIDs;
    const rootState = esm_default(this.config.stateSelector);
    if (!params?.try) {
      if (!params?.ephemeral) {
        listOfIds.forEach((id) => {
          if (rootState.contracts[id] === null) {
            console.warn("[chelonia/contract/release] Called /release on permanently deleted contract. This has no effect.", id);
            return;
          }
          if (has2(rootState.contracts, id) && has2(rootState.contracts[id], "references")) {
            const current = rootState.contracts[id].references;
            if (current === 0) {
              console.error("[chelonia/contract/release] Invalid negative reference count for", id);
              if (process.env.CI) {
                Promise.reject(new Error("Invalid negative reference count: " + id));
              }
              throw new Error("Invalid negative reference count");
            }
            if (current <= 1) {
              this.config.reactiveDel(rootState.contracts[id], "references");
            } else {
              this.config.reactiveSet(rootState.contracts[id], "references", current - 1);
            }
          } else {
            console.error("[chelonia/contract/release] Invalid negative reference count for", id);
            if (process.env.CI) {
              Promise.reject(new Error("Invalid negative reference count: " + id));
            }
            throw new Error("Invalid negative reference count");
          }
        });
      } else {
        listOfIds.forEach((id) => {
          if (rootState.contracts[id] === null) {
            console.warn("[chelonia/contract/release] Called /release on permanently deleted contract. This has no effect.", id);
            return;
          }
          if (has2(this.ephemeralReferenceCount, id)) {
            const current = this.ephemeralReferenceCount[id] ?? 0;
            if (current <= 1) {
              delete this.ephemeralReferenceCount[id];
            } else {
              this.ephemeralReferenceCount[id] = current - 1;
            }
          } else {
            console.error("[chelonia/contract/release] Invalid negative ephemeral reference count for", id);
            if (process.env.CI) {
              Promise.reject(new Error("Invalid negative ephemeral reference count: " + id));
            }
            throw new Error("Invalid negative ephemeral reference count");
          }
        });
      }
    }
    const boundCheckCanBeGarbageCollected = checkCanBeGarbageCollected.bind(this);
    const idsToRemove = listOfIds.filter(boundCheckCanBeGarbageCollected);
    return idsToRemove.length ? await esm_default("chelonia/contract/remove", idsToRemove, {
      confirmRemovalCallback: boundCheckCanBeGarbageCollected
    }) : void 0;
  },
  "chelonia/contract/disconnect": async function(contractID, contractIDToDisconnect) {
    const state = esm_default(this.config.stateSelector);
    const contractState = state[contractID];
    const keyIds = Object.values(contractState._vm.authorizedKeys).filter((k) => {
      return k._notAfterHeight == null && k.meta?.keyRequest?.contractID === contractIDToDisconnect;
    }).map((k) => k.id);
    if (!keyIds.length) return;
    return await esm_default("chelonia/out/keyDel", {
      contractID,
      contractName: contractState._vm.type,
      data: keyIds,
      signingKeyId: findSuitableSecretKeyId(contractState, [
        SPMessage.OP_KEY_DEL
      ], [
        "sig"
      ])
    });
  },
  "chelonia/in/processMessage": function(messageOrRawMessage, state) {
    const stateCopy = cloneDeep2(state);
    const message = typeof messageOrRawMessage === "string" ? SPMessage.deserialize(messageOrRawMessage, this.transientSecretKeys, stateCopy, this.config.unwrapMaybeEncryptedData) : messageOrRawMessage;
    return esm_default("chelonia/private/in/processMessage", message, stateCopy).then(() => stateCopy).catch((e2) => {
      console.warn(`chelonia/in/processMessage: reverting mutation ${message.description()}: ${message.serialize()}`, e2);
      return state;
    });
  },
  "chelonia/out/fetchResource": async function(cid, { code: code3 } = {}) {
    const parsedCID = parseCID(cid);
    if (code3 != null) {
      if (parsedCID.code !== code3) {
        throw new Error(`Invalid CID content type. Expected ${code3}, got ${parsedCID.code}`);
      }
    }
    const local = await esm_default("chelonia.db/get", cid);
    if (local != null) return local;
    const url2 = `${this.config.connectionURL}/file/${cid}`;
    const data = await this.config.fetch(url2, {
      signal: this.abortController.signal
    }).then(handleFetchResult("text"));
    const ourHash = createCID(data, parsedCID.code);
    if (ourHash !== cid) {
      throw new Error(`expected hash ${cid}. Got: ${ourHash}`);
    }
    await esm_default("chelonia.db/set", cid, data);
    return data;
  },
  "chelonia/out/latestHEADInfo": function(contractID) {
    return this.config.fetch(`${this.config.connectionURL}/latestHEADinfo/${contractID}`, {
      cache: "no-store",
      signal: this.abortController.signal
    }).then(handleFetchResult("json"));
  },
  "chelonia/out/eventsAfter": eventsAfter,
  "chelonia/out/eventsBefore": function(contractID, { beforeHeight, limit, stream }) {
    if (limit <= 0) {
      console.error('[chelonia] invalid params error: "limit" needs to be positive integer');
    }
    const offset = Math.max(0, beforeHeight - limit + 1);
    const eventsAfterLimit = Math.min(beforeHeight + 1, limit);
    return esm_default("chelonia/out/eventsAfter", contractID, {
      sinceHeight: offset,
      limit: eventsAfterLimit,
      stream
    });
  },
  "chelonia/out/eventsBetween": function(contractID, { startHash, endHeight, offset = 0, limit = 0, stream = true }) {
    if (offset < 0) {
      console.error('[chelonia] invalid params error: "offset" needs to be positive integer or zero');
      return;
    }
    let reader;
    const s = new ReadableStream({
      start: async (controller) => {
        const first = await this.config.fetch(`${this.config.connectionURL}/file/${startHash}`, {
          signal: this.abortController.signal
        }).then(handleFetchResult("text"));
        const deserializedHEAD = SPMessage.deserializeHEAD(first);
        if (deserializedHEAD.contractID !== contractID) {
          controller.error(new Error("chelonia/out/eventsBetween: Mismatched contract ID"));
          return;
        }
        const startOffset = Math.max(0, deserializedHEAD.head.height - offset);
        const ourLimit = limit ? Math.min(endHeight - startOffset + 1, limit) : endHeight - startOffset + 1;
        if (ourLimit < 1) {
          controller.close();
          return;
        }
        reader = esm_default("chelonia/out/eventsAfter", contractID, {
          sinceHeight: startOffset,
          limit: ourLimit
        }).getReader();
      },
      async pull(controller) {
        const { done, value } = await reader.read();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      }
    });
    if (stream) return s;
    return collectEventStream(s);
  },
  "chelonia/rootState": function() {
    return esm_default(this.config.stateSelector);
  },
  "chelonia/latestContractState": async function(contractID, options3 = {
    forceSync: false
  }) {
    const rootState = esm_default(this.config.stateSelector);
    if (rootState.contracts[contractID] === null) {
      throw new ChelErrorResourceGone("Permanently deleted contract " + contractID);
    }
    if (!options3.forceSync && rootState[contractID] && Object.keys(rootState[contractID]).some((x3) => x3 !== "_volatile")) {
      return cloneDeep2(rootState[contractID]);
    }
    let state = /* @__PURE__ */ Object.create(null);
    let contractName = rootState.contracts[contractID]?.type;
    const eventsStream = esm_default("chelonia/out/eventsAfter", contractID, {
      sinceHeight: 0,
      sinceHash: contractID
    });
    const eventsStreamReader = eventsStream.getReader();
    if (rootState[contractID]) state._volatile = rootState[contractID]._volatile;
    for (; ; ) {
      const { value: event, done } = await eventsStreamReader.read();
      if (done) return state;
      const stateCopy = cloneDeep2(state);
      try {
        await esm_default("chelonia/private/in/processMessage", SPMessage.deserialize(event, this.transientSecretKeys, state, this.config.unwrapMaybeEncryptedData), state, void 0, contractName);
        if (!contractName && state._vm) {
          contractName = state._vm.type;
        }
      } catch (e2) {
        console.warn(`[chelonia] latestContractState: '${e2.name}': ${e2.message} processing:`, event, e2.stack);
        if (e2 instanceof ChelErrorUnrecoverable) throw e2;
        state = stateCopy;
      }
    }
  },
  "chelonia/contract/state": function(contractID, height) {
    const state = esm_default(this.config.stateSelector)[contractID];
    const stateCopy = state && cloneDeep2(state);
    if (stateCopy?._vm && height != null) {
      Object.keys(stateCopy._vm.authorizedKeys).forEach((keyId2) => {
        if (stateCopy._vm.authorizedKeys[keyId2]._notBeforeHeight > height) {
          delete stateCopy._vm.authorizedKeys[keyId2];
        }
      });
    }
    return stateCopy;
  },
  "chelonia/contract/fullState": function(contractID) {
    const rootState = esm_default(this.config.stateSelector);
    if (Array.isArray(contractID)) {
      return Object.fromEntries(contractID.map((contractID2) => {
        return [
          contractID2,
          {
            contractState: rootState[contractID2],
            cheloniaState: rootState.contracts[contractID2]
          }
        ];
      }));
    }
    return {
      contractState: rootState[contractID],
      cheloniaState: rootState.contracts[contractID]
    };
  },
  // 'chelonia/out' - selectors that send data out to the server
  "chelonia/out/registerContract": async function(params) {
    const { contractName, keys, hooks, publishOptions, signingKeyId, actionSigningKeyId, actionEncryptionKeyId } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contractInfo = this.manifestToContract[manifestHash];
    if (!contractInfo) throw new Error(`contract not defined: ${contractName}`);
    const signingKey = this.transientSecretKeys[signingKeyId];
    if (!signingKey) throw new Error(`Signing key ${signingKeyId} is not defined`);
    const payload = {
      type: contractName,
      keys
    };
    const contractMsg = SPMessage.createV1_0({
      contractID: null,
      height: 0,
      op: [
        SPMessage.OP_CONTRACT,
        signedOutgoingDataWithRawKey(signingKey, payload)
      ],
      manifest: manifestHash
    });
    const contractID = contractMsg.hash();
    await esm_default("chelonia/private/out/publishEvent", contractMsg, params.namespaceRegistration ? {
      ...publishOptions,
      headers: {
        ...publishOptions?.headers,
        "shelter-namespace-registration": params.namespaceRegistration
      }
    } : publishOptions, hooks && {
      prepublish: hooks.prepublishContract,
      postpublish: hooks.postpublishContract
    });
    await esm_default("chelonia/private/out/sync", contractID);
    const msg = await esm_default(actionEncryptionKeyId ? "chelonia/out/actionEncrypted" : "chelonia/out/actionUnencrypted", {
      action: contractName,
      contractID,
      data: params.data,
      signingKeyId: actionSigningKeyId ?? signingKeyId,
      encryptionKeyId: actionEncryptionKeyId,
      hooks,
      publishOptions
    });
    return msg;
  },
  "chelonia/out/ownResources": async function(contractID) {
    if (!contractID) {
      throw new TypeError("A contract ID must be provided");
    }
    const response = await this.config.fetch(`${this.config.connectionURL}/ownResources`, {
      method: "GET",
      signal: this.abortController.signal,
      headers: new Headers([
        [
          "authorization",
          buildShelterAuthorizationHeader.call(this, contractID)
        ]
      ])
    });
    if (!response.ok) {
      console.error("Unable to fetch own resources", contractID, response.status);
      throw new Error(`Unable to fetch own resources for ${contractID}: ${response.status}`);
    }
    return response.json();
  },
  "chelonia/out/deleteContract": async function(contractID, credentials = {}) {
    if (!contractID) {
      throw new TypeError("A contract ID must be provided");
    }
    if (!Array.isArray(contractID)) contractID = [
      contractID
    ];
    return await Promise.allSettled(contractID.map(async (cid) => {
      const hasCredential = has2(credentials, cid);
      const hasToken = has2(credentials[cid], "token") && credentials[cid].token;
      const hasBillableContractID = has2(credentials[cid], "billableContractID") && credentials[cid].billableContractID;
      if (!hasCredential || hasToken === hasBillableContractID) {
        throw new TypeError(`Either a token or a billable contract ID must be provided for ${cid}`);
      }
      const response = await this.config.fetch(`${this.config.connectionURL}/deleteContract/${cid}`, {
        method: "POST",
        signal: this.abortController.signal,
        headers: new Headers([
          [
            "authorization",
            hasToken ? `bearer ${credentials[cid].token.valueOf()}` : buildShelterAuthorizationHeader.call(this, credentials[cid].billableContractID)
          ]
        ])
      });
      if (!response.ok) {
        if (response.status === 404 || response.status === 410) {
          console.warn("Contract appears to have been deleted already", cid, response.status);
          return;
        }
        console.error("Unable to delete contract", cid, response.status);
        throw new Error(`Unable to delete contract ${cid}: ${response.status}`);
      }
    }));
  },
  // all of these functions will do both the creation of the SPMessage
  // and the sending of it via 'chelonia/private/out/publishEvent'
  "chelonia/out/actionEncrypted": function(params) {
    return outEncryptedOrUnencryptedAction.call(this, SPMessage.OP_ACTION_ENCRYPTED, params);
  },
  "chelonia/out/actionUnencrypted": function(params) {
    return outEncryptedOrUnencryptedAction.call(this, SPMessage.OP_ACTION_UNENCRYPTED, params);
  },
  "chelonia/out/keyShare": async function(params) {
    const { atomic, originatingContractName, originatingContractID, contractName, contractID, data, hooks, publishOptions } = params;
    const originatingManifestHash = this.config.contracts.manifests[originatingContractName];
    const destinationManifestHash = this.config.contracts.manifests[contractName];
    const originatingContract = originatingContractID ? this.manifestToContract[originatingManifestHash]?.contract : void 0;
    const destinationContract = this.manifestToContract[destinationManifestHash]?.contract;
    if (originatingContractID && !originatingContract || !destinationContract) {
      throw new Error("Contract name not found");
    }
    const payload = data;
    if (!params.signingKeyId && !params.signingKey) {
      throw new TypeError("Either signingKeyId or signingKey must be specified");
    }
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_SHARE,
        params.signingKeyId ? signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys) : signedOutgoingDataWithRawKey(params.signingKey, payload)
      ],
      manifest: destinationManifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyAdd": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const state = contract.state(contractID);
    const payload = params.skipExistingKeyCheck ? data : data.filter((wk) => {
      const k = isEncryptedData(wk) ? wk.valueOf() : wk;
      if (has2(state._vm.authorizedKeys, k.id)) {
        if (state._vm.authorizedKeys[k.id]._notAfterHeight == null) {
          return false;
        }
      }
      return true;
    });
    if (payload.length === 0) return;
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_ADD,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyDel": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const state = contract.state(contractID);
    const payload = data.map((keyId2) => {
      if (isEncryptedData(keyId2)) return keyId2;
      if (!has2(state._vm.authorizedKeys, keyId2) || state._vm.authorizedKeys[keyId2]._notAfterHeight != null) return void 0;
      if (state._vm.authorizedKeys[keyId2]._private) {
        return encryptedOutgoingData(contractID, state._vm.authorizedKeys[keyId2]._private, keyId2);
      } else {
        return keyId2;
      }
    }).filter(Boolean);
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_DEL,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyUpdate": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const state = contract.state(contractID);
    const payload = data.map((key) => {
      if (isEncryptedData(key)) return key;
      const { oldKeyId } = key;
      if (state._vm.authorizedKeys[oldKeyId]._private) {
        return encryptedOutgoingData(contractID, state._vm.authorizedKeys[oldKeyId]._private, key);
      } else {
        return key;
      }
    });
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_UPDATE,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyRequest": async function(params) {
    const { originatingContractID, originatingContractName, contractID, contractName, hooks, publishOptions, innerSigningKeyId, encryptionKeyId, innerEncryptionKeyId, encryptKeyRequestMetadata, reference } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const originatingManifestHash = this.config.contracts.manifests[originatingContractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    const originatingContract = this.manifestToContract[originatingManifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const rootState = esm_default(this.config.stateSelector);
    try {
      await esm_default("chelonia/contract/retain", contractID, {
        ephemeral: true
      });
      const state = contract.state(contractID);
      const originatingState = originatingContract.state(originatingContractID);
      const havePendingKeyRequest = Object.values(originatingState._vm.authorizedKeys).findIndex((k) => {
        return k._notAfterHeight == null && k.meta?.keyRequest?.contractID === contractID && state?._volatile?.pendingKeyRequests?.some((pkr) => pkr.name === k.name);
      }) !== -1;
      if (havePendingKeyRequest) {
        return;
      }
      const keyRequestReplyKey = keygen(EDWARDS25519SHA512BATCH);
      const keyRequestReplyKeyId = keyId(keyRequestReplyKey);
      const keyRequestReplyKeyP = serializeKey(keyRequestReplyKey, false);
      const keyRequestReplyKeyS = serializeKey(keyRequestReplyKey, true);
      const signingKeyId = findSuitableSecretKeyId(originatingState, [
        SPMessage.OP_KEY_ADD
      ], [
        "sig"
      ]);
      if (!signingKeyId) {
        throw new ChelErrorUnexpected(`Unable to send key request. Originating contract is missing a key with OP_KEY_ADD permission. contractID=${contractID} originatingContractID=${originatingContractID}`);
      }
      const keyAddOp = () => esm_default("chelonia/out/keyAdd", {
        contractID: originatingContractID,
        contractName: originatingContractName,
        data: [
          {
            id: keyRequestReplyKeyId,
            name: "#krrk-" + keyRequestReplyKeyId,
            purpose: [
              "sig"
            ],
            ringLevel: Number.MAX_SAFE_INTEGER,
            permissions: params.permissions === "*" ? "*" : Array.isArray(params.permissions) ? [
              ...params.permissions,
              SPMessage.OP_KEY_SHARE
            ] : [
              SPMessage.OP_KEY_SHARE
            ],
            allowedActions: params.allowedActions,
            meta: {
              private: {
                content: encryptedOutgoingData(originatingContractID, encryptionKeyId, keyRequestReplyKeyS),
                shareable: false
              },
              keyRequest: {
                ...reference && {
                  reference: encryptKeyRequestMetadata ? encryptedOutgoingData(originatingContractID, encryptionKeyId, reference) : reference
                },
                contractID: encryptKeyRequestMetadata ? encryptedOutgoingData(originatingContractID, encryptionKeyId, contractID) : contractID
              }
            },
            data: keyRequestReplyKeyP
          }
        ],
        signingKeyId
      }).catch((e2) => {
        console.error(`[chelonia] Error sending OP_KEY_ADD for ${originatingContractID} during key request to ${contractID}`, e2);
        throw e2;
      });
      const payload = {
        contractID: originatingContractID,
        height: rootState.contracts[originatingContractID].height,
        replyWith: signedOutgoingData(originatingContractID, innerSigningKeyId, {
          encryptionKeyId,
          responseKey: encryptedOutgoingData(contractID, innerEncryptionKeyId, keyRequestReplyKeyS)
        }, this.transientSecretKeys),
        request: "*"
      };
      let msg = SPMessage.createV1_0({
        contractID,
        op: [
          SPMessage.OP_KEY_REQUEST,
          signedOutgoingData(contractID, params.signingKeyId, encryptKeyRequestMetadata ? encryptedOutgoingData(contractID, innerEncryptionKeyId, payload) : payload, this.transientSecretKeys)
        ],
        manifest: manifestHash
      });
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, {
        ...hooks,
        // We ensure that both messages are placed into the publish queue
        prepublish: (...args) => {
          return keyAddOp().then(() => hooks?.prepublish?.(...args));
        }
      });
      return msg;
    } finally {
      await esm_default("chelonia/contract/release", contractID, {
        ephemeral: true
      });
    }
  },
  "chelonia/out/keyRequestResponse": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const payload = data;
    let message = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_REQUEST_SEEN,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      message = await esm_default("chelonia/private/out/publishEvent", message, publishOptions, hooks);
    }
    return message;
  },
  "chelonia/out/atomic": async function(params) {
    const { contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const payload = (await Promise.all(data.map(([selector, opParams]) => {
      if (![
        "chelonia/out/actionEncrypted",
        "chelonia/out/actionUnencrypted",
        "chelonia/out/keyAdd",
        "chelonia/out/keyDel",
        "chelonia/out/keyUpdate",
        "chelonia/out/keyRequestResponse",
        "chelonia/out/keyShare"
      ].includes(selector)) {
        throw new Error("Selector not allowed in OP_ATOMIC: " + selector);
      }
      return esm_default(selector, {
        ...opParams,
        ...params,
        data: opParams.data,
        atomic: true
      });
    }))).flat().filter(Boolean).map((msg2) => {
      return [
        msg2.opType(),
        msg2.opValue()
      ];
    });
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_ATOMIC,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    return msg;
  },
  "chelonia/out/protocolUpgrade": async function() {
  },
  "chelonia/out/propSet": async function() {
  },
  "chelonia/out/propDel": async function() {
  },
  "chelonia/out/encryptedOrUnencryptedPubMessage": function({ contractID, innerSigningKeyId, encryptionKeyId, signingKeyId, data }) {
    const serializedData = outputEncryptedOrUnencryptedMessage.call(this, {
      contractID,
      innerSigningKeyId,
      encryptionKeyId,
      signingKeyId,
      data
    });
    this.pubsub.pub(contractID, serializedData);
  },
  // Note: This is a bare-bones function designed for precise control. In many
  // situations, the `chelonia/kv/queuedSet` selector (in chelonia-utils.js)
  // will be simpler and more appropriate to use.
  // In most situations, you want to use some queuing strategy (which this
  // selector doesn't provide) alongside writing to the KV store. Therefore, as
  // a general rule, you shouldn't be calling this selector directly unless
  // you're building a utility library or if you have very specific needs. In
  // this case, see if `chelonia/kv/queuedSet` covers your needs.
  // `data` is allowed to be falsy, in which case a fetch will occur first and
  // the `onconflict` handler will be called.
  "chelonia/kv/set": async function(contractID, key, data, { ifMatch, innerSigningKeyId, encryptionKeyId, signingKeyId, maxAttempts, onconflict }) {
    maxAttempts = maxAttempts ?? 3;
    const url2 = `${this.config.connectionURL}/kv/${encodeURIComponent(contractID)}/${encodeURIComponent(key)}`;
    const hasOnconflict = typeof onconflict === "function";
    let response;
    const resolveData = async () => {
      let currentValue;
      if (response.ok || response.status === 409 || response.status === 412) {
        const serializedDataText = await response.text();
        currentValue = serializedDataText ? parseEncryptedOrUnencryptedMessage(this, {
          contractID,
          serializedData: JSON.parse(serializedDataText),
          meta: key
        }) : void 0;
      } else if (response.status !== 404 && response.status !== 410) {
        throw new ChelErrorUnexpectedHttpResponseCode("[kv/set] Invalid response code: " + response.status);
      }
      const result = await onconflict({
        contractID,
        key,
        failedData: data,
        status: response.status,
        // If no x-cid or etag header was returned, `ifMatch` would likely be
        // returned as undefined, which will then use the `''` fallback value
        // when writing. This allows 404 / 410 responses to work even if no
        // etag is explicitly given
        etag: response.headers.get("x-cid") || response.headers.get("etag"),
        get currentData() {
          return currentValue?.data;
        },
        currentValue
      });
      if (!result) return false;
      data = result[0];
      ifMatch = result[1];
      return true;
    };
    for (; ; ) {
      if (data !== void 0) {
        const serializedData = outputEncryptedOrUnencryptedMessage.call(this, {
          contractID,
          innerSigningKeyId,
          encryptionKeyId,
          signingKeyId,
          data,
          meta: key
        });
        response = await this.config.fetch(url2, {
          headers: new Headers([
            [
              "authorization",
              buildShelterAuthorizationHeader.call(this, contractID)
            ],
            [
              "if-match",
              ifMatch || '""'
            ]
          ]),
          method: "POST",
          body: JSON.stringify(serializedData),
          signal: this.abortController.signal
        });
      } else {
        if (!hasOnconflict) {
          throw TypeError("onconflict required with empty data");
        }
        response = await this.config.fetch(url2, {
          headers: new Headers([
            [
              "authorization",
              buildShelterAuthorizationHeader.call(this, contractID)
            ]
          ]),
          signal: this.abortController.signal
        });
        if (await resolveData()) {
          continue;
        } else {
          break;
        }
      }
      if (!response.ok) {
        if (response.status === 409 || response.status === 412) {
          if (--maxAttempts <= 0) {
            throw new Error("kv/set conflict setting KV value");
          }
          await delay(randomIntFromRange(0, 1500));
          if (hasOnconflict) {
            if (await resolveData()) {
              continue;
            } else {
              break;
            }
          } else {
            throw new Error(`kv/set failed with status ${response.status} and no onconflict handler was provided`);
          }
        }
        throw new ChelErrorUnexpectedHttpResponseCode("kv/set invalid response status: " + response.status);
      }
      break;
    }
  },
  "chelonia/kv/get": async function(contractID, key) {
    const response = await this.config.fetch(`${this.config.connectionURL}/kv/${encodeURIComponent(contractID)}/${encodeURIComponent(key)}`, {
      headers: new Headers([
        [
          "authorization",
          buildShelterAuthorizationHeader.call(this, contractID)
        ]
      ]),
      signal: this.abortController.signal
    });
    if (response.status === 404) {
      return null;
    }
    if (!response.ok) {
      throw new Error("Invalid response status: " + response.status);
    }
    const data = await response.json();
    return parseEncryptedOrUnencryptedMessage(this, {
      contractID,
      serializedData: data,
      meta: key
    });
  },
  // To set filters for a contract, call with `filter` set to an array of KV
  // keys to receive updates for over the WebSocket. An empty array means that
  // no KV updates will be sent.
  // Calling with a single argument (the contract ID) will remove filters,
  // meaning that KV updates will be sent for _any_ KV key.
  // The last call takes precedence, so, for example, calling with filter
  // set to `['foo', 'bar']` and then with `['baz']` means that KV updates will
  // be received for `baz` only, not for `foo`, `bar` or any other keys.
  "chelonia/kv/setFilter": function(contractID, filter) {
    this.pubsub.setKvFilter(contractID, filter);
  },
  "chelonia/parseEncryptedOrUnencryptedDetachedMessage": function({ contractID, serializedData, meta }) {
    return parseEncryptedOrUnencryptedMessage(this, {
      contractID,
      serializedData,
      meta
    });
  }
});
function contractNameFromAction(action) {
  const regexResult = ACTION_REGEX.exec(action);
  const contractName = regexResult?.[2];
  if (!contractName) throw new Error(`Poorly named action '${action}': missing contract name.`);
  return contractName;
}
function outputEncryptedOrUnencryptedMessage({ contractID, innerSigningKeyId, encryptionKeyId, signingKeyId, data, meta }) {
  const state = esm_default(this.config.stateSelector)[contractID];
  const signedMessage = innerSigningKeyId ? state._vm.authorizedKeys[innerSigningKeyId] && state._vm.authorizedKeys[innerSigningKeyId]?._notAfterHeight == null ? signedOutgoingData(contractID, innerSigningKeyId, data, this.transientSecretKeys) : signedOutgoingDataWithRawKey(this.transientSecretKeys[innerSigningKeyId], data) : data;
  const payload = !encryptionKeyId ? signedMessage : encryptedOutgoingData(contractID, encryptionKeyId, signedMessage);
  const message = signedOutgoingData(contractID, signingKeyId, payload, this.transientSecretKeys);
  const rootState = esm_default(this.config.stateSelector);
  const height = String(rootState.contracts[contractID].height);
  const serializedData = {
    ...message.serialize((meta ?? "") + height),
    height
  };
  return serializedData;
}
function parseEncryptedOrUnencryptedMessage(ctx, { contractID, serializedData, meta }) {
  if (!serializedData) {
    throw new TypeError("[chelonia] parseEncryptedOrUnencryptedMessage: serializedData is required");
  }
  const state = esm_default(ctx.config.stateSelector)[contractID];
  const numericHeight = parseInt(serializedData.height);
  const rootState = esm_default(ctx.config.stateSelector);
  const currentHeight = rootState.contracts[contractID].height;
  if (!(numericHeight >= 0) || !(numericHeight <= currentHeight)) {
    throw new Error(`[chelonia] parseEncryptedOrUnencryptedMessage: Invalid height ${serializedData.height}; it must be between 0 and ${currentHeight}`);
  }
  const aad = (meta ?? "") + serializedData.height;
  const v2 = signedIncomingData(contractID, state, serializedData, numericHeight, aad, (message) => {
    return maybeEncryptedIncomingData(contractID, state, message, numericHeight, ctx.transientSecretKeys, aad, void 0);
  });
  let encryptionKeyId;
  let innerSigningKeyId;
  const unwrap2 = /* @__PURE__ */ (() => {
    let result2;
    return () => {
      if (!result2) {
        try {
          let unwrapped;
          unwrapped = v2.valueOf();
          if (isEncryptedData(unwrapped)) {
            encryptionKeyId = unwrapped.encryptionKeyId;
            unwrapped = unwrapped.valueOf();
            if (isSignedData(unwrapped)) {
              innerSigningKeyId = unwrapped.signingKeyId;
              unwrapped = unwrapped.valueOf();
            } else {
              innerSigningKeyId = null;
            }
          } else {
            encryptionKeyId = null;
            innerSigningKeyId = null;
          }
          result2 = [
            unwrapped
          ];
        } catch (e2) {
          result2 = [
            void 0,
            e2
          ];
        }
      }
      if (result2.length === 2) {
        throw result2[1];
      }
      return result2[0];
    };
  })();
  const result = {
    get contractID() {
      return contractID;
    },
    get innerSigningKeyId() {
      if (innerSigningKeyId === void 0) {
        try {
          unwrap2();
        } catch {
        }
      }
      return innerSigningKeyId;
    },
    get encryptionKeyId() {
      if (encryptionKeyId === void 0) {
        try {
          unwrap2();
        } catch {
        }
      }
      return encryptionKeyId;
    },
    get signingKeyId() {
      return v2.signingKeyId;
    },
    get data() {
      return unwrap2();
    },
    get signingContractID() {
      return getContractIDfromKeyId(contractID, result.signingKeyId, state);
    },
    get innerSigningContractID() {
      return getContractIDfromKeyId(contractID, result.innerSigningKeyId, state);
    }
  };
  return result;
}
async function outEncryptedOrUnencryptedAction(opType, params) {
  const { atomic, action, contractID, data, hooks, publishOptions } = params;
  const contractName = contractNameFromAction(action);
  const manifestHash = this.config.contracts.manifests[contractName];
  const { contract } = this.manifestToContract[manifestHash];
  const state = contract.state(contractID);
  const meta = await contract.metadata.create();
  const unencMessage = {
    action,
    data,
    meta
  };
  const signedMessage = params.innerSigningKeyId ? state._vm.authorizedKeys[params.innerSigningKeyId] && state._vm.authorizedKeys[params.innerSigningKeyId]?._notAfterHeight == null ? signedOutgoingData(contractID, params.innerSigningKeyId, unencMessage, this.transientSecretKeys) : signedOutgoingDataWithRawKey(this.transientSecretKeys[params.innerSigningKeyId], unencMessage) : unencMessage;
  if (opType === SPMessage.OP_ACTION_ENCRYPTED && !params.encryptionKeyId) {
    throw new Error("OP_ACTION_ENCRYPTED requires an encryption key ID be given");
  }
  if (params.encryptionKey) {
    if (params.encryptionKeyId !== keyId(params.encryptionKey)) {
      throw new Error("OP_ACTION_ENCRYPTED raw encryption key does not match encryptionKeyId");
    }
  }
  const payload = opType === SPMessage.OP_ACTION_UNENCRYPTED ? signedMessage : params.encryptionKey ? encryptedOutgoingDataWithRawKey(params.encryptionKey, signedMessage) : encryptedOutgoingData(contractID, params.encryptionKeyId, signedMessage);
  let message = SPMessage.createV1_0({
    contractID,
    op: [
      opType,
      signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
    ],
    manifest: manifestHash
  });
  if (!atomic) {
    message = await esm_default("chelonia/private/out/publishEvent", message, publishOptions, hooks);
  }
  return message;
}
function gettersProxy(state, getters) {
  const proxyGetters = new Proxy({}, {
    get(_target, prop) {
      return getters[prop](state, proxyGetters);
    }
  });
  return {
    getters: proxyGetters
  };
}
esm_default("sbp/domains/lock", [
  "chelonia"
]);

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/persistent-actions.mjs
var timer = Symbol("timer");
var coerceToError = (arg) => {
  if (arg && arg instanceof Error) return arg;
  console.warn(tag, "Please use Error objects when throwing or rejecting");
  return new Error((typeof arg === "string" ? arg : JSON.stringify(arg)) ?? "undefined");
};
var defaultOptions2 = {
  maxAttempts: Number.POSITIVE_INFINITY,
  retrySeconds: 30
};
var tag = "[chelonia.persistentActions]";
var PersistentAction = class {
  id;
  invocation;
  options;
  status;
  [timer];
  constructor(invocation, options3 = {}) {
    this.id = crypto.randomUUID();
    this.invocation = invocation;
    this.options = {
      ...defaultOptions2,
      ...options3
    };
    this.status = {
      attempting: false,
      failedAttemptsSoFar: 0,
      lastError: "",
      nextRetry: "",
      resolved: false
    };
  }
  async attempt() {
    if (this.status.attempting || this.status.resolved) return;
    if (await this.trySBP(this.options.skipCondition)) this.cancel();
    if (this.status.resolved) return;
    try {
      this.status.attempting = true;
      const result = await esm_default(...this.invocation);
      this.status.attempting = false;
      this.handleSuccess(result);
    } catch (error40) {
      this.status.attempting = false;
      await this.handleError(coerceToError(error40));
    }
  }
  cancel() {
    if (this[timer]) clearTimeout(this[timer]);
    this.status.nextRetry = "";
    this.status.resolved = true;
  }
  async handleError(error40) {
    const { id, options: options3, status } = this;
    status.failedAttemptsSoFar++;
    status.lastError = error40.message;
    const anyAttemptLeft = options3.maxAttempts > status.failedAttemptsSoFar;
    if (!anyAttemptLeft) status.resolved = true;
    status.nextRetry = anyAttemptLeft && !status.resolved ? new Date(Date.now() + options3.retrySeconds * 1e3).toISOString() : "";
    esm_default("okTurtles.events/emit", PERSISTENT_ACTION_FAILURE, {
      error: error40,
      id
    });
    await this.trySBP(options3.errorInvocation);
    if (!anyAttemptLeft) {
      esm_default("okTurtles.events/emit", PERSISTENT_ACTION_TOTAL_FAILURE, {
        error: error40,
        id
      });
      await this.trySBP(options3.totalFailureInvocation);
    }
    if (status.nextRetry) {
      this[timer] = setTimeout(() => {
        this.attempt().catch((e2) => {
          console.error("Error attempting persistent action", id, e2);
        });
      }, this.options.retrySeconds * 1e3);
    }
  }
  handleSuccess(result) {
    const { id, status } = this;
    status.lastError = "";
    status.nextRetry = "";
    status.resolved = true;
    esm_default("okTurtles.events/emit", PERSISTENT_ACTION_SUCCESS, {
      id,
      result
    });
  }
  async trySBP(invocation) {
    try {
      return invocation ? await esm_default(...invocation) : void 0;
    } catch (error40) {
      console.error(tag, coerceToError(error40).message);
    }
  }
};
var persistent_actions_default = esm_default("sbp/selectors/register", {
  "chelonia.persistentActions/_init"() {
    this.actionsByID = /* @__PURE__ */ Object.create(null);
    this.checkDatabaseKey = () => {
      if (!this.databaseKey) throw new TypeError(`${tag} No database key configured`);
    };
    esm_default("okTurtles.events/on", PERSISTENT_ACTION_SUCCESS, ({ id }) => {
      esm_default("chelonia.persistentActions/cancel", id);
    });
    esm_default("okTurtles.events/on", PERSISTENT_ACTION_TOTAL_FAILURE, ({ id }) => {
      esm_default("chelonia.persistentActions/cancel", id);
    });
  },
  // Cancels a specific action by its ID.
  // The action won't be retried again, but an async action cannot be aborted if its promise is stil attempting.
  async "chelonia.persistentActions/cancel"(id) {
    if (id in this.actionsByID) {
      this.actionsByID[id].cancel();
      delete this.actionsByID[id];
      return await esm_default("chelonia.persistentActions/save");
    }
  },
  // TODO: validation
  "chelonia.persistentActions/configure"({ databaseKey, options: options3 = {} }) {
    this.databaseKey = databaseKey;
    for (const key in options3) {
      if (key in defaultOptions2) {
        defaultOptions2[key] = options3[key];
      } else {
        throw new TypeError(`${tag} Unknown option: ${key}`);
      }
    }
  },
  "chelonia.persistentActions/enqueue"(...args) {
    const ids = [];
    for (const arg of args) {
      const action = Array.isArray(arg) ? new PersistentAction(arg) : new PersistentAction(arg.invocation, arg);
      this.actionsByID[action.id] = action;
      ids.push(action.id);
    }
    esm_default("chelonia.persistentActions/save").catch((e2) => {
      console.error("Error saving persistent actions", e2);
    });
    for (const id of ids) {
      this.actionsByID[id].attempt().catch((e2) => {
        console.error("Error attempting persistent action", id, e2);
      });
    }
    return ids;
  },
  // Forces retrying a given persisted action immediately, rather than waiting for the scheduled retry.
  // - 'status.failedAttemptsSoFar' will still be increased upon failure.
  // - Does nothing if a retry is already running.
  // - Does nothing if the action has already been resolved, rejected or cancelled.
  "chelonia.persistentActions/forceRetry"(id) {
    if (id in this.actionsByID) {
      return this.actionsByID[id].attempt();
    }
  },
  // Loads and tries every stored persistent action under the configured database key.
  async "chelonia.persistentActions/load"() {
    this.checkDatabaseKey();
    const storedActions = JSON.parse(await esm_default("chelonia.db/get", this.databaseKey) ?? "[]");
    for (const { id, invocation, options: options3 } of storedActions) {
      this.actionsByID[id] = new PersistentAction(invocation, options3);
      this.actionsByID[id].id = id;
    }
    return esm_default("chelonia.persistentActions/retryAll");
  },
  // Retry all existing persisted actions.
  // TODO: add some delay between actions so as not to spam the server,
  // or have a way to issue them all at once in a single network call.
  "chelonia.persistentActions/retryAll"() {
    return Promise.allSettled(Object.keys(this.actionsByID).map((id) => esm_default("chelonia.persistentActions/forceRetry", id)));
  },
  // Updates the database version of the attempting action list.
  "chelonia.persistentActions/save"() {
    this.checkDatabaseKey();
    return esm_default("chelonia.db/set", this.databaseKey, JSON.stringify(Object.values(this.actionsByID)));
  },
  "chelonia.persistentActions/status"() {
    return Object.values(this.actionsByID).map((action) => ({
      id: action.id,
      invocation: action.invocation,
      ...action.status
    }));
  },
  // Pauses every currently loaded action, and removes them from memory.
  // Note: persistent storage is not affected, so that these actions can be later loaded again and retried.
  "chelonia.persistentActions/unload"() {
    for (const id in this.actionsByID) {
      if (this.actionsByID[id][timer]) {
        clearTimeout(this.actionsByID[id][timer]);
      }
      delete this.actionsByID[id];
    }
  }
});

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/presets.mjs
var SERVER = {
  // We don't check the subscriptionSet in the server because we accpt new
  // contract registrations, and are also not subcribed to contracts the same
  // way clients are
  acceptAllMessages: true,
  // The server also doesn't process actions
  skipActionProcessing: true,
  // The previous setting implies this one, which we set to be on the safe side
  skipSideEffects: true,
  // Changes the behaviour of unwrapMaybeEncryptedData so that it never decrypts.
  // Mostly useful for the server, to avoid filling up the logs and for faster
  // execution.
  skipDecryptionAttempts: true,
  // If an error occurs during processing, the message is rejected rather than
  // ignored
  strictProcessing: true,
  // The server expects events to be received in order (no past or future events)
  strictOrdering: true
};

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/zkpp.mjs
var import_scrypt_async2 = __toESM(require_scrypt_async(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
import { Buffer as Buffer9 } from "node:buffer";

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/zkppConstants.mjs
var AUTHSALT = "AUTHSALT";
var CONTRACTSALT = "CONTRACTSALT";
var CS = "CS";
var SU = "SU";
var SALT_LENGTH_IN_OCTETS = 24;

// node_modules/.deno/@chelonia+lib@1.2.4/node_modules/@chelonia/lib/dist/esm/zkpp.mjs
var base64ToBase64url = (s) => s.replace(/\//g, "_").replace(/\+/g, "-").replace(/=*$/, "");
var base64urlToBase64 = (s) => s.replace(/_/g, "/").replace(/-/g, "+") + "=".repeat((4 - s.length % 4) % 4);
var hashStringArray = (...args) => {
  return import_tweetnacl2.default.hash(Buffer9.concat(args.map((s) => import_tweetnacl2.default.hash(Buffer9.from(s)))));
};
var hashRawStringArray = (...args) => {
  return import_tweetnacl2.default.hash(Buffer9.concat(args.map((s) => Buffer9.from(s))));
};
var randomNonce = () => {
  return base64ToBase64url(Buffer9.from(import_tweetnacl2.default.randomBytes(12)).toString("base64"));
};
var hash2 = (v2) => {
  return base64ToBase64url(Buffer9.from(import_tweetnacl2.default.hash(Buffer9.from(v2))).toString("base64"));
};
var computeCAndHc = (r, s, h2) => {
  const \u0127 = hashStringArray(r, s);
  const c = hashStringArray(h2, \u0127);
  const hc = import_tweetnacl2.default.hash(c);
  return [
    c,
    hc
  ];
};
var encryptContractSalt = (c, contractSalt) => {
  const encryptionKey = hashRawStringArray(CS, c).slice(0, import_tweetnacl2.default.secretbox.keyLength);
  const nonce = import_tweetnacl2.default.randomBytes(import_tweetnacl2.default.secretbox.nonceLength);
  const encryptedContractSalt = import_tweetnacl2.default.secretbox(Buffer9.from(contractSalt), nonce, encryptionKey);
  return base64ToBase64url(Buffer9.concat([
    nonce,
    encryptedContractSalt
  ]).toString("base64"));
};
var encryptSaltUpdate = (secret, recordId, record2) => {
  const nonce = import_tweetnacl2.default.randomBytes(import_tweetnacl2.default.secretbox.nonceLength);
  const encryptionKey = hashRawStringArray(SU, secret, nonce, recordId).slice(0, import_tweetnacl2.default.secretbox.keyLength);
  const encryptedRecord = import_tweetnacl2.default.secretbox(Buffer9.from(record2), nonce, encryptionKey);
  return base64ToBase64url(Buffer9.concat([
    nonce,
    encryptedRecord
  ]).toString("base64"));
};
var decryptSaltUpdate = (secret, recordId, encryptedRecordBox) => {
  const encryptedRecordBoxBuf = Buffer9.from(base64urlToBase64(encryptedRecordBox), "base64");
  const nonce = encryptedRecordBoxBuf.subarray(0, import_tweetnacl2.default.secretbox.nonceLength);
  const encryptionKey = hashRawStringArray(SU, secret, nonce, recordId).slice(0, import_tweetnacl2.default.secretbox.keyLength);
  const encryptedRecord = encryptedRecordBoxBuf.subarray(import_tweetnacl2.default.secretbox.nonceLength);
  const decrypted = import_tweetnacl2.default.secretbox.open(encryptedRecord, nonce, encryptionKey);
  if (!decrypted) throw new Error("Failed to decrypt salt update");
  return Buffer9.from(decrypted).toString();
};
var boxKeyPair = () => {
  return import_tweetnacl2.default.box.keyPair();
};
var saltAgreement = (publicKey, secretKey) => {
  const publicKeyBuf = Buffer9.from(base64urlToBase64(publicKey), "base64");
  const dhKey = import_tweetnacl2.default.box.before(publicKeyBuf, secretKey);
  if (!publicKeyBuf || publicKeyBuf.byteLength !== import_tweetnacl2.default.box.publicKeyLength) {
    return false;
  }
  const authSalt = Buffer9.from(hashStringArray(AUTHSALT, dhKey)).subarray(0, SALT_LENGTH_IN_OCTETS).toString("base64");
  const contractSalt = Buffer9.from(hashStringArray(CONTRACTSALT, dhKey)).subarray(0, SALT_LENGTH_IN_OCTETS).toString("base64");
  return [
    authSalt,
    contractSalt
  ];
};
var parseRegisterSalt = (publicKey, secretKey, encryptedHashedPassword) => {
  const saltAgreementRes = saltAgreement(publicKey, secretKey);
  if (!saltAgreementRes) {
    return false;
  }
  const [authSalt, contractSalt] = saltAgreementRes;
  const encryptionKey = import_tweetnacl2.default.hash(Buffer9.from(authSalt + contractSalt)).slice(0, import_tweetnacl2.default.secretbox.keyLength);
  const encryptedHashedPasswordBuf = Buffer9.from(base64urlToBase64(encryptedHashedPassword), "base64");
  const hashedPasswordBuf = import_tweetnacl2.default.secretbox.open(encryptedHashedPasswordBuf.subarray(import_tweetnacl2.default.box.nonceLength), encryptedHashedPasswordBuf.subarray(0, import_tweetnacl2.default.box.nonceLength), encryptionKey);
  if (!hashedPasswordBuf) {
    return false;
  }
  return [
    authSalt,
    contractSalt,
    hashedPasswordBuf,
    encryptionKey
  ];
};

// build/serve/ownerSizeTotalWorker.js-tmp
var import_npm_vuelidate_0_7 = __toESM(require_lib35());
import { mkdir, readdir, readFile, rm, unlink, writeFile } from "node:fs/promises";
import { basename as basename6, dirname as dirname6, join as join6, normalize as normalize6, resolve as resolve6 } from "node:path";
import process2 from "node:process";
import { mkdir as mkdir2 } from "node:fs/promises";
import { basename as basename22, dirname as dirname22, join as join22, resolve as resolve22 } from "node:path";
import { resolve as resolve32 } from "node:path";
import { readFile as readFile2 } from "node:fs/promises";
import process3 from "node:process";
import { Readable } from "node:stream";
import fs2 from "node:fs";
import { readdir as readdir2, readFile as readFile3 } from "node:fs/promises";
import path2 from "node:path";
import process4 from "node:process";
import { Buffer as Buffer22 } from "node:buffer";
import process5 from "node:process";
import { randomBytes as randomBytes2, timingSafeEqual } from "node:crypto";
import { Buffer as Buffer32 } from "node:buffer";
import { parentPort } from "node:worker_threads";
import process52 from "node:process";
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __glob = (map2) => (path3) => {
  var fn = map2[path3];
  if (fn) return fn();
  throw new Error("Module not found in bundle: " + path3);
};
var __esm2 = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps2 = (to, from6, except, desc) => {
  if (from6 && typeof from6 === "object" || typeof from6 === "function") {
    for (let key of __getOwnPropNames2(from6))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from6[key], enumerable: !(desc = __getOwnPropDesc2(from6, key)) || desc.enumerable });
  }
  return to;
};
var __reExport2 = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
var deps_exports = {};
__export2(deps_exports, {
  AUTHSALT: () => AUTHSALT,
  Boom: () => import_boom_10_0.default,
  Bottleneck: () => import_npm_bottleneck_2_19.default,
  CID: () => CID2,
  CONTRACTSALT: () => CONTRACTSALT,
  CS: () => CS,
  CURVE25519XSALSA20POLY1305: () => CURVE25519XSALSA20POLY1305,
  ChelErrorGenerator: () => ChelErrorGenerator,
  EDWARDS25519SHA512BATCH: () => EDWARDS25519SHA512BATCH,
  Hapi: () => Hapi,
  Inert: () => import_inert_7_1.default,
  Joi: () => import_npm_joi_18_0.default,
  LRU: () => import_npm_lru_cache_7_14.default,
  NOTIFICATION_TYPE: () => NOTIFICATION_TYPE,
  PUSH_SERVER_ACTION_TYPE: () => PUSH_SERVER_ACTION_TYPE,
  REQUEST_TYPE: () => REQUEST_TYPE,
  RESPONSE_TYPE: () => RESPONSE_TYPE,
  SALT_LENGTH_IN_OCTETS: () => SALT_LENGTH_IN_OCTETS,
  SERVER: () => SERVER,
  SPMessage: () => SPMessage,
  SU: () => SU,
  WebSocket: () => wrapper_default,
  WebSocketServer: () => import_websocket_server.default,
  XSALSA20POLY1305: () => XSALSA20POLY1305,
  aes128gcm: () => x,
  assert: () => assert,
  assertEquals: () => assertEquals,
  assertRejects: () => assertRejects,
  assertThrows: () => assertThrows,
  base58btc: () => base58btc,
  base64: () => base64_exports,
  base64ToBase64url: () => base64ToBase64url,
  base64urlToBase64: () => base64urlToBase64,
  blake: () => blake2_default,
  blake32Hash: () => blake32Hash,
  boxKeyPair: () => boxKeyPair,
  chalk: () => import_npm_chalk_4_1.default,
  checkKey: () => checkKey,
  cloneDeep: () => cloneDeep,
  colors: () => colors_exports,
  computeCAndHc: () => computeCAndHc,
  copy: () => copy3,
  createCID: () => createCID,
  createClient: () => createClient,
  createKvMessage: () => createKvMessage,
  createMessage: () => createMessage,
  decrypt: () => decrypt,
  decryptSaltUpdate: () => decryptSaltUpdate,
  deriveKeyFromPassword: () => deriveKeyFromPassword,
  deserializeKey: () => deserializeKey,
  encrypt: () => encrypt,
  encryptContractSalt: () => encryptContractSalt,
  encryptSaltUpdate: () => encryptSaltUpdate,
  flags: () => mod_exports,
  fs: () => mod_exports2,
  generateSalt: () => generateSalt,
  getSubscriptionId: () => getSubscriptionId,
  hash: () => hash2,
  hashRawStringArray: () => hashRawStringArray,
  hashStringArray: () => hashStringArray,
  keyId: () => keyId,
  keygen: () => keygen,
  keygenOfSameType: () => keygenOfSameType,
  maybeParseCID: () => maybeParseCID,
  messageParser: () => messageParser,
  multicodes: () => multicodes,
  omit: () => omit2,
  parseCID: () => parseCID,
  parsePrefixableKey: () => parsePrefixableKey,
  parseRegisterSalt: () => parseRegisterSalt,
  path: () => mod_exports3,
  pino: () => import_npm_pino_8_19.default,
  prefixHandlers: () => prefixHandlers,
  randomNonce: () => randomNonce,
  readAll: () => readAll,
  rfc8188Encrypt: () => K,
  sbp: () => esm_default,
  scrypt: () => import_npm_scrypt_async_2_0.default,
  serializeKey: () => serializeKey,
  sign: () => sign,
  sqlite: () => mod_exports8,
  strToB64: () => strToB64,
  streams: () => mod_exports4,
  tweetnacl: () => import_npm_tweetnacl_1_0.default,
  util: () => mod_exports5,
  uuid: () => v4,
  validationMixin: () => import_npm_vuelidate_0_7.validationMixin,
  verifyShelterAuthorizationHeader: () => verifyShelterAuthorizationHeader,
  verifySignature: () => verifySignature,
  writeAll: () => writeAll,
  z: () => external_exports
});
var init_deps = __esm2({
  "src/deps.ts"() {
    "use strict";
    __reExport2(deps_exports, chelonia_exports);
  }
});
var requiredMethodNames;
var DatabaseBackend;
var init_DatabaseBackend = __esm2({
  "src/serve/DatabaseBackend.ts"() {
    "use strict";
    requiredMethodNames = ["init", "clear", "readData", "writeData", "deleteData", "close"];
    DatabaseBackend = class _DatabaseBackend {
      constructor() {
        if (new.target === _DatabaseBackend) {
          throw new Error("Class DatabaseBackend cannot be instantiated directly.");
        }
        const bindMethod = (name) => {
          this[name] = this[name].bind(this);
        };
        for (const name of requiredMethodNames) {
          bindMethod(name);
        }
      }
    };
  }
});
var database_fs_exports = {};
__export2(database_fs_exports, {
  default: () => FsBackend
});
async function testCaseSensitivity(backend) {
  const { readData, writeData, deleteData } = backend;
  const date5 = /* @__PURE__ */ new Date();
  const dateString = date5.toISOString();
  const originalKey = `_private_testCaseSensitivity_${date5.getTime()}_${(0, Math.random)().toFixed(8).slice(2)}`;
  const differentlyCasedKey = "_P" + originalKey.slice(2);
  await writeData(originalKey, dateString);
  try {
    const valueOriginalCase = await readData(originalKey);
    const valueDifferentCase = await readData(differentlyCasedKey);
    if (valueOriginalCase?.toString() !== dateString) {
      console.error(`Unexpected value on case-sensitivity test; expected ${dateString}`);
      throw new Error("Unexpected value: original key does not have the correct value");
    }
    if (valueDifferentCase?.toString() === dateString) {
      const errStr = "Filesystem database backend only works on case-sensitive filesystems. This appears to be a case insensitive file system. Set SKIP_DB_FS_CASE_SENSITIVITY_CHECK=true to skip.";
      console.error(errStr);
      throw new Error(errStr);
    }
  } finally {
    await deleteData(originalKey);
  }
}
var splitAndGroup;
var FsBackend;
var init_database_fs = __esm2({
  "src/serve/database-fs.ts"() {
    "use strict";
    init_deps();
    init_DatabaseBackend();
    splitAndGroup = (input, chunkLength, depth) => input.slice(0, chunkLength * depth).split("").reduce((acc, cv, i2) => {
      acc[i2 / chunkLength | 0] = (acc[i2 / chunkLength | 0] || "") + cv;
      return acc;
    }, []);
    FsBackend = class extends DatabaseBackend {
      dataFolder = "";
      depth = 0;
      keyChunkLength = 2;
      constructor(options22 = {}) {
        super();
        this.dataFolder = resolve6(options22.dirname);
        if (options22.depth) this.depth = options22.depth;
        if (options22.keyChunkLength) this.keyChunkLength = options22.keyChunkLength;
      }
      // Maps a given key to a real path on the filesystem.
      mapKey(key) {
        if (basename6(normalize6(key)) !== key) throw new TypeError("Invalid key");
        if (!this.depth) return join6(this.dataFolder, key);
        const keyChunks = splitAndGroup(key, this.keyChunkLength, this.depth);
        return join6(this.dataFolder, ...keyChunks, key);
      }
      async init() {
        await mkdir(this.dataFolder, { mode: 488, recursive: true });
        if (process2.env.SKIP_DB_FS_CASE_SENSITIVITY_CHECK === void 0) {
          await testCaseSensitivity(this);
        }
      }
      async clear() {
        const names = await readdir(this.dataFolder);
        const paths = names.map((name) => join6(this.dataFolder, name));
        await Promise.all(
          paths.map((p) => rm(p, { recursive: true }))
        );
      }
      async readData(key) {
        checkKey(key);
        return await readFile(this.mapKey(key)).catch((err) => {
          if (err.code !== "ENOENT") throw err;
        });
      }
      async writeData(key, value) {
        const path3 = this.mapKey(key);
        if (this.depth) await mkdir(dirname6(path3), { mode: 488, recursive: true });
        await writeFile(path3, value);
      }
      async deleteData(key) {
        await unlink(this.mapKey(key)).catch((e2) => {
          if (e2?.code === "ENOENT") {
            return;
          }
          throw e2;
        });
      }
      close() {
      }
    };
  }
});
var database_sqlite_exports = {};
__export2(database_sqlite_exports, {
  default: () => SqliteBackend
});
var SqliteBackend;
var init_database_sqlite = __esm2({
  "src/serve/database-sqlite.ts"() {
    "use strict";
    init_deps();
    init_DatabaseBackend();
    SqliteBackend = class extends DatabaseBackend {
      dataFolder = "";
      db = null;
      filename = "";
      readStatement = null;
      writeStatement = null;
      deleteStatement = null;
      constructor(options22 = {}) {
        super();
        const { filepath } = options22;
        const resolvedPath = resolve22(filepath);
        this.dataFolder = dirname22(resolvedPath);
        this.filename = basename22(resolvedPath);
      }
      run(sql) {
        this.db.prepare(sql).run();
      }
      async init() {
        const { dataFolder: dataFolder2, filename } = this;
        await mkdir2(dataFolder2, { mode: 488, recursive: true });
        if (this.db) {
          throw new Error(`The ${filename} SQLite database is already open.`);
        }
        this.db = new Database(join22(dataFolder2, filename));
        this.run("CREATE TABLE IF NOT EXISTS Data(key TEXT NOT NULL PRIMARY KEY, value TEXT NOT NULL)");
        console.info(`Connected to the ${filename} SQLite database.`);
        this.readStatement = this.db.prepare("SELECT value FROM Data WHERE key = ?");
        this.writeStatement = this.db.prepare("REPLACE INTO Data(key, value) VALUES(?, ?)");
        this.deleteStatement = this.db.prepare("DELETE FROM Data WHERE key = ?");
      }
      // Useful in test hooks.
      // deno-lint-ignore require-await
      async clear() {
        this.run("DELETE FROM Data");
      }
      // deno-lint-ignore require-await
      async readData(key) {
        const row = this.readStatement.get(key);
        return row?.value;
      }
      async writeData(key, value) {
        await this.writeStatement.run(key, value);
      }
      async deleteData(key) {
        await this.deleteStatement.run(key);
      }
      close() {
        this.db.close();
      }
    };
  }
});
var globImport_database_ts;
var init_ = __esm2({
  'import("./database-*.ts") in src/serve/database-router.ts'() {
    globImport_database_ts = __glob({
      "./database-fs.ts": () => Promise.resolve().then(() => (init_database_fs(), database_fs_exports)),
      "./database-router.test.ts": () => Promise.resolve().then(() => (init_database_router_test(), database_router_test_exports)),
      "./database-router.ts": () => Promise.resolve().then(() => (init_database_router(), database_router_exports)),
      "./database-sqlite.ts": () => Promise.resolve().then(() => (init_database_sqlite(), database_sqlite_exports))
    });
  }
});
var database_router_exports = {};
__export2(database_router_exports, {
  default: () => RouterBackend
});
var GI_PERSIST_ROUTER_CONFIG;
var GI_PERSIST_ROUTER_CONFIG_PATH;
var RouterBackend;
var init_database_router = __esm2({
  "src/serve/database-router.ts"() {
    "use strict";
    init_DatabaseBackend();
    init_();
    ({
      GI_PERSIST_ROUTER_CONFIG: (
        // Tried first by the config lookup.
        // Define this if your config JSON comes as a string from an envar's contents.
        GI_PERSIST_ROUTER_CONFIG
      ),
      GI_PERSIST_ROUTER_CONFIG_PATH: (
        // Tried next.
        // Define this if your config comes from a JSON file.
        GI_PERSIST_ROUTER_CONFIG_PATH
      ) = "./database-router-config.json"
    } = process3.env);
    RouterBackend = class extends DatabaseBackend {
      backends;
      config;
      constructor(options22 = {}) {
        super();
        if (options22.config) this.config = options22.config;
      }
      lookupBackend(key) {
        const { backends, config: config2 } = this;
        const keyPrefixes = Object.keys(config2);
        for (let i2 = 0; i2 < keyPrefixes.length; i2++) {
          if (key.startsWith(keyPrefixes[i2])) {
            return backends[keyPrefixes[i2]];
          }
        }
        return backends["*"];
      }
      async readConfig() {
        if (GI_PERSIST_ROUTER_CONFIG) {
          console.info("[database-router] Reading config from envar GI_PERSIST_ROUTER_CONFIG");
        } else {
          console.info("[database-router] Reading config from path", GI_PERSIST_ROUTER_CONFIG_PATH);
        }
        const configString = GI_PERSIST_ROUTER_CONFIG || await readFile2(resolve32(GI_PERSIST_ROUTER_CONFIG_PATH), "utf8");
        const config2 = JSON.parse(configString);
        return Object.fromEntries(Object.entries(config2).sort((a, b) => b[0].length - a[0].length));
      }
      validateConfig(config2) {
        const errors = [];
        if (!config2["*"]) {
          errors.push({ msg: 'Missing key: "*" (fallback storage is required)' });
        }
        for (const entry of Object.entries(config2)) {
          const value = entry[1];
          if (typeof value?.name !== "string" || typeof value?.options !== "object") {
            errors.push({ msg: "entry value must be of type { name: string, options: Object }", entry });
            continue;
          }
          if (value.name === "router") {
            errors.push({ msg: "Router backends cannot be nested.", entry });
            continue;
          }
        }
        return errors;
      }
      async init() {
        if (!this.config) this.config = await this.readConfig();
        const errors = this.validateConfig(this.config);
        if (errors.length) {
          throw new Error(`[${this.constructor.name}] ${errors.length} error(s) found in your config.`, { cause: errors });
        }
        this.backends = /* @__PURE__ */ Object.create(null);
        const entries = Object.entries(this.config);
        await Promise.all(entries.map(async (entry) => {
          const [keyPrefix, { name, options: options22 }] = entry;
          const Ctor = (await globImport_database_ts(`./database-${name}.ts`)).default;
          const backend = new Ctor(options22);
          await backend.init();
          this.backends[keyPrefix] = backend;
        }));
      }
      async readData(key) {
        return await this.lookupBackend(key).readData(key);
      }
      async writeData(key, value) {
        return await this.lookupBackend(key).writeData(key, value);
      }
      async deleteData(key) {
        return await this.lookupBackend(key).deleteData(key);
      }
      async clear() {
        for (const backend of new Set(Object.values(this.backends))) {
          try {
            await backend.clear();
          } catch (e2) {
            const prefix = Object.entries(this.backends).find(([, b]) => b === backend)[0];
            console.error(e2, `Error clearing DB for prefix ${prefix}`);
          }
        }
      }
      async close() {
        for (const backend of new Set(Object.values(this.backends))) {
          try {
            await backend.close();
          } catch (e2) {
            const prefix = Object.entries(this.backends).find(([, b]) => b === backend)[0];
            console.error(e2, `Error closing DB for prefix ${prefix}`);
          }
        }
      }
    };
  }
});
var database_router_test_exports = {};
var CID22;
var randomKeyWithPrefix;
var validConfig;
var db;
var init_database_router_test = __esm2({
  "src/serve/database-router.test.ts"() {
    "use strict";
    init_database_router();
    init_deps();
    CID22 = "Q";
    randomKeyWithPrefix = (prefix) => `${prefix}${globalThis.crypto.randomUUID().replaceAll("-", "")}`;
    validConfig = {
      [CID22]: {
        name: "sqlite",
        options: {
          filepath: "./test/temp/sqlite.db"
        }
      },
      "*": {
        name: "fs",
        options: {
          dirname: "./test/temp"
        }
      }
    };
    db = new RouterBackend({ config: validConfig });
    Deno.test({
      name: "DatabaseRouter::validateConfig",
      async fn(t) {
        await t.step("should accept a valid config", () => {
          const errors = db.validateConfig(validConfig);
          if (errors.length !== 0) throw new Error(`Expected 0 errors but got ${errors.length}`);
        });
        await t.step("should reject configs missing a * key", () => {
          const config2 = omit2(validConfig, ["*"]);
          const errors = db.validateConfig(config2);
          if (errors.length !== 1) throw new Error(`Expected 1 error but got ${errors.length}`);
        });
        await t.step("should reject config entries missing a name", () => {
          const config2 = cloneDeep(validConfig);
          delete config2["*"].name;
          const errors = db.validateConfig(config2);
          if (errors.length !== 1) throw new Error(`Expected 1 error but got ${errors.length}`);
        });
      }
    });
    Deno.test({
      name: "DatabaseRouter::lookupBackend",
      async fn(t) {
        await db.init();
        try {
          await t.step("should find the right backend for keys starting with configured prefixes", () => {
            for (const keyPrefix of Object.keys(db.config)) {
              if (keyPrefix === "*") continue;
              const key = randomKeyWithPrefix(keyPrefix);
              const actual = db.lookupBackend(key);
              const expected = db.backends[keyPrefix];
              if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
            }
          });
          await t.step("should find the right backend for keys equal to configured prefixes", () => {
            for (const keyPrefix of Object.keys(db.config)) {
              const key = keyPrefix;
              const actual = db.lookupBackend(key);
              const expected = db.backends[keyPrefix];
              if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
            }
          });
          await t.step("should return the fallback backend for keys not matching any configured prefix", () => {
            const key = "foo";
            const actual = db.lookupBackend(key);
            const expected = db.backends["*"];
            if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
          });
        } finally {
          await db.clear();
        }
      }
    });
  }
});
init_deps();
var OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL = 3e4;
init_deps();
init_deps();
var vapidPublicKey;
var vapidPrivateKey;
if (!process5.env.VAPID_EMAIL) {
  console.warn('Missing VAPID identification. Please set VAPID_EMAIL to a value like "mailto:some@example".');
}
var vapid = { VAPID_EMAIL: process5.env.VAPID_EMAIL || "mailto:test@example.com" };
var initVapid = async () => {
  const vapidKeyPair = await esm_default("chelonia.db/get", "_private_immutable_vapid_key").then(async (vapidKeyPair2) => {
    if (!vapidKeyPair2) {
      console.info("Generating new VAPID keypair...");
      const keyPair = await crypto.subtle.generateKey(
        {
          name: "ECDSA",
          namedCurve: "P-256"
          // Use P-256 curve
        },
        true,
        // Whether the key is extractable
        ["sign", "verify"]
        // Usages
      );
      const serializedKeyPair2 = await Promise.all([
        crypto.subtle.exportKey("jwk", keyPair.privateKey),
        crypto.subtle.exportKey("raw", keyPair.publicKey).then(
          (key) => Buffer22.from(key).toString("base64url")
        )
      ]);
      return esm_default("chelonia.db/set", "_private_immutable_vapid_key", JSON.stringify(serializedKeyPair2)).then(() => {
        console.info("Successfully saved newly generated VAPID keys");
        return [keyPair.privateKey, serializedKeyPair2[1]];
      });
    }
    const serializedKeyPair = JSON.parse(vapidKeyPair2);
    return [
      await crypto.subtle.importKey(
        "jwk",
        serializedKeyPair[0],
        { name: "ECDSA", namedCurve: "P-256" },
        false,
        ["sign"]
      ),
      serializedKeyPair[1]
    ];
  });
  vapidPrivateKey = vapidKeyPair[0];
  vapidPublicKey = vapidKeyPair[1];
};
init_deps();
var recordSecret;
var challengeSecret;
var registrationSecret;
var hashUpdateSecret;
var initZkpp = async () => {
  const IKM = await esm_default("chelonia.db/get", "_private_immutable_zkpp_ikm").then((IKM2) => {
    if (!IKM2) {
      const secret = randomBytes2(33).toString("base64");
      return esm_default("chelonia.db/set", "_private_immutable_zkpp_ikm", secret).then(() => {
        return secret;
      });
    }
    return IKM2;
  });
  recordSecret = Buffer32.from(hashStringArray("private/recordSecret", IKM)).toString("base64");
  challengeSecret = Buffer32.from(hashStringArray("private/challengeSecret", IKM)).toString("base64");
  registrationSecret = Buffer32.from(hashStringArray("private/registrationSecret", IKM)).toString("base64");
  hashUpdateSecret = Buffer32.from(hashStringArray("private/hashUpdateSecret", IKM)).toString("base64");
};
var SERVER_EXITING = "server-exiting";
var globImport_database_ts2 = __glob({
  "./database-fs.ts": () => Promise.resolve().then(() => (init_database_fs(), database_fs_exports)),
  "./database-router.test.ts": () => Promise.resolve().then(() => (init_database_router_test(), database_router_test_exports)),
  "./database-router.ts": () => Promise.resolve().then(() => (init_database_router(), database_router_exports)),
  "./database-sqlite.ts": () => Promise.resolve().then(() => (init_database_sqlite(), database_sqlite_exports))
});
var production = process4.env.NODE_ENV === "production";
var persistence = process4.env.GI_PERSIST || (production ? "fs" : void 0);
var dbRootPath = process4.env.DB_PATH || "./data";
var options2 = {
  fs: {
    depth: 0,
    dirname: dbRootPath,
    keyChunkLength: 2
  },
  sqlite: {
    filepath: path2.join(dbRootPath, "groupincome.db")
  }
};
var KEYOP_SEGMENT_LENGTH = 1e4;
var dataFolder = path2.resolve(options2.fs.dirname);
if (!fs2.existsSync(dataFolder)) {
  fs2.mkdirSync(dataFolder, { mode: 488 });
}
var updateSize = async (resourceID, sizeKey, size, skipIfDeleted) => {
  if (!Number.isSafeInteger(size)) {
    throw new TypeError(`Invalid given size ${size} for ${resourceID}`);
  }
  await esm_default("okTurtles.eventQueue/queueEvent", sizeKey, async () => {
    const storedSize = await esm_default("chelonia.db/get", sizeKey, { bypassCache: true });
    if (skipIfDeleted && storedSize == null) return;
    const existingSize = parseInt(storedSize ?? "0", 10);
    if (!(existingSize >= 0)) {
      throw new TypeError(`Invalid stored size ${existingSize} for ${resourceID}`);
    }
    const updatedSize = existingSize + size;
    if (!(updatedSize >= 0)) {
      throw new TypeError(`Invalid stored updated size ${updatedSize} for ${resourceID}`);
    }
    await esm_default("chelonia.db/set", sizeKey, updatedSize.toString(10));
  });
};
var database_default = esm_default("sbp/selectors/register", {
  "backend/db/streamEntriesAfter": async function(contractID, height, requestedLimit, options22 = {}) {
    const limit = Math.min(requestedLimit ?? Number.POSITIVE_INFINITY, process4.env.MAX_EVENTS_BATCH_SIZE ? parseInt(process4.env.MAX_EVENTS_BATCH_SIZE) : 500);
    const latestHEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
    if (latestHEADinfo === "") {
      throw import_boom_10_0.default.resourceGone(`contractID ${contractID} has been deleted!`);
    }
    if (!latestHEADinfo) {
      throw import_boom_10_0.default.notFound(`contractID ${contractID} doesn't exist!`);
    }
    let counter = 0;
    let currentHeight = height;
    let currentHash, serverMeta;
    let prefix = "";
    const nextKeyOp = /* @__PURE__ */ (() => {
      let index;
      return async () => {
        if (!index) {
          index = (await esm_default("chelonia.db/get", `_private_keyop_idx_${contractID}_${currentHeight - currentHeight % KEYOP_SEGMENT_LENGTH}`))?.split("\0");
        }
        const value = index?.find((h2, i2) => {
          if (Number(h2) >= currentHeight) {
            index = index.slice(i2 + 1);
            return true;
          } else {
            return false;
          }
        });
        if (value != null) {
          const newHeight = Number(value);
          currentHeight = newHeight;
        } else {
          currentHeight = currentHeight - currentHeight % KEYOP_SEGMENT_LENGTH + KEYOP_SEGMENT_LENGTH;
          index = void 0;
          if (currentHeight > latestHEADinfo.height) {
            return false;
          } else {
            return null;
          }
        }
        return true;
      };
    })();
    const fetchMeta = async () => {
      if (currentHeight > latestHEADinfo.height) {
        return false;
      }
      const meta = await esm_default("chelonia/db/getEntryMeta", contractID, currentHeight);
      if (!meta) {
        return false;
      }
      const { hash: newCurrentHash, ...newServerMeta } = meta;
      currentHash = newCurrentHash;
      serverMeta = newServerMeta;
      return true;
    };
    const stream = Readable.from(async function* () {
      yield "[";
      await fetchMeta();
      while (serverMeta && counter < limit) {
        try {
          const entry = await esm_default("chelonia/db/getEntry", currentHash);
          if (!entry) break;
          const currentPrefix = prefix;
          prefix = ",";
          counter++;
          yield `${currentPrefix}"${strToB64(
            JSON.stringify({ serverMeta, message: entry.serialize() })
          )}"`;
          currentHeight++;
          currentHash = void 0;
          serverMeta = void 0;
          if (options22.keyOps) {
            while (await nextKeyOp() === null) ;
          }
          await fetchMeta();
        } catch (e2) {
          console.error(e2, "[backend] streamEntriesAfter: read()");
          break;
        }
      }
      yield "]";
    }(), { encoding: "utf-8", objectMode: false });
    stream.headers = {
      "shelter-headinfo-head": latestHEADinfo.HEAD,
      "shelter-headinfo-height": latestHEADinfo.height
    };
    return stream;
  },
  // =======================
  // wrapper methods to add / lookup names
  // =======================
  "backend/db/registerName": async function(name, value) {
    const exists2 = await esm_default("backend/db/lookupName", name);
    if (exists2) {
      throw import_boom_10_0.default.conflict("exists");
    }
    await esm_default("chelonia.db/set", namespaceKey(name), value);
    await esm_default("chelonia.db/set", `_private_cid2name_${value}`, name);
    await appendToNamesIndex(name);
    return { name, value };
  },
  "backend/db/lookupName": async function(name) {
    const value = await esm_default("chelonia.db/get", namespaceKey(name));
    return value;
  }
});
function namespaceKey(name) {
  return "name=" + name;
}
var initDB = async ({ skipDbPreloading } = {}) => {
  if (persistence) {
    const Ctor = (await globImport_database_ts2(`./database-${persistence}.ts`)).default;
    const { init: init2, readData, writeData, deleteData, close } = new Ctor(options2[persistence]);
    await init2();
    esm_default("okTurtles.events/once", SERVER_EXITING, () => {
      esm_default("okTurtles.eventQueue/queueEvent", SERVER_EXITING, async () => {
        try {
          await close();
        } catch (e2) {
          console.error(e2, `Error closing DB ${persistence}`);
        }
      });
    });
    const cache3 = new import_npm_lru_cache_7_14.default({
      max: Number(process4.env.GI_LRU_NUM_ITEMS) || 1e4
    });
    const prefixes = Object.keys(prefixHandlers);
    esm_default("sbp/selectors/overwrite", {
      "chelonia.db/get": async function(prefixableKey, { bypassCache } = {}) {
        if (!bypassCache) {
          const lookupValue = cache3.get(prefixableKey);
          if (lookupValue !== void 0) {
            return lookupValue;
          }
        }
        const [prefix, key] = parsePrefixableKey(prefixableKey);
        let value = await readData(key);
        if (value === void 0) {
          return;
        }
        value = prefixHandlers[prefix](value);
        cache3.set(prefixableKey, value);
        return value;
      },
      "chelonia.db/set": async function(key, value) {
        if (process4.env.CHELONIA_ARCHIVE_MODE) throw new Error("Unable to write in archive mode");
        checkKey(key);
        if (key.startsWith("_private_immutable")) {
          const existingValue = await readData(key);
          if (existingValue !== void 0) {
            throw new Error("Cannot set already set immutable key");
          }
        }
        await writeData(key, value);
        prefixes.forEach((prefix) => {
          cache3.delete(prefix + key);
        });
      },
      "chelonia.db/delete": async function(key) {
        if (process4.env.CHELONIA_ARCHIVE_MODE) throw new Error("Unable to write in archive mode");
        checkKey(key);
        if (key.startsWith("_private_immutable")) {
          throw new Error("Cannot delete immutable key");
        }
        await deleteData(key);
        prefixes.forEach((prefix) => {
          cache3.delete(prefix + key);
        });
      }
    });
    esm_default("sbp/selectors/lock", ["chelonia.db/get", "chelonia.db/set", "chelonia.db/delete"]);
  }
  if (skipDbPreloading) return;
  if (persistence !== "fs" || options2.fs.dirname !== dbRootPath) {
    const HASH_LENGTH = 56;
    const keys = (await readdir2(dataFolder)).filter((k) => {
      if (k.length !== HASH_LENGTH) return false;
      const parsed = maybeParseCID(k);
      return parsed && [
        multicodes.SHELTER_CONTRACT_MANIFEST,
        multicodes.SHELTER_CONTRACT_TEXT
      ].includes(parsed.code);
    });
    const numKeys2 = keys.length;
    let numVisitedKeys = 0;
    let numNewKeys = 0;
    const savedProgress = { value: 0, numKeys: 0 };
    console.info("[chelonia.db] Preloading...");
    for (const key of keys) {
      if (!persistence || !await esm_default("chelonia.db/get", key)) {
        const value = await readFile3(path2.join(dataFolder, key), "utf8");
        await esm_default("chelonia.db/set", key, value);
        numNewKeys++;
      }
      numVisitedKeys++;
      const progress = numVisitedKeys === numKeys2 ? 100 : Math.floor(100 * numVisitedKeys / numKeys2);
      if (progress === 100 || progress - savedProgress.value >= 10 && numVisitedKeys - savedProgress.numKeys >= 10) {
        console.info(`[chelonia.db] Preloading... ${progress}% done`);
        savedProgress.numKeys = numVisitedKeys;
        savedProgress.value = progress;
      }
    }
    numNewKeys && console.info(`[chelonia.db] Preloaded ${numNewKeys} new entries`);
  }
  await Promise.all([initVapid(), initZkpp()]);
};
var appendToIndexFactory = (key) => {
  return (value) => {
    return esm_default("okTurtles.eventQueue/queueEvent", key, async () => {
      const currentIndex = await esm_default("chelonia.db/get", key, { bypassCache: true });
      if (currentIndex) {
        if (
          // Check if the value is at the end
          currentIndex.endsWith("\0" + value) || // Check if the value is at the start
          currentIndex.startsWith(value + "\0") || // Check if the current index is exactly the value
          currentIndex === value
        ) {
          return;
        }
        await esm_default("chelonia.db/set", key, `${currentIndex}\0${value}`);
        return;
      }
      await esm_default("chelonia.db/set", key, value);
    });
  };
};
var appendToNamesIndex = appendToIndexFactory("_private_names_index");
var removeFromIndexFactory = (key) => {
  return (values) => {
    return esm_default("okTurtles.eventQueue/queueEvent", key, async () => {
      let existingEntries = await esm_default("chelonia.db/get", key, { bypassCache: true });
      if (!existingEntries) return;
      if (!Array.isArray(values)) {
        values = [values];
      }
      for (const value of values) {
        if (existingEntries.endsWith("\0" + value)) {
          existingEntries = existingEntries.slice(0, -value.length - 1);
          continue;
        }
        if (existingEntries.startsWith(value + "\0")) {
          existingEntries = existingEntries.slice(value.length + 1);
          continue;
        }
        if (existingEntries === value) {
          existingEntries = void 0;
          break;
        }
        const entryIndex = existingEntries.indexOf("\0" + value + "\0");
        if (entryIndex === -1) continue;
        existingEntries = existingEntries.slice(0, entryIndex) + existingEntries.slice(entryIndex + value.length + 1);
      }
      if (existingEntries) {
        await esm_default("chelonia.db/set", key, existingEntries);
      } else {
        await esm_default("chelonia.db/delete", key);
      }
    });
  };
};
var lookupUltimateOwner = async (resourceID) => {
  let ownerID = resourceID;
  for (let depth = 128; depth >= 0; depth--) {
    const newOwnerID = await esm_default("chelonia.db/get", `_private_owner_${ownerID}`, { bypassCache: true });
    if (!newOwnerID) break;
    if (!depth) {
      throw new Error("Exceeded max depth looking up owner for " + resourceID);
    }
    ownerID = newOwnerID;
  }
  return ownerID;
};
init_deps();
init_deps();
var prettyPrint = process52.env.NODE_ENV === "development" || process52.env.CI || process52.env.CYPRESS_RECORD_KEY || process52.env.PRETTY;
function logMethod(args, method) {
  const stringIdx = typeof args[0] === "string" ? 0 : 1;
  if (args.length > 1) {
    for (let i2 = stringIdx + 1; i2 < args.length; ++i2) {
      args[stringIdx] += typeof args[i2] === "string" ? " %s" : " %o";
    }
  }
  method.apply(this, args);
}
var logger;
if (prettyPrint) {
  try {
    logger = (0, import_npm_pino_8_19.default)({
      hooks: { logMethod },
      transport: {
        target: "pino-pretty",
        options: {
          colorize: true
        }
      }
    });
  } catch (e2) {
    console.warn("pino-pretty transport unavailable, using basic logging", e2);
    logger = (0, import_npm_pino_8_19.default)({ hooks: { logMethod } });
  }
} else {
  logger = (0, import_npm_pino_8_19.default)({ hooks: { logMethod } });
}
var logLevel = process52.env.LOG_LEVEL || (prettyPrint ? "debug" : "info");
if (Object.keys(logger.levels.values).includes(logLevel)) {
  logger.level = logLevel;
} else {
  logger.warn(`Unknown log level: ${logLevel}`);
}
globalThis.logger = logger;
console.debug = logger.debug.bind(logger);
console.info = logger.info.bind(logger);
console.log = logger.info.bind(logger);
console.warn = logger.warn.bind(logger);
console.error = logger.error.bind(logger);
var readyQueueName = "parentPort";
parentPort.on("message", ([port, ...msg]) => {
  esm_default("okTurtles.eventQueue/queueEvent", readyQueueName, () => {
    (async () => {
      try {
        port?.postMessage([true, await esm_default(...msg)]);
      } catch (e2) {
        port?.postMessage([false, e2]);
      }
    })();
  });
});
esm_default("okTurtles.eventQueue/queueEvent", readyQueueName, async () => {
  await initDB({ skipDbPreloading: true });
  parentPort.postMessage("ready");
});
var updatedSizeList = /* @__PURE__ */ new Set();
var updatedSizeMap = /* @__PURE__ */ new Map();
var cachedUltimateOwnerMap = /* @__PURE__ */ new Map();
var fastBase58Hash = (cid) => {
  const len = cid.length;
  const a = cid.codePointAt(len - 2) || 0;
  const b = cid.codePointAt(len - 1) || 0;
  return a * 19 + (b + 19) & 255;
};
var addToTempIndex = (cid) => {
  return appendToIndexFactory(`_private_pendingIdx_ownerTotalSize_${fastBase58Hash(cid)}`)(cid);
};
var removeFromTempIndex = (cids) => {
  const cidsByBucket = cids.reduce((acc, cv) => {
    const bucket = fastBase58Hash(cv);
    const ownedResourcesSet = acc.get(bucket);
    if (ownedResourcesSet) {
      ownedResourcesSet.add(cv);
    } else {
      acc.set(bucket, /* @__PURE__ */ new Set([cv]));
    }
    return acc;
  }, /* @__PURE__ */ new Map());
  return Promise.all([...cidsByBucket].map(([bucket, cids2]) => {
    return removeFromIndexFactory(`_private_pendingIdx_ownerTotalSize_${bucket}`)([...cids2]);
  }));
};
esm_default("okTurtles.eventQueue/queueEvent", readyQueueName, async () => {
  for (let i2 = 0; i2 < 256; i2++) {
    const data = await esm_default("chelonia.db/get", `_private_pendingIdx_ownerTotalSize_${i2}`, { bypassCache: true });
    if (data) {
      data.split("\0").forEach((cid) => {
        updatedSizeList.add(cid);
      });
    }
  }
  console.info(`[ownerSizeTotalWorker] Loaded ${updatedSizeList.size} CIDs for full recalculation.`);
  if (updatedSizeList.size) {
    esm_default("backend/server/computeSizeTask");
  }
  setTimeout(esm_default, OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL, "backend/server/computeSizeTaskDeltas");
});
esm_default("sbp/selectors/register", {
  /**
   * Selector: 'worker/updateSizeSideEffects'
   * Handles incoming size update events for a specific resource.
   * It adds the CID to the temporary persistent index (if not already processed
   * or pending full recalc) and updates the in-memory delta map (`updatedSizeMap`).
   *
   * IMPORTANT: This should only be called for keys where this is relevant,
   * such as `_private_size_` keys.
   */
  "worker/updateSizeSideEffects": async ({ resourceID, size, ultimateOwnerID }) => {
    if (updatedSizeList.has(resourceID)) return;
    const current = updatedSizeMap.get(resourceID);
    if (current === void 0) {
      try {
        await addToTempIndex(ultimateOwnerID || resourceID);
        updatedSizeMap.set(resourceID, size);
      } catch (e2) {
        console.error(e2, `[ownerSizeTotalWorker] Error adding ${resourceID} to temp index:`);
      }
    } else {
      updatedSizeMap.set(resourceID, current + size);
    }
    if (ultimateOwnerID) {
      cachedUltimateOwnerMap.set(resourceID, ultimateOwnerID);
    }
  },
  /**
   * Selector: 'backend/server/computeSizeTaskDeltas'
   * Periodically executed task (via setTimeout) to process accumulated
   * size _deltas_.
   * Calculates the change in total size for ultimate owners based on the deltas
   * stored in `updatedSizeMap` and updates the database.
   */
  "backend/server/computeSizeTaskDeltas": async function() {
    const deltaEntries = Array.from(updatedSizeMap);
    updatedSizeMap.clear();
    const ultimateOwners = /* @__PURE__ */ new Map();
    const orphansSet = /* @__PURE__ */ new Set();
    await Promise.all(deltaEntries.map(async ([contractID, delta]) => {
      const cachedOwnerID = cachedUltimateOwnerMap.get(contractID);
      const ownerID = cachedOwnerID || await lookupUltimateOwner(contractID);
      if (!cachedOwnerID && ownerID === contractID) {
        if (!await esm_default("chelonia.db/get", contractID)) {
          const current = updatedSizeMap.get(contractID) ?? 0;
          updatedSizeMap.set(contractID, current + delta);
          orphansSet.add(contractID);
          return;
        }
      }
      cachedUltimateOwnerMap.delete(contractID);
      const [val, ownedResourcesSet] = ultimateOwners.get(ownerID) || [0, /* @__PURE__ */ new Set([ownerID])];
      ownedResourcesSet.add(contractID);
      ultimateOwners.set(ownerID, [val + delta, ownedResourcesSet]);
    }));
    await Promise.all(Array.from(ultimateOwners).map(async ([id, [totalDelta, contributingResources]]) => {
      await updateSize(id, `_private_ownerTotalSize_${id}`, totalDelta);
      await removeFromTempIndex(Array.from(contributingResources));
    }));
    await removeFromTempIndex(Array.from(orphansSet));
    setTimeout(esm_default, OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL, "backend/server/computeSizeTaskDeltas");
  },
  /**
   * Selector: 'backend/server/computeSizeTask'
   * Task to perform a full recalculation of total owner sizes.
   * Triggered on startup if `updatedSizeList` is populated (from
   * persistent index).
   * Processes resource IDs from `updatedSizeList`.
   */
  "backend/server/computeSizeTask": async function() {
    const start = performance.now();
    const resourcesToRecalculate = Array.from(updatedSizeList);
    const ultimateOwners = /* @__PURE__ */ new Map();
    await Promise.all(resourcesToRecalculate.map(async (contractID) => {
      const ownerID = await lookupUltimateOwner(contractID);
      const resources = ultimateOwners.get(ownerID);
      if (resources) {
        resources.add(contractID);
      } else {
        ultimateOwners.set(ownerID, /* @__PURE__ */ new Set([contractID]));
      }
    }));
    await Promise.all(Array.from(ultimateOwners).map(async ([ownerID, contractIDs]) => {
      const resources = await esm_default("chelonia.db/get", `_private_resources_${ownerID}`);
      const indirectResources = resources ? await esm_default("chelonia.db/get", `_private_indirectResources_${ownerID}`) : void 0;
      const allSubresources = Array.from(/* @__PURE__ */ new Set([
        ownerID,
        ...resources ? resources.split("\0") : [],
        ...indirectResources ? indirectResources.split("\0") : []
      ]));
      const totalSize = (await Promise.all(allSubresources.map((id) => {
        return esm_default("chelonia.db/get", `_private_size_${id}`);
      }))).reduce((acc, cv) => {
        if (cv) {
          const parsed = parseInt(cv, 10);
          if (parsed) return parsed + acc;
        }
        return acc;
      }, 0);
      await esm_default("okTurtles.eventQueue/queueEvent", `_private_ownerTotalSize_${ownerID}`, async () => {
        allSubresources.forEach((id) => {
          updatedSizeList.delete(id);
          if (updatedSizeMap.delete(id)) {
            contractIDs.add(id);
          }
        });
        await esm_default("chelonia.db/set", `_private_ownerTotalSize_${ownerID}`, totalSize.toString(10));
        await removeFromTempIndex(Array.from(contractIDs).filter((id) => {
          return !updatedSizeMap.has(id);
        }));
      });
    }));
    console.info(`[ownerSizeTotalWorker] Computed size for ${updatedSizeList.size} CIDs in ${((performance.now() - start) / 1e3).toFixed(2)} seconds.`);
  }
});
/*! Bundled license information:

scrypt-async/scrypt-async.js:
  (*!
   * Fast "async" scrypt implementation in JavaScript.
   * Copyright (c) 2013-2016 Dmitry Chestnykh | BSD License
   * https://github.com/dchest/scrypt-async-js
   *)
*/
