import { createRequire } from "node:module";
var __require = createRequire(import.meta.url);


// build/serve/ownerSizeTotalWorker.js-tmp
import { Buffer as Buffer2 } from "node:buffer";
import { Buffer as Buffer5 } from "node:buffer";
import { mkdir, readdir, readFile, rm, unlink, writeFile } from "node:fs/promises";
import { basename as basename6, dirname as dirname6, join as join6, normalize as normalize6, resolve as resolve6 } from "node:path";
import process3 from "node:process";
import { Buffer as Buffer10 } from "node:buffer";

// deno:https://jsr.io/@db/sqlite/0.12.0/deno.json
var deno_default = {
  name: "@db/sqlite",
  version: "0.12.0",
  github: "https://github.com/denodrivers/sqlite3",
  exports: "./mod.ts",
  exclude: [
    "sqlite",
    "scripts"
  ],
  tasks: {
    test: "deno test --unstable-ffi -A test/test.ts",
    build: "deno run -A scripts/build.ts",
    "bench-deno": "deno run -A --unstable-ffi bench/bench_deno.js 50 1000000",
    "bench-deno-ffi": "deno run -A --unstable-ffi bench/bench_deno_ffi.js 50 1000000",
    "bench-deno-wasm": "deno run -A --unstable-ffi bench/bench_deno_wasm.js 50 1000000",
    "bench-node": "node bench/bench_node.js 50 1000000",
    "bench-bun": "bun run bench/bench_bun.js 50 1000000",
    "bench-bun-ffi": "bun run bench/bench_bun_ffi.js 50 1000000",
    "bench-c": "./bench/bench 50 1000000",
    "bench-python": "python ./bench/bench_python.py",
    "bench:northwind": "deno bench -A --unstable-ffi bench/northwind/deno.js",
    "bench-wasm:northwind": "deno run -A --unstable-ffi bench/northwind/deno_wasm.js",
    "bench-node:northwind": "node bench/northwind/node.mjs",
    "bench-bun:northwind": "bun run bench/northwind/bun.js"
  },
  fmt: {
    exclude: [
      "sqlite"
    ]
  },
  lint: {
    rules: {
      exclude: [
        "camelcase",
        "no-explicit-any"
      ],
      include: [
        "explicit-function-return-type",
        "eqeqeq",
        "explicit-module-boundary-types"
      ]
    }
  }
};

// deno:https://jsr.io/@std/path/0.217.0/_common/from_file_url.ts
function assertArg3(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol !== "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return url;
}

// deno:https://jsr.io/@std/path/0.217.0/windows/from_file_url.ts
function fromFileUrl(url) {
  url = assertArg3(url);
  let path2 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname !== "") {
    path2 = `\\\\${url.hostname}${path2}`;
  }
  return path2;
}

// deno:https://jsr.io/@std/path/0.217.0/posix/from_file_url.ts
function fromFileUrl2(url) {
  url = assertArg3(url);
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

// deno:https://jsr.io/@std/path/0.217.0/_os.ts
var osType = (() => {
  const { Deno: Deno3 } = globalThis;
  if (typeof Deno3?.build?.os === "string") {
    return Deno3.build.os;
  }
  const { navigator: navigator2 } = globalThis;
  if (navigator2?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows = osType === "windows";

// deno:https://jsr.io/@std/path/0.217.0/from_file_url.ts
function fromFileUrl3(url) {
  return isWindows ? fromFileUrl(url) : fromFileUrl2(url);
}

// deno:https://jsr.io/@std/internal/1.0.10/_os.ts
function checkWindows() {
  const global2 = globalThis;
  const os = global2.Deno?.build?.os;
  return typeof os === "string" ? os === "windows" : global2.navigator?.platform?.startsWith("Win") ?? global2.process?.platform?.startsWith("win") ?? false;
}

// deno:https://jsr.io/@std/internal/1.0.10/os.ts
var isWindows2 = checkWindows();

// deno:https://jsr.io/@std/path/1.1.1/_common/assert_path.ts
function assertPath2(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string, received "${JSON.stringify(path2)}"`);
  }
}

// deno:https://jsr.io/@std/path/1.1.1/_common/from_file_url.ts
function assertArg5(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol !== "file:") {
    throw new TypeError(`URL must be a file URL: received "${url.protocol}"`);
  }
  return url;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/from_file_url.ts
function fromFileUrl4(url) {
  url = assertArg5(url);
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

// deno:https://jsr.io/@std/path/1.1.1/_common/strip_trailing_separators.ts
function stripTrailingSeparators2(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i2 = segment.length - 1; i2 > 0; i2--) {
    if (isSep(segment.charCodeAt(i2))) {
      end = i2;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/constants.ts
var CHAR_UPPERCASE_A2 = 65;
var CHAR_LOWERCASE_A2 = 97;
var CHAR_UPPERCASE_Z2 = 90;
var CHAR_LOWERCASE_Z2 = 122;
var CHAR_DOT2 = 46;
var CHAR_FORWARD_SLASH2 = 47;
var CHAR_BACKWARD_SLASH2 = 92;
var CHAR_COLON2 = 58;

// deno:https://jsr.io/@std/path/1.1.1/posix/_util.ts
function isPosixPathSeparator3(code2) {
  return code2 === CHAR_FORWARD_SLASH2;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/_util.ts
function isPosixPathSeparator4(code2) {
  return code2 === CHAR_FORWARD_SLASH2;
}
function isPathSeparator2(code2) {
  return code2 === CHAR_FORWARD_SLASH2 || code2 === CHAR_BACKWARD_SLASH2;
}
function isWindowsDeviceRoot2(code2) {
  return code2 >= CHAR_LOWERCASE_A2 && code2 <= CHAR_LOWERCASE_Z2 || code2 >= CHAR_UPPERCASE_A2 && code2 <= CHAR_UPPERCASE_Z2;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/from_file_url.ts
function fromFileUrl5(url) {
  url = assertArg5(url);
  let path2 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname !== "") {
    path2 = `\\\\${url.hostname}${path2}`;
  }
  return path2;
}

// deno:https://jsr.io/@std/path/1.1.1/_common/dirname.ts
function assertArg6(path2) {
  assertPath2(path2);
  if (path2.length === 0) return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/posix/dirname.ts
function dirname3(path2) {
  if (path2 instanceof URL) {
    path2 = fromFileUrl4(path2);
  }
  assertArg6(path2);
  let end = -1;
  let matchedNonSeparator = false;
  for (let i2 = path2.length - 1; i2 >= 1; --i2) {
    if (isPosixPathSeparator3(path2.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        end = i2;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator3(path2.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators2(path2.slice(0, end), isPosixPathSeparator3);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/dirname.ts
function dirname4(path2) {
  if (path2 instanceof URL) {
    path2 = fromFileUrl5(path2);
  }
  assertArg6(path2);
  const len = path2.length;
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path2.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator2(path2.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path2.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path2.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path2.charCodeAt(j))) break;
            }
            if (j === len) {
              return path2;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path2.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator2(path2.charCodeAt(2))) rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return path2;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator2(path2.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1) return ".";
    else end = rootEnd;
  }
  return stripTrailingSeparators2(path2.slice(0, end), isPosixPathSeparator4);
}

// deno:https://jsr.io/@std/path/1.1.1/dirname.ts
function dirname5(path2) {
  return isWindows2 ? dirname4(path2) : dirname3(path2);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/extname.ts
function extname3(path2) {
  if (path2 instanceof URL) {
    path2 = fromFileUrl4(path2);
  }
  assertPath2(path2);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path2.length - 1; i2 >= 0; --i2) {
    const code2 = path2.charCodeAt(i2);
    if (isPosixPathSeparator3(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT2) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/extname.ts
function extname4(path2) {
  if (path2 instanceof URL) {
    path2 = fromFileUrl5(path2);
  }
  assertPath2(path2);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path2.length >= 2 && path2.charCodeAt(1) === CHAR_COLON2 && isWindowsDeviceRoot2(path2.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path2.length - 1; i2 >= start; --i2) {
    const code2 = path2.charCodeAt(i2);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT2) {
      if (startDot === -1) startDot = i2;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}

// deno:https://jsr.io/@std/path/1.1.1/extname.ts
function extname5(path2) {
  return isWindows2 ? extname4(path2) : extname3(path2);
}

// deno:https://jsr.io/@std/path/1.1.1/from_file_url.ts
function fromFileUrl6(url) {
  return isWindows2 ? fromFileUrl5(url) : fromFileUrl4(url);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/is_absolute.ts
function isAbsolute3(path2) {
  assertPath2(path2);
  return path2.length > 0 && isPosixPathSeparator3(path2.charCodeAt(0));
}

// deno:https://jsr.io/@std/path/1.1.1/windows/is_absolute.ts
function isAbsolute4(path2) {
  assertPath2(path2);
  const len = path2.length;
  if (len === 0) return false;
  const code2 = path2.charCodeAt(0);
  if (isPathSeparator2(code2)) {
    return true;
  } else if (isWindowsDeviceRoot2(code2)) {
    if (len > 2 && path2.charCodeAt(1) === CHAR_COLON2) {
      if (isPathSeparator2(path2.charCodeAt(2))) return true;
    }
  }
  return false;
}

// deno:https://jsr.io/@std/path/1.1.1/is_absolute.ts
function isAbsolute5(path2) {
  return isWindows2 ? isAbsolute4(path2) : isAbsolute3(path2);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/normalize.ts
function assertArg8(path2) {
  assertPath2(path2);
  if (path2.length === 0) return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/_common/normalize_string.ts
function normalizeString2(path2, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length) code2 = path2.charCodeAt(i2);
    else if (isPathSeparator3(code2)) break;
    else code2 = CHAR_FORWARD_SLASH2;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT2 || res.charCodeAt(res.length - 2) !== CHAR_DOT2) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) res += `${separator}..`;
          else res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += separator + path2.slice(lastSlash + 1, i2);
        else res = path2.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === CHAR_DOT2 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/normalize.ts
function normalize3(path2) {
  if (path2 instanceof URL) {
    path2 = fromFileUrl4(path2);
  }
  assertArg8(path2);
  const isAbsolute6 = isPosixPathSeparator3(path2.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator3(path2.charCodeAt(path2.length - 1));
  path2 = normalizeString2(path2, !isAbsolute6, "/", isPosixPathSeparator3);
  if (path2.length === 0 && !isAbsolute6) path2 = ".";
  if (path2.length > 0 && trailingSeparator) path2 += "/";
  if (isAbsolute6) return `/${path2}`;
  return path2;
}

// deno:https://jsr.io/@std/path/1.1.1/posix/join.ts
function join3(path2, ...paths) {
  if (path2 === void 0) return ".";
  if (path2 instanceof URL) {
    path2 = fromFileUrl4(path2);
  }
  paths = path2 ? [
    path2,
    ...paths
  ] : paths;
  paths.forEach((path3) => assertPath2(path3));
  const joined = paths.filter((path3) => path3.length > 0).join("/");
  return joined === "" ? "." : normalize3(joined);
}

// deno:https://jsr.io/@std/path/1.1.1/windows/normalize.ts
function normalize4(path2) {
  if (path2 instanceof URL) {
    path2 = fromFileUrl5(path2);
  }
  assertArg8(path2);
  const len = path2.length;
  let rootEnd = 0;
  let device;
  let isAbsolute6 = false;
  const code2 = path2.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      isAbsolute6 = true;
      if (isPathSeparator2(path2.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path2.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          const firstPart = path2.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path2.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path2.charCodeAt(j))) break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path2.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path2.charCodeAt(1) === CHAR_COLON2) {
        device = path2.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path2.charCodeAt(2))) {
            isAbsolute6 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString2(path2.slice(rootEnd), !isAbsolute6, "\\", isPathSeparator2);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute6) tail = ".";
  if (tail.length > 0 && isPathSeparator2(path2.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute6) {
      if (tail.length > 0) return `\\${tail}`;
      else return "\\";
    }
    return tail;
  } else if (isAbsolute6) {
    if (tail.length > 0) return `${device}\\${tail}`;
    else return `${device}\\`;
  }
  return device + tail;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/join.ts
function join4(path2, ...paths) {
  if (path2 instanceof URL) {
    path2 = fromFileUrl5(path2);
  }
  paths = path2 ? [
    path2,
    ...paths
  ] : paths;
  paths.forEach((path3) => assertPath2(path3));
  paths = paths.filter((path3) => path3.length > 0);
  if (paths.length === 0) return ".";
  let needsReplace = true;
  let slashCount = 0;
  const firstPart = paths[0];
  if (isPathSeparator2(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator2(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  let joined = paths.join("\\");
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
    }
    if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize4(joined);
}

// deno:https://jsr.io/@std/path/1.1.1/join.ts
function join5(path2, ...paths) {
  return isWindows2 ? join4(path2, ...paths) : join3(path2, ...paths);
}

// deno:https://jsr.io/@std/path/1.1.1/normalize.ts
function normalize5(path2) {
  return isWindows2 ? normalize4(path2) : normalize3(path2);
}

// deno:https://jsr.io/@std/path/1.1.1/posix/resolve.ts
function resolve3(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path2;
    if (i2 >= 0) path2 = pathSegments[i2];
    else {
      const { Deno: Deno3 } = globalThis;
      if (typeof Deno3?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path2 = Deno3.cwd();
    }
    assertPath2(path2);
    if (path2.length === 0) {
      continue;
    }
    resolvedPath = `${path2}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator3(path2.charCodeAt(0));
  }
  resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator3);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) return `/${resolvedPath}`;
    else return "/";
  } else if (resolvedPath.length > 0) return resolvedPath;
  else return ".";
}

// deno:https://jsr.io/@std/path/1.1.1/windows/resolve.ts
function resolve4(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path2;
    const { Deno: Deno3 } = globalThis;
    if (i2 >= 0) {
      path2 = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno3?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a current working directory (CWD)");
      }
      path2 = Deno3.cwd();
    } else {
      if (typeof Deno3?.env?.get !== "function" || typeof Deno3?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path2 = Deno3.cwd();
      if (path2 === void 0 || path2.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path2 = `${resolvedDevice}\\`;
      }
    }
    assertPath2(path2);
    const len = path2.length;
    if (len === 0) continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute6 = false;
    const code2 = path2.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator2(code2)) {
        isAbsolute6 = true;
        if (isPathSeparator2(path2.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator2(path2.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            const firstPart = path2.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator2(path2.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator2(path2.charCodeAt(j))) break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path2.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot2(code2)) {
        if (path2.charCodeAt(1) === CHAR_COLON2) {
          device = path2.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator2(path2.charCodeAt(2))) {
              isAbsolute6 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator2(code2)) {
      rootEnd = 1;
      isAbsolute6 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path2.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute6;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0) break;
  }
  resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}

// deno:https://jsr.io/@std/path/1.1.1/resolve.ts
function resolve5(...pathSegments) {
  return isWindows2 ? resolve4(...pathSegments) : resolve3(...pathSegments);
}

// deno:https://jsr.io/@std/path/1.1.1/_common/to_file_url.ts
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace2(string) {
  return string.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS[c] ?? c;
  });
}

// deno:https://jsr.io/@std/path/1.1.1/posix/to_file_url.ts
function toFileUrl3(path2) {
  if (!isAbsolute3(path2)) {
    throw new TypeError(`Path must be absolute: received "${path2}"`);
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(path2.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}

// deno:https://jsr.io/@std/path/1.1.1/windows/to_file_url.ts
function toFileUrl4(path2) {
  if (!isAbsolute4(path2)) {
    throw new TypeError(`Path must be absolute: received "${path2}"`);
  }
  const [, hostname, pathname] = path2.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
  if (hostname !== void 0 && hostname !== "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError(`Invalid hostname: "${url.hostname}"`);
    }
  }
  return url;
}

// deno:https://jsr.io/@std/path/1.1.1/to_file_url.ts
function toFileUrl5(path2) {
  return isWindows2 ? toFileUrl4(path2) : toFileUrl3(path2);
}

// deno:https://jsr.io/@std/fs/1.0.19/_get_file_info_type.ts
function getFileInfoType(fileInfo) {
  return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : void 0;
}

// deno:https://jsr.io/@std/fs/1.0.19/ensure_dir.ts
async function ensureDir(dir) {
  try {
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    await Deno.mkdir(dir, {
      recursive: true
    });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
  }
}
function throwIfNotDirectory(fileInfo) {
  if (!fileInfo.isDirectory) {
    throw new Error(`Failed to ensure directory exists: expected 'dir', got '${getFileInfoType(fileInfo)}'`);
  }
}

// deno:https://jsr.io/@std/fs/1.0.19/move.ts
var EXISTS_ERROR = new Deno.errors.AlreadyExists("dest already exists.");

// deno:https://jsr.io/@std/fs/1.0.19/eol.ts
var LF = "\n";
var CRLF = "\r\n";
var EOL = globalThis.Deno?.build.os === "windows" ? CRLF : LF;

// deno:https://jsr.io/@std/fmt/1.0.8/colors.ts
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : false;
var enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code2) {
  return enabled ? `${code2.open}${str.replace(code2.regexp, code2.open)}${code2.close}` : str;
}
function green(str) {
  return run(str, code([
    32
  ], 39));
}
var ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
].join("|"), "g");

// deno:https://jsr.io/@std/encoding/1.0.10/_common16.ts
var alphabet = new TextEncoder().encode("0123456789abcdef");
var rAlphabet = new Uint8Array(128).fill(16);
alphabet.forEach((byte, i2) => rAlphabet[byte] = i2);
new TextEncoder().encode("ABCDEF").forEach((byte, i2) => rAlphabet[byte] = i2 + 10);
function calcSizeHex(originalSize) {
  return originalSize * 2;
}
function encode(buffer, i2, o2, alphabet3) {
  for (; i2 < buffer.length; ++i2) {
    const x2 = buffer[i2];
    buffer[o2++] = alphabet3[x2 >> 4];
    buffer[o2++] = alphabet3[x2 & 15];
  }
  return o2;
}

// deno:https://jsr.io/@std/encoding/1.0.10/_common_detach.ts
function detach(buffer, maxSize) {
  const originalSize = buffer.length;
  if (buffer.byteOffset) {
    const b = new Uint8Array(buffer.buffer);
    b.set(buffer);
    buffer = b.subarray(0, originalSize);
  }
  buffer = new Uint8Array(buffer.buffer.transfer(maxSize));
  buffer.set(buffer.subarray(0, originalSize), maxSize - originalSize);
  return [
    buffer,
    maxSize - originalSize
  ];
}

// deno:https://jsr.io/@std/encoding/1.0.10/hex.ts
var alphabet2 = new TextEncoder().encode("0123456789abcdef");
var rAlphabet2 = new Uint8Array(128).fill(16);
alphabet2.forEach((byte, i2) => rAlphabet2[byte] = i2);
new TextEncoder().encode("ABCDEF").forEach((byte, i2) => rAlphabet2[byte] = i2 + 10);
function encodeHex(src2) {
  if (typeof src2 === "string") {
    src2 = new TextEncoder().encode(src2);
  } else if (src2 instanceof ArrayBuffer) src2 = new Uint8Array(src2).slice();
  else src2 = src2.slice();
  const [output, i2] = detach(src2, calcSizeHex(src2.length));
  encode(output, i2, 0, alphabet2);
  return new TextDecoder().decode(output);
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/util.ts
var encoder = new TextEncoder();
function baseUrlToFilename(url) {
  const out = [];
  const protocol = url.protocol.replace(":", "");
  out.push(protocol);
  switch (protocol) {
    case "http":
    case "https": {
      const host = url.hostname;
      const hostPort = url.port;
      out.push(hostPort ? `${host}_PORT${hostPort}` : host);
      break;
    }
    case "file":
    case "data":
    case "blob":
      break;
    default:
      throw new TypeError(`Don't know how to create cache name for protocol: ${protocol}`);
  }
  return join5(...out);
}
function stringToURL(url) {
  return url.startsWith("file://") || url.startsWith("http://") || url.startsWith("https://") ? new URL(url) : toFileUrl5(resolve5(url));
}
async function hash(value) {
  return encodeHex(new Uint8Array(await crypto.subtle.digest("SHA-256", encoder.encode(value))));
}
async function urlToFilename(url) {
  const cacheFilename = baseUrlToFilename(url);
  const hashedFilename = await hash(url.pathname + url.search);
  return join5(cacheFilename, hashedFilename);
}
async function isFile(filePath) {
  try {
    const stats = await Deno.lstat(filePath);
    return stats.isFile;
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    }
    throw err;
  }
}
function homeDir() {
  switch (Deno.build.os) {
    case "windows":
      return Deno.env.get("USERPROFILE");
    case "linux":
    case "darwin":
    case "freebsd":
    case "netbsd":
    case "aix":
    case "solaris":
    case "illumos":
    case "android":
      return Deno.env.get("HOME");
    default:
      throw Error("unreachable");
  }
}
function cacheDir() {
  if (Deno.build.os === "darwin") {
    const home = homeDir();
    if (home) {
      return join5(home, "Library/Caches");
    }
  } else if (Deno.build.os === "windows") {
    return Deno.env.get("LOCALAPPDATA");
  } else {
    const cacheHome = Deno.env.get("XDG_CACHE_HOME");
    if (cacheHome) {
      return cacheHome;
    } else {
      const home = homeDir();
      if (home) {
        return join5(home, ".cache");
      }
    }
  }
}
function denoCacheDir() {
  const dd = Deno.env.get("DENO_DIR");
  let root;
  if (dd) {
    root = normalize5(isAbsolute5(dd) ? dd : join5(Deno.cwd(), dd));
  } else {
    const cd = cacheDir();
    if (cd) {
      root = join5(cd, "deno");
    } else {
      const hd = homeDir();
      if (hd) {
        root = join5(hd, ".deno");
      }
    }
  }
  return root;
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/download.ts
var ALL_ARCHS = [
  "x86_64",
  "aarch64"
];
var ALL_OSS = [
  "darwin",
  "linux",
  "android",
  "windows",
  "freebsd",
  "netbsd",
  "aix",
  "solaris",
  "illumos"
];
var defaultExtensions = {
  darwin: "dylib",
  linux: "so",
  windows: "dll",
  freebsd: "so",
  netbsd: "so",
  aix: "so",
  solaris: "so",
  illumos: "so",
  android: "so"
};
var defaultPrefixes = {
  darwin: "lib",
  linux: "lib",
  netbsd: "lib",
  freebsd: "lib",
  aix: "lib",
  solaris: "lib",
  illumos: "lib",
  windows: "",
  android: "lib"
};
function getCrossOption(record) {
  if (record === void 0) {
    return;
  }
  if (ALL_OSS.some((os) => os in record)) {
    const subrecord = record[Deno.build.os];
    if (subrecord && typeof subrecord === "object" && ALL_ARCHS.some((arch) => arch in subrecord)) {
      return subrecord[Deno.build.arch];
    } else {
      return subrecord;
    }
  }
  if (ALL_ARCHS.some((arch) => arch in record)) {
    const subrecord = record[Deno.build.arch];
    if (subrecord && typeof subrecord === "object" && ALL_OSS.some((os) => os in subrecord)) {
      return subrecord[Deno.build.os];
    } else {
      return subrecord;
    }
  }
}
function createDownloadURL(options2) {
  if (typeof options2 === "string" || options2 instanceof URL) {
    options2 = {
      url: options2
    };
  }
  options2.extensions ??= defaultExtensions;
  options2.prefixes ??= defaultPrefixes;
  for (const key in options2.extensions) {
    const os = key;
    if (options2.extensions[os] !== void 0) {
      options2.extensions[os] = options2.extensions[os].replace(/\.?(.+)/, "$1");
    }
  }
  let url;
  if (options2.url instanceof URL) {
    url = options2.url;
  } else if (typeof options2.url === "string") {
    url = stringToURL(options2.url);
  } else {
    const tmpUrl = getCrossOption(options2.url);
    if (tmpUrl === void 0) {
      throw new TypeError(`An URL for the "${Deno.build.os}-${Deno.build.arch}" target was not provided.`);
    }
    if (typeof tmpUrl === "string") {
      url = stringToURL(tmpUrl);
    } else {
      url = tmpUrl;
    }
  }
  if ("name" in options2 && !Object.values(options2.extensions).includes(extname5(url.pathname))) {
    if (!url.pathname.endsWith("/")) {
      url.pathname = `${url.pathname}/`;
    }
    const prefix = getCrossOption(options2.prefixes) ?? "";
    const suffix = getCrossOption(options2.suffixes) ?? "";
    const extension = options2.extensions[Deno.build.os];
    if (options2.name === void 0) {
      throw new TypeError(`Expected the "name" property for an automatically assembled URL.`);
    }
    const filename = `${prefix}${options2.name}${suffix}.${extension}`;
    url = new URL(filename, url);
  }
  return url;
}
async function ensureCacheLocation(location = "deno") {
  if (location === "deno") {
    const dir = denoCacheDir();
    if (dir === void 0) {
      throw new Error("Could not get the deno cache directory, try using another CacheLocation in the plug options.");
    }
    location = join5(dir, "plug");
  } else if (location === "cache") {
    const dir = cacheDir();
    if (dir === void 0) {
      throw new Error("Could not get the cache directory, try using another CacheLocation in the plug options.");
    }
    location = join5(dir, "plug");
  } else if (location === "cwd") {
    location = join5(Deno.cwd(), "plug");
  } else if (location === "tmp") {
    location = await Deno.makeTempDir({
      prefix: "plug"
    });
  } else if (typeof location === "string" && location.startsWith("file://")) {
    location = fromFileUrl6(location);
  } else if (location instanceof URL) {
    if (location?.protocol !== "file:") {
      throw new TypeError("Cannot use any other protocol than file:// for an URL cache location.");
    }
    location = fromFileUrl6(location);
  }
  location = resolve5(normalize5(location));
  await ensureDir(location);
  return location;
}
async function download(options2) {
  const location = (typeof options2 === "object" && "location" in options2 ? options2.location : void 0) ?? "deno";
  const setting = (typeof options2 === "object" && "cache" in options2 ? options2.cache : void 0) ?? "use";
  const url = createDownloadURL(options2);
  const directory = await ensureCacheLocation(location);
  const cacheBasePath = join5(directory, await urlToFilename(url));
  const cacheFilePath = `${cacheBasePath}${extname5(url.pathname)}`;
  const cacheMetaPath = `${cacheBasePath}.metadata.json`;
  const cached = setting === "use" ? await isFile(cacheFilePath) : setting === "only" || setting !== "reloadAll";
  await ensureDir(dirname5(cacheBasePath));
  if (!cached) {
    const meta = {
      url
    };
    switch (url.protocol) {
      case "http:":
      case "https:": {
        console.log(`${green("Downloading")} ${url}`);
        const response = await fetch(url.toString());
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error(`Could not find ${url}`);
          } else {
            throw new Deno.errors.Http(`${response.status} ${response.statusText}`);
          }
        }
        await Deno.writeFile(cacheFilePath, new Uint8Array(await response.arrayBuffer()));
        break;
      }
      case "file:": {
        console.log(`${green("Copying")} ${url}`);
        await Deno.copyFile(fromFileUrl6(url), cacheFilePath);
        if (Deno.build.os !== "windows") {
          await Deno.chmod(cacheFilePath, 420);
        }
        break;
      }
      default: {
        throw new TypeError(`Cannot fetch to cache using the "${url.protocol}" protocol`);
      }
    }
    await Deno.writeTextFile(cacheMetaPath, JSON.stringify(meta));
  }
  if (!await isFile(cacheFilePath)) {
    throw new Error(`Could not find "${url}" in cache.`);
  }
  return cacheFilePath;
}

// deno:https://jsr.io/@denosaurs/plug/1.1.0/mod.ts
async function dlopen(options2, symbols2) {
  if (Deno.dlopen === void 0) {
    throw new Error("`--unstable-ffi` is required");
  }
  return Deno.dlopen(await download(options2), symbols2);
}

// deno:https://jsr.io/@db/sqlite/0.12.0/src/ffi.ts
var symbols = {
  sqlite3_open_v2: {
    parameters: [
      "buffer",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_close_v2: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_changes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_total_changes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_last_insert_rowid: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_get_autocommit: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_prepare_v2: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "buffer",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_reset: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_clear_bindings: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_step: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_column_count: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_column_type: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_text: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_value: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_finalize: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_exec: {
    parameters: [
      "pointer",
      "buffer",
      "pointer",
      "pointer",
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_free: {
    parameters: [
      "pointer"
    ],
    result: "void"
  },
  sqlite3_column_int: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_double: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "f64"
  },
  sqlite3_column_blob: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_bytes: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_column_name: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_decltype: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "u64"
  },
  sqlite3_bind_parameter_index: {
    parameters: [
      "pointer",
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_bind_text: {
    parameters: [
      "pointer",
      "i32",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_blob: {
    parameters: [
      "pointer",
      "i32",
      "buffer",
      "i32",
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_double: {
    parameters: [
      "pointer",
      "i32",
      "f64"
    ],
    result: "i32"
  },
  sqlite3_bind_int: {
    parameters: [
      "pointer",
      "i32",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_bind_int64: {
    parameters: [
      "pointer",
      "i32",
      "i64"
    ],
    result: "i32"
  },
  sqlite3_bind_null: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_expanded_sql: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_bind_parameter_count: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_complete: {
    parameters: [
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_sourceid: {
    parameters: [],
    result: "pointer"
  },
  sqlite3_libversion: {
    parameters: [],
    result: "pointer"
  },
  sqlite3_blob_open: {
    parameters: [
      "pointer",
      /* sqlite3 *db */
      "buffer",
      /* const char *zDb */
      "buffer",
      /* const char *zTable */
      "buffer",
      /* const char *zColumn */
      "i64",
      /* sqlite3_int64 iRow */
      "i32",
      /* int flags */
      "buffer"
    ],
    result: "i32"
  },
  sqlite3_blob_read: {
    parameters: [
      "pointer",
      /* sqlite3_blob *blob */
      "buffer",
      /* void *Z */
      "i32",
      /* int N */
      "i32"
    ],
    result: "i32"
  },
  sqlite3_blob_write: {
    parameters: [
      "pointer",
      /* sqlite3_blob *blob */
      "buffer",
      /* const void *z */
      "i32",
      /* int n */
      "i32"
    ],
    result: "i32"
  },
  sqlite3_blob_bytes: {
    parameters: [
      "pointer"
      /* sqlite3_blob *blob */
    ],
    result: "i32"
  },
  sqlite3_blob_close: {
    parameters: [
      "pointer"
      /* sqlite3_blob *blob */
    ],
    result: "i32"
  },
  sqlite3_sql: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_stmt_readonly: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_bind_parameter_name: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_errcode: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_errmsg: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_errstr: {
    parameters: [
      "i32"
    ],
    result: "pointer"
  },
  sqlite3_column_int64: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i64"
  },
  sqlite3_backup_init: {
    parameters: [
      "pointer",
      "buffer",
      "pointer",
      "buffer"
    ],
    result: "pointer"
  },
  sqlite3_backup_step: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32"
  },
  sqlite3_backup_finish: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_backup_remaining: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_backup_pagecount: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_create_function: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "i32",
      "pointer",
      "pointer",
      "pointer",
      "pointer"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_result_blob: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "isize"
    ],
    result: "void"
  },
  sqlite3_result_double: {
    parameters: [
      "pointer",
      "f64"
    ],
    result: "void"
  },
  sqlite3_result_error: {
    parameters: [
      "pointer",
      "buffer",
      "i32"
    ],
    result: "void"
  },
  sqlite3_result_int: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "void"
  },
  sqlite3_result_int64: {
    parameters: [
      "pointer",
      "i64"
    ],
    result: "void"
  },
  sqlite3_result_null: {
    parameters: [
      "pointer"
    ],
    result: "void"
  },
  sqlite3_result_text: {
    parameters: [
      "pointer",
      "buffer",
      "i32",
      "isize"
    ],
    result: "void"
  },
  sqlite3_value_type: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_subtype: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_blob: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_value_double: {
    parameters: [
      "pointer"
    ],
    result: "f64"
  },
  sqlite3_value_int: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_value_int64: {
    parameters: [
      "pointer"
    ],
    result: "i64"
  },
  sqlite3_value_text: {
    parameters: [
      "pointer"
    ],
    result: "pointer"
  },
  sqlite3_value_bytes: {
    parameters: [
      "pointer"
    ],
    result: "i32"
  },
  sqlite3_aggregate_context: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "pointer",
    optional: true
  },
  sqlite3_enable_load_extension: {
    parameters: [
      "pointer",
      "i32"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_load_extension: {
    parameters: [
      "pointer",
      "buffer",
      "buffer",
      "buffer"
    ],
    result: "i32",
    optional: true
  },
  sqlite3_initialize: {
    parameters: [],
    result: "i32"
  }
};
var lib;
function tryGetEnv(key) {
  try {
    return Deno.env.get(key);
  } catch (e2) {
    if (e2 instanceof Deno.errors.PermissionDenied) {
      return void 0;
    }
    throw e2;
  }
}
try {
  const customPath = tryGetEnv("DENO_SQLITE_PATH");
  const sqliteLocal = tryGetEnv("DENO_SQLITE_LOCAL");
  if (sqliteLocal === "1") {
    lib = Deno.dlopen(new URL(`../build/${Deno.build.os === "windows" ? "" : "lib"}sqlite3${Deno.build.arch !== "x86_64" ? `_${Deno.build.arch}` : ""}.${Deno.build.os === "windows" ? "dll" : Deno.build.os === "darwin" ? "dylib" : "so"}`, import.meta.url), symbols).symbols;
  } else if (customPath) {
    lib = Deno.dlopen(customPath, symbols).symbols;
  } else {
    lib = (await dlopen({
      name: "sqlite3",
      url: `${deno_default.github}/releases/download/${deno_default.version}/`,
      suffixes: {
        aarch64: "_aarch64"
      }
    }, symbols)).symbols;
  }
} catch (e2) {
  if (e2 instanceof Deno.errors.PermissionDenied) {
    throw e2;
  }
  throw new Error("Failed to load SQLite3 Dynamic Library", {
    cause: e2
  });
}
var init = lib.sqlite3_initialize();
if (init !== 0) {
  throw new Error(`Failed to initialize SQLite3: ${init}`);
}
var ffi_default = lib;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/constants.ts
var SQLITE3_OK = 0;
var SQLITE3_MISUSE = 21;
var SQLITE3_ROW = 100;
var SQLITE3_DONE = 101;
var SQLITE3_OPEN_READONLY = 1;
var SQLITE3_OPEN_READWRITE = 2;
var SQLITE3_OPEN_CREATE = 4;
var SQLITE3_OPEN_MEMORY = 128;
var SQLITE_INTEGER = 1;
var SQLITE_FLOAT = 2;
var SQLITE_TEXT = 3;
var SQLITE_BLOB = 4;
var SQLITE_NULL = 5;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/util.ts
var { sqlite3_errmsg, sqlite3_errstr } = ffi_default;
var encoder2 = new TextEncoder();
function toCString(str) {
  return encoder2.encode(str + "\0");
}
var SqliteError = class extends Error {
  code;
  name;
  constructor(code2 = 1, message = "Unknown Error") {
    super(`${code2}: ${message}`), this.code = code2, this.name = "SqliteError";
  }
};
function unwrap(code2, db2) {
  if (code2 === SQLITE3_OK || code2 === SQLITE3_DONE) return;
  if (code2 === SQLITE3_MISUSE) {
    throw new SqliteError(code2, "SQLite3 API misuse");
  } else if (db2 !== void 0) {
    const errmsg = sqlite3_errmsg(db2);
    if (errmsg === null) throw new SqliteError(code2);
    throw new Error(Deno.UnsafePointerView.getCString(errmsg));
  } else {
    throw new SqliteError(code2, Deno.UnsafePointerView.getCString(sqlite3_errstr(code2)));
  }
}
var buf = Deno.UnsafePointerView.getArrayBuffer;
var readCstr = Deno.UnsafePointerView.getCString;

// deno:https://jsr.io/@db/sqlite/0.12.0/src/statement.ts
var _computedKey;
var _computedKey1;
var _computedKey2;
var { sqlite3_prepare_v2, sqlite3_reset, sqlite3_clear_bindings, sqlite3_step, sqlite3_column_count, sqlite3_column_type, sqlite3_column_value, sqlite3_value_subtype, sqlite3_column_text, sqlite3_finalize, sqlite3_column_int64, sqlite3_column_double, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_name, sqlite3_expanded_sql, sqlite3_bind_parameter_count, sqlite3_bind_int, sqlite3_bind_int64, sqlite3_bind_text, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_parameter_index, sqlite3_sql, sqlite3_stmt_readonly, sqlite3_bind_parameter_name, sqlite3_changes, sqlite3_column_int } = ffi_default;
var STATEMENTS_TO_DB = /* @__PURE__ */ new Map();
var emptyStringBuffer = new Uint8Array(1);
var statementFinalizer = new FinalizationRegistry((ptr) => {
  if (STATEMENTS_TO_DB.has(ptr)) {
    sqlite3_finalize(ptr);
    STATEMENTS_TO_DB.delete(ptr);
  }
});
var JSON_SUBTYPE = 74;
var BIG_MAX = BigInt(Number.MAX_SAFE_INTEGER);
function getColumn(handle, i2, int64) {
  const ty = sqlite3_column_type(handle, i2);
  if (ty === SQLITE_INTEGER && !int64) return sqlite3_column_int(handle, i2);
  switch (ty) {
    case SQLITE_TEXT: {
      const ptr = sqlite3_column_text(handle, i2);
      if (ptr === null) return null;
      const text = readCstr(ptr, 0);
      const value = sqlite3_column_value(handle, i2);
      const subtype = sqlite3_value_subtype(value);
      if (subtype === JSON_SUBTYPE) {
        try {
          return JSON.parse(text);
        } catch (_error) {
          return text;
        }
      }
      return text;
    }
    case SQLITE_INTEGER: {
      const val = sqlite3_column_int64(handle, i2);
      if (val < -BIG_MAX || val > BIG_MAX) {
        return val;
      }
      return Number(val);
    }
    case SQLITE_FLOAT: {
      return sqlite3_column_double(handle, i2);
    }
    case SQLITE_BLOB: {
      const ptr = sqlite3_column_blob(handle, i2);
      if (ptr === null) {
        return new Uint8Array();
      }
      const bytes = sqlite3_column_bytes(handle, i2);
      return new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(ptr, bytes).slice(0));
    }
    default: {
      return null;
    }
  }
}
_computedKey = Symbol.iterator, _computedKey1 = Symbol.dispose, _computedKey2 = Symbol.for("Deno.customInspect");
var Statement = class {
  db;
  #handle;
  #finalizerToken;
  #bound;
  #hasNoArgs;
  #unsafeConcurrency;
  /**
   * Whether the query might call into JavaScript or not.
   *
   * Must enable if the query makes use of user defined functions,
   * otherwise there can be V8 crashes.
   *
   * Off by default. Causes performance degradation.
   */
  callback;
  /** Unsafe Raw (pointer) to the sqlite object */
  get unsafeHandle() {
    return this.#handle;
  }
  /** SQL string including bindings */
  get expandedSql() {
    return readCstr(sqlite3_expanded_sql(this.#handle));
  }
  /** The SQL string that we passed when creating statement */
  get sql() {
    return readCstr(sqlite3_sql(this.#handle));
  }
  /** Whether this statement doesn't make any direct changes to the DB */
  get readonly() {
    return sqlite3_stmt_readonly(this.#handle) !== 0;
  }
  /** Simply run the query without retrieving any output there may be. */
  run(...args) {
    return this.#runWithArgs(...args);
  }
  /**
   * Run the query and return the resulting rows where rows are array of columns.
   */
  values(...args) {
    return this.#valuesWithArgs(...args);
  }
  /**
   * Run the query and return the resulting rows where rows are objects
   * mapping column name to their corresponding values.
   */
  all(...args) {
    return this.#allWithArgs(...args);
  }
  #bindParameterCount;
  /** Number of parameters (to be) bound */
  get bindParameterCount() {
    return this.#bindParameterCount;
  }
  constructor(db2, sql) {
    this.db = db2;
    this.#bound = false;
    this.#hasNoArgs = false;
    this.callback = false;
    this.#bindRefs = /* @__PURE__ */ new Set();
    this.#rowObject = {};
    const pHandle = new BigUint64Array(1);
    unwrap(sqlite3_prepare_v2(db2.unsafeHandle, toCString(sql), sql.length, pHandle, null), db2.unsafeHandle);
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
    STATEMENTS_TO_DB.set(this.#handle, db2.unsafeHandle);
    this.#unsafeConcurrency = db2.unsafeConcurrency;
    this.#finalizerToken = {
      handle: this.#handle
    };
    statementFinalizer.register(this, this.#handle, this.#finalizerToken);
    if ((this.#bindParameterCount = sqlite3_bind_parameter_count(this.#handle)) === 0) {
      this.#hasNoArgs = true;
      this.all = this.#allNoArgs;
      this.values = this.#valuesNoArgs;
      this.run = this.#runNoArgs;
      this.value = this.#valueNoArgs;
      this.get = this.#getNoArgs;
    }
  }
  /** Shorthand for `this.callback = true`. Enables calling user defined functions. */
  enableCallback() {
    this.callback = true;
    return this;
  }
  /** Get bind parameter name by index */
  bindParameterName(i2) {
    return readCstr(sqlite3_bind_parameter_name(this.#handle, i2));
  }
  /** Get bind parameter index by name */
  bindParameterIndex(name) {
    if (name[0] !== ":" && name[0] !== "@" && name[0] !== "$") {
      name = ":" + name;
    }
    return sqlite3_bind_parameter_index(this.#handle, toCString(name));
  }
  #begin() {
    sqlite3_reset(this.#handle);
    if (!this.#bound && !this.#hasNoArgs) {
      sqlite3_clear_bindings(this.#handle);
      this.#bindRefs.clear();
    }
  }
  #bindRefs;
  #bind(i2, param) {
    switch (typeof param) {
      case "number": {
        if (Number.isInteger(param)) {
          if (Number.isSafeInteger(param) && param >= -(2 ** 31) && param < 2 ** 31) {
            unwrap(sqlite3_bind_int(this.#handle, i2 + 1, param));
          } else {
            unwrap(sqlite3_bind_int64(this.#handle, i2 + 1, BigInt(param)));
          }
        } else {
          unwrap(sqlite3_bind_double(this.#handle, i2 + 1, param));
        }
        break;
      }
      case "string": {
        if (param === "") {
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, emptyStringBuffer, 0, null));
        } else {
          const str = new TextEncoder().encode(param);
          this.#bindRefs.add(str);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, str, str.byteLength, null));
        }
        break;
      }
      case "object": {
        if (param === null) {
        } else if (param instanceof Uint8Array) {
          this.#bindRefs.add(param);
          unwrap(sqlite3_bind_blob(this.#handle, i2 + 1, param.byteLength === 0 ? emptyStringBuffer : param, param.byteLength, null));
        } else if (param instanceof Date) {
          const cstring = toCString(param.toISOString());
          this.#bindRefs.add(cstring);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, cstring, -1, null));
        } else {
          const cstring = toCString(JSON.stringify(param));
          this.#bindRefs.add(cstring);
          unwrap(sqlite3_bind_text(this.#handle, i2 + 1, cstring, -1, null));
        }
        break;
      }
      case "bigint": {
        unwrap(sqlite3_bind_int64(this.#handle, i2 + 1, param));
        break;
      }
      case "boolean":
        unwrap(sqlite3_bind_int(this.#handle, i2 + 1, param ? 1 : 0));
        break;
      default: {
        throw new Error(`Value of unsupported type: ${Deno.inspect(param)}`);
      }
    }
  }
  /**
   * Bind parameters to the statement. This method can only be called once
   * to set the parameters to be same throughout the statement. You cannot
   * change the parameters after this method is called.
   *
   * This method is merely just for optimization to avoid binding parameters
   * each time in prepared statement.
   */
  bind(...params) {
    this.#bindAll(params);
    this.#bound = true;
    return this;
  }
  #bindAll(params) {
    if (this.#bound) throw new Error("Statement already bound to values");
    if (typeof params[0] === "object" && params[0] !== null && !(params[0] instanceof Uint8Array) && !(params[0] instanceof Date)) {
      params = params[0];
    }
    if (Array.isArray(params)) {
      for (let i2 = 0; i2 < params.length; i2++) {
        this.#bind(i2, params[i2]);
      }
    } else {
      for (const [name, param] of Object.entries(params)) {
        const i2 = this.bindParameterIndex(name);
        if (i2 === 0) {
          throw new Error(`No such parameter "${name}"`);
        }
        this.#bind(i2 - 1, param);
      }
    }
  }
  #runNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const status = sqlite3_step(handle);
    if (status !== SQLITE3_ROW && status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return sqlite3_changes(this.db.unsafeHandle);
  }
  #runWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_ROW && status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return sqlite3_changes(this.db.unsafeHandle);
  }
  #valuesNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const columnCount = sqlite3_column_count(handle);
    const result = [];
    const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
      length: columnCount
    }).map((_, i2) => `getColumn(h, ${i2}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowArray(handle));
      status = sqlite3_step(handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #valuesWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const columnCount = sqlite3_column_count(handle);
    const result = [];
    const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
      length: columnCount
    }).map((_, i2) => `getColumn(h, ${i2}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowArray(handle));
      status = sqlite3_step(handle);
    }
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #rowObjectFn;
  getRowObject() {
    if (!this.#rowObjectFn || !this.#unsafeConcurrency) {
      const columnNames = this.columnNames();
      const getRowObject = new Function("getColumn", `
        return function(h) {
          return {
            ${columnNames.map((name, i2) => `"${name}": getColumn(h, ${i2}, ${this.db.int64})`).join(",\n")}
          };
        };
        `)(getColumn);
      this.#rowObjectFn = getRowObject;
    }
    return this.#rowObjectFn;
  }
  #allNoArgs() {
    const handle = this.#handle;
    this.#begin();
    const getRowObject = this.getRowObject();
    const result = [];
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowObject(handle));
      status = sqlite3_step(handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  #allWithArgs(...params) {
    const handle = this.#handle;
    this.#begin();
    this.#bindAll(params);
    const getRowObject = this.getRowObject();
    const result = [];
    let status = sqlite3_step(handle);
    while (status === SQLITE3_ROW) {
      result.push(getRowObject(handle));
      status = sqlite3_step(handle);
    }
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(handle);
    return result;
  }
  /** Fetch only first row as an array, if any. */
  value(...params) {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const arr = new Array(sqlite3_column_count(handle));
    sqlite3_reset(handle);
    if (!this.#hasNoArgs && !this.#bound) {
      sqlite3_clear_bindings(handle);
      this.#bindRefs.clear();
      if (params.length) {
        this.#bindAll(params);
      }
    }
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        arr[i2] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(this.#handle);
      return arr;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #valueNoArgs() {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const cc = sqlite3_column_count(handle);
    const arr = new Array(cc);
    sqlite3_reset(handle);
    const status = sqlite3_step(handle);
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < cc; i2++) {
        arr[i2] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(this.#handle);
      return arr;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #columnNames;
  #rowObject;
  columnNames() {
    if (!this.#columnNames || !this.#unsafeConcurrency) {
      const columnCount = sqlite3_column_count(this.#handle);
      const columnNames = new Array(columnCount);
      for (let i2 = 0; i2 < columnCount; i2++) {
        columnNames[i2] = readCstr(sqlite3_column_name(this.#handle, i2));
      }
      this.#columnNames = columnNames;
      this.#rowObject = {};
      for (const name of columnNames) {
        this.#rowObject[name] = void 0;
      }
    }
    return this.#columnNames;
  }
  /** Fetch only first row as an object, if any. */
  get(...params) {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const columnNames = this.columnNames();
    const row = {};
    sqlite3_reset(handle);
    if (!this.#hasNoArgs && !this.#bound) {
      sqlite3_clear_bindings(handle);
      this.#bindRefs.clear();
      if (params.length) {
        this.#bindAll(params);
      }
    }
    const status = sqlite3_step(handle);
    if (!this.#hasNoArgs && !this.#bound && params.length) {
      this.#bindRefs.clear();
    }
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < columnNames.length; i2++) {
        row[columnNames[i2]] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(this.#handle);
      return row;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  #getNoArgs() {
    const handle = this.#handle;
    const int64 = this.db.int64;
    const columnNames = this.columnNames();
    const row = this.#rowObject;
    sqlite3_reset(handle);
    const status = sqlite3_step(handle);
    if (status === SQLITE3_ROW) {
      for (let i2 = 0; i2 < columnNames?.length; i2++) {
        row[columnNames[i2]] = getColumn(handle, i2, int64);
      }
      sqlite3_reset(handle);
      return row;
    } else if (status === SQLITE3_DONE) {
      return;
    } else {
      unwrap(status, this.db.unsafeHandle);
    }
  }
  /** Free up the statement object. */
  finalize() {
    if (!STATEMENTS_TO_DB.has(this.#handle)) return;
    this.#bindRefs.clear();
    statementFinalizer.unregister(this.#finalizerToken);
    STATEMENTS_TO_DB.delete(this.#handle);
    unwrap(sqlite3_finalize(this.#handle));
  }
  /** Coerces the statement to a string, which in this case is expanded SQL. */
  toString() {
    return readCstr(sqlite3_expanded_sql(this.#handle));
  }
  /** Iterate over resultant rows from query. */
  *iter(...params) {
    this.#begin();
    this.#bindAll(params);
    const getRowObject = this.getRowObject();
    let status = sqlite3_step(this.#handle);
    while (status === SQLITE3_ROW) {
      yield getRowObject(this.#handle);
      status = sqlite3_step(this.#handle);
    }
    if (status !== SQLITE3_DONE) {
      unwrap(status, this.db.unsafeHandle);
    }
    sqlite3_reset(this.#handle);
  }
  [_computedKey]() {
    return this.iter();
  }
  [_computedKey1]() {
    this.finalize();
  }
  [_computedKey2]() {
    return `Statement { ${this.expandedSql} }`;
  }
};

// deno:https://jsr.io/@db/sqlite/0.12.0/src/blob.ts
var _computedKey3;
var _computedKey12;
var { sqlite3_blob_open, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_read, sqlite3_blob_write } = ffi_default;
_computedKey3 = Symbol.iterator, _computedKey12 = Symbol.for("Deno.customInspect");
var SQLBlob = class {
  #handle;
  constructor(db2, options2) {
    options2 = Object.assign({
      readonly: true,
      db: "main"
    }, options2);
    const pHandle = new BigUint64Array(1);
    unwrap(sqlite3_blob_open(db2.unsafeHandle, toCString(options2.db ?? "main"), toCString(options2.table), toCString(options2.column), BigInt(options2.row), options2.readonly === false ? 1 : 0, pHandle));
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
  }
  /** Byte size of the Blob */
  get byteLength() {
    return sqlite3_blob_bytes(this.#handle);
  }
  /** Read from the Blob at given offset into a buffer (Uint8Array) */
  readSync(offset, p) {
    unwrap(sqlite3_blob_read(this.#handle, p, p.byteLength, offset));
  }
  /** Write a buffer (Uint8Array) at given offset in the Blob */
  writeSync(offset, p) {
    unwrap(sqlite3_blob_write(this.#handle, p, p.byteLength, offset));
  }
  /** Close the Blob. It **must** be called to prevent leaks. */
  close() {
    unwrap(sqlite3_blob_close(this.#handle));
  }
  /** Obtains Web Stream for reading the Blob */
  get readable() {
    const length2 = this.byteLength;
    let offset = 0;
    return new ReadableStream({
      type: "bytes",
      pull: (ctx) => {
        try {
          const byob = ctx.byobRequest;
          if (byob) {
            const toRead = Math.min(length2 - offset, byob.view.byteLength);
            this.readSync(offset, byob.view.subarray(0, toRead));
            offset += toRead;
            byob.respond(toRead);
          } else {
            const toRead = Math.min(length2 - offset, ctx.desiredSize || 1024 * 16);
            if (toRead === 0) {
              ctx.close();
              return;
            }
            const buffer = new Uint8Array(toRead);
            this.readSync(offset, buffer);
            offset += toRead;
            ctx.enqueue(buffer);
          }
        } catch (e2) {
          ctx.error(e2);
          ctx.byobRequest?.respond(0);
        }
      }
    });
  }
  /** Obtains Web Stream for writing to the Blob */
  get writable() {
    const length2 = this.byteLength;
    let offset = 0;
    return new WritableStream({
      write: (chunk, ctx) => {
        if (offset + chunk.byteLength > length2) {
          ctx.error(new Error("Write exceeds blob length"));
          return;
        }
        this.writeSync(offset, chunk);
        offset += chunk.byteLength;
      }
    });
  }
  *[_computedKey3]() {
    const length2 = this.byteLength;
    let offset = 0;
    while (offset < length2) {
      const toRead = Math.min(length2 - offset, 1024 * 16);
      const buffer = new Uint8Array(toRead);
      this.readSync(offset, buffer);
      offset += toRead;
      yield buffer;
    }
  }
  [_computedKey12]() {
    return `SQLite3.Blob(0x${this.byteLength.toString(16)})`;
  }
};

// deno:https://jsr.io/@db/sqlite/0.12.0/src/database.ts
var _computedKey4;
var { sqlite3_open_v2, sqlite3_close_v2, sqlite3_changes: sqlite3_changes2, sqlite3_total_changes, sqlite3_last_insert_rowid, sqlite3_get_autocommit, sqlite3_exec, sqlite3_free, sqlite3_libversion, sqlite3_sourceid, sqlite3_complete, sqlite3_finalize: sqlite3_finalize2, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_error, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double, sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type, sqlite3_create_function, sqlite3_result_int, sqlite3_aggregate_context, sqlite3_enable_load_extension, sqlite3_load_extension, sqlite3_backup_init, sqlite3_backup_step, sqlite3_backup_finish, sqlite3_errcode } = ffi_default;
var SQLITE_VERSION = readCstr(sqlite3_libversion());
var SQLITE_SOURCEID = readCstr(sqlite3_sourceid());
var BIG_MAX2 = BigInt(Number.MAX_SAFE_INTEGER);
_computedKey4 = Symbol.for("Deno.customInspect");
var Database = class {
  #path;
  #handle;
  #open = true;
  #enableLoadExtension = false;
  /** Whether to support BigInt columns. False by default, integers larger than 32 bit will be inaccurate. */
  int64;
  unsafeConcurrency;
  /** Whether DB connection is open */
  get open() {
    return this.#open;
  }
  /** Unsafe Raw (pointer) to the sqlite object */
  get unsafeHandle() {
    return this.#handle;
  }
  /** Path of the database file. */
  get path() {
    return this.#path;
  }
  /** Number of rows changed by the last executed statement. */
  get changes() {
    return sqlite3_changes2(this.#handle);
  }
  /** Number of rows changed since the database connection was opened. */
  get totalChanges() {
    return sqlite3_total_changes(this.#handle);
  }
  /** Gets last inserted Row ID */
  get lastInsertRowId() {
    return Number(sqlite3_last_insert_rowid(this.#handle));
  }
  /** Whether autocommit is enabled. Enabled by default, can be disabled using BEGIN statement. */
  get autocommit() {
    return sqlite3_get_autocommit(this.#handle) === 1;
  }
  /** Whether DB is in mid of a transaction */
  get inTransaction() {
    return this.#open && !this.autocommit;
  }
  get enableLoadExtension() {
    return this.#enableLoadExtension;
  }
  set enableLoadExtension(enabled2) {
    if (sqlite3_enable_load_extension === null) {
      throw new Error("Extension loading is not supported by the shared library that was used.");
    }
    const result = sqlite3_enable_load_extension(this.#handle, Number(enabled2));
    unwrap(result, this.#handle);
    this.#enableLoadExtension = enabled2;
  }
  constructor(path2, options2 = {}) {
    this.#path = path2 instanceof URL ? fromFileUrl3(path2) : path2;
    let flags = 0;
    this.int64 = options2.int64 ?? false;
    this.unsafeConcurrency = options2.unsafeConcurrency ?? false;
    if (options2.flags !== void 0) {
      flags = options2.flags;
    } else {
      if (options2.memory) {
        flags |= SQLITE3_OPEN_MEMORY;
      }
      if (options2.readonly ?? false) {
        flags |= SQLITE3_OPEN_READONLY;
      } else {
        flags |= SQLITE3_OPEN_READWRITE;
      }
      if ((options2.create ?? true) && !options2.readonly) {
        flags |= SQLITE3_OPEN_CREATE;
      }
    }
    const pHandle = new BigUint64Array(1);
    const result = sqlite3_open_v2(toCString(this.#path), pHandle, flags, null);
    this.#handle = Deno.UnsafePointer.create(pHandle[0]);
    if (result !== 0) sqlite3_close_v2(this.#handle);
    unwrap(result);
    if (options2.enableLoadExtension) {
      this.enableLoadExtension = options2.enableLoadExtension;
    }
  }
  /**
   * Creates a new Prepared Statement from the given SQL statement.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = ?");
   *
   * for (const row of stmt.all(1)) {
   *   console.log(row);
   * }
   * ```
   *
   * Bind parameters can be either provided as an array of values, or as an object
   * mapping the parameter name to the value.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = ?");
   * const row = stmt.get(1);
   *
   * // or
   *
   * const stmt = db.prepare("SELECT * FROM mytable WHERE id = :id");
   * const row = stmt.get({ id: 1 });
   * ```
   *
   * Statements are automatically freed once GC catches them, however
   * you can also manually free using `finalize` method.
   *
   * @param sql SQL statement string
   * @returns Statement object
   */
  prepare(sql) {
    return new Statement(this, sql);
  }
  /**
   * Open a Blob for incremental I/O.
   *
   * Make sure to close the blob after you are done with it,
   * otherwise you will have memory leaks.
   */
  openBlob(options2) {
    return new SQLBlob(this, options2);
  }
  /**
   * Simply executes the SQL statement (supports multiple statements separated by semicolon).
   * Returns the number of changes made by last statement.
   *
   * Example:
   * ```ts
   * // Create table
   * db.exec("create table users (id integer not null, username varchar(20) not null)");
   *
   * // Inserts
   * db.exec("insert into users (id, username) values(?, ?)", id, username);
   *
   * // Insert with named parameters
   * db.exec("insert into users (id, username) values(:id, :username)", { id, username });
   *
   * // Pragma statements
   * db.exec("pragma journal_mode = WAL");
   * db.exec("pragma synchronous = normal");
   * db.exec("pragma temp_store = memory");
   * ```
   *
   * Under the hood, it uses `sqlite3_exec` if no parameters are given to bind
   * with the SQL statement, a prepared statement otherwise.
   */
  exec(sql, ...params) {
    if (params.length === 0) {
      const pErr = new BigUint64Array(1);
      sqlite3_exec(this.#handle, toCString(sql), null, null, new Uint8Array(pErr.buffer));
      const errPtr = Deno.UnsafePointer.create(pErr[0]);
      if (errPtr !== null) {
        const err = readCstr(errPtr);
        sqlite3_free(errPtr);
        throw new Error(err);
      }
      return sqlite3_changes2(this.#handle);
    }
    const stmt = this.prepare(sql);
    stmt.run(...params);
    return sqlite3_changes2(this.#handle);
  }
  /** Alias for `exec`. */
  run(sql, ...params) {
    return this.exec(sql, ...params);
  }
  /** Safely execute SQL with parameters using a tagged template */
  sql(strings, ...parameters) {
    const sql = strings.join("?");
    const stmt = this.prepare(sql);
    return stmt.all(...parameters);
  }
  /**
   * Wraps a callback function in a transaction.
   *
   * - When function is called, the transaction is started.
   * - When function returns, the transaction is committed.
   * - When function throws an error, the transaction is rolled back.
   *
   * Example:
   * ```ts
   * const stmt = db.prepare("insert into users (id, username) values(?, ?)");
   *
   * interface User {
   *   id: number;
   *   username: string;
   * }
   *
   * const insertUsers = db.transaction((data: User[]) => {
   *   for (const user of data) {
   *     stmt.run(user);
   *   }
   * });
   *
   * insertUsers([
   *   { id: 1, username: "alice" },
   *   { id: 2, username: "bob" },
   * ]);
   *
   * // May also use `insertUsers.deferred`, `immediate`, or `exclusive`.
   * // They corresspond to using `BEGIN DEFERRED`, `BEGIN IMMEDIATE`, and `BEGIN EXCLUSIVE`.
   * // For eg.
   *
   * insertUsers.deferred([
   *   { id: 1, username: "alice" },
   *   { id: 2, username: "bob" },
   * ]);
   * ```
   */
  transaction(fn) {
    const controller = getController(this);
    const properties = {
      default: {
        value: wrapTransaction(fn, this, controller.default)
      },
      deferred: {
        value: wrapTransaction(fn, this, controller.deferred)
      },
      immediate: {
        value: wrapTransaction(fn, this, controller.immediate)
      },
      exclusive: {
        value: wrapTransaction(fn, this, controller.exclusive)
      },
      database: {
        value: this,
        enumerable: true
      }
    };
    Object.defineProperties(properties.default.value, properties);
    Object.defineProperties(properties.deferred.value, properties);
    Object.defineProperties(properties.immediate.value, properties);
    Object.defineProperties(properties.exclusive.value, properties);
    return properties.default.value;
  }
  #callbacks = /* @__PURE__ */ new Set();
  /**
   * Creates a new user-defined function.
   *
   * Example:
   * ```ts
   * db.function("add", (a: number, b: number) => a + b);
   * db.prepare("select add(1, 2)").value<[number]>()!; // [3]
   * ```
   */
  function(name, fn, options2) {
    if (sqlite3_create_function === null) {
      throw new Error("User-defined functions are not supported by the shared library that was used.");
    }
    const cb = new Deno.UnsafeCallback({
      parameters: [
        "pointer",
        "i32",
        "pointer"
      ],
      result: "void"
    }, (ctx, nArgs, pArgs) => {
      const argptr = new Deno.UnsafePointerView(pArgs);
      const args = [];
      for (let i2 = 0; i2 < nArgs; i2++) {
        const arg = Deno.UnsafePointer.create(argptr.getBigUint64(i2 * 8));
        const type = sqlite3_value_type(arg);
        switch (type) {
          case SQLITE_INTEGER: {
            const value = sqlite3_value_int64(arg);
            if (value < -BIG_MAX2 || value > BIG_MAX2) {
              args.push(value);
            } else {
              args.push(Number(value));
            }
            break;
          }
          case SQLITE_FLOAT:
            args.push(sqlite3_value_double(arg));
            break;
          case SQLITE_TEXT:
            args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
            break;
          case SQLITE_BLOB:
            args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
            break;
          case SQLITE_NULL:
            args.push(null);
            break;
          default:
            throw new Error(`Unknown type: ${type}`);
        }
      }
      let result;
      try {
        result = fn(...args);
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      if (result === void 0 || result === null) {
        sqlite3_result_null(ctx);
      } else if (typeof result === "boolean") {
        sqlite3_result_int(ctx, result ? 1 : 0);
      } else if (typeof result === "number") {
        if (Number.isSafeInteger(result)) {
          sqlite3_result_int64(ctx, BigInt(result));
        } else sqlite3_result_double(ctx, result);
      } else if (typeof result === "bigint") {
        sqlite3_result_int64(ctx, result);
      } else if (typeof result === "string") {
        const buffer = new TextEncoder().encode(result);
        sqlite3_result_text(ctx, buffer, buffer.byteLength, 0n);
      } else if (result instanceof Uint8Array) {
        sqlite3_result_blob(ctx, result, result.length, -1n);
      } else {
        const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
        sqlite3_result_error(ctx, buffer, buffer.byteLength);
      }
    });
    let flags = 1;
    if (options2?.deterministic) {
      flags |= 2048;
    }
    if (options2?.directOnly) {
      flags |= 524288;
    }
    if (options2?.subtype) {
      flags |= 1048576;
    }
    if (options2?.directOnly) {
      flags |= 2097152;
    }
    const err = sqlite3_create_function(this.#handle, toCString(name), options2?.varargs ? -1 : fn.length, flags, null, cb.pointer, null, null);
    unwrap(err, this.#handle);
    this.#callbacks.add(cb);
  }
  /**
   * Creates a new user-defined aggregate function.
   */
  aggregate(name, options2) {
    if (sqlite3_aggregate_context === null || sqlite3_create_function === null) {
      throw new Error("User-defined functions are not supported by the shared library that was used.");
    }
    const contexts = /* @__PURE__ */ new Map();
    const cb = new Deno.UnsafeCallback({
      parameters: [
        "pointer",
        "i32",
        "pointer"
      ],
      result: "void"
    }, (ctx, nArgs, pArgs) => {
      const aggrCtx = sqlite3_aggregate_context(ctx, 8);
      const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
      let aggregate;
      if (contexts.has(aggrPtr)) {
        aggregate = contexts.get(aggrPtr);
      } else {
        aggregate = typeof options2.start === "function" ? options2.start() : options2.start;
        contexts.set(aggrPtr, aggregate);
      }
      const argptr = new Deno.UnsafePointerView(pArgs);
      const args = [];
      for (let i2 = 0; i2 < nArgs; i2++) {
        const arg = Deno.UnsafePointer.create(argptr.getBigUint64(i2 * 8));
        const type = sqlite3_value_type(arg);
        switch (type) {
          case SQLITE_INTEGER: {
            const value = sqlite3_value_int64(arg);
            if (value < -BIG_MAX2 || value > BIG_MAX2) {
              args.push(value);
            } else {
              args.push(Number(value));
            }
            break;
          }
          case SQLITE_FLOAT:
            args.push(sqlite3_value_double(arg));
            break;
          case SQLITE_TEXT:
            args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
            break;
          case SQLITE_BLOB:
            args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
            break;
          case SQLITE_NULL:
            args.push(null);
            break;
          default:
            throw new Error(`Unknown type: ${type}`);
        }
      }
      let result;
      try {
        result = options2.step(aggregate, ...args);
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      contexts.set(aggrPtr, result);
    });
    const cbFinal = new Deno.UnsafeCallback({
      parameters: [
        "pointer"
      ],
      result: "void"
    }, (ctx) => {
      const aggrCtx = sqlite3_aggregate_context(ctx, 0);
      const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
      const aggregate = contexts.get(aggrPtr);
      contexts.delete(aggrPtr);
      let result;
      try {
        result = options2.final ? options2.final(aggregate) : aggregate;
      } catch (err2) {
        const buf2 = new TextEncoder().encode(err2.message);
        sqlite3_result_error(ctx, buf2, buf2.byteLength);
        return;
      }
      if (result === void 0 || result === null) {
        sqlite3_result_null(ctx);
      } else if (typeof result === "boolean") {
        sqlite3_result_int(ctx, result ? 1 : 0);
      } else if (typeof result === "number") {
        if (Number.isSafeInteger(result)) {
          sqlite3_result_int64(ctx, BigInt(result));
        } else sqlite3_result_double(ctx, result);
      } else if (typeof result === "bigint") {
        sqlite3_result_int64(ctx, result);
      } else if (typeof result === "string") {
        const buffer = new TextEncoder().encode(result);
        sqlite3_result_text(ctx, buffer, buffer.byteLength, 0n);
      } else if (result instanceof Uint8Array) {
        sqlite3_result_blob(ctx, result, result.length, -1n);
      } else {
        const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
        sqlite3_result_error(ctx, buffer, buffer.byteLength);
      }
    });
    let flags = 1;
    if (options2?.deterministic) {
      flags |= 2048;
    }
    if (options2?.directOnly) {
      flags |= 524288;
    }
    if (options2?.subtype) {
      flags |= 1048576;
    }
    if (options2?.directOnly) {
      flags |= 2097152;
    }
    const err = sqlite3_create_function(this.#handle, toCString(name), options2?.varargs ? -1 : options2.step.length - 1, flags, null, null, cb.pointer, cbFinal.pointer);
    unwrap(err, this.#handle);
    this.#callbacks.add(cb);
    this.#callbacks.add(cbFinal);
  }
  /**
   * Loads an SQLite extension library from the named file.
   */
  loadExtension(file, entryPoint) {
    if (sqlite3_load_extension === null) {
      throw new Error("Extension loading is not supported by the shared library that was used.");
    }
    if (!this.enableLoadExtension) {
      throw new Error("Extension loading is not enabled");
    }
    const pzErrMsg = new BigUint64Array(1);
    const result = sqlite3_load_extension(this.#handle, toCString(file), entryPoint ? toCString(entryPoint) : null, pzErrMsg);
    const pzErrPtr = Deno.UnsafePointer.create(pzErrMsg[0]);
    if (pzErrPtr !== null) {
      const pzErr = readCstr(pzErrPtr);
      sqlite3_free(pzErrPtr);
      throw new Error(pzErr);
    }
    unwrap(result, this.#handle);
  }
  /**
   * Closes the database connection.
   *
   * Calling this method more than once is no-op.
   */
  close() {
    if (!this.#open) return;
    for (const [stmt, db2] of STATEMENTS_TO_DB) {
      if (db2 === this.#handle) {
        sqlite3_finalize2(stmt);
        STATEMENTS_TO_DB.delete(stmt);
      }
    }
    for (const cb of this.#callbacks) {
      cb.close();
    }
    unwrap(sqlite3_close_v2(this.#handle));
    this.#open = false;
  }
  /**
   * @param dest The destination database connection.
   * @param name Destination database name. "main" for main database, "temp" for temporary database, or the name specified after the AS keyword in an ATTACH statement for an attached database.
   * @param pages The number of pages to copy. If it is negative, all remaining pages are copied (default).
   */
  backup(dest, name = "main", pages = -1) {
    const backup = sqlite3_backup_init(dest.#handle, toCString(name), this.#handle, toCString("main"));
    if (backup) {
      unwrap(sqlite3_backup_step(backup, pages));
      unwrap(sqlite3_backup_finish(backup));
    } else {
      unwrap(sqlite3_errcode(dest.#handle), dest.#handle);
    }
  }
  [_computedKey4]() {
    return `SQLite3.Database { path: ${this.path} }`;
  }
};
var controllers = /* @__PURE__ */ new WeakMap();
var getController = (db2) => {
  let controller = controllers.get(db2);
  if (!controller) {
    const shared = {
      commit: db2.prepare("COMMIT"),
      rollback: db2.prepare("ROLLBACK"),
      savepoint: db2.prepare("SAVEPOINT `	_bs3.	`"),
      release: db2.prepare("RELEASE `	_bs3.	`"),
      rollbackTo: db2.prepare("ROLLBACK TO `	_bs3.	`")
    };
    controllers.set(db2, controller = {
      default: Object.assign({
        begin: db2.prepare("BEGIN")
      }, shared),
      deferred: Object.assign({
        begin: db2.prepare("BEGIN DEFERRED")
      }, shared),
      immediate: Object.assign({
        begin: db2.prepare("BEGIN IMMEDIATE")
      }, shared),
      exclusive: Object.assign({
        begin: db2.prepare("BEGIN EXCLUSIVE")
      }, shared)
    });
  }
  return controller;
};
var wrapTransaction = (fn, db2, { begin, commit, rollback, savepoint, release, rollbackTo }) => function sqliteTransaction(...args) {
  const { apply } = Function.prototype;
  let before, after, undo;
  if (db2.inTransaction) {
    before = savepoint;
    after = release;
    undo = rollbackTo;
  } else {
    before = begin;
    after = commit;
    undo = rollback;
  }
  before.run();
  try {
    const result = apply.call(fn, this, args);
    after.run();
    return result;
  } catch (ex) {
    if (!db2.autocommit) {
      undo.run();
      if (undo !== rollback) after.run();
    }
    throw ex;
  }
};

// build/serve/ownerSizeTotalWorker.js-tmp
import { mkdir as mkdir2 } from "node:fs/promises";
import { basename as basename22, dirname as dirname22, join as join22, resolve as resolve22 } from "node:path";
import { resolve as resolve32 } from "node:path";
import { readFile as readFile2 } from "node:fs/promises";
import process4 from "node:process";
import fs from "node:fs";
import { readFile as readFile3, readdir as readdir2 } from "node:fs/promises";
import path from "node:path";
import process5 from "node:process";
import { Readable } from "node:stream";
import { Buffer as Buffer6 } from "node:buffer";
import { Buffer as Buffer4 } from "node:buffer";
import { Buffer as Buffer3 } from "node:buffer";
import { Buffer as Buffer7 } from "node:buffer";
import process2 from "node:process";
import { Buffer as Buffer9 } from "node:buffer";
import { randomBytes as randomBytes2, timingSafeEqual } from "node:crypto";
import { Buffer as Buffer8 } from "node:buffer";
import { parentPort } from "node:worker_threads";
import process6 from "node:process";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x2) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
}) : x2)(function(x2) {
  if (typeof __require !== "undefined") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __glob = (map) => (path2) => {
  var fn = map[path2];
  if (fn) return fn();
  throw new Error("Module not found in bundle: " + path2);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require22() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
function sbp(selector, ...data) {
  const domain = domainFromSelector(selector);
  const starSelector = `${domain}/*`;
  const selExists = !!selectors[selector];
  let sel = selector;
  if (!selExists) {
    if (selectors[starSelector]) {
      sel = starSelector;
    } else {
      throw new Error(`SBP: selector not registered: ${selector}`);
    }
  }
  for (const filters of [selectorFilters[selector], domainFilters[domain], globalFilters]) {
    if (filters) {
      for (const filter of filters) {
        if (filter(domain, selector, data) === false)
          return;
      }
    }
  }
  if (!selExists) {
    data.unshift(selector);
  }
  return selectors[sel].apply(domains[domain].state, data);
}
function domainFromSelector(selector) {
  const domainLookup = DOMAIN_REGEX.exec(selector);
  if (domainLookup === null) {
    throw new Error(`SBP: selector missing domain: ${selector}`);
  }
  return domainLookup[0];
}
var selectors;
var domains;
var globalFilters;
var domainFilters;
var selectorFilters;
var unsafeSelectors;
var DOMAIN_REGEX;
var SBP_BASE_SELECTORS;
var esm_default;
var init_esm = __esm({
  "node_modules/.deno/@sbp+sbp@2.4.1/node_modules/@sbp/sbp/dist/esm/index.js"() {
    selectors = /* @__PURE__ */ Object.create(null);
    domains = /* @__PURE__ */ Object.create(null);
    globalFilters = [];
    domainFilters = /* @__PURE__ */ Object.create(null);
    selectorFilters = /* @__PURE__ */ Object.create(null);
    unsafeSelectors = /* @__PURE__ */ Object.create(null);
    DOMAIN_REGEX = /^[^/]+/;
    SBP_BASE_SELECTORS = {
      "sbp/selectors/register": (sels) => {
        const registered = [];
        for (const selector in sels) {
          const domainName = domainFromSelector(selector);
          const domain = domainName in domains ? domains[domainName] : domains[domainName] = { state: /* @__PURE__ */ Object.create(null), locked: false };
          if (domain.locked) {
            (console.warn || console.log)(`[SBP WARN]: not registering selector on locked domain: '${selector}'`);
          } else if (selectors[selector]) {
            (console.warn || console.log)(`[SBP WARN]: not registering already registered selector: '${selector}'`);
          } else if (typeof sels[selector] === "function") {
            if (unsafeSelectors[selector]) {
              (console.warn || console.log)(`[SBP WARN]: registering unsafe selector: '${selector}' (remember to lock after overwriting)`);
            }
            const fn = selectors[selector] = sels[selector];
            registered.push(selector);
            if (selector === `${domainName}/_init`) {
              fn.call(domain.state);
            }
          }
        }
        return registered;
      },
      "sbp/selectors/unregister": (sels) => {
        var _a2;
        for (const selector of sels) {
          if (!unsafeSelectors[selector]) {
            throw new Error(`SBP: can't unregister locked selector: ${selector}`);
          }
          if ((_a2 = domains[domainFromSelector(selector)]) === null || _a2 === void 0 ? void 0 : _a2.locked) {
            throw new Error(`SBP: can't unregister selector on a locked domain: '${selector}'`);
          }
          delete selectors[selector];
        }
      },
      "sbp/selectors/overwrite": (sels) => {
        sbp("sbp/selectors/unregister", Object.keys(sels));
        return sbp("sbp/selectors/register", sels);
      },
      "sbp/selectors/unsafe": (sels) => {
        for (const selector of sels) {
          if (selectors[selector]) {
            throw new Error("unsafe must be called before registering selector");
          }
          unsafeSelectors[selector] = true;
        }
      },
      "sbp/selectors/lock": (sels) => {
        for (const selector of sels) {
          delete unsafeSelectors[selector];
        }
      },
      "sbp/selectors/fn": (sel) => {
        return selectors[sel];
      },
      "sbp/filters/global/add": (filter) => {
        globalFilters.push(filter);
      },
      "sbp/filters/domain/add": (domain, filter) => {
        if (!domainFilters[domain])
          domainFilters[domain] = [];
        domainFilters[domain].push(filter);
      },
      "sbp/filters/selector/add": (selector, filter) => {
        if (!selectorFilters[selector])
          selectorFilters[selector] = [];
        selectorFilters[selector].push(filter);
      },
      "sbp/domains/lock": (domainNames) => {
        if (!domainNames) {
          for (const name in domains) {
            domains[name].locked = true;
          }
        } else {
          for (const name of domainNames) {
            if (!domains[name]) {
              throw new Error(`SBP: cannot lock non-existent domain: ${name}`);
            }
            domains[name].locked = true;
          }
        }
      }
    };
    SBP_BASE_SELECTORS["sbp/selectors/register"](SBP_BASE_SELECTORS);
    esm_default = sbp;
  }
});
var isEventQueueSbpEvent;
var esm_default2;
var init_esm2 = __esm({
  "node_modules/.deno/@sbp+okturtles.eventqueue@1.2.1/node_modules/@sbp/okturtles.eventqueue/dist/esm/index.mjs"() {
    init_esm();
    isEventQueueSbpEvent = (e2) => {
      return Object.prototype.hasOwnProperty.call(e2, "sbpInvocation");
    };
    esm_default2 = esm_default("sbp/selectors/register", {
      "okTurtles.eventQueue/_init": function() {
        this.eventQueues = /* @__PURE__ */ Object.create(null);
      },
      "okTurtles.eventQueue/isWaiting": function(name) {
        var _a2;
        return !!((_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.length);
      },
      "okTurtles.eventQueue/queuedInvocations": function(name) {
        var _a2, _b;
        if (name == null) {
          return Object.fromEntries(Object.entries(this.eventQueues).map(([name2, events]) => [name2, events.map((event) => {
            if (isEventQueueSbpEvent(event)) {
              return event.sbpInvocation;
            } else {
              return event.fn;
            }
          })]));
        }
        return (_b = (_a2 = this.eventQueues[name]) === null || _a2 === void 0 ? void 0 : _a2.map((event) => {
          if (isEventQueueSbpEvent(event)) {
            return event.sbpInvocation;
          } else {
            return event.fn;
          }
        })) !== null && _b !== void 0 ? _b : [];
      },
      "okTurtles.eventQueue/queueEvent": async function(name, invocation) {
        if (!Object.prototype.hasOwnProperty.call(this.eventQueues, name)) {
          this.eventQueues[name] = [];
        }
        const events = this.eventQueues[name];
        let accept;
        const promise = new Promise((resolve42) => {
          accept = resolve42;
        });
        const thisEvent = typeof invocation === "function" ? {
          fn: invocation,
          promise
        } : {
          sbpInvocation: invocation,
          promise
        };
        events.push(thisEvent);
        while (events.length > 0) {
          const event = events[0];
          if (event === thisEvent) {
            try {
              if (typeof invocation === "function") {
                return await invocation();
              } else {
                return await esm_default(...invocation);
              }
            } finally {
              accept();
              events.shift();
            }
          } else {
            await event.promise;
          }
        }
      }
    });
  }
});
var _store;
var esm_default3;
var init_esm3 = __esm({
  "node_modules/.deno/@sbp+okturtles.data@0.1.6/node_modules/@sbp/okturtles.data/dist/esm/index.mjs"() {
    init_esm();
    _store = /* @__PURE__ */ new Map();
    esm_default3 = esm_default("sbp/selectors/register", {
      "okTurtles.data/get": function(key) {
        return _store.get(key);
      },
      "okTurtles.data/set": function(key, data) {
        _store.set(key, data);
        return data;
      },
      "okTurtles.data/delete": function(key) {
        return _store.delete(key);
      },
      "okTurtles.data/add": function(key, data) {
        const array = _store.get(key);
        if (array) {
          array.push(data);
        } else {
          _store.set(key, [data]);
        }
      },
      "okTurtles.data/remove": function(key, data) {
        const array = _store.get(key);
        if (array) {
          const aLen = array.length;
          const filtered = array.filter((v2) => v2 !== data);
          _store.set(key, filtered);
          return aLen - filtered.length;
        }
      },
      "okTurtles.data/apply": function(key, fn) {
        return fn(_store.get(key));
      }
    });
  }
});
function pick(o2, props) {
  const x2 = /* @__PURE__ */ Object.create(null);
  for (const k of props) {
    if (has(o2, k)) {
      x2[k] = o2[k];
    }
  }
  return x2;
}
function omit(o2, props) {
  const x2 = /* @__PURE__ */ Object.create(null);
  for (const k in o2) {
    if (!props.includes(k)) {
      x2[k] = o2[k];
    }
  }
  return x2;
}
function cloneDeep(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function isMergeableObject(val) {
  const nonNullObject = val && typeof val === "object";
  return nonNullObject && Object.prototype.toString.call(val) !== "[object RegExp]" && Object.prototype.toString.call(val) !== "[object Date]";
}
function merge(obj, src2) {
  const res = obj;
  for (const key in src2) {
    const clone = isMergeableObject(src2[key]) ? cloneDeep(src2[key]) : void 0;
    let x2;
    if (clone && has(obj, key) && isMergeableObject(x2 = res[key])) {
      merge(x2, clone);
      continue;
    }
    Object.defineProperty(res, key, {
      configurable: true,
      enumerable: true,
      value: clone || src2[key],
      writable: true
    });
  }
  return res;
}
function delay(msec) {
  return new Promise((resolve42) => {
    setTimeout(resolve42, msec);
  });
}
function randomBytes(length2) {
  return crypto.getRandomValues(new Uint8Array(length2));
}
function randomHexString(length2) {
  return Array.from(randomBytes(length2), (byte) => (byte % 16).toString(16)).join("");
}
function randomIntFromRange(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function uniq(array) {
  return Array.from(new Set(array));
}
function intersection(a1, ...arrays) {
  return uniq(a1).filter((v1) => arrays.every((v2) => v2.indexOf(v1) >= 0));
}
function difference(a1, ...arrays) {
  const a2 = Array.prototype.concat.apply([], arrays);
  return a1.filter((v2) => a2.indexOf(v2) === -1);
}
function debounce(func, wait, immediate) {
  let timeout, args, context, timestamp, result;
  if (wait == null)
    wait = 100;
  function later() {
    const last = performance.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = void 0;
      if (!immediate) {
        result = func.apply(context, args);
        args = void 0;
        context = void 0;
      }
    }
  }
  const debounced = function(...args_) {
    args = args_;
    context = this;
    timestamp = performance.now();
    const callNow = immediate && !timeout;
    if (!timeout)
      timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      args = void 0;
      context = void 0;
    }
    return result;
  };
  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      args = void 0;
      context = void 0;
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debounced;
}
var has;
var init_esm4 = __esm({
  "node_modules/.deno/turtledash@1.0.3/node_modules/turtledash/dist/esm/index.js"() {
    has = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  }
});
function equals(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
    return o2;
  }
  if (o2 instanceof ArrayBuffer) {
    return new Uint8Array(o2);
  }
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
var empty;
var init_bytes = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bytes.mjs"() {
    empty = new Uint8Array(0);
  }
});
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode5(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode3,
    decodeUnsafe,
    decode: decode5
  };
}
var src;
var _brrp__multiformats_scope_baseX;
var base_x_default;
var init_base_x = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/base-x.mjs"() {
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});
function or(left, right) {
  var _a2, _b;
  return new ComposedDecoder(Object.assign(Object.assign({}, (_a2 = left.decoders) !== null && _a2 !== void 0 ? _a2 : { [left.prefix]: left }), (_b = right.decoders) !== null && _b !== void 0 ? _b : { [right.prefix]: right }));
}
function from({ name, prefix, encode: encode3, decode: decode5 }) {
  return new Codec(name, prefix, encode3, decode5);
}
function baseX({ name, prefix, alphabet: alphabet3 }) {
  const { encode: encode3, decode: decode5 } = base_x_default(alphabet3, name);
  return from({
    prefix,
    name,
    encode: encode3,
    decode: (text) => coerce(decode5(text))
  });
}
function decode2(string, alphabet3, bitsPerChar, name) {
  const codes = {};
  for (let i2 = 0; i2 < alphabet3.length; ++i2) {
    codes[alphabet3[i2]] = i2;
  }
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode2(data, alphabet3, bitsPerChar) {
  const pad = alphabet3[alphabet3.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet3[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet3[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc4648({ name, prefix, bitsPerChar, alphabet: alphabet3 }) {
  return from({
    prefix,
    name,
    encode(input) {
      return encode2(input, alphabet3, bitsPerChar);
    },
    decode(input) {
      return decode2(input, alphabet3, bitsPerChar, name);
    }
  });
}
var Encoder;
var Decoder;
var ComposedDecoder;
var Codec;
var init_base = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base.mjs"() {
    init_bytes();
    init_base_x();
    Encoder = class {
      constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    Codec = class {
      constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
  }
});
var base58btc;
var base58flickr;
var init_base58 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base58.mjs"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});
var require_util = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder3 = new TextEncoder();
        ret = encoder3.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex(bytes) {
      return Array.prototype.map.call(bytes, function(n) {
        return (n < 16 ? "0" : "") + n.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i2 = 0; i2 < arr.length; i2 += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i2]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i2]).toUpperCase();
        } else throw new Error("Invalid size " + size);
        if (i2 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i2 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N10, M2) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N10);
      for (let i2 = 0; i2 < N10; i2++) {
        input[i2] = i2 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i2 = 0; i2 < M2; i2++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N10 / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex,
      debugPrint,
      testSpeed
    };
  }
});
var require_blake2b = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v3, a, b) {
      const o0 = v3[a] + v3[b];
      let o1 = v3[a + 1] + v3[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v3[a] = o0;
      v3[a + 1] = o1;
    }
    function ADD64AC(v3, a, b0, b1) {
      let o0 = v3[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v3[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v3[a] = o0;
      v3[a + 1] = o1;
    }
    function B2B_GET32(arr, i2) {
      return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
    }
    function B2B_G(a, b, c, d, ix, iy) {
      const x0 = m3[ix];
      const x1 = m3[ix + 1];
      const y0 = m3[iy];
      const y1 = m3[iy + 1];
      ADD64AA(v2, a, b);
      ADD64AC(v2, a, x0, x1);
      let xor0 = v2[d] ^ v2[a];
      let xor1 = v2[d + 1] ^ v2[a + 1];
      v2[d] = xor1;
      v2[d + 1] = xor0;
      ADD64AA(v2, c, d);
      xor0 = v2[b] ^ v2[c];
      xor1 = v2[b + 1] ^ v2[c + 1];
      v2[b] = xor0 >>> 24 ^ xor1 << 8;
      v2[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v2, a, b);
      ADD64AC(v2, a, y0, y1);
      xor0 = v2[d] ^ v2[a];
      xor1 = v2[d + 1] ^ v2[a + 1];
      v2[d] = xor0 >>> 16 ^ xor1 << 16;
      v2[d + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v2, c, d);
      xor0 = v2[b] ^ v2[c];
      xor1 = v2[b + 1] ^ v2[c + 1];
      v2[b] = xor1 >>> 31 ^ xor0 << 1;
      v2[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x2) {
        return x2 * 2;
      })
    );
    var v2 = new Uint32Array(32);
    var m3 = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 16; i2++) {
        v2[i2] = ctx.h[i2];
        v2[i2 + 16] = BLAKE2B_IV32[i2];
      }
      v2[24] = v2[24] ^ ctx.t;
      v2[25] = v2[25] ^ ctx.t / 4294967296;
      if (last) {
        v2[28] = ~v2[28];
        v2[29] = ~v2[29];
      }
      for (i2 = 0; i2 < 32; i2++) {
        m3[i2] = B2B_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 12; i2++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
      }
      for (i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = ctx.h[i2] ^ v2[i2] ^ v2[i2 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit2(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameterBlock, i2 * 4);
      }
      if (key) {
        blake2bUpdate2(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate2(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2bFinal2(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
      }
      return out;
    }
    function blake2b3(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit2(outlen, key, salt, personal);
      blake2bUpdate2(ctx, input);
      return blake2bFinal2(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b3(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module.exports = {
      blake2b: blake2b3,
      blake2bHex,
      blake2bInit: blake2bInit2,
      blake2bUpdate: blake2bUpdate2,
      blake2bFinal: blake2bFinal2
    };
  }
});
var require_blake2s = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v3, i2) {
      return v3[i2] ^ v3[i2 + 1] << 8 ^ v3[i2 + 2] << 16 ^ v3[i2 + 3] << 24;
    }
    function B2S_G(a, b, c, d, x2, y) {
      v2[a] = v2[a] + v2[b] + x2;
      v2[d] = ROTR32(v2[d] ^ v2[a], 16);
      v2[c] = v2[c] + v2[d];
      v2[b] = ROTR32(v2[b] ^ v2[c], 12);
      v2[a] = v2[a] + v2[b] + y;
      v2[d] = ROTR32(v2[d] ^ v2[a], 8);
      v2[c] = v2[c] + v2[d];
      v2[b] = ROTR32(v2[b] ^ v2[c], 7);
    }
    function ROTR32(x2, y) {
      return x2 >>> y ^ x2 << 32 - y;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v2 = new Uint32Array(16);
    var m3 = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 8; i2++) {
        v2[i2] = ctx.h[i2];
        v2[i2 + 8] = BLAKE2S_IV[i2];
      }
      v2[12] ^= ctx.t;
      v2[13] ^= ctx.t / 4294967296;
      if (last) {
        v2[14] = ~v2[14];
      }
      for (i2 = 0; i2 < 16; i2++) {
        m3[i2] = B2S_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 10; i2++) {
        B2S_G(0, 4, 8, 12, m3[SIGMA[i2 * 16 + 0]], m3[SIGMA[i2 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m3[SIGMA[i2 * 16 + 2]], m3[SIGMA[i2 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m3[SIGMA[i2 * 16 + 4]], m3[SIGMA[i2 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m3[SIGMA[i2 * 16 + 6]], m3[SIGMA[i2 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m3[SIGMA[i2 * 16 + 8]], m3[SIGMA[i2 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m3[SIGMA[i2 * 16 + 10]], m3[SIGMA[i2 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m3[SIGMA[i2 * 16 + 12]], m3[SIGMA[i2 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m3[SIGMA[i2 * 16 + 14]], m3[SIGMA[i2 * 16 + 15]]);
      }
      for (i2 = 0; i2 < 8; i2++) {
        ctx.h[i2] ^= v2[i2] ^ v2[i2 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s(input, key, outlen);
      return util.toHex(output);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});
var require_blakejs = __commonJS({
  "node_modules/.deno/blakejs@1.2.1/node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});
function encode22(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode22.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1;
var MSB;
var REST;
var MSBALL;
var INT;
var decode22;
var MSB$1;
var REST$1;
var N1;
var N2;
var N3;
var N4;
var N5;
var N6;
var N7;
var N8;
var N9;
var length;
var varint;
var _brrp_varint;
var varint_default;
var init_varint = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/vendor/varint.mjs"() {
    encode_1 = encode22;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode22 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode22,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});
function decode3(data, offset = 0) {
  const code2 = varint_default.decode(data, offset);
  return [code2, varint_default.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
function encodingLength(int) {
  return varint_default.encodingLength(int);
}
var init_varint2 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/varint.mjs"() {
    init_varint();
  }
});
function create(code2, digest) {
  const size = digest.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code2, size, digest, bytes);
}
function decode4(multihash) {
  const bytes = coerce(multihash);
  const [code2, sizeOffset] = decode3(bytes);
  const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size, digest, bytes);
}
function equals2(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
  }
}
var Digest;
var init_digest = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/hashes/digest.mjs"() {
    init_bytes();
    init_varint2();
    Digest = class {
      /**
       * Creates a multihash digest.
       */
      constructor(code2, size, digest, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
      }
    };
  }
});
function from2({ name, code: code2, encode: encode3 }) {
  return new Hasher(name, code2, encode3);
}
var Hasher;
var init_hasher = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/hasher.mjs"() {
    init_digest();
    Hasher = class {
      constructor(name, code2, encode3) {
        this.name = name;
        this.code = code2;
        this.encode = encode3;
      }
      digest(input) {
        if (input instanceof Uint8Array || input instanceof ReadableStream) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest) => create(this.code, digest));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});
var import_blakejs;
var blake2b;
var blake2b8;
var blake2b16;
var blake2b24;
var blake2b32;
var blake2b40;
var blake2b48;
var blake2b56;
var blake2b64;
var blake2b72;
var blake2b80;
var blake2b88;
var blake2b96;
var blake2b104;
var blake2b112;
var blake2b120;
var blake2b128;
var blake2b136;
var blake2b144;
var blake2b152;
var blake2b160;
var blake2b168;
var blake2b176;
var blake2b184;
var blake2b192;
var blake2b200;
var blake2b208;
var blake2b216;
var blake2b224;
var blake2b232;
var blake2b240;
var blake2b248;
var blake2b256;
var blake2b264;
var blake2b272;
var blake2b280;
var blake2b288;
var blake2b296;
var blake2b304;
var blake2b312;
var blake2b320;
var blake2b328;
var blake2b336;
var blake2b344;
var blake2b352;
var blake2b360;
var blake2b368;
var blake2b376;
var blake2b384;
var blake2b392;
var blake2b400;
var blake2b408;
var blake2b416;
var blake2b424;
var blake2b432;
var blake2b440;
var blake2b448;
var blake2b456;
var blake2b464;
var blake2b472;
var blake2b480;
var blake2b488;
var blake2b496;
var blake2b504;
var blake2b512;
var init_blake2b = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/blake2b.mjs"() {
    import_blakejs = __toESM(require_blakejs(), 1);
    init_bytes();
    init_hasher();
    ({ blake2b } = import_blakejs.default);
    blake2b8 = from2({
      name: "blake2b-8",
      code: 45569,
      encode: (input) => coerce(blake2b(input, void 0, 1))
    });
    blake2b16 = from2({
      name: "blake2b-16",
      code: 45570,
      encode: (input) => coerce(blake2b(input, void 0, 2))
    });
    blake2b24 = from2({
      name: "blake2b-24",
      code: 45571,
      encode: (input) => coerce(blake2b(input, void 0, 3))
    });
    blake2b32 = from2({
      name: "blake2b-32",
      code: 45572,
      encode: (input) => coerce(blake2b(input, void 0, 4))
    });
    blake2b40 = from2({
      name: "blake2b-40",
      code: 45573,
      encode: (input) => coerce(blake2b(input, void 0, 5))
    });
    blake2b48 = from2({
      name: "blake2b-48",
      code: 45574,
      encode: (input) => coerce(blake2b(input, void 0, 6))
    });
    blake2b56 = from2({
      name: "blake2b-56",
      code: 45575,
      encode: (input) => coerce(blake2b(input, void 0, 7))
    });
    blake2b64 = from2({
      name: "blake2b-64",
      code: 45576,
      encode: (input) => coerce(blake2b(input, void 0, 8))
    });
    blake2b72 = from2({
      name: "blake2b-72",
      code: 45577,
      encode: (input) => coerce(blake2b(input, void 0, 9))
    });
    blake2b80 = from2({
      name: "blake2b-80",
      code: 45578,
      encode: (input) => coerce(blake2b(input, void 0, 10))
    });
    blake2b88 = from2({
      name: "blake2b-88",
      code: 45579,
      encode: (input) => coerce(blake2b(input, void 0, 11))
    });
    blake2b96 = from2({
      name: "blake2b-96",
      code: 45580,
      encode: (input) => coerce(blake2b(input, void 0, 12))
    });
    blake2b104 = from2({
      name: "blake2b-104",
      code: 45581,
      encode: (input) => coerce(blake2b(input, void 0, 13))
    });
    blake2b112 = from2({
      name: "blake2b-112",
      code: 45582,
      encode: (input) => coerce(blake2b(input, void 0, 14))
    });
    blake2b120 = from2({
      name: "blake2b-120",
      code: 45583,
      encode: (input) => coerce(blake2b(input, void 0, 15))
    });
    blake2b128 = from2({
      name: "blake2b-128",
      code: 45584,
      encode: (input) => coerce(blake2b(input, void 0, 16))
    });
    blake2b136 = from2({
      name: "blake2b-136",
      code: 45585,
      encode: (input) => coerce(blake2b(input, void 0, 17))
    });
    blake2b144 = from2({
      name: "blake2b-144",
      code: 45586,
      encode: (input) => coerce(blake2b(input, void 0, 18))
    });
    blake2b152 = from2({
      name: "blake2b-152",
      code: 45587,
      encode: (input) => coerce(blake2b(input, void 0, 19))
    });
    blake2b160 = from2({
      name: "blake2b-160",
      code: 45588,
      encode: (input) => coerce(blake2b(input, void 0, 20))
    });
    blake2b168 = from2({
      name: "blake2b-168",
      code: 45589,
      encode: (input) => coerce(blake2b(input, void 0, 21))
    });
    blake2b176 = from2({
      name: "blake2b-176",
      code: 45590,
      encode: (input) => coerce(blake2b(input, void 0, 22))
    });
    blake2b184 = from2({
      name: "blake2b-184",
      code: 45591,
      encode: (input) => coerce(blake2b(input, void 0, 23))
    });
    blake2b192 = from2({
      name: "blake2b-192",
      code: 45592,
      encode: (input) => coerce(blake2b(input, void 0, 24))
    });
    blake2b200 = from2({
      name: "blake2b-200",
      code: 45593,
      encode: (input) => coerce(blake2b(input, void 0, 25))
    });
    blake2b208 = from2({
      name: "blake2b-208",
      code: 45594,
      encode: (input) => coerce(blake2b(input, void 0, 26))
    });
    blake2b216 = from2({
      name: "blake2b-216",
      code: 45595,
      encode: (input) => coerce(blake2b(input, void 0, 27))
    });
    blake2b224 = from2({
      name: "blake2b-224",
      code: 45596,
      encode: (input) => coerce(blake2b(input, void 0, 28))
    });
    blake2b232 = from2({
      name: "blake2b-232",
      code: 45597,
      encode: (input) => coerce(blake2b(input, void 0, 29))
    });
    blake2b240 = from2({
      name: "blake2b-240",
      code: 45598,
      encode: (input) => coerce(blake2b(input, void 0, 30))
    });
    blake2b248 = from2({
      name: "blake2b-248",
      code: 45599,
      encode: (input) => coerce(blake2b(input, void 0, 31))
    });
    blake2b256 = from2({
      name: "blake2b-256",
      code: 45600,
      encode: (input) => coerce(blake2b(input, void 0, 32))
    });
    blake2b264 = from2({
      name: "blake2b-264",
      code: 45601,
      encode: (input) => coerce(blake2b(input, void 0, 33))
    });
    blake2b272 = from2({
      name: "blake2b-272",
      code: 45602,
      encode: (input) => coerce(blake2b(input, void 0, 34))
    });
    blake2b280 = from2({
      name: "blake2b-280",
      code: 45603,
      encode: (input) => coerce(blake2b(input, void 0, 35))
    });
    blake2b288 = from2({
      name: "blake2b-288",
      code: 45604,
      encode: (input) => coerce(blake2b(input, void 0, 36))
    });
    blake2b296 = from2({
      name: "blake2b-296",
      code: 45605,
      encode: (input) => coerce(blake2b(input, void 0, 37))
    });
    blake2b304 = from2({
      name: "blake2b-304",
      code: 45606,
      encode: (input) => coerce(blake2b(input, void 0, 38))
    });
    blake2b312 = from2({
      name: "blake2b-312",
      code: 45607,
      encode: (input) => coerce(blake2b(input, void 0, 39))
    });
    blake2b320 = from2({
      name: "blake2b-320",
      code: 45608,
      encode: (input) => coerce(blake2b(input, void 0, 40))
    });
    blake2b328 = from2({
      name: "blake2b-328",
      code: 45609,
      encode: (input) => coerce(blake2b(input, void 0, 41))
    });
    blake2b336 = from2({
      name: "blake2b-336",
      code: 45610,
      encode: (input) => coerce(blake2b(input, void 0, 42))
    });
    blake2b344 = from2({
      name: "blake2b-344",
      code: 45611,
      encode: (input) => coerce(blake2b(input, void 0, 43))
    });
    blake2b352 = from2({
      name: "blake2b-352",
      code: 45612,
      encode: (input) => coerce(blake2b(input, void 0, 44))
    });
    blake2b360 = from2({
      name: "blake2b-360",
      code: 45613,
      encode: (input) => coerce(blake2b(input, void 0, 45))
    });
    blake2b368 = from2({
      name: "blake2b-368",
      code: 45614,
      encode: (input) => coerce(blake2b(input, void 0, 46))
    });
    blake2b376 = from2({
      name: "blake2b-376",
      code: 45615,
      encode: (input) => coerce(blake2b(input, void 0, 47))
    });
    blake2b384 = from2({
      name: "blake2b-384",
      code: 45616,
      encode: (input) => coerce(blake2b(input, void 0, 48))
    });
    blake2b392 = from2({
      name: "blake2b-392",
      code: 45617,
      encode: (input) => coerce(blake2b(input, void 0, 49))
    });
    blake2b400 = from2({
      name: "blake2b-400",
      code: 45618,
      encode: (input) => coerce(blake2b(input, void 0, 50))
    });
    blake2b408 = from2({
      name: "blake2b-408",
      code: 45619,
      encode: (input) => coerce(blake2b(input, void 0, 51))
    });
    blake2b416 = from2({
      name: "blake2b-416",
      code: 45620,
      encode: (input) => coerce(blake2b(input, void 0, 52))
    });
    blake2b424 = from2({
      name: "blake2b-424",
      code: 45621,
      encode: (input) => coerce(blake2b(input, void 0, 53))
    });
    blake2b432 = from2({
      name: "blake2b-432",
      code: 45622,
      encode: (input) => coerce(blake2b(input, void 0, 54))
    });
    blake2b440 = from2({
      name: "blake2b-440",
      code: 45623,
      encode: (input) => coerce(blake2b(input, void 0, 55))
    });
    blake2b448 = from2({
      name: "blake2b-448",
      code: 45624,
      encode: (input) => coerce(blake2b(input, void 0, 56))
    });
    blake2b456 = from2({
      name: "blake2b-456",
      code: 45625,
      encode: (input) => coerce(blake2b(input, void 0, 57))
    });
    blake2b464 = from2({
      name: "blake2b-464",
      code: 45626,
      encode: (input) => coerce(blake2b(input, void 0, 58))
    });
    blake2b472 = from2({
      name: "blake2b-472",
      code: 45627,
      encode: (input) => coerce(blake2b(input, void 0, 59))
    });
    blake2b480 = from2({
      name: "blake2b-480",
      code: 45628,
      encode: (input) => coerce(blake2b(input, void 0, 60))
    });
    blake2b488 = from2({
      name: "blake2b-488",
      code: 45629,
      encode: (input) => coerce(blake2b(input, void 0, 61))
    });
    blake2b496 = from2({
      name: "blake2b-496",
      code: 45630,
      encode: (input) => coerce(blake2b(input, void 0, 62))
    });
    blake2b504 = from2({
      name: "blake2b-504",
      code: 45631,
      encode: (input) => coerce(blake2b(input, void 0, 63))
    });
    blake2b512 = from2({
      name: "blake2b-512",
      code: 45632,
      encode: (input) => coerce(blake2b(input, void 0, 64))
    });
  }
});
var import_blakejs2;
var __awaiter;
var blake2b2;
var blake2bInit;
var blake2bUpdate;
var blake2bFinal;
var blake2b256stream;
var init_blake2bstream = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/blake2bstream.mjs"() {
    import_blakejs2 = __toESM(require_blakejs(), 1);
    init_bytes();
    init_hasher();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve42) {
          resolve42(value);
        });
      }
      return new (P || (P = Promise))(function(resolve42, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve42(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ({ blake2b: blake2b2, blake2bInit, blake2bUpdate, blake2bFinal } = import_blakejs2.default);
    blake2b256stream = from2({
      name: "blake2b-256",
      code: 45600,
      encode: (input) => __awaiter(void 0, void 0, void 0, function* () {
        if (input instanceof ReadableStream) {
          const ctx = blake2bInit(32);
          const reader = input.getReader();
          for (; ; ) {
            const result = yield reader.read();
            if (result.done)
              break;
            blake2bUpdate(ctx, coerce(result.value));
          }
          return blake2bFinal(ctx);
        } else {
          return coerce(blake2b2(input, void 0, 32));
        }
      })
    });
  }
});
var base32;
var base32upper;
var base32pad;
var base32padupper;
var base32hex;
var base32hexupper;
var base32hexpad;
var base32hexpadupper;
var base32z;
var init_base32 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/bases/base32.mjs"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});
var init_interface = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/link/interface.mjs"() {
  }
});
function format5(link, base2) {
  const { bytes, version } = link;
  switch (version) {
    case 0:
      return toStringV0(bytes, baseCache(link), base2 !== null && base2 !== void 0 ? base2 : base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base2 !== null && base2 !== void 0 ? base2 : base32.encoder);
  }
}
function baseCache(cid) {
  const baseCache2 = cache.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
}
function parseCIDtoBytes(source, base2) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base2 !== null && base2 !== void 0 ? base2 : base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base2 !== null && base2 !== void 0 ? base2 : base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base2 !== null && base2 !== void 0 ? base2 : base32;
      return [base32.prefix, decoder.decode(source)];
    }
    default: {
      if (base2 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base2.decode(source)];
    }
  }
}
function toStringV0(bytes, cache2, base2) {
  const { prefix } = base2;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base2.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base2.encode(bytes).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache2, base2) {
  const { prefix } = base2;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base2.encode(bytes);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function encodeCID(version, code2, multihash) {
  const codeOffset = encodingLength(version);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version, bytes, 0);
  encodeTo(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var _a;
var cache;
var CID;
var DAG_PB_CODE;
var SHA_256_CODE;
var cidSymbol;
var init_cid = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/cid.mjs"() {
    init_base32();
    init_base58();
    init_bytes();
    init_digest();
    init_varint2();
    init_interface();
    cache = /* @__PURE__ */ new WeakMap();
    CID = class _CID {
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param multihash - (Multi)hash of the of the content.
       */
      constructor(version, code2, multihash, bytes) {
        this[_a] = "CID";
        this.code = code2;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        this["/"] = bytes;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          case 1: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest } = this.multihash;
            const multihash = create(code2, digest);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return _CID.equals(this, other);
      }
      static equals(self2, other) {
        const unknown = other;
        return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
      }
      toString(base2) {
        return format5(this, base2);
      }
      toJSON() {
        return { "/": format5(this) };
      }
      link() {
        return this;
      }
      // Legacy
      [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       */
      static asCID(input) {
        if (input == null) {
          return null;
        }
        const value = input;
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version, code: code2, multihash, bytes } = value;
          return new _CID(version, code2, multihash, bytes !== null && bytes !== void 0 ? bytes : encodeCID(version, code2, multihash.bytes));
        } else if (value[cidSymbol] === true) {
          const { version, multihash, code: code2 } = value;
          const digest = decode4(multihash);
          return _CID.create(version, code2, digest);
        } else {
          return null;
        }
      }
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param digest - (Multi)hash of the of the content.
       */
      static create(version, code2, digest) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version, code2, digest, digest.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version, code2, digest.bytes);
            return new _CID(version, code2, digest, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       */
      static createV0(digest) {
        return _CID.create(0, DAG_PB_CODE, digest);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @param code - Content encoding format code.
       * @param digest - Multihash of the content.
       */
      static createV1(code2, digest) {
        return _CID.create(1, code2, digest);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       */
      static decode(bytes) {
        const [cid, remainder] = _CID.decodeFirst(bytes);
        if (remainder.length !== 0) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       */
      static decodeFirst(bytes) {
        const specs = _CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
        return [cid, bytes.subarray(specs.size)];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       */
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i2, length2] = decode3(initialBytes.subarray(offset));
          offset += length2;
          return i2;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
          version = 0;
          offset = 0;
        } else {
          codec = next();
        }
        if (version !== 0 && version !== 1) {
          throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return { version, codec, multihashCode, digestSize, multihashSize, size };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       */
      static parse(source, base2) {
        const [prefix, bytes] = parseCIDtoBytes(source, base2);
        const cid = _CID.decode(bytes);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache(cid).set(prefix, source);
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
  }
});
async function createCIDfromStream(data, multicode = multicodes.RAW) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = await blake2b256stream.digest(uint8array);
  return CID.create(1, multicode, digest).toString(base58btc);
}
function createCID(data, multicode = multicodes.RAW) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = blake2b256.digest(uint8array);
  return CID.create(1, multicode, digest).toString(base58btc);
}
function blake32Hash(data) {
  const uint8array = typeof data === "string" ? new TextEncoder().encode(data) : data;
  const digest = blake2b256.digest(uint8array);
  return base58btc.encode(digest.bytes);
}
var multicodes;
var parseCID;
var maybeParseCID;
var b64ToBuf;
var b64ToStr;
var strToBuf;
var strToB64;
var init_functions = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/functions.mjs"() {
    init_base58();
    init_blake2b();
    init_blake2bstream();
    init_cid();
    multicodes = {
      RAW: 0,
      JSON: 512,
      SHELTER_CONTRACT_MANIFEST: 5316096,
      SHELTER_CONTRACT_TEXT: 5316097,
      SHELTER_CONTRACT_DATA: 5316098,
      SHELTER_FILE_MANIFEST: 5316099,
      SHELTER_FILE_CHUNK: 5316100
    };
    parseCID = (cid) => {
      if (!cid || cid.length < 52 || cid.length > 64) {
        throw new RangeError("CID length too short or too long");
      }
      const parsed = CID.parse(cid, base58btc);
      if (parsed.version !== 1 || parsed.multihash.code !== blake2b256.code || !Object.values(multicodes).includes(parsed.code)) {
        throw new Error("Invalid CID");
      }
      return parsed;
    };
    maybeParseCID = (cid) => {
      try {
        return parseCID(cid);
      } catch {
        return null;
      }
    };
    b64ToBuf = (b64) => Buffer2.from(b64, "base64");
    b64ToStr = (b64) => b64ToBuf(b64).toString("utf8");
    strToBuf = (str) => Buffer2.from(str, "utf8");
    strToB64 = (str) => strToBuf(str).toString("base64");
  }
});
var init_esm5 = __esm({
  "node_modules/.deno/@chelonia+multiformats@1.0.0/node_modules/@chelonia/multiformats/dist/esm/index.mjs"() {
    init_base();
    init_base32();
    init_base58();
    init_blake2b();
    init_blake2bstream();
    init_cid();
    init_hasher();
    init_digest();
  }
});
var require_scrypt_async = __commonJS({
  "node_modules/.deno/scrypt-async@2.0.1/node_modules/scrypt-async/scrypt-async.js"(exports, module) {
    function scrypt3(password, salt, logN, r, dkLen, interruptStep, callback, encoding) {
      "use strict";
      function SHA256(m3) {
        var K2 = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225, w3 = new Array(64);
        function blocks(p3) {
          var off = 0, len = p3.length;
          while (len >= 64) {
            var a = h0, b = h1, c = h2, d = h3, e2 = h4, f = h5, g2 = h6, h8 = h7, u2, i3, j, t1, t2;
            for (i3 = 0; i3 < 16; i3++) {
              j = off + i3 * 4;
              w3[i3] = (p3[j] & 255) << 24 | (p3[j + 1] & 255) << 16 | (p3[j + 2] & 255) << 8 | p3[j + 3] & 255;
            }
            for (i3 = 16; i3 < 64; i3++) {
              u2 = w3[i3 - 2];
              t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
              u2 = w3[i3 - 15];
              t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
              w3[i3] = (t1 + w3[i3 - 7] | 0) + (t2 + w3[i3 - 16] | 0) | 0;
            }
            for (i3 = 0; i3 < 64; i3++) {
              t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f ^ ~e2 & g2) | 0) + (h8 + (K2[i3] + w3[i3] | 0) | 0) | 0;
              t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
              h8 = g2;
              g2 = f;
              f = e2;
              e2 = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            h0 = h0 + a | 0;
            h1 = h1 + b | 0;
            h2 = h2 + c | 0;
            h3 = h3 + d | 0;
            h4 = h4 + e2 | 0;
            h5 = h5 + f | 0;
            h6 = h6 + g2 | 0;
            h7 = h7 + h8 | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m3);
        var i2, bytesLeft = m3.length % 64, bitLenHi = m3.length / 536870912 | 0, bitLenLo = m3.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m3.slice(m3.length - bytesLeft, m3.length);
        p2.push(128);
        for (i2 = bytesLeft + 1; i2 < numZeros; i2++) p2.push(0);
        p2.push(bitLenHi >>> 24 & 255);
        p2.push(bitLenHi >>> 16 & 255);
        p2.push(bitLenHi >>> 8 & 255);
        p2.push(bitLenHi >>> 0 & 255);
        p2.push(bitLenLo >>> 24 & 255);
        p2.push(bitLenLo >>> 16 & 255);
        p2.push(bitLenLo >>> 8 & 255);
        p2.push(bitLenLo >>> 0 & 255);
        blocks(p2);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password2, salt2, dkLen2) {
        if (password2.length > 64) {
          password2 = SHA256(password2.push ? password2 : Array.prototype.slice.call(password2, 0));
        }
        var i2, innerLen = 64 + salt2.length + 4, inner = new Array(innerLen), outerKey = new Array(64), dk = [];
        for (i2 = 0; i2 < 64; i2++) inner[i2] = 54;
        for (i2 = 0; i2 < password2.length; i2++) inner[i2] ^= password2[i2];
        for (i2 = 0; i2 < salt2.length; i2++) inner[64 + i2] = salt2[i2];
        for (i2 = innerLen - 4; i2 < innerLen; i2++) inner[i2] = 0;
        for (i2 = 0; i2 < 64; i2++) outerKey[i2] = 92;
        for (i2 = 0; i2 < password2.length; i2++) outerKey[i2] ^= password2[i2];
        function incrementCounter() {
          for (var i3 = innerLen - 1; i3 >= innerLen - 4; i3--) {
            inner[i3]++;
            if (inner[i3] <= 255) return;
            inner[i3] = 0;
          }
        }
        while (dkLen2 >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen2 -= 32;
        }
        if (dkLen2 > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen2));
        }
        return dk;
      }
      function salsaXOR(tmp2, B4, bin, bout) {
        var j0 = tmp2[0] ^ B4[bin++], j1 = tmp2[1] ^ B4[bin++], j2 = tmp2[2] ^ B4[bin++], j3 = tmp2[3] ^ B4[bin++], j4 = tmp2[4] ^ B4[bin++], j5 = tmp2[5] ^ B4[bin++], j6 = tmp2[6] ^ B4[bin++], j7 = tmp2[7] ^ B4[bin++], j8 = tmp2[8] ^ B4[bin++], j9 = tmp2[9] ^ B4[bin++], j10 = tmp2[10] ^ B4[bin++], j11 = tmp2[11] ^ B4[bin++], j12 = tmp2[12] ^ B4[bin++], j13 = tmp2[13] ^ B4[bin++], j14 = tmp2[14] ^ B4[bin++], j15 = tmp2[15] ^ B4[bin++], u2, i2;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15;
        for (i2 = 0; i2 < 8; i2 += 2) {
          u2 = x0 + x12;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        B4[bout++] = tmp2[0] = x0 + j0 | 0;
        B4[bout++] = tmp2[1] = x1 + j1 | 0;
        B4[bout++] = tmp2[2] = x2 + j2 | 0;
        B4[bout++] = tmp2[3] = x3 + j3 | 0;
        B4[bout++] = tmp2[4] = x4 + j4 | 0;
        B4[bout++] = tmp2[5] = x5 + j5 | 0;
        B4[bout++] = tmp2[6] = x6 + j6 | 0;
        B4[bout++] = tmp2[7] = x7 + j7 | 0;
        B4[bout++] = tmp2[8] = x8 + j8 | 0;
        B4[bout++] = tmp2[9] = x9 + j9 | 0;
        B4[bout++] = tmp2[10] = x10 + j10 | 0;
        B4[bout++] = tmp2[11] = x11 + j11 | 0;
        B4[bout++] = tmp2[12] = x12 + j12 | 0;
        B4[bout++] = tmp2[13] = x13 + j13 | 0;
        B4[bout++] = tmp2[14] = x14 + j14 | 0;
        B4[bout++] = tmp2[15] = x15 + j15 | 0;
      }
      function blockCopy(dst, di, src2, si, len) {
        while (len--) dst[di++] = src2[si++];
      }
      function blockXOR(dst, di, src2, si, len) {
        while (len--) dst[di++] ^= src2[si++];
      }
      function blockMix(tmp2, B4, bin, bout, r2) {
        blockCopy(tmp2, 0, B4, bin + (2 * r2 - 1) * 16, 16);
        for (var i2 = 0; i2 < 2 * r2; i2 += 2) {
          salsaXOR(tmp2, B4, bin + i2 * 16, bout + i2 * 8);
          salsaXOR(tmp2, B4, bin + i2 * 16 + 16, bout + i2 * 8 + r2 * 16);
        }
      }
      function integerify(B4, bi, r2) {
        return B4[bi + (2 * r2 - 1) * 16];
      }
      function stringToUTF8Bytes(s) {
        var arr = [];
        for (var i2 = 0; i2 < s.length; i2++) {
          var c = s.charCodeAt(i2);
          if (c < 128) {
            arr.push(c);
          } else if (c < 2048) {
            arr.push(192 | c >> 6);
            arr.push(128 | c & 63);
          } else if (c < 55296) {
            arr.push(224 | c >> 12);
            arr.push(128 | c >> 6 & 63);
            arr.push(128 | c & 63);
          } else {
            if (i2 >= s.length - 1) {
              throw new Error("invalid string");
            }
            i2++;
            c = (c & 1023) << 10;
            c |= s.charCodeAt(i2) & 1023;
            c += 65536;
            arr.push(240 | c >> 18);
            arr.push(128 | c >> 12 & 63);
            arr.push(128 | c >> 6 & 63);
            arr.push(128 | c & 63);
          }
        }
        return arr;
      }
      function bytesToHex(p2) {
        var enc = "0123456789abcdef".split("");
        var len = p2.length, arr = [], i2 = 0;
        for (; i2 < len; i2++) {
          arr.push(enc[p2[i2] >>> 4 & 15]);
          arr.push(enc[p2[i2] >>> 0 & 15]);
        }
        return arr.join("");
      }
      function bytesToBase64(p2) {
        var enc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        var len = p2.length, arr = [], i2 = 0, a, b, c, t;
        while (i2 < len) {
          a = i2 < len ? p2[i2++] : 0;
          b = i2 < len ? p2[i2++] : 0;
          c = i2 < len ? p2[i2++] : 0;
          t = (a << 16) + (b << 8) + c;
          arr.push(enc[t >>> 3 * 6 & 63]);
          arr.push(enc[t >>> 2 * 6 & 63]);
          arr.push(enc[t >>> 1 * 6 & 63]);
          arr.push(enc[t >>> 0 * 6 & 63]);
        }
        if (len % 3 > 0) {
          arr[arr.length - 1] = "=";
          if (len % 3 === 1) arr[arr.length - 2] = "=";
        }
        return arr.join("");
      }
      var MAX_UINT = -1 >>> 0, p = 1;
      if (typeof logN === "object") {
        if (arguments.length > 4) {
          throw new Error("scrypt: incorrect number of arguments");
        }
        var opts = logN;
        callback = r;
        logN = opts.logN;
        if (typeof logN === "undefined") {
          if (typeof opts.N !== "undefined") {
            if (opts.N < 2 || opts.N > MAX_UINT)
              throw new Error("scrypt: N is out of range");
            if ((opts.N & opts.N - 1) !== 0)
              throw new Error("scrypt: N is not a power of 2");
            logN = Math.log(opts.N) / Math.LN2;
          } else {
            throw new Error("scrypt: missing N parameter");
          }
        }
        p = opts.p || 1;
        r = opts.r;
        dkLen = opts.dkLen || 32;
        interruptStep = opts.interruptStep || 0;
        encoding = opts.encoding;
      }
      if (p < 1)
        throw new Error("scrypt: invalid p");
      if (r <= 0)
        throw new Error("scrypt: invalid r");
      if (logN < 1 || logN > 31)
        throw new Error("scrypt: logN must be between 1 and 31");
      var N10 = 1 << logN >>> 0, XY, V, B3, tmp;
      if (r * p >= 1 << 30 || r > MAX_UINT / 128 / p || r > MAX_UINT / 256 || N10 > MAX_UINT / 128 / r)
        throw new Error("scrypt: parameters are too large");
      if (typeof password === "string")
        password = stringToUTF8Bytes(password);
      if (typeof salt === "string")
        salt = stringToUTF8Bytes(salt);
      if (typeof Int32Array !== "undefined") {
        XY = new Int32Array(64 * r);
        V = new Int32Array(32 * N10 * r);
        tmp = new Int32Array(16);
      } else {
        XY = [];
        V = [];
        tmp = new Array(16);
      }
      B3 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
      var xi = 0, yi = 32 * r;
      function smixStart(pos) {
        for (var i2 = 0; i2 < 32 * r; i2++) {
          var j = pos + i2 * 4;
          XY[xi + i2] = (B3[j + 3] & 255) << 24 | (B3[j + 2] & 255) << 16 | (B3[j + 1] & 255) << 8 | (B3[j + 0] & 255) << 0;
        }
      }
      function smixStep1(start, end) {
        for (var i2 = start; i2 < end; i2 += 2) {
          blockCopy(V, i2 * (32 * r), XY, xi, 32 * r);
          blockMix(tmp, XY, xi, yi, r);
          blockCopy(V, (i2 + 1) * (32 * r), XY, yi, 32 * r);
          blockMix(tmp, XY, yi, xi, r);
        }
      }
      function smixStep2(start, end) {
        for (var i2 = start; i2 < end; i2 += 2) {
          var j = integerify(XY, xi, r) & N10 - 1;
          blockXOR(XY, xi, V, j * (32 * r), 32 * r);
          blockMix(tmp, XY, xi, yi, r);
          j = integerify(XY, yi, r) & N10 - 1;
          blockXOR(XY, yi, V, j * (32 * r), 32 * r);
          blockMix(tmp, XY, yi, xi, r);
        }
      }
      function smixFinish(pos) {
        for (var i2 = 0; i2 < 32 * r; i2++) {
          var j = XY[xi + i2];
          B3[pos + i2 * 4 + 0] = j >>> 0 & 255;
          B3[pos + i2 * 4 + 1] = j >>> 8 & 255;
          B3[pos + i2 * 4 + 2] = j >>> 16 & 255;
          B3[pos + i2 * 4 + 3] = j >>> 24 & 255;
        }
      }
      var nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      function interruptedFor(start, end, step, fn, donefn) {
        (function performStep() {
          nextTick(function() {
            fn(start, start + step < end ? start + step : end);
            start += step;
            if (start < end)
              performStep();
            else
              donefn();
          });
        })();
      }
      function getResult(enc) {
        var result = PBKDF2_HMAC_SHA256_OneIter(password, B3, dkLen);
        if (enc === "base64")
          return bytesToBase64(result);
        else if (enc === "hex")
          return bytesToHex(result);
        else if (enc === "binary")
          return new Uint8Array(result);
        else
          return result;
      }
      function calculateSync() {
        for (var i2 = 0; i2 < p; i2++) {
          smixStart(i2 * 128 * r);
          smixStep1(0, N10);
          smixStep2(0, N10);
          smixFinish(i2 * 128 * r);
        }
        callback(getResult(encoding));
      }
      function calculateAsync(i2) {
        smixStart(i2 * 128 * r);
        interruptedFor(0, N10, interruptStep * 2, smixStep1, function() {
          interruptedFor(0, N10, interruptStep * 2, smixStep2, function() {
            smixFinish(i2 * 128 * r);
            if (i2 + 1 < p) {
              nextTick(function() {
                calculateAsync(i2 + 1);
              });
            } else {
              callback(getResult(encoding));
            }
          });
        });
      }
      if (typeof interruptStep === "function") {
        encoding = callback;
        callback = interruptStep;
        interruptStep = 1e3;
      }
      if (interruptStep <= 0) {
        calculateSync();
      } else {
        calculateAsync(0);
      }
    }
    if (typeof module !== "undefined") module.exports = scrypt3;
  }
});
var require_nacl_fast = __commonJS({
  "node_modules/.deno/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl3) {
      "use strict";
      var gf = function(init2) {
        var i2, r = new Float64Array(16);
        if (init2) for (i2 = 0; i2 < init2.length; i2++) r[i2] = init2[i2];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i2, h2, l) {
        x2[i2] = h2 >> 24 & 255;
        x2[i2 + 1] = h2 >> 16 & 255;
        x2[i2 + 2] = h2 >> 8 & 255;
        x2[i2 + 3] = h2 & 255;
        x2[i2 + 4] = l >> 24 & 255;
        x2[i2 + 5] = l >> 16 & 255;
        x2[i2 + 6] = l >> 8 & 255;
        x2[i2 + 7] = l & 255;
      }
      function vn(x2, xi, y, yi, n) {
        var i2, d = 0;
        for (i2 = 0; i2 < n; i2++) d |= x2[xi + i2] ^ y[yi + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y, yi) {
        return vn(x2, xi, y, yi, 16);
      }
      function crypto_verify_32(x2, xi, y, yi) {
        return vn(x2, xi, y, yi, 32);
      }
      function core_salsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x1 >>> 0 & 255;
        o2[5] = x1 >>> 8 & 255;
        o2[6] = x1 >>> 16 & 255;
        o2[7] = x1 >>> 24 & 255;
        o2[8] = x2 >>> 0 & 255;
        o2[9] = x2 >>> 8 & 255;
        o2[10] = x2 >>> 16 & 255;
        o2[11] = x2 >>> 24 & 255;
        o2[12] = x3 >>> 0 & 255;
        o2[13] = x3 >>> 8 & 255;
        o2[14] = x3 >>> 16 & 255;
        o2[15] = x3 >>> 24 & 255;
        o2[16] = x4 >>> 0 & 255;
        o2[17] = x4 >>> 8 & 255;
        o2[18] = x4 >>> 16 & 255;
        o2[19] = x4 >>> 24 & 255;
        o2[20] = x5 >>> 0 & 255;
        o2[21] = x5 >>> 8 & 255;
        o2[22] = x5 >>> 16 & 255;
        o2[23] = x5 >>> 24 & 255;
        o2[24] = x6 >>> 0 & 255;
        o2[25] = x6 >>> 8 & 255;
        o2[26] = x6 >>> 16 & 255;
        o2[27] = x6 >>> 24 & 255;
        o2[28] = x7 >>> 0 & 255;
        o2[29] = x7 >>> 8 & 255;
        o2[30] = x7 >>> 16 & 255;
        o2[31] = x7 >>> 24 & 255;
        o2[32] = x8 >>> 0 & 255;
        o2[33] = x8 >>> 8 & 255;
        o2[34] = x8 >>> 16 & 255;
        o2[35] = x8 >>> 24 & 255;
        o2[36] = x9 >>> 0 & 255;
        o2[37] = x9 >>> 8 & 255;
        o2[38] = x9 >>> 16 & 255;
        o2[39] = x9 >>> 24 & 255;
        o2[40] = x10 >>> 0 & 255;
        o2[41] = x10 >>> 8 & 255;
        o2[42] = x10 >>> 16 & 255;
        o2[43] = x10 >>> 24 & 255;
        o2[44] = x11 >>> 0 & 255;
        o2[45] = x11 >>> 8 & 255;
        o2[46] = x11 >>> 16 & 255;
        o2[47] = x11 >>> 24 & 255;
        o2[48] = x12 >>> 0 & 255;
        o2[49] = x12 >>> 8 & 255;
        o2[50] = x12 >>> 16 & 255;
        o2[51] = x12 >>> 24 & 255;
        o2[52] = x13 >>> 0 & 255;
        o2[53] = x13 >>> 8 & 255;
        o2[54] = x13 >>> 16 & 255;
        o2[55] = x13 >>> 24 & 255;
        o2[56] = x14 >>> 0 & 255;
        o2[57] = x14 >>> 8 & 255;
        o2[58] = x14 >>> 16 & 255;
        o2[59] = x14 >>> 24 & 255;
        o2[60] = x15 >>> 0 & 255;
        o2[61] = x15 >>> 8 & 255;
        o2[62] = x15 >>> 16 & 255;
        o2[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o2, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o2[0] = x0 >>> 0 & 255;
        o2[1] = x0 >>> 8 & 255;
        o2[2] = x0 >>> 16 & 255;
        o2[3] = x0 >>> 24 & 255;
        o2[4] = x5 >>> 0 & 255;
        o2[5] = x5 >>> 8 & 255;
        o2[6] = x5 >>> 16 & 255;
        o2[7] = x5 >>> 24 & 255;
        o2[8] = x10 >>> 0 & 255;
        o2[9] = x10 >>> 8 & 255;
        o2[10] = x10 >>> 16 & 255;
        o2[11] = x10 >>> 24 & 255;
        o2[12] = x15 >>> 0 & 255;
        o2[13] = x15 >>> 8 & 255;
        o2[14] = x15 >>> 16 & 255;
        o2[15] = x15 >>> 24 & 255;
        o2[16] = x6 >>> 0 & 255;
        o2[17] = x6 >>> 8 & 255;
        o2[18] = x6 >>> 16 & 255;
        o2[19] = x6 >>> 24 & 255;
        o2[20] = x7 >>> 0 & 255;
        o2[21] = x7 >>> 8 & 255;
        o2[22] = x7 >>> 16 & 255;
        o2[23] = x7 >>> 24 & 255;
        o2[24] = x8 >>> 0 & 255;
        o2[25] = x8 >>> 8 & 255;
        o2[26] = x8 >>> 16 & 255;
        o2[27] = x8 >>> 24 & 255;
        o2[28] = x9 >>> 0 & 255;
        o2[29] = x9 >>> 8 & 255;
        o2[30] = x9 >>> 16 & 255;
        o2[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m3, mpos, b, n, k) {
        var z = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x2, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = m3[mpos + i2] ^ x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z[i2] & 255) | 0;
            z[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x2, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = m3[mpos + i2] ^ x2[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x2, z, k, sigma);
          for (i2 = 0; i2 < 64; i2++) c[cpos + i2] = x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z[i2] & 255) | 0;
            z[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x2, z, k, sigma);
          for (i2 = 0; i2 < b; i2++) c[cpos + i2] = x2[i2];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m3, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20_xor(c, cpos, m3, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m3, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m3[mpos + 0] & 255 | (m3[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m3[mpos + 2] & 255 | (m3[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m3[mpos + 4] & 255 | (m3[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m3[mpos + 6] & 255 | (m3[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m3[mpos + 8] & 255 | (m3[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m3[mpos + 10] & 255 | (m3[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m3[mpos + 12] & 255 | (m3[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m3[mpos + 14] & 255 | (m3[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c, mask, f, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c;
          c = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g2[0] = this.h[0] + 5;
        c = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this.h[i2] + c;
          c = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g2[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask | g2[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f = (this.h[i2] + this.pad[i2] | 0) + (f >>> 16) | 0;
          this.h[i2] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m3, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m3[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m3, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m3[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m3, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m3, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m3, mpos, n, k) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m3, mpos, n, k);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c, m3, d, n, k) {
        var i2;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m3, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i2 = 0; i2 < 16; i2++) c[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m3, c, d, n, k) {
        var i2;
        var x2 = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x2, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x2) !== 0) return -1;
        crypto_stream_xor(m3, 0, c, 0, d, n, k);
        for (i2 = 0; i2 < 32; i2++) m3[i2] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r[i2] = a[i2] | 0;
      }
      function car25519(o2) {
        var i2, v2, c = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v2 = o2[i2] + c + 65535;
          c = Math.floor(v2 / 65536);
          o2[i2] = v2 - c * 65536;
        }
        o2[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t = c & (p[i2] ^ q[i2]);
          p[i2] ^= t;
          q[i2] ^= t;
        }
      }
      function pack25519(o2, n) {
        var i2, j, b;
        var m3 = gf(), t = gf();
        for (i2 = 0; i2 < 16; i2++) t[i2] = n[i2];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m3[0] = t[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m3[i2] = t[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
            m3[i2 - 1] &= 65535;
          }
          m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
          b = m3[15] >> 16 & 1;
          m3[14] &= 65535;
          sel25519(t, m3, 1 - b);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o2[2 * i2] = t[i2] & 255;
          o2[2 * i2 + 1] = t[i2] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o2, n) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o2[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
        o2[15] &= 32767;
      }
      function A2(o2, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a[i2] + b[i2];
      }
      function Z(o2, a, b) {
        for (var i2 = 0; i2 < 16; i2++) o2[i2] = a[i2] - b[i2];
      }
      function M2(o2, a, b) {
        var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v2 = a[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b2;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b2;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b2;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b2;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b2;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b2;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b2;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b2;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b2;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b2;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b2;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b2;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b2;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b2;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b2;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b2;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o2[0] = t0;
        o2[1] = t1;
        o2[2] = t2;
        o2[3] = t3;
        o2[4] = t4;
        o2[5] = t5;
        o2[6] = t6;
        o2[7] = t7;
        o2[8] = t8;
        o2[9] = t9;
        o2[10] = t10;
        o2[11] = t11;
        o2[12] = t12;
        o2[13] = t13;
        o2[14] = t14;
        o2[15] = t15;
      }
      function S2(o2, a) {
        M2(o2, a, a);
      }
      function inv25519(o2, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 253; a >= 0; a--) {
          S2(c, c);
          if (a !== 2 && a !== 4) M2(c, c, i2);
        }
        for (a = 0; a < 16; a++) o2[a] = c[a];
      }
      function pow2523(o2, i2) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i2[a];
        for (a = 250; a >= 0; a--) {
          S2(c, c);
          if (a !== 1) M2(c, c, i2);
        }
        for (a = 0; a < 16; a++) o2[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x2 = new Float64Array(80), r, i2;
        var a = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf();
        for (i2 = 0; i2 < 31; i2++) z[i2] = n[i2];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x2, p);
        for (i2 = 0; i2 < 16; i2++) {
          b[i2] = x2[i2];
          d[i2] = a[i2] = c[i2] = 0;
        }
        a[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r = z[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A2(e2, a, c);
          Z(a, a, c);
          A2(c, b, d);
          Z(b, b, d);
          S2(d, e2);
          S2(f, a);
          M2(a, c, a);
          M2(c, b, e2);
          A2(e2, a, c);
          Z(a, a, c);
          S2(b, a);
          Z(c, d, f);
          M2(a, c, _121665);
          A2(a, a, d);
          M2(c, c, a);
          M2(a, d, f);
          M2(d, b, x2);
          S2(b, e2);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x2[i2 + 16] = a[i2];
          x2[i2 + 32] = c[i2];
          x2[i2 + 48] = b[i2];
          x2[i2 + 64] = d[i2];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y, x2);
      }
      function crypto_box_beforenm(k, y, x2) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x2, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m3, d, n, y, x2) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x2);
        return crypto_box_afternm(c, m3, d, n, k);
      }
      function crypto_box_open(m3, c, d, n, y, x2) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x2);
        return crypto_box_open_afternm(m3, c, d, n, k);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m3, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j, h2, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m3[j + 0] << 24 | m3[j + 1] << 16 | m3[j + 2] << 8 | m3[j + 3];
            wl[i2] = m3[j + 4] << 24 | m3[j + 5] << 16 | m3[j + 6] << 8 | m3[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = K2[i2 * 2];
            l = K2[i2 * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = wh[i2 % 16];
            l = wl[i2 % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h2 = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h2 = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h2 = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h2 & 65535;
                d = h2 >>> 16;
                h2 = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h2 = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h2 = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h2 = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h2 = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h2 = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h2 = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h2 = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h2 = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m3, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i2, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m3, n);
        n %= 128;
        for (i2 = 0; i2 < n; i2++) x2[i2] = m3[b - n + i2];
        x2[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x2[n - 9] = 0;
        ts64(x2, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x2, n);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf(), g2 = gf(), h2 = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M2(a, a, t);
        A2(b, p[0], p[1]);
        A2(t, q[0], q[1]);
        M2(b, b, t);
        M2(c, p[3], q[3]);
        M2(c, c, D2);
        M2(d, p[2], q[2]);
        A2(d, d, d);
        Z(e2, b, a);
        Z(f, d, c);
        A2(g2, d, c);
        A2(h2, b, a);
        M2(p[0], e2, f);
        M2(p[1], h2, g2);
        M2(p[2], g2, f);
        M2(p[3], e2, h2);
      }
      function cswap(p, q, b) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p[i2], q[i2], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M2(tx, p[0], zi);
        M2(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i2;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b = s[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M2(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x2) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x2[j] += carry - 16 * x2[i2] * L[j - (i2 - 32)];
            carry = Math.floor((x2[j] + 128) / 256);
            x2[j] -= carry * 256;
          }
          x2[j] += carry;
          x2[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x2[j] += carry - (x2[31] >> 4) * L[j];
          carry = x2[j] >> 8;
          x2[j] &= 255;
        }
        for (j = 0; j < 32; j++) x2[j] -= carry * L[j];
        for (i2 = 0; i2 < 32; i2++) {
          x2[i2 + 1] += x2[i2] >> 8;
          r[i2] = x2[i2] & 255;
        }
      }
      function reduce(r) {
        var x2 = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x2[i2] = r[i2];
        for (i2 = 0; i2 < 64; i2++) r[i2] = 0;
        modL(r, x2);
      }
      function crypto_sign(sm, m3, n, sk) {
        var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
        var i2, j, x2 = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i2 = 0; i2 < n; i2++) sm[64 + i2] = m3[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d[32 + i2];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h2, sm, n + 64);
        reduce(h2);
        for (i2 = 0; i2 < 64; i2++) x2[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x2[i2] = r[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x2[i2 + j] += h2[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S2(num, r[1]);
        M2(den, num, D);
        Z(num, num, r[2]);
        A2(den, r[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r[0], t, den);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r[0], r[0], I2);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M2(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m3, sm, n, pk) {
        var i2;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i2 = 0; i2 < n; i2++) m3[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m3[i2 + 32] = pk[i2];
        crypto_hash(h2, m3, n);
        reduce(h2);
        scalarmult(p, q, h2);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i2 = 0; i2 < n; i2++) m3[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n; i2++) m3[i2] = sm[i2 + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl3.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
      }
      nacl3.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl3.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m3 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m3.length);
        for (var i2 = 0; i2 < msg.length; i2++) m3[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c, m3, m3.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl3.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m3 = new Uint8Array(c.length);
        for (var i2 = 0; i2 < box.length; i2++) c[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m3, c, c.length, nonce, key) !== 0) return null;
        return m3.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl3.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl3.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl3.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl3.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl3.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl3.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl3.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl3.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox(msg, nonce, k);
      };
      nacl3.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl3.box.after = nacl3.secretbox;
      nacl3.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox.open(msg, nonce, k);
      };
      nacl3.box.open.after = nacl3.secretbox.open;
      nacl3.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl3.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl3.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl3.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl3.box.nonceLength = crypto_box_NONCEBYTES;
      nacl3.box.overheadLength = nacl3.secretbox.overheadLength;
      nacl3.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl3.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m3 = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m3.length; i2++) m3[i2] = tmp[i2];
        return m3;
      };
      nacl3.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl3.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl3.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
      };
      nacl3.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl3.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl3.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl3.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl3.sign.signatureLength = crypto_sign_BYTES;
      nacl3.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl3.hash.hashLength = crypto_hash_BYTES;
      nacl3.verify = function(x2, y) {
        checkArrayTypes(x2, y);
        if (x2.length === 0 || y.length === 0) return false;
        if (x2.length !== y.length) return false;
        return vn(x2, 0, y, 0, x2.length) === 0 ? true : false;
      };
      nacl3.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl3.setPRNG(function(x2, n) {
            var i2, v2 = new Uint8Array(n);
            for (i2 = 0; i2 < n; i2 += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n; i2++) x2[i2] = v2[i2];
            cleanup(v2);
          });
        } else if (typeof __require2 !== "undefined") {
          crypto2 = __require2("crypto");
          if (crypto2 && crypto2.randomBytes) {
            nacl3.setPRNG(function(x2, n) {
              var i2, v2 = crypto2.randomBytes(n);
              for (i2 = 0; i2 < n; i2++) x2[i2] = v2[i2];
              cleanup(v2);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});
var import_scrypt_async;
var import_tweetnacl;
var bufToStr;
var strToBuf2;
var blake32Hash2;
var b64ToBuf2;
var ENULL;
var SNULL;
var EDWARDS25519SHA512BATCH;
var CURVE25519XSALSA20POLY1305;
var XSALSA20POLY1305;
var EXTERNALKM32;
var bytesOrObjectToB64;
var keygen;
var generateSalt;
var serializeKey;
var deserializeKey;
var keyId;
var sign;
var verifySignature;
var encrypt;
var decrypt;
var init_esm6 = __esm({
  "node_modules/.deno/@chelonia+crypto@1.0.1/node_modules/@chelonia/crypto/dist/esm/index.mjs"() {
    init_esm5();
    import_scrypt_async = __toESM(require_scrypt_async(), 1);
    import_tweetnacl = __toESM(require_nacl_fast(), 1);
    bufToStr = (() => {
      const textDecoder = new TextDecoder();
      return (buf2) => {
        return textDecoder.decode(buf2);
      };
    })();
    strToBuf2 = (() => {
      const textEncoder = new TextEncoder();
      return (str) => {
        return textEncoder.encode(str);
      };
    })();
    blake32Hash2 = (data) => {
      const uint8array = typeof data === "string" ? strToBuf2(data) : data;
      const digest = blake2b256.digest(uint8array);
      return base58btc.encode(digest.bytes);
    };
    b64ToBuf2 = (data) => new Uint8Array(atob(data).split("").map((b) => b.charCodeAt(0)));
    ENULL = "eNULL";
    SNULL = "sNULL";
    EDWARDS25519SHA512BATCH = "edwards25519sha512batch";
    CURVE25519XSALSA20POLY1305 = "curve25519xsalsa20poly1305";
    XSALSA20POLY1305 = "xsalsa20poly1305";
    EXTERNALKM32 = "externalkm32";
    if (false) {
      throw new Error("ENABLE_UNSAFE_NULL_CRYPTO cannot be enabled in production mode");
    }
    bytesOrObjectToB64 = (ary) => {
      if (!(ary instanceof Uint8Array)) {
        throw TypeError("Unsupported type");
      }
      return btoa(Array.from(ary).map((c) => String.fromCharCode(c)).join(""));
    };
    keygen = (type) => {
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (type === ENULL || type === SNULL)) {
        const res = {
          type,
          publicKey: bytesOrObjectToB64(import_tweetnacl.default.randomBytes(18))
        };
        Object.defineProperty(res, "secretKey", { value: res.publicKey });
        return res;
      }
      if (type === EDWARDS25519SHA512BATCH) {
        const key = import_tweetnacl.default.sign.keyPair();
        const res = {
          type,
          publicKey: key.publicKey
        };
        Object.defineProperty(res, "secretKey", { value: key.secretKey });
        return res;
      } else if (type === CURVE25519XSALSA20POLY1305) {
        const key = import_tweetnacl.default.box.keyPair();
        const res = {
          type,
          publicKey: key.publicKey
        };
        Object.defineProperty(res, "secretKey", { value: key.secretKey });
        return res;
      } else if (type === XSALSA20POLY1305) {
        const res = {
          type
        };
        Object.defineProperty(res, "secretKey", { value: import_tweetnacl.default.randomBytes(import_tweetnacl.default.secretbox.keyLength) });
        return res;
      } else if (type === EXTERNALKM32) {
        const res = {
          type
        };
        Object.defineProperty(res, "secretKey", { value: import_tweetnacl.default.randomBytes(32) });
        return res;
      }
      throw new Error("Unsupported key type");
    };
    generateSalt = () => {
      return bytesOrObjectToB64(import_tweetnacl.default.randomBytes(18));
    };
    serializeKey = (key, saveSecretKey) => {
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (key.type === ENULL || key.type === SNULL)) {
        return JSON.stringify([
          key.type,
          saveSecretKey ? null : key.publicKey,
          saveSecretKey ? key.secretKey : null
        ], void 0, 0);
      }
      if (key.type === EDWARDS25519SHA512BATCH || key.type === CURVE25519XSALSA20POLY1305) {
        if (!saveSecretKey) {
          if (!key.publicKey) {
            throw new Error("Unsupported operation: no public key to export");
          }
          return JSON.stringify([
            key.type,
            bytesOrObjectToB64(key.publicKey),
            null
          ], void 0, 0);
        }
        if (!key.secretKey) {
          throw new Error("Unsupported operation: no secret key to export");
        }
        return JSON.stringify([
          key.type,
          null,
          bytesOrObjectToB64(key.secretKey)
        ], void 0, 0);
      } else if (key.type === XSALSA20POLY1305) {
        if (!saveSecretKey) {
          throw new Error("Unsupported operation: no public key to export");
        }
        if (!key.secretKey) {
          throw new Error("Unsupported operation: no secret key to export");
        }
        return JSON.stringify([
          key.type,
          null,
          bytesOrObjectToB64(key.secretKey)
        ], void 0, 0);
      }
      throw new Error("Unsupported key type");
    };
    deserializeKey = (data) => {
      const keyData = JSON.parse(data);
      if (!keyData || keyData.length !== 3) {
        throw new Error("Invalid key object");
      }
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && (keyData[0] === ENULL || keyData[0] === SNULL)) {
        const res = {
          type: keyData[0]
        };
        if (keyData[2]) {
          Object.defineProperty(res, "secretKey", { value: keyData[2] });
          res.publicKey = keyData[2];
        } else {
          res.publicKey = keyData[1];
        }
        return res;
      }
      if (keyData[0] === EDWARDS25519SHA512BATCH) {
        if (keyData[2]) {
          const key = import_tweetnacl.default.sign.keyPair.fromSecretKey(b64ToBuf2(keyData[2]));
          const res = {
            type: keyData[0],
            publicKey: key.publicKey
          };
          Object.defineProperty(res, "secretKey", { value: key.secretKey });
          return res;
        } else if (keyData[1]) {
          return {
            type: keyData[0],
            publicKey: new Uint8Array(b64ToBuf2(keyData[1]))
          };
        }
        throw new Error("Missing secret or public key");
      } else if (keyData[0] === CURVE25519XSALSA20POLY1305) {
        if (keyData[2]) {
          const key = import_tweetnacl.default.box.keyPair.fromSecretKey(b64ToBuf2(keyData[2]));
          const res = {
            type: keyData[0],
            publicKey: key.publicKey
          };
          Object.defineProperty(res, "secretKey", { value: key.secretKey });
          return res;
        } else if (keyData[1]) {
          return {
            type: keyData[0],
            publicKey: new Uint8Array(b64ToBuf2(keyData[1]))
          };
        }
        throw new Error("Missing secret or public key");
      } else if (keyData[0] === XSALSA20POLY1305) {
        if (!keyData[2]) {
          throw new Error("Secret key missing");
        }
        const res = {
          type: keyData[0]
        };
        Object.defineProperty(res, "secretKey", { value: new Uint8Array(b64ToBuf2(keyData[2])) });
        return res;
      }
      throw new Error("Unsupported key type");
    };
    keyId = (inKey) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      const serializedKey = serializeKey(key, !key.publicKey);
      return blake32Hash2(serializedKey);
    };
    sign = (inKey, data) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === SNULL) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        return key.secretKey + ";" + blake32Hash2(data);
      }
      if (key.type !== EDWARDS25519SHA512BATCH) {
        throw new Error("Unsupported algorithm");
      }
      if (!key.secretKey) {
        throw new Error("Secret key missing");
      }
      const messageUint8 = strToBuf2(data);
      const signature = import_tweetnacl.default.sign.detached(messageUint8, key.secretKey);
      const base64Signature = bytesOrObjectToB64(signature);
      return base64Signature;
    };
    verifySignature = (inKey, data, signature) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === SNULL) {
        if (!key.publicKey) {
          throw new Error("Public key missing");
        }
        if (key.publicKey + ";" + blake32Hash2(data) !== signature) {
          throw new Error("Invalid signature");
        }
        return;
      }
      if (key.type !== EDWARDS25519SHA512BATCH) {
        throw new Error("Unsupported algorithm");
      }
      if (!key.publicKey) {
        throw new Error("Public key missing");
      }
      const decodedSignature = b64ToBuf2(signature);
      const messageUint8 = strToBuf2(data);
      const result = import_tweetnacl.default.sign.detached.verify(messageUint8, decodedSignature, key.publicKey);
      if (!result) {
        throw new Error("Invalid signature");
      }
    };
    encrypt = (inKey, data, ad) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === ENULL) {
        if (!key.publicKey) {
          throw new Error("Public key missing");
        }
        return `${key.publicKey};${data};${ad !== null && ad !== void 0 ? ad : ""}`;
      }
      if (key.type === XSALSA20POLY1305) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.secretbox.nonceLength);
        let encryptionNonce;
        if (ad) {
          encryptionNonce = new Uint8Array(nonce);
          const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            encryptionNonce[i2] ^= adHash[i2];
          }
        } else {
          encryptionNonce = nonce;
        }
        const messageUint8 = strToBuf2(data);
        const box = import_tweetnacl.default.secretbox(messageUint8, encryptionNonce, key.secretKey);
        const fullMessage = new Uint8Array(nonce.length + box.length);
        fullMessage.set(nonce);
        fullMessage.set(box, nonce.length);
        const base64FullMessage = bytesOrObjectToB64(fullMessage);
        return base64FullMessage;
      } else if (key.type === CURVE25519XSALSA20POLY1305) {
        if (!key.publicKey) {
          throw new Error("Public key missing");
        }
        const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
        let encryptionNonce;
        if (ad) {
          encryptionNonce = new Uint8Array(nonce);
          const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            encryptionNonce[i2] ^= adHash[i2];
          }
        } else {
          encryptionNonce = nonce;
        }
        const messageUint8 = strToBuf2(data);
        const ephemeralKey = import_tweetnacl.default.box.keyPair();
        const box = import_tweetnacl.default.box(messageUint8, encryptionNonce, key.publicKey, ephemeralKey.secretKey);
        crypto.getRandomValues(ephemeralKey.secretKey);
        ephemeralKey.secretKey.fill(0);
        const fullMessage = new Uint8Array(import_tweetnacl.default.box.publicKeyLength + nonce.length + box.length);
        fullMessage.set(ephemeralKey.publicKey);
        fullMessage.set(nonce, import_tweetnacl.default.box.publicKeyLength);
        fullMessage.set(box, import_tweetnacl.default.box.publicKeyLength + nonce.length);
        const base64FullMessage = bytesOrObjectToB64(fullMessage);
        return base64FullMessage;
      }
      throw new Error("Unsupported algorithm");
    };
    decrypt = (inKey, data, ad) => {
      const key = typeof inKey === "string" ? deserializeKey(inKey) : inKey;
      if (process.env.ENABLE_UNSAFE_NULL_CRYPTO === "true" && key.type === ENULL) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        if (!data.startsWith(key.secretKey + ";") || !data.endsWith(";" + (ad !== null && ad !== void 0 ? ad : ""))) {
          throw new Error("Additional data mismatch");
        }
        return data.slice(String(key.secretKey).length + 1, data.length - 1 - (ad !== null && ad !== void 0 ? ad : "").length);
      }
      if (key.type === XSALSA20POLY1305) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        const messageWithNonceAsUint8Array = b64ToBuf2(data);
        const nonce = messageWithNonceAsUint8Array.slice(0, import_tweetnacl.default.secretbox.nonceLength);
        const message = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.secretbox.nonceLength, messageWithNonceAsUint8Array.length);
        if (ad) {
          const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            nonce[i2] ^= adHash[i2];
          }
        }
        const decrypted = import_tweetnacl.default.secretbox.open(message, nonce, key.secretKey);
        if (!decrypted) {
          throw new Error("Could not decrypt message");
        }
        return bufToStr(decrypted);
      } else if (key.type === CURVE25519XSALSA20POLY1305) {
        if (!key.secretKey) {
          throw new Error("Secret key missing");
        }
        const messageWithNonceAsUint8Array = b64ToBuf2(data);
        const ephemeralPublicKey = messageWithNonceAsUint8Array.slice(0, import_tweetnacl.default.box.publicKeyLength);
        const nonce = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.box.publicKeyLength, import_tweetnacl.default.box.publicKeyLength + import_tweetnacl.default.box.nonceLength);
        const message = messageWithNonceAsUint8Array.slice(import_tweetnacl.default.box.publicKeyLength + import_tweetnacl.default.box.nonceLength);
        if (ad) {
          const adHash = import_tweetnacl.default.hash(strToBuf2(ad));
          const len = Math.min(adHash.length, nonce.length);
          for (let i2 = 0; i2 < len; i2++) {
            nonce[i2] ^= adHash[i2];
          }
        }
        const decrypted = import_tweetnacl.default.box.open(message, nonce, ephemeralPublicKey, key.secretKey);
        if (!decrypted) {
          throw new Error("Could not decrypt message");
        }
        return bufToStr(decrypted);
      }
      throw new Error("Unsupported algorithm");
    };
  }
});
var ChelErrorGenerator;
var ChelErrorWarning;
var ChelErrorAlreadyProcessed;
var ChelErrorDBBadPreviousHEAD;
var ChelErrorDBConnection;
var ChelErrorUnexpected;
var ChelErrorKeyAlreadyExists;
var ChelErrorUnrecoverable;
var ChelErrorForkedChain;
var ChelErrorDecryptionError;
var ChelErrorDecryptionKeyNotFound;
var ChelErrorSignatureError;
var ChelErrorSignatureKeyUnauthorized;
var ChelErrorSignatureKeyNotFound;
var ChelErrorFetchServerTimeFailed;
var ChelErrorUnexpectedHttpResponseCode;
var ChelErrorResourceGone;
var init_errors = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/errors.mjs"() {
    ChelErrorGenerator = (name, base2 = Error) => class extends base2 {
      constructor(...params) {
        super(...params);
        this.name = name;
        if (params[1]?.cause !== this.cause) {
          Object.defineProperty(this, "cause", {
            configurable: true,
            writable: true,
            value: params[1]?.cause
          });
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    ChelErrorWarning = ChelErrorGenerator("ChelErrorWarning");
    ChelErrorAlreadyProcessed = ChelErrorGenerator("ChelErrorAlreadyProcessed");
    ChelErrorDBBadPreviousHEAD = ChelErrorGenerator("ChelErrorDBBadPreviousHEAD");
    ChelErrorDBConnection = ChelErrorGenerator("ChelErrorDBConnection");
    ChelErrorUnexpected = ChelErrorGenerator("ChelErrorUnexpected");
    ChelErrorKeyAlreadyExists = ChelErrorGenerator("ChelErrorKeyAlreadyExists");
    ChelErrorUnrecoverable = ChelErrorGenerator("ChelErrorUnrecoverable");
    ChelErrorForkedChain = ChelErrorGenerator("ChelErrorForkedChain");
    ChelErrorDecryptionError = ChelErrorGenerator("ChelErrorDecryptionError");
    ChelErrorDecryptionKeyNotFound = ChelErrorGenerator("ChelErrorDecryptionKeyNotFound", ChelErrorDecryptionError);
    ChelErrorSignatureError = ChelErrorGenerator("ChelErrorSignatureError");
    ChelErrorSignatureKeyUnauthorized = ChelErrorGenerator("ChelErrorSignatureKeyUnauthorized", ChelErrorSignatureError);
    ChelErrorSignatureKeyNotFound = ChelErrorGenerator("ChelErrorSignatureKeyNotFound", ChelErrorSignatureError);
    ChelErrorFetchServerTimeFailed = ChelErrorGenerator("ChelErrorFetchServerTimeFailed");
    ChelErrorUnexpectedHttpResponseCode = ChelErrorGenerator("ChelErrorUnexpectedHttpResponseCode");
    ChelErrorResourceGone = ChelErrorGenerator("ChelErrorResourceGone", ChelErrorUnexpectedHttpResponseCode);
  }
});
var serdesTagSymbol;
var serdesSerializeSymbol;
var serdesDeserializeSymbol;
var rawResult;
var serializer;
var deserializerTable;
var deserializer;
var init_esm7 = __esm({
  "node_modules/.deno/@chelonia+serdes@1.0.0/node_modules/@chelonia/serdes/dist/esm/index.js"() {
    serdesTagSymbol = Symbol("tag");
    serdesSerializeSymbol = Symbol("serialize");
    serdesDeserializeSymbol = Symbol("deserialize");
    rawResult = (rawResultSet, obj) => {
      rawResultSet.add(obj);
      return obj;
    };
    serializer = (data) => {
      const rawResultSet = /* @__PURE__ */ new WeakSet();
      const verbatim = [];
      const transferables = /* @__PURE__ */ new Set();
      const revokables = /* @__PURE__ */ new Set();
      const result = JSON.parse(JSON.stringify(data, (_key, value) => {
        if (value && typeof value === "object" && rawResultSet.has(value))
          return value;
        if (value === void 0)
          return rawResult(rawResultSet, ["_", "_"]);
        if (!value)
          return value;
        if (Array.isArray(value) && value[0] === "_")
          return rawResult(rawResultSet, ["_", "_", ...value]);
        if (value instanceof Map) {
          return rawResult(rawResultSet, ["_", "Map", Array.from(value.entries())]);
        }
        if (value instanceof Set) {
          return rawResult(rawResultSet, ["_", "Set", Array.from(value.values())]);
        }
        if (value instanceof Blob || value instanceof File) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        if (value instanceof Error) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          if (value.cause) {
            value.cause = serializer(value.cause).data;
          }
          return rawResult(rawResultSet, ["_", "_err", rawResult(rawResultSet, ["_", "_ref", pos]), value.name]);
        }
        if (value instanceof MessagePort || value instanceof ReadableStream || value instanceof WritableStream || value instanceof ArrayBuffer) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          transferables.add(value);
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        if (ArrayBuffer.isView(value)) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          transferables.add(value.buffer);
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        if (typeof value === "function") {
          const mc = new MessageChannel();
          mc.port1.onmessage = async (ev) => {
            try {
              try {
                const result2 = await value(...deserializer(ev.data[1]));
                const { data: data2, transferables: transferables2 } = serializer(result2);
                ev.data[0].postMessage([true, data2], transferables2);
              } catch (e2) {
                const { data: data2, transferables: transferables2 } = serializer(e2);
                ev.data[0].postMessage([false, data2], transferables2);
              }
            } catch (e2) {
              console.error("Async error on onmessage handler", e2);
            }
          };
          transferables.add(mc.port2);
          revokables.add(mc.port1);
          return rawResult(rawResultSet, ["_", "_fn", mc.port2]);
        }
        const proto3 = Object.getPrototypeOf(value);
        if (proto3?.constructor?.[serdesTagSymbol] && proto3.constructor[serdesSerializeSymbol]) {
          return rawResult(rawResultSet, ["_", "_custom", proto3.constructor[serdesTagSymbol], proto3.constructor[serdesSerializeSymbol](value)]);
        }
        return value;
      }), (_key, value) => {
        if (Array.isArray(value) && value[0] === "_" && value[1] === "_ref") {
          return verbatim[value[2]];
        }
        return value;
      });
      return {
        data: result,
        transferables: Array.from(transferables),
        revokables: Array.from(revokables)
      };
    };
    deserializerTable = /* @__PURE__ */ Object.create(null);
    deserializer = (data) => {
      const rawResultSet = /* @__PURE__ */ new WeakSet();
      const verbatim = [];
      return JSON.parse(JSON.stringify(data, (_key, value) => {
        if (value && typeof value === "object" && !rawResultSet.has(value) && !Array.isArray(value) && Object.getPrototypeOf(value) !== Object.prototype) {
          const pos = verbatim.length;
          verbatim[verbatim.length] = value;
          return rawResult(rawResultSet, ["_", "_ref", pos]);
        }
        return value;
      }), (_key, value) => {
        if (Array.isArray(value) && value[0] === "_") {
          switch (value[1]) {
            case "_":
              if (value.length >= 3) {
                return value.slice(2);
              } else {
                return;
              }
            // Map input (reconstruct Map)
            case "Map":
              return new Map(value[2]);
            // Set input (reconstruct Set)
            case "Set":
              return new Set(value[2]);
            // Custom object type (reconstruct if possible, otherwise throw an error)
            case "_custom":
              if (deserializerTable[value[2]]) {
                return deserializerTable[value[2]](value[3]);
              } else {
                throw new Error("Invalid or unknown tag: " + value[2]);
              }
            // These are literal values, return them
            case "_ref":
              return verbatim[value[2]];
            case "_err": {
              if (value[2].name !== value[3]) {
                value[2].name = value[3];
              }
              if (value[2].cause) {
                value[2].cause = deserializer(value[2].cause);
              }
              return value[2];
            }
            // These were functions converted to a MessagePort. Convert them on this
            // end back into functions using that port.
            case "_fn": {
              const mp = value[2];
              return (...args) => {
                return new Promise((resolve42, reject) => {
                  const mc = new MessageChannel();
                  const { data: data2, transferables } = serializer(args);
                  mc.port1.onmessage = (ev) => {
                    if (ev.data[0]) {
                      resolve42(deserializer(ev.data[1]));
                    } else {
                      reject(deserializer(ev.data[1]));
                    }
                  };
                  mp.postMessage([mc.port2, data2], [mc.port2, ...transferables]);
                });
              };
            }
          }
        }
        return value;
      });
    };
    deserializer.register = (ctor) => {
      if (typeof ctor === "function" && typeof ctor[serdesTagSymbol] === "string" && typeof ctor[serdesDeserializeSymbol] === "function") {
        deserializerTable[ctor[serdesTagSymbol]] = ctor[serdesDeserializeSymbol].bind(ctor);
      }
    };
  }
});
var rootStateFn;
var proto;
var wrapper;
var isSignedData;
var signData;
var verifySignatureData;
var signedOutgoingData;
var signedOutgoingDataWithRawKey;
var signedIncomingData;
var signedDataKeyId;
var isRawSignedData;
var rawSignedIncomingData;
var init_signedData = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/signedData.mjs"() {
    init_esm6();
    init_esm();
    init_esm4();
    init_errors();
    init_functions();
    rootStateFn = () => esm_default("chelonia/rootState");
    proto = Object.create(null, {
      _isSignedData: {
        value: true
      }
    });
    wrapper = (o2) => {
      return Object.setPrototypeOf(o2, proto);
    };
    isSignedData = (o2) => {
      return !!o2 && !!Object.getPrototypeOf(o2)?._isSignedData;
    };
    signData = function(stateOrContractID, sKeyId, data, extraFields, additionalKeys, additionalData) {
      const state = typeof stateOrContractID === "string" ? rootStateFn()[stateOrContractID] : stateOrContractID;
      if (!additionalData) {
        throw new ChelErrorSignatureError("Signature additional data must be provided");
      }
      const designatedKey = state?._vm?.authorizedKeys?.[sKeyId];
      if (!designatedKey?.purpose.includes("sig")) {
        throw new ChelErrorSignatureKeyNotFound(`Signing key ID ${sKeyId} is missing or is missing signing purpose`);
      }
      if (designatedKey._notAfterHeight != null) {
        const name = state._vm.authorizedKeys[sKeyId].name;
        const newKeyId = Object.values(state._vm?.authorizedKeys).find((v2) => v2._notAfterHeight == null && v2.name === name && v2.purpose.includes("sig"))?.id;
        if (!newKeyId) {
          throw new ChelErrorSignatureKeyNotFound(`Signing key ID ${sKeyId} has been revoked and no new key exists by the same name (${name})`);
        }
        sKeyId = newKeyId;
      }
      const key = additionalKeys[sKeyId];
      if (!key) {
        throw new ChelErrorSignatureKeyNotFound(`Missing signing key ${sKeyId}`);
      }
      const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
      const serializedData = JSON.stringify(data, (_, v2) => {
        if (v2 && has(v2, "serialize") && typeof v2.serialize === "function") {
          if (v2.serialize.length === 1) {
            return v2.serialize(additionalData);
          } else {
            return v2.serialize();
          }
        }
        return v2;
      });
      const payloadToSign = blake32Hash(`${blake32Hash(additionalData)}${blake32Hash(serializedData)}`);
      return {
        ...extraFields,
        _signedData: [serializedData, keyId(deserializedKey), sign(deserializedKey, payloadToSign)]
      };
    };
    verifySignatureData = function(state, height, data, additionalData) {
      if (!state) {
        throw new ChelErrorSignatureError("Missing contract state");
      }
      if (!isRawSignedData(data)) {
        throw new ChelErrorSignatureError("Invalid message format");
      }
      if (!Number.isSafeInteger(height) || height < 0) {
        throw new ChelErrorSignatureError(`Height ${height} is invalid or out of range`);
      }
      const [serializedMessage, sKeyId, signature] = data._signedData;
      const designatedKey = state._vm?.authorizedKeys?.[sKeyId];
      if (!designatedKey || height > designatedKey._notAfterHeight || height < designatedKey._notBeforeHeight || !designatedKey.purpose.includes("sig")) {
        if (process.env.CI) {
          console.error(`Key ${sKeyId} is unauthorized or expired for the current contract`, {
            designatedKey,
            height,
            state: JSON.parse(JSON.stringify(esm_default("state/vuex/state")))
          });
          Promise.reject(new ChelErrorSignatureKeyUnauthorized(`Key ${sKeyId} is unauthorized or expired for the current contract`));
        }
        throw new ChelErrorSignatureKeyUnauthorized(`Key ${sKeyId} is unauthorized or expired for the current contract`);
      }
      const deserializedKey = designatedKey.data;
      const payloadToSign = blake32Hash(`${blake32Hash(additionalData)}${blake32Hash(serializedMessage)}`);
      try {
        verifySignature(deserializedKey, payloadToSign, signature);
        const message = JSON.parse(serializedMessage);
        return [sKeyId, message];
      } catch (e2) {
        throw new ChelErrorSignatureError(e2?.message || e2);
      }
    };
    signedOutgoingData = (stateOrContractID, sKeyId, data, additionalKeys) => {
      if (!stateOrContractID || data === void 0 || !sKeyId) {
        throw new TypeError("Invalid invocation");
      }
      if (!additionalKeys) {
        additionalKeys = rootStateFn().secretKeys;
      }
      const extraFields = /* @__PURE__ */ Object.create(null);
      const boundStringValueFn = signData.bind(null, stateOrContractID, sKeyId, data, extraFields, additionalKeys);
      const serializefn = (additionalData) => boundStringValueFn(additionalData || "");
      return wrapper({
        get signingKeyId() {
          return sKeyId;
        },
        get serialize() {
          return serializefn;
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        },
        get recreate() {
          return (data2) => signedOutgoingData(stateOrContractID, sKeyId, data2, additionalKeys);
        },
        get get() {
          return (k) => extraFields[k];
        },
        get set() {
          return (k, v2) => {
            extraFields[k] = v2;
          };
        }
      });
    };
    signedOutgoingDataWithRawKey = (key, data) => {
      const sKeyId = keyId(key);
      const state = {
        _vm: {
          authorizedKeys: {
            [sKeyId]: {
              purpose: ["sig"],
              data: serializeKey(key, false),
              _notBeforeHeight: 0,
              _notAfterHeight: void 0
            }
          }
        }
      };
      const extraFields = /* @__PURE__ */ Object.create(null);
      const boundStringValueFn = signData.bind(null, state, sKeyId, data, extraFields, {
        [sKeyId]: key
      });
      const serializefn = (additionalData) => boundStringValueFn(additionalData || "");
      return wrapper({
        get signingKeyId() {
          return sKeyId;
        },
        get serialize() {
          return serializefn;
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        },
        get recreate() {
          return (data2) => signedOutgoingDataWithRawKey(key, data2);
        },
        get get() {
          return (k) => extraFields[k];
        },
        get set() {
          return (k, v2) => {
            extraFields[k] = v2;
          };
        }
      });
    };
    signedIncomingData = (contractID, state, data, height, additionalData, mapperFn) => {
      const stringValueFn = () => data;
      let verifySignedValue;
      const verifySignedValueFn = () => {
        if (verifySignedValue) {
          return verifySignedValue[1];
        }
        verifySignedValue = verifySignatureData(state || rootStateFn()[contractID], height, data, additionalData);
        if (mapperFn)
          verifySignedValue[1] = mapperFn(verifySignedValue[1]);
        return verifySignedValue[1];
      };
      return wrapper({
        get signingKeyId() {
          if (verifySignedValue)
            return verifySignedValue[0];
          return signedDataKeyId(data);
        },
        get serialize() {
          return stringValueFn;
        },
        get context() {
          return [contractID, data, height, additionalData];
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return verifySignedValueFn;
        },
        get toJSON() {
          return this.serialize;
        },
        get get() {
          return (k) => k !== "_signedData" ? data[k] : void 0;
        }
      });
    };
    signedDataKeyId = (data) => {
      if (!isRawSignedData(data)) {
        throw new ChelErrorSignatureError("Invalid message format");
      }
      return data._signedData[1];
    };
    isRawSignedData = (data) => {
      if (!data || typeof data !== "object" || !has(data, "_signedData") || !Array.isArray(data._signedData) || data._signedData.length !== 3 || data._signedData.map((v2) => typeof v2).filter((v2) => v2 !== "string").length !== 0) {
        return false;
      }
      return true;
    };
    rawSignedIncomingData = (data) => {
      if (!isRawSignedData(data)) {
        throw new ChelErrorSignatureError("Invalid message format");
      }
      const stringValueFn = () => data;
      let verifySignedValue;
      const verifySignedValueFn = () => {
        if (verifySignedValue) {
          return verifySignedValue[1];
        }
        verifySignedValue = [data._signedData[1], JSON.parse(data._signedData[0])];
        return verifySignedValue[1];
      };
      return wrapper({
        get signingKeyId() {
          if (verifySignedValue)
            return verifySignedValue[0];
          return signedDataKeyId(data);
        },
        get serialize() {
          return stringValueFn;
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return verifySignedValueFn;
        },
        get toJSON() {
          return this.serialize;
        },
        get get() {
          return (k) => k !== "_signedData" ? data[k] : void 0;
        }
      });
    };
  }
});
var rootStateFn2;
var proto2;
var wrapper2;
var isEncryptedData;
var encryptData;
var decryptData;
var encryptedOutgoingData;
var encryptedOutgoingDataWithRawKey;
var encryptedIncomingData;
var encryptedIncomingForeignData;
var encryptedDataKeyId;
var isRawEncryptedData;
var unwrapMaybeEncryptedData;
var maybeEncryptedIncomingData;
var init_encryptedData = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/encryptedData.mjs"() {
    init_esm6();
    init_esm();
    init_esm4();
    init_errors();
    init_signedData();
    rootStateFn2 = () => esm_default("chelonia/rootState");
    proto2 = Object.create(null, {
      _isEncryptedData: {
        value: true
      }
    });
    wrapper2 = (o2) => {
      return Object.setPrototypeOf(o2, proto2);
    };
    isEncryptedData = (o2) => {
      return !!o2 && !!Object.getPrototypeOf(o2)?._isEncryptedData;
    };
    encryptData = function(stateOrContractID, eKeyId, data, additionalData) {
      const state = typeof stateOrContractID === "string" ? rootStateFn2()[stateOrContractID] : stateOrContractID;
      const designatedKey = state?._vm?.authorizedKeys?.[eKeyId];
      if (!designatedKey?.purpose.includes("enc")) {
        throw new Error(`Encryption key ID ${eKeyId} is missing or is missing encryption purpose`);
      }
      if (designatedKey._notAfterHeight != null) {
        const name = state._vm.authorizedKeys[eKeyId].name;
        const newKeyId = Object.values(state._vm?.authorizedKeys).find((v2) => v2._notAfterHeight == null && v2.name === name && v2.purpose.includes("enc"))?.id;
        if (!newKeyId) {
          throw new Error(`Encryption key ID ${eKeyId} has been revoked and no new key exists by the same name (${name})`);
        }
        eKeyId = newKeyId;
      }
      const key = state._vm?.authorizedKeys?.[eKeyId].data;
      if (!key) {
        throw new Error(`Missing encryption key ${eKeyId}`);
      }
      const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
      return [
        keyId(deserializedKey),
        encrypt(deserializedKey, JSON.stringify(data, (_, v2) => {
          if (v2 && has(v2, "serialize") && typeof v2.serialize === "function") {
            if (v2.serialize.length === 1) {
              return v2.serialize(additionalData);
            } else {
              return v2.serialize();
            }
          }
          return v2;
        }), additionalData)
      ];
    };
    decryptData = function(state, height, data, additionalKeys, additionalData, validatorFn) {
      if (!state) {
        throw new ChelErrorDecryptionError("Missing contract state");
      }
      if (typeof data.valueOf === "function")
        data = data.valueOf();
      if (!isRawEncryptedData(data)) {
        throw new ChelErrorDecryptionError("Invalid message format");
      }
      const [eKeyId, message] = data;
      const key = additionalKeys[eKeyId];
      if (!key) {
        throw new ChelErrorDecryptionKeyNotFound(`Key ${eKeyId} not found`, { cause: eKeyId });
      }
      const designatedKey = state._vm?.authorizedKeys?.[eKeyId];
      if (!designatedKey || height > designatedKey._notAfterHeight || height < designatedKey._notBeforeHeight || !designatedKey.purpose.includes("enc")) {
        throw new ChelErrorUnexpected(`Key ${eKeyId} is unauthorized or expired for the current contract`);
      }
      const deserializedKey = typeof key === "string" ? deserializeKey(key) : key;
      try {
        const result = JSON.parse(decrypt(deserializedKey, message, additionalData));
        if (typeof validatorFn === "function")
          validatorFn(result, eKeyId);
        return result;
      } catch (e2) {
        throw new ChelErrorDecryptionError(e2?.message || e2);
      }
    };
    encryptedOutgoingData = (stateOrContractID, eKeyId, data) => {
      if (!stateOrContractID || data === void 0 || !eKeyId) {
        throw new TypeError("Invalid invocation");
      }
      const boundStringValueFn = encryptData.bind(null, stateOrContractID, eKeyId, data);
      return wrapper2({
        get encryptionKeyId() {
          return eKeyId;
        },
        get serialize() {
          return (additionalData) => boundStringValueFn(additionalData || "");
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        }
      });
    };
    encryptedOutgoingDataWithRawKey = (key, data) => {
      if (data === void 0 || !key)
        throw new TypeError("Invalid invocation");
      const eKeyId = keyId(key);
      const state = {
        _vm: {
          authorizedKeys: {
            [eKeyId]: {
              purpose: ["enc"],
              data: serializeKey(key, false),
              _notBeforeHeight: 0,
              _notAfterHeight: void 0
            }
          }
        }
      };
      const boundStringValueFn = encryptData.bind(null, state, eKeyId, data);
      return wrapper2({
        get encryptionKeyId() {
          return eKeyId;
        },
        get serialize() {
          return (additionalData) => boundStringValueFn(additionalData || "");
        },
        get toString() {
          return (additionalData) => JSON.stringify(this.serialize(additionalData));
        },
        get valueOf() {
          return () => data;
        }
      });
    };
    encryptedIncomingData = (contractID, state, data, height, additionalKeys, additionalData, validatorFn) => {
      let decryptedValue;
      const decryptedValueFn = () => {
        if (decryptedValue) {
          return decryptedValue;
        }
        if (!state || !additionalKeys) {
          const rootState = rootStateFn2();
          state = state || rootState[contractID];
          additionalKeys = additionalKeys ?? rootState.secretKeys;
        }
        decryptedValue = decryptData(state, height, data, additionalKeys, additionalData || "", validatorFn);
        if (isRawSignedData(decryptedValue)) {
          decryptedValue = signedIncomingData(contractID, state, decryptedValue, height, additionalData || "");
        }
        return decryptedValue;
      };
      return wrapper2({
        get encryptionKeyId() {
          return encryptedDataKeyId(data);
        },
        get serialize() {
          return () => data;
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return decryptedValueFn;
        },
        get toJSON() {
          return this.serialize;
        }
      });
    };
    encryptedIncomingForeignData = (contractID, _0, data, _1, additionalKeys, additionalData, validatorFn) => {
      let decryptedValue;
      const decryptedValueFn = () => {
        if (decryptedValue) {
          return decryptedValue;
        }
        const rootState = rootStateFn2();
        const state = rootState[contractID];
        decryptedValue = decryptData(state, NaN, data, additionalKeys ?? rootState.secretKeys, additionalData || "", validatorFn);
        if (isRawSignedData(decryptedValue)) {
          return signedIncomingData(contractID, state, decryptedValue, NaN, additionalData || "");
        }
        return decryptedValue;
      };
      return wrapper2({
        get encryptionKeyId() {
          return encryptedDataKeyId(data);
        },
        get serialize() {
          return () => data;
        },
        get toString() {
          return () => JSON.stringify(this.serialize());
        },
        get valueOf() {
          return decryptedValueFn;
        },
        get toJSON() {
          return this.serialize;
        }
      });
    };
    encryptedDataKeyId = (data) => {
      if (!isRawEncryptedData(data)) {
        throw new ChelErrorDecryptionError("Invalid message format");
      }
      return data[0];
    };
    isRawEncryptedData = (data) => {
      if (!Array.isArray(data) || data.length !== 2 || data.map((v2) => typeof v2).filter((v2) => v2 !== "string").length !== 0) {
        return false;
      }
      return true;
    };
    unwrapMaybeEncryptedData = (data) => {
      if (data == null)
        return;
      if (isEncryptedData(data)) {
        try {
          return {
            encryptionKeyId: data.encryptionKeyId,
            data: data.valueOf()
          };
        } catch (e2) {
          console.warn("unwrapMaybeEncryptedData: Unable to decrypt", e2);
        }
      } else {
        return {
          encryptionKeyId: null,
          data
        };
      }
    };
    maybeEncryptedIncomingData = (contractID, state, data, height, additionalKeys, additionalData, validatorFn) => {
      if (isRawEncryptedData(data)) {
        return encryptedIncomingData(contractID, state, data, height, additionalKeys, additionalData, validatorFn);
      } else {
        validatorFn?.(data, "");
        return data;
      }
    };
  }
});
function messageToParams(head, message) {
  let mapping;
  return {
    direction: has(message, "recreate") ? "outgoing" : "incoming",
    // Lazy computation of mapping to prevent us from serializing outgoing
    // atomic operations
    get mapping() {
      if (!mapping) {
        const headJSON = JSON.stringify(head);
        const messageJSON = { ...message.serialize(headJSON), head: headJSON };
        const value = JSON.stringify(messageJSON);
        mapping = {
          key: createCID(value, multicodes.SHELTER_CONTRACT_DATA),
          value
        };
      }
      return mapping;
    },
    head,
    signedMessageData: message
  };
}
var decryptedAndVerifiedDeserializedMessage;
var SPMessage;
var keyOps;
var init_SPMessage = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/SPMessage.mjs"() {
    init_esm6();
    init_esm7();
    init_esm4();
    init_encryptedData();
    init_functions();
    init_signedData();
    decryptedAndVerifiedDeserializedMessage = (head, headJSON, contractID, parsedMessage, additionalKeys, state) => {
      const op = head.op;
      const height = head.height;
      const message = op === SPMessage.OP_ACTION_ENCRYPTED ? encryptedIncomingData(contractID, state, parsedMessage, height, additionalKeys, headJSON, void 0) : parsedMessage;
      if ([SPMessage.OP_KEY_ADD, SPMessage.OP_KEY_UPDATE].includes(op)) {
        return message.map((key) => {
          return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, (key2) => {
            if (key2.meta?.private?.content) {
              key2.meta.private.content = encryptedIncomingData(contractID, state, key2.meta.private.content, height, additionalKeys, headJSON, (value) => {
                const computedKeyId = keyId(value);
                if (computedKeyId !== key2.id) {
                  throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key2.id} but got ${computedKeyId}`);
                }
              });
            }
            if (key2.meta?.keyRequest?.reference) {
              try {
                key2.meta.keyRequest.reference = maybeEncryptedIncomingData(contractID, state, key2.meta.keyRequest.reference, height, additionalKeys, headJSON)?.valueOf();
              } catch {
                delete key2.meta.keyRequest.reference;
              }
            }
            if (key2.meta?.keyRequest?.contractID) {
              try {
                key2.meta.keyRequest.contractID = maybeEncryptedIncomingData(contractID, state, key2.meta.keyRequest.contractID, height, additionalKeys, headJSON)?.valueOf();
              } catch {
                delete key2.meta.keyRequest.contractID;
              }
            }
          });
        });
      }
      if (op === SPMessage.OP_CONTRACT) {
        message.keys = message.keys?.map((key) => {
          return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, (key2) => {
            if (!key2.meta?.private?.content)
              return;
            const decryptionFn = encryptedIncomingData;
            const decryptionContract = contractID;
            key2.meta.private.content = decryptionFn(decryptionContract, state, key2.meta.private.content, height, additionalKeys, headJSON, (value) => {
              const computedKeyId = keyId(value);
              if (computedKeyId !== key2.id) {
                throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key2.id} but got ${computedKeyId}`);
              }
            });
          });
        });
      }
      if (op === SPMessage.OP_KEY_SHARE) {
        return maybeEncryptedIncomingData(contractID, state, message, height, additionalKeys, headJSON, (message2) => {
          message2.keys?.forEach((key) => {
            if (!key.meta?.private?.content)
              return;
            const decryptionFn = message2.foreignContractID ? encryptedIncomingForeignData : encryptedIncomingData;
            const decryptionContract = message2.foreignContractID || contractID;
            key.meta.private.content = decryptionFn(decryptionContract, state, key.meta.private.content, height, additionalKeys, headJSON, (value) => {
              const computedKeyId = keyId(value);
              if (computedKeyId !== key.id) {
                throw new Error(`Key ID mismatch. Expected to decrypt key ID ${key.id} but got ${computedKeyId}`);
              }
            });
          });
        });
      }
      if (op === SPMessage.OP_KEY_REQUEST) {
        return maybeEncryptedIncomingData(contractID, state, message, height, additionalKeys, headJSON, (msg) => {
          msg.replyWith = signedIncomingData(msg.contractID, void 0, msg.replyWith, msg.height, headJSON);
        });
      }
      if (op === SPMessage.OP_ACTION_UNENCRYPTED && isRawSignedData(message)) {
        return signedIncomingData(contractID, state, message, height, headJSON);
      }
      if (op === SPMessage.OP_ACTION_ENCRYPTED) {
        return message;
      }
      if (op === SPMessage.OP_KEY_DEL) {
        return message.map((key) => {
          return maybeEncryptedIncomingData(contractID, state, key, height, additionalKeys, headJSON, void 0);
        });
      }
      if (op === SPMessage.OP_KEY_REQUEST_SEEN) {
        return maybeEncryptedIncomingData(contractID, state, parsedMessage, height, additionalKeys, headJSON, void 0);
      }
      if (op === SPMessage.OP_ATOMIC) {
        return message.map(([opT, opV]) => [
          opT,
          decryptedAndVerifiedDeserializedMessage({ ...head, op: opT }, headJSON, contractID, opV, additionalKeys, state)
        ]);
      }
      return message;
    };
    SPMessage = class _SPMessage {
      // flow type annotations to make flow happy
      _mapping;
      _head;
      _message;
      _signedMessageData;
      _direction;
      _decryptedValue;
      _innerSigningKeyId;
      static OP_CONTRACT = "c";
      static OP_ACTION_ENCRYPTED = "ae";
      // e2e-encrypted action
      static OP_ACTION_UNENCRYPTED = "au";
      // publicly readable action
      static OP_KEY_ADD = "ka";
      // add this key to the list of keys allowed to write to this contract, or update an existing key
      static OP_KEY_DEL = "kd";
      // remove this key from authorized keys
      static OP_KEY_UPDATE = "ku";
      // update key in authorized keys
      static OP_PROTOCOL_UPGRADE = "pu";
      static OP_PROP_SET = "ps";
      // set a public key/value pair
      static OP_PROP_DEL = "pd";
      // delete a public key/value pair
      static OP_CONTRACT_AUTH = "ca";
      // authorize a contract
      static OP_CONTRACT_DEAUTH = "cd";
      // deauthorize a contract
      static OP_ATOMIC = "a";
      // atomic op
      static OP_KEY_SHARE = "ks";
      // key share
      static OP_KEY_REQUEST = "kr";
      // key request
      static OP_KEY_REQUEST_SEEN = "krs";
      // key request response
      // eslint-disable-next-line camelcase
      static createV1_0({
        contractID,
        previousHEAD = null,
        previousKeyOp = null,
        // Height will be automatically set to the correct value when sending
        // The reason to set it to Number.MAX_SAFE_INTEGER is so that we can
        // temporarily process outgoing messages with signature validation
        // still working
        height = Number.MAX_SAFE_INTEGER,
        op,
        manifest
      }) {
        const head = {
          version: "1.0.0",
          previousHEAD,
          previousKeyOp,
          height,
          contractID,
          op: op[0],
          manifest
        };
        return new this(messageToParams(head, op[1]));
      }
      // SPMessage.cloneWith could be used when make a SPMessage object having the same id()
      // https://github.com/okTurtles/group-income/issues/1503
      static cloneWith(targetHead, targetOp, sources) {
        const head = Object.assign({}, targetHead, sources);
        return new this(messageToParams(head, targetOp[1]));
      }
      static deserialize(value, additionalKeys, state, unwrapMaybeEncryptedDataFn = unwrapMaybeEncryptedData) {
        if (!value)
          throw new Error(`deserialize bad value: ${value}`);
        const { head: headJSON, ...parsedValue } = JSON.parse(value);
        const head = JSON.parse(headJSON);
        const contractID = head.op === _SPMessage.OP_CONTRACT ? createCID(value, multicodes.SHELTER_CONTRACT_DATA) : head.contractID;
        if (!state?._vm?.authorizedKeys && head.op === _SPMessage.OP_CONTRACT) {
          const value2 = rawSignedIncomingData(parsedValue);
          const authorizedKeys = Object.fromEntries(value2.valueOf()?.keys.map((wk) => {
            const k = unwrapMaybeEncryptedDataFn(wk);
            if (!k)
              return null;
            return [k.data.id, k.data];
          }).filter(Boolean));
          state = {
            _vm: {
              type: head.type,
              authorizedKeys
            }
          };
        }
        const signedMessageData = signedIncomingData(contractID, state, parsedValue, head.height, headJSON, (message) => decryptedAndVerifiedDeserializedMessage(head, headJSON, contractID, message, additionalKeys, state));
        return new this({
          direction: "incoming",
          mapping: { key: createCID(value, multicodes.SHELTER_CONTRACT_DATA), value },
          head,
          signedMessageData
        });
      }
      static deserializeHEAD(value) {
        if (!value)
          throw new Error(`deserialize bad value: ${value}`);
        let head, hash2;
        const result = {
          get head() {
            if (head === void 0) {
              head = JSON.parse(JSON.parse(value).head);
            }
            return head;
          },
          get hash() {
            if (!hash2) {
              hash2 = createCID(value, multicodes.SHELTER_CONTRACT_DATA);
            }
            return hash2;
          },
          get contractID() {
            return result.head?.contractID ?? result.hash;
          },
          // `description` is not a getter to prevent the value from being copied
          // if the object is cloned or serialized
          description() {
            const type = this.head.op;
            return `<op_${type}|${this.hash} of ${this.contractID}>`;
          },
          get isFirstMessage() {
            return !result.head?.contractID;
          }
        };
        return result;
      }
      constructor(params) {
        this._direction = params.direction;
        this._mapping = params.mapping;
        this._head = params.head;
        this._signedMessageData = params.signedMessageData;
        const type = this.opType();
        let atomicTopLevel = true;
        const validate = (type2, message) => {
          switch (type2) {
            case _SPMessage.OP_CONTRACT:
              if (!this.isFirstMessage() || !atomicTopLevel) {
                throw new Error("OP_CONTRACT: must be first message");
              }
              break;
            case _SPMessage.OP_ATOMIC:
              if (!atomicTopLevel) {
                throw new Error("OP_ATOMIC not allowed inside of OP_ATOMIC");
              }
              if (!Array.isArray(message)) {
                throw new TypeError("OP_ATOMIC must be of an array type");
              }
              atomicTopLevel = false;
              message.forEach(([t, m3]) => validate(t, m3));
              break;
            case _SPMessage.OP_KEY_ADD:
            case _SPMessage.OP_KEY_DEL:
            case _SPMessage.OP_KEY_UPDATE:
              if (!Array.isArray(message)) {
                throw new TypeError("OP_KEY_{ADD|DEL|UPDATE} must be of an array type");
              }
              break;
            case _SPMessage.OP_KEY_SHARE:
            case _SPMessage.OP_KEY_REQUEST:
            case _SPMessage.OP_KEY_REQUEST_SEEN:
            case _SPMessage.OP_ACTION_ENCRYPTED:
            case _SPMessage.OP_ACTION_UNENCRYPTED:
              break;
            default:
              throw new Error(`unsupported op: ${type2}`);
          }
        };
        Object.defineProperty(this, "_message", {
          get: /* @__PURE__ */ ((validated) => () => {
            const message = this._signedMessageData.valueOf();
            if (!validated) {
              validate(type, message);
              validated = true;
            }
            return message;
          })()
        });
      }
      decryptedValue() {
        if (this._decryptedValue)
          return this._decryptedValue;
        try {
          const value = this.message();
          const data = unwrapMaybeEncryptedData(value);
          if (data?.data) {
            if (isSignedData(data.data)) {
              this._innerSigningKeyId = data.data.signingKeyId;
              this._decryptedValue = data.data.valueOf();
            } else {
              this._decryptedValue = data.data;
            }
          }
          return this._decryptedValue;
        } catch {
          return void 0;
        }
      }
      innerSigningKeyId() {
        if (!this._decryptedValue) {
          this.decryptedValue();
        }
        return this._innerSigningKeyId;
      }
      head() {
        return this._head;
      }
      message() {
        return this._message;
      }
      op() {
        return [this.head().op, this.message()];
      }
      rawOp() {
        return [this.head().op, this._signedMessageData];
      }
      opType() {
        return this.head().op;
      }
      opValue() {
        return this.message();
      }
      signingKeyId() {
        return this._signedMessageData.signingKeyId;
      }
      manifest() {
        return this.head().manifest;
      }
      description() {
        const type = this.opType();
        let desc = `<op_${type}`;
        if (type === _SPMessage.OP_ACTION_UNENCRYPTED) {
          try {
            const value = this.opValue().valueOf();
            if (typeof value.action === "string") {
              desc += `|${value.action}`;
            }
          } catch (e2) {
            console.warn("Error on .description()", this.hash(), e2);
          }
        }
        return `${desc}|${this.hash()} of ${this.contractID()}>`;
      }
      isFirstMessage() {
        return !this.head().contractID;
      }
      contractID() {
        return this.head().contractID || this.hash();
      }
      serialize() {
        return this._mapping.value;
      }
      hash() {
        return this._mapping.key;
      }
      previousKeyOp() {
        return this._head.previousKeyOp;
      }
      height() {
        return this._head.height;
      }
      id() {
        throw new Error("SPMessage.id() was called but it has been removed");
      }
      direction() {
        return this._direction;
      }
      // `isKeyOp` is used to filter out non-key operations for providing an
      // abbreviated chain fo snapshot validation
      isKeyOp() {
        let value;
        return !!(keyOps.includes(this.opType()) || this.opType() === _SPMessage.OP_ATOMIC && Array.isArray(value = this.opValue()) && value.some(([opT]) => {
          return keyOps.includes(opT);
        }));
      }
      static get [serdesTagSymbol]() {
        return "SPMessage";
      }
      static [serdesSerializeSymbol](m3) {
        return [m3.serialize(), m3.direction(), m3.decryptedValue(), m3.innerSigningKeyId()];
      }
      static [serdesDeserializeSymbol]([serialized, direction, decryptedValue, innerSigningKeyId]) {
        const m3 = _SPMessage.deserialize(serialized);
        m3._direction = direction;
        m3._decryptedValue = decryptedValue;
        m3._innerSigningKeyId = innerSigningKeyId;
        return m3;
      }
    };
    keyOps = [
      SPMessage.OP_CONTRACT,
      SPMessage.OP_KEY_ADD,
      SPMessage.OP_KEY_DEL,
      SPMessage.OP_KEY_UPDATE
    ];
  }
});
var headPrefix;
var getContractIdFromLogHead;
var getLogHead;
var checkKey;
var parsePrefixableKey;
var prefixHandlers;
var dbPrimitiveSelectors;
var db_default;
var init_db = __esm({
  "node_modules/.deno/@chelonia+lib@1.2.7/node_modules/@chelonia/lib/dist/esm/db.mjs"() {
    init_esm3();
    init_esm2();
    init_esm();
    init_SPMessage();
    init_errors();
    headPrefix = "head=";
    getContractIdFromLogHead = (key) => {
      if (!key.startsWith(headPrefix))
        return;
      return key.slice(headPrefix.length);
    };
    getLogHead = (contractID) => `${headPrefix}${contractID}`;
    checkKey = (key) => {
      if (/[\x00-\x1f\x7f\t\\/<>:"|?*]/.test(key)) {
        throw new Error(`bad key: ${JSON.stringify(key)}`);
      }
    };
    parsePrefixableKey = (key) => {
      const i2 = key.indexOf(":");
      if (i2 === -1) {
        return ["", key];
      }
      const prefix = key.slice(0, i2 + 1);
      if (prefix in prefixHandlers) {
        return [prefix, key.slice(prefix.length)];
      }
      throw new ChelErrorDBConnection(`Unknown prefix in '${key}'.`);
    };
    prefixHandlers = {
      // Decode buffers, but don't transform other values.
      "": (value) => Buffer5.isBuffer(value) ? value.toString("utf8") : value,
      "any:": (value) => value
      /*
      // 2025-03-24: Commented out because it's not used; currently, only `any:`
      // is used in the `/file` route.
      // Throw if the value if not a buffer.
      'blob:': value => {
        if (Buffer.isBuffer(value)) {
          return value
        }
        throw new ChelErrorDBConnection('Unexpected value: expected a buffer.')
      }
      */
    };
    esm_default("sbp/selectors/unsafe", ["chelonia.db/get", "chelonia.db/set", "chelonia.db/delete"]);
    dbPrimitiveSelectors = process.env.LIGHTWEIGHT_CLIENT === "true" ? {
      "chelonia.db/get": function(key) {
        const id = getContractIdFromLogHead(key);
        if (!id)
          return Promise.resolve();
        const state = esm_default("chelonia/rootState").contracts[id];
        const value = state?.HEAD ? JSON.stringify({
          HEAD: state.HEAD,
          height: state.height,
          previousKeyOp: state.previousKeyOp
        }) : void 0;
        return Promise.resolve(value);
      },
      "chelonia.db/set": function() {
        return Promise.resolve();
      },
      "chelonia.db/delete": function() {
        return Promise.resolve(true);
      }
    } : {
      // eslint-disable-next-line require-await
      "chelonia.db/get": async function(prefixableKey) {
        const [prefix, key] = parsePrefixableKey(prefixableKey);
        const value = esm_default("okTurtles.data/get", key);
        if (value === void 0) {
          return;
        }
        return prefixHandlers[prefix](value);
      },
      // eslint-disable-next-line require-await
      "chelonia.db/set": async function(key, value) {
        checkKey(key);
        return esm_default("okTurtles.data/set", key, value);
      },
      // eslint-disable-next-line require-await
      "chelonia.db/delete": async function(key) {
        return esm_default("okTurtles.data/delete", key);
      }
    };
    db_default = esm_default("sbp/selectors/register", {
      ...dbPrimitiveSelectors,
      "chelonia/db/getEntryMeta": async (contractID, height) => {
        const entryMetaJson = await esm_default("chelonia.db/get", `_private_hidx=${contractID}#${height}`);
        if (!entryMetaJson)
          return;
        return JSON.parse(entryMetaJson);
      },
      "chelonia/db/setEntryMeta": async (contractID, height, entryMeta) => {
        const entryMetaJson = JSON.stringify(entryMeta);
        await esm_default("chelonia.db/set", `_private_hidx=${contractID}#${height}`, entryMetaJson);
      },
      "chelonia/db/latestHEADinfo": async (contractID) => {
        const r = await esm_default("chelonia.db/get", getLogHead(contractID));
        return r && JSON.parse(r);
      },
      "chelonia/db/deleteLatestHEADinfo": (contractID) => {
        return esm_default("chelonia.db/set", getLogHead(contractID), "");
      },
      "chelonia/db/getEntry": async function(hash2) {
        try {
          const value = await esm_default("chelonia.db/get", hash2);
          if (!value)
            throw new Error(`no entry for ${hash2}!`);
          return SPMessage.deserialize(value, this.transientSecretKeys, void 0, this.config.unwrapMaybeEncryptedData);
        } catch (e2) {
          throw new ChelErrorDBConnection(`${e2.name} during getEntry: ${e2.message}`);
        }
      },
      "chelonia/db/addEntry": function(entry) {
        return esm_default("okTurtles.eventQueue/queueEvent", `chelonia/db/${entry.contractID()}`, ["chelonia/private/db/addEntry", entry]);
      },
      // NEVER call this directly yourself! _always_ call 'chelonia/db/addEntry' instead
      "chelonia/private/db/addEntry": async function(entry) {
        try {
          const { previousHEAD: entryPreviousHEAD, previousKeyOp: entryPreviousKeyOp, height: entryHeight } = entry.head();
          const contractID = entry.contractID();
          if (await esm_default("chelonia.db/get", entry.hash())) {
            console.warn(`[chelonia.db] entry exists: ${entry.hash()}`);
            return entry.hash();
          }
          const HEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
          if (!entry.isFirstMessage()) {
            if (!HEADinfo) {
              throw new Error(`No latest HEAD for ${contractID} when attempting to process entry with previous HEAD ${entryPreviousHEAD} at height ${entryHeight}`);
            }
            const { HEAD: contractHEAD, previousKeyOp: contractPreviousKeyOp, height: contractHeight } = HEADinfo;
            if (entryPreviousHEAD !== contractHEAD) {
              console.warn(`[chelonia.db] bad previousHEAD: ${entryPreviousHEAD}! Expected: ${contractHEAD} for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`bad previousHEAD: ${entryPreviousHEAD}. Expected ${contractHEAD} for contractID: ${contractID}`);
            } else if (entryPreviousKeyOp !== contractPreviousKeyOp) {
              console.error(`[chelonia.db] bad previousKeyOp: ${entryPreviousKeyOp}! Expected: ${contractPreviousKeyOp} for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`bad previousKeyOp: ${entryPreviousKeyOp}. Expected ${contractPreviousKeyOp} for contractID: ${contractID}`);
            } else if (!Number.isSafeInteger(entryHeight) || entryHeight !== contractHeight + 1) {
              console.error(`[chelonia.db] bad height: ${entryHeight}! Expected: ${contractHeight + 1} for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`[chelonia.db] bad height: ${entryHeight}! Expected: ${contractHeight + 1} for contractID: ${contractID}`);
            }
          } else {
            if (HEADinfo) {
              console.error(`[chelonia.db] bad previousHEAD: ${entryPreviousHEAD}! Expected: <null> for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`bad previousHEAD: ${entryPreviousHEAD}. Expected <null> for contractID: ${contractID}`);
            } else if (entryHeight !== 0) {
              console.error(`[chelonia.db] bad height: ${entryHeight}! Expected: 0 for contractID: ${contractID}`);
              throw new ChelErrorDBBadPreviousHEAD(`[chelonia.db] bad height: ${entryHeight}! Expected: 0 for contractID: ${contractID}`);
            }
          }
          await esm_default("chelonia.db/set", entry.hash(), entry.serialize());
          await esm_default("chelonia.db/set", getLogHead(contractID), JSON.stringify({
            HEAD: entry.hash(),
            previousKeyOp: entry.isKeyOp() ? entry.hash() : entry.previousKeyOp(),
            height: entry.height()
          }));
          console.debug(`[chelonia.db] HEAD for ${contractID} updated to:`, entry.hash());
          await esm_default("chelonia/db/setEntryMeta", contractID, entryHeight, {
            // The hash is used for reverse lookups (height to CID)
            hash: entry.hash(),
            // The date isn't currently used, but will be used for filtering messages
            date: (/* @__PURE__ */ new Date()).toISOString(),
            // isKeyOp is used for filtering messages (the actual filtering is
            // done more efficiently a separate index key, but `isKeyOp` allows
            // us to bootstrap this process without having to load the full message)
            // The separate index key bears the prefix `_private_keyop_idx_`.
            ...entry.isKeyOp() && { isKeyOp: true }
          });
          return entry.hash();
        } catch (e2) {
          if (e2.name.includes("ErrorDB")) {
            throw e2;
          }
          throw new ChelErrorDBConnection(`${e2.name} during addEntry: ${e2.message}`);
        }
      },
      "chelonia/db/lastEntry": async function(contractID) {
        try {
          const latestHEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
          if (!latestHEADinfo)
            throw new Error(`contract ${contractID} has no latest hash!`);
          return esm_default("chelonia/db/getEntry", latestHEADinfo.HEAD);
        } catch (e2) {
          throw new ChelErrorDBConnection(`${e2.name} during lastEntry: ${e2.message}`);
        }
      }
    });
  }
});
var require_assertError = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assertError.js"(exports, module) {
    "use strict";
    module.exports = class AssertError extends Error {
      name = "AssertError";
      constructor(message, ctor) {
        super(message || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, ctor);
        }
      }
    };
  }
});
var require_stringify = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/stringify.js"(exports, module) {
    "use strict";
    module.exports = function(...args) {
      try {
        return JSON.stringify(...args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
  }
});
var require_assert = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/assert.js"(exports, module) {
    "use strict";
    var AssertError = require_assertError();
    var Stringify = require_stringify();
    var assert2 = module.exports = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
      });
      throw new AssertError(msgs.join(" "), assert2);
    };
  }
});
var require_reach = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reach.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var internals = {};
    module.exports = function(obj, chain, options2) {
      if (chain === false || chain === null || chain === void 0) {
        return obj;
      }
      options2 = options2 || {};
      if (typeof options2 === "string") {
        options2 = { separator: options2 };
      }
      const isChainArray = Array.isArray(chain);
      Assert(!isChainArray || !options2.separator, "Separator option is not valid for array-based chain");
      const path2 = isChainArray ? chain : chain.split(options2.separator || ".");
      let ref = obj;
      for (let i2 = 0; i2 < path2.length; ++i2) {
        let key = path2[i2];
        const type = options2.iterables && internals.iterables(ref);
        if (Array.isArray(ref) || type === "set") {
          const number = Number(key);
          if (Number.isInteger(number)) {
            key = number < 0 ? ref.length + number : number;
          }
        }
        if (!ref || typeof ref === "function" && options2.functions === false || // Defaults to true
        !type && ref[key] === void 0) {
          Assert(!options2.strict || i2 + 1 === path2.length, "Missing segment", key, "in reach path ", chain);
          Assert(typeof ref === "object" || options2.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options2.default;
          break;
        }
        if (!type) {
          ref = ref[key];
        } else if (type === "set") {
          ref = [...ref][key];
        } else {
          ref = ref.get(key);
        }
      }
      return ref;
    };
    internals.iterables = function(ref) {
      if (ref instanceof Set) {
        return "set";
      }
      if (ref instanceof Map) {
        return "map";
      }
    };
  }
});
var require_types = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/types.js"(exports, module) {
    "use strict";
    var internals = {};
    exports = module.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      // $lab:coverage:ignore$
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      url: URL.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      ["[object Error]", exports.error],
      ["[object Map]", exports.map],
      ["[object Promise]", exports.promise],
      ["[object Set]", exports.set],
      ["[object URL]", exports.url],
      ["[object WeakMap]", exports.weakMap],
      ["[object WeakSet]", exports.weakSet]
    ]);
    exports.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports.buffer;
      }
      if (obj instanceof Date) {
        return exports.date;
      }
      if (obj instanceof RegExp) {
        return exports.regex;
      }
      if (obj instanceof Error) {
        return exports.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports.generic;
    };
  }
});
var require_utils = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/utils.js"(exports) {
    "use strict";
    exports.keys = function(obj, options2 = {}) {
      return options2.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
  }
});
var require_clone = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/clone.js"(exports, module) {
    "use strict";
    var Reach = require_reach();
    var Types = require_types();
    var Utils = require_utils();
    var internals = {
      needsProtoHack: /* @__PURE__ */ new Set([Types.set, Types.map, Types.weakSet, Types.weakMap]),
      structuredCloneExists: typeof structuredClone === "function"
    };
    module.exports = internals.clone = function(obj, options2 = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      let clone = internals.clone;
      let seen = _seen;
      if (options2.shallow) {
        if (options2.shallow !== true) {
          return internals.cloneWithShallow(obj, options2);
        }
        clone = (value) => value;
      } else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
          return lookup;
        }
      } else {
        seen = /* @__PURE__ */ new Map();
      }
      const baseProto = Types.getInternalProto(obj);
      switch (baseProto) {
        case Types.buffer:
          return Buffer?.from(obj);
        case Types.date:
          return new Date(obj.getTime());
        case Types.regex:
        case Types.url:
          return new baseProto.constructor(obj);
      }
      const newObj = internals.base(obj, baseProto, options2);
      if (newObj === obj) {
        return obj;
      }
      if (seen) {
        seen.set(obj, newObj);
      }
      if (baseProto === Types.set) {
        for (const value of obj) {
          newObj.add(clone(value, options2, seen));
        }
      } else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
          newObj.set(key, clone(value, options2, seen));
        }
      }
      const keys = Utils.keys(obj, options2);
      for (const key of keys) {
        if (key === "__proto__") {
          continue;
        }
        if (baseProto === Types.array && key === "length") {
          newObj.length = obj.length;
          continue;
        }
        if (internals.structuredCloneExists && baseProto === Types.error && key === "stack") {
          continue;
        }
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, key, descriptor);
          } else if (descriptor.enumerable) {
            newObj[key] = clone(obj[key], options2, seen);
          } else {
            Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options2, seen) });
          }
        } else {
          Object.defineProperty(newObj, key, {
            enumerable: true,
            writable: true,
            configurable: true,
            value: clone(obj[key], options2, seen)
          });
        }
      }
      return newObj;
    };
    internals.cloneWithShallow = function(source, options2) {
      const keys = options2.shallow;
      options2 = Object.assign({}, options2);
      options2.shallow = false;
      const seen = /* @__PURE__ */ new Map();
      for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === "object" || typeof ref === "function") {
          seen.set(ref, ref);
        }
      }
      return internals.clone(source, options2, seen);
    };
    internals.base = function(obj, baseProto, options2) {
      if (options2.prototype === false) {
        if (internals.needsProtoHack.has(baseProto)) {
          return new baseProto.constructor();
        }
        return baseProto === Types.array ? [] : {};
      }
      const proto3 = Object.getPrototypeOf(obj);
      if (proto3 && proto3.isImmutable) {
        return obj;
      }
      if (baseProto === Types.array) {
        const newObj = [];
        if (proto3 !== baseProto) {
          Object.setPrototypeOf(newObj, proto3);
        }
        return newObj;
      } else if (baseProto === Types.error && internals.structuredCloneExists && (proto3 === baseProto || Error.isPrototypeOf(proto3.constructor))) {
        const err = structuredClone(obj);
        if (Object.getPrototypeOf(err) !== proto3) {
          Object.setPrototypeOf(err, proto3);
        }
        return err;
      }
      if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto3.constructor();
        if (proto3 !== baseProto) {
          Object.setPrototypeOf(newObj, proto3);
        }
        return newObj;
      }
      return Object.create(proto3);
    };
  }
});
var require_merge = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/merge.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Utils = require_utils();
    var internals = {};
    module.exports = internals.merge = function(target, source, options2) {
      Assert(target && typeof target === "object", "Invalid target value: must be an object");
      Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      options2 = Object.assign({ nullOverride: true, mergeArrays: true }, options2);
      if (Array.isArray(source)) {
        Assert(Array.isArray(target), "Cannot merge array onto an object");
        if (!options2.mergeArrays) {
          target.length = 0;
        }
        for (let i2 = 0; i2 < source.length; ++i2) {
          target.push(Clone(source[i2], { symbols: options2.symbols }));
        }
        return target;
      }
      const keys = Utils.keys(source, options2);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (target[key] === value) {
            continue;
          }
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
          value instanceof RegExp) {
            target[key] = Clone(value, { symbols: options2.symbols });
          } else {
            internals.merge(target[key], value, options2);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (options2.nullOverride) {
            target[key] = value;
          }
        }
      }
      return target;
    };
  }
});
var require_applyToDefaults = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/applyToDefaults.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Merge = require_merge();
    var Reach = require_reach();
    var internals = {};
    module.exports = function(defaults, source, options2 = {}) {
      Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
      Assert(typeof options2 === "object", "Invalid options: must be an object");
      if (!source) {
        return null;
      }
      if (options2.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options2);
      }
      const copy = Clone(defaults);
      if (source === true) {
        return copy;
      }
      const nullOverride = options2.nullOverride !== void 0 ? options2.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.applyToDefaultsWithShallow = function(defaults, source, options2) {
      const keys = options2.shallow;
      Assert(Array.isArray(keys), "Invalid keys");
      const seen = /* @__PURE__ */ new Map();
      const merge2 = source === true ? null : /* @__PURE__ */ new Set();
      for (let key of keys) {
        key = Array.isArray(key) ? key : key.split(".");
        const ref = Reach(defaults, key);
        if (ref && typeof ref === "object") {
          seen.set(ref, merge2 && Reach(source, key) || ref);
        } else if (merge2) {
          merge2.add(key);
        }
      }
      const copy = Clone(defaults, {}, seen);
      if (!merge2) {
        return copy;
      }
      for (const key of merge2) {
        internals.reachCopy(copy, source, key);
      }
      const nullOverride = options2.nullOverride !== void 0 ? options2.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.reachCopy = function(dst, src2, path2) {
      for (const segment of path2) {
        if (!(segment in src2)) {
          return;
        }
        const val = src2[segment];
        if (typeof val !== "object" || val === null) {
          return;
        }
        src2 = val;
      }
      const value = src2;
      let ref = dst;
      for (let i2 = 0; i2 < path2.length - 1; ++i2) {
        const segment = path2[i2];
        if (typeof ref[segment] !== "object") {
          ref[segment] = {};
        }
        ref = ref[segment];
      }
      ref[path2[path2.length - 1]] = value;
    };
  }
});
var require_bench = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/bench.js"(exports, module) {
    "use strict";
    var internals = {};
    module.exports = internals.Bench = class {
      constructor() {
        this.ts = 0;
        this.reset();
      }
      reset() {
        this.ts = internals.Bench.now();
      }
      elapsed() {
        return internals.Bench.now() - this.ts;
      }
      static now() {
        const ts = process.hrtime();
        return ts[0] * 1e3 + ts[1] / 1e6;
      }
    };
  }
});
var require_ignore = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/ignore.js"(exports, module) {
    "use strict";
    module.exports = function() {
    };
  }
});
var require_block = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/block.js"(exports, module) {
    "use strict";
    var Ignore = require_ignore();
    module.exports = function() {
      return new Promise(Ignore);
    };
  }
});
var require_deepEqual = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/deepEqual.js"(exports, module) {
    "use strict";
    var Types = require_types();
    var internals = {
      mismatched: null
    };
    module.exports = function(obj, ref, options2) {
      options2 = Object.assign({ prototype: true }, options2);
      return !!internals.isDeepEqual(obj, ref, options2, []);
    };
    internals.isDeepEqual = function(obj, ref, options2, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (obj === null || ref === null) {
        return false;
      }
      if (type === "function") {
        if (!options2.deepFunction || obj.toString() !== ref.toString()) {
          return false;
        }
      } else if (type !== "object") {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options2.prototype);
      switch (instanceType) {
        case Types.buffer:
          return Buffer && Buffer.prototype.equals.call(obj, ref);
        // $lab:coverage:ignore$
        case Types.promise:
          return obj === ref;
        case Types.regex:
        case Types.url:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i2 = seen.length - 1; i2 >= 0; --i2) {
        if (seen[i2].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options2, seen);
      } finally {
        seen.pop();
      }
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return Types.getInternalProto(obj);
      }
      const type = Types.getInternalProto(obj);
      if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options2, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === Types.array) {
        if (options2.part) {
          for (const objValue of obj) {
            for (const refValue of ref) {
              if (isDeepEqual(objValue, refValue, options2, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i2 = 0; i2 < obj.length; ++i2) {
            if (!isDeepEqual(obj[i2], ref[i2], options2, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(Set.prototype.values.call(ref));
          for (const objEntry of Set.prototype.values.call(obj)) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options2, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of Map.prototype.entries.call(obj)) {
          if (value === void 0 && !Map.prototype.has.call(ref, key)) {
            return false;
          }
          if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options2, seen)) {
            return false;
          }
        }
      } else if (instanceType === Types.error) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options2, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options2.part && objKeys.length !== keys(ref).length && !options2.skip) {
        return false;
      }
      let skipped = 0;
      for (const key of objKeys) {
        if (options2.skip && options2.skip.includes(key)) {
          if (ref[key] === void 0) {
            ++skipped;
          }
          continue;
        }
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options2, seen)) {
          return false;
        }
      }
      if (!options2.part && objKeys.length - skipped !== keys(ref).length) {
        return false;
      }
      if (options2.symbols !== false) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (const key of objSymbols) {
          if (!options2.skip?.includes(key)) {
            if (hasOwnEnumerableProperty(obj, key)) {
              if (!hasOwnEnumerableProperty(ref, key)) {
                return false;
              }
              if (!isDeepEqual(obj[key], ref[key], options2, seen)) {
                return false;
              }
            } else if (hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
  }
});
var require_escapeRegex = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeRegex.js"(exports, module) {
    "use strict";
    module.exports = function(string) {
      return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }
});
var require_contain = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/contain.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var EscapeRegex = require_escapeRegex();
    var Utils = require_utils();
    var internals = {};
    module.exports = function(ref, values, options2 = {}) {
      if (typeof values !== "object") {
        values = [values];
      }
      Assert(!Array.isArray(values) || values.length, "Values array cannot be empty");
      if (typeof ref === "string") {
        return internals.string(ref, values, options2);
      }
      if (Array.isArray(ref)) {
        return internals.array(ref, values, options2);
      }
      Assert(typeof ref === "object", "Reference must be string or an object");
      return internals.object(ref, values, options2);
    };
    internals.array = function(ref, values, options2) {
      if (!Array.isArray(values)) {
        values = [values];
      }
      if (!ref.length) {
        return false;
      }
      if (options2.only && options2.once && ref.length !== values.length) {
        return false;
      }
      let compare;
      const map = /* @__PURE__ */ new Map();
      for (const value of values) {
        if (!options2.deep || !value || typeof value !== "object") {
          const existing = map.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map.set(value, { allowed: 1, hits: 0 });
          }
        } else {
          compare = compare ?? internals.compare(options2);
          let found = false;
          for (const [key, existing] of map.entries()) {
            if (compare(key, value)) {
              ++existing.allowed;
              found = true;
              break;
            }
          }
          if (!found) {
            map.set(value, { allowed: 1, hits: 0 });
          }
        }
      }
      let hits = 0;
      for (const item of ref) {
        let match;
        if (!options2.deep || !item || typeof item !== "object") {
          match = map.get(item);
        } else {
          compare = compare ?? internals.compare(options2);
          for (const [key, existing] of map.entries()) {
            if (compare(key, item)) {
              match = existing;
              break;
            }
          }
        }
        if (match) {
          ++match.hits;
          ++hits;
          if (options2.once && match.hits > match.allowed) {
            return false;
          }
        }
      }
      if (options2.only && hits !== ref.length) {
        return false;
      }
      for (const match of map.values()) {
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options2.part) {
          return false;
        }
      }
      return !!hits;
    };
    internals.object = function(ref, values, options2) {
      Assert(options2.once === void 0, "Cannot use option once with object");
      const keys = Utils.keys(ref, options2);
      if (!keys.length) {
        return false;
      }
      if (Array.isArray(values)) {
        return internals.array(keys, values, options2);
      }
      const symbols2 = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
      const targets = [...Object.keys(values), ...symbols2];
      const compare = internals.compare(options2);
      const set = new Set(targets);
      for (const key of keys) {
        if (!set.has(key)) {
          if (options2.only) {
            return false;
          }
          continue;
        }
        if (!compare(values[key], ref[key])) {
          return false;
        }
        set.delete(key);
      }
      if (set.size) {
        return options2.part ? set.size < targets.length : false;
      }
      return true;
    };
    internals.string = function(ref, values, options2) {
      if (ref === "") {
        return values.length === 1 && values[0] === "" || // '' contains ''
        !options2.once && !values.some((v2) => v2 !== "");
      }
      const map = /* @__PURE__ */ new Map();
      const patterns = [];
      for (const value of values) {
        Assert(typeof value === "string", "Cannot compare string reference to non-string value");
        if (value) {
          const existing = map.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map.set(value, { allowed: 1, hits: 0 });
            patterns.push(EscapeRegex(value));
          }
        } else if (options2.once || options2.only) {
          return false;
        }
      }
      if (!patterns.length) {
        return true;
      }
      const regex = new RegExp(`(${patterns.join("|")})`, "g");
      const leftovers = ref.replace(regex, ($0, $1) => {
        ++map.get($1).hits;
        return "";
      });
      if (options2.only && leftovers) {
        return false;
      }
      let any = false;
      for (const match of map.values()) {
        if (match.hits) {
          any = true;
        }
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options2.part) {
          return false;
        }
        if (options2.once) {
          return false;
        }
      }
      return !!any;
    };
    internals.compare = function(options2) {
      if (!options2.deep) {
        return internals.shallow;
      }
      const hasOnly = options2.only !== void 0;
      const hasPart = options2.part !== void 0;
      const flags = {
        prototype: hasOnly ? options2.only : hasPart ? !options2.part : false,
        part: hasOnly ? !options2.only : hasPart ? options2.part : false
      };
      return (a, b) => DeepEqual(a, b, flags);
    };
    internals.shallow = function(a, b) {
      return a === b;
    };
  }
});
var require_escapeHeaderAttribute = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js"(exports, module) {
    "use strict";
    var Assert = require_assert();
    module.exports = function(attribute) {
      Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
      return attribute.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
    };
  }
});
var require_escapeHtml = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeHtml.js"(exports, module) {
    "use strict";
    var internals = {};
    module.exports = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i2 = 0; i2 < input.length; ++i2) {
        const charCode = input.charCodeAt(i2);
        if (internals.isSafe(charCode)) {
          escaped += input[i2];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml.get(charCode);
      if (namedEscape) {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = charCode.toString(16).padStart(2, "0");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return internals.safeCharCodes.has(charCode);
    };
    internals.namedHtml = /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [34, "&quot;"],
      [160, "&nbsp;"],
      [162, "&cent;"],
      [163, "&pound;"],
      [164, "&curren;"],
      [169, "&copy;"],
      [174, "&reg;"]
    ]);
    internals.safeCharCodes = function() {
      const safe = /* @__PURE__ */ new Set();
      for (let i2 = 32; i2 < 123; ++i2) {
        if (i2 >= 97 || // a-z
        i2 >= 65 && i2 <= 90 || // A-Z
        i2 >= 48 && i2 <= 57 || // 0-9
        i2 === 32 || // space
        i2 === 46 || // .
        i2 === 44 || // ,
        i2 === 45 || // -
        i2 === 58 || // :
        i2 === 95) {
          safe.add(i2);
        }
      }
      return safe;
    }();
  }
});
var require_escapeJson = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/escapeJson.js"(exports, module) {
    "use strict";
    var internals = {};
    module.exports = function(input) {
      if (!input) {
        return "";
      }
      return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
    };
    internals.escape = function(char) {
      return internals.replacements.get(char);
    };
    internals.replacements = /* @__PURE__ */ new Map([
      ["<", "\\u003c"],
      [">", "\\u003e"],
      ["&", "\\u0026"],
      ["\u2028", "\\u2028"],
      ["\u2029", "\\u2029"]
    ]);
  }
});
var require_flatten = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/flatten.js"(exports, module) {
    "use strict";
    var internals = {};
    module.exports = internals.flatten = function(array, target) {
      const result = target || [];
      for (const entry of array) {
        if (Array.isArray(entry)) {
          internals.flatten(entry, result);
        } else {
          result.push(entry);
        }
      }
      return result;
    };
  }
});
var require_intersect = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/intersect.js"(exports, module) {
    "use strict";
    var internals = {};
    module.exports = function(array1, array2, options2 = {}) {
      if (!array1 || !array2) {
        return options2.first ? null : [];
      }
      const common2 = [];
      const hash2 = Array.isArray(array1) ? new Set(array1) : array1;
      const found = /* @__PURE__ */ new Set();
      for (const value of array2) {
        if (internals.has(hash2, value) && !found.has(value)) {
          if (options2.first) {
            return value;
          }
          common2.push(value);
          found.add(value);
        }
      }
      return options2.first ? null : common2;
    };
    internals.has = function(ref, key) {
      if (typeof ref.has === "function") {
        return ref.has(key);
      }
      return ref[key] !== void 0;
    };
  }
});
var require_isPromise = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/isPromise.js"(exports, module) {
    "use strict";
    module.exports = function(promise) {
      return typeof promise?.then === "function";
    };
  }
});
var require_once = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/once.js"(exports, module) {
    "use strict";
    var internals = {
      wrapped: Symbol("wrapped")
    };
    module.exports = function(method) {
      if (method[internals.wrapped]) {
        return method;
      }
      let once = false;
      const wrappedFn = function(...args) {
        if (!once) {
          once = true;
          method(...args);
        }
      };
      wrappedFn[internals.wrapped] = true;
      return wrappedFn;
    };
  }
});
var require_reachTemplate = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/reachTemplate.js"(exports, module) {
    "use strict";
    var Reach = require_reach();
    module.exports = function(obj, template, options2) {
      return template.replace(/{([^{}]+)}/g, ($0, chain) => {
        const value = Reach(obj, chain, options2);
        return value ?? "";
      });
    };
  }
});
var require_wait = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/wait.js"(exports, module) {
    "use strict";
    var internals = {
      maxTimer: 2 ** 31 - 1
      // ~25 days
    };
    module.exports = function(timeout, returnValue, options2) {
      if (typeof timeout === "bigint") {
        timeout = Number(timeout);
      }
      if (timeout >= Number.MAX_SAFE_INTEGER) {
        timeout = Infinity;
      }
      if (typeof timeout !== "number" && timeout !== void 0) {
        throw new TypeError("Timeout must be a number or bigint");
      }
      return new Promise((resolve42) => {
        const _setTimeout = options2 ? options2.setTimeout : setTimeout;
        const activate = () => {
          const time = Math.min(timeout, internals.maxTimer);
          timeout -= time;
          _setTimeout(() => timeout > 0 ? activate() : resolve42(returnValue), time);
        };
        if (timeout !== Infinity) {
          activate();
        }
      });
    };
  }
});
var require_lib = __commonJS({
  "node_modules/.deno/@hapi+hoek@11.0.7/node_modules/@hapi/hoek/lib/index.js"(exports) {
    "use strict";
    exports.applyToDefaults = require_applyToDefaults();
    exports.assert = require_assert();
    exports.AssertError = require_assertError();
    exports.Bench = require_bench();
    exports.block = require_block();
    exports.clone = require_clone();
    exports.contain = require_contain();
    exports.deepEqual = require_deepEqual();
    exports.escapeHeaderAttribute = require_escapeHeaderAttribute();
    exports.escapeHtml = require_escapeHtml();
    exports.escapeJson = require_escapeJson();
    exports.escapeRegex = require_escapeRegex();
    exports.flatten = require_flatten();
    exports.ignore = require_ignore();
    exports.intersect = require_intersect();
    exports.isPromise = require_isPromise();
    exports.merge = require_merge();
    exports.once = require_once();
    exports.reach = require_reach();
    exports.reachTemplate = require_reachTemplate();
    exports.stringify = require_stringify();
    exports.wait = require_wait();
  }
});
var require_lib2 = __commonJS({
  "node_modules/.deno/@hapi+boom@10.0.1/node_modules/@hapi/boom/lib/index.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var internals = {
      codes: /* @__PURE__ */ new Map([
        [100, "Continue"],
        [101, "Switching Protocols"],
        [102, "Processing"],
        [200, "OK"],
        [201, "Created"],
        [202, "Accepted"],
        [203, "Non-Authoritative Information"],
        [204, "No Content"],
        [205, "Reset Content"],
        [206, "Partial Content"],
        [207, "Multi-Status"],
        [300, "Multiple Choices"],
        [301, "Moved Permanently"],
        [302, "Moved Temporarily"],
        [303, "See Other"],
        [304, "Not Modified"],
        [305, "Use Proxy"],
        [307, "Temporary Redirect"],
        [400, "Bad Request"],
        [401, "Unauthorized"],
        [402, "Payment Required"],
        [403, "Forbidden"],
        [404, "Not Found"],
        [405, "Method Not Allowed"],
        [406, "Not Acceptable"],
        [407, "Proxy Authentication Required"],
        [408, "Request Time-out"],
        [409, "Conflict"],
        [410, "Gone"],
        [411, "Length Required"],
        [412, "Precondition Failed"],
        [413, "Request Entity Too Large"],
        [414, "Request-URI Too Large"],
        [415, "Unsupported Media Type"],
        [416, "Requested Range Not Satisfiable"],
        [417, "Expectation Failed"],
        [418, "I'm a teapot"],
        [422, "Unprocessable Entity"],
        [423, "Locked"],
        [424, "Failed Dependency"],
        [425, "Too Early"],
        [426, "Upgrade Required"],
        [428, "Precondition Required"],
        [429, "Too Many Requests"],
        [431, "Request Header Fields Too Large"],
        [451, "Unavailable For Legal Reasons"],
        [500, "Internal Server Error"],
        [501, "Not Implemented"],
        [502, "Bad Gateway"],
        [503, "Service Unavailable"],
        [504, "Gateway Time-out"],
        [505, "HTTP Version Not Supported"],
        [506, "Variant Also Negotiates"],
        [507, "Insufficient Storage"],
        [509, "Bandwidth Limit Exceeded"],
        [510, "Not Extended"],
        [511, "Network Authentication Required"]
      ])
    };
    exports.Boom = class extends Error {
      constructor(messageOrError, options2 = {}) {
        if (messageOrError instanceof Error) {
          return exports.boomify(Hoek.clone(messageOrError), options2);
        }
        const { statusCode = 500, data = null, ctor = exports.Boom } = options2;
        const error = new Error(messageOrError ? messageOrError : void 0);
        Error.captureStackTrace(error, ctor);
        error.data = data;
        const boom = internals.initialize(error, statusCode);
        Object.defineProperty(boom, "typeof", { value: ctor });
        if (options2.decorate) {
          Object.assign(boom, options2.decorate);
        }
        return boom;
      }
      static [Symbol.hasInstance](instance) {
        if (this === exports.Boom) {
          return exports.isBoom(instance);
        }
        return this.prototype.isPrototypeOf(instance);
      }
    };
    exports.isBoom = function(err, statusCode) {
      return err instanceof Error && !!err.isBoom && (!statusCode || err.output.statusCode === statusCode);
    };
    exports.boomify = function(err, options2) {
      Hoek.assert(err instanceof Error, "Cannot wrap non-Error object");
      options2 = options2 || {};
      if (options2.data !== void 0) {
        err.data = options2.data;
      }
      if (options2.decorate) {
        Object.assign(err, options2.decorate);
      }
      if (!err.isBoom) {
        return internals.initialize(err, options2.statusCode ?? 500, options2.message);
      }
      if (options2.override === false || // Defaults to true
      !options2.statusCode && !options2.message) {
        return err;
      }
      return internals.initialize(err, options2.statusCode ?? err.output.statusCode, options2.message);
    };
    exports.badRequest = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 400, data, ctor: exports.badRequest });
    };
    exports.unauthorized = function(message, scheme, attributes) {
      const err = new exports.Boom(message, { statusCode: 401, ctor: exports.unauthorized });
      if (!scheme) {
        return err;
      }
      if (typeof scheme !== "string") {
        err.output.headers["WWW-Authenticate"] = scheme.join(", ");
        return err;
      }
      let wwwAuthenticate = `${scheme}`;
      if (attributes || message) {
        err.output.payload.attributes = {};
      }
      if (attributes) {
        if (typeof attributes === "string") {
          wwwAuthenticate += " " + Hoek.escapeHeaderAttribute(attributes);
          err.output.payload.attributes = attributes;
        } else {
          wwwAuthenticate += " " + Object.keys(attributes).map((name) => {
            const value = attributes[name] ?? "";
            err.output.payload.attributes[name] = value;
            return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
          }).join(", ");
        }
      }
      if (message) {
        if (attributes) {
          wwwAuthenticate += ",";
        }
        wwwAuthenticate += ` error="${Hoek.escapeHeaderAttribute(message)}"`;
        err.output.payload.attributes.error = message;
      } else {
        err.isMissing = true;
      }
      err.output.headers["WWW-Authenticate"] = wwwAuthenticate;
      return err;
    };
    exports.paymentRequired = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 402, data, ctor: exports.paymentRequired });
    };
    exports.forbidden = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 403, data, ctor: exports.forbidden });
    };
    exports.notFound = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 404, data, ctor: exports.notFound });
    };
    exports.methodNotAllowed = function(messageOrError, data, allow) {
      const err = new exports.Boom(messageOrError, { statusCode: 405, data, ctor: exports.methodNotAllowed });
      if (typeof allow === "string") {
        allow = [allow];
      }
      if (Array.isArray(allow)) {
        err.output.headers.Allow = allow.join(", ");
      }
      return err;
    };
    exports.notAcceptable = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 406, data, ctor: exports.notAcceptable });
    };
    exports.proxyAuthRequired = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 407, data, ctor: exports.proxyAuthRequired });
    };
    exports.clientTimeout = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 408, data, ctor: exports.clientTimeout });
    };
    exports.conflict = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 409, data, ctor: exports.conflict });
    };
    exports.resourceGone = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 410, data, ctor: exports.resourceGone });
    };
    exports.lengthRequired = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 411, data, ctor: exports.lengthRequired });
    };
    exports.preconditionFailed = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 412, data, ctor: exports.preconditionFailed });
    };
    exports.entityTooLarge = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 413, data, ctor: exports.entityTooLarge });
    };
    exports.uriTooLong = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 414, data, ctor: exports.uriTooLong });
    };
    exports.unsupportedMediaType = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 415, data, ctor: exports.unsupportedMediaType });
    };
    exports.rangeNotSatisfiable = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 416, data, ctor: exports.rangeNotSatisfiable });
    };
    exports.expectationFailed = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 417, data, ctor: exports.expectationFailed });
    };
    exports.teapot = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 418, data, ctor: exports.teapot });
    };
    exports.badData = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 422, data, ctor: exports.badData });
    };
    exports.locked = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 423, data, ctor: exports.locked });
    };
    exports.failedDependency = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 424, data, ctor: exports.failedDependency });
    };
    exports.tooEarly = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 425, data, ctor: exports.tooEarly });
    };
    exports.preconditionRequired = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 428, data, ctor: exports.preconditionRequired });
    };
    exports.tooManyRequests = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 429, data, ctor: exports.tooManyRequests });
    };
    exports.illegal = function(messageOrError, data) {
      return new exports.Boom(messageOrError, { statusCode: 451, data, ctor: exports.illegal });
    };
    exports.internal = function(message, data, statusCode = 500) {
      return internals.serverError(message, data, statusCode, exports.internal);
    };
    exports.notImplemented = function(message, data) {
      return internals.serverError(message, data, 501, exports.notImplemented);
    };
    exports.badGateway = function(message, data) {
      return internals.serverError(message, data, 502, exports.badGateway);
    };
    exports.serverUnavailable = function(message, data) {
      return internals.serverError(message, data, 503, exports.serverUnavailable);
    };
    exports.gatewayTimeout = function(message, data) {
      return internals.serverError(message, data, 504, exports.gatewayTimeout);
    };
    exports.badImplementation = function(message, data) {
      const err = internals.serverError(message, data, 500, exports.badImplementation);
      err.isDeveloperError = true;
      return err;
    };
    internals.initialize = function(err, statusCode, message) {
      const numberCode = parseInt(statusCode, 10);
      Hoek.assert(!isNaN(numberCode) && numberCode >= 400, "First argument must be a number (400+):", statusCode);
      err.isBoom = true;
      err.isServer = numberCode >= 500;
      if (!err.hasOwnProperty("data")) {
        err.data = null;
      }
      err.output = {
        statusCode: numberCode,
        payload: {},
        headers: {}
      };
      Object.defineProperty(err, "reformat", { value: internals.reformat, configurable: true });
      if (!message && !err.message) {
        err.reformat();
        message = err.output.payload.error;
      }
      if (message) {
        const props = Object.getOwnPropertyDescriptor(err, "message") || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), "message");
        Hoek.assert(!props || props.configurable && !props.get, "The error is not compatible with boom");
        err.message = message + (err.message ? ": " + err.message : "");
        err.output.payload.message = err.message;
      }
      err.reformat();
      return err;
    };
    internals.reformat = function(debug = false) {
      this.output.payload.statusCode = this.output.statusCode;
      this.output.payload.error = internals.codes.get(this.output.statusCode) || "Unknown";
      if (this.output.statusCode === 500 && debug !== true) {
        this.output.payload.message = "An internal server error occurred";
      } else if (this.message) {
        this.output.payload.message = this.message;
      }
    };
    internals.serverError = function(messageOrError, data, statusCode, ctor) {
      if (data instanceof Error && !data.isBoom) {
        return exports.boomify(data, { statusCode, message: messageOrError });
      }
      return new exports.Boom(messageOrError, { statusCode, data, ctor });
    };
  }
});
var require_lru_cache = __commonJS({
  "node_modules/.deno/lru-cache@7.14.0/node_modules/lru-cache/index.js"(exports, module) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e2 = { type, target: this };
          this.onabort(e2);
          this._listeners.forEach((f) => f(e2), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code2 = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code2)) {
        warn(code2, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code2 = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code2)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code2, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code2 = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code2)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code2, `${field} property`, `cache.${instead}`, get);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code2) => !warned.has(code2);
    var warn = (code2, what, instead, fn) => {
      warned.add(code2);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code2, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options2 = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          maxEntrySize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet
        } = options2;
        const { length: length2, maxAge, stale } = options2 instanceof _LRUCache ? {} : options2;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length2;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize or maxEntrySize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError(
                "maxSize must be a positive integer if specified"
              );
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError(
              "maxEntrySize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code2 = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code2)) {
            warned.add(code2);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code2, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length2) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v2, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v2, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, size) {
      }
      requireSize(k, v2, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize or maxEntrySize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.tail; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.head) {
              break;
            } else {
              i2 = this.prev[i2];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.head; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.tail) {
              break;
            } else {
              i2 = this.next[i2];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i2 of this.indexes()) {
          yield [this.keyList[i2], this.valList[i2]];
        }
      }
      *rentries() {
        for (const i2 of this.rindexes()) {
          yield [this.keyList[i2], this.valList[i2]];
        }
      }
      *keys() {
        for (const i2 of this.indexes()) {
          yield this.keyList[i2];
        }
      }
      *rkeys() {
        for (const i2 of this.rindexes()) {
          yield this.keyList[i2];
        }
      }
      *values() {
        for (const i2 of this.indexes()) {
          yield this.valList[i2];
        }
      }
      *rvalues() {
        for (const i2 of this.rindexes()) {
          yield this.valList[i2];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i2 of this.indexes()) {
          if (fn(this.valList[i2], this.keyList[i2], this)) {
            return this.get(this.keyList[i2], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i2 of this.indexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i2 of this.rindexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i2 of this.rindexes({ allowStale: true })) {
          if (this.isStale(i2)) {
            this.delete(this.keyList[i2]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i2 of this.indexes({ allowStale: true })) {
          const key = this.keyList[i2];
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i2];
            const age = perf.now() - this.starts[i2];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i2];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v2, k, reason) {
      }
      set(k, v2, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v2, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v2;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v2 !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v2;
            this.addItemSize(index, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v2 = this.valList[head];
        if (this.isBackgroundFetch(v2)) {
          v2.__abortController.abort();
        } else {
          this.dispose(v2, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v2, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v2 = this.valList[index];
          return this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
        }
      }
      backgroundFetch(k, index, options2, context) {
        const v2 = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v2)) {
          return v2;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options: options2,
          context
        };
        const cb = (v3) => {
          if (!ac.signal.aborted) {
            this.set(k, v3, fetchOpts.options);
          }
          return v3;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options2.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v2, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v2;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = false
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet
          });
        }
        const options2 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options2, fetchContext);
          return p.__returned = p;
        } else {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            return allowStale && v2.__staleWhileFetching !== void 0 ? v2.__staleWhileFetching : v2.__returned = v2;
          }
          if (!forceRefresh && !this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v2;
          }
          const p = this.backgroundFetch(k, index, options2, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v2 = this.valList[index];
              if (this.isBackgroundFetch(v2)) {
                v2.__abortController.abort();
              } else {
                this.dispose(v2, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v2, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v2, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v2, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module.exports = LRUCache;
  }
});
var requiredMethodNames;
var DatabaseBackend;
var init_DatabaseBackend = __esm({
  "src/serve/DatabaseBackend.ts"() {
    "use strict";
    requiredMethodNames = ["init", "clear", "readData", "writeData", "deleteData", "close"];
    DatabaseBackend = class _DatabaseBackend {
      constructor() {
        if (new.target === _DatabaseBackend) {
          throw new Error("Class DatabaseBackend cannot be instantiated directly.");
        }
        const bindMethod = (name) => {
          this[name] = this[name].bind(this);
        };
        for (const name of requiredMethodNames) {
          bindMethod(name);
        }
      }
    };
  }
});
var database_fs_exports = {};
__export(database_fs_exports, {
  default: () => FsBackend
});
async function testCaseSensitivity(backend) {
  const { readData, writeData, deleteData } = backend;
  const date = /* @__PURE__ */ new Date();
  const dateString = date.toISOString();
  const originalKey = `_private_testCaseSensitivity_${date.getTime()}_${(0, Math.random)().toFixed(8).slice(2)}`;
  const differentlyCasedKey = "_P" + originalKey.slice(2);
  await writeData(originalKey, dateString);
  try {
    const valueOriginalCase = await readData(originalKey);
    const valueDifferentCase = await readData(differentlyCasedKey);
    if (valueOriginalCase?.toString() !== dateString) {
      console.error(`Unexpected value on case-sensitivity test; expected ${dateString}`);
      throw new Error("Unexpected value: original key does not have the correct value");
    }
    if (valueDifferentCase?.toString() === dateString) {
      const errStr = "Filesystem database backend only works on case-sensitive filesystems. This appears to be a case insensitive file system. Set SKIP_DB_FS_CASE_SENSITIVITY_CHECK=true to skip.";
      console.error(errStr);
      throw new Error(errStr);
    }
  } finally {
    await deleteData(originalKey);
  }
}
var splitAndGroup;
var FsBackend;
var init_database_fs = __esm({
  "src/serve/database-fs.ts"() {
    "use strict";
    init_db();
    init_DatabaseBackend();
    splitAndGroup = (input, chunkLength, depth) => input.slice(0, chunkLength * depth).split("").reduce((acc, cv, i2) => {
      acc[i2 / chunkLength | 0] = (acc[i2 / chunkLength | 0] || "") + cv;
      return acc;
    }, []);
    FsBackend = class extends DatabaseBackend {
      dataFolder = "";
      depth = 0;
      keyChunkLength = 2;
      constructor(options2 = {}) {
        super();
        this.dataFolder = resolve6(options2.dirname);
        if (options2.depth) this.depth = options2.depth;
        if (options2.keyChunkLength) this.keyChunkLength = options2.keyChunkLength;
      }
      // Maps a given key to a real path on the filesystem.
      mapKey(key) {
        if (basename6(normalize6(key)) !== key) throw new TypeError("Invalid key");
        if (!this.depth) return join6(this.dataFolder, key);
        const keyChunks = splitAndGroup(key, this.keyChunkLength, this.depth);
        return join6(this.dataFolder, ...keyChunks, key);
      }
      async init() {
        await mkdir(this.dataFolder, { mode: 488, recursive: true });
        if (process3.env.SKIP_DB_FS_CASE_SENSITIVITY_CHECK === void 0) {
          await testCaseSensitivity(this);
        }
      }
      async clear() {
        const names = await readdir(this.dataFolder);
        const paths = names.map((name) => join6(this.dataFolder, name));
        await Promise.all(
          paths.map((p) => rm(p, { recursive: true }))
        );
      }
      async readData(key) {
        checkKey(key);
        return await readFile(this.mapKey(key)).catch((err) => {
          if (err.code !== "ENOENT") throw err;
        });
      }
      async writeData(key, value) {
        const path2 = this.mapKey(key);
        if (this.depth) await mkdir(dirname6(path2), { mode: 488, recursive: true });
        await writeFile(path2, value);
      }
      async deleteData(key) {
        await unlink(this.mapKey(key)).catch((e2) => {
          if (e2?.code === "ENOENT") {
            return;
          }
          throw e2;
        });
      }
      close() {
      }
      async *iterKeys() {
        const entries = await readdir(this.dataFolder, { withFileTypes: true });
        for await (const entry of entries) {
          if (entry.isFile()) {
            yield entry.name;
          }
        }
      }
    };
  }
});
var require_verbatim_string = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/RESP/verbatim-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VerbatimString = void 0;
    var VerbatimString = class extends String {
      format;
      constructor(format22, value) {
        super(value);
        this.format = format22;
      }
    };
    exports.VerbatimString = VerbatimString;
  }
});
var require_errors = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiErrorReply = exports.CommandTimeoutDuringMaintenanceError = exports.SocketTimeoutDuringMaintenanceError = exports.TimeoutError = exports.BlobError = exports.SimpleError = exports.ErrorReply = exports.ReconnectStrategyError = exports.RootNodesUnavailableError = exports.SocketClosedUnexpectedlyError = exports.DisconnectsClientError = exports.ClientOfflineError = exports.ClientClosedError = exports.SocketTimeoutError = exports.ConnectionTimeoutError = exports.WatchError = exports.AbortError = void 0;
    var AbortError = class extends Error {
      constructor() {
        super("The command was aborted");
      }
    };
    exports.AbortError = AbortError;
    var WatchError = class extends Error {
      constructor(message = "One (or more) of the watched keys has been changed") {
        super(message);
      }
    };
    exports.WatchError = WatchError;
    var ConnectionTimeoutError = class extends Error {
      constructor() {
        super("Connection timeout");
      }
    };
    exports.ConnectionTimeoutError = ConnectionTimeoutError;
    var SocketTimeoutError = class extends Error {
      constructor(timeout) {
        super(`Socket timeout timeout. Expecting data, but didn't receive any in ${timeout}ms.`);
      }
    };
    exports.SocketTimeoutError = SocketTimeoutError;
    var ClientClosedError = class extends Error {
      constructor() {
        super("The client is closed");
      }
    };
    exports.ClientClosedError = ClientClosedError;
    var ClientOfflineError = class extends Error {
      constructor() {
        super("The client is offline");
      }
    };
    exports.ClientOfflineError = ClientOfflineError;
    var DisconnectsClientError = class extends Error {
      constructor() {
        super("Disconnects client");
      }
    };
    exports.DisconnectsClientError = DisconnectsClientError;
    var SocketClosedUnexpectedlyError = class extends Error {
      constructor() {
        super("Socket closed unexpectedly");
      }
    };
    exports.SocketClosedUnexpectedlyError = SocketClosedUnexpectedlyError;
    var RootNodesUnavailableError = class extends Error {
      constructor() {
        super("All the root nodes are unavailable");
      }
    };
    exports.RootNodesUnavailableError = RootNodesUnavailableError;
    var ReconnectStrategyError = class extends Error {
      originalError;
      socketError;
      constructor(originalError, socketError) {
        super(originalError.message);
        this.originalError = originalError;
        this.socketError = socketError;
      }
    };
    exports.ReconnectStrategyError = ReconnectStrategyError;
    var ErrorReply = class extends Error {
    };
    exports.ErrorReply = ErrorReply;
    var SimpleError = class extends ErrorReply {
    };
    exports.SimpleError = SimpleError;
    var BlobError = class extends ErrorReply {
    };
    exports.BlobError = BlobError;
    var TimeoutError = class extends Error {
    };
    exports.TimeoutError = TimeoutError;
    var SocketTimeoutDuringMaintenanceError = class extends TimeoutError {
      constructor(timeout) {
        super(`Socket timeout during maintenance. Expecting data, but didn't receive any in ${timeout}ms.`);
      }
    };
    exports.SocketTimeoutDuringMaintenanceError = SocketTimeoutDuringMaintenanceError;
    var CommandTimeoutDuringMaintenanceError = class extends TimeoutError {
      constructor(timeout) {
        super(`Command timeout during maintenance. Waited to write command for more than ${timeout}ms.`);
      }
    };
    exports.CommandTimeoutDuringMaintenanceError = CommandTimeoutDuringMaintenanceError;
    var MultiErrorReply = class extends ErrorReply {
      replies;
      errorIndexes;
      constructor(replies, errorIndexes) {
        super(`${errorIndexes.length} commands failed, see .replies and .errorIndexes for more information`);
        this.replies = replies;
        this.errorIndexes = errorIndexes;
      }
      *errors() {
        for (const index of this.errorIndexes) {
          yield this.replies[index];
        }
      }
    };
    exports.MultiErrorReply = MultiErrorReply;
  }
});
var require_decoder = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/RESP/decoder.js"(exports) {
    "use strict";
    var _a2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.PUSH_TYPE_MAPPING = exports.RESP_TYPES = void 0;
    var verbatim_string_1 = require_verbatim_string();
    var errors_1 = require_errors();
    exports.RESP_TYPES = {
      NULL: 95,
      // _
      BOOLEAN: 35,
      // #
      NUMBER: 58,
      // :
      BIG_NUMBER: 40,
      // (
      DOUBLE: 44,
      // ,
      SIMPLE_STRING: 43,
      // +
      BLOB_STRING: 36,
      // $
      VERBATIM_STRING: 61,
      // =
      SIMPLE_ERROR: 45,
      // -
      BLOB_ERROR: 33,
      // !
      ARRAY: 42,
      // *
      SET: 126,
      // ~
      MAP: 37,
      // %
      PUSH: 62
      // >
    };
    var ASCII = {
      "\r": 13,
      "t": 116,
      "+": 43,
      "-": 45,
      "0": 48,
      ".": 46,
      "i": 105,
      "n": 110,
      "E": 69,
      "e": 101
    };
    exports.PUSH_TYPE_MAPPING = {
      [exports.RESP_TYPES.BLOB_STRING]: Buffer
    };
    var Decoder2 = class {
      onReply;
      onErrorReply;
      onPush;
      getTypeMapping;
      #cursor = 0;
      #next;
      constructor(config) {
        this.onReply = config.onReply;
        this.onErrorReply = config.onErrorReply;
        this.onPush = config.onPush;
        this.getTypeMapping = config.getTypeMapping;
      }
      reset() {
        this.#cursor = 0;
        this.#next = void 0;
      }
      write(chunk) {
        if (this.#cursor >= chunk.length) {
          this.#cursor -= chunk.length;
          return;
        }
        if (this.#next) {
          if (this.#next(chunk) || this.#cursor >= chunk.length) {
            this.#cursor -= chunk.length;
            return;
          }
        }
        do {
          const type = chunk[this.#cursor];
          if (++this.#cursor === chunk.length) {
            this.#next = this.#continueDecodeTypeValue.bind(this, type);
            break;
          }
          if (this.#decodeTypeValue(type, chunk)) {
            break;
          }
        } while (this.#cursor < chunk.length);
        this.#cursor -= chunk.length;
      }
      #continueDecodeTypeValue(type, chunk) {
        this.#next = void 0;
        return this.#decodeTypeValue(type, chunk);
      }
      #decodeTypeValue(type, chunk) {
        switch (type) {
          case exports.RESP_TYPES.NULL:
            this.onReply(this.#decodeNull());
            return false;
          case exports.RESP_TYPES.BOOLEAN:
            return this.#handleDecodedValue(this.onReply, this.#decodeBoolean(chunk));
          case exports.RESP_TYPES.NUMBER:
            return this.#handleDecodedValue(this.onReply, this.#decodeNumber(this.getTypeMapping()[exports.RESP_TYPES.NUMBER], chunk));
          case exports.RESP_TYPES.BIG_NUMBER:
            return this.#handleDecodedValue(this.onReply, this.#decodeBigNumber(this.getTypeMapping()[exports.RESP_TYPES.BIG_NUMBER], chunk));
          case exports.RESP_TYPES.DOUBLE:
            return this.#handleDecodedValue(this.onReply, this.#decodeDouble(this.getTypeMapping()[exports.RESP_TYPES.DOUBLE], chunk));
          case exports.RESP_TYPES.SIMPLE_STRING:
            return this.#handleDecodedValue(this.onReply, this.#decodeSimpleString(this.getTypeMapping()[exports.RESP_TYPES.SIMPLE_STRING], chunk));
          case exports.RESP_TYPES.BLOB_STRING:
            return this.#handleDecodedValue(this.onReply, this.#decodeBlobString(this.getTypeMapping()[exports.RESP_TYPES.BLOB_STRING], chunk));
          case exports.RESP_TYPES.VERBATIM_STRING:
            return this.#handleDecodedValue(this.onReply, this.#decodeVerbatimString(this.getTypeMapping()[exports.RESP_TYPES.VERBATIM_STRING], chunk));
          case exports.RESP_TYPES.SIMPLE_ERROR:
            return this.#handleDecodedValue(this.onErrorReply, this.#decodeSimpleError(chunk));
          case exports.RESP_TYPES.BLOB_ERROR:
            return this.#handleDecodedValue(this.onErrorReply, this.#decodeBlobError(chunk));
          case exports.RESP_TYPES.ARRAY:
            return this.#handleDecodedValue(this.onReply, this.#decodeArray(this.getTypeMapping(), chunk));
          case exports.RESP_TYPES.SET:
            return this.#handleDecodedValue(this.onReply, this.#decodeSet(this.getTypeMapping(), chunk));
          case exports.RESP_TYPES.MAP:
            return this.#handleDecodedValue(this.onReply, this.#decodeMap(this.getTypeMapping(), chunk));
          case exports.RESP_TYPES.PUSH:
            return this.#handleDecodedValue(this.onPush, this.#decodeArray(exports.PUSH_TYPE_MAPPING, chunk));
          default:
            throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
        }
      }
      #handleDecodedValue(cb, value) {
        if (typeof value === "function") {
          this.#next = this.#continueDecodeValue.bind(this, cb, value);
          return true;
        }
        cb(value);
        return false;
      }
      #continueDecodeValue(cb, next, chunk) {
        this.#next = void 0;
        return this.#handleDecodedValue(cb, next(chunk));
      }
      #decodeNull() {
        this.#cursor += 2;
        return null;
      }
      #decodeBoolean(chunk) {
        const boolean = chunk[this.#cursor] === ASCII.t;
        this.#cursor += 3;
        return boolean;
      }
      #decodeNumber(type, chunk) {
        if (type === String) {
          return this.#decodeSimpleString(String, chunk);
        }
        switch (chunk[this.#cursor]) {
          case ASCII["+"]:
            return this.#maybeDecodeNumberValue(false, chunk);
          case ASCII["-"]:
            return this.#maybeDecodeNumberValue(true, chunk);
          default:
            return this.#decodeNumberValue(false, this.#decodeUnsingedNumber.bind(this, 0), chunk);
        }
      }
      #maybeDecodeNumberValue(isNegative, chunk) {
        const cb = this.#decodeUnsingedNumber.bind(this, 0);
        return ++this.#cursor === chunk.length ? this.#decodeNumberValue.bind(this, isNegative, cb) : this.#decodeNumberValue(isNegative, cb, chunk);
      }
      #decodeNumberValue(isNegative, numberCb, chunk) {
        const number = numberCb(chunk);
        return typeof number === "function" ? this.#decodeNumberValue.bind(this, isNegative, number) : isNegative ? -number : number;
      }
      #decodeUnsingedNumber(number, chunk) {
        let cursor = this.#cursor;
        do {
          const byte = chunk[cursor];
          if (byte === ASCII["\r"]) {
            this.#cursor = cursor + 2;
            return number;
          }
          number = number * 10 + byte - ASCII["0"];
        } while (++cursor < chunk.length);
        this.#cursor = cursor;
        return this.#decodeUnsingedNumber.bind(this, number);
      }
      #decodeBigNumber(type, chunk) {
        if (type === String) {
          return this.#decodeSimpleString(String, chunk);
        }
        switch (chunk[this.#cursor]) {
          case ASCII["+"]:
            return this.#maybeDecodeBigNumberValue(false, chunk);
          case ASCII["-"]:
            return this.#maybeDecodeBigNumberValue(true, chunk);
          default:
            return this.#decodeBigNumberValue(false, this.#decodeUnsingedBigNumber.bind(this, 0n), chunk);
        }
      }
      #maybeDecodeBigNumberValue(isNegative, chunk) {
        const cb = this.#decodeUnsingedBigNumber.bind(this, 0n);
        return ++this.#cursor === chunk.length ? this.#decodeBigNumberValue.bind(this, isNegative, cb) : this.#decodeBigNumberValue(isNegative, cb, chunk);
      }
      #decodeBigNumberValue(isNegative, bigNumberCb, chunk) {
        const bigNumber = bigNumberCb(chunk);
        return typeof bigNumber === "function" ? this.#decodeBigNumberValue.bind(this, isNegative, bigNumber) : isNegative ? -bigNumber : bigNumber;
      }
      #decodeUnsingedBigNumber(bigNumber, chunk) {
        let cursor = this.#cursor;
        do {
          const byte = chunk[cursor];
          if (byte === ASCII["\r"]) {
            this.#cursor = cursor + 2;
            return bigNumber;
          }
          bigNumber = bigNumber * 10n + BigInt(byte - ASCII["0"]);
        } while (++cursor < chunk.length);
        this.#cursor = cursor;
        return this.#decodeUnsingedBigNumber.bind(this, bigNumber);
      }
      #decodeDouble(type, chunk) {
        if (type === String) {
          return this.#decodeSimpleString(String, chunk);
        }
        switch (chunk[this.#cursor]) {
          case ASCII.n:
            this.#cursor += 5;
            return NaN;
          case ASCII["+"]:
            return this.#maybeDecodeDoubleInteger(false, chunk);
          case ASCII["-"]:
            return this.#maybeDecodeDoubleInteger(true, chunk);
          default:
            return this.#decodeDoubleInteger(false, 0, chunk);
        }
      }
      #maybeDecodeDoubleInteger(isNegative, chunk) {
        return ++this.#cursor === chunk.length ? this.#decodeDoubleInteger.bind(this, isNegative, 0) : this.#decodeDoubleInteger(isNegative, 0, chunk);
      }
      #decodeDoubleInteger(isNegative, integer, chunk) {
        if (chunk[this.#cursor] === ASCII.i) {
          this.#cursor += 5;
          return isNegative ? -Infinity : Infinity;
        }
        return this.#continueDecodeDoubleInteger(isNegative, integer, chunk);
      }
      #continueDecodeDoubleInteger(isNegative, integer, chunk) {
        let cursor = this.#cursor;
        do {
          const byte = chunk[cursor];
          switch (byte) {
            case ASCII["."]:
              this.#cursor = cursor + 1;
              return this.#cursor < chunk.length ? this.#decodeDoubleDecimal(isNegative, 0, integer, chunk) : this.#decodeDoubleDecimal.bind(this, isNegative, 0, integer);
            case ASCII.E:
            case ASCII.e:
              this.#cursor = cursor + 1;
              const i2 = isNegative ? -integer : integer;
              return this.#cursor < chunk.length ? this.#decodeDoubleExponent(i2, chunk) : this.#decodeDoubleExponent.bind(this, i2);
            case ASCII["\r"]:
              this.#cursor = cursor + 2;
              return isNegative ? -integer : integer;
            default:
              integer = integer * 10 + byte - ASCII["0"];
          }
        } while (++cursor < chunk.length);
        this.#cursor = cursor;
        return this.#continueDecodeDoubleInteger.bind(this, isNegative, integer);
      }
      // Precalculated multipliers for decimal points to improve performance
      // "... about 15 to 17 decimal places ..."
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#:~:text=about%2015%20to%2017%20decimal%20places
      static #DOUBLE_DECIMAL_MULTIPLIERS = [
        0.1,
        0.01,
        1e-3,
        1e-4,
        1e-5,
        1e-6,
        1e-7,
        1e-8,
        1e-9,
        1e-10,
        1e-11,
        1e-12,
        1e-13,
        1e-14,
        1e-15,
        1e-16,
        1e-17
      ];
      #decodeDoubleDecimal(isNegative, decimalIndex, double, chunk) {
        let cursor = this.#cursor;
        do {
          const byte = chunk[cursor];
          switch (byte) {
            case ASCII.E:
            case ASCII.e:
              this.#cursor = cursor + 1;
              const d = isNegative ? -double : double;
              return this.#cursor === chunk.length ? this.#decodeDoubleExponent.bind(this, d) : this.#decodeDoubleExponent(d, chunk);
            case ASCII["\r"]:
              this.#cursor = cursor + 2;
              return isNegative ? -double : double;
          }
          if (decimalIndex < _a2.#DOUBLE_DECIMAL_MULTIPLIERS.length) {
            double += (byte - ASCII["0"]) * _a2.#DOUBLE_DECIMAL_MULTIPLIERS[decimalIndex++];
          }
        } while (++cursor < chunk.length);
        this.#cursor = cursor;
        return this.#decodeDoubleDecimal.bind(this, isNegative, decimalIndex, double);
      }
      #decodeDoubleExponent(double, chunk) {
        switch (chunk[this.#cursor]) {
          case ASCII["+"]:
            return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, false, double, 0) : this.#continueDecodeDoubleExponent(false, double, 0, chunk);
          case ASCII["-"]:
            return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, true, double, 0) : this.#continueDecodeDoubleExponent(true, double, 0, chunk);
        }
        return this.#continueDecodeDoubleExponent(false, double, 0, chunk);
      }
      #continueDecodeDoubleExponent(isNegative, double, exponent, chunk) {
        let cursor = this.#cursor;
        do {
          const byte = chunk[cursor];
          if (byte === ASCII["\r"]) {
            this.#cursor = cursor + 2;
            return double * 10 ** (isNegative ? -exponent : exponent);
          }
          exponent = exponent * 10 + byte - ASCII["0"];
        } while (++cursor < chunk.length);
        this.#cursor = cursor;
        return this.#continueDecodeDoubleExponent.bind(this, isNegative, double, exponent);
      }
      #findCRLF(chunk, cursor) {
        while (chunk[cursor] !== ASCII["\r"]) {
          if (++cursor === chunk.length) {
            this.#cursor = chunk.length;
            return -1;
          }
        }
        this.#cursor = cursor + 2;
        return cursor;
      }
      #decodeSimpleString(type, chunk) {
        const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
        if (crlfIndex === -1) {
          return this.#continueDecodeSimpleString.bind(this, [chunk.subarray(start)], type);
        }
        const slice = chunk.subarray(start, crlfIndex);
        return type === Buffer ? slice : slice.toString();
      }
      #continueDecodeSimpleString(chunks, type, chunk) {
        const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
        if (crlfIndex === -1) {
          chunks.push(chunk.subarray(start));
          return this.#continueDecodeSimpleString.bind(this, chunks, type);
        }
        chunks.push(chunk.subarray(start, crlfIndex));
        const buffer = Buffer.concat(chunks);
        return type === Buffer ? buffer : buffer.toString();
      }
      #decodeBlobString(type, chunk) {
        if (chunk[this.#cursor] === ASCII["-"]) {
          this.#cursor += 4;
          return null;
        }
        const length2 = this.#decodeUnsingedNumber(0, chunk);
        if (typeof length2 === "function") {
          return this.#continueDecodeBlobStringLength.bind(this, length2, type);
        } else if (this.#cursor >= chunk.length) {
          return this.#decodeBlobStringWithLength.bind(this, length2, type);
        }
        return this.#decodeBlobStringWithLength(length2, type, chunk);
      }
      #continueDecodeBlobStringLength(lengthCb, type, chunk) {
        const length2 = lengthCb(chunk);
        if (typeof length2 === "function") {
          return this.#continueDecodeBlobStringLength.bind(this, length2, type);
        } else if (this.#cursor >= chunk.length) {
          return this.#decodeBlobStringWithLength.bind(this, length2, type);
        }
        return this.#decodeBlobStringWithLength(length2, type, chunk);
      }
      #decodeStringWithLength(length2, skip, type, chunk) {
        const end = this.#cursor + length2;
        if (end >= chunk.length) {
          const slice2 = chunk.subarray(this.#cursor);
          this.#cursor = chunk.length;
          return this.#continueDecodeStringWithLength.bind(this, length2 - slice2.length, [slice2], skip, type);
        }
        const slice = chunk.subarray(this.#cursor, end);
        this.#cursor = end + skip;
        return type === Buffer ? slice : slice.toString();
      }
      #continueDecodeStringWithLength(length2, chunks, skip, type, chunk) {
        const end = this.#cursor + length2;
        if (end >= chunk.length) {
          const slice = chunk.subarray(this.#cursor);
          chunks.push(slice);
          this.#cursor = chunk.length;
          return this.#continueDecodeStringWithLength.bind(this, length2 - slice.length, chunks, skip, type);
        }
        chunks.push(chunk.subarray(this.#cursor, end));
        this.#cursor = end + skip;
        const buffer = Buffer.concat(chunks);
        return type === Buffer ? buffer : buffer.toString();
      }
      #decodeBlobStringWithLength(length2, type, chunk) {
        return this.#decodeStringWithLength(length2, 2, type, chunk);
      }
      #decodeVerbatimString(type, chunk) {
        return this.#continueDecodeVerbatimStringLength(this.#decodeUnsingedNumber.bind(this, 0), type, chunk);
      }
      #continueDecodeVerbatimStringLength(lengthCb, type, chunk) {
        const length2 = lengthCb(chunk);
        return typeof length2 === "function" ? this.#continueDecodeVerbatimStringLength.bind(this, length2, type) : this.#decodeVerbatimStringWithLength(length2, type, chunk);
      }
      #decodeVerbatimStringWithLength(length2, type, chunk) {
        const stringLength = length2 - 4;
        if (type === verbatim_string_1.VerbatimString) {
          return this.#decodeVerbatimStringFormat(stringLength, chunk);
        }
        this.#cursor += 4;
        return this.#cursor >= chunk.length ? this.#decodeBlobStringWithLength.bind(this, stringLength, type) : this.#decodeBlobStringWithLength(stringLength, type, chunk);
      }
      #decodeVerbatimStringFormat(stringLength, chunk) {
        const formatCb = this.#decodeStringWithLength.bind(this, 3, 1, String);
        return this.#cursor >= chunk.length ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, formatCb) : this.#continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk);
      }
      #continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk) {
        const format22 = formatCb(chunk);
        return typeof format22 === "function" ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, format22) : this.#decodeVerbatimStringWithFormat(stringLength, format22, chunk);
      }
      #decodeVerbatimStringWithFormat(stringLength, format22, chunk) {
        return this.#continueDecodeVerbatimStringWithFormat(format22, this.#decodeBlobStringWithLength.bind(this, stringLength, String), chunk);
      }
      #continueDecodeVerbatimStringWithFormat(format22, stringCb, chunk) {
        const string = stringCb(chunk);
        return typeof string === "function" ? this.#continueDecodeVerbatimStringWithFormat.bind(this, format22, string) : new verbatim_string_1.VerbatimString(format22, string);
      }
      #decodeSimpleError(chunk) {
        const string = this.#decodeSimpleString(String, chunk);
        return typeof string === "function" ? this.#continueDecodeSimpleError.bind(this, string) : new errors_1.SimpleError(string);
      }
      #continueDecodeSimpleError(stringCb, chunk) {
        const string = stringCb(chunk);
        return typeof string === "function" ? this.#continueDecodeSimpleError.bind(this, string) : new errors_1.SimpleError(string);
      }
      #decodeBlobError(chunk) {
        const string = this.#decodeBlobString(String, chunk);
        return typeof string === "function" ? this.#continueDecodeBlobError.bind(this, string) : new errors_1.BlobError(string);
      }
      #continueDecodeBlobError(stringCb, chunk) {
        const string = stringCb(chunk);
        return typeof string === "function" ? this.#continueDecodeBlobError.bind(this, string) : new errors_1.BlobError(string);
      }
      #decodeNestedType(typeMapping, chunk) {
        const type = chunk[this.#cursor];
        return ++this.#cursor === chunk.length ? this.#decodeNestedTypeValue.bind(this, type, typeMapping) : this.#decodeNestedTypeValue(type, typeMapping, chunk);
      }
      #decodeNestedTypeValue(type, typeMapping, chunk) {
        switch (type) {
          case exports.RESP_TYPES.NULL:
            return this.#decodeNull();
          case exports.RESP_TYPES.BOOLEAN:
            return this.#decodeBoolean(chunk);
          case exports.RESP_TYPES.NUMBER:
            return this.#decodeNumber(typeMapping[exports.RESP_TYPES.NUMBER], chunk);
          case exports.RESP_TYPES.BIG_NUMBER:
            return this.#decodeBigNumber(typeMapping[exports.RESP_TYPES.BIG_NUMBER], chunk);
          case exports.RESP_TYPES.DOUBLE:
            return this.#decodeDouble(typeMapping[exports.RESP_TYPES.DOUBLE], chunk);
          case exports.RESP_TYPES.SIMPLE_STRING:
            return this.#decodeSimpleString(typeMapping[exports.RESP_TYPES.SIMPLE_STRING], chunk);
          case exports.RESP_TYPES.BLOB_STRING:
            return this.#decodeBlobString(typeMapping[exports.RESP_TYPES.BLOB_STRING], chunk);
          case exports.RESP_TYPES.VERBATIM_STRING:
            return this.#decodeVerbatimString(typeMapping[exports.RESP_TYPES.VERBATIM_STRING], chunk);
          case exports.RESP_TYPES.SIMPLE_ERROR:
            return this.#decodeSimpleError(chunk);
          case exports.RESP_TYPES.BLOB_ERROR:
            return this.#decodeBlobError(chunk);
          case exports.RESP_TYPES.ARRAY:
            return this.#decodeArray(typeMapping, chunk);
          case exports.RESP_TYPES.SET:
            return this.#decodeSet(typeMapping, chunk);
          case exports.RESP_TYPES.MAP:
            return this.#decodeMap(typeMapping, chunk);
          default:
            throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
        }
      }
      #decodeArray(typeMapping, chunk) {
        if (chunk[this.#cursor] === ASCII["-"]) {
          this.#cursor += 4;
          return null;
        }
        return this.#decodeArrayWithLength(this.#decodeUnsingedNumber(0, chunk), typeMapping, chunk);
      }
      #decodeArrayWithLength(length2, typeMapping, chunk) {
        return typeof length2 === "function" ? this.#continueDecodeArrayLength.bind(this, length2, typeMapping) : this.#decodeArrayItems(new Array(length2), 0, typeMapping, chunk);
      }
      #continueDecodeArrayLength(lengthCb, typeMapping, chunk) {
        return this.#decodeArrayWithLength(lengthCb(chunk), typeMapping, chunk);
      }
      #decodeArrayItems(array, filled, typeMapping, chunk) {
        for (let i2 = filled; i2 < array.length; i2++) {
          if (this.#cursor >= chunk.length) {
            return this.#decodeArrayItems.bind(this, array, i2, typeMapping);
          }
          const item = this.#decodeNestedType(typeMapping, chunk);
          if (typeof item === "function") {
            return this.#continueDecodeArrayItems.bind(this, array, i2, item, typeMapping);
          }
          array[i2] = item;
        }
        return array;
      }
      #continueDecodeArrayItems(array, filled, itemCb, typeMapping, chunk) {
        const item = itemCb(chunk);
        if (typeof item === "function") {
          return this.#continueDecodeArrayItems.bind(this, array, filled, item, typeMapping);
        }
        array[filled++] = item;
        return this.#decodeArrayItems(array, filled, typeMapping, chunk);
      }
      #decodeSet(typeMapping, chunk) {
        const length2 = this.#decodeUnsingedNumber(0, chunk);
        if (typeof length2 === "function") {
          return this.#continueDecodeSetLength.bind(this, length2, typeMapping);
        }
        return this.#decodeSetItems(length2, typeMapping, chunk);
      }
      #continueDecodeSetLength(lengthCb, typeMapping, chunk) {
        const length2 = lengthCb(chunk);
        return typeof length2 === "function" ? this.#continueDecodeSetLength.bind(this, length2, typeMapping) : this.#decodeSetItems(length2, typeMapping, chunk);
      }
      #decodeSetItems(length2, typeMapping, chunk) {
        return typeMapping[exports.RESP_TYPES.SET] === Set ? this.#decodeSetAsSet(/* @__PURE__ */ new Set(), length2, typeMapping, chunk) : this.#decodeArrayItems(new Array(length2), 0, typeMapping, chunk);
      }
      #decodeSetAsSet(set, remaining, typeMapping, chunk) {
        while (remaining > 0) {
          if (this.#cursor >= chunk.length) {
            return this.#decodeSetAsSet.bind(this, set, remaining, typeMapping);
          }
          const item = this.#decodeNestedType(typeMapping, chunk);
          if (typeof item === "function") {
            return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
          }
          set.add(item);
          --remaining;
        }
        return set;
      }
      #continueDecodeSetAsSet(set, remaining, itemCb, typeMapping, chunk) {
        const item = itemCb(chunk);
        if (typeof item === "function") {
          return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
        }
        set.add(item);
        return this.#decodeSetAsSet(set, remaining - 1, typeMapping, chunk);
      }
      #decodeMap(typeMapping, chunk) {
        const length2 = this.#decodeUnsingedNumber(0, chunk);
        if (typeof length2 === "function") {
          return this.#continueDecodeMapLength.bind(this, length2, typeMapping);
        }
        return this.#decodeMapItems(length2, typeMapping, chunk);
      }
      #continueDecodeMapLength(lengthCb, typeMapping, chunk) {
        const length2 = lengthCb(chunk);
        return typeof length2 === "function" ? this.#continueDecodeMapLength.bind(this, length2, typeMapping) : this.#decodeMapItems(length2, typeMapping, chunk);
      }
      #decodeMapItems(length2, typeMapping, chunk) {
        switch (typeMapping[exports.RESP_TYPES.MAP]) {
          case Map:
            return this.#decodeMapAsMap(/* @__PURE__ */ new Map(), length2, typeMapping, chunk);
          case Array:
            return this.#decodeArrayItems(new Array(length2 * 2), 0, typeMapping, chunk);
          default:
            return this.#decodeMapAsObject(/* @__PURE__ */ Object.create(null), length2, typeMapping, chunk);
        }
      }
      #decodeMapAsMap(map, remaining, typeMapping, chunk) {
        while (remaining > 0) {
          if (this.#cursor >= chunk.length) {
            return this.#decodeMapAsMap.bind(this, map, remaining, typeMapping);
          }
          const key = this.#decodeMapKey(typeMapping, chunk);
          if (typeof key === "function") {
            return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
          }
          if (this.#cursor >= chunk.length) {
            return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
          }
          const value = this.#decodeNestedType(typeMapping, chunk);
          if (typeof value === "function") {
            return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
          }
          map.set(key, value);
          --remaining;
        }
        return map;
      }
      #decodeMapKey(typeMapping, chunk) {
        const type = chunk[this.#cursor];
        return ++this.#cursor === chunk.length ? this.#decodeMapKeyValue.bind(this, type, typeMapping) : this.#decodeMapKeyValue(type, typeMapping, chunk);
      }
      #decodeMapKeyValue(type, typeMapping, chunk) {
        switch (type) {
          // decode simple string map key as string (and not as buffer)
          case exports.RESP_TYPES.SIMPLE_STRING:
            return this.#decodeSimpleString(String, chunk);
          // decode blob string map key as string (and not as buffer)
          case exports.RESP_TYPES.BLOB_STRING:
            return this.#decodeBlobString(String, chunk);
          default:
            return this.#decodeNestedTypeValue(type, typeMapping, chunk);
        }
      }
      #continueDecodeMapKey(map, remaining, keyCb, typeMapping, chunk) {
        const key = keyCb(chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
        }
        map.set(key, value);
        return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
      }
      #continueDecodeMapValue(map, remaining, key, valueCb, typeMapping, chunk) {
        const value = valueCb(chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
        }
        map.set(key, value);
        return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
      }
      #decodeMapAsObject(object, remaining, typeMapping, chunk) {
        while (remaining > 0) {
          if (this.#cursor >= chunk.length) {
            return this.#decodeMapAsObject.bind(this, object, remaining, typeMapping);
          }
          const key = this.#decodeMapKey(typeMapping, chunk);
          if (typeof key === "function") {
            return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
          }
          if (this.#cursor >= chunk.length) {
            return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
          }
          const value = this.#decodeNestedType(typeMapping, chunk);
          if (typeof value === "function") {
            return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
          }
          object[key] = value;
          --remaining;
        }
        return object;
      }
      #continueDecodeMapAsObjectKey(object, remaining, keyCb, typeMapping, chunk) {
        const key = keyCb(chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
        }
        object[key] = value;
        return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
      }
      #continueDecodeMapAsObjectValue(object, remaining, key, valueCb, typeMapping, chunk) {
        const value = valueCb(chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
        }
        object[key] = value;
        return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
      }
    };
    exports.Decoder = Decoder2;
    _a2 = Decoder2;
  }
});
var require_lua_script = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/lua-script.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scriptSha1 = exports.defineScript = void 0;
    var node_crypto_1 = __require2("node:crypto");
    function defineScript(script) {
      return {
        ...script,
        SHA1: scriptSha1(script.SCRIPT)
      };
    }
    exports.defineScript = defineScript;
    function scriptSha1(script) {
      return (0, node_crypto_1.createHash)("sha1").update(script).digest("hex");
    }
    exports.scriptSha1 = scriptSha1;
  }
});
var require_ACL_CAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_CAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Lists ACL categories or commands in a category
       * @param parser - The Redis command parser
       * @param categoryName - Optional category name to filter commands
       */
      parseCommand(parser, categoryName) {
        parser.push("ACL", "CAT");
        if (categoryName) {
          parser.push(categoryName);
        }
      },
      transformReply: void 0
    };
  }
});
var require_ACL_DELUSER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_DELUSER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Deletes one or more users from the ACL
       * @param parser - The Redis command parser
       * @param username - Username(s) to delete
       */
      parseCommand(parser, username) {
        parser.push("ACL", "DELUSER");
        parser.pushVariadic(username);
      },
      transformReply: void 0
    };
  }
});
var require_ACL_DRYRUN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_DRYRUN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Simulates ACL operations without executing them
       * @param parser - The Redis command parser
       * @param username - Username to simulate ACL operations for
       * @param command - Command arguments to simulate
       */
      parseCommand(parser, username, command) {
        parser.push("ACL", "DRYRUN", username, ...command);
      },
      transformReply: void 0
    };
  }
});
var require_ACL_GENPASS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_GENPASS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Generates a secure password for ACL users
       * @param parser - The Redis command parser
       * @param bits - Optional number of bits for password entropy
       */
      parseCommand(parser, bits) {
        parser.push("ACL", "GENPASS");
        if (bits) {
          parser.push(bits.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_ACL_GETUSER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_GETUSER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns ACL information about a specific user
       * @param parser - The Redis command parser
       * @param username - Username to get information for
       */
      parseCommand(parser, username) {
        parser.push("ACL", "GETUSER", username);
      },
      transformReply: {
        2: (reply) => ({
          flags: reply[1],
          passwords: reply[3],
          commands: reply[5],
          keys: reply[7],
          channels: reply[9],
          selectors: reply[11]?.map((selector) => {
            const inferred = selector;
            return {
              commands: inferred[1],
              keys: inferred[3],
              channels: inferred[5]
            };
          })
        }),
        3: void 0
      }
    };
  }
});
var require_ACL_LIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_LIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns all configured ACL users and their permissions
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("ACL", "LIST");
      },
      transformReply: void 0
    };
  }
});
var require_ACL_LOAD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_LOAD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Reloads ACL configuration from the ACL file
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("ACL", "LOAD");
      },
      transformReply: void 0
    };
  }
});
var require_parser = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicCommandParser = void 0;
    var BasicCommandParser = class {
      #redisArgs = [];
      #keys = [];
      preserve;
      get redisArgs() {
        return this.#redisArgs;
      }
      get keys() {
        return this.#keys;
      }
      get firstKey() {
        return this.#keys[0];
      }
      get cacheKey() {
        const tmp = new Array(this.#redisArgs.length * 2);
        for (let i2 = 0; i2 < this.#redisArgs.length; i2++) {
          tmp[i2] = this.#redisArgs[i2].length;
          tmp[i2 + this.#redisArgs.length] = this.#redisArgs[i2];
        }
        return tmp.join("_");
      }
      push(...arg) {
        this.#redisArgs.push(...arg);
      }
      pushVariadic(vals) {
        if (Array.isArray(vals)) {
          for (const val of vals) {
            this.push(val);
          }
        } else {
          this.push(vals);
        }
      }
      pushVariadicWithLength(vals) {
        if (Array.isArray(vals)) {
          this.#redisArgs.push(vals.length.toString());
        } else {
          this.#redisArgs.push("1");
        }
        this.pushVariadic(vals);
      }
      pushVariadicNumber(vals) {
        if (Array.isArray(vals)) {
          for (const val of vals) {
            this.push(val.toString());
          }
        } else {
          this.push(vals.toString());
        }
      }
      pushKey(key) {
        this.#keys.push(key);
        this.#redisArgs.push(key);
      }
      pushKeysLength(keys) {
        if (Array.isArray(keys)) {
          this.#redisArgs.push(keys.length.toString());
        } else {
          this.#redisArgs.push("1");
        }
        this.pushKeys(keys);
      }
      pushKeys(keys) {
        if (Array.isArray(keys)) {
          this.#keys.push(...keys);
          this.#redisArgs.push(...keys);
        } else {
          this.#keys.push(keys);
          this.#redisArgs.push(keys);
        }
      }
    };
    exports.BasicCommandParser = BasicCommandParser;
  }
});
var require_generic_transformers = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/generic-transformers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = exports.transformStreamsMessagesReplyResp3 = exports.transformStreamsMessagesReplyResp2 = exports.transformStreamMessagesReply = exports.transformStreamMessageNullReply = exports.transformStreamMessageReply = exports.parseArgs = exports.parseZKeysArguments = exports.transformRangeReply = exports.parseSlotRangesArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.parseOptionalVariadicArgument = exports.pushVariadicArgument = exports.pushVariadicNumberArguments = exports.pushVariadicArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformSortedSetReply = exports.transformTuplesReply = exports.createTransformTuplesReplyFunc = exports.transformTuplesToMap = exports.transformNullableDoubleReply = exports.createTransformNullableDoubleReplyResp2Func = exports.transformDoubleArrayReply = exports.createTransformDoubleReplyResp2Func = exports.transformDoubleReply = exports.transformStringDoubleArgument = exports.transformDoubleArgument = exports.transformBooleanArrayReply = exports.transformBooleanReply = exports.isArrayReply = exports.isNullReply = void 0;
    var parser_1 = require_parser();
    var decoder_1 = require_decoder();
    function isNullReply(reply) {
      return reply === null;
    }
    exports.isNullReply = isNullReply;
    function isArrayReply(reply) {
      return Array.isArray(reply);
    }
    exports.isArrayReply = isArrayReply;
    exports.transformBooleanReply = {
      2: (reply) => reply === 1,
      3: void 0
    };
    exports.transformBooleanArrayReply = {
      2: (reply) => {
        return reply.map(exports.transformBooleanReply[2]);
      },
      3: void 0
    };
    function transformDoubleArgument(num) {
      switch (num) {
        case Infinity:
          return "+inf";
        case -Infinity:
          return "-inf";
        default:
          return num.toString();
      }
    }
    exports.transformDoubleArgument = transformDoubleArgument;
    function transformStringDoubleArgument(num) {
      if (typeof num !== "number")
        return num;
      return transformDoubleArgument(num);
    }
    exports.transformStringDoubleArgument = transformStringDoubleArgument;
    exports.transformDoubleReply = {
      2: (reply, preserve, typeMapping) => {
        const double = typeMapping ? typeMapping[decoder_1.RESP_TYPES.DOUBLE] : void 0;
        switch (double) {
          case String: {
            return reply;
          }
          default: {
            let ret;
            switch (reply.toString()) {
              case "inf":
              case "+inf":
                ret = Infinity;
              case "-inf":
                ret = -Infinity;
              case "nan":
                ret = NaN;
              default:
                ret = Number(reply);
            }
            return ret;
          }
        }
      },
      3: void 0
    };
    function createTransformDoubleReplyResp2Func(preserve, typeMapping) {
      return (reply) => {
        return exports.transformDoubleReply[2](reply, preserve, typeMapping);
      };
    }
    exports.createTransformDoubleReplyResp2Func = createTransformDoubleReplyResp2Func;
    exports.transformDoubleArrayReply = {
      2: (reply, preserve, typeMapping) => {
        return reply.map(createTransformDoubleReplyResp2Func(preserve, typeMapping));
      },
      3: void 0
    };
    function createTransformNullableDoubleReplyResp2Func(preserve, typeMapping) {
      return (reply) => {
        return exports.transformNullableDoubleReply[2](reply, preserve, typeMapping);
      };
    }
    exports.createTransformNullableDoubleReplyResp2Func = createTransformNullableDoubleReplyResp2Func;
    exports.transformNullableDoubleReply = {
      2: (reply, preserve, typeMapping) => {
        if (reply === null)
          return null;
        return exports.transformDoubleReply[2](reply, preserve, typeMapping);
      },
      3: void 0
    };
    function transformTuplesToMap(reply, func) {
      const message = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0; i2 < reply.length; i2 += 2) {
        message[reply[i2].toString()] = func(reply[i2 + 1]);
      }
      return message;
    }
    exports.transformTuplesToMap = transformTuplesToMap;
    function createTransformTuplesReplyFunc(preserve, typeMapping) {
      return (reply) => {
        return transformTuplesReply(reply, preserve, typeMapping);
      };
    }
    exports.createTransformTuplesReplyFunc = createTransformTuplesReplyFunc;
    function transformTuplesReply(reply, preserve, typeMapping) {
      const mapType = typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : void 0;
      const inferred = reply;
      switch (mapType) {
        case Array: {
          return reply;
        }
        case Map: {
          const ret = /* @__PURE__ */ new Map();
          for (let i2 = 0; i2 < inferred.length; i2 += 2) {
            ret.set(inferred[i2].toString(), inferred[i2 + 1]);
          }
          return ret;
          ;
        }
        default: {
          const ret = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < inferred.length; i2 += 2) {
            ret[inferred[i2].toString()] = inferred[i2 + 1];
          }
          return ret;
          ;
        }
      }
    }
    exports.transformTuplesReply = transformTuplesReply;
    exports.transformSortedSetReply = {
      2: (reply, preserve, typeMapping) => {
        const inferred = reply, members = [];
        for (let i2 = 0; i2 < inferred.length; i2 += 2) {
          members.push({
            value: inferred[i2],
            score: exports.transformDoubleReply[2](inferred[i2 + 1], preserve, typeMapping)
          });
        }
        return members;
      },
      3: (reply) => {
        return reply.map((member) => {
          const [value, score] = member;
          return {
            value,
            score
          };
        });
      }
    };
    function transformEXAT(EXAT) {
      return (typeof EXAT === "number" ? EXAT : Math.floor(EXAT.getTime() / 1e3)).toString();
    }
    exports.transformEXAT = transformEXAT;
    function transformPXAT(PXAT) {
      return (typeof PXAT === "number" ? PXAT : PXAT.getTime()).toString();
    }
    exports.transformPXAT = transformPXAT;
    function evalFirstKeyIndex(options2) {
      return options2?.keys?.[0];
    }
    exports.evalFirstKeyIndex = evalFirstKeyIndex;
    function pushEvalArguments(args, options2) {
      if (options2?.keys) {
        args.push(options2.keys.length.toString(), ...options2.keys);
      } else {
        args.push("0");
      }
      if (options2?.arguments) {
        args.push(...options2.arguments);
      }
      return args;
    }
    exports.pushEvalArguments = pushEvalArguments;
    function pushVariadicArguments(args, value) {
      if (Array.isArray(value)) {
        args = args.concat(value);
      } else {
        args.push(value);
      }
      return args;
    }
    exports.pushVariadicArguments = pushVariadicArguments;
    function pushVariadicNumberArguments(args, value) {
      if (Array.isArray(value)) {
        for (const item of value) {
          args.push(item.toString());
        }
      } else {
        args.push(value.toString());
      }
      return args;
    }
    exports.pushVariadicNumberArguments = pushVariadicNumberArguments;
    function pushVariadicArgument(args, value) {
      if (Array.isArray(value)) {
        args.push(value.length.toString(), ...value);
      } else {
        args.push("1", value);
      }
      return args;
    }
    exports.pushVariadicArgument = pushVariadicArgument;
    function parseOptionalVariadicArgument(parser, name, value) {
      if (value === void 0)
        return;
      parser.push(name);
      parser.pushVariadicWithLength(value);
    }
    exports.parseOptionalVariadicArgument = parseOptionalVariadicArgument;
    var CommandFlags;
    (function(CommandFlags2) {
      CommandFlags2["WRITE"] = "write";
      CommandFlags2["READONLY"] = "readonly";
      CommandFlags2["DENYOOM"] = "denyoom";
      CommandFlags2["ADMIN"] = "admin";
      CommandFlags2["PUBSUB"] = "pubsub";
      CommandFlags2["NOSCRIPT"] = "noscript";
      CommandFlags2["RANDOM"] = "random";
      CommandFlags2["SORT_FOR_SCRIPT"] = "sort_for_script";
      CommandFlags2["LOADING"] = "loading";
      CommandFlags2["STALE"] = "stale";
      CommandFlags2["SKIP_MONITOR"] = "skip_monitor";
      CommandFlags2["ASKING"] = "asking";
      CommandFlags2["FAST"] = "fast";
      CommandFlags2["MOVABLEKEYS"] = "movablekeys";
    })(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
    var CommandCategories;
    (function(CommandCategories2) {
      CommandCategories2["KEYSPACE"] = "@keyspace";
      CommandCategories2["READ"] = "@read";
      CommandCategories2["WRITE"] = "@write";
      CommandCategories2["SET"] = "@set";
      CommandCategories2["SORTEDSET"] = "@sortedset";
      CommandCategories2["LIST"] = "@list";
      CommandCategories2["HASH"] = "@hash";
      CommandCategories2["STRING"] = "@string";
      CommandCategories2["BITMAP"] = "@bitmap";
      CommandCategories2["HYPERLOGLOG"] = "@hyperloglog";
      CommandCategories2["GEO"] = "@geo";
      CommandCategories2["STREAM"] = "@stream";
      CommandCategories2["PUBSUB"] = "@pubsub";
      CommandCategories2["ADMIN"] = "@admin";
      CommandCategories2["FAST"] = "@fast";
      CommandCategories2["SLOW"] = "@slow";
      CommandCategories2["BLOCKING"] = "@blocking";
      CommandCategories2["DANGEROUS"] = "@dangerous";
      CommandCategories2["CONNECTION"] = "@connection";
      CommandCategories2["TRANSACTION"] = "@transaction";
      CommandCategories2["SCRIPTING"] = "@scripting";
    })(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
    function transformCommandReply([name, arity, flags, firstKeyIndex, lastKeyIndex, step, categories]) {
      return {
        name,
        arity,
        flags: new Set(flags),
        firstKeyIndex,
        lastKeyIndex,
        step,
        categories: new Set(categories)
      };
    }
    exports.transformCommandReply = transformCommandReply;
    var RedisFunctionFlags;
    (function(RedisFunctionFlags2) {
      RedisFunctionFlags2["NO_WRITES"] = "no-writes";
      RedisFunctionFlags2["ALLOW_OOM"] = "allow-oom";
      RedisFunctionFlags2["ALLOW_STALE"] = "allow-stale";
      RedisFunctionFlags2["NO_CLUSTER"] = "no-cluster";
    })(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
    function transformFunctionListItemReply(reply) {
      return {
        libraryName: reply[1],
        engine: reply[3],
        functions: reply[5].map((fn) => ({
          name: fn[1],
          description: fn[3],
          flags: fn[5]
        }))
      };
    }
    exports.transformFunctionListItemReply = transformFunctionListItemReply;
    function parseSlotRangeArguments(parser, range) {
      parser.push(range.start.toString(), range.end.toString());
    }
    function parseSlotRangesArguments(parser, ranges) {
      if (Array.isArray(ranges)) {
        for (const range of ranges) {
          parseSlotRangeArguments(parser, range);
        }
      } else {
        parseSlotRangeArguments(parser, ranges);
      }
    }
    exports.parseSlotRangesArguments = parseSlotRangesArguments;
    function transformRangeReply([start, end]) {
      return {
        start,
        end
      };
    }
    exports.transformRangeReply = transformRangeReply;
    function parseZKeysArguments(parser, keys) {
      if (Array.isArray(keys)) {
        parser.push(keys.length.toString());
        if (keys.length) {
          if (isPlainKeys(keys)) {
            parser.pushKeys(keys);
          } else {
            for (let i2 = 0; i2 < keys.length; i2++) {
              parser.pushKey(keys[i2].key);
            }
            parser.push("WEIGHTS");
            for (let i2 = 0; i2 < keys.length; i2++) {
              parser.push(transformDoubleArgument(keys[i2].weight));
            }
          }
        }
      } else {
        parser.push("1");
        if (isPlainKey(keys)) {
          parser.pushKey(keys);
        } else {
          parser.pushKey(keys.key);
          parser.push("WEIGHTS", transformDoubleArgument(keys.weight));
        }
      }
    }
    exports.parseZKeysArguments = parseZKeysArguments;
    function isPlainKey(key) {
      return typeof key === "string" || key instanceof Buffer;
    }
    function isPlainKeys(keys) {
      return isPlainKey(keys[0]);
    }
    function parseArgs(command, ...args) {
      const parser = new parser_1.BasicCommandParser();
      command.parseCommand(parser, ...args);
      const redisArgs = parser.redisArgs;
      if (parser.preserve) {
        redisArgs.preserve = parser.preserve;
      }
      return redisArgs;
    }
    exports.parseArgs = parseArgs;
    function transformStreamMessageReply(typeMapping, reply) {
      const [id, message] = reply;
      return {
        id,
        message: transformTuplesReply(message, void 0, typeMapping)
      };
    }
    exports.transformStreamMessageReply = transformStreamMessageReply;
    function transformStreamMessageNullReply(typeMapping, reply) {
      return isNullReply(reply) ? reply : transformStreamMessageReply(typeMapping, reply);
    }
    exports.transformStreamMessageNullReply = transformStreamMessageNullReply;
    function transformStreamMessagesReply(r, typeMapping) {
      const reply = r;
      return reply.map(transformStreamMessageReply.bind(void 0, typeMapping));
    }
    exports.transformStreamMessagesReply = transformStreamMessagesReply;
    function transformStreamsMessagesReplyResp2(reply, preserve, typeMapping) {
      if (reply === null)
        return null;
      switch (typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : void 0) {
        /* FUTURE: a response type for when resp3 is working properly
            case Map: {
              const ret = new Map<string, StreamMessagesReply>();
        
              for (let i=0; i < reply.length; i++) {
                const stream = reply[i] as unknown as UnwrapReply<StreamMessagesRawReply>;
            
                const name = stream[0];
                const rawMessages = stream[1];
            
                ret.set(name.toString(), transformStreamMessagesReply(rawMessages, typeMapping));
              }
            
              return ret as unknown as MapReply<string, StreamMessagesReply>;
            }
            case Array: {
              const ret: Array<BlobStringReply | StreamMessagesReply> = [];
        
              for (let i=0; i < reply.length; i++) {
                const stream = reply[i] as unknown as UnwrapReply<StreamMessagesRawReply>;
            
                const name = stream[0];
                const rawMessages = stream[1];
            
                ret.push(name);
                ret.push(transformStreamMessagesReply(rawMessages, typeMapping));
              }
        
              return ret as unknown as MapReply<string, StreamMessagesReply>;
            }
            default: {
              const ret: Record<string, StreamMessagesReply> = Object.create(null);
        
              for (let i=0; i < reply.length; i++) {
                const stream = reply[i] as unknown as UnwrapReply<StreamMessagesRawReply>;
            
                const name = stream[0] as unknown as UnwrapReply<BlobStringReply>;
                const rawMessages = stream[1];
            
                ret[name.toString()] = transformStreamMessagesReply(rawMessages);
              }
            
              return ret as unknown as MapReply<string, StreamMessagesReply>;
            }
        */
        // V4 compatible response type
        default: {
          const ret = [];
          for (let i2 = 0; i2 < reply.length; i2++) {
            const stream = reply[i2];
            ret.push({
              name: stream[0],
              messages: transformStreamMessagesReply(stream[1])
            });
          }
          return ret;
        }
      }
    }
    exports.transformStreamsMessagesReplyResp2 = transformStreamsMessagesReplyResp2;
    function transformStreamsMessagesReplyResp3(reply) {
      if (reply === null)
        return null;
      if (reply instanceof Map) {
        const ret = /* @__PURE__ */ new Map();
        for (const [n, rawMessages] of reply) {
          const name = n;
          ret.set(name.toString(), transformStreamMessagesReply(rawMessages));
        }
        return ret;
      } else if (reply instanceof Array) {
        const ret = [];
        for (let i2 = 0; i2 < reply.length; i2 += 2) {
          const name = reply[i2];
          const rawMessages = reply[i2 + 1];
          ret.push(name);
          ret.push(transformStreamMessagesReply(rawMessages));
        }
        return ret;
      } else {
        const ret = /* @__PURE__ */ Object.create(null);
        for (const [name, rawMessages] of Object.entries(reply)) {
          ret[name] = transformStreamMessagesReply(rawMessages);
        }
        return ret;
      }
    }
    exports.transformStreamsMessagesReplyResp3 = transformStreamsMessagesReplyResp3;
    function transformRedisJsonArgument(json) {
      return JSON.stringify(json);
    }
    exports.transformRedisJsonArgument = transformRedisJsonArgument;
    function transformRedisJsonReply(json) {
      const res = JSON.parse(json.toString());
      return res;
    }
    exports.transformRedisJsonReply = transformRedisJsonReply;
    function transformRedisJsonNullReply(json) {
      return isNullReply(json) ? json : transformRedisJsonReply(json);
    }
    exports.transformRedisJsonNullReply = transformRedisJsonNullReply;
  }
});
var require_ACL_LOG = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_LOG.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns ACL security events log entries
       * @param parser - The Redis command parser
       * @param count - Optional maximum number of entries to return
       */
      parseCommand(parser, count) {
        parser.push("ACL", "LOG");
        if (count != void 0) {
          parser.push(count.toString());
        }
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          return reply.map((item) => {
            const inferred = item;
            return {
              count: inferred[1],
              reason: inferred[3],
              context: inferred[5],
              object: inferred[7],
              username: inferred[9],
              "age-seconds": generic_transformers_1.transformDoubleReply[2](inferred[11], preserve, typeMapping),
              "client-info": inferred[13],
              "entry-id": inferred[15],
              "timestamp-created": inferred[17],
              "timestamp-last-updated": inferred[19]
            };
          });
        },
        3: void 0
      }
    };
  }
});
var require_ACL_LOG_RESET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_LOG_RESET.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ACL_LOG_1 = __importDefault(require_ACL_LOG());
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: ACL_LOG_1.default.IS_READ_ONLY,
      /**
       * Clears the ACL security events log
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("ACL", "LOG", "RESET");
      },
      transformReply: void 0
    };
  }
});
var require_ACL_SAVE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_SAVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Saves the current ACL configuration to the ACL file
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("ACL", "SAVE");
      },
      transformReply: void 0
    };
  }
});
var require_ACL_SETUSER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_SETUSER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Creates or modifies ACL user with specified rules
       * @param parser - The Redis command parser
       * @param username - Username to create or modify
       * @param rule - ACL rule(s) to apply to the user
       */
      parseCommand(parser, username, rule) {
        parser.push("ACL", "SETUSER", username);
        parser.pushVariadic(rule);
      },
      transformReply: void 0
    };
  }
});
var require_ACL_USERS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_USERS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns a list of all configured ACL usernames
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("ACL", "USERS");
      },
      transformReply: void 0
    };
  }
});
var require_ACL_WHOAMI = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ACL_WHOAMI.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the username of the current connection
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("ACL", "WHOAMI");
      },
      transformReply: void 0
    };
  }
});
var require_APPEND = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/APPEND.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Appends a value to a string key
       * @param parser - The Redis command parser
       * @param key - The key to append to
       * @param value - The value to append
       */
      parseCommand(parser, key, value) {
        parser.push("APPEND", key, value);
      },
      transformReply: void 0
    };
  }
});
var require_ASKING = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ASKING.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ASKING_CMD = void 0;
    exports.ASKING_CMD = "ASKING";
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Tells a Redis cluster node that the client is ok receiving such redirects
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push(exports.ASKING_CMD);
      },
      transformReply: void 0
    };
  }
});
var require_AUTH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/AUTH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Authenticates the connection using a password or username and password
       * @param parser - The Redis command parser
       * @param options - Authentication options containing username and/or password
       * @param options.username - Optional username for authentication
       * @param options.password - Password for authentication
       */
      parseCommand(parser, { username, password }) {
        parser.push("AUTH");
        if (username !== void 0) {
          parser.push(username);
        }
        parser.push(password);
      },
      transformReply: void 0
    };
  }
});
var require_BGREWRITEAOF = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BGREWRITEAOF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Asynchronously rewrites the append-only file
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("BGREWRITEAOF");
      },
      transformReply: void 0
    };
  }
});
var require_BGSAVE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BGSAVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Asynchronously saves the dataset to disk
       * @param parser - The Redis command parser
       * @param options - Optional configuration
       * @param options.SCHEDULE - Schedule a BGSAVE operation when no BGSAVE is already in progress
       */
      parseCommand(parser, options2) {
        parser.push("BGSAVE");
        if (options2?.SCHEDULE) {
          parser.push("SCHEDULE");
        }
      },
      transformReply: void 0
    };
  }
});
var require_BITCOUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BITCOUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the count of set bits in a string key
       * @param parser - The Redis command parser
       * @param key - The key to count bits in
       * @param range - Optional range specification
       * @param range.start - Start offset in bytes/bits
       * @param range.end - End offset in bytes/bits
       * @param range.mode - Optional counting mode: BYTE or BIT
       */
      parseCommand(parser, key, range) {
        parser.push("BITCOUNT");
        parser.pushKey(key);
        if (range) {
          parser.push(range.start.toString());
          parser.push(range.end.toString());
          if (range.mode) {
            parser.push(range.mode);
          }
        }
      },
      transformReply: void 0
    };
  }
});
var require_BITFIELD_RO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BITFIELD_RO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Performs read-only bitfield integer operations on strings
       * @param parser - The Redis command parser
       * @param key - The key holding the string
       * @param operations - Array of GET operations to perform on the bitfield
       */
      parseCommand(parser, key, operations) {
        parser.push("BITFIELD_RO");
        parser.pushKey(key);
        for (const operation of operations) {
          parser.push("GET");
          parser.push(operation.encoding);
          parser.push(operation.offset.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_BITFIELD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BITFIELD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Performs arbitrary bitfield integer operations on strings
       * @param parser - The Redis command parser
       * @param key - The key holding the string
       * @param operations - Array of bitfield operations to perform: GET, SET, INCRBY or OVERFLOW
       */
      parseCommand(parser, key, operations) {
        parser.push("BITFIELD");
        parser.pushKey(key);
        for (const options2 of operations) {
          switch (options2.operation) {
            case "GET":
              parser.push("GET", options2.encoding, options2.offset.toString());
              break;
            case "SET":
              parser.push("SET", options2.encoding, options2.offset.toString(), options2.value.toString());
              break;
            case "INCRBY":
              parser.push("INCRBY", options2.encoding, options2.offset.toString(), options2.increment.toString());
              break;
            case "OVERFLOW":
              parser.push("OVERFLOW", options2.behavior);
              break;
          }
        }
      },
      transformReply: void 0
    };
  }
});
var require_BITOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BITOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Performs bitwise operations between strings
       * @param parser - The Redis command parser
       * @param operation - Bitwise operation to perform: AND, OR, XOR, NOT, DIFF, DIFF1, ANDOR, ONE
       * @param destKey - Destination key to store the result
       * @param key - Source key(s) to perform operation on
       */
      parseCommand(parser, operation, destKey, key) {
        parser.push("BITOP", operation);
        parser.pushKey(destKey);
        parser.pushKeys(key);
      },
      transformReply: void 0
    };
  }
});
var require_BITPOS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BITPOS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the position of first bit set to 0 or 1 in a string
       * @param parser - The Redis command parser
       * @param key - The key holding the string
       * @param bit - The bit value to look for (0 or 1)
       * @param start - Optional starting position in bytes/bits
       * @param end - Optional ending position in bytes/bits
       * @param mode - Optional counting mode: BYTE or BIT
       */
      parseCommand(parser, key, bit, start, end, mode) {
        parser.push("BITPOS");
        parser.pushKey(key);
        parser.push(bit.toString());
        if (start !== void 0) {
          parser.push(start.toString());
        }
        if (end !== void 0) {
          parser.push(end.toString());
        }
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_BLMOVE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BLMOVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Pop an element from a list, push it to another list and return it; or block until one is available
       * @param parser - The Redis command parser
       * @param source - Key of the source list
       * @param destination - Key of the destination list
       * @param sourceSide - Side of source list to pop from (LEFT or RIGHT)
       * @param destinationSide - Side of destination list to push to (LEFT or RIGHT)
       * @param timeout - Timeout in seconds, 0 to block indefinitely
       */
      parseCommand(parser, source, destination, sourceSide, destinationSide, timeout) {
        parser.push("BLMOVE");
        parser.pushKeys([source, destination]);
        parser.push(sourceSide, destinationSide, timeout.toString());
      },
      transformReply: void 0
    };
  }
});
var require_LMPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LMPOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseLMPopArguments = void 0;
    function parseLMPopArguments(parser, keys, side, options2) {
      parser.pushKeysLength(keys);
      parser.push(side);
      if (options2?.COUNT !== void 0) {
        parser.push("COUNT", options2.COUNT.toString());
      }
    }
    exports.parseLMPopArguments = parseLMPopArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the LMPOP command
       *
       * @param parser - The command parser
       * @param args - Arguments including keys, side (LEFT or RIGHT), and options
       * @see https://redis.io/commands/lmpop/
       */
      parseCommand(parser, ...args) {
        parser.push("LMPOP");
        parseLMPopArguments(parser, ...args);
      },
      transformReply: void 0
    };
  }
});
var require_BLMPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BLMPOP.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var LMPOP_1 = __importStar(require_LMPOP());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Pops elements from multiple lists; blocks until elements are available
       * @param parser - The Redis command parser
       * @param timeout - Timeout in seconds, 0 to block indefinitely
       * @param args - Additional arguments for LMPOP command
       */
      parseCommand(parser, timeout, ...args) {
        parser.push("BLMPOP", timeout.toString());
        (0, LMPOP_1.parseLMPopArguments)(parser, ...args);
      },
      transformReply: LMPOP_1.default.transformReply
    };
  }
});
var require_BLPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BLPOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Removes and returns the first element in a list, or blocks until one is available
       * @param parser - The Redis command parser
       * @param key - Key of the list to pop from, or array of keys to try sequentially
       * @param timeout - Maximum seconds to block, 0 to block indefinitely
       */
      parseCommand(parser, key, timeout) {
        parser.push("BLPOP");
        parser.pushKeys(key);
        parser.push(timeout.toString());
      },
      transformReply(reply) {
        if (reply === null)
          return null;
        return {
          key: reply[0],
          element: reply[1]
        };
      }
    };
  }
});
var require_BRPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BRPOP.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BLPOP_1 = __importDefault(require_BLPOP());
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Removes and returns the last element in a list, or blocks until one is available
       * @param parser - The Redis command parser
       * @param key - Key of the list to pop from, or array of keys to try sequentially
       * @param timeout - Maximum seconds to block, 0 to block indefinitely
       */
      parseCommand(parser, key, timeout) {
        parser.push("BRPOP");
        parser.pushKeys(key);
        parser.push(timeout.toString());
      },
      transformReply: BLPOP_1.default.transformReply
    };
  }
});
var require_BRPOPLPUSH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BRPOPLPUSH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Pops an element from a list, pushes it to another list and returns it; blocks until element is available
       * @param parser - The Redis command parser
       * @param source - Key of the source list to pop from
       * @param destination - Key of the destination list to push to
       * @param timeout - Maximum seconds to block, 0 to block indefinitely
       */
      parseCommand(parser, source, destination, timeout) {
        parser.push("BRPOPLPUSH");
        parser.pushKeys([source, destination]);
        parser.push(timeout.toString());
      },
      transformReply: void 0
    };
  }
});
var require_ZMPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZMPOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseZMPopArguments = void 0;
    var generic_transformers_1 = require_generic_transformers();
    function parseZMPopArguments(parser, keys, side, options2) {
      parser.pushKeysLength(keys);
      parser.push(side);
      if (options2?.COUNT) {
        parser.push("COUNT", options2.COUNT.toString());
      }
    }
    exports.parseZMPopArguments = parseZMPopArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns up to count members with the highest/lowest scores from the first non-empty sorted set.
       * @param parser - The Redis command parser.
       * @param keys - Keys of the sorted sets to pop from.
       * @param side - Side to pop from (MIN or MAX).
       * @param options - Optional parameters including COUNT.
       */
      parseCommand(parser, keys, side, options2) {
        parser.push("ZMPOP");
        parseZMPopArguments(parser, keys, side, options2);
      },
      transformReply: {
        2(reply, preserve, typeMapping) {
          return reply === null ? null : {
            key: reply[0],
            members: reply[1].map((member) => {
              const [value, score] = member;
              return {
                value,
                score: generic_transformers_1.transformDoubleReply[2](score, preserve, typeMapping)
              };
            })
          };
        },
        3(reply) {
          return reply === null ? null : {
            key: reply[0],
            members: generic_transformers_1.transformSortedSetReply[3](reply[1])
          };
        }
      }
    };
  }
});
var require_BZMPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BZMPOP.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZMPOP_1 = __importStar(require_ZMPOP());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns members from one or more sorted sets in the specified order; blocks until elements are available
       * @param parser - The Redis command parser
       * @param timeout - Maximum seconds to block, 0 to block indefinitely
       * @param args - Additional arguments specifying the keys, min/max count, and order (MIN/MAX)
       */
      parseCommand(parser, timeout, ...args) {
        parser.push("BZMPOP", timeout.toString());
        (0, ZMPOP_1.parseZMPopArguments)(parser, ...args);
      },
      transformReply: ZMPOP_1.default.transformReply
    };
  }
});
var require_BZPOPMAX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BZPOPMAX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns the member with the highest score in a sorted set, or blocks until one is available
       * @param parser - The Redis command parser
       * @param keys - Key of the sorted set, or array of keys to try sequentially
       * @param timeout - Maximum seconds to block, 0 to block indefinitely
       */
      parseCommand(parser, keys, timeout) {
        parser.push("BZPOPMAX");
        parser.pushKeys(keys);
        parser.push(timeout.toString());
      },
      transformReply: {
        2(reply, preserve, typeMapping) {
          return reply === null ? null : {
            key: reply[0],
            value: reply[1],
            score: generic_transformers_1.transformDoubleReply[2](reply[2], preserve, typeMapping)
          };
        },
        3(reply) {
          return reply === null ? null : {
            key: reply[0],
            value: reply[1],
            score: reply[2]
          };
        }
      }
    };
  }
});
var require_BZPOPMIN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/BZPOPMIN.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
    exports.default = {
      IS_READ_ONLY: BZPOPMAX_1.default.IS_READ_ONLY,
      /**
       * Removes and returns the member with the lowest score in a sorted set, or blocks until one is available
       * @param parser - The Redis command parser
       * @param keys - Key of the sorted set, or array of keys to try sequentially
       * @param timeout - Maximum seconds to block, 0 to block indefinitely
       */
      parseCommand(parser, keys, timeout) {
        parser.push("BZPOPMIN");
        parser.pushKeys(keys);
        parser.push(timeout.toString());
      },
      transformReply: BZPOPMAX_1.default.transformReply
    };
  }
});
var require_CLIENT_CACHING = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_CACHING.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Instructs the server about tracking or not keys in the next request
       * @param parser - The Redis command parser
       * @param value - Whether to enable (true) or disable (false) tracking
       */
      parseCommand(parser, value) {
        parser.push("CLIENT", "CACHING", value ? "YES" : "NO");
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_GETNAME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_GETNAME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the name of the current connection
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLIENT", "GETNAME");
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_GETREDIR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_GETREDIR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the ID of the client to which the current client is redirecting tracking notifications
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLIENT", "GETREDIR");
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_ID = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_ID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the client ID for the current connection
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLIENT", "ID");
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_INFO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CLIENT_INFO_REGEX = /([^\s=]+)=([^\s]*)/g;
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information and statistics about the current client connection
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLIENT", "INFO");
      },
      transformReply(rawReply) {
        const map = {};
        for (const item of rawReply.toString().matchAll(CLIENT_INFO_REGEX)) {
          map[item[1]] = item[2];
        }
        const reply = {
          id: Number(map.id),
          addr: map.addr,
          fd: Number(map.fd),
          name: map.name,
          age: Number(map.age),
          idle: Number(map.idle),
          flags: map.flags,
          db: Number(map.db),
          sub: Number(map.sub),
          psub: Number(map.psub),
          multi: Number(map.multi),
          qbuf: Number(map.qbuf),
          qbufFree: Number(map["qbuf-free"]),
          argvMem: Number(map["argv-mem"]),
          obl: Number(map.obl),
          oll: Number(map.oll),
          omem: Number(map.omem),
          totMem: Number(map["tot-mem"]),
          events: map.events,
          cmd: map.cmd,
          user: map.user,
          libName: map["lib-name"],
          libVer: map["lib-ver"]
        };
        if (map.laddr !== void 0) {
          reply.laddr = map.laddr;
        }
        if (map.redir !== void 0) {
          reply.redir = Number(map.redir);
        }
        if (map.ssub !== void 0) {
          reply.ssub = Number(map.ssub);
        }
        if (map["multi-mem"] !== void 0) {
          reply.multiMem = Number(map["multi-mem"]);
        }
        if (map.resp !== void 0) {
          reply.resp = Number(map.resp);
        }
        return reply;
      }
    };
  }
});
var require_CLIENT_KILL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_KILL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CLIENT_KILL_FILTERS = void 0;
    exports.CLIENT_KILL_FILTERS = {
      ADDRESS: "ADDR",
      LOCAL_ADDRESS: "LADDR",
      ID: "ID",
      TYPE: "TYPE",
      USER: "USER",
      SKIP_ME: "SKIPME",
      MAXAGE: "MAXAGE"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Closes client connections matching the specified filters
       * @param parser - The Redis command parser
       * @param filters - One or more filters to match client connections to kill
       */
      parseCommand(parser, filters) {
        parser.push("CLIENT", "KILL");
        if (Array.isArray(filters)) {
          for (const filter of filters) {
            pushFilter(parser, filter);
          }
        } else {
          pushFilter(parser, filters);
        }
      },
      transformReply: void 0
    };
    function pushFilter(parser, filter) {
      if (filter === exports.CLIENT_KILL_FILTERS.SKIP_ME) {
        parser.push("SKIPME");
        return;
      }
      parser.push(filter.filter);
      switch (filter.filter) {
        case exports.CLIENT_KILL_FILTERS.ADDRESS:
          parser.push(filter.address);
          break;
        case exports.CLIENT_KILL_FILTERS.LOCAL_ADDRESS:
          parser.push(filter.localAddress);
          break;
        case exports.CLIENT_KILL_FILTERS.ID:
          parser.push(typeof filter.id === "number" ? filter.id.toString() : filter.id);
          break;
        case exports.CLIENT_KILL_FILTERS.TYPE:
          parser.push(filter.type);
          break;
        case exports.CLIENT_KILL_FILTERS.USER:
          parser.push(filter.username);
          break;
        case exports.CLIENT_KILL_FILTERS.SKIP_ME:
          parser.push(filter.skipMe ? "yes" : "no");
          break;
        case exports.CLIENT_KILL_FILTERS.MAXAGE:
          parser.push(filter.maxAge.toString());
          break;
      }
    }
  }
});
var require_CLIENT_LIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_LIST.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information about all client connections. Can be filtered by type or ID
       * @param parser - The Redis command parser
       * @param filter - Optional filter to return only specific client types or IDs
       */
      parseCommand(parser, filter) {
        parser.push("CLIENT", "LIST");
        if (filter) {
          if (filter.TYPE !== void 0) {
            parser.push("TYPE", filter.TYPE);
          } else {
            parser.push("ID");
            parser.pushVariadic(filter.ID);
          }
        }
      },
      transformReply(rawReply) {
        const split = rawReply.toString().split("\n"), length2 = split.length - 1, reply = [];
        for (let i2 = 0; i2 < length2; i2++) {
          reply.push(CLIENT_INFO_1.default.transformReply(split[i2]));
        }
        return reply;
      }
    };
  }
});
var require_CLIENT_NO_EVICT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_NO-EVICT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Controls whether to prevent the client's connections from being evicted
       * @param parser - The Redis command parser
       * @param value - Whether to enable (true) or disable (false) the no-evict mode
       */
      parseCommand(parser, value) {
        parser.push("CLIENT", "NO-EVICT", value ? "ON" : "OFF");
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_NO_TOUCH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_NO-TOUCH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Controls whether to prevent the client from touching the LRU/LFU of keys
       * @param parser - The Redis command parser
       * @param value - Whether to enable (true) or disable (false) the no-touch mode
       */
      parseCommand(parser, value) {
        parser.push("CLIENT", "NO-TOUCH", value ? "ON" : "OFF");
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_PAUSE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_PAUSE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Stops the server from processing client commands for the specified duration
       * @param parser - The Redis command parser
       * @param timeout - Time in milliseconds to pause command processing
       * @param mode - Optional mode: 'WRITE' to pause only write commands, 'ALL' to pause all commands
       */
      parseCommand(parser, timeout, mode) {
        parser.push("CLIENT", "PAUSE", timeout.toString());
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_SETNAME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_SETNAME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Assigns a name to the current connection
       * @param parser - The Redis command parser
       * @param name - The name to assign to the connection
       */
      parseCommand(parser, name) {
        parser.push("CLIENT", "SETNAME", name);
      },
      transformReply: void 0
    };
  }
});
var require_CLIENT_TRACKING = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKING.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Controls server-assisted client side caching for the current connection
       * @param parser - The Redis command parser
       * @param mode - Whether to enable (true) or disable (false) tracking
       * @param options - Optional configuration including REDIRECT, BCAST, PREFIX, OPTIN, OPTOUT, and NOLOOP options
       */
      parseCommand(parser, mode, options2) {
        parser.push("CLIENT", "TRACKING", mode ? "ON" : "OFF");
        if (mode) {
          if (options2?.REDIRECT) {
            parser.push("REDIRECT", options2.REDIRECT.toString());
          }
          if (isBroadcast(options2)) {
            parser.push("BCAST");
            if (options2?.PREFIX) {
              if (Array.isArray(options2.PREFIX)) {
                for (const prefix of options2.PREFIX) {
                  parser.push("PREFIX", prefix);
                }
              } else {
                parser.push("PREFIX", options2.PREFIX);
              }
            }
          } else if (isOptIn(options2)) {
            parser.push("OPTIN");
          } else if (isOptOut(options2)) {
            parser.push("OPTOUT");
          }
          if (options2?.NOLOOP) {
            parser.push("NOLOOP");
          }
        }
      },
      transformReply: void 0
    };
    function isBroadcast(options2) {
      return options2?.BCAST === true;
    }
    function isOptIn(options2) {
      return options2?.OPTIN === true;
    }
    function isOptOut(options2) {
      return options2?.OPTOUT === true;
    }
  }
});
var require_CLIENT_TRACKINGINFO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKINGINFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information about the current connection's key tracking state
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLIENT", "TRACKINGINFO");
      },
      transformReply: {
        2: (reply) => ({
          flags: reply[1],
          redirect: reply[3],
          prefixes: reply[5]
        }),
        3: void 0
      }
    };
  }
});
var require_CLIENT_UNPAUSE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLIENT_UNPAUSE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Resumes processing of client commands after a CLIENT PAUSE
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLIENT", "UNPAUSE");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_ADDSLOTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Assigns hash slots to the current node in a Redis Cluster
       * @param parser - The Redis command parser
       * @param slots - One or more hash slots to be assigned
       */
      parseCommand(parser, slots) {
        parser.push("CLUSTER", "ADDSLOTS");
        parser.pushVariadicNumber(slots);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_ADDSLOTSRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTSRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Assigns hash slot ranges to the current node in a Redis Cluster
       * @param parser - The Redis command parser
       * @param ranges - One or more slot ranges to be assigned, each specified as [start, end]
       */
      parseCommand(parser, ranges) {
        parser.push("CLUSTER", "ADDSLOTSRANGE");
        (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_BUMPEPOCH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_BUMPEPOCH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Advances the cluster config epoch
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "BUMPEPOCH");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_COUNT_FAILURE_REPORTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNT-FAILURE-REPORTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the number of failure reports for a given node
       * @param parser - The Redis command parser
       * @param nodeId - The ID of the node to check
       */
      parseCommand(parser, nodeId) {
        parser.push("CLUSTER", "COUNT-FAILURE-REPORTS", nodeId);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_COUNTKEYSINSLOT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNTKEYSINSLOT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the number of keys in the specified hash slot
       * @param parser - The Redis command parser
       * @param slot - The hash slot to check
       */
      parseCommand(parser, slot) {
        parser.push("CLUSTER", "COUNTKEYSINSLOT", slot.toString());
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_DELSLOTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Removes hash slots from the current node in a Redis Cluster
       * @param parser - The Redis command parser
       * @param slots - One or more hash slots to be removed
       */
      parseCommand(parser, slots) {
        parser.push("CLUSTER", "DELSLOTS");
        parser.pushVariadicNumber(slots);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_DELSLOTSRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTSRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Removes hash slot ranges from the current node in a Redis Cluster
       * @param parser - The Redis command parser
       * @param ranges - One or more slot ranges to be removed, each specified as [start, end]
       */
      parseCommand(parser, ranges) {
        parser.push("CLUSTER", "DELSLOTSRANGE");
        (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_FAILOVER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_FAILOVER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FAILOVER_MODES = void 0;
    exports.FAILOVER_MODES = {
      FORCE: "FORCE",
      TAKEOVER: "TAKEOVER"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Forces a replica to perform a manual failover of its master
       * @param parser - The Redis command parser
       * @param options - Optional configuration with FORCE or TAKEOVER mode
       */
      parseCommand(parser, options2) {
        parser.push("CLUSTER", "FAILOVER");
        if (options2?.mode) {
          parser.push(options2.mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_FLUSHSLOTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_FLUSHSLOTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Deletes all hash slots from the current node in a Redis Cluster
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "FLUSHSLOTS");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_FORGET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_FORGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Removes a node from the cluster
       * @param parser - The Redis command parser
       * @param nodeId - The ID of the node to remove
       */
      parseCommand(parser, nodeId) {
        parser.push("CLUSTER", "FORGET", nodeId);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_GETKEYSINSLOT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_GETKEYSINSLOT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns a number of keys from the specified hash slot
       * @param parser - The Redis command parser
       * @param slot - The hash slot to get keys from
       * @param count - Maximum number of keys to return
       */
      parseCommand(parser, slot, count) {
        parser.push("CLUSTER", "GETKEYSINSLOT", slot.toString(), count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_INFO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information about the state of a Redis Cluster
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "INFO");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_KEYSLOT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_KEYSLOT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the hash slot number for a given key
       * @param parser - The Redis command parser
       * @param key - The key to get the hash slot for
       */
      parseCommand(parser, key) {
        parser.push("CLUSTER", "KEYSLOT", key);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_LINKS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_LINKS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information about all cluster links (lower level connections to other nodes)
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "LINKS");
      },
      transformReply: {
        2: (reply) => reply.map((link) => {
          const unwrapped = link;
          return {
            direction: unwrapped[1],
            node: unwrapped[3],
            "create-time": unwrapped[5],
            events: unwrapped[7],
            "send-buffer-allocated": unwrapped[9],
            "send-buffer-used": unwrapped[11]
          };
        }),
        3: void 0
      }
    };
  }
});
var require_CLUSTER_MEET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_MEET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Initiates a handshake with another node in the cluster
       * @param parser - The Redis command parser
       * @param host - Host name or IP address of the node
       * @param port - TCP port of the node
       */
      parseCommand(parser, host, port) {
        parser.push("CLUSTER", "MEET", host, port.toString());
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_MYID = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_MYID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the node ID of the current Redis Cluster node
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "MYID");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_MYSHARDID = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_MYSHARDID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the shard ID of the current Redis Cluster node
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "MYSHARDID");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_NODES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_NODES.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns serialized information about the nodes in a Redis Cluster
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "NODES");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_REPLICAS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICAS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the replica nodes replicating from the specified primary node
       * @param parser - The Redis command parser
       * @param nodeId - Node ID of the primary node
       */
      parseCommand(parser, nodeId) {
        parser.push("CLUSTER", "REPLICAS", nodeId);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_REPLICATE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Reconfigures a node as a replica of the specified primary node
       * @param parser - The Redis command parser
       * @param nodeId - Node ID of the primary node to replicate
       */
      parseCommand(parser, nodeId) {
        parser.push("CLUSTER", "REPLICATE", nodeId);
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_RESET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_RESET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Resets a Redis Cluster node, clearing all information and returning it to a brand new state
       * @param parser - The Redis command parser
       * @param options - Options for the reset operation
       */
      parseCommand(parser, options2) {
        parser.push("CLUSTER", "RESET");
        if (options2?.mode) {
          parser.push(options2.mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_SAVECONFIG = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_SAVECONFIG.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Forces a Redis Cluster node to save the cluster configuration to disk
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "SAVECONFIG");
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_SET_CONFIG_EPOCH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_SET-CONFIG-EPOCH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Sets the configuration epoch for a Redis Cluster node
       * @param parser - The Redis command parser
       * @param configEpoch - The configuration epoch to set
       */
      parseCommand(parser, configEpoch) {
        parser.push("CLUSTER", "SET-CONFIG-EPOCH", configEpoch.toString());
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_SETSLOT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_SETSLOT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CLUSTER_SLOT_STATES = void 0;
    exports.CLUSTER_SLOT_STATES = {
      IMPORTING: "IMPORTING",
      MIGRATING: "MIGRATING",
      STABLE: "STABLE",
      NODE: "NODE"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Assigns a hash slot to a specific Redis Cluster node
       * @param parser - The Redis command parser
       * @param slot - The slot number to assign
       * @param state - The state to set for the slot (IMPORTING, MIGRATING, STABLE, NODE)
       * @param nodeId - Node ID (required for IMPORTING, MIGRATING, and NODE states)
       */
      parseCommand(parser, slot, state, nodeId) {
        parser.push("CLUSTER", "SETSLOT", slot.toString(), state);
        if (nodeId) {
          parser.push(nodeId);
        }
      },
      transformReply: void 0
    };
  }
});
var require_CLUSTER_SLOTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CLUSTER_SLOTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information about which Redis Cluster node handles which hash slots
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CLUSTER", "SLOTS");
      },
      transformReply(reply) {
        return reply.map(([from3, to, master, ...replicas]) => ({
          from: from3,
          to,
          master: transformNode(master),
          replicas: replicas.map(transformNode)
        }));
      }
    };
    function transformNode(node) {
      const [host, port, id] = node;
      return {
        host,
        port,
        id
      };
    }
  }
});
var require_COMMAND_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/COMMAND_COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the total number of commands available in the Redis server
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("COMMAND", "COUNT");
      },
      transformReply: void 0
    };
  }
});
var require_COMMAND_GETKEYS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Extracts the key names from a Redis command
       * @param parser - The Redis command parser
       * @param args - Command arguments to analyze
       */
      parseCommand(parser, args) {
        parser.push("COMMAND", "GETKEYS");
        parser.push(...args);
      },
      transformReply: void 0
    };
  }
});
var require_COMMAND_GETKEYSANDFLAGS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYSANDFLAGS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Extracts the key names and access flags from a Redis command
       * @param parser - The Redis command parser
       * @param args - Command arguments to analyze
       */
      parseCommand(parser, args) {
        parser.push("COMMAND", "GETKEYSANDFLAGS");
        parser.push(...args);
      },
      transformReply(reply) {
        return reply.map((entry) => {
          const [key, flags] = entry;
          return {
            key,
            flags
          };
        });
      }
    };
  }
});
var require_COMMAND_INFO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/COMMAND_INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns details about specific Redis commands
       * @param parser - The Redis command parser
       * @param commands - Array of command names to get information about
       */
      parseCommand(parser, commands) {
        parser.push("COMMAND", "INFO", ...commands);
      },
      // TODO: This works, as we don't currently handle any of the items returned as a map
      transformReply(reply) {
        return reply.map((command) => command ? (0, generic_transformers_1.transformCommandReply)(command) : null);
      }
    };
  }
});
var require_COMMAND_LIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/COMMAND_LIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.COMMAND_LIST_FILTER_BY = void 0;
    exports.COMMAND_LIST_FILTER_BY = {
      MODULE: "MODULE",
      ACLCAT: "ACLCAT",
      PATTERN: "PATTERN"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns a list of all commands supported by the Redis server
       * @param parser - The Redis command parser
       * @param options - Options for filtering the command list
       */
      parseCommand(parser, options2) {
        parser.push("COMMAND", "LIST");
        if (options2?.FILTERBY) {
          parser.push("FILTERBY", options2.FILTERBY.type, options2.FILTERBY.value);
        }
      },
      transformReply: void 0
    };
  }
});
var require_COMMAND = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/COMMAND.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns an array with details about all Redis commands
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("COMMAND");
      },
      // TODO: This works, as we don't currently handle any of the items returned as a map
      transformReply(reply) {
        return reply.map(generic_transformers_1.transformCommandReply);
      }
    };
  }
});
var require_CONFIG_GET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CONFIG_GET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Gets the values of configuration parameters
       * @param parser - The Redis command parser
       * @param parameters - Pattern or specific configuration parameter names
       */
      parseCommand(parser, parameters) {
        parser.push("CONFIG", "GET");
        parser.pushVariadic(parameters);
      },
      transformReply: {
        2: generic_transformers_1.transformTuplesReply,
        3: void 0
      }
    };
  }
});
var require_CONFIG_RESETSTAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CONFIG_RESETSTAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Resets the statistics reported by Redis using the INFO command
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CONFIG", "RESETSTAT");
      },
      transformReply: void 0
    };
  }
});
var require_CONFIG_REWRITE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CONFIG_REWRITE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Rewrites the Redis configuration file with the current configuration
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("CONFIG", "REWRITE");
      },
      transformReply: void 0
    };
  }
});
var require_CONFIG_SET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/CONFIG_SET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Sets configuration parameters to the specified values
       * @param parser - The Redis command parser
       * @param parameterOrConfig - Either a single parameter name or a configuration object
       * @param value - Value for the parameter (when using single parameter format)
       */
      parseCommand(parser, ...[parameterOrConfig, value]) {
        parser.push("CONFIG", "SET");
        if (typeof parameterOrConfig === "string" || parameterOrConfig instanceof Buffer) {
          parser.push(parameterOrConfig, value);
        } else {
          for (const [key, value2] of Object.entries(parameterOrConfig)) {
            parser.push(key, value2);
          }
        }
      },
      transformReply: void 0
    };
  }
});
var require_COPY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/COPY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Copies the value stored at the source key to the destination key
       * @param parser - The Redis command parser
       * @param source - Source key
       * @param destination - Destination key
       * @param options - Options for the copy operation
       */
      parseCommand(parser, source, destination, options2) {
        parser.push("COPY");
        parser.pushKeys([source, destination]);
        if (options2?.DB) {
          parser.push("DB", options2.DB.toString());
        }
        if (options2?.REPLACE) {
          parser.push("REPLACE");
        }
      },
      transformReply: void 0
    };
  }
});
var require_DBSIZE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/DBSIZE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the number of keys in the current database
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("DBSIZE");
      },
      transformReply: void 0
    };
  }
});
var require_DECR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/DECR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Decrements the integer value of a key by one
       * @param parser - The Redis command parser
       * @param key - Key to decrement
       */
      parseCommand(parser, key) {
        parser.push("DECR");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_DECRBY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/DECRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Decrements the integer value of a key by the given number
       * @param parser - The Redis command parser
       * @param key - Key to decrement
       * @param decrement - Decrement amount
       */
      parseCommand(parser, key, decrement) {
        parser.push("DECRBY");
        parser.pushKey(key);
        parser.push(decrement.toString());
      },
      transformReply: void 0
    };
  }
});
var require_DEL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/DEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes the specified keys. A key is ignored if it does not exist
       * @param parser - The Redis command parser
       * @param keys - One or more keys to delete
       */
      parseCommand(parser, keys) {
        parser.push("DEL");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_DUMP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/DUMP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns a serialized version of the value stored at the key
       * @param parser - The Redis command parser
       * @param key - Key to dump
       */
      parseCommand(parser, key) {
        parser.push("DUMP");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_ECHO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ECHO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the given string
       * @param parser - The Redis command parser
       * @param message - Message to echo back
       */
      parseCommand(parser, message) {
        parser.push("ECHO", message);
      },
      transformReply: void 0
    };
  }
});
var require_EVAL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EVAL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEvalArguments = void 0;
    function parseEvalArguments(parser, script, options2) {
      parser.push(script);
      if (options2?.keys) {
        parser.pushKeysLength(options2.keys);
      } else {
        parser.push("0");
      }
      if (options2?.arguments) {
        parser.push(...options2.arguments);
      }
    }
    exports.parseEvalArguments = parseEvalArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Executes a Lua script server side
       * @param parser - The Redis command parser
       * @param script - Lua script to execute
       * @param options - Script execution options including keys and arguments
       */
      parseCommand(...args) {
        args[0].push("EVAL");
        parseEvalArguments(...args);
      },
      transformReply: void 0
    };
  }
});
var require_EVAL_RO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EVAL_RO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var EVAL_1 = __importStar(require_EVAL());
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Executes a read-only Lua script server side
       * @param parser - The Redis command parser
       * @param script - Lua script to execute
       * @param options - Script execution options including keys and arguments
       */
      parseCommand(...args) {
        args[0].push("EVAL_RO");
        (0, EVAL_1.parseEvalArguments)(...args);
      },
      transformReply: EVAL_1.default.transformReply
    };
  }
});
var require_EVALSHA_RO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EVALSHA_RO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var EVAL_1 = __importStar(require_EVAL());
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Executes a read-only Lua script server side using the script's SHA1 digest
       * @param parser - The Redis command parser
       * @param sha1 - SHA1 digest of the script
       * @param options - Script execution options including keys and arguments
       */
      parseCommand(...args) {
        args[0].push("EVALSHA_RO");
        (0, EVAL_1.parseEvalArguments)(...args);
      },
      transformReply: EVAL_1.default.transformReply
    };
  }
});
var require_EVALSHA = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EVALSHA.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var EVAL_1 = __importStar(require_EVAL());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Executes a Lua script server side using the script's SHA1 digest
       * @param parser - The Redis command parser
       * @param sha1 - SHA1 digest of the script
       * @param options - Script execution options including keys and arguments
       */
      parseCommand(...args) {
        args[0].push("EVALSHA");
        (0, EVAL_1.parseEvalArguments)(...args);
      },
      transformReply: EVAL_1.default.transformReply
    };
  }
});
var require_GEOADD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEOADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds geospatial items to the specified key
       * @param parser - The Redis command parser
       * @param key - Key to add the geospatial items to
       * @param toAdd - Geospatial member(s) to add
       * @param options - Options for the GEOADD command
       */
      parseCommand(parser, key, toAdd, options2) {
        parser.push("GEOADD");
        parser.pushKey(key);
        if (options2?.condition) {
          parser.push(options2.condition);
        } else if (options2?.NX) {
          parser.push("NX");
        } else if (options2?.XX) {
          parser.push("XX");
        }
        if (options2?.CH) {
          parser.push("CH");
        }
        if (Array.isArray(toAdd)) {
          for (const member of toAdd) {
            pushMember(parser, member);
          }
        } else {
          pushMember(parser, toAdd);
        }
      },
      transformReply: void 0
    };
    function pushMember(parser, { longitude, latitude, member }) {
      parser.push(longitude.toString(), latitude.toString(), member);
    }
  }
});
var require_GEODIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEODIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the distance between two members in a geospatial index
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param member1 - First member in the geospatial index
       * @param member2 - Second member in the geospatial index
       * @param unit - Unit of distance (m, km, ft, mi)
       */
      parseCommand(parser, key, member1, member2, unit) {
        parser.push("GEODIST");
        parser.pushKey(key);
        parser.push(member1, member2);
        if (unit) {
          parser.push(unit);
        }
      },
      transformReply(reply) {
        return reply === null ? null : Number(reply);
      }
    };
  }
});
var require_GEOHASH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEOHASH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the Geohash string representation of one or more position members
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param member - One or more members in the geospatial index
       */
      parseCommand(parser, key, member) {
        parser.push("GEOHASH");
        parser.pushKey(key);
        parser.pushVariadic(member);
      },
      transformReply: void 0
    };
  }
});
var require_GEOPOS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEOPOS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the longitude and latitude of one or more members in a geospatial index
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param member - One or more members in the geospatial index
       */
      parseCommand(parser, key, member) {
        parser.push("GEOPOS");
        parser.pushKey(key);
        parser.pushVariadic(member);
      },
      transformReply(reply) {
        return reply.map((item) => {
          const unwrapped = item;
          return unwrapped === null ? null : {
            longitude: unwrapped[0],
            latitude: unwrapped[1]
          };
        });
      }
    };
  }
});
var require_GEOSEARCH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEOSEARCH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGeoSearchOptions = exports.parseGeoSearchArguments = void 0;
    function parseGeoSearchArguments(parser, key, from3, by, options2) {
      parser.pushKey(key);
      if (typeof from3 === "string" || from3 instanceof Buffer) {
        parser.push("FROMMEMBER", from3);
      } else {
        parser.push("FROMLONLAT", from3.longitude.toString(), from3.latitude.toString());
      }
      if ("radius" in by) {
        parser.push("BYRADIUS", by.radius.toString(), by.unit);
      } else {
        parser.push("BYBOX", by.width.toString(), by.height.toString(), by.unit);
      }
      parseGeoSearchOptions(parser, options2);
    }
    exports.parseGeoSearchArguments = parseGeoSearchArguments;
    function parseGeoSearchOptions(parser, options2) {
      if (options2?.SORT) {
        parser.push(options2.SORT);
      }
      if (options2?.COUNT) {
        if (typeof options2.COUNT === "number") {
          parser.push("COUNT", options2.COUNT.toString());
        } else {
          parser.push("COUNT", options2.COUNT.value.toString());
          if (options2.COUNT.ANY) {
            parser.push("ANY");
          }
        }
      }
    }
    exports.parseGeoSearchOptions = parseGeoSearchOptions;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Queries members inside an area of a geospatial index
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Center point of the search (member name or coordinates)
       * @param by - Search area specification (radius or box dimensions)
       * @param options - Additional search options
       */
      parseCommand(parser, key, from3, by, options2) {
        parser.push("GEOSEARCH");
        parseGeoSearchArguments(parser, key, from3, by, options2);
      },
      transformReply: void 0
    };
  }
});
var require_GEORADIUS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGeoRadiusArguments = void 0;
    var GEOSEARCH_1 = require_GEOSEARCH();
    function parseGeoRadiusArguments(parser, key, from3, radius, unit, options2) {
      parser.pushKey(key);
      parser.push(from3.longitude.toString(), from3.latitude.toString(), radius.toString(), unit);
      (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options2);
    }
    exports.parseGeoRadiusArguments = parseGeoRadiusArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Queries members in a geospatial index based on a radius from a center point
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Center coordinates for the search
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param options - Additional search options
       */
      parseCommand(...args) {
        args[0].push("GEORADIUS");
        return parseGeoRadiusArguments(...args);
      },
      transformReply: void 0
    };
  }
});
var require_GEOSEARCH_WITH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEOSEARCH_WITH.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GEO_REPLY_WITH = void 0;
    var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
    exports.GEO_REPLY_WITH = {
      DISTANCE: "WITHDIST",
      HASH: "WITHHASH",
      COORDINATES: "WITHCOORD"
    };
    exports.default = {
      IS_READ_ONLY: GEOSEARCH_1.default.IS_READ_ONLY,
      /**
       * Queries members inside an area of a geospatial index with additional information
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Center point of the search (member name or coordinates)
       * @param by - Search area specification (radius or box dimensions)
       * @param replyWith - Information to include with each returned member
       * @param options - Additional search options
       */
      parseCommand(parser, key, from3, by, replyWith, options2) {
        GEOSEARCH_1.default.parseCommand(parser, key, from3, by, options2);
        parser.push(...replyWith);
        parser.preserve = replyWith;
      },
      transformReply(reply, replyWith) {
        const replyWithSet = new Set(replyWith);
        let index = 0;
        const distanceIndex = replyWithSet.has(exports.GEO_REPLY_WITH.DISTANCE) && ++index, hashIndex = replyWithSet.has(exports.GEO_REPLY_WITH.HASH) && ++index, coordinatesIndex = replyWithSet.has(exports.GEO_REPLY_WITH.COORDINATES) && ++index;
        return reply.map((raw) => {
          const unwrapped = raw;
          const item = {
            member: unwrapped[0]
          };
          if (distanceIndex) {
            item.distance = unwrapped[distanceIndex];
          }
          if (hashIndex) {
            item.hash = unwrapped[hashIndex];
          }
          if (coordinatesIndex) {
            const [longitude, latitude] = unwrapped[coordinatesIndex];
            item.coordinates = {
              longitude,
              latitude
            };
          }
          return item;
        });
      }
    };
  }
});
var require_GEORADIUS_WITH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUS_WITH.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGeoRadiusWithArguments = void 0;
    var GEORADIUS_1 = __importStar(require_GEORADIUS());
    var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
    function parseGeoRadiusWithArguments(parser, key, from3, radius, unit, replyWith, options2) {
      (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from3, radius, unit, options2);
      parser.pushVariadic(replyWith);
      parser.preserve = replyWith;
    }
    exports.parseGeoRadiusWithArguments = parseGeoRadiusWithArguments;
    exports.default = {
      IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
      /**
       * Queries members in a geospatial index based on a radius from a center point with additional information
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Center coordinates for the search
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param replyWith - Information to include with each returned member
       * @param options - Additional search options
       */
      parseCommand(parser, key, from3, radius, unit, replyWith, options2) {
        parser.push("GEORADIUS");
        parseGeoRadiusWithArguments(parser, key, from3, radius, unit, replyWith, options2);
      },
      transformReply: GEOSEARCH_WITH_1.default.transformReply
    };
  }
});
var require_GEORADIUS_RO_WITH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO_WITH.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GEORADIUS_WITH_1 = require_GEORADIUS_WITH();
    var GEORADIUS_WITH_2 = __importDefault(require_GEORADIUS_WITH());
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Read-only variant that queries members in a geospatial index based on a radius from a center point with additional information
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Center coordinates for the search
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param replyWith - Information to include with each returned member
       * @param options - Additional search options
       */
      parseCommand(...args) {
        args[0].push("GEORADIUS_RO");
        (0, GEORADIUS_WITH_1.parseGeoRadiusWithArguments)(...args);
      },
      transformReply: GEORADIUS_WITH_2.default.transformReply
    };
  }
});
var require_GEORADIUS_RO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GEORADIUS_1 = __importStar(require_GEORADIUS());
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Read-only variant that queries members in a geospatial index based on a radius from a center point
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Center coordinates for the search
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param options - Additional search options
       */
      parseCommand(...args) {
        args[0].push("GEORADIUS_RO");
        (0, GEORADIUS_1.parseGeoRadiusArguments)(...args);
      },
      transformReply: GEORADIUS_1.default.transformReply
    };
  }
});
var require_GEORADIUS_STORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUS_STORE.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GEORADIUS_1 = __importStar(require_GEORADIUS());
    exports.default = {
      IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
      /**
       * Queries members in a geospatial index based on a radius from a center point and stores the results
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Center coordinates for the search
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param destination - Key to store the results
       * @param options - Additional search and storage options
       */
      parseCommand(parser, key, from3, radius, unit, destination, options2) {
        parser.push("GEORADIUS");
        (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from3, radius, unit, options2);
        if (options2?.STOREDIST) {
          parser.push("STOREDIST");
          parser.pushKey(destination);
        } else {
          parser.push("STORE");
          parser.pushKey(destination);
        }
      },
      transformReply: void 0
    };
  }
});
var require_GEORADIUSBYMEMBER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGeoRadiusByMemberArguments = void 0;
    var GEOSEARCH_1 = require_GEOSEARCH();
    function parseGeoRadiusByMemberArguments(parser, key, from3, radius, unit, options2) {
      parser.pushKey(key);
      parser.push(from3, radius.toString(), unit);
      (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options2);
    }
    exports.parseGeoRadiusByMemberArguments = parseGeoRadiusByMemberArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Queries members in a geospatial index based on a radius from a member
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Member name to use as center point
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param options - Additional search options
       */
      parseCommand(parser, key, from3, radius, unit, options2) {
        parser.push("GEORADIUSBYMEMBER");
        parseGeoRadiusByMemberArguments(parser, key, from3, radius, unit, options2);
      },
      transformReply: void 0
    };
  }
});
var require_GEORADIUSBYMEMBER_WITH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_WITH.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGeoRadiusByMemberWithArguments = void 0;
    var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
    var GEOSEARCH_1 = require_GEOSEARCH();
    var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
    function parseGeoRadiusByMemberWithArguments(parser, key, from3, radius, unit, replyWith, options2) {
      parser.pushKey(key);
      parser.push(from3, radius.toString(), unit);
      (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options2);
      parser.push(...replyWith);
      parser.preserve = replyWith;
    }
    exports.parseGeoRadiusByMemberWithArguments = parseGeoRadiusByMemberWithArguments;
    exports.default = {
      IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
      /**
       * Queries members in a geospatial index based on a radius from a member with additional information
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Member name to use as center point
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param replyWith - Information to include with each returned member
       * @param options - Additional search options
       */
      parseCommand(parser, key, from3, radius, unit, replyWith, options2) {
        parser.push("GEORADIUSBYMEMBER");
        parseGeoRadiusByMemberWithArguments(parser, key, from3, radius, unit, replyWith, options2);
      },
      transformReply: GEOSEARCH_WITH_1.default.transformReply
    };
  }
});
var require_GEORADIUSBYMEMBER_RO_WITH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO_WITH.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GEORADIUSBYMEMBER_WITH_1 = __importStar(require_GEORADIUSBYMEMBER_WITH());
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Read-only variant that queries members in a geospatial index based on a radius from a member with additional information
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Member name to use as center point
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param withValues - Information to include with each returned member
       */
      parseCommand(...args) {
        const parser = args[0];
        parser.push("GEORADIUSBYMEMBER_RO");
        (0, GEORADIUSBYMEMBER_WITH_1.parseGeoRadiusByMemberWithArguments)(...args);
      },
      transformReply: GEORADIUSBYMEMBER_WITH_1.default.transformReply
    };
  }
});
var require_GEORADIUSBYMEMBER_RO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Read-only variant that queries members in a geospatial index based on a radius from a member
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Member name to use as center point
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param options - Additional search options
       */
      parseCommand(...args) {
        const parser = args[0];
        parser.push("GEORADIUSBYMEMBER_RO");
        (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(...args);
      },
      transformReply: GEORADIUSBYMEMBER_1.default.transformReply
    };
  }
});
var require_GEORADIUSBYMEMBER_STORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_STORE.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
    exports.default = {
      IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
      /**
       * Queries members in a geospatial index based on a radius from a member and stores the results
       * @param parser - The Redis command parser
       * @param key - Key of the geospatial index
       * @param from - Member name to use as center point
       * @param radius - Radius of the search area
       * @param unit - Unit of distance (m, km, ft, mi)
       * @param destination - Key to store the results
       * @param options - Additional search and storage options
       */
      parseCommand(parser, key, from3, radius, unit, destination, options2) {
        parser.push("GEORADIUSBYMEMBER");
        (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(parser, key, from3, radius, unit, options2);
        if (options2?.STOREDIST) {
          parser.push("STOREDIST");
          parser.pushKey(destination);
        } else {
          parser.push("STORE");
          parser.pushKey(destination);
        }
      },
      transformReply: void 0
    };
  }
});
var require_GEOSEARCHSTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GEOSEARCHSTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GEOSEARCH_1 = require_GEOSEARCH();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Searches a geospatial index and stores the results in a new sorted set
       * @param parser - The Redis command parser
       * @param destination - Key to store the results
       * @param source - Key of the geospatial index to search
       * @param from - Center point of the search (member name or coordinates)
       * @param by - Search area specification (radius or box dimensions)
       * @param options - Additional search and storage options
       */
      parseCommand(parser, destination, source, from3, by, options2) {
        parser.push("GEOSEARCHSTORE");
        if (destination !== void 0) {
          parser.pushKey(destination);
        }
        (0, GEOSEARCH_1.parseGeoSearchArguments)(parser, source, from3, by, options2);
        if (options2?.STOREDIST) {
          parser.push("STOREDIST");
        }
      },
      transformReply: void 0
    };
  }
});
var require_GET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Gets the value of a key
       * @param parser - The Redis command parser
       * @param key - Key to get the value of
       */
      parseCommand(parser, key) {
        parser.push("GET");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_GETBIT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GETBIT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the bit value at a given offset in a string value
       * @param parser - The Redis command parser
       * @param key - Key to retrieve the bit from
       * @param offset - Bit offset
       */
      parseCommand(parser, key, offset) {
        parser.push("GETBIT");
        parser.pushKey(key);
        parser.push(offset.toString());
      },
      transformReply: void 0
    };
  }
});
var require_GETDEL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GETDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets the value of a key and deletes the key
       * @param parser - The Redis command parser
       * @param key - Key to get and delete
       */
      parseCommand(parser, key) {
        parser.push("GETDEL");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_GETEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GETEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets the value of a key and optionally sets its expiration
       * @param parser - The Redis command parser
       * @param key - Key to get value from
       * @param options - Options for setting expiration
       */
      parseCommand(parser, key, options2) {
        parser.push("GETEX");
        parser.pushKey(key);
        if ("type" in options2) {
          switch (options2.type) {
            case "EX":
            case "PX":
              parser.push(options2.type, options2.value.toString());
              break;
            case "EXAT":
            case "PXAT":
              parser.push(options2.type, (0, generic_transformers_1.transformEXAT)(options2.value));
              break;
            case "PERSIST":
              parser.push("PERSIST");
              break;
          }
        } else {
          if ("EX" in options2) {
            parser.push("EX", options2.EX.toString());
          } else if ("PX" in options2) {
            parser.push("PX", options2.PX.toString());
          } else if ("EXAT" in options2) {
            parser.push("EXAT", (0, generic_transformers_1.transformEXAT)(options2.EXAT));
          } else if ("PXAT" in options2) {
            parser.push("PXAT", (0, generic_transformers_1.transformPXAT)(options2.PXAT));
          } else {
            parser.push("PERSIST");
          }
        }
      },
      transformReply: void 0
    };
  }
});
var require_GETRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GETRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns a substring of the string stored at a key
       * @param parser - The Redis command parser
       * @param key - Key to get substring from
       * @param start - Start position of the substring
       * @param end - End position of the substring
       */
      parseCommand(parser, key, start, end) {
        parser.push("GETRANGE");
        parser.pushKey(key);
        parser.push(start.toString(), end.toString());
      },
      transformReply: void 0
    };
  }
});
var require_GETSET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/GETSET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Sets a key to a new value and returns its old value
       * @param parser - The Redis command parser
       * @param key - Key to set
       * @param value - Value to set
       */
      parseCommand(parser, key, value) {
        parser.push("GETSET");
        parser.pushKey(key);
        parser.push(value);
      },
      transformReply: void 0
    };
  }
});
var require_EXISTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EXISTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Determines if the specified keys exist
       * @param parser - The Redis command parser
       * @param keys - One or more keys to check
       */
      parseCommand(parser, keys) {
        parser.push("EXISTS");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_EXPIRE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EXPIRE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Sets a timeout on key. After the timeout has expired, the key will be automatically deleted
       * @param parser - The Redis command parser
       * @param key - Key to set expiration on
       * @param seconds - Number of seconds until key expiration
       * @param mode - Expiration mode: NX (only if key has no expiry), XX (only if key has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
       */
      parseCommand(parser, key, seconds, mode) {
        parser.push("EXPIRE");
        parser.pushKey(key);
        parser.push(seconds.toString());
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_EXPIREAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EXPIREAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Sets the expiration for a key at a specific Unix timestamp
       * @param parser - The Redis command parser
       * @param key - Key to set expiration on
       * @param timestamp - Unix timestamp (seconds since January 1, 1970) or Date object
       * @param mode - Expiration mode: NX (only if key has no expiry), XX (only if key has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
       */
      parseCommand(parser, key, timestamp, mode) {
        parser.push("EXPIREAT");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_EXPIRETIME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/EXPIRETIME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the absolute Unix timestamp (since January 1, 1970) at which the given key will expire
       * @param parser - The Redis command parser
       * @param key - Key to check expiration time
       */
      parseCommand(parser, key) {
        parser.push("EXPIRETIME");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_FLUSHALL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FLUSHALL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.REDIS_FLUSH_MODES = void 0;
    exports.REDIS_FLUSH_MODES = {
      ASYNC: "ASYNC",
      SYNC: "SYNC"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Removes all keys from all databases
       * @param parser - The Redis command parser
       * @param mode - Optional flush mode (ASYNC or SYNC)
       */
      parseCommand(parser, mode) {
        parser.push("FLUSHALL");
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_FLUSHDB = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FLUSHDB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Removes all keys from the current database
       * @param parser - The Redis command parser
       * @param mode - Optional flush mode (ASYNC or SYNC)
       */
      parseCommand(parser, mode) {
        parser.push("FLUSHDB");
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_FCALL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FCALL.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var EVAL_1 = __importStar(require_EVAL());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Invokes a Redis function
       * @param parser - The Redis command parser
       * @param functionName - Name of the function to call
       * @param options - Function execution options including keys and arguments
       */
      parseCommand(...args) {
        args[0].push("FCALL");
        (0, EVAL_1.parseEvalArguments)(...args);
      },
      transformReply: EVAL_1.default.transformReply
    };
  }
});
var require_FCALL_RO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FCALL_RO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var EVAL_1 = __importStar(require_EVAL());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Invokes a read-only Redis function
       * @param parser - The Redis command parser
       * @param functionName - Name of the function to call
       * @param options - Function execution options including keys and arguments
       */
      parseCommand(...args) {
        args[0].push("FCALL_RO");
        (0, EVAL_1.parseEvalArguments)(...args);
      },
      transformReply: EVAL_1.default.transformReply
    };
  }
});
var require_FUNCTION_DELETE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_DELETE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Deletes a library and all its functions
       * @param parser - The Redis command parser
       * @param library - Name of the library to delete
       */
      parseCommand(parser, library) {
        parser.push("FUNCTION", "DELETE", library);
      },
      transformReply: void 0
    };
  }
});
var require_FUNCTION_DUMP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_DUMP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns a serialized payload representing the current functions loaded in the server
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("FUNCTION", "DUMP");
      },
      transformReply: void 0
    };
  }
});
var require_FUNCTION_FLUSH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_FLUSH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Deletes all the libraries and functions from a Redis server
       * @param parser - The Redis command parser
       * @param mode - Optional flush mode (ASYNC or SYNC)
       */
      parseCommand(parser, mode) {
        parser.push("FUNCTION", "FLUSH");
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_FUNCTION_KILL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_KILL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Kills a function that is currently executing
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("FUNCTION", "KILL");
      },
      transformReply: void 0
    };
  }
});
var require_FUNCTION_LIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Returns all libraries and functions
       * @param parser - The Redis command parser
       * @param options - Options for listing functions
       */
      parseCommand(parser, options2) {
        parser.push("FUNCTION", "LIST");
        if (options2?.LIBRARYNAME) {
          parser.push("LIBRARYNAME", options2.LIBRARYNAME);
        }
      },
      transformReply: {
        2: (reply) => {
          return reply.map((library) => {
            const unwrapped = library;
            return {
              library_name: unwrapped[1],
              engine: unwrapped[3],
              functions: unwrapped[5].map((fn) => {
                const unwrapped2 = fn;
                return {
                  name: unwrapped2[1],
                  description: unwrapped2[3],
                  flags: unwrapped2[5]
                };
              })
            };
          });
        },
        3: void 0
      }
    };
  }
});
var require_FUNCTION_LIST_WITHCODE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST_WITHCODE.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
    exports.default = {
      NOT_KEYED_COMMAND: FUNCTION_LIST_1.default.NOT_KEYED_COMMAND,
      IS_READ_ONLY: FUNCTION_LIST_1.default.IS_READ_ONLY,
      /**
       * Returns all libraries and functions including their source code
       * @param parser - The Redis command parser
       * @param options - Options for listing functions
       */
      parseCommand(...args) {
        FUNCTION_LIST_1.default.parseCommand(...args);
        args[0].push("WITHCODE");
      },
      transformReply: {
        2: (reply) => {
          return reply.map((library) => {
            const unwrapped = library;
            return {
              library_name: unwrapped[1],
              engine: unwrapped[3],
              functions: unwrapped[5].map((fn) => {
                const unwrapped2 = fn;
                return {
                  name: unwrapped2[1],
                  description: unwrapped2[3],
                  flags: unwrapped2[5]
                };
              }),
              library_code: unwrapped[7]
            };
          });
        },
        3: void 0
      }
    };
  }
});
var require_FUNCTION_LOAD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_LOAD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Loads a library to Redis
       * @param parser - The Redis command parser
       * @param code - Library code to load
       * @param options - Function load options
       */
      parseCommand(parser, code2, options2) {
        parser.push("FUNCTION", "LOAD");
        if (options2?.REPLACE) {
          parser.push("REPLACE");
        }
        parser.push(code2);
      },
      transformReply: void 0
    };
  }
});
var require_FUNCTION_RESTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_RESTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Restores libraries from the dump payload
       * @param parser - The Redis command parser
       * @param dump - Serialized payload of functions to restore
       * @param options - Options for the restore operation
       */
      parseCommand(parser, dump, options2) {
        parser.push("FUNCTION", "RESTORE", dump);
        if (options2?.mode) {
          parser.push(options2.mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_FUNCTION_STATS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/FUNCTION_STATS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information about the function that is currently running and information about the available execution engines
       * @param parser - The Redis command parser
       */
      parseCommand(parser) {
        parser.push("FUNCTION", "STATS");
      },
      transformReply: {
        2: (reply) => {
          return {
            running_script: transformRunningScript(reply[1]),
            engines: transformEngines(reply[3])
          };
        },
        3: void 0
      }
    };
    function transformRunningScript(reply) {
      if ((0, generic_transformers_1.isNullReply)(reply)) {
        return null;
      }
      const unwraped = reply;
      return {
        name: unwraped[1],
        command: unwraped[3],
        duration_ms: unwraped[5]
      };
    }
    function transformEngines(reply) {
      const unwraped = reply;
      const engines = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0; i2 < unwraped.length; i2++) {
        const name = unwraped[i2], stats = unwraped[++i2], unwrapedStats = stats;
        engines[name.toString()] = {
          libraries_count: unwrapedStats[1],
          functions_count: unwrapedStats[3]
        };
      }
      return engines;
    }
  }
});
var require_HDEL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Removes one or more fields from a hash
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param field - Field(s) to remove
       */
      parseCommand(parser, key, field) {
        parser.push("HDEL");
        parser.pushKey(key);
        parser.pushVariadic(field);
      },
      transformReply: void 0
    };
  }
});
var require_HELLO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HELLO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Handshakes with the Redis server and switches to the specified protocol version
       * @param parser - The Redis command parser
       * @param protover - Protocol version to use
       * @param options - Additional options for authentication and connection naming
       */
      parseCommand(parser, protover, options2) {
        parser.push("HELLO");
        if (protover) {
          parser.push(protover.toString());
          if (options2?.AUTH) {
            parser.push("AUTH", options2.AUTH.username, options2.AUTH.password);
          }
          if (options2?.SETNAME) {
            parser.push("SETNAME", options2.SETNAME);
          }
        }
      },
      transformReply: {
        2: (reply) => ({
          server: reply[1],
          version: reply[3],
          proto: reply[5],
          id: reply[7],
          mode: reply[9],
          role: reply[11],
          modules: reply[13]
        }),
        3: void 0
      }
    };
  }
});
var require_HEXISTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HEXISTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Determines whether a field exists in a hash
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param field - Field to check
       */
      parseCommand(parser, key, field) {
        parser.push("HEXISTS");
        parser.pushKey(key);
        parser.push(field);
      },
      transformReply: void 0
    };
  }
});
var require_HEXPIRE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HEXPIRE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HASH_EXPIRATION = void 0;
    exports.HASH_EXPIRATION = {
      /** The field does not exist */
      FIELD_NOT_EXISTS: -2,
      /** Specified NX | XX | GT | LT condition not met */
      CONDITION_NOT_MET: 0,
      /** Expiration time was set or updated */
      UPDATED: 1,
      /** Field deleted because the specified expiration time is in the past */
      DELETED: 2
    };
    exports.default = {
      /**
       * Sets a timeout on hash fields. After the timeout has expired, the fields will be automatically deleted
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param fields - Fields to set expiration on
       * @param seconds - Number of seconds until field expiration
       * @param mode - Expiration mode: NX (only if field has no expiry), XX (only if field has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
       */
      parseCommand(parser, key, fields, seconds, mode) {
        parser.push("HEXPIRE");
        parser.pushKey(key);
        parser.push(seconds.toString());
        if (mode) {
          parser.push(mode);
        }
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HEXPIREAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HEXPIREAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Sets the expiration for hash fields at a specific Unix timestamp
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param fields - Fields to set expiration on
       * @param timestamp - Unix timestamp (seconds since January 1, 1970) or Date object
       * @param mode - Expiration mode: NX (only if field has no expiry), XX (only if field has existing expiry), GT (only if new expiry is greater than current), LT (only if new expiry is less than current)
       */
      parseCommand(parser, key, fields, timestamp, mode) {
        parser.push("HEXPIREAT");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
        if (mode) {
          parser.push(mode);
        }
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HEXPIRETIME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HEXPIRETIME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HASH_EXPIRATION_TIME = void 0;
    exports.HASH_EXPIRATION_TIME = {
      /** The field does not exist */
      FIELD_NOT_EXISTS: -2,
      /** The field exists but has no associated expire */
      NO_EXPIRATION: -1
    };
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the absolute Unix timestamp (since January 1, 1970) at which the given hash fields will expire
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param fields - Fields to check expiration time
       */
      parseCommand(parser, key, fields) {
        parser.push("HEXPIRETIME");
        parser.pushKey(key);
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HGET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Gets the value of a field in a hash
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param field - Field to get the value of
       */
      parseCommand(parser, key, field) {
        parser.push("HGET");
        parser.pushKey(key);
        parser.push(field);
      },
      transformReply: void 0
    };
  }
});
var require_HGETALL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HGETALL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Gets all fields and values in a hash
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       */
      parseCommand(parser, key) {
        parser.push("HGETALL");
        parser.pushKey(key);
      },
      TRANSFORM_LEGACY_REPLY: true,
      transformReply: {
        2: generic_transformers_1.transformTuplesReply,
        3: void 0
      }
    };
  }
});
var require_HGETDEL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HGETDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Gets and deletes the specified fields from a hash
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param fields - Fields to get and delete
       */
      parseCommand(parser, key, fields) {
        parser.push("HGETDEL");
        parser.pushKey(key);
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HGETEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HGETEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Gets the values of the specified fields in a hash and optionally sets their expiration
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param fields - Fields to get values from
       * @param options - Options for setting expiration
       */
      parseCommand(parser, key, fields, options2) {
        parser.push("HGETEX");
        parser.pushKey(key);
        if (options2?.expiration) {
          if (typeof options2.expiration === "string") {
            parser.push(options2.expiration);
          } else if (options2.expiration.type === "PERSIST") {
            parser.push("PERSIST");
          } else {
            parser.push(options2.expiration.type, options2.expiration.value.toString());
          }
        }
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HINCRBY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HINCRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Increments the integer value of a field in a hash by the given number
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param field - Field to increment
       * @param increment - Increment amount
       */
      parseCommand(parser, key, field, increment) {
        parser.push("HINCRBY");
        parser.pushKey(key);
        parser.push(field, increment.toString());
      },
      transformReply: void 0
    };
  }
});
var require_HINCRBYFLOAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HINCRBYFLOAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Increments the float value of a field in a hash by the given amount
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       * @param field - Field to increment
       * @param increment - Increment amount (float)
       */
      parseCommand(parser, key, field, increment) {
        parser.push("HINCRBYFLOAT");
        parser.pushKey(key);
        parser.push(field, increment.toString());
      },
      transformReply: void 0
    };
  }
});
var require_HKEYS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HKEYS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Gets all field names in a hash
       * @param parser - The Redis command parser
       * @param key - Key of the hash
       */
      parseCommand(parser, key) {
        parser.push("HKEYS");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_HLEN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Gets the number of fields in a hash.
       * @param parser - The Redis command parser.
       * @param key - Key of the hash.
       */
      parseCommand(parser, key) {
        parser.push("HLEN");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_HMGET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HMGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Gets the values of all the specified fields in a hash.
       * @param parser - The Redis command parser.
       * @param key - Key of the hash.
       * @param fields - Fields to get from the hash.
       */
      parseCommand(parser, key, fields) {
        parser.push("HMGET");
        parser.pushKey(key);
        parser.pushVariadic(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HPERSIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HPERSIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Removes the expiration from the specified fields in a hash.
       * @param parser - The Redis command parser.
       * @param key - Key of the hash.
       * @param fields - Fields to remove expiration from.
       */
      parseCommand(parser, key, fields) {
        parser.push("HPERSIST");
        parser.pushKey(key);
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HPEXPIRE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HPEXPIRE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Parses the arguments for the `HPEXPIRE` command.
       *
       * @param parser - The command parser instance.
       * @param key - The key of the hash.
       * @param fields - The fields to set the expiration for.
       * @param ms - The expiration time in milliseconds.
       * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT').
       */
      parseCommand(parser, key, fields, ms, mode) {
        parser.push("HPEXPIRE");
        parser.pushKey(key);
        parser.push(ms.toString());
        if (mode) {
          parser.push(mode);
        }
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HPEXPIREAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HPEXPIREAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Parses the arguments for the `HPEXPIREAT` command.
       *
       * @param parser - The command parser instance.
       * @param key - The key of the hash.
       * @param fields - The fields to set the expiration for.
       * @param timestamp - The expiration timestamp (Unix timestamp or Date object).
       * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT').
       */
      parseCommand(parser, key, fields, timestamp, mode) {
        parser.push("HPEXPIREAT");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformPXAT)(timestamp));
        if (mode) {
          parser.push(mode);
        }
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HPEXPIRETIME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HPEXPIRETIME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HPEXPIRETIME command
       *
       * @param parser - The command parser
       * @param key - The key to retrieve expiration time for
       * @param fields - The fields to retrieve expiration time for
       * @see https://redis.io/commands/hpexpiretime/
       */
      parseCommand(parser, key, fields) {
        parser.push("HPEXPIRETIME");
        parser.pushKey(key);
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HPTTL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HPTTL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HPTTL command
       *
       * @param parser - The command parser
       * @param key - The key to check time-to-live for
       * @param fields - The fields to check time-to-live for
       * @see https://redis.io/commands/hpttl/
       */
      parseCommand(parser, key, fields) {
        parser.push("HPTTL");
        parser.pushKey(key);
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HRANDFIELD_COUNT_WITHVALUES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT_WITHVALUES.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HRANDFIELD command with count parameter and WITHVALUES option
       *
       * @param parser - The command parser
       * @param key - The key of the hash to get random fields from
       * @param count - The number of fields to return (positive: unique fields, negative: may repeat fields)
       * @see https://redis.io/commands/hrandfield/
       */
      parseCommand(parser, key, count) {
        parser.push("HRANDFIELD");
        parser.pushKey(key);
        parser.push(count.toString(), "WITHVALUES");
      },
      transformReply: {
        2: (rawReply) => {
          const reply = [];
          let i2 = 0;
          while (i2 < rawReply.length) {
            reply.push({
              field: rawReply[i2++],
              value: rawReply[i2++]
            });
          }
          return reply;
        },
        3: (reply) => {
          return reply.map((entry) => {
            const [field, value] = entry;
            return {
              field,
              value
            };
          });
        }
      }
    };
  }
});
var require_HRANDFIELD_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HRANDFIELD command with count parameter
       *
       * @param parser - The command parser
       * @param key - The key of the hash to get random fields from
       * @param count - The number of fields to return (positive: unique fields, negative: may repeat fields)
       * @see https://redis.io/commands/hrandfield/
       */
      parseCommand(parser, key, count) {
        parser.push("HRANDFIELD");
        parser.pushKey(key);
        parser.push(count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_HRANDFIELD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HRANDFIELD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HRANDFIELD command
       *
       * @param parser - The command parser
       * @param key - The key of the hash to get a random field from
       * @see https://redis.io/commands/hrandfield/
       */
      parseCommand(parser, key) {
        parser.push("HRANDFIELD");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_SCAN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SCAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pushScanArguments = exports.parseScanArguments = void 0;
    function parseScanArguments(parser, cursor, options2) {
      parser.push(cursor);
      if (options2?.MATCH) {
        parser.push("MATCH", options2.MATCH);
      }
      if (options2?.COUNT) {
        parser.push("COUNT", options2.COUNT.toString());
      }
    }
    exports.parseScanArguments = parseScanArguments;
    function pushScanArguments(args, cursor, options2) {
      args.push(cursor.toString());
      if (options2?.MATCH) {
        args.push("MATCH", options2.MATCH);
      }
      if (options2?.COUNT) {
        args.push("COUNT", options2.COUNT.toString());
      }
      return args;
    }
    exports.pushScanArguments = pushScanArguments;
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SCAN command
       *
       * @param parser - The command parser
       * @param cursor - The cursor position to start scanning from
       * @param options - Scan options
       * @see https://redis.io/commands/scan/
       */
      parseCommand(parser, cursor, options2) {
        parser.push("SCAN");
        parseScanArguments(parser, cursor, options2);
        if (options2?.TYPE) {
          parser.push("TYPE", options2.TYPE);
        }
      },
      /**
       * Transforms the SCAN reply into a structured object
       *
       * @param reply - The raw reply containing cursor and keys
       * @returns Object with cursor and keys properties
       */
      transformReply([cursor, keys]) {
        return {
          cursor,
          keys
        };
      }
    };
  }
});
var require_HSCAN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HSCAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SCAN_1 = require_SCAN();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HSCAN command
       *
       * @param parser - The command parser
       * @param key - The key of the hash to scan
       * @param cursor - The cursor position to start scanning from
       * @param options - Options for the scan (COUNT, MATCH, TYPE)
       * @see https://redis.io/commands/hscan/
       */
      parseCommand(parser, key, cursor, options2) {
        parser.push("HSCAN");
        parser.pushKey(key);
        (0, SCAN_1.parseScanArguments)(parser, cursor, options2);
      },
      transformReply([cursor, rawEntries]) {
        const entries = [];
        let i2 = 0;
        while (i2 < rawEntries.length) {
          entries.push({
            field: rawEntries[i2++],
            value: rawEntries[i2++]
          });
        }
        return {
          cursor,
          entries
        };
      }
    };
  }
});
var require_HSCAN_NOVALUES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HSCAN_NOVALUES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HSCAN_1 = __importDefault(require_HSCAN());
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HSCAN command with NOVALUES option
       *
       * @param args - The same parameters as HSCAN command
       * @see https://redis.io/commands/hscan/
       */
      parseCommand(...args) {
        const parser = args[0];
        HSCAN_1.default.parseCommand(...args);
        parser.push("NOVALUES");
      },
      transformReply([cursor, fields]) {
        return {
          cursor,
          fields
        };
      }
    };
  }
});
var require_HSET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HSET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the HSET command
       *
       * @param parser - The command parser
       * @param key - The key of the hash
       * @param value - Either the field name (when using single field) or an object/map/array of field-value pairs
       * @param fieldValue - The value to set (only used with single field variant)
       * @see https://redis.io/commands/hset/
       */
      parseCommand(parser, ...[key, value, fieldValue]) {
        parser.push("HSET");
        parser.pushKey(key);
        if (typeof value === "string" || typeof value === "number" || value instanceof Buffer) {
          parser.push(convertValue(value), convertValue(fieldValue));
        } else if (value instanceof Map) {
          pushMap(parser, value);
        } else if (Array.isArray(value)) {
          pushTuples(parser, value);
        } else {
          pushObject(parser, value);
        }
      },
      transformReply: void 0
    };
    function pushMap(parser, map) {
      for (const [key, value] of map.entries()) {
        parser.push(convertValue(key), convertValue(value));
      }
    }
    function pushTuples(parser, tuples) {
      for (const tuple of tuples) {
        if (Array.isArray(tuple)) {
          pushTuples(parser, tuple);
          continue;
        }
        parser.push(convertValue(tuple));
      }
    }
    function pushObject(parser, object) {
      for (const key of Object.keys(object)) {
        parser.push(convertValue(key), convertValue(object[key]));
      }
    }
    function convertValue(value) {
      return typeof value === "number" ? value.toString() : value;
    }
  }
});
var require_HSETEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HSETEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var parser_1 = require_parser();
    exports.default = {
      /**
       * Constructs the HSETEX command
       *
       * @param parser - The command parser
       * @param key - The key of the hash
       * @param fields - Object, Map, or Array of field-value pairs to set
       * @param options - Optional configuration for expiration and mode settings
       * @see https://redis.io/commands/hsetex/
       */
      parseCommand(parser, key, fields, options2) {
        parser.push("HSETEX");
        parser.pushKey(key);
        if (options2?.mode) {
          parser.push(options2.mode);
        }
        if (options2?.expiration) {
          if (typeof options2.expiration === "string") {
            parser.push(options2.expiration);
          } else if (options2.expiration.type === "KEEPTTL") {
            parser.push("KEEPTTL");
          } else {
            parser.push(options2.expiration.type, options2.expiration.value.toString());
          }
        }
        parser.push("FIELDS");
        if (fields instanceof Map) {
          pushMap(parser, fields);
        } else if (Array.isArray(fields)) {
          pushTuples(parser, fields);
        } else {
          pushObject(parser, fields);
        }
      },
      transformReply: void 0
    };
    function pushMap(parser, map) {
      parser.push(map.size.toString());
      for (const [key, value] of map.entries()) {
        parser.push(convertValue(key), convertValue(value));
      }
    }
    function pushTuples(parser, tuples) {
      const tmpParser = new parser_1.BasicCommandParser();
      _pushTuples(tmpParser, tuples);
      if (tmpParser.redisArgs.length % 2 != 0) {
        throw Error("invalid number of arguments, expected key value ....[key value] pairs, got key without value");
      }
      parser.push((tmpParser.redisArgs.length / 2).toString());
      parser.push(...tmpParser.redisArgs);
    }
    function _pushTuples(parser, tuples) {
      for (const tuple of tuples) {
        if (Array.isArray(tuple)) {
          _pushTuples(parser, tuple);
          continue;
        }
        parser.push(convertValue(tuple));
      }
    }
    function pushObject(parser, object) {
      const len = Object.keys(object).length;
      if (len == 0) {
        throw Error("object without keys");
      }
      parser.push(len.toString());
      for (const key of Object.keys(object)) {
        parser.push(convertValue(key), convertValue(object[key]));
      }
    }
    function convertValue(value) {
      return typeof value === "number" ? value.toString() : value;
    }
  }
});
var require_HSETNX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HSETNX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the HSETNX command
       *
       * @param parser - The command parser
       * @param key - The key of the hash
       * @param field - The field to set if it does not exist
       * @param value - The value to set
       * @see https://redis.io/commands/hsetnx/
       */
      parseCommand(parser, key, field, value) {
        parser.push("HSETNX");
        parser.pushKey(key);
        parser.push(field, value);
      },
      transformReply: void 0
    };
  }
});
var require_HSTRLEN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HSTRLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the HSTRLEN command
       *
       * @param parser - The command parser
       * @param key - The key of the hash
       * @param field - The field to get the string length of
       * @see https://redis.io/commands/hstrlen/
       */
      parseCommand(parser, key, field) {
        parser.push("HSTRLEN");
        parser.pushKey(key);
        parser.push(field);
      },
      transformReply: void 0
    };
  }
});
var require_HTTL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HTTL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the remaining time to live of field(s) in a hash.
       * @param parser - The Redis command parser.
       * @param key - Key of the hash.
       * @param fields - Fields to check time to live.
       */
      parseCommand(parser, key, fields) {
        parser.push("HTTL");
        parser.pushKey(key);
        parser.push("FIELDS");
        parser.pushVariadicWithLength(fields);
      },
      transformReply: void 0
    };
  }
});
var require_HVALS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/HVALS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Gets all values in a hash.
       * @param parser - The Redis command parser.
       * @param key - Key of the hash.
       */
      parseCommand(parser, key) {
        parser.push("HVALS");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_INCR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/INCR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the INCR command
       *
       * @param parser - The command parser
       * @param key - The key to increment
       * @see https://redis.io/commands/incr/
       */
      parseCommand(parser, key) {
        parser.push("INCR");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_INCRBY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/INCRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the INCRBY command
       *
       * @param parser - The command parser
       * @param key - The key to increment
       * @param increment - The amount to increment by
       * @see https://redis.io/commands/incrby/
       */
      parseCommand(parser, key, increment) {
        parser.push("INCRBY");
        parser.pushKey(key);
        parser.push(increment.toString());
      },
      transformReply: void 0
    };
  }
});
var require_INCRBYFLOAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/INCRBYFLOAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the INCRBYFLOAT command
       *
       * @param parser - The command parser
       * @param key - The key to increment
       * @param increment - The floating-point value to increment by
       * @see https://redis.io/commands/incrbyfloat/
       */
      parseCommand(parser, key, increment) {
        parser.push("INCRBYFLOAT");
        parser.pushKey(key);
        parser.push(increment.toString());
      },
      transformReply: void 0
    };
  }
});
var require_INFO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the INFO command
       *
       * @param parser - The command parser
       * @param section - Optional specific section of information to retrieve
       * @see https://redis.io/commands/info/
       */
      parseCommand(parser, section) {
        parser.push("INFO");
        if (section) {
          parser.push(section);
        }
      },
      transformReply: void 0
    };
  }
});
var require_KEYS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/KEYS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the KEYS command
       *
       * @param parser - The command parser
       * @param pattern - The pattern to match keys against
       * @see https://redis.io/commands/keys/
       */
      parseCommand(parser, pattern) {
        parser.push("KEYS", pattern);
      },
      transformReply: void 0
    };
  }
});
var require_LASTSAVE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LASTSAVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LASTSAVE command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/lastsave/
       */
      parseCommand(parser) {
        parser.push("LASTSAVE");
      },
      transformReply: void 0
    };
  }
});
var require_LATENCY_DOCTOR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LATENCY_DOCTOR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LATENCY DOCTOR command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/latency-doctor/
       */
      parseCommand(parser) {
        parser.push("LATENCY", "DOCTOR");
      },
      transformReply: void 0
    };
  }
});
var require_LATENCY_GRAPH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LATENCY_GRAPH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LATENCY_EVENTS = void 0;
    exports.LATENCY_EVENTS = {
      ACTIVE_DEFRAG_CYCLE: "active-defrag-cycle",
      AOF_FSYNC_ALWAYS: "aof-fsync-always",
      AOF_STAT: "aof-stat",
      AOF_REWRITE_DIFF_WRITE: "aof-rewrite-diff-write",
      AOF_RENAME: "aof-rename",
      AOF_WRITE: "aof-write",
      AOF_WRITE_ACTIVE_CHILD: "aof-write-active-child",
      AOF_WRITE_ALONE: "aof-write-alone",
      AOF_WRITE_PENDING_FSYNC: "aof-write-pending-fsync",
      COMMAND: "command",
      EXPIRE_CYCLE: "expire-cycle",
      EVICTION_CYCLE: "eviction-cycle",
      EVICTION_DEL: "eviction-del",
      FAST_COMMAND: "fast-command",
      FORK: "fork",
      RDB_UNLINK_TEMP_FILE: "rdb-unlink-temp-file"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LATENCY GRAPH command
       *
       * @param parser - The command parser
       * @param event - The latency event to get the graph for
       * @see https://redis.io/commands/latency-graph/
       */
      parseCommand(parser, event) {
        parser.push("LATENCY", "GRAPH", event);
      },
      transformReply: void 0
    };
  }
});
var require_LATENCY_HISTORY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LATENCY_HISTORY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LATENCY HISTORY command
       *
       * @param parser - The command parser
       * @param event - The latency event to get the history for
       * @see https://redis.io/commands/latency-history/
       */
      parseCommand(parser, event) {
        parser.push("LATENCY", "HISTORY", event);
      },
      transformReply: void 0
    };
  }
});
var require_LATENCY_LATEST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LATENCY_LATEST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LATENCY LATEST command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/latency-latest/
       */
      parseCommand(parser) {
        parser.push("LATENCY", "LATEST");
      },
      transformReply: void 0
    };
  }
});
var require_LATENCY_RESET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LATENCY_RESET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LATENCY_EVENTS = void 0;
    var LATENCY_GRAPH_1 = require_LATENCY_GRAPH();
    Object.defineProperty(exports, "LATENCY_EVENTS", { enumerable: true, get: function() {
      return LATENCY_GRAPH_1.LATENCY_EVENTS;
    } });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Constructs the LATENCY RESET command
       * * @param parser - The command parser
       * @param events - The latency events to reset. If not specified, all events are reset.
       * @see https://redis.io/commands/latency-reset/
       */
      parseCommand(parser, ...events) {
        const args = ["LATENCY", "RESET"];
        if (events.length > 0) {
          args.push(...events);
        }
        parser.push(...args);
      },
      transformReply: void 0
    };
  }
});
var require_LCS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LCS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the LCS command (Longest Common Substring)
       *
       * @param parser - The command parser
       * @param key1 - First key containing the first string
       * @param key2 - Second key containing the second string
       * @see https://redis.io/commands/lcs/
       */
      parseCommand(parser, key1, key2) {
        parser.push("LCS");
        parser.pushKeys([key1, key2]);
      },
      transformReply: void 0
    };
  }
});
var require_LCS_IDX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LCS_IDX.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var LCS_1 = __importDefault(require_LCS());
    exports.default = {
      IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
      /**
       * Constructs the LCS command with IDX option
       *
       * @param parser - The command parser
       * @param key1 - First key containing the first string
       * @param key2 - Second key containing the second string
       * @param options - Additional options for the LCS IDX command
       * @see https://redis.io/commands/lcs/
       */
      parseCommand(parser, key1, key2, options2) {
        LCS_1.default.parseCommand(parser, key1, key2);
        parser.push("IDX");
        if (options2?.MINMATCHLEN) {
          parser.push("MINMATCHLEN", options2.MINMATCHLEN.toString());
        }
      },
      transformReply: {
        2: (reply) => ({
          matches: reply[1],
          len: reply[3]
        }),
        3: void 0
      }
    };
  }
});
var require_LCS_IDX_WITHMATCHLEN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LCS_IDX_WITHMATCHLEN.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var LCS_IDX_1 = __importDefault(require_LCS_IDX());
    exports.default = {
      IS_READ_ONLY: LCS_IDX_1.default.IS_READ_ONLY,
      /**
       * Constructs the LCS command with IDX and WITHMATCHLEN options
       *
       * @param args - The same parameters as LCS_IDX command
       * @see https://redis.io/commands/lcs/
       */
      parseCommand(...args) {
        const parser = args[0];
        LCS_IDX_1.default.parseCommand(...args);
        parser.push("WITHMATCHLEN");
      },
      transformReply: {
        2: (reply) => ({
          matches: reply[1],
          len: reply[3]
        }),
        3: void 0
      }
    };
  }
});
var require_LCS_LEN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LCS_LEN.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var LCS_1 = __importDefault(require_LCS());
    exports.default = {
      IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
      /**
       * Constructs the LCS command with LEN option
       *
       * @param args - The same parameters as LCS command
       * @see https://redis.io/commands/lcs/
       */
      parseCommand(...args) {
        const parser = args[0];
        LCS_1.default.parseCommand(...args);
        parser.push("LEN");
      },
      transformReply: void 0
    };
  }
});
var require_LINDEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LINDEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LINDEX command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param index - The index of the element to retrieve
       * @see https://redis.io/commands/lindex/
       */
      parseCommand(parser, key, index) {
        parser.push("LINDEX");
        parser.pushKey(key);
        parser.push(index.toString());
      },
      transformReply: void 0
    };
  }
});
var require_LINSERT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LINSERT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the LINSERT command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param position - The position where to insert (BEFORE or AFTER)
       * @param pivot - The element to find in the list
       * @param element - The element to insert
       * @see https://redis.io/commands/linsert/
       */
      parseCommand(parser, key, position, pivot, element) {
        parser.push("LINSERT");
        parser.pushKey(key);
        parser.push(position, pivot, element);
      },
      transformReply: void 0
    };
  }
});
var require_LLEN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LLEN command
       *
       * @param parser - The command parser
       * @param key - The key of the list to get the length of
       * @see https://redis.io/commands/llen/
       */
      parseCommand(parser, key) {
        parser.push("LLEN");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_LMOVE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LMOVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the LMOVE command
       *
       * @param parser - The command parser
       * @param source - The source list key
       * @param destination - The destination list key
       * @param sourceSide - The side to pop from (LEFT or RIGHT)
       * @param destinationSide - The side to push to (LEFT or RIGHT)
       * @see https://redis.io/commands/lmove/
       */
      parseCommand(parser, source, destination, sourceSide, destinationSide) {
        parser.push("LMOVE");
        parser.pushKeys([source, destination]);
        parser.push(sourceSide, destinationSide);
      },
      transformReply: void 0
    };
  }
});
var require_LOLWUT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LOLWUT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LOLWUT command
       *
       * @param parser - The command parser
       * @param version - Optional version parameter
       * @param optionalArguments - Additional optional numeric arguments
       * @see https://redis.io/commands/lolwut/
       */
      parseCommand(parser, version, ...optionalArguments) {
        parser.push("LOLWUT");
        if (version) {
          parser.push("VERSION", version.toString());
          parser.pushVariadic(optionalArguments.map(String));
        }
      },
      transformReply: void 0
    };
  }
});
var require_LPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LPOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the LPOP command
       *
       * @param parser - The command parser
       * @param key - The key of the list to pop from
       * @see https://redis.io/commands/lpop/
       */
      parseCommand(parser, key) {
        parser.push("LPOP");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_LPOP_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LPOP_COUNT.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var LPOP_1 = __importDefault(require_LPOP());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the LPOP command with count parameter
       *
       * @param parser - The command parser
       * @param key - The key of the list to pop from
       * @param count - The number of elements to pop
       * @see https://redis.io/commands/lpop/
       */
      parseCommand(parser, key, count) {
        LPOP_1.default.parseCommand(parser, key);
        parser.push(count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_LPOS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LPOS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LPOS command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param element - The element to search for
       * @param options - Optional parameters for RANK and MAXLEN
       * @see https://redis.io/commands/lpos/
       */
      parseCommand(parser, key, element, options2) {
        parser.push("LPOS");
        parser.pushKey(key);
        parser.push(element);
        if (options2?.RANK !== void 0) {
          parser.push("RANK", options2.RANK.toString());
        }
        if (options2?.MAXLEN !== void 0) {
          parser.push("MAXLEN", options2.MAXLEN.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_LPOS_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LPOS_COUNT.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var LPOS_1 = __importDefault(require_LPOS());
    exports.default = {
      CACHEABLE: LPOS_1.default.CACHEABLE,
      IS_READ_ONLY: LPOS_1.default.IS_READ_ONLY,
      /**
       * Constructs the LPOS command with COUNT option
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param element - The element to search for
       * @param count - The number of positions to return
       * @param options - Optional parameters for RANK and MAXLEN
       * @see https://redis.io/commands/lpos/
       */
      parseCommand(parser, key, element, count, options2) {
        LPOS_1.default.parseCommand(parser, key, element, options2);
        parser.push("COUNT", count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_LPUSH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LPUSH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the LPUSH command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param elements - One or more elements to push to the list
       * @see https://redis.io/commands/lpush/
       */
      parseCommand(parser, key, elements) {
        parser.push("LPUSH");
        parser.pushKey(key);
        parser.pushVariadic(elements);
      },
      transformReply: void 0
    };
  }
});
var require_LPUSHX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LPUSHX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the LPUSHX command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param elements - One or more elements to push to the list if it exists
       * @see https://redis.io/commands/lpushx/
       */
      parseCommand(parser, key, elements) {
        parser.push("LPUSHX");
        parser.pushKey(key);
        parser.pushVariadic(elements);
      },
      transformReply: void 0
    };
  }
});
var require_LRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the LRANGE command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param start - The starting index
       * @param stop - The ending index
       * @see https://redis.io/commands/lrange/
       */
      parseCommand(parser, key, start, stop) {
        parser.push("LRANGE");
        parser.pushKey(key);
        parser.push(start.toString(), stop.toString());
      },
      transformReply: void 0
    };
  }
});
var require_LREM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LREM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the LREM command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param count - The count of elements to remove (negative: from tail to head, 0: all occurrences, positive: from head to tail)
       * @param element - The element to remove
       * @see https://redis.io/commands/lrem/
       */
      parseCommand(parser, key, count, element) {
        parser.push("LREM");
        parser.pushKey(key);
        parser.push(count.toString());
        parser.push(element);
      },
      transformReply: void 0
    };
  }
});
var require_LSET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LSET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the LSET command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param index - The index of the element to replace
       * @param element - The new value to set
       * @see https://redis.io/commands/lset/
       */
      parseCommand(parser, key, index, element) {
        parser.push("LSET");
        parser.pushKey(key);
        parser.push(index.toString(), element);
      },
      transformReply: void 0
    };
  }
});
var require_LTRIM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/LTRIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the LTRIM command
       *
       * @param parser - The command parser
       * @param key - The key of the list
       * @param start - The starting index
       * @param stop - The ending index
       * @see https://redis.io/commands/ltrim/
       */
      parseCommand(parser, key, start, stop) {
        parser.push("LTRIM");
        parser.pushKey(key);
        parser.push(start.toString(), stop.toString());
      },
      transformReply: void 0
    };
  }
});
var require_MEMORY_DOCTOR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MEMORY_DOCTOR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the MEMORY DOCTOR command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/memory-doctor/
       */
      parseCommand(parser) {
        parser.push("MEMORY", "DOCTOR");
      },
      transformReply: void 0
    };
  }
});
var require_MEMORY_MALLOC_STATS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MEMORY_MALLOC-STATS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the MEMORY MALLOC-STATS command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/memory-malloc-stats/
       */
      parseCommand(parser) {
        parser.push("MEMORY", "MALLOC-STATS");
      },
      transformReply: void 0
    };
  }
});
var require_MEMORY_PURGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MEMORY_PURGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Constructs the MEMORY PURGE command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/memory-purge/
       */
      parseCommand(parser) {
        parser.push("MEMORY", "PURGE");
      },
      transformReply: void 0
    };
  }
});
var require_MEMORY_STATS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MEMORY_STATS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the MEMORY STATS command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/memory-stats/
       */
      parseCommand(parser) {
        parser.push("MEMORY", "STATS");
      },
      transformReply: {
        2: (rawReply, preserve, typeMapping) => {
          const reply = {};
          let i2 = 0;
          while (i2 < rawReply.length) {
            switch (rawReply[i2].toString()) {
              case "dataset.percentage":
              case "peak.percentage":
              case "allocator-fragmentation.ratio":
              case "allocator-rss.ratio":
              case "rss-overhead.ratio":
              case "fragmentation":
                reply[rawReply[i2++]] = generic_transformers_1.transformDoubleReply[2](rawReply[i2++], preserve, typeMapping);
                break;
              default:
                reply[rawReply[i2++]] = rawReply[i2++];
            }
          }
          return reply;
        },
        3: void 0
      }
    };
  }
});
var require_MEMORY_USAGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MEMORY_USAGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the MEMORY USAGE command
       *
       * @param parser - The command parser
       * @param key - The key to get memory usage for
       * @param options - Optional parameters including SAMPLES
       * @see https://redis.io/commands/memory-usage/
       */
      parseCommand(parser, key, options2) {
        parser.push("MEMORY", "USAGE");
        parser.pushKey(key);
        if (options2?.SAMPLES) {
          parser.push("SAMPLES", options2.SAMPLES.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_MGET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the MGET command
       *
       * @param parser - The command parser
       * @param keys - Array of keys to get
       * @see https://redis.io/commands/mget/
       */
      parseCommand(parser, keys) {
        parser.push("MGET");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_MIGRATE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MIGRATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the MIGRATE command
       *
       * @param parser - The command parser
       * @param host - Target Redis instance host
       * @param port - Target Redis instance port
       * @param key - Key or keys to migrate
       * @param destinationDb - Target database index
       * @param timeout - Timeout in milliseconds
       * @param options - Optional parameters including COPY, REPLACE, and AUTH
       * @see https://redis.io/commands/migrate/
       */
      parseCommand(parser, host, port, key, destinationDb, timeout, options2) {
        parser.push("MIGRATE", host, port.toString());
        const isKeyArray = Array.isArray(key);
        if (isKeyArray) {
          parser.push("");
        } else {
          parser.push(key);
        }
        parser.push(destinationDb.toString(), timeout.toString());
        if (options2?.COPY) {
          parser.push("COPY");
        }
        if (options2?.REPLACE) {
          parser.push("REPLACE");
        }
        if (options2?.AUTH) {
          if (options2.AUTH.username) {
            parser.push("AUTH2", options2.AUTH.username, options2.AUTH.password);
          } else {
            parser.push("AUTH", options2.AUTH.password);
          }
        }
        if (isKeyArray) {
          parser.push("KEYS");
          parser.pushVariadic(key);
        }
      },
      transformReply: void 0
    };
  }
});
var require_MODULE_LIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MODULE_LIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the MODULE LIST command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/module-list/
       */
      parseCommand(parser) {
        parser.push("MODULE", "LIST");
      },
      transformReply: {
        2: (reply) => {
          return reply.map((module2) => {
            const unwrapped = module2;
            return {
              name: unwrapped[1],
              ver: unwrapped[3]
            };
          });
        },
        3: void 0
      }
    };
  }
});
var require_MODULE_LOAD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MODULE_LOAD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the MODULE LOAD command
       *
       * @param parser - The command parser
       * @param path - Path to the module file
       * @param moduleArguments - Optional arguments to pass to the module
       * @see https://redis.io/commands/module-load/
       */
      parseCommand(parser, path2, moduleArguments) {
        parser.push("MODULE", "LOAD", path2);
        if (moduleArguments) {
          parser.push(...moduleArguments);
        }
      },
      transformReply: void 0
    };
  }
});
var require_MODULE_UNLOAD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MODULE_UNLOAD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the MODULE UNLOAD command
       *
       * @param parser - The command parser
       * @param name - The name of the module to unload
       * @see https://redis.io/commands/module-unload/
       */
      parseCommand(parser, name) {
        parser.push("MODULE", "UNLOAD", name);
      },
      transformReply: void 0
    };
  }
});
var require_MOVE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MOVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the MOVE command
       *
       * @param parser - The command parser
       * @param key - The key to move
       * @param db - The destination database index
       * @see https://redis.io/commands/move/
       */
      parseCommand(parser, key, db2) {
        parser.push("MOVE");
        parser.pushKey(key);
        parser.push(db2.toString());
      },
      transformReply: void 0
    };
  }
});
var require_MSET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MSET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseMSetArguments = void 0;
    function parseMSetArguments(parser, toSet) {
      if (Array.isArray(toSet)) {
        if (toSet.length == 0) {
          throw new Error("empty toSet Argument");
        }
        if (Array.isArray(toSet[0])) {
          for (const tuple of toSet) {
            parser.pushKey(tuple[0]);
            parser.push(tuple[1]);
          }
        } else {
          const arr = toSet;
          for (let i2 = 0; i2 < arr.length; i2 += 2) {
            parser.pushKey(arr[i2]);
            parser.push(arr[i2 + 1]);
          }
        }
      } else {
        for (const tuple of Object.entries(toSet)) {
          parser.pushKey(tuple[0]);
          parser.push(tuple[1]);
        }
      }
    }
    exports.parseMSetArguments = parseMSetArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the MSET command
       *
       * @param parser - The command parser
       * @param toSet - Key-value pairs to set (array of tuples, flat array, or object)
       * @see https://redis.io/commands/mset/
       */
      parseCommand(parser, toSet) {
        parser.push("MSET");
        return parseMSetArguments(parser, toSet);
      },
      transformReply: void 0
    };
  }
});
var require_MSETNX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/MSETNX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MSET_1 = require_MSET();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the MSETNX command
       *
       * @param parser - The command parser
       * @param toSet - Key-value pairs to set if none of the keys exist (array of tuples, flat array, or object)
       * @see https://redis.io/commands/msetnx/
       */
      parseCommand(parser, toSet) {
        parser.push("MSETNX");
        return (0, MSET_1.parseMSetArguments)(parser, toSet);
      },
      transformReply: void 0
    };
  }
});
var require_OBJECT_ENCODING = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/OBJECT_ENCODING.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the OBJECT ENCODING command
       *
       * @param parser - The command parser
       * @param key - The key to get the internal encoding for
       * @see https://redis.io/commands/object-encoding/
       */
      parseCommand(parser, key) {
        parser.push("OBJECT", "ENCODING");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_OBJECT_FREQ = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/OBJECT_FREQ.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the OBJECT FREQ command
       *
       * @param parser - The command parser
       * @param key - The key to get the access frequency for
       * @see https://redis.io/commands/object-freq/
       */
      parseCommand(parser, key) {
        parser.push("OBJECT", "FREQ");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_OBJECT_IDLETIME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/OBJECT_IDLETIME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the OBJECT IDLETIME command
       *
       * @param parser - The command parser
       * @param key - The key to get the idle time for
       * @see https://redis.io/commands/object-idletime/
       */
      parseCommand(parser, key) {
        parser.push("OBJECT", "IDLETIME");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_OBJECT_REFCOUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/OBJECT_REFCOUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the OBJECT REFCOUNT command
       *
       * @param parser - The command parser
       * @param key - The key to get the reference count for
       * @see https://redis.io/commands/object-refcount/
       */
      parseCommand(parser, key) {
        parser.push("OBJECT", "REFCOUNT");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_PERSIST = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PERSIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the PERSIST command
       *
       * @param parser - The command parser
       * @param key - The key to remove the expiration from
       * @see https://redis.io/commands/persist/
       */
      parseCommand(parser, key) {
        parser.push("PERSIST");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_PEXPIRE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PEXPIRE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the PEXPIRE command
       *
       * @param parser - The command parser
       * @param key - The key to set the expiration for
       * @param ms - The expiration time in milliseconds
       * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT')
       * @see https://redis.io/commands/pexpire/
       */
      parseCommand(parser, key, ms, mode) {
        parser.push("PEXPIRE");
        parser.pushKey(key);
        parser.push(ms.toString());
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_PEXPIREAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PEXPIREAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the PEXPIREAT command
       *
       * @param parser - The command parser
       * @param key - The key to set the expiration for
       * @param msTimestamp - The expiration timestamp in milliseconds (Unix timestamp or Date object)
       * @param mode - Optional mode for the command ('NX', 'XX', 'GT', 'LT')
       * @see https://redis.io/commands/pexpireat/
       */
      parseCommand(parser, key, msTimestamp, mode) {
        parser.push("PEXPIREAT");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformPXAT)(msTimestamp));
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_PEXPIRETIME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PEXPIRETIME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the PEXPIRETIME command
       *
       * @param parser - The command parser
       * @param key - The key to get the expiration time for in milliseconds
       * @see https://redis.io/commands/pexpiretime/
       */
      parseCommand(parser, key) {
        parser.push("PEXPIRETIME");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_PFADD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PFADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the PFADD command
       *
       * @param parser - The command parser
       * @param key - The key of the HyperLogLog
       * @param element - Optional elements to add
       * @see https://redis.io/commands/pfadd/
       */
      parseCommand(parser, key, element) {
        parser.push("PFADD");
        parser.pushKey(key);
        if (element) {
          parser.pushVariadic(element);
        }
      },
      transformReply: void 0
    };
  }
});
var require_PFCOUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PFCOUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the PFCOUNT command
       *
       * @param parser - The command parser
       * @param keys - One or more keys of HyperLogLog structures to count
       * @see https://redis.io/commands/pfcount/
       */
      parseCommand(parser, keys) {
        parser.push("PFCOUNT");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_PFMERGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PFMERGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the PFMERGE command
       *
       * @param parser - The command parser
       * @param destination - The destination key to merge to
       * @param sources - One or more source keys to merge from
       * @see https://redis.io/commands/pfmerge/
       */
      parseCommand(parser, destination, sources) {
        parser.push("PFMERGE");
        parser.pushKey(destination);
        if (sources) {
          parser.pushKeys(sources);
        }
      },
      transformReply: void 0
    };
  }
});
var require_PING = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PING.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the PING command
       *
       * @param parser - The command parser
       * @param message - Optional message to be returned instead of PONG
       * @see https://redis.io/commands/ping/
       */
      parseCommand(parser, message) {
        parser.push("PING");
        if (message) {
          parser.push(message);
        }
      },
      transformReply: void 0
    };
  }
});
var require_PSETEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PSETEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the PSETEX command
       *
       * @param parser - The command parser
       * @param key - The key to set
       * @param ms - The expiration time in milliseconds
       * @param value - The value to set
       * @see https://redis.io/commands/psetex/
       */
      parseCommand(parser, key, ms, value) {
        parser.push("PSETEX");
        parser.pushKey(key);
        parser.push(ms.toString(), value);
      },
      transformReply: void 0
    };
  }
});
var require_PTTL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PTTL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the PTTL command
       *
       * @param parser - The command parser
       * @param key - The key to get the time to live in milliseconds
       * @see https://redis.io/commands/pttl/
       */
      parseCommand(parser, key) {
        parser.push("PTTL");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_PUBLISH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PUBLISH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      IS_FORWARD_COMMAND: true,
      /**
       * Constructs the PUBLISH command
       *
       * @param parser - The command parser
       * @param channel - The channel to publish to
       * @param message - The message to publish
       * @see https://redis.io/commands/publish/
       */
      parseCommand(parser, channel, message) {
        parser.push("PUBLISH", channel, message);
      },
      transformReply: void 0
    };
  }
});
var require_PUBSUB_CHANNELS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PUBSUB_CHANNELS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the PUBSUB CHANNELS command
       *
       * @param parser - The command parser
       * @param pattern - Optional pattern to filter channels
       * @see https://redis.io/commands/pubsub-channels/
       */
      parseCommand(parser, pattern) {
        parser.push("PUBSUB", "CHANNELS");
        if (pattern) {
          parser.push(pattern);
        }
      },
      transformReply: void 0
    };
  }
});
var require_PUBSUB_NUMPAT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMPAT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the PUBSUB NUMPAT command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/pubsub-numpat/
       */
      parseCommand(parser) {
        parser.push("PUBSUB", "NUMPAT");
      },
      transformReply: void 0
    };
  }
});
var require_PUBSUB_NUMSUB = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMSUB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the PUBSUB NUMSUB command
       *
       * @param parser - The command parser
       * @param channels - Optional channel names to get subscription count for
       * @see https://redis.io/commands/pubsub-numsub/
       */
      parseCommand(parser, channels) {
        parser.push("PUBSUB", "NUMSUB");
        if (channels) {
          parser.pushVariadic(channels);
        }
      },
      /**
       * Transforms the PUBSUB NUMSUB reply into a record of channel name to subscriber count
       *
       * @param rawReply - The raw reply from Redis
       * @returns Record mapping channel names to their subscriber counts
       */
      transformReply(rawReply) {
        const reply = /* @__PURE__ */ Object.create(null);
        let i2 = 0;
        while (i2 < rawReply.length) {
          reply[rawReply[i2++].toString()] = Number(rawReply[i2++]);
        }
        return reply;
      }
    };
  }
});
var require_PUBSUB_SHARDNUMSUB = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDNUMSUB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the PUBSUB SHARDNUMSUB command
       *
       * @param parser - The command parser
       * @param channels - Optional shard channel names to get subscription count for
       * @see https://redis.io/commands/pubsub-shardnumsub/
       */
      parseCommand(parser, channels) {
        parser.push("PUBSUB", "SHARDNUMSUB");
        if (channels) {
          parser.pushVariadic(channels);
        }
      },
      /**
       * Transforms the PUBSUB SHARDNUMSUB reply into a record of shard channel name to subscriber count
       *
       * @param reply - The raw reply from Redis
       * @returns Record mapping shard channel names to their subscriber counts
       */
      transformReply(reply) {
        const transformedReply = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < reply.length; i2 += 2) {
          transformedReply[reply[i2].toString()] = reply[i2 + 1];
        }
        return transformedReply;
      }
    };
  }
});
var require_PUBSUB_SHARDCHANNELS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDCHANNELS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the PUBSUB SHARDCHANNELS command
       *
       * @param parser - The command parser
       * @param pattern - Optional pattern to filter shard channels
       * @see https://redis.io/commands/pubsub-shardchannels/
       */
      parseCommand(parser, pattern) {
        parser.push("PUBSUB", "SHARDCHANNELS");
        if (pattern) {
          parser.push(pattern);
        }
      },
      transformReply: void 0
    };
  }
});
var require_RANDOMKEY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RANDOMKEY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the RANDOMKEY command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/randomkey/
       */
      parseCommand(parser) {
        parser.push("RANDOMKEY");
      },
      transformReply: void 0
    };
  }
});
var require_READONLY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/READONLY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the READONLY command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/readonly/
       */
      parseCommand(parser) {
        parser.push("READONLY");
      },
      transformReply: void 0
    };
  }
});
var require_RENAME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RENAME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the RENAME command
       *
       * @param parser - The command parser
       * @param key - The key to rename
       * @param newKey - The new key name
       * @see https://redis.io/commands/rename/
       */
      parseCommand(parser, key, newKey) {
        parser.push("RENAME");
        parser.pushKeys([key, newKey]);
      },
      transformReply: void 0
    };
  }
});
var require_RENAMENX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RENAMENX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the RENAMENX command
       *
       * @param parser - The command parser
       * @param key - The key to rename
       * @param newKey - The new key name, if it doesn't exist
       * @see https://redis.io/commands/renamenx/
       */
      parseCommand(parser, key, newKey) {
        parser.push("RENAMENX");
        parser.pushKeys([key, newKey]);
      },
      transformReply: void 0
    };
  }
});
var require_REPLICAOF = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/REPLICAOF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the REPLICAOF command
       *
       * @param parser - The command parser
       * @param host - The host of the master to replicate from
       * @param port - The port of the master to replicate from
       * @see https://redis.io/commands/replicaof/
       */
      parseCommand(parser, host, port) {
        parser.push("REPLICAOF", host, port.toString());
      },
      transformReply: void 0
    };
  }
});
var require_RESTORE_ASKING = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RESTORE-ASKING.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the RESTORE-ASKING command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/restore-asking/
       */
      parseCommand(parser) {
        parser.push("RESTORE-ASKING");
      },
      transformReply: void 0
    };
  }
});
var require_RESTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RESTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the RESTORE command
       *
       * @param parser - The command parser
       * @param key - The key to restore
       * @param ttl - Time to live in milliseconds, 0 for no expiry
       * @param serializedValue - The serialized value from DUMP command
       * @param options - Options for the RESTORE command
       * @see https://redis.io/commands/restore/
       */
      parseCommand(parser, key, ttl, serializedValue, options2) {
        parser.push("RESTORE");
        parser.pushKey(key);
        parser.push(ttl.toString(), serializedValue);
        if (options2?.REPLACE) {
          parser.push("REPLACE");
        }
        if (options2?.ABSTTL) {
          parser.push("ABSTTL");
        }
        if (options2?.IDLETIME) {
          parser.push("IDLETIME", options2.IDLETIME.toString());
        }
        if (options2?.FREQ) {
          parser.push("FREQ", options2.FREQ.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_ROLE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ROLE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the ROLE command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/role/
       */
      parseCommand(parser) {
        parser.push("ROLE");
      },
      /**
       * Transforms the ROLE reply into a structured object
       *
       * @param reply - The raw reply from Redis
       * @returns Structured object representing role information
       */
      transformReply(reply) {
        switch (reply[0]) {
          case "master": {
            const [role, replicationOffest, replicas] = reply;
            return {
              role,
              replicationOffest,
              replicas: replicas.map((replica) => {
                const [host, port, replicationOffest2] = replica;
                return {
                  host,
                  port: Number(port),
                  replicationOffest: Number(replicationOffest2)
                };
              })
            };
          }
          case "slave": {
            const [role, masterHost, masterPort, state, dataReceived] = reply;
            return {
              role,
              master: {
                host: masterHost,
                port: masterPort
              },
              state,
              dataReceived
            };
          }
          case "sentinel": {
            const [role, masterNames] = reply;
            return {
              role,
              masterNames
            };
          }
        }
      }
    };
  }
});
var require_RPOP_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RPOP_COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the RPOP command with count parameter
       *
       * @param parser - The command parser
       * @param key - The list key to pop from
       * @param count - The number of elements to pop
       * @see https://redis.io/commands/rpop/
       */
      parseCommand(parser, key, count) {
        parser.push("RPOP");
        parser.pushKey(key);
        parser.push(count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_RPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RPOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the RPOP command
       *
       * @param parser - The command parser
       * @param key - The list key to pop from
       * @see https://redis.io/commands/rpop/
       */
      parseCommand(parser, key) {
        parser.push("RPOP");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_RPOPLPUSH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RPOPLPUSH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the RPOPLPUSH command
       *
       * @param parser - The command parser
       * @param source - The source list key
       * @param destination - The destination list key
       * @see https://redis.io/commands/rpoplpush/
       */
      parseCommand(parser, source, destination) {
        parser.push("RPOPLPUSH");
        parser.pushKeys([source, destination]);
      },
      transformReply: void 0
    };
  }
});
var require_RPUSH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RPUSH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the RPUSH command
       *
       * @param parser - The command parser
       * @param key - The list key to push to
       * @param element - One or more elements to push
       * @see https://redis.io/commands/rpush/
       */
      parseCommand(parser, key, element) {
        parser.push("RPUSH");
        parser.pushKey(key);
        parser.pushVariadic(element);
      },
      transformReply: void 0
    };
  }
});
var require_RPUSHX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/RPUSHX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the RPUSHX command
       *
       * @param parser - The command parser
       * @param key - The list key to push to (only if it exists)
       * @param element - One or more elements to push
       * @see https://redis.io/commands/rpushx/
       */
      parseCommand(parser, key, element) {
        parser.push("RPUSHX");
        parser.pushKey(key);
        parser.pushVariadic(element);
      },
      transformReply: void 0
    };
  }
});
var require_SADD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the SADD command
       *
       * @param parser - The command parser
       * @param key - The set key to add members to
       * @param members - One or more members to add to the set
       * @see https://redis.io/commands/sadd/
       */
      parseCommand(parser, key, members) {
        parser.push("SADD");
        parser.pushKey(key);
        parser.pushVariadic(members);
      },
      transformReply: void 0
    };
  }
});
var require_SCARD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SCARD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SCARD command
       *
       * @param parser - The command parser
       * @param key - The set key to get the cardinality of
       * @see https://redis.io/commands/scard/
       */
      parseCommand(parser, key) {
        parser.push("SCARD");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_SCRIPT_DEBUG = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SCRIPT_DEBUG.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SCRIPT DEBUG command
       *
       * @param parser - The command parser
       * @param mode - Debug mode: YES, SYNC, or NO
       * @see https://redis.io/commands/script-debug/
       */
      parseCommand(parser, mode) {
        parser.push("SCRIPT", "DEBUG", mode);
      },
      transformReply: void 0
    };
  }
});
var require_SCRIPT_EXISTS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SCRIPT_EXISTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SCRIPT EXISTS command
       *
       * @param parser - The command parser
       * @param sha1 - One or more SHA1 digests of scripts
       * @see https://redis.io/commands/script-exists/
       */
      parseCommand(parser, sha1) {
        parser.push("SCRIPT", "EXISTS");
        parser.pushVariadic(sha1);
      },
      transformReply: void 0
    };
  }
});
var require_SCRIPT_FLUSH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SCRIPT_FLUSH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SCRIPT FLUSH command
       *
       * @param parser - The command parser
       * @param mode - Optional flush mode: ASYNC or SYNC
       * @see https://redis.io/commands/script-flush/
       */
      parseCommand(parser, mode) {
        parser.push("SCRIPT", "FLUSH");
        if (mode) {
          parser.push(mode);
        }
      },
      transformReply: void 0
    };
  }
});
var require_SCRIPT_KILL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SCRIPT_KILL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SCRIPT KILL command
       *
       * @param parser - The command parser
       * @see https://redis.io/commands/script-kill/
       */
      parseCommand(parser) {
        parser.push("SCRIPT", "KILL");
      },
      transformReply: void 0
    };
  }
});
var require_SCRIPT_LOAD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SCRIPT_LOAD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SCRIPT LOAD command
       *
       * @param parser - The command parser
       * @param script - The Lua script to load
       * @see https://redis.io/commands/script-load/
       */
      parseCommand(parser, script) {
        parser.push("SCRIPT", "LOAD", script);
      },
      transformReply: void 0
    };
  }
});
var require_SDIFF = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SDIFF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SDIFF command
       *
       * @param parser - The command parser
       * @param keys - One or more set keys to compute the difference from
       * @see https://redis.io/commands/sdiff/
       */
      parseCommand(parser, keys) {
        parser.push("SDIFF");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_SDIFFSTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SDIFFSTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the SDIFFSTORE command
       *
       * @param parser - The command parser
       * @param destination - The destination key to store the result
       * @param keys - One or more set keys to compute the difference from
       * @see https://redis.io/commands/sdiffstore/
       */
      parseCommand(parser, destination, keys) {
        parser.push("SDIFFSTORE");
        parser.pushKey(destination);
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_SET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the SET command
       *
       * @param parser - The command parser
       * @param key - The key to set
       * @param value - The value to set
       * @param options - Additional options for the SET command
       * @see https://redis.io/commands/set/
       */
      parseCommand(parser, key, value, options2) {
        parser.push("SET");
        parser.pushKey(key);
        parser.push(typeof value === "number" ? value.toString() : value);
        if (options2?.expiration) {
          if (typeof options2.expiration === "string") {
            parser.push(options2.expiration);
          } else if (options2.expiration.type === "KEEPTTL") {
            parser.push("KEEPTTL");
          } else {
            parser.push(options2.expiration.type, options2.expiration.value.toString());
          }
        } else if (options2?.EX !== void 0) {
          parser.push("EX", options2.EX.toString());
        } else if (options2?.PX !== void 0) {
          parser.push("PX", options2.PX.toString());
        } else if (options2?.EXAT !== void 0) {
          parser.push("EXAT", options2.EXAT.toString());
        } else if (options2?.PXAT !== void 0) {
          parser.push("PXAT", options2.PXAT.toString());
        } else if (options2?.KEEPTTL) {
          parser.push("KEEPTTL");
        }
        if (options2?.condition) {
          parser.push(options2.condition);
        } else if (options2?.NX) {
          parser.push("NX");
        } else if (options2?.XX) {
          parser.push("XX");
        }
        if (options2?.GET) {
          parser.push("GET");
        }
      },
      transformReply: void 0
    };
  }
});
var require_SETBIT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SETBIT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the SETBIT command
       *
       * @param parser - The command parser
       * @param key - The key to set the bit on
       * @param offset - The bit offset (zero-based)
       * @param value - The bit value (0 or 1)
       * @see https://redis.io/commands/setbit/
       */
      parseCommand(parser, key, offset, value) {
        parser.push("SETBIT");
        parser.pushKey(key);
        parser.push(offset.toString(), value.toString());
      },
      transformReply: void 0
    };
  }
});
var require_SETEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SETEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the SETEX command
       *
       * @param parser - The command parser
       * @param key - The key to set
       * @param seconds - The expiration time in seconds
       * @param value - The value to set
       * @see https://redis.io/commands/setex/
       */
      parseCommand(parser, key, seconds, value) {
        parser.push("SETEX");
        parser.pushKey(key);
        parser.push(seconds.toString(), value);
      },
      transformReply: void 0
    };
  }
});
var require_SETNX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SETNX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the SETNX command
       *
       * @param parser - The command parser
       * @param key - The key to set if it doesn't exist
       * @param value - The value to set
       * @see https://redis.io/commands/setnx/
       */
      parseCommand(parser, key, value) {
        parser.push("SETNX");
        parser.pushKey(key);
        parser.push(value);
      },
      transformReply: void 0
    };
  }
});
var require_SETRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SETRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Constructs the SETRANGE command
       *
       * @param parser - The command parser
       * @param key - The key to modify
       * @param offset - The offset at which to start writing
       * @param value - The value to write at the offset
       * @see https://redis.io/commands/setrange/
       */
      parseCommand(parser, key, offset, value) {
        parser.push("SETRANGE");
        parser.pushKey(key);
        parser.push(offset.toString(), value);
      },
      transformReply: void 0
    };
  }
});
var require_SINTER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SINTER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SINTER command
       *
       * @param parser - The command parser
       * @param keys - One or more set keys to compute the intersection from
       * @see https://redis.io/commands/sinter/
       */
      parseCommand(parser, keys) {
        parser.push("SINTER");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_SINTERCARD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SINTERCARD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the SINTERCARD command
       *
       * @param parser - The command parser
       * @param keys - One or more set keys to compute the intersection cardinality from
       * @param options - Options for the SINTERCARD command or a number for LIMIT (backwards compatibility)
       * @see https://redis.io/commands/sintercard/
       */
      parseCommand(parser, keys, options2) {
        parser.push("SINTERCARD");
        parser.pushKeysLength(keys);
        if (typeof options2 === "number") {
          parser.push("LIMIT", options2.toString());
        } else if (options2?.LIMIT !== void 0) {
          parser.push("LIMIT", options2.LIMIT.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_SINTERSTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SINTERSTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the SINTERSTORE command
       *
       * @param parser - The command parser
       * @param destination - The destination key to store the result
       * @param keys - One or more set keys to compute the intersection from
       * @see https://redis.io/commands/sinterstore/
       */
      parseCommand(parser, destination, keys) {
        parser.push("SINTERSTORE");
        parser.pushKey(destination);
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_SISMEMBER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SISMEMBER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SISMEMBER command
       *
       * @param parser - The command parser
       * @param key - The set key to check membership in
       * @param member - The member to check for existence
       * @see https://redis.io/commands/sismember/
       */
      parseCommand(parser, key, member) {
        parser.push("SISMEMBER");
        parser.pushKey(key);
        parser.push(member);
      },
      transformReply: void 0
    };
  }
});
var require_SMEMBERS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SMEMBERS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SMEMBERS command
       *
       * @param parser - The command parser
       * @param key - The set key to get all members from
       * @see https://redis.io/commands/smembers/
       */
      parseCommand(parser, key) {
        parser.push("SMEMBERS");
        parser.pushKey(key);
      },
      transformReply: {
        2: void 0,
        3: void 0
      }
    };
  }
});
var require_SMISMEMBER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SMISMEMBER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SMISMEMBER command
       *
       * @param parser - The command parser
       * @param key - The set key to check membership in
       * @param members - The members to check for existence
       * @see https://redis.io/commands/smismember/
       */
      parseCommand(parser, key, members) {
        parser.push("SMISMEMBER");
        parser.pushKey(key);
        parser.pushVariadic(members);
      },
      transformReply: void 0
    };
  }
});
var require_SMOVE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SMOVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the SMOVE command
       *
       * @param parser - The command parser
       * @param source - The source set key
       * @param destination - The destination set key
       * @param member - The member to move
       * @see https://redis.io/commands/smove/
       */
      parseCommand(parser, source, destination, member) {
        parser.push("SMOVE");
        parser.pushKeys([source, destination]);
        parser.push(member);
      },
      transformReply: void 0
    };
  }
});
var require_SORT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SORT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSortArguments = void 0;
    function parseSortArguments(parser, key, options2) {
      parser.pushKey(key);
      if (options2?.BY) {
        parser.push("BY", options2.BY);
      }
      if (options2?.LIMIT) {
        parser.push("LIMIT", options2.LIMIT.offset.toString(), options2.LIMIT.count.toString());
      }
      if (options2?.GET) {
        if (Array.isArray(options2.GET)) {
          for (const pattern of options2.GET) {
            parser.push("GET", pattern);
          }
        } else {
          parser.push("GET", options2.GET);
        }
      }
      if (options2?.DIRECTION) {
        parser.push(options2.DIRECTION);
      }
      if (options2?.ALPHA) {
        parser.push("ALPHA");
      }
    }
    exports.parseSortArguments = parseSortArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the SORT command
       *
       * @param parser - The command parser
       * @param key - The key to sort (list, set, or sorted set)
       * @param options - Sort options
       * @see https://redis.io/commands/sort/
       */
      parseCommand(parser, key, options2) {
        parser.push("SORT");
        parseSortArguments(parser, key, options2);
      },
      transformReply: void 0
    };
  }
});
var require_SORT_RO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SORT_RO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SORT_1 = __importStar(require_SORT());
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Read-only variant of SORT that sorts the elements in a list, set or sorted set.
       * @param args - Same parameters as the SORT command.
       */
      parseCommand(...args) {
        const parser = args[0];
        parser.push("SORT_RO");
        (0, SORT_1.parseSortArguments)(...args);
      },
      transformReply: SORT_1.default.transformReply
    };
  }
});
var require_SORT_STORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SORT_STORE.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SORT_1 = __importDefault(require_SORT());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Sorts the elements in a list, set or sorted set and stores the result in a new list.
       * @param parser - The Redis command parser.
       * @param source - Key of the source list, set or sorted set.
       * @param destination - Destination key where the result will be stored.
       * @param options - Optional sorting parameters.
       */
      parseCommand(parser, source, destination, options2) {
        SORT_1.default.parseCommand(parser, source, options2);
        parser.push("STORE", destination);
      },
      transformReply: void 0
    };
  }
});
var require_SPOP_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SPOP_COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the SPOP command to remove and return multiple random members from a set
       *
       * @param parser - The command parser
       * @param key - The key of the set to pop from
       * @param count - The number of members to pop
       * @see https://redis.io/commands/spop/
       */
      parseCommand(parser, key, count) {
        parser.push("SPOP");
        parser.pushKey(key);
        parser.push(count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_SPOP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SPOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the SPOP command to remove and return a random member from a set
       *
       * @param parser - The command parser
       * @param key - The key of the set to pop from
       * @see https://redis.io/commands/spop/
       */
      parseCommand(parser, key) {
        parser.push("SPOP");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_SPUBLISH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SPUBLISH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the SPUBLISH command to post a message to a Sharded Pub/Sub channel
       *
       * @param parser - The command parser
       * @param channel - The channel to publish to
       * @param message - The message to publish
       * @see https://redis.io/commands/spublish/
       */
      parseCommand(parser, channel, message) {
        parser.push("SPUBLISH");
        parser.pushKey(channel);
        parser.push(message);
      },
      transformReply: void 0
    };
  }
});
var require_SRANDMEMBER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SRANDMEMBER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the SRANDMEMBER command to get a random member from a set
       *
       * @param parser - The command parser
       * @param key - The key of the set to get random member from
       * @see https://redis.io/commands/srandmember/
       */
      parseCommand(parser, key) {
        parser.push("SRANDMEMBER");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_SRANDMEMBER_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SRANDMEMBER_COUNT.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
    exports.default = {
      IS_READ_ONLY: SRANDMEMBER_1.default.IS_READ_ONLY,
      /**
       * Constructs the SRANDMEMBER command to get multiple random members from a set
       *
       * @param parser - The command parser
       * @param key - The key of the set to get random members from
       * @param count - The number of members to return. If negative, may return the same member multiple times
       * @see https://redis.io/commands/srandmember/
       */
      parseCommand(parser, key, count) {
        SRANDMEMBER_1.default.parseCommand(parser, key);
        parser.push(count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_SREM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SREM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the SREM command to remove one or more members from a set
       *
       * @param parser - The command parser
       * @param key - The key of the set to remove members from
       * @param members - One or more members to remove from the set
       * @returns The number of members that were removed from the set
       * @see https://redis.io/commands/srem/
       */
      parseCommand(parser, key, members) {
        parser.push("SREM");
        parser.pushKey(key);
        parser.pushVariadic(members);
      },
      transformReply: void 0
    };
  }
});
var require_SSCAN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SSCAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SCAN_1 = require_SCAN();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the SSCAN command to incrementally iterate over elements in a set
       *
       * @param parser - The command parser
       * @param key - The key of the set to scan
       * @param cursor - The cursor position to start scanning from
       * @param options - Optional scanning parameters (COUNT and MATCH)
       * @returns Iterator containing cursor position and matching members
       * @see https://redis.io/commands/sscan/
       */
      parseCommand(parser, key, cursor, options2) {
        parser.push("SSCAN");
        parser.pushKey(key);
        (0, SCAN_1.parseScanArguments)(parser, cursor, options2);
      },
      /**
       * Transforms the SSCAN reply into a cursor result object
       *
       * @param cursor - The next cursor position
       * @param members - Array of matching set members
       * @returns Object containing cursor and members array
       */
      transformReply([cursor, members]) {
        return {
          cursor,
          members
        };
      }
    };
  }
});
var require_STRLEN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/STRLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the STRLEN command to get the length of a string value
       *
       * @param parser - The command parser
       * @param key - The key holding the string value
       * @returns The length of the string value, or 0 when key does not exist
       * @see https://redis.io/commands/strlen/
       */
      parseCommand(parser, key) {
        parser.push("STRLEN");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_SUNION = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SUNION.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the SUNION command to return the members of the set resulting from the union of all the given sets
       *
       * @param parser - The command parser
       * @param keys - One or more set keys to compute the union from
       * @returns Array of all elements that are members of at least one of the given sets
       * @see https://redis.io/commands/sunion/
       */
      parseCommand(parser, keys) {
        parser.push("SUNION");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_SUNIONSTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SUNIONSTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the SUNIONSTORE command to store the union of multiple sets into a destination set
       *
       * @param parser - The command parser
       * @param destination - The destination key to store the resulting set
       * @param keys - One or more source set keys to compute the union from
       * @returns The number of elements in the resulting set
       * @see https://redis.io/commands/sunionstore/
       */
      parseCommand(parser, destination, keys) {
        parser.push("SUNIONSTORE");
        parser.pushKey(destination);
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_SWAPDB = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/SWAPDB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Swaps the data of two Redis databases.
       * @param parser - The Redis command parser.
       * @param index1 - First database index.
       * @param index2 - Second database index.
       */
      parseCommand(parser, index1, index2) {
        parser.push("SWAPDB", index1.toString(), index2.toString());
      },
      transformReply: void 0
    };
  }
});
var require_TIME = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/TIME.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the TIME command to return the server's current time
       *
       * @param parser - The command parser
       * @returns Array containing the Unix timestamp in seconds and microseconds
       * @see https://redis.io/commands/time/
       */
      parseCommand(parser) {
        parser.push("TIME");
      },
      transformReply: void 0
    };
  }
});
var require_TOUCH = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/TOUCH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the TOUCH command to alter the last access time of keys
       *
       * @param parser - The command parser
       * @param key - One or more keys to touch
       * @returns The number of keys that were touched
       * @see https://redis.io/commands/touch/
       */
      parseCommand(parser, key) {
        parser.push("TOUCH");
        parser.pushKeys(key);
      },
      transformReply: void 0
    };
  }
});
var require_TTL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/TTL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the TTL command to get the remaining time to live of a key
       *
       * @param parser - The command parser
       * @param key - Key to check
       * @returns Time to live in seconds, -2 if key does not exist, -1 if has no timeout
       * @see https://redis.io/commands/ttl/
       */
      parseCommand(parser, key) {
        parser.push("TTL");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_TYPE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/TYPE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the TYPE command to determine the data type stored at key
       *
       * @param parser - The command parser
       * @param key - Key to check
       * @returns String reply: "none", "string", "list", "set", "zset", "hash", "stream"
       * @see https://redis.io/commands/type/
       */
      parseCommand(parser, key) {
        parser.push("TYPE");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_UNLINK = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/UNLINK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the UNLINK command to asynchronously delete one or more keys
       *
       * @param parser - The command parser
       * @param keys - One or more keys to unlink
       * @returns The number of keys that were unlinked
       * @see https://redis.io/commands/unlink/
       */
      parseCommand(parser, keys) {
        parser.push("UNLINK");
        parser.pushKeys(keys);
      },
      transformReply: void 0
    };
  }
});
var require_WAIT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/WAIT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the WAIT command to synchronize with replicas
       *
       * @param parser - The command parser
       * @param numberOfReplicas - Number of replicas that must acknowledge the write
       * @param timeout - Maximum time to wait in milliseconds
       * @returns The number of replicas that acknowledged the write
       * @see https://redis.io/commands/wait/
       */
      parseCommand(parser, numberOfReplicas, timeout) {
        parser.push("WAIT", numberOfReplicas.toString(), timeout.toString());
      },
      transformReply: void 0
    };
  }
});
var require_XACK = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XACK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XACK command to acknowledge the processing of stream messages in a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - The consumer group name
       * @param id - One or more message IDs to acknowledge
       * @returns The number of messages successfully acknowledged
       * @see https://redis.io/commands/xack/
       */
      parseCommand(parser, key, group, id) {
        parser.push("XACK");
        parser.pushKey(key);
        parser.push(group);
        parser.pushVariadic(id);
      },
      transformReply: void 0
    };
  }
});
var require_XACKDEL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XACKDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XACKDEL command to acknowledge and delete one or multiple messages for a stream consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - The consumer group name
       * @param id - One or more message IDs to acknowledge and delete
       * @param policy - Policy to apply when deleting entries (optional, defaults to KEEPREF)
       * @returns Array of integers: -1 (not found), 1 (acknowledged and deleted), 2 (acknowledged with dangling refs)
       * @see https://redis.io/commands/xackdel/
       */
      parseCommand(parser, key, group, id, policy) {
        parser.push("XACKDEL");
        parser.pushKey(key);
        parser.push(group);
        if (policy) {
          parser.push(policy);
        }
        parser.push("IDS");
        parser.pushVariadicWithLength(id);
      },
      transformReply: void 0
    };
  }
});
var require_XADD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseXAddArguments = void 0;
    function parseXAddArguments(optional, parser, key, id, message, options2) {
      parser.push("XADD");
      parser.pushKey(key);
      if (optional) {
        parser.push(optional);
      }
      if (options2?.TRIM) {
        if (options2.TRIM.strategy) {
          parser.push(options2.TRIM.strategy);
        }
        if (options2.TRIM.strategyModifier) {
          parser.push(options2.TRIM.strategyModifier);
        }
        parser.push(options2.TRIM.threshold.toString());
        if (options2.TRIM.limit) {
          parser.push("LIMIT", options2.TRIM.limit.toString());
        }
        if (options2.TRIM.policy) {
          parser.push(options2.TRIM.policy);
        }
      }
      parser.push(id);
      for (const [key2, value] of Object.entries(message)) {
        parser.push(key2, value);
      }
    }
    exports.parseXAddArguments = parseXAddArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XADD command to append a new entry to a stream
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param id - Message ID (* for auto-generation)
       * @param message - Key-value pairs representing the message fields
       * @param options - Additional options for stream trimming
       * @returns The ID of the added entry
       * @see https://redis.io/commands/xadd/
       */
      parseCommand(...args) {
        return parseXAddArguments(void 0, ...args);
      },
      transformReply: void 0
    };
  }
});
var require_XADD_NOMKSTREAM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XADD_NOMKSTREAM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var XADD_1 = require_XADD();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XADD command with NOMKSTREAM option to append a new entry to an existing stream
       *
       * @param args - Arguments tuple containing parser, key, id, message, and options
       * @returns The ID of the added entry, or null if the stream doesn't exist
       * @see https://redis.io/commands/xadd/
       */
      parseCommand(...args) {
        return (0, XADD_1.parseXAddArguments)("NOMKSTREAM", ...args);
      },
      transformReply: void 0
    };
  }
});
var require_XAUTOCLAIM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XAUTOCLAIM command to automatically claim pending messages in a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - The consumer group name
       * @param consumer - The consumer name that will claim the messages
       * @param minIdleTime - Minimum idle time in milliseconds for a message to be claimed
       * @param start - Message ID to start scanning from
       * @param options - Additional options for the claim operation
       * @returns Object containing nextId, claimed messages, and list of deleted message IDs
       * @see https://redis.io/commands/xautoclaim/
       */
      parseCommand(parser, key, group, consumer, minIdleTime, start, options2) {
        parser.push("XAUTOCLAIM");
        parser.pushKey(key);
        parser.push(group, consumer, minIdleTime.toString(), start);
        if (options2?.COUNT) {
          parser.push("COUNT", options2.COUNT.toString());
        }
      },
      /**
       * Transforms the raw XAUTOCLAIM reply into a structured object
       *
       * @param reply - Raw reply from Redis
       * @param preserve - Preserve options (unused)
       * @param typeMapping - Type mapping for message fields
       * @returns Structured object containing nextId, messages, and deletedMessages
       */
      transformReply(reply, preserve, typeMapping) {
        return {
          nextId: reply[0],
          messages: reply[1].map(generic_transformers_1.transformStreamMessageNullReply.bind(void 0, typeMapping)),
          deletedMessages: reply[2]
        };
      }
    };
  }
});
var require_XAUTOCLAIM_JUSTID = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM_JUSTID.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
    exports.default = {
      IS_READ_ONLY: XAUTOCLAIM_1.default.IS_READ_ONLY,
      /**
       * Constructs the XAUTOCLAIM command with JUSTID option to get only message IDs
       *
       * @param args - Same parameters as XAUTOCLAIM command
       * @returns Object containing nextId and arrays of claimed and deleted message IDs
       * @see https://redis.io/commands/xautoclaim/
       */
      parseCommand(...args) {
        const parser = args[0];
        XAUTOCLAIM_1.default.parseCommand(...args);
        parser.push("JUSTID");
      },
      /**
       * Transforms the raw XAUTOCLAIM JUSTID reply into a structured object
       *
       * @param reply - Raw reply from Redis
       * @returns Structured object containing nextId, message IDs, and deleted message IDs
       */
      transformReply(reply) {
        return {
          nextId: reply[0],
          messages: reply[1],
          deletedMessages: reply[2]
        };
      }
    };
  }
});
var require_XCLAIM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XCLAIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XCLAIM command to claim pending messages in a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - The consumer group name
       * @param consumer - The consumer name that will claim the messages
       * @param minIdleTime - Minimum idle time in milliseconds for a message to be claimed
       * @param id - One or more message IDs to claim
       * @param options - Additional options for the claim operation
       * @returns Array of claimed messages
       * @see https://redis.io/commands/xclaim/
       */
      parseCommand(parser, key, group, consumer, minIdleTime, id, options2) {
        parser.push("XCLAIM");
        parser.pushKey(key);
        parser.push(group, consumer, minIdleTime.toString());
        parser.pushVariadic(id);
        if (options2?.IDLE !== void 0) {
          parser.push("IDLE", options2.IDLE.toString());
        }
        if (options2?.TIME !== void 0) {
          parser.push("TIME", (options2.TIME instanceof Date ? options2.TIME.getTime() : options2.TIME).toString());
        }
        if (options2?.RETRYCOUNT !== void 0) {
          parser.push("RETRYCOUNT", options2.RETRYCOUNT.toString());
        }
        if (options2?.FORCE) {
          parser.push("FORCE");
        }
        if (options2?.LASTID !== void 0) {
          parser.push("LASTID", options2.LASTID);
        }
      },
      /**
       * Transforms the raw XCLAIM reply into an array of messages
       *
       * @param reply - Raw reply from Redis
       * @param preserve - Preserve options (unused)
       * @param typeMapping - Type mapping for message fields
       * @returns Array of claimed messages with their fields
       */
      transformReply(reply, preserve, typeMapping) {
        return reply.map(generic_transformers_1.transformStreamMessageNullReply.bind(void 0, typeMapping));
      }
    };
  }
});
var require_XCLAIM_JUSTID = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XCLAIM_JUSTID.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var XCLAIM_1 = __importDefault(require_XCLAIM());
    exports.default = {
      IS_READ_ONLY: XCLAIM_1.default.IS_READ_ONLY,
      /**
       * Constructs the XCLAIM command with JUSTID option to get only message IDs
       *
       * @param args - Same parameters as XCLAIM command
       * @returns Array of successfully claimed message IDs
       * @see https://redis.io/commands/xclaim/
       */
      parseCommand(...args) {
        const parser = args[0];
        XCLAIM_1.default.parseCommand(...args);
        parser.push("JUSTID");
      },
      /**
       * Transforms the XCLAIM JUSTID reply into an array of message IDs
       *
       * @returns Array of claimed message IDs
       */
      transformReply: void 0
    };
  }
});
var require_XDEL = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XDEL command to remove one or more messages from a stream
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param id - One or more message IDs to delete
       * @returns The number of messages actually deleted
       * @see https://redis.io/commands/xdel/
       */
      parseCommand(parser, key, id) {
        parser.push("XDEL");
        parser.pushKey(key);
        parser.pushVariadic(id);
      },
      transformReply: void 0
    };
  }
});
var require_XDELEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XDELEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XDELEX command to delete one or multiple entries from the stream
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param id - One or more message IDs to delete
       * @param policy - Policy to apply when deleting entries (optional, defaults to KEEPREF)
       * @returns Array of integers: -1 (not found), 1 (deleted), 2 (dangling refs)
       * @see https://redis.io/commands/xdelex/
       */
      parseCommand(parser, key, id, policy) {
        parser.push("XDELEX");
        parser.pushKey(key);
        if (policy) {
          parser.push(policy);
        }
        parser.push("IDS");
        parser.pushVariadicWithLength(id);
      },
      transformReply: void 0
    };
  }
});
var require_XGROUP_CREATE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XGROUP_CREATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XGROUP CREATE command to create a consumer group for a stream
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group
       * @param id - ID of the last delivered item in the stream ('$' for last item, '0' for all items)
       * @param options - Additional options for group creation
       * @returns 'OK' if successful
       * @see https://redis.io/commands/xgroup-create/
       */
      parseCommand(parser, key, group, id, options2) {
        parser.push("XGROUP", "CREATE");
        parser.pushKey(key);
        parser.push(group, id);
        if (options2?.MKSTREAM) {
          parser.push("MKSTREAM");
        }
        if (options2?.ENTRIESREAD) {
          parser.push("ENTRIESREAD", options2.ENTRIESREAD.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_XGROUP_CREATECONSUMER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XGROUP_CREATECONSUMER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XGROUP CREATECONSUMER command to create a new consumer in a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group
       * @param consumer - Name of the consumer to create
       * @returns 1 if the consumer was created, 0 if it already existed
       * @see https://redis.io/commands/xgroup-createconsumer/
       */
      parseCommand(parser, key, group, consumer) {
        parser.push("XGROUP", "CREATECONSUMER");
        parser.pushKey(key);
        parser.push(group, consumer);
      },
      transformReply: void 0
    };
  }
});
var require_XGROUP_DELCONSUMER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XGROUP_DELCONSUMER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XGROUP DELCONSUMER command to remove a consumer from a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group
       * @param consumer - Name of the consumer to remove
       * @returns The number of pending messages owned by the deleted consumer
       * @see https://redis.io/commands/xgroup-delconsumer/
       */
      parseCommand(parser, key, group, consumer) {
        parser.push("XGROUP", "DELCONSUMER");
        parser.pushKey(key);
        parser.push(group, consumer);
      },
      transformReply: void 0
    };
  }
});
var require_XGROUP_DESTROY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XGROUP_DESTROY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XGROUP DESTROY command to remove a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group to destroy
       * @returns 1 if the group was destroyed, 0 if it did not exist
       * @see https://redis.io/commands/xgroup-destroy/
       */
      parseCommand(parser, key, group) {
        parser.push("XGROUP", "DESTROY");
        parser.pushKey(key);
        parser.push(group);
      },
      transformReply: void 0
    };
  }
});
var require_XGROUP_SETID = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XGROUP_SETID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XGROUP SETID command to set the last delivered ID for a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group
       * @param id - ID to set as last delivered message ('$' for last item, '0' for all items)
       * @param options - Additional options for setting the group ID
       * @returns 'OK' if successful
       * @see https://redis.io/commands/xgroup-setid/
       */
      parseCommand(parser, key, group, id, options2) {
        parser.push("XGROUP", "SETID");
        parser.pushKey(key);
        parser.push(group, id);
        if (options2?.ENTRIESREAD) {
          parser.push("ENTRIESREAD", options2.ENTRIESREAD.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_XINFO_CONSUMERS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XINFO_CONSUMERS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the XINFO CONSUMERS command to list the consumers in a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group
       * @returns Array of consumer information objects
       * @see https://redis.io/commands/xinfo-consumers/
       */
      parseCommand(parser, key, group) {
        parser.push("XINFO", "CONSUMERS");
        parser.pushKey(key);
        parser.push(group);
      },
      transformReply: {
        /**
         * Transforms RESP2 reply into a structured consumer information array
         *
         * @param reply - Raw RESP2 reply from Redis
         * @returns Array of consumer information objects
         */
        2: (reply) => {
          return reply.map((consumer) => {
            const unwrapped = consumer;
            return {
              name: unwrapped[1],
              pending: unwrapped[3],
              idle: unwrapped[5],
              inactive: unwrapped[7]
            };
          });
        },
        3: void 0
      }
    };
  }
});
var require_XINFO_GROUPS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XINFO_GROUPS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the XINFO GROUPS command to list the consumer groups of a stream
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @returns Array of consumer group information objects
       * @see https://redis.io/commands/xinfo-groups/
       */
      parseCommand(parser, key) {
        parser.push("XINFO", "GROUPS");
        parser.pushKey(key);
      },
      transformReply: {
        /**
         * Transforms RESP2 reply into a structured consumer group information array
         *
         * @param reply - Raw RESP2 reply from Redis
         * @returns Array of consumer group information objects containing:
         *          name - Name of the consumer group
         *          consumers - Number of consumers in the group
         *          pending - Number of pending messages for the group
         *          last-delivered-id - ID of the last delivered message
         *          entries-read - Number of entries read in the group (Redis 7.0+)
         *          lag - Number of entries not read by the group (Redis 7.0+)
         */
        2: (reply) => {
          return reply.map((group) => {
            const unwrapped = group;
            return {
              name: unwrapped[1],
              consumers: unwrapped[3],
              pending: unwrapped[5],
              "last-delivered-id": unwrapped[7],
              "entries-read": unwrapped[9],
              lag: unwrapped[11]
            };
          });
        },
        3: void 0
      }
    };
  }
});
var require_XINFO_STREAM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XINFO_STREAM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the XINFO STREAM command to get detailed information about a stream
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @returns Detailed information about the stream including its length, structure, and entries
       * @see https://redis.io/commands/xinfo-stream/
       */
      parseCommand(parser, key) {
        parser.push("XINFO", "STREAM");
        parser.pushKey(key);
      },
      transformReply: {
        // TODO: is there a "type safe" way to do it?
        2(reply) {
          const parsedReply = {};
          for (let i2 = 0; i2 < reply.length; i2 += 2) {
            switch (reply[i2]) {
              case "first-entry":
              case "last-entry":
                parsedReply[reply[i2]] = transformEntry(reply[i2 + 1]);
                break;
              default:
                parsedReply[reply[i2]] = reply[i2 + 1];
                break;
            }
          }
          return parsedReply;
        },
        3(reply) {
          if (reply instanceof Map) {
            reply.set("first-entry", transformEntry(reply.get("first-entry")));
            reply.set("last-entry", transformEntry(reply.get("last-entry")));
          } else if (reply instanceof Array) {
            reply[17] = transformEntry(reply[17]);
            reply[19] = transformEntry(reply[19]);
          } else {
            reply["first-entry"] = transformEntry(reply["first-entry"]);
            reply["last-entry"] = transformEntry(reply["last-entry"]);
          }
          return reply;
        }
      }
    };
    function transformEntry(entry) {
      if ((0, generic_transformers_1.isNullReply)(entry))
        return entry;
      const [id, message] = entry;
      return {
        id,
        message: (0, generic_transformers_1.transformTuplesReply)(message)
      };
    }
  }
});
var require_XLEN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the XLEN command to get the number of entries in a stream
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @returns The number of entries inside the stream
       * @see https://redis.io/commands/xlen/
       */
      parseCommand(parser, key) {
        parser.push("XLEN");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_XPENDING_RANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XPENDING_RANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the XPENDING command with range parameters to get detailed information about pending messages
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group
       * @param start - Start of ID range (use '-' for minimum ID)
       * @param end - End of ID range (use '+' for maximum ID)
       * @param count - Maximum number of messages to return
       * @param options - Additional filtering options
       * @returns Array of pending message details
       * @see https://redis.io/commands/xpending/
       */
      parseCommand(parser, key, group, start, end, count, options2) {
        parser.push("XPENDING");
        parser.pushKey(key);
        parser.push(group);
        if (options2?.IDLE !== void 0) {
          parser.push("IDLE", options2.IDLE.toString());
        }
        parser.push(start, end, count.toString());
        if (options2?.consumer) {
          parser.push(options2.consumer);
        }
      },
      /**
       * Transforms the raw XPENDING RANGE reply into a structured array of message details
       *
       * @param reply - Raw reply from Redis
       * @returns Array of objects containing message ID, consumer, idle time, and delivery count
       */
      transformReply(reply) {
        return reply.map((pending) => {
          const unwrapped = pending;
          return {
            id: unwrapped[0],
            consumer: unwrapped[1],
            millisecondsSinceLastDelivery: unwrapped[2],
            deliveriesCounter: unwrapped[3]
          };
        });
      }
    };
  }
});
var require_XPENDING = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XPENDING.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the XPENDING command to inspect pending messages of a consumer group
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param group - Name of the consumer group
       * @returns Summary of pending messages including total count, ID range, and per-consumer stats
       * @see https://redis.io/commands/xpending/
       */
      parseCommand(parser, key, group) {
        parser.push("XPENDING");
        parser.pushKey(key);
        parser.push(group);
      },
      /**
       * Transforms the raw XPENDING reply into a structured object
       *
       * @param reply - Raw reply from Redis
       * @returns Object containing pending count, ID range, and consumer statistics
       */
      transformReply(reply) {
        const consumers = reply[3];
        return {
          pending: reply[0],
          firstId: reply[1],
          lastId: reply[2],
          consumers: consumers === null ? null : consumers.map((consumer) => {
            const [name, deliveriesCounter] = consumer;
            return {
              name,
              deliveriesCounter: Number(deliveriesCounter)
            };
          })
        };
      }
    };
  }
});
var require_XRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xRangeArguments = void 0;
    var generic_transformers_1 = require_generic_transformers();
    function xRangeArguments(start, end, options2) {
      const args = [start, end];
      if (options2?.COUNT) {
        args.push("COUNT", options2.COUNT.toString());
      }
      return args;
    }
    exports.xRangeArguments = xRangeArguments;
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the XRANGE command to read stream entries in a specific range
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param args - Arguments tuple containing start ID, end ID, and options
       * @returns Array of messages in the specified range
       * @see https://redis.io/commands/xrange/
       */
      parseCommand(parser, key, ...args) {
        parser.push("XRANGE");
        parser.pushKey(key);
        parser.pushVariadic(xRangeArguments(args[0], args[1], args[2]));
      },
      /**
       * Transforms the raw XRANGE reply into structured message objects
       *
       * @param reply - Raw reply from Redis
       * @param preserve - Preserve options (unused)
       * @param typeMapping - Type mapping for message fields
       * @returns Array of structured message objects
       */
      transformReply(reply, preserve, typeMapping) {
        return reply.map(generic_transformers_1.transformStreamMessageReply.bind(void 0, typeMapping));
      }
    };
  }
});
var require_XREAD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XREAD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pushXReadStreams = void 0;
    var generic_transformers_1 = require_generic_transformers();
    function pushXReadStreams(parser, streams) {
      parser.push("STREAMS");
      if (Array.isArray(streams)) {
        for (let i2 = 0; i2 < streams.length; i2++) {
          parser.pushKey(streams[i2].key);
        }
        for (let i2 = 0; i2 < streams.length; i2++) {
          parser.push(streams[i2].id);
        }
      } else {
        parser.pushKey(streams.key);
        parser.push(streams.id);
      }
    }
    exports.pushXReadStreams = pushXReadStreams;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the XREAD command to read messages from one or more streams
       *
       * @param parser - The command parser
       * @param streams - Single stream or array of streams to read from
       * @param options - Additional options for reading streams
       * @returns Array of stream entries, each containing the stream name and its messages
       * @see https://redis.io/commands/xread/
       */
      parseCommand(parser, streams, options2) {
        parser.push("XREAD");
        if (options2?.COUNT) {
          parser.push("COUNT", options2.COUNT.toString());
        }
        if (options2?.BLOCK !== void 0) {
          parser.push("BLOCK", options2.BLOCK.toString());
        }
        pushXReadStreams(parser, streams);
      },
      /**
       * Transform functions for different RESP versions
       */
      transformReply: {
        2: generic_transformers_1.transformStreamsMessagesReplyResp2,
        3: void 0
      },
      unstableResp3: true
    };
  }
});
var require_XREADGROUP = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XREADGROUP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var XREAD_1 = require_XREAD();
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Constructs the XREADGROUP command to read messages from streams as a consumer group member
       *
       * @param parser - The command parser
       * @param group - Name of the consumer group
       * @param consumer - Name of the consumer in the group
       * @param streams - Single stream or array of streams to read from
       * @param options - Additional options for reading streams
       * @returns Array of stream entries, each containing the stream name and its messages
       * @see https://redis.io/commands/xreadgroup/
       */
      parseCommand(parser, group, consumer, streams, options2) {
        parser.push("XREADGROUP", "GROUP", group, consumer);
        if (options2?.COUNT !== void 0) {
          parser.push("COUNT", options2.COUNT.toString());
        }
        if (options2?.BLOCK !== void 0) {
          parser.push("BLOCK", options2.BLOCK.toString());
        }
        if (options2?.NOACK) {
          parser.push("NOACK");
        }
        (0, XREAD_1.pushXReadStreams)(parser, streams);
      },
      /**
       * Transform functions for different RESP versions
       */
      transformReply: {
        2: generic_transformers_1.transformStreamsMessagesReplyResp2,
        3: void 0
      },
      unstableResp3: true
    };
  }
});
var require_XREVRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XREVRANGE.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var XRANGE_1 = __importStar(require_XRANGE());
    exports.default = {
      CACHEABLE: XRANGE_1.default.CACHEABLE,
      IS_READ_ONLY: XRANGE_1.default.IS_READ_ONLY,
      /**
       * Constructs the XREVRANGE command to read stream entries in reverse order
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param args - Arguments tuple containing start ID, end ID, and options
       * @returns Array of messages in the specified range in reverse order
       * @see https://redis.io/commands/xrevrange/
       */
      parseCommand(parser, key, ...args) {
        parser.push("XREVRANGE");
        parser.pushKey(key);
        parser.pushVariadic((0, XRANGE_1.xRangeArguments)(args[0], args[1], args[2]));
      },
      transformReply: XRANGE_1.default.transformReply
    };
  }
});
var require_XSETID = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XSETID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      parseCommand(parser, key, lastId, options2) {
        parser.push("XSETID");
        parser.pushKey(key);
        parser.push(lastId);
        if (options2?.ENTRIESADDED) {
          parser.push("ENTRIESADDED", options2.ENTRIESADDED.toString());
        }
        if (options2?.MAXDELETEDID) {
          parser.push("MAXDELETEDID", options2.MAXDELETEDID);
        }
      },
      transformReply: void 0
    };
  }
});
var require_XTRIM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/XTRIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Constructs the XTRIM command to trim a stream by length or minimum ID
       *
       * @param parser - The command parser
       * @param key - The stream key
       * @param strategy - Trim by maximum length (MAXLEN) or minimum ID (MINID)
       * @param threshold - Maximum length or minimum ID threshold
       * @param options - Additional options for trimming
       * @returns Number of entries removed from the stream
       * @see https://redis.io/commands/xtrim/
       */
      parseCommand(parser, key, strategy, threshold, options2) {
        parser.push("XTRIM");
        parser.pushKey(key);
        parser.push(strategy);
        if (options2?.strategyModifier) {
          parser.push(options2.strategyModifier);
        }
        parser.push(threshold.toString());
        if (options2?.LIMIT) {
          parser.push("LIMIT", options2.LIMIT.toString());
        }
        if (options2?.policy) {
          parser.push(options2.policy);
        }
      },
      transformReply: void 0
    };
  }
});
var require_ZADD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pushMembers = void 0;
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Constructs the ZADD command to add one or more members to a sorted set
       *
       * @param parser - The command parser
       * @param key - The sorted set key
       * @param members - One or more members to add with their scores
       * @param options - Additional options for adding members
       * @returns Number of new members added (or changed members if CH is set)
       * @see https://redis.io/commands/zadd/
       */
      parseCommand(parser, key, members, options2) {
        parser.push("ZADD");
        parser.pushKey(key);
        if (options2?.condition) {
          parser.push(options2.condition);
        } else if (options2?.NX) {
          parser.push("NX");
        } else if (options2?.XX) {
          parser.push("XX");
        }
        if (options2?.comparison) {
          parser.push(options2.comparison);
        } else if (options2?.LT) {
          parser.push("LT");
        } else if (options2?.GT) {
          parser.push("GT");
        }
        if (options2?.CH) {
          parser.push("CH");
        }
        pushMembers(parser, members);
      },
      transformReply: generic_transformers_1.transformDoubleReply
    };
    function pushMembers(parser, members) {
      if (Array.isArray(members)) {
        for (const member of members) {
          pushMember(parser, member);
        }
      } else {
        pushMember(parser, members);
      }
    }
    exports.pushMembers = pushMembers;
    function pushMember(parser, member) {
      parser.push((0, generic_transformers_1.transformDoubleArgument)(member.score), member.value);
    }
  }
});
var require_ZADD_INCR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZADD_INCR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZADD_1 = require_ZADD();
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Constructs the ZADD command with INCR option to increment the score of a member
       *
       * @param parser - The command parser
       * @param key - The sorted set key
       * @param members - Member(s) whose score to increment
       * @param options - Additional options for the increment operation
       * @returns The new score of the member after increment (null if member does not exist with XX option)
       * @see https://redis.io/commands/zadd/
       */
      parseCommand(parser, key, members, options2) {
        parser.push("ZADD");
        parser.pushKey(key);
        if (options2?.condition) {
          parser.push(options2.condition);
        }
        if (options2?.comparison) {
          parser.push(options2.comparison);
        }
        if (options2?.CH) {
          parser.push("CH");
        }
        parser.push("INCR");
        (0, ZADD_1.pushMembers)(parser, members);
      },
      transformReply: generic_transformers_1.transformNullableDoubleReply
    };
  }
});
var require_ZCARD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZCARD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Constructs the ZCARD command to get the cardinality (number of members) of a sorted set
       *
       * @param parser - The command parser
       * @param key - The sorted set key
       * @returns Number of members in the sorted set
       * @see https://redis.io/commands/zcard/
       */
      parseCommand(parser, key) {
        parser.push("ZCARD");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_ZCOUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZCOUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the number of elements in the sorted set with a score between min and max.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param min - Minimum score to count from (inclusive).
       * @param max - Maximum score to count to (inclusive).
       */
      parseCommand(parser, key, min, max) {
        parser.push("ZCOUNT");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      },
      transformReply: void 0
    };
  }
});
var require_ZDIFF = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZDIFF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the difference between the first sorted set and all the successive sorted sets.
       * @param parser - The Redis command parser.
       * @param keys - Keys of the sorted sets.
       */
      parseCommand(parser, keys) {
        parser.push("ZDIFF");
        parser.pushKeysLength(keys);
      },
      transformReply: void 0
    };
  }
});
var require_ZDIFF_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZDIFF_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var ZDIFF_1 = __importDefault(require_ZDIFF());
    exports.default = {
      IS_READ_ONLY: ZDIFF_1.default.IS_READ_ONLY,
      /**
       * Returns the difference between the first sorted set and all successive sorted sets with their scores.
       * @param parser - The Redis command parser.
       * @param keys - Keys of the sorted sets.
       */
      parseCommand(parser, keys) {
        ZDIFF_1.default.parseCommand(parser, keys);
        parser.push("WITHSCORES");
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZDIFFSTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZDIFFSTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Computes the difference between the first and all successive sorted sets and stores it in a new key.
       * @param parser - The Redis command parser.
       * @param destination - Destination key where the result will be stored.
       * @param inputKeys - Keys of the sorted sets to find the difference between.
       */
      parseCommand(parser, destination, inputKeys) {
        parser.push("ZDIFFSTORE");
        parser.pushKey(destination);
        parser.pushKeysLength(inputKeys);
      },
      transformReply: void 0
    };
  }
});
var require_ZINCRBY = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZINCRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Increments the score of a member in a sorted set by the specified increment.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param increment - Value to increment the score by.
       * @param member - Member whose score should be incremented.
       */
      parseCommand(parser, key, increment, member) {
        parser.push("ZINCRBY");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformDoubleArgument)(increment), member);
      },
      transformReply: generic_transformers_1.transformDoubleReply
    };
  }
});
var require_ZINTER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZINTER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseZInterArguments = void 0;
    var generic_transformers_1 = require_generic_transformers();
    function parseZInterArguments(parser, keys, options2) {
      (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
      if (options2?.AGGREGATE) {
        parser.push("AGGREGATE", options2.AGGREGATE);
      }
    }
    exports.parseZInterArguments = parseZInterArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Intersects multiple sorted sets and returns the result as a new sorted set.
       * @param parser - The Redis command parser.
       * @param keys - Keys of the sorted sets to intersect.
       * @param options - Optional parameters for the intersection operation.
       */
      parseCommand(parser, keys, options2) {
        parser.push("ZINTER");
        parseZInterArguments(parser, keys, options2);
      },
      transformReply: void 0
    };
  }
});
var require_ZINTER_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZINTER_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var ZINTER_1 = __importDefault(require_ZINTER());
    exports.default = {
      IS_READ_ONLY: ZINTER_1.default.IS_READ_ONLY,
      /**
       * Intersects multiple sorted sets and returns the result with scores.
       * @param args - Same parameters as ZINTER command.
       */
      parseCommand(...args) {
        ZINTER_1.default.parseCommand(...args);
        args[0].push("WITHSCORES");
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZINTERCARD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZINTERCARD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the cardinality of the intersection of multiple sorted sets.
       * @param parser - The Redis command parser.
       * @param keys - Keys of the sorted sets to intersect.
       * @param options - Limit option or options object with limit.
       */
      parseCommand(parser, keys, options2) {
        parser.push("ZINTERCARD");
        parser.pushKeysLength(keys);
        if (typeof options2 === "number") {
          parser.push("LIMIT", options2.toString());
        } else if (options2?.LIMIT) {
          parser.push("LIMIT", options2.LIMIT.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_ZINTERSTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZINTERSTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZINTER_1 = require_ZINTER();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Stores the result of intersection of multiple sorted sets in a new sorted set.
       * @param parser - The Redis command parser.
       * @param destination - Destination key where the result will be stored.
       * @param keys - Keys of the sorted sets to intersect.
       * @param options - Optional parameters for the intersection operation.
       */
      parseCommand(parser, destination, keys, options2) {
        parser.push("ZINTERSTORE");
        parser.pushKey(destination);
        (0, ZINTER_1.parseZInterArguments)(parser, keys, options2);
      },
      transformReply: void 0
    };
  }
});
var require_ZLEXCOUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZLEXCOUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the number of elements in the sorted set between the lexicographical range specified by min and max.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param min - Minimum lexicographical value (inclusive).
       * @param max - Maximum lexicographical value (inclusive).
       */
      parseCommand(parser, key, min, max) {
        parser.push("ZLEXCOUNT");
        parser.pushKey(key);
        parser.push(min);
        parser.push(max);
      },
      transformReply: void 0
    };
  }
});
var require_ZMSCORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZMSCORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the scores associated with the specified members in the sorted set stored at key.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param member - One or more members to get scores for.
       */
      parseCommand(parser, key, member) {
        parser.push("ZMSCORE");
        parser.pushKey(key);
        parser.pushVariadic(member);
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          return reply.map((0, generic_transformers_1.createTransformNullableDoubleReplyResp2Func)(preserve, typeMapping));
        },
        3: void 0
      }
    };
  }
});
var require_ZPOPMAX_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZPOPMAX_COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns up to count members with the highest scores in the sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param count - Number of members to pop.
       */
      parseCommand(parser, key, count) {
        parser.push("ZPOPMAX");
        parser.pushKey(key);
        parser.push(count.toString());
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZPOPMAX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZPOPMAX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns the member with the highest score in the sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       */
      parseCommand(parser, key) {
        parser.push("ZPOPMAX");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          if (reply.length === 0)
            return null;
          return {
            value: reply[0],
            score: generic_transformers_1.transformDoubleReply[2](reply[1], preserve, typeMapping)
          };
        },
        3: (reply) => {
          if (reply.length === 0)
            return null;
          return {
            value: reply[0],
            score: reply[1]
          };
        }
      }
    };
  }
});
var require_ZPOPMIN_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZPOPMIN_COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns up to count members with the lowest scores in the sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param count - Number of members to pop.
       */
      parseCommand(parser, key, count) {
        parser.push("ZPOPMIN");
        parser.pushKey(key);
        parser.push(count.toString());
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZPOPMIN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZPOPMIN.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns the member with the lowest score in the sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       */
      parseCommand(parser, key) {
        parser.push("ZPOPMIN");
        parser.pushKey(key);
      },
      transformReply: ZPOPMAX_1.default.transformReply
    };
  }
});
var require_ZRANDMEMBER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns a random member from a sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       */
      parseCommand(parser, key) {
        parser.push("ZRANDMEMBER");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_ZRANDMEMBER_COUNT = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
    exports.default = {
      IS_READ_ONLY: ZRANDMEMBER_1.default.IS_READ_ONLY,
      /**
       * Returns one or more random members from a sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param count - Number of members to return.
       */
      parseCommand(parser, key, count) {
        ZRANDMEMBER_1.default.parseCommand(parser, key);
        parser.push(count.toString());
      },
      transformReply: void 0
    };
  }
});
var require_ZRANDMEMBER_COUNT_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
    exports.default = {
      IS_READ_ONLY: ZRANDMEMBER_COUNT_1.default.IS_READ_ONLY,
      /**
       * Returns one or more random members with their scores from a sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param count - Number of members to return.
       */
      parseCommand(parser, key, count) {
        ZRANDMEMBER_COUNT_1.default.parseCommand(parser, key, count);
        parser.push("WITHSCORES");
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZRANGE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zRangeArgument = void 0;
    var generic_transformers_1 = require_generic_transformers();
    function zRangeArgument(min, max, options2) {
      const args = [
        (0, generic_transformers_1.transformStringDoubleArgument)(min),
        (0, generic_transformers_1.transformStringDoubleArgument)(max)
      ];
      switch (options2?.BY) {
        case "SCORE":
          args.push("BYSCORE");
          break;
        case "LEX":
          args.push("BYLEX");
          break;
      }
      if (options2?.REV) {
        args.push("REV");
      }
      if (options2?.LIMIT) {
        args.push("LIMIT", options2.LIMIT.offset.toString(), options2.LIMIT.count.toString());
      }
      return args;
    }
    exports.zRangeArgument = zRangeArgument;
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the specified range of elements in the sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param min - Minimum index, score or lexicographical value.
       * @param max - Maximum index, score or lexicographical value.
       * @param options - Optional parameters for range retrieval (BY, REV, LIMIT).
       */
      parseCommand(parser, key, min, max, options2) {
        parser.push("ZRANGE");
        parser.pushKey(key);
        parser.pushVariadic(zRangeArgument(min, max, options2));
      },
      transformReply: void 0
    };
  }
});
var require_ZRANGE_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANGE_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var ZRANGE_1 = __importDefault(require_ZRANGE());
    exports.default = {
      CACHEABLE: ZRANGE_1.default.CACHEABLE,
      IS_READ_ONLY: ZRANGE_1.default.IS_READ_ONLY,
      /**
       * Returns the specified range of elements in the sorted set with their scores.
       * @param args - Same parameters as the ZRANGE command.
       */
      parseCommand(...args) {
        const parser = args[0];
        ZRANGE_1.default.parseCommand(...args);
        parser.push("WITHSCORES");
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZRANGEBYLEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANGEBYLEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns all the elements in the sorted set at key with a lexicographical value between min and max.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param min - Minimum lexicographical value.
       * @param max - Maximum lexicographical value.
       * @param options - Optional parameters including LIMIT.
       */
      parseCommand(parser, key, min, max, options2) {
        parser.push("ZRANGEBYLEX");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
        if (options2?.LIMIT) {
          parser.push("LIMIT", options2.LIMIT.offset.toString(), options2.LIMIT.count.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_ZRANGEBYSCORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns all the elements in the sorted set with a score between min and max.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param min - Minimum score.
       * @param max - Maximum score.
       * @param options - Optional parameters including LIMIT.
       */
      parseCommand(parser, key, min, max, options2) {
        parser.push("ZRANGEBYSCORE");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
        if (options2?.LIMIT) {
          parser.push("LIMIT", options2.LIMIT.offset.toString(), options2.LIMIT.count.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_ZRANGEBYSCORE_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
    exports.default = {
      CACHEABLE: ZRANGEBYSCORE_1.default.CACHEABLE,
      IS_READ_ONLY: ZRANGEBYSCORE_1.default.IS_READ_ONLY,
      /**
       * Returns all the elements in the sorted set with a score between min and max, with their scores.
       * @param args - Same parameters as the ZRANGEBYSCORE command.
       */
      parseCommand(...args) {
        const parser = args[0];
        ZRANGEBYSCORE_1.default.parseCommand(...args);
        parser.push("WITHSCORES");
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZRANGESTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANGESTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Stores the result of a range operation on a sorted set into a new sorted set.
       * @param parser - The Redis command parser.
       * @param destination - Destination key where the result will be stored.
       * @param source - Key of the source sorted set.
       * @param min - Minimum index, score or lexicographical value.
       * @param max - Maximum index, score or lexicographical value.
       * @param options - Optional parameters for the range operation (BY, REV, LIMIT).
       */
      parseCommand(parser, destination, source, min, max, options2) {
        parser.push("ZRANGESTORE");
        parser.pushKey(destination);
        parser.pushKey(source);
        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
        switch (options2?.BY) {
          case "SCORE":
            parser.push("BYSCORE");
            break;
          case "LEX":
            parser.push("BYLEX");
            break;
        }
        if (options2?.REV) {
          parser.push("REV");
        }
        if (options2?.LIMIT) {
          parser.push("LIMIT", options2.LIMIT.offset.toString(), options2.LIMIT.count.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_ZREMRANGEBYSCORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYSCORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes all elements in the sorted set with scores between min and max.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param min - Minimum score.
       * @param max - Maximum score.
       */
      parseCommand(parser, key, min, max) {
        parser.push("ZREMRANGEBYSCORE");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      },
      transformReply: void 0
    };
  }
});
var require_ZRANK = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the rank of a member in the sorted set, with scores ordered from low to high.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param member - Member to get the rank for.
       */
      parseCommand(parser, key, member) {
        parser.push("ZRANK");
        parser.pushKey(key);
        parser.push(member);
      },
      transformReply: void 0
    };
  }
});
var require_ZRANK_WITHSCORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZRANK_WITHSCORE.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZRANK_1 = __importDefault(require_ZRANK());
    exports.default = {
      CACHEABLE: ZRANK_1.default.CACHEABLE,
      IS_READ_ONLY: ZRANK_1.default.IS_READ_ONLY,
      /**
       * Returns the rank of a member in the sorted set with its score.
       * @param args - Same parameters as the ZRANK command.
       */
      parseCommand(...args) {
        const parser = args[0];
        ZRANK_1.default.parseCommand(...args);
        parser.push("WITHSCORE");
      },
      transformReply: {
        2: (reply) => {
          if (reply === null)
            return null;
          return {
            rank: reply[0],
            score: Number(reply[1])
          };
        },
        3: (reply) => {
          if (reply === null)
            return null;
          return {
            rank: reply[0],
            score: reply[1]
          };
        }
      }
    };
  }
});
var require_ZREM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZREM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes the specified members from the sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param member - One or more members to remove.
       */
      parseCommand(parser, key, member) {
        parser.push("ZREM");
        parser.pushKey(key);
        parser.pushVariadic(member);
      },
      transformReply: void 0
    };
  }
});
var require_ZREMRANGEBYLEX = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYLEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes all elements in the sorted set with lexicographical values between min and max.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param min - Minimum lexicographical value.
       * @param max - Maximum lexicographical value.
       */
      parseCommand(parser, key, min, max) {
        parser.push("ZREMRANGEBYLEX");
        parser.pushKey(key);
        parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      },
      transformReply: void 0
    };
  }
});
var require_ZREMRANGEBYRANK = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYRANK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes all elements in the sorted set with rank between start and stop.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param start - Minimum rank (starting from 0).
       * @param stop - Maximum rank.
       */
      parseCommand(parser, key, start, stop) {
        parser.push("ZREMRANGEBYRANK");
        parser.pushKey(key);
        parser.push(start.toString(), stop.toString());
      },
      transformReply: void 0
    };
  }
});
var require_ZREVRANK = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZREVRANK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the rank of a member in the sorted set, with scores ordered from high to low.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param member - Member to get the rank for.
       */
      parseCommand(parser, key, member) {
        parser.push("ZREVRANK");
        parser.pushKey(key);
        parser.push(member);
      },
      transformReply: void 0
    };
  }
});
var require_ZSCAN = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZSCAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SCAN_1 = require_SCAN();
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Incrementally iterates over a sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param cursor - Cursor position to start the scan from.
       * @param options - Optional scan parameters (COUNT, MATCH, TYPE).
       */
      parseCommand(parser, key, cursor, options2) {
        parser.push("ZSCAN");
        parser.pushKey(key);
        (0, SCAN_1.parseScanArguments)(parser, cursor, options2);
      },
      transformReply([cursor, rawMembers]) {
        return {
          cursor,
          members: generic_transformers_1.transformSortedSetReply[2](rawMembers)
        };
      }
    };
  }
});
var require_ZSCORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZSCORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      CACHEABLE: true,
      IS_READ_ONLY: true,
      /**
       * Returns the score of a member in a sorted set.
       * @param parser - The Redis command parser.
       * @param key - Key of the sorted set.
       * @param member - Member to get the score for.
       */
      parseCommand(parser, key, member) {
        parser.push("ZSCORE");
        parser.pushKey(key);
        parser.push(member);
      },
      transformReply: generic_transformers_1.transformNullableDoubleReply
    };
  }
});
var require_ZUNION = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZUNION.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the union of multiple sorted sets.
       * @param parser - The Redis command parser.
       * @param keys - Keys of the sorted sets to combine.
       * @param options - Optional parameters for the union operation.
       */
      parseCommand(parser, keys, options2) {
        parser.push("ZUNION");
        (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
        if (options2?.AGGREGATE) {
          parser.push("AGGREGATE", options2.AGGREGATE);
        }
      },
      transformReply: void 0
    };
  }
});
var require_ZUNION_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZUNION_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var ZUNION_1 = __importDefault(require_ZUNION());
    exports.default = {
      IS_READ_ONLY: ZUNION_1.default.IS_READ_ONLY,
      /**
       * Returns the union of multiple sorted sets with their scores.
       * @param args - Same parameters as the ZUNION command.
       */
      parseCommand(...args) {
        const parser = args[0];
        ZUNION_1.default.parseCommand(...args);
        parser.push("WITHSCORES");
      },
      transformReply: generic_transformers_1.transformSortedSetReply
    };
  }
});
var require_ZUNIONSTORE = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/ZUNIONSTORE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Stores the union of multiple sorted sets in a new sorted set.
       * @param parser - The Redis command parser.
       * @param destination - Destination key where the result will be stored.
       * @param keys - Keys of the sorted sets to combine.
       * @param options - Optional parameters for the union operation.
       */
      parseCommand(parser, destination, keys, options2) {
        parser.push("ZUNIONSTORE");
        parser.pushKey(destination);
        (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
        if (options2?.AGGREGATE) {
          parser.push("AGGREGATE", options2.AGGREGATE);
        }
      },
      transformReply: void 0
    };
  }
});
var require_VADD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Add a new element into the vector set specified by key
       *
       * @param parser - The command parser
       * @param key - The name of the key that will hold the vector set data
       * @param vector - The vector data as array of numbers
       * @param element - The name of the element being added to the vector set
       * @param options - Optional parameters for vector addition
       * @see https://redis.io/commands/vadd/
       */
      parseCommand(parser, key, vector, element, options2) {
        parser.push("VADD");
        parser.pushKey(key);
        if (options2?.REDUCE !== void 0) {
          parser.push("REDUCE", options2.REDUCE.toString());
        }
        parser.push("VALUES", vector.length.toString());
        for (const value of vector) {
          parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
        }
        parser.push(element);
        if (options2?.CAS) {
          parser.push("CAS");
        }
        options2?.QUANT && parser.push(options2.QUANT);
        if (options2?.EF !== void 0) {
          parser.push("EF", options2.EF.toString());
        }
        if (options2?.SETATTR) {
          parser.push("SETATTR", JSON.stringify(options2.SETATTR));
        }
        if (options2?.M !== void 0) {
          parser.push("M", options2.M.toString());
        }
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_VCARD = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VCARD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve the number of elements in a vector set
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @see https://redis.io/commands/vcard/
       */
      parseCommand(parser, key) {
        parser.push("VCARD");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_VDIM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VDIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve the dimension of the vectors in a vector set
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @see https://redis.io/commands/vdim/
       */
      parseCommand(parser, key) {
        parser.push("VDIM");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_VEMB = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VEMB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve the approximate vector associated with a vector set element
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param element - The name of the element to retrieve the vector for
       * @see https://redis.io/commands/vemb/
       */
      parseCommand(parser, key, element) {
        parser.push("VEMB");
        parser.pushKey(key);
        parser.push(element);
      },
      transformReply: generic_transformers_1.transformDoubleArrayReply
    };
  }
});
var require_VEMB_RAW = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VEMB_RAW.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var VEMB_1 = __importDefault(require_VEMB());
    var transformRawVembReply = {
      2: (reply) => {
        return {
          quantization: reply[0],
          raw: reply[1],
          l2Norm: generic_transformers_1.transformDoubleReply[2](reply[2]),
          ...reply[3] !== void 0 && { quantizationRange: generic_transformers_1.transformDoubleReply[2](reply[3]) }
        };
      },
      3: (reply) => {
        return {
          quantization: reply[0],
          raw: reply[1],
          l2Norm: reply[2],
          quantizationRange: reply[3]
        };
      }
    };
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve the RAW approximate vector associated with a vector set element
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param element - The name of the element to retrieve the vector for
       * @see https://redis.io/commands/vemb/
       */
      parseCommand(parser, key, element) {
        VEMB_1.default.parseCommand(parser, key, element);
        parser.push("RAW");
      },
      transformReply: transformRawVembReply
    };
  }
});
var require_VGETATTR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VGETATTR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve the attributes of a vector set element
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param element - The name of the element to retrieve attributes for
       * @see https://redis.io/commands/vgetattr/
       */
      parseCommand(parser, key, element) {
        parser.push("VGETATTR");
        parser.pushKey(key);
        parser.push(element);
      },
      transformReply: generic_transformers_1.transformRedisJsonNullReply
    };
  }
});
var require_VINFO = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VINFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve metadata and internal details about a vector set, including size, dimensions, quantization type, and graph structure
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @see https://redis.io/commands/vinfo/
       */
      parseCommand(parser, key) {
        parser.push("VINFO");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply) => {
          const ret = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < reply.length; i2 += 2) {
            ret[reply[i2].toString()] = reply[i2 + 1];
          }
          return ret;
        },
        3: void 0
      }
    };
  }
});
var require_VLINKS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VLINKS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve the neighbors of a specified element in a vector set; the connections for each layer of the HNSW graph
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param element - The name of the element to retrieve neighbors for
       * @see https://redis.io/commands/vlinks/
       */
      parseCommand(parser, key, element) {
        parser.push("VLINKS");
        parser.pushKey(key);
        parser.push(element);
      },
      transformReply: void 0
    };
  }
});
var require_VLINKS_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VLINKS_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var VLINKS_1 = __importDefault(require_VLINKS());
    function transformVLinksWithScoresReply(reply) {
      const layers = [];
      for (const layer of reply) {
        const obj = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < layer.length; i2 += 2) {
          const element = layer[i2];
          const score = generic_transformers_1.transformDoubleReply[2](layer[i2 + 1]);
          obj[element.toString()] = score;
        }
        layers.push(obj);
      }
      return layers;
    }
    exports.default = {
      IS_READ_ONLY: VLINKS_1.default.IS_READ_ONLY,
      /**
       * Get the connections for each layer of the HNSW graph with similarity scores
       * @param args - Same parameters as the VLINKS command
       * @see https://redis.io/commands/vlinks/
       */
      parseCommand(...args) {
        const parser = args[0];
        VLINKS_1.default.parseCommand(...args);
        parser.push("WITHSCORES");
      },
      transformReply: {
        2: transformVLinksWithScoresReply,
        3: void 0
      }
    };
  }
});
var require_VRANDMEMBER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VRANDMEMBER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve random elements of a vector set
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param count - Optional number of elements to return
       * @see https://redis.io/commands/vrandmember/
       */
      parseCommand(parser, key, count) {
        parser.push("VRANDMEMBER");
        parser.pushKey(key);
        if (count !== void 0) {
          parser.push(count.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_VREM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VREM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Remove an element from a vector set
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param element - The name of the element to remove from the vector set
       * @see https://redis.io/commands/vrem/
       */
      parseCommand(parser, key, element) {
        parser.push("VREM");
        parser.pushKey(key);
        parser.push(element);
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_VSETATTR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VSETATTR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Set or replace attributes on a vector set element
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param element - The name of the element to set attributes for
       * @param attributes - The attributes to set (as JSON string or object)
       * @see https://redis.io/commands/vsetattr/
       */
      parseCommand(parser, key, element, attributes) {
        parser.push("VSETATTR");
        parser.pushKey(key);
        parser.push(element);
        if (typeof attributes === "object" && attributes !== null) {
          parser.push(JSON.stringify(attributes));
        } else {
          parser.push(attributes);
        }
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_VSIM = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VSIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Retrieve elements similar to a given vector or element with optional filtering
       *
       * @param parser - The command parser
       * @param key - The key of the vector set
       * @param query - The query vector (array of numbers) or element name (string)
       * @param options - Optional parameters for similarity search
       * @see https://redis.io/commands/vsim/
       */
      parseCommand(parser, key, query, options2) {
        parser.push("VSIM");
        parser.pushKey(key);
        if (Array.isArray(query)) {
          parser.push("VALUES", query.length.toString());
          for (const value of query) {
            parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
          }
        } else {
          parser.push("ELE", query);
        }
        if (options2?.COUNT !== void 0) {
          parser.push("COUNT", options2.COUNT.toString());
        }
        if (options2?.EPSILON !== void 0) {
          parser.push("EPSILON", options2.EPSILON.toString());
        }
        if (options2?.EF !== void 0) {
          parser.push("EF", options2.EF.toString());
        }
        if (options2?.FILTER) {
          parser.push("FILTER", options2.FILTER);
        }
        if (options2?.["FILTER-EF"] !== void 0) {
          parser.push("FILTER-EF", options2["FILTER-EF"].toString());
        }
        if (options2?.TRUTH) {
          parser.push("TRUTH");
        }
        if (options2?.NOTHREAD) {
          parser.push("NOTHREAD");
        }
      },
      transformReply: void 0
    };
  }
});
var require_VSIM_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/VSIM_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var VSIM_1 = __importDefault(require_VSIM());
    exports.default = {
      IS_READ_ONLY: VSIM_1.default.IS_READ_ONLY,
      /**
       * Retrieve elements similar to a given vector or element with similarity scores
       * @param args - Same parameters as the VSIM command
       * @see https://redis.io/commands/vsim/
       */
      parseCommand(...args) {
        const parser = args[0];
        VSIM_1.default.parseCommand(...args);
        parser.push("WITHSCORES");
      },
      transformReply: {
        2: (reply) => {
          const inferred = reply;
          const members = {};
          for (let i2 = 0; i2 < inferred.length; i2 += 2) {
            members[inferred[i2].toString()] = generic_transformers_1.transformDoubleReply[2](inferred[i2 + 1]);
          }
          return members;
        },
        3: void 0
      }
    };
  }
});
var require_commands = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commands/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.REDIS_FLUSH_MODES = exports.COMMAND_LIST_FILTER_BY = exports.CLUSTER_SLOT_STATES = exports.FAILOVER_MODES = exports.CLIENT_KILL_FILTERS = void 0;
    var ACL_CAT_1 = __importDefault(require_ACL_CAT());
    var ACL_DELUSER_1 = __importDefault(require_ACL_DELUSER());
    var ACL_DRYRUN_1 = __importDefault(require_ACL_DRYRUN());
    var ACL_GENPASS_1 = __importDefault(require_ACL_GENPASS());
    var ACL_GETUSER_1 = __importDefault(require_ACL_GETUSER());
    var ACL_LIST_1 = __importDefault(require_ACL_LIST());
    var ACL_LOAD_1 = __importDefault(require_ACL_LOAD());
    var ACL_LOG_RESET_1 = __importDefault(require_ACL_LOG_RESET());
    var ACL_LOG_1 = __importDefault(require_ACL_LOG());
    var ACL_SAVE_1 = __importDefault(require_ACL_SAVE());
    var ACL_SETUSER_1 = __importDefault(require_ACL_SETUSER());
    var ACL_USERS_1 = __importDefault(require_ACL_USERS());
    var ACL_WHOAMI_1 = __importDefault(require_ACL_WHOAMI());
    var APPEND_1 = __importDefault(require_APPEND());
    var ASKING_1 = __importDefault(require_ASKING());
    var AUTH_1 = __importDefault(require_AUTH());
    var BGREWRITEAOF_1 = __importDefault(require_BGREWRITEAOF());
    var BGSAVE_1 = __importDefault(require_BGSAVE());
    var BITCOUNT_1 = __importDefault(require_BITCOUNT());
    var BITFIELD_RO_1 = __importDefault(require_BITFIELD_RO());
    var BITFIELD_1 = __importDefault(require_BITFIELD());
    var BITOP_1 = __importDefault(require_BITOP());
    var BITPOS_1 = __importDefault(require_BITPOS());
    var BLMOVE_1 = __importDefault(require_BLMOVE());
    var BLMPOP_1 = __importDefault(require_BLMPOP());
    var BLPOP_1 = __importDefault(require_BLPOP());
    var BRPOP_1 = __importDefault(require_BRPOP());
    var BRPOPLPUSH_1 = __importDefault(require_BRPOPLPUSH());
    var BZMPOP_1 = __importDefault(require_BZMPOP());
    var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
    var BZPOPMIN_1 = __importDefault(require_BZPOPMIN());
    var CLIENT_CACHING_1 = __importDefault(require_CLIENT_CACHING());
    var CLIENT_GETNAME_1 = __importDefault(require_CLIENT_GETNAME());
    var CLIENT_GETREDIR_1 = __importDefault(require_CLIENT_GETREDIR());
    var CLIENT_ID_1 = __importDefault(require_CLIENT_ID());
    var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
    var CLIENT_KILL_1 = __importStar(require_CLIENT_KILL());
    Object.defineProperty(exports, "CLIENT_KILL_FILTERS", { enumerable: true, get: function() {
      return CLIENT_KILL_1.CLIENT_KILL_FILTERS;
    } });
    var CLIENT_LIST_1 = __importDefault(require_CLIENT_LIST());
    var CLIENT_NO_EVICT_1 = __importDefault(require_CLIENT_NO_EVICT());
    var CLIENT_NO_TOUCH_1 = __importDefault(require_CLIENT_NO_TOUCH());
    var CLIENT_PAUSE_1 = __importDefault(require_CLIENT_PAUSE());
    var CLIENT_SETNAME_1 = __importDefault(require_CLIENT_SETNAME());
    var CLIENT_TRACKING_1 = __importDefault(require_CLIENT_TRACKING());
    var CLIENT_TRACKINGINFO_1 = __importDefault(require_CLIENT_TRACKINGINFO());
    var CLIENT_UNPAUSE_1 = __importDefault(require_CLIENT_UNPAUSE());
    var CLUSTER_ADDSLOTS_1 = __importDefault(require_CLUSTER_ADDSLOTS());
    var CLUSTER_ADDSLOTSRANGE_1 = __importDefault(require_CLUSTER_ADDSLOTSRANGE());
    var CLUSTER_BUMPEPOCH_1 = __importDefault(require_CLUSTER_BUMPEPOCH());
    var CLUSTER_COUNT_FAILURE_REPORTS_1 = __importDefault(require_CLUSTER_COUNT_FAILURE_REPORTS());
    var CLUSTER_COUNTKEYSINSLOT_1 = __importDefault(require_CLUSTER_COUNTKEYSINSLOT());
    var CLUSTER_DELSLOTS_1 = __importDefault(require_CLUSTER_DELSLOTS());
    var CLUSTER_DELSLOTSRANGE_1 = __importDefault(require_CLUSTER_DELSLOTSRANGE());
    var CLUSTER_FAILOVER_1 = __importStar(require_CLUSTER_FAILOVER());
    Object.defineProperty(exports, "FAILOVER_MODES", { enumerable: true, get: function() {
      return CLUSTER_FAILOVER_1.FAILOVER_MODES;
    } });
    var CLUSTER_FLUSHSLOTS_1 = __importDefault(require_CLUSTER_FLUSHSLOTS());
    var CLUSTER_FORGET_1 = __importDefault(require_CLUSTER_FORGET());
    var CLUSTER_GETKEYSINSLOT_1 = __importDefault(require_CLUSTER_GETKEYSINSLOT());
    var CLUSTER_INFO_1 = __importDefault(require_CLUSTER_INFO());
    var CLUSTER_KEYSLOT_1 = __importDefault(require_CLUSTER_KEYSLOT());
    var CLUSTER_LINKS_1 = __importDefault(require_CLUSTER_LINKS());
    var CLUSTER_MEET_1 = __importDefault(require_CLUSTER_MEET());
    var CLUSTER_MYID_1 = __importDefault(require_CLUSTER_MYID());
    var CLUSTER_MYSHARDID_1 = __importDefault(require_CLUSTER_MYSHARDID());
    var CLUSTER_NODES_1 = __importDefault(require_CLUSTER_NODES());
    var CLUSTER_REPLICAS_1 = __importDefault(require_CLUSTER_REPLICAS());
    var CLUSTER_REPLICATE_1 = __importDefault(require_CLUSTER_REPLICATE());
    var CLUSTER_RESET_1 = __importDefault(require_CLUSTER_RESET());
    var CLUSTER_SAVECONFIG_1 = __importDefault(require_CLUSTER_SAVECONFIG());
    var CLUSTER_SET_CONFIG_EPOCH_1 = __importDefault(require_CLUSTER_SET_CONFIG_EPOCH());
    var CLUSTER_SETSLOT_1 = __importStar(require_CLUSTER_SETSLOT());
    Object.defineProperty(exports, "CLUSTER_SLOT_STATES", { enumerable: true, get: function() {
      return CLUSTER_SETSLOT_1.CLUSTER_SLOT_STATES;
    } });
    var CLUSTER_SLOTS_1 = __importDefault(require_CLUSTER_SLOTS());
    var COMMAND_COUNT_1 = __importDefault(require_COMMAND_COUNT());
    var COMMAND_GETKEYS_1 = __importDefault(require_COMMAND_GETKEYS());
    var COMMAND_GETKEYSANDFLAGS_1 = __importDefault(require_COMMAND_GETKEYSANDFLAGS());
    var COMMAND_INFO_1 = __importDefault(require_COMMAND_INFO());
    var COMMAND_LIST_1 = __importStar(require_COMMAND_LIST());
    Object.defineProperty(exports, "COMMAND_LIST_FILTER_BY", { enumerable: true, get: function() {
      return COMMAND_LIST_1.COMMAND_LIST_FILTER_BY;
    } });
    var COMMAND_1 = __importDefault(require_COMMAND());
    var CONFIG_GET_1 = __importDefault(require_CONFIG_GET());
    var CONFIG_RESETSTAT_1 = __importDefault(require_CONFIG_RESETSTAT());
    var CONFIG_REWRITE_1 = __importDefault(require_CONFIG_REWRITE());
    var CONFIG_SET_1 = __importDefault(require_CONFIG_SET());
    var COPY_1 = __importDefault(require_COPY());
    var DBSIZE_1 = __importDefault(require_DBSIZE());
    var DECR_1 = __importDefault(require_DECR());
    var DECRBY_1 = __importDefault(require_DECRBY());
    var DEL_1 = __importDefault(require_DEL());
    var DUMP_1 = __importDefault(require_DUMP());
    var ECHO_1 = __importDefault(require_ECHO());
    var EVAL_RO_1 = __importDefault(require_EVAL_RO());
    var EVAL_1 = __importDefault(require_EVAL());
    var EVALSHA_RO_1 = __importDefault(require_EVALSHA_RO());
    var EVALSHA_1 = __importDefault(require_EVALSHA());
    var GEOADD_1 = __importDefault(require_GEOADD());
    var GEODIST_1 = __importDefault(require_GEODIST());
    var GEOHASH_1 = __importDefault(require_GEOHASH());
    var GEOPOS_1 = __importDefault(require_GEOPOS());
    var GEORADIUS_RO_WITH_1 = __importDefault(require_GEORADIUS_RO_WITH());
    var GEORADIUS_RO_1 = __importDefault(require_GEORADIUS_RO());
    var GEORADIUS_STORE_1 = __importDefault(require_GEORADIUS_STORE());
    var GEORADIUS_WITH_1 = __importDefault(require_GEORADIUS_WITH());
    var GEORADIUS_1 = __importDefault(require_GEORADIUS());
    var GEORADIUSBYMEMBER_RO_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_RO_WITH());
    var GEORADIUSBYMEMBER_RO_1 = __importDefault(require_GEORADIUSBYMEMBER_RO());
    var GEORADIUSBYMEMBER_STORE_1 = __importDefault(require_GEORADIUSBYMEMBER_STORE());
    var GEORADIUSBYMEMBER_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_WITH());
    var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
    var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
    var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
    var GEOSEARCHSTORE_1 = __importDefault(require_GEOSEARCHSTORE());
    var GET_1 = __importDefault(require_GET());
    var GETBIT_1 = __importDefault(require_GETBIT());
    var GETDEL_1 = __importDefault(require_GETDEL());
    var GETEX_1 = __importDefault(require_GETEX());
    var GETRANGE_1 = __importDefault(require_GETRANGE());
    var GETSET_1 = __importDefault(require_GETSET());
    var EXISTS_1 = __importDefault(require_EXISTS());
    var EXPIRE_1 = __importDefault(require_EXPIRE());
    var EXPIREAT_1 = __importDefault(require_EXPIREAT());
    var EXPIRETIME_1 = __importDefault(require_EXPIRETIME());
    var FLUSHALL_1 = __importStar(require_FLUSHALL());
    Object.defineProperty(exports, "REDIS_FLUSH_MODES", { enumerable: true, get: function() {
      return FLUSHALL_1.REDIS_FLUSH_MODES;
    } });
    var FLUSHDB_1 = __importDefault(require_FLUSHDB());
    var FCALL_1 = __importDefault(require_FCALL());
    var FCALL_RO_1 = __importDefault(require_FCALL_RO());
    var FUNCTION_DELETE_1 = __importDefault(require_FUNCTION_DELETE());
    var FUNCTION_DUMP_1 = __importDefault(require_FUNCTION_DUMP());
    var FUNCTION_FLUSH_1 = __importDefault(require_FUNCTION_FLUSH());
    var FUNCTION_KILL_1 = __importDefault(require_FUNCTION_KILL());
    var FUNCTION_LIST_WITHCODE_1 = __importDefault(require_FUNCTION_LIST_WITHCODE());
    var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
    var FUNCTION_LOAD_1 = __importDefault(require_FUNCTION_LOAD());
    var FUNCTION_RESTORE_1 = __importDefault(require_FUNCTION_RESTORE());
    var FUNCTION_STATS_1 = __importDefault(require_FUNCTION_STATS());
    var HDEL_1 = __importDefault(require_HDEL());
    var HELLO_1 = __importDefault(require_HELLO());
    var HEXISTS_1 = __importDefault(require_HEXISTS());
    var HEXPIRE_1 = __importDefault(require_HEXPIRE());
    var HEXPIREAT_1 = __importDefault(require_HEXPIREAT());
    var HEXPIRETIME_1 = __importDefault(require_HEXPIRETIME());
    var HGET_1 = __importDefault(require_HGET());
    var HGETALL_1 = __importDefault(require_HGETALL());
    var HGETDEL_1 = __importDefault(require_HGETDEL());
    var HGETEX_1 = __importDefault(require_HGETEX());
    var HINCRBY_1 = __importDefault(require_HINCRBY());
    var HINCRBYFLOAT_1 = __importDefault(require_HINCRBYFLOAT());
    var HKEYS_1 = __importDefault(require_HKEYS());
    var HLEN_1 = __importDefault(require_HLEN());
    var HMGET_1 = __importDefault(require_HMGET());
    var HPERSIST_1 = __importDefault(require_HPERSIST());
    var HPEXPIRE_1 = __importDefault(require_HPEXPIRE());
    var HPEXPIREAT_1 = __importDefault(require_HPEXPIREAT());
    var HPEXPIRETIME_1 = __importDefault(require_HPEXPIRETIME());
    var HPTTL_1 = __importDefault(require_HPTTL());
    var HRANDFIELD_COUNT_WITHVALUES_1 = __importDefault(require_HRANDFIELD_COUNT_WITHVALUES());
    var HRANDFIELD_COUNT_1 = __importDefault(require_HRANDFIELD_COUNT());
    var HRANDFIELD_1 = __importDefault(require_HRANDFIELD());
    var HSCAN_1 = __importDefault(require_HSCAN());
    var HSCAN_NOVALUES_1 = __importDefault(require_HSCAN_NOVALUES());
    var HSET_1 = __importDefault(require_HSET());
    var HSETEX_1 = __importDefault(require_HSETEX());
    var HSETNX_1 = __importDefault(require_HSETNX());
    var HSTRLEN_1 = __importDefault(require_HSTRLEN());
    var HTTL_1 = __importDefault(require_HTTL());
    var HVALS_1 = __importDefault(require_HVALS());
    var INCR_1 = __importDefault(require_INCR());
    var INCRBY_1 = __importDefault(require_INCRBY());
    var INCRBYFLOAT_1 = __importDefault(require_INCRBYFLOAT());
    var INFO_1 = __importDefault(require_INFO());
    var KEYS_1 = __importDefault(require_KEYS());
    var LASTSAVE_1 = __importDefault(require_LASTSAVE());
    var LATENCY_DOCTOR_1 = __importDefault(require_LATENCY_DOCTOR());
    var LATENCY_GRAPH_1 = __importDefault(require_LATENCY_GRAPH());
    var LATENCY_HISTORY_1 = __importDefault(require_LATENCY_HISTORY());
    var LATENCY_LATEST_1 = __importDefault(require_LATENCY_LATEST());
    var LATENCY_RESET_1 = __importDefault(require_LATENCY_RESET());
    var LCS_IDX_WITHMATCHLEN_1 = __importDefault(require_LCS_IDX_WITHMATCHLEN());
    var LCS_IDX_1 = __importDefault(require_LCS_IDX());
    var LCS_LEN_1 = __importDefault(require_LCS_LEN());
    var LCS_1 = __importDefault(require_LCS());
    var LINDEX_1 = __importDefault(require_LINDEX());
    var LINSERT_1 = __importDefault(require_LINSERT());
    var LLEN_1 = __importDefault(require_LLEN());
    var LMOVE_1 = __importDefault(require_LMOVE());
    var LMPOP_1 = __importDefault(require_LMPOP());
    var LOLWUT_1 = __importDefault(require_LOLWUT());
    var LPOP_COUNT_1 = __importDefault(require_LPOP_COUNT());
    var LPOP_1 = __importDefault(require_LPOP());
    var LPOS_COUNT_1 = __importDefault(require_LPOS_COUNT());
    var LPOS_1 = __importDefault(require_LPOS());
    var LPUSH_1 = __importDefault(require_LPUSH());
    var LPUSHX_1 = __importDefault(require_LPUSHX());
    var LRANGE_1 = __importDefault(require_LRANGE());
    var LREM_1 = __importDefault(require_LREM());
    var LSET_1 = __importDefault(require_LSET());
    var LTRIM_1 = __importDefault(require_LTRIM());
    var MEMORY_DOCTOR_1 = __importDefault(require_MEMORY_DOCTOR());
    var MEMORY_MALLOC_STATS_1 = __importDefault(require_MEMORY_MALLOC_STATS());
    var MEMORY_PURGE_1 = __importDefault(require_MEMORY_PURGE());
    var MEMORY_STATS_1 = __importDefault(require_MEMORY_STATS());
    var MEMORY_USAGE_1 = __importDefault(require_MEMORY_USAGE());
    var MGET_1 = __importDefault(require_MGET());
    var MIGRATE_1 = __importDefault(require_MIGRATE());
    var MODULE_LIST_1 = __importDefault(require_MODULE_LIST());
    var MODULE_LOAD_1 = __importDefault(require_MODULE_LOAD());
    var MODULE_UNLOAD_1 = __importDefault(require_MODULE_UNLOAD());
    var MOVE_1 = __importDefault(require_MOVE());
    var MSET_1 = __importDefault(require_MSET());
    var MSETNX_1 = __importDefault(require_MSETNX());
    var OBJECT_ENCODING_1 = __importDefault(require_OBJECT_ENCODING());
    var OBJECT_FREQ_1 = __importDefault(require_OBJECT_FREQ());
    var OBJECT_IDLETIME_1 = __importDefault(require_OBJECT_IDLETIME());
    var OBJECT_REFCOUNT_1 = __importDefault(require_OBJECT_REFCOUNT());
    var PERSIST_1 = __importDefault(require_PERSIST());
    var PEXPIRE_1 = __importDefault(require_PEXPIRE());
    var PEXPIREAT_1 = __importDefault(require_PEXPIREAT());
    var PEXPIRETIME_1 = __importDefault(require_PEXPIRETIME());
    var PFADD_1 = __importDefault(require_PFADD());
    var PFCOUNT_1 = __importDefault(require_PFCOUNT());
    var PFMERGE_1 = __importDefault(require_PFMERGE());
    var PING_1 = __importDefault(require_PING());
    var PSETEX_1 = __importDefault(require_PSETEX());
    var PTTL_1 = __importDefault(require_PTTL());
    var PUBLISH_1 = __importDefault(require_PUBLISH());
    var PUBSUB_CHANNELS_1 = __importDefault(require_PUBSUB_CHANNELS());
    var PUBSUB_NUMPAT_1 = __importDefault(require_PUBSUB_NUMPAT());
    var PUBSUB_NUMSUB_1 = __importDefault(require_PUBSUB_NUMSUB());
    var PUBSUB_SHARDNUMSUB_1 = __importDefault(require_PUBSUB_SHARDNUMSUB());
    var PUBSUB_SHARDCHANNELS_1 = __importDefault(require_PUBSUB_SHARDCHANNELS());
    var RANDOMKEY_1 = __importDefault(require_RANDOMKEY());
    var READONLY_1 = __importDefault(require_READONLY());
    var RENAME_1 = __importDefault(require_RENAME());
    var RENAMENX_1 = __importDefault(require_RENAMENX());
    var REPLICAOF_1 = __importDefault(require_REPLICAOF());
    var RESTORE_ASKING_1 = __importDefault(require_RESTORE_ASKING());
    var RESTORE_1 = __importDefault(require_RESTORE());
    var ROLE_1 = __importDefault(require_ROLE());
    var RPOP_COUNT_1 = __importDefault(require_RPOP_COUNT());
    var RPOP_1 = __importDefault(require_RPOP());
    var RPOPLPUSH_1 = __importDefault(require_RPOPLPUSH());
    var RPUSH_1 = __importDefault(require_RPUSH());
    var RPUSHX_1 = __importDefault(require_RPUSHX());
    var SADD_1 = __importDefault(require_SADD());
    var SCAN_1 = __importDefault(require_SCAN());
    var SCARD_1 = __importDefault(require_SCARD());
    var SCRIPT_DEBUG_1 = __importDefault(require_SCRIPT_DEBUG());
    var SCRIPT_EXISTS_1 = __importDefault(require_SCRIPT_EXISTS());
    var SCRIPT_FLUSH_1 = __importDefault(require_SCRIPT_FLUSH());
    var SCRIPT_KILL_1 = __importDefault(require_SCRIPT_KILL());
    var SCRIPT_LOAD_1 = __importDefault(require_SCRIPT_LOAD());
    var SDIFF_1 = __importDefault(require_SDIFF());
    var SDIFFSTORE_1 = __importDefault(require_SDIFFSTORE());
    var SET_1 = __importDefault(require_SET());
    var SETBIT_1 = __importDefault(require_SETBIT());
    var SETEX_1 = __importDefault(require_SETEX());
    var SETNX_1 = __importDefault(require_SETNX());
    var SETRANGE_1 = __importDefault(require_SETRANGE());
    var SINTER_1 = __importDefault(require_SINTER());
    var SINTERCARD_1 = __importDefault(require_SINTERCARD());
    var SINTERSTORE_1 = __importDefault(require_SINTERSTORE());
    var SISMEMBER_1 = __importDefault(require_SISMEMBER());
    var SMEMBERS_1 = __importDefault(require_SMEMBERS());
    var SMISMEMBER_1 = __importDefault(require_SMISMEMBER());
    var SMOVE_1 = __importDefault(require_SMOVE());
    var SORT_RO_1 = __importDefault(require_SORT_RO());
    var SORT_STORE_1 = __importDefault(require_SORT_STORE());
    var SORT_1 = __importDefault(require_SORT());
    var SPOP_COUNT_1 = __importDefault(require_SPOP_COUNT());
    var SPOP_1 = __importDefault(require_SPOP());
    var SPUBLISH_1 = __importDefault(require_SPUBLISH());
    var SRANDMEMBER_COUNT_1 = __importDefault(require_SRANDMEMBER_COUNT());
    var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
    var SREM_1 = __importDefault(require_SREM());
    var SSCAN_1 = __importDefault(require_SSCAN());
    var STRLEN_1 = __importDefault(require_STRLEN());
    var SUNION_1 = __importDefault(require_SUNION());
    var SUNIONSTORE_1 = __importDefault(require_SUNIONSTORE());
    var SWAPDB_1 = __importDefault(require_SWAPDB());
    var TIME_1 = __importDefault(require_TIME());
    var TOUCH_1 = __importDefault(require_TOUCH());
    var TTL_1 = __importDefault(require_TTL());
    var TYPE_1 = __importDefault(require_TYPE());
    var UNLINK_1 = __importDefault(require_UNLINK());
    var WAIT_1 = __importDefault(require_WAIT());
    var XACK_1 = __importDefault(require_XACK());
    var XACKDEL_1 = __importDefault(require_XACKDEL());
    var XADD_NOMKSTREAM_1 = __importDefault(require_XADD_NOMKSTREAM());
    var XADD_1 = __importDefault(require_XADD());
    var XAUTOCLAIM_JUSTID_1 = __importDefault(require_XAUTOCLAIM_JUSTID());
    var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
    var XCLAIM_JUSTID_1 = __importDefault(require_XCLAIM_JUSTID());
    var XCLAIM_1 = __importDefault(require_XCLAIM());
    var XDEL_1 = __importDefault(require_XDEL());
    var XDELEX_1 = __importDefault(require_XDELEX());
    var XGROUP_CREATE_1 = __importDefault(require_XGROUP_CREATE());
    var XGROUP_CREATECONSUMER_1 = __importDefault(require_XGROUP_CREATECONSUMER());
    var XGROUP_DELCONSUMER_1 = __importDefault(require_XGROUP_DELCONSUMER());
    var XGROUP_DESTROY_1 = __importDefault(require_XGROUP_DESTROY());
    var XGROUP_SETID_1 = __importDefault(require_XGROUP_SETID());
    var XINFO_CONSUMERS_1 = __importDefault(require_XINFO_CONSUMERS());
    var XINFO_GROUPS_1 = __importDefault(require_XINFO_GROUPS());
    var XINFO_STREAM_1 = __importDefault(require_XINFO_STREAM());
    var XLEN_1 = __importDefault(require_XLEN());
    var XPENDING_RANGE_1 = __importDefault(require_XPENDING_RANGE());
    var XPENDING_1 = __importDefault(require_XPENDING());
    var XRANGE_1 = __importDefault(require_XRANGE());
    var XREAD_1 = __importDefault(require_XREAD());
    var XREADGROUP_1 = __importDefault(require_XREADGROUP());
    var XREVRANGE_1 = __importDefault(require_XREVRANGE());
    var XSETID_1 = __importDefault(require_XSETID());
    var XTRIM_1 = __importDefault(require_XTRIM());
    var ZADD_INCR_1 = __importDefault(require_ZADD_INCR());
    var ZADD_1 = __importDefault(require_ZADD());
    var ZCARD_1 = __importDefault(require_ZCARD());
    var ZCOUNT_1 = __importDefault(require_ZCOUNT());
    var ZDIFF_WITHSCORES_1 = __importDefault(require_ZDIFF_WITHSCORES());
    var ZDIFF_1 = __importDefault(require_ZDIFF());
    var ZDIFFSTORE_1 = __importDefault(require_ZDIFFSTORE());
    var ZINCRBY_1 = __importDefault(require_ZINCRBY());
    var ZINTER_WITHSCORES_1 = __importDefault(require_ZINTER_WITHSCORES());
    var ZINTER_1 = __importDefault(require_ZINTER());
    var ZINTERCARD_1 = __importDefault(require_ZINTERCARD());
    var ZINTERSTORE_1 = __importDefault(require_ZINTERSTORE());
    var ZLEXCOUNT_1 = __importDefault(require_ZLEXCOUNT());
    var ZMPOP_1 = __importDefault(require_ZMPOP());
    var ZMSCORE_1 = __importDefault(require_ZMSCORE());
    var ZPOPMAX_COUNT_1 = __importDefault(require_ZPOPMAX_COUNT());
    var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
    var ZPOPMIN_COUNT_1 = __importDefault(require_ZPOPMIN_COUNT());
    var ZPOPMIN_1 = __importDefault(require_ZPOPMIN());
    var ZRANDMEMBER_COUNT_WITHSCORES_1 = __importDefault(require_ZRANDMEMBER_COUNT_WITHSCORES());
    var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
    var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
    var ZRANGE_WITHSCORES_1 = __importDefault(require_ZRANGE_WITHSCORES());
    var ZRANGE_1 = __importDefault(require_ZRANGE());
    var ZRANGEBYLEX_1 = __importDefault(require_ZRANGEBYLEX());
    var ZRANGEBYSCORE_WITHSCORES_1 = __importDefault(require_ZRANGEBYSCORE_WITHSCORES());
    var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
    var ZRANGESTORE_1 = __importDefault(require_ZRANGESTORE());
    var ZREMRANGEBYSCORE_1 = __importDefault(require_ZREMRANGEBYSCORE());
    var ZRANK_WITHSCORE_1 = __importDefault(require_ZRANK_WITHSCORE());
    var ZRANK_1 = __importDefault(require_ZRANK());
    var ZREM_1 = __importDefault(require_ZREM());
    var ZREMRANGEBYLEX_1 = __importDefault(require_ZREMRANGEBYLEX());
    var ZREMRANGEBYRANK_1 = __importDefault(require_ZREMRANGEBYRANK());
    var ZREVRANK_1 = __importDefault(require_ZREVRANK());
    var ZSCAN_1 = __importDefault(require_ZSCAN());
    var ZSCORE_1 = __importDefault(require_ZSCORE());
    var ZUNION_WITHSCORES_1 = __importDefault(require_ZUNION_WITHSCORES());
    var ZUNION_1 = __importDefault(require_ZUNION());
    var ZUNIONSTORE_1 = __importDefault(require_ZUNIONSTORE());
    var VADD_1 = __importDefault(require_VADD());
    var VCARD_1 = __importDefault(require_VCARD());
    var VDIM_1 = __importDefault(require_VDIM());
    var VEMB_1 = __importDefault(require_VEMB());
    var VEMB_RAW_1 = __importDefault(require_VEMB_RAW());
    var VGETATTR_1 = __importDefault(require_VGETATTR());
    var VINFO_1 = __importDefault(require_VINFO());
    var VLINKS_1 = __importDefault(require_VLINKS());
    var VLINKS_WITHSCORES_1 = __importDefault(require_VLINKS_WITHSCORES());
    var VRANDMEMBER_1 = __importDefault(require_VRANDMEMBER());
    var VREM_1 = __importDefault(require_VREM());
    var VSETATTR_1 = __importDefault(require_VSETATTR());
    var VSIM_1 = __importDefault(require_VSIM());
    var VSIM_WITHSCORES_1 = __importDefault(require_VSIM_WITHSCORES());
    exports.default = {
      ACL_CAT: ACL_CAT_1.default,
      aclCat: ACL_CAT_1.default,
      ACL_DELUSER: ACL_DELUSER_1.default,
      aclDelUser: ACL_DELUSER_1.default,
      ACL_DRYRUN: ACL_DRYRUN_1.default,
      aclDryRun: ACL_DRYRUN_1.default,
      ACL_GENPASS: ACL_GENPASS_1.default,
      aclGenPass: ACL_GENPASS_1.default,
      ACL_GETUSER: ACL_GETUSER_1.default,
      aclGetUser: ACL_GETUSER_1.default,
      ACL_LIST: ACL_LIST_1.default,
      aclList: ACL_LIST_1.default,
      ACL_LOAD: ACL_LOAD_1.default,
      aclLoad: ACL_LOAD_1.default,
      ACL_LOG_RESET: ACL_LOG_RESET_1.default,
      aclLogReset: ACL_LOG_RESET_1.default,
      ACL_LOG: ACL_LOG_1.default,
      aclLog: ACL_LOG_1.default,
      ACL_SAVE: ACL_SAVE_1.default,
      aclSave: ACL_SAVE_1.default,
      ACL_SETUSER: ACL_SETUSER_1.default,
      aclSetUser: ACL_SETUSER_1.default,
      ACL_USERS: ACL_USERS_1.default,
      aclUsers: ACL_USERS_1.default,
      ACL_WHOAMI: ACL_WHOAMI_1.default,
      aclWhoAmI: ACL_WHOAMI_1.default,
      APPEND: APPEND_1.default,
      append: APPEND_1.default,
      ASKING: ASKING_1.default,
      asking: ASKING_1.default,
      AUTH: AUTH_1.default,
      auth: AUTH_1.default,
      BGREWRITEAOF: BGREWRITEAOF_1.default,
      bgRewriteAof: BGREWRITEAOF_1.default,
      BGSAVE: BGSAVE_1.default,
      bgSave: BGSAVE_1.default,
      BITCOUNT: BITCOUNT_1.default,
      bitCount: BITCOUNT_1.default,
      BITFIELD_RO: BITFIELD_RO_1.default,
      bitFieldRo: BITFIELD_RO_1.default,
      BITFIELD: BITFIELD_1.default,
      bitField: BITFIELD_1.default,
      BITOP: BITOP_1.default,
      bitOp: BITOP_1.default,
      BITPOS: BITPOS_1.default,
      bitPos: BITPOS_1.default,
      BLMOVE: BLMOVE_1.default,
      blMove: BLMOVE_1.default,
      BLMPOP: BLMPOP_1.default,
      blmPop: BLMPOP_1.default,
      BLPOP: BLPOP_1.default,
      blPop: BLPOP_1.default,
      BRPOP: BRPOP_1.default,
      brPop: BRPOP_1.default,
      BRPOPLPUSH: BRPOPLPUSH_1.default,
      brPopLPush: BRPOPLPUSH_1.default,
      BZMPOP: BZMPOP_1.default,
      bzmPop: BZMPOP_1.default,
      BZPOPMAX: BZPOPMAX_1.default,
      bzPopMax: BZPOPMAX_1.default,
      BZPOPMIN: BZPOPMIN_1.default,
      bzPopMin: BZPOPMIN_1.default,
      CLIENT_CACHING: CLIENT_CACHING_1.default,
      clientCaching: CLIENT_CACHING_1.default,
      CLIENT_GETNAME: CLIENT_GETNAME_1.default,
      clientGetName: CLIENT_GETNAME_1.default,
      CLIENT_GETREDIR: CLIENT_GETREDIR_1.default,
      clientGetRedir: CLIENT_GETREDIR_1.default,
      CLIENT_ID: CLIENT_ID_1.default,
      clientId: CLIENT_ID_1.default,
      CLIENT_INFO: CLIENT_INFO_1.default,
      clientInfo: CLIENT_INFO_1.default,
      CLIENT_KILL: CLIENT_KILL_1.default,
      clientKill: CLIENT_KILL_1.default,
      CLIENT_LIST: CLIENT_LIST_1.default,
      clientList: CLIENT_LIST_1.default,
      "CLIENT_NO-EVICT": CLIENT_NO_EVICT_1.default,
      clientNoEvict: CLIENT_NO_EVICT_1.default,
      "CLIENT_NO-TOUCH": CLIENT_NO_TOUCH_1.default,
      clientNoTouch: CLIENT_NO_TOUCH_1.default,
      CLIENT_PAUSE: CLIENT_PAUSE_1.default,
      clientPause: CLIENT_PAUSE_1.default,
      CLIENT_SETNAME: CLIENT_SETNAME_1.default,
      clientSetName: CLIENT_SETNAME_1.default,
      CLIENT_TRACKING: CLIENT_TRACKING_1.default,
      clientTracking: CLIENT_TRACKING_1.default,
      CLIENT_TRACKINGINFO: CLIENT_TRACKINGINFO_1.default,
      clientTrackingInfo: CLIENT_TRACKINGINFO_1.default,
      CLIENT_UNPAUSE: CLIENT_UNPAUSE_1.default,
      clientUnpause: CLIENT_UNPAUSE_1.default,
      CLUSTER_ADDSLOTS: CLUSTER_ADDSLOTS_1.default,
      clusterAddSlots: CLUSTER_ADDSLOTS_1.default,
      CLUSTER_ADDSLOTSRANGE: CLUSTER_ADDSLOTSRANGE_1.default,
      clusterAddSlotsRange: CLUSTER_ADDSLOTSRANGE_1.default,
      CLUSTER_BUMPEPOCH: CLUSTER_BUMPEPOCH_1.default,
      clusterBumpEpoch: CLUSTER_BUMPEPOCH_1.default,
      "CLUSTER_COUNT-FAILURE-REPORTS": CLUSTER_COUNT_FAILURE_REPORTS_1.default,
      clusterCountFailureReports: CLUSTER_COUNT_FAILURE_REPORTS_1.default,
      CLUSTER_COUNTKEYSINSLOT: CLUSTER_COUNTKEYSINSLOT_1.default,
      clusterCountKeysInSlot: CLUSTER_COUNTKEYSINSLOT_1.default,
      CLUSTER_DELSLOTS: CLUSTER_DELSLOTS_1.default,
      clusterDelSlots: CLUSTER_DELSLOTS_1.default,
      CLUSTER_DELSLOTSRANGE: CLUSTER_DELSLOTSRANGE_1.default,
      clusterDelSlotsRange: CLUSTER_DELSLOTSRANGE_1.default,
      CLUSTER_FAILOVER: CLUSTER_FAILOVER_1.default,
      clusterFailover: CLUSTER_FAILOVER_1.default,
      CLUSTER_FLUSHSLOTS: CLUSTER_FLUSHSLOTS_1.default,
      clusterFlushSlots: CLUSTER_FLUSHSLOTS_1.default,
      CLUSTER_FORGET: CLUSTER_FORGET_1.default,
      clusterForget: CLUSTER_FORGET_1.default,
      CLUSTER_GETKEYSINSLOT: CLUSTER_GETKEYSINSLOT_1.default,
      clusterGetKeysInSlot: CLUSTER_GETKEYSINSLOT_1.default,
      CLUSTER_INFO: CLUSTER_INFO_1.default,
      clusterInfo: CLUSTER_INFO_1.default,
      CLUSTER_KEYSLOT: CLUSTER_KEYSLOT_1.default,
      clusterKeySlot: CLUSTER_KEYSLOT_1.default,
      CLUSTER_LINKS: CLUSTER_LINKS_1.default,
      clusterLinks: CLUSTER_LINKS_1.default,
      CLUSTER_MEET: CLUSTER_MEET_1.default,
      clusterMeet: CLUSTER_MEET_1.default,
      CLUSTER_MYID: CLUSTER_MYID_1.default,
      clusterMyId: CLUSTER_MYID_1.default,
      CLUSTER_MYSHARDID: CLUSTER_MYSHARDID_1.default,
      clusterMyShardId: CLUSTER_MYSHARDID_1.default,
      CLUSTER_NODES: CLUSTER_NODES_1.default,
      clusterNodes: CLUSTER_NODES_1.default,
      CLUSTER_REPLICAS: CLUSTER_REPLICAS_1.default,
      clusterReplicas: CLUSTER_REPLICAS_1.default,
      CLUSTER_REPLICATE: CLUSTER_REPLICATE_1.default,
      clusterReplicate: CLUSTER_REPLICATE_1.default,
      CLUSTER_RESET: CLUSTER_RESET_1.default,
      clusterReset: CLUSTER_RESET_1.default,
      CLUSTER_SAVECONFIG: CLUSTER_SAVECONFIG_1.default,
      clusterSaveConfig: CLUSTER_SAVECONFIG_1.default,
      "CLUSTER_SET-CONFIG-EPOCH": CLUSTER_SET_CONFIG_EPOCH_1.default,
      clusterSetConfigEpoch: CLUSTER_SET_CONFIG_EPOCH_1.default,
      CLUSTER_SETSLOT: CLUSTER_SETSLOT_1.default,
      clusterSetSlot: CLUSTER_SETSLOT_1.default,
      CLUSTER_SLOTS: CLUSTER_SLOTS_1.default,
      clusterSlots: CLUSTER_SLOTS_1.default,
      COMMAND_COUNT: COMMAND_COUNT_1.default,
      commandCount: COMMAND_COUNT_1.default,
      COMMAND_GETKEYS: COMMAND_GETKEYS_1.default,
      commandGetKeys: COMMAND_GETKEYS_1.default,
      COMMAND_GETKEYSANDFLAGS: COMMAND_GETKEYSANDFLAGS_1.default,
      commandGetKeysAndFlags: COMMAND_GETKEYSANDFLAGS_1.default,
      COMMAND_INFO: COMMAND_INFO_1.default,
      commandInfo: COMMAND_INFO_1.default,
      COMMAND_LIST: COMMAND_LIST_1.default,
      commandList: COMMAND_LIST_1.default,
      COMMAND: COMMAND_1.default,
      command: COMMAND_1.default,
      CONFIG_GET: CONFIG_GET_1.default,
      configGet: CONFIG_GET_1.default,
      CONFIG_RESETASTAT: CONFIG_RESETSTAT_1.default,
      configResetStat: CONFIG_RESETSTAT_1.default,
      CONFIG_REWRITE: CONFIG_REWRITE_1.default,
      configRewrite: CONFIG_REWRITE_1.default,
      CONFIG_SET: CONFIG_SET_1.default,
      configSet: CONFIG_SET_1.default,
      COPY: COPY_1.default,
      copy: COPY_1.default,
      DBSIZE: DBSIZE_1.default,
      dbSize: DBSIZE_1.default,
      DECR: DECR_1.default,
      decr: DECR_1.default,
      DECRBY: DECRBY_1.default,
      decrBy: DECRBY_1.default,
      DEL: DEL_1.default,
      del: DEL_1.default,
      DUMP: DUMP_1.default,
      dump: DUMP_1.default,
      ECHO: ECHO_1.default,
      echo: ECHO_1.default,
      EVAL_RO: EVAL_RO_1.default,
      evalRo: EVAL_RO_1.default,
      EVAL: EVAL_1.default,
      eval: EVAL_1.default,
      EVALSHA_RO: EVALSHA_RO_1.default,
      evalShaRo: EVALSHA_RO_1.default,
      EVALSHA: EVALSHA_1.default,
      evalSha: EVALSHA_1.default,
      EXISTS: EXISTS_1.default,
      exists: EXISTS_1.default,
      EXPIRE: EXPIRE_1.default,
      expire: EXPIRE_1.default,
      EXPIREAT: EXPIREAT_1.default,
      expireAt: EXPIREAT_1.default,
      EXPIRETIME: EXPIRETIME_1.default,
      expireTime: EXPIRETIME_1.default,
      FLUSHALL: FLUSHALL_1.default,
      flushAll: FLUSHALL_1.default,
      FLUSHDB: FLUSHDB_1.default,
      flushDb: FLUSHDB_1.default,
      FCALL: FCALL_1.default,
      fCall: FCALL_1.default,
      FCALL_RO: FCALL_RO_1.default,
      fCallRo: FCALL_RO_1.default,
      FUNCTION_DELETE: FUNCTION_DELETE_1.default,
      functionDelete: FUNCTION_DELETE_1.default,
      FUNCTION_DUMP: FUNCTION_DUMP_1.default,
      functionDump: FUNCTION_DUMP_1.default,
      FUNCTION_FLUSH: FUNCTION_FLUSH_1.default,
      functionFlush: FUNCTION_FLUSH_1.default,
      FUNCTION_KILL: FUNCTION_KILL_1.default,
      functionKill: FUNCTION_KILL_1.default,
      FUNCTION_LIST_WITHCODE: FUNCTION_LIST_WITHCODE_1.default,
      functionListWithCode: FUNCTION_LIST_WITHCODE_1.default,
      FUNCTION_LIST: FUNCTION_LIST_1.default,
      functionList: FUNCTION_LIST_1.default,
      FUNCTION_LOAD: FUNCTION_LOAD_1.default,
      functionLoad: FUNCTION_LOAD_1.default,
      FUNCTION_RESTORE: FUNCTION_RESTORE_1.default,
      functionRestore: FUNCTION_RESTORE_1.default,
      FUNCTION_STATS: FUNCTION_STATS_1.default,
      functionStats: FUNCTION_STATS_1.default,
      GEOADD: GEOADD_1.default,
      geoAdd: GEOADD_1.default,
      GEODIST: GEODIST_1.default,
      geoDist: GEODIST_1.default,
      GEOHASH: GEOHASH_1.default,
      geoHash: GEOHASH_1.default,
      GEOPOS: GEOPOS_1.default,
      geoPos: GEOPOS_1.default,
      GEORADIUS_RO_WITH: GEORADIUS_RO_WITH_1.default,
      geoRadiusRoWith: GEORADIUS_RO_WITH_1.default,
      GEORADIUS_RO: GEORADIUS_RO_1.default,
      geoRadiusRo: GEORADIUS_RO_1.default,
      GEORADIUS_STORE: GEORADIUS_STORE_1.default,
      geoRadiusStore: GEORADIUS_STORE_1.default,
      GEORADIUS_WITH: GEORADIUS_WITH_1.default,
      geoRadiusWith: GEORADIUS_WITH_1.default,
      GEORADIUS: GEORADIUS_1.default,
      geoRadius: GEORADIUS_1.default,
      GEORADIUSBYMEMBER_RO_WITH: GEORADIUSBYMEMBER_RO_WITH_1.default,
      geoRadiusByMemberRoWith: GEORADIUSBYMEMBER_RO_WITH_1.default,
      GEORADIUSBYMEMBER_RO: GEORADIUSBYMEMBER_RO_1.default,
      geoRadiusByMemberRo: GEORADIUSBYMEMBER_RO_1.default,
      GEORADIUSBYMEMBER_STORE: GEORADIUSBYMEMBER_STORE_1.default,
      geoRadiusByMemberStore: GEORADIUSBYMEMBER_STORE_1.default,
      GEORADIUSBYMEMBER_WITH: GEORADIUSBYMEMBER_WITH_1.default,
      geoRadiusByMemberWith: GEORADIUSBYMEMBER_WITH_1.default,
      GEORADIUSBYMEMBER: GEORADIUSBYMEMBER_1.default,
      geoRadiusByMember: GEORADIUSBYMEMBER_1.default,
      GEOSEARCH_WITH: GEOSEARCH_WITH_1.default,
      geoSearchWith: GEOSEARCH_WITH_1.default,
      GEOSEARCH: GEOSEARCH_1.default,
      geoSearch: GEOSEARCH_1.default,
      GEOSEARCHSTORE: GEOSEARCHSTORE_1.default,
      geoSearchStore: GEOSEARCHSTORE_1.default,
      GET: GET_1.default,
      get: GET_1.default,
      GETBIT: GETBIT_1.default,
      getBit: GETBIT_1.default,
      GETDEL: GETDEL_1.default,
      getDel: GETDEL_1.default,
      GETEX: GETEX_1.default,
      getEx: GETEX_1.default,
      GETRANGE: GETRANGE_1.default,
      getRange: GETRANGE_1.default,
      GETSET: GETSET_1.default,
      getSet: GETSET_1.default,
      HDEL: HDEL_1.default,
      hDel: HDEL_1.default,
      HELLO: HELLO_1.default,
      hello: HELLO_1.default,
      HEXISTS: HEXISTS_1.default,
      hExists: HEXISTS_1.default,
      HEXPIRE: HEXPIRE_1.default,
      hExpire: HEXPIRE_1.default,
      HEXPIREAT: HEXPIREAT_1.default,
      hExpireAt: HEXPIREAT_1.default,
      HEXPIRETIME: HEXPIRETIME_1.default,
      hExpireTime: HEXPIRETIME_1.default,
      HGET: HGET_1.default,
      hGet: HGET_1.default,
      HGETALL: HGETALL_1.default,
      hGetAll: HGETALL_1.default,
      HGETDEL: HGETDEL_1.default,
      hGetDel: HGETDEL_1.default,
      HGETEX: HGETEX_1.default,
      hGetEx: HGETEX_1.default,
      HINCRBY: HINCRBY_1.default,
      hIncrBy: HINCRBY_1.default,
      HINCRBYFLOAT: HINCRBYFLOAT_1.default,
      hIncrByFloat: HINCRBYFLOAT_1.default,
      HKEYS: HKEYS_1.default,
      hKeys: HKEYS_1.default,
      HLEN: HLEN_1.default,
      hLen: HLEN_1.default,
      HMGET: HMGET_1.default,
      hmGet: HMGET_1.default,
      HPERSIST: HPERSIST_1.default,
      hPersist: HPERSIST_1.default,
      HPEXPIRE: HPEXPIRE_1.default,
      hpExpire: HPEXPIRE_1.default,
      HPEXPIREAT: HPEXPIREAT_1.default,
      hpExpireAt: HPEXPIREAT_1.default,
      HPEXPIRETIME: HPEXPIRETIME_1.default,
      hpExpireTime: HPEXPIRETIME_1.default,
      HPTTL: HPTTL_1.default,
      hpTTL: HPTTL_1.default,
      HRANDFIELD_COUNT_WITHVALUES: HRANDFIELD_COUNT_WITHVALUES_1.default,
      hRandFieldCountWithValues: HRANDFIELD_COUNT_WITHVALUES_1.default,
      HRANDFIELD_COUNT: HRANDFIELD_COUNT_1.default,
      hRandFieldCount: HRANDFIELD_COUNT_1.default,
      HRANDFIELD: HRANDFIELD_1.default,
      hRandField: HRANDFIELD_1.default,
      HSCAN: HSCAN_1.default,
      hScan: HSCAN_1.default,
      HSCAN_NOVALUES: HSCAN_NOVALUES_1.default,
      hScanNoValues: HSCAN_NOVALUES_1.default,
      HSET: HSET_1.default,
      hSet: HSET_1.default,
      HSETEX: HSETEX_1.default,
      hSetEx: HSETEX_1.default,
      HSETNX: HSETNX_1.default,
      hSetNX: HSETNX_1.default,
      HSTRLEN: HSTRLEN_1.default,
      hStrLen: HSTRLEN_1.default,
      HTTL: HTTL_1.default,
      hTTL: HTTL_1.default,
      HVALS: HVALS_1.default,
      hVals: HVALS_1.default,
      INCR: INCR_1.default,
      incr: INCR_1.default,
      INCRBY: INCRBY_1.default,
      incrBy: INCRBY_1.default,
      INCRBYFLOAT: INCRBYFLOAT_1.default,
      incrByFloat: INCRBYFLOAT_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      KEYS: KEYS_1.default,
      keys: KEYS_1.default,
      LASTSAVE: LASTSAVE_1.default,
      lastSave: LASTSAVE_1.default,
      LATENCY_DOCTOR: LATENCY_DOCTOR_1.default,
      latencyDoctor: LATENCY_DOCTOR_1.default,
      LATENCY_GRAPH: LATENCY_GRAPH_1.default,
      latencyGraph: LATENCY_GRAPH_1.default,
      LATENCY_HISTORY: LATENCY_HISTORY_1.default,
      latencyHistory: LATENCY_HISTORY_1.default,
      LATENCY_LATEST: LATENCY_LATEST_1.default,
      latencyLatest: LATENCY_LATEST_1.default,
      LATENCY_RESET: LATENCY_RESET_1.default,
      latencyReset: LATENCY_RESET_1.default,
      LCS_IDX_WITHMATCHLEN: LCS_IDX_WITHMATCHLEN_1.default,
      lcsIdxWithMatchLen: LCS_IDX_WITHMATCHLEN_1.default,
      LCS_IDX: LCS_IDX_1.default,
      lcsIdx: LCS_IDX_1.default,
      LCS_LEN: LCS_LEN_1.default,
      lcsLen: LCS_LEN_1.default,
      LCS: LCS_1.default,
      lcs: LCS_1.default,
      LINDEX: LINDEX_1.default,
      lIndex: LINDEX_1.default,
      LINSERT: LINSERT_1.default,
      lInsert: LINSERT_1.default,
      LLEN: LLEN_1.default,
      lLen: LLEN_1.default,
      LMOVE: LMOVE_1.default,
      lMove: LMOVE_1.default,
      LMPOP: LMPOP_1.default,
      lmPop: LMPOP_1.default,
      LOLWUT: LOLWUT_1.default,
      LPOP_COUNT: LPOP_COUNT_1.default,
      lPopCount: LPOP_COUNT_1.default,
      LPOP: LPOP_1.default,
      lPop: LPOP_1.default,
      LPOS_COUNT: LPOS_COUNT_1.default,
      lPosCount: LPOS_COUNT_1.default,
      LPOS: LPOS_1.default,
      lPos: LPOS_1.default,
      LPUSH: LPUSH_1.default,
      lPush: LPUSH_1.default,
      LPUSHX: LPUSHX_1.default,
      lPushX: LPUSHX_1.default,
      LRANGE: LRANGE_1.default,
      lRange: LRANGE_1.default,
      LREM: LREM_1.default,
      lRem: LREM_1.default,
      LSET: LSET_1.default,
      lSet: LSET_1.default,
      LTRIM: LTRIM_1.default,
      lTrim: LTRIM_1.default,
      MEMORY_DOCTOR: MEMORY_DOCTOR_1.default,
      memoryDoctor: MEMORY_DOCTOR_1.default,
      "MEMORY_MALLOC-STATS": MEMORY_MALLOC_STATS_1.default,
      memoryMallocStats: MEMORY_MALLOC_STATS_1.default,
      MEMORY_PURGE: MEMORY_PURGE_1.default,
      memoryPurge: MEMORY_PURGE_1.default,
      MEMORY_STATS: MEMORY_STATS_1.default,
      memoryStats: MEMORY_STATS_1.default,
      MEMORY_USAGE: MEMORY_USAGE_1.default,
      memoryUsage: MEMORY_USAGE_1.default,
      MGET: MGET_1.default,
      mGet: MGET_1.default,
      MIGRATE: MIGRATE_1.default,
      migrate: MIGRATE_1.default,
      MODULE_LIST: MODULE_LIST_1.default,
      moduleList: MODULE_LIST_1.default,
      MODULE_LOAD: MODULE_LOAD_1.default,
      moduleLoad: MODULE_LOAD_1.default,
      MODULE_UNLOAD: MODULE_UNLOAD_1.default,
      moduleUnload: MODULE_UNLOAD_1.default,
      MOVE: MOVE_1.default,
      move: MOVE_1.default,
      MSET: MSET_1.default,
      mSet: MSET_1.default,
      MSETNX: MSETNX_1.default,
      mSetNX: MSETNX_1.default,
      OBJECT_ENCODING: OBJECT_ENCODING_1.default,
      objectEncoding: OBJECT_ENCODING_1.default,
      OBJECT_FREQ: OBJECT_FREQ_1.default,
      objectFreq: OBJECT_FREQ_1.default,
      OBJECT_IDLETIME: OBJECT_IDLETIME_1.default,
      objectIdleTime: OBJECT_IDLETIME_1.default,
      OBJECT_REFCOUNT: OBJECT_REFCOUNT_1.default,
      objectRefCount: OBJECT_REFCOUNT_1.default,
      PERSIST: PERSIST_1.default,
      persist: PERSIST_1.default,
      PEXPIRE: PEXPIRE_1.default,
      pExpire: PEXPIRE_1.default,
      PEXPIREAT: PEXPIREAT_1.default,
      pExpireAt: PEXPIREAT_1.default,
      PEXPIRETIME: PEXPIRETIME_1.default,
      pExpireTime: PEXPIRETIME_1.default,
      PFADD: PFADD_1.default,
      pfAdd: PFADD_1.default,
      PFCOUNT: PFCOUNT_1.default,
      pfCount: PFCOUNT_1.default,
      PFMERGE: PFMERGE_1.default,
      pfMerge: PFMERGE_1.default,
      PING: PING_1.default,
      /**
       * ping jsdoc
       */
      ping: PING_1.default,
      PSETEX: PSETEX_1.default,
      pSetEx: PSETEX_1.default,
      PTTL: PTTL_1.default,
      pTTL: PTTL_1.default,
      PUBLISH: PUBLISH_1.default,
      publish: PUBLISH_1.default,
      PUBSUB_CHANNELS: PUBSUB_CHANNELS_1.default,
      pubSubChannels: PUBSUB_CHANNELS_1.default,
      PUBSUB_NUMPAT: PUBSUB_NUMPAT_1.default,
      pubSubNumPat: PUBSUB_NUMPAT_1.default,
      PUBSUB_NUMSUB: PUBSUB_NUMSUB_1.default,
      pubSubNumSub: PUBSUB_NUMSUB_1.default,
      PUBSUB_SHARDNUMSUB: PUBSUB_SHARDNUMSUB_1.default,
      pubSubShardNumSub: PUBSUB_SHARDNUMSUB_1.default,
      PUBSUB_SHARDCHANNELS: PUBSUB_SHARDCHANNELS_1.default,
      pubSubShardChannels: PUBSUB_SHARDCHANNELS_1.default,
      RANDOMKEY: RANDOMKEY_1.default,
      randomKey: RANDOMKEY_1.default,
      READONLY: READONLY_1.default,
      readonly: READONLY_1.default,
      RENAME: RENAME_1.default,
      rename: RENAME_1.default,
      RENAMENX: RENAMENX_1.default,
      renameNX: RENAMENX_1.default,
      REPLICAOF: REPLICAOF_1.default,
      replicaOf: REPLICAOF_1.default,
      "RESTORE-ASKING": RESTORE_ASKING_1.default,
      restoreAsking: RESTORE_ASKING_1.default,
      RESTORE: RESTORE_1.default,
      restore: RESTORE_1.default,
      RPOP_COUNT: RPOP_COUNT_1.default,
      rPopCount: RPOP_COUNT_1.default,
      ROLE: ROLE_1.default,
      role: ROLE_1.default,
      RPOP: RPOP_1.default,
      rPop: RPOP_1.default,
      RPOPLPUSH: RPOPLPUSH_1.default,
      rPopLPush: RPOPLPUSH_1.default,
      RPUSH: RPUSH_1.default,
      rPush: RPUSH_1.default,
      RPUSHX: RPUSHX_1.default,
      rPushX: RPUSHX_1.default,
      SADD: SADD_1.default,
      sAdd: SADD_1.default,
      SCAN: SCAN_1.default,
      scan: SCAN_1.default,
      SCARD: SCARD_1.default,
      sCard: SCARD_1.default,
      SCRIPT_DEBUG: SCRIPT_DEBUG_1.default,
      scriptDebug: SCRIPT_DEBUG_1.default,
      SCRIPT_EXISTS: SCRIPT_EXISTS_1.default,
      scriptExists: SCRIPT_EXISTS_1.default,
      SCRIPT_FLUSH: SCRIPT_FLUSH_1.default,
      scriptFlush: SCRIPT_FLUSH_1.default,
      SCRIPT_KILL: SCRIPT_KILL_1.default,
      scriptKill: SCRIPT_KILL_1.default,
      SCRIPT_LOAD: SCRIPT_LOAD_1.default,
      scriptLoad: SCRIPT_LOAD_1.default,
      SDIFF: SDIFF_1.default,
      sDiff: SDIFF_1.default,
      SDIFFSTORE: SDIFFSTORE_1.default,
      sDiffStore: SDIFFSTORE_1.default,
      SET: SET_1.default,
      set: SET_1.default,
      SETBIT: SETBIT_1.default,
      setBit: SETBIT_1.default,
      SETEX: SETEX_1.default,
      setEx: SETEX_1.default,
      SETNX: SETNX_1.default,
      setNX: SETNX_1.default,
      SETRANGE: SETRANGE_1.default,
      setRange: SETRANGE_1.default,
      SINTER: SINTER_1.default,
      sInter: SINTER_1.default,
      SINTERCARD: SINTERCARD_1.default,
      sInterCard: SINTERCARD_1.default,
      SINTERSTORE: SINTERSTORE_1.default,
      sInterStore: SINTERSTORE_1.default,
      SISMEMBER: SISMEMBER_1.default,
      sIsMember: SISMEMBER_1.default,
      SMEMBERS: SMEMBERS_1.default,
      sMembers: SMEMBERS_1.default,
      SMISMEMBER: SMISMEMBER_1.default,
      smIsMember: SMISMEMBER_1.default,
      SMOVE: SMOVE_1.default,
      sMove: SMOVE_1.default,
      SORT_RO: SORT_RO_1.default,
      sortRo: SORT_RO_1.default,
      SORT_STORE: SORT_STORE_1.default,
      sortStore: SORT_STORE_1.default,
      SORT: SORT_1.default,
      sort: SORT_1.default,
      SPOP_COUNT: SPOP_COUNT_1.default,
      sPopCount: SPOP_COUNT_1.default,
      SPOP: SPOP_1.default,
      sPop: SPOP_1.default,
      SPUBLISH: SPUBLISH_1.default,
      sPublish: SPUBLISH_1.default,
      SRANDMEMBER_COUNT: SRANDMEMBER_COUNT_1.default,
      sRandMemberCount: SRANDMEMBER_COUNT_1.default,
      SRANDMEMBER: SRANDMEMBER_1.default,
      sRandMember: SRANDMEMBER_1.default,
      SREM: SREM_1.default,
      sRem: SREM_1.default,
      SSCAN: SSCAN_1.default,
      sScan: SSCAN_1.default,
      STRLEN: STRLEN_1.default,
      strLen: STRLEN_1.default,
      SUNION: SUNION_1.default,
      sUnion: SUNION_1.default,
      SUNIONSTORE: SUNIONSTORE_1.default,
      sUnionStore: SUNIONSTORE_1.default,
      SWAPDB: SWAPDB_1.default,
      swapDb: SWAPDB_1.default,
      TIME: TIME_1.default,
      time: TIME_1.default,
      TOUCH: TOUCH_1.default,
      touch: TOUCH_1.default,
      TTL: TTL_1.default,
      ttl: TTL_1.default,
      TYPE: TYPE_1.default,
      type: TYPE_1.default,
      UNLINK: UNLINK_1.default,
      unlink: UNLINK_1.default,
      WAIT: WAIT_1.default,
      wait: WAIT_1.default,
      XACK: XACK_1.default,
      xAck: XACK_1.default,
      XACKDEL: XACKDEL_1.default,
      xAckDel: XACKDEL_1.default,
      XADD_NOMKSTREAM: XADD_NOMKSTREAM_1.default,
      xAddNoMkStream: XADD_NOMKSTREAM_1.default,
      XADD: XADD_1.default,
      xAdd: XADD_1.default,
      XAUTOCLAIM_JUSTID: XAUTOCLAIM_JUSTID_1.default,
      xAutoClaimJustId: XAUTOCLAIM_JUSTID_1.default,
      XAUTOCLAIM: XAUTOCLAIM_1.default,
      xAutoClaim: XAUTOCLAIM_1.default,
      XCLAIM_JUSTID: XCLAIM_JUSTID_1.default,
      xClaimJustId: XCLAIM_JUSTID_1.default,
      XCLAIM: XCLAIM_1.default,
      xClaim: XCLAIM_1.default,
      XDEL: XDEL_1.default,
      xDel: XDEL_1.default,
      XDELEX: XDELEX_1.default,
      xDelEx: XDELEX_1.default,
      XGROUP_CREATE: XGROUP_CREATE_1.default,
      xGroupCreate: XGROUP_CREATE_1.default,
      XGROUP_CREATECONSUMER: XGROUP_CREATECONSUMER_1.default,
      xGroupCreateConsumer: XGROUP_CREATECONSUMER_1.default,
      XGROUP_DELCONSUMER: XGROUP_DELCONSUMER_1.default,
      xGroupDelConsumer: XGROUP_DELCONSUMER_1.default,
      XGROUP_DESTROY: XGROUP_DESTROY_1.default,
      xGroupDestroy: XGROUP_DESTROY_1.default,
      XGROUP_SETID: XGROUP_SETID_1.default,
      xGroupSetId: XGROUP_SETID_1.default,
      XINFO_CONSUMERS: XINFO_CONSUMERS_1.default,
      xInfoConsumers: XINFO_CONSUMERS_1.default,
      XINFO_GROUPS: XINFO_GROUPS_1.default,
      xInfoGroups: XINFO_GROUPS_1.default,
      XINFO_STREAM: XINFO_STREAM_1.default,
      xInfoStream: XINFO_STREAM_1.default,
      XLEN: XLEN_1.default,
      xLen: XLEN_1.default,
      XPENDING_RANGE: XPENDING_RANGE_1.default,
      xPendingRange: XPENDING_RANGE_1.default,
      XPENDING: XPENDING_1.default,
      xPending: XPENDING_1.default,
      XRANGE: XRANGE_1.default,
      xRange: XRANGE_1.default,
      XREAD: XREAD_1.default,
      xRead: XREAD_1.default,
      XREADGROUP: XREADGROUP_1.default,
      xReadGroup: XREADGROUP_1.default,
      XREVRANGE: XREVRANGE_1.default,
      xRevRange: XREVRANGE_1.default,
      XSETID: XSETID_1.default,
      xSetId: XSETID_1.default,
      XTRIM: XTRIM_1.default,
      xTrim: XTRIM_1.default,
      ZADD_INCR: ZADD_INCR_1.default,
      zAddIncr: ZADD_INCR_1.default,
      ZADD: ZADD_1.default,
      zAdd: ZADD_1.default,
      ZCARD: ZCARD_1.default,
      zCard: ZCARD_1.default,
      ZCOUNT: ZCOUNT_1.default,
      zCount: ZCOUNT_1.default,
      ZDIFF_WITHSCORES: ZDIFF_WITHSCORES_1.default,
      zDiffWithScores: ZDIFF_WITHSCORES_1.default,
      ZDIFF: ZDIFF_1.default,
      zDiff: ZDIFF_1.default,
      ZDIFFSTORE: ZDIFFSTORE_1.default,
      zDiffStore: ZDIFFSTORE_1.default,
      ZINCRBY: ZINCRBY_1.default,
      zIncrBy: ZINCRBY_1.default,
      ZINTER_WITHSCORES: ZINTER_WITHSCORES_1.default,
      zInterWithScores: ZINTER_WITHSCORES_1.default,
      ZINTER: ZINTER_1.default,
      zInter: ZINTER_1.default,
      ZINTERCARD: ZINTERCARD_1.default,
      zInterCard: ZINTERCARD_1.default,
      ZINTERSTORE: ZINTERSTORE_1.default,
      zInterStore: ZINTERSTORE_1.default,
      ZLEXCOUNT: ZLEXCOUNT_1.default,
      zLexCount: ZLEXCOUNT_1.default,
      ZMPOP: ZMPOP_1.default,
      zmPop: ZMPOP_1.default,
      ZMSCORE: ZMSCORE_1.default,
      zmScore: ZMSCORE_1.default,
      ZPOPMAX_COUNT: ZPOPMAX_COUNT_1.default,
      zPopMaxCount: ZPOPMAX_COUNT_1.default,
      ZPOPMAX: ZPOPMAX_1.default,
      zPopMax: ZPOPMAX_1.default,
      ZPOPMIN_COUNT: ZPOPMIN_COUNT_1.default,
      zPopMinCount: ZPOPMIN_COUNT_1.default,
      ZPOPMIN: ZPOPMIN_1.default,
      zPopMin: ZPOPMIN_1.default,
      ZRANDMEMBER_COUNT_WITHSCORES: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
      zRandMemberCountWithScores: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
      ZRANDMEMBER_COUNT: ZRANDMEMBER_COUNT_1.default,
      zRandMemberCount: ZRANDMEMBER_COUNT_1.default,
      ZRANDMEMBER: ZRANDMEMBER_1.default,
      zRandMember: ZRANDMEMBER_1.default,
      ZRANGE_WITHSCORES: ZRANGE_WITHSCORES_1.default,
      zRangeWithScores: ZRANGE_WITHSCORES_1.default,
      ZRANGE: ZRANGE_1.default,
      zRange: ZRANGE_1.default,
      ZRANGEBYLEX: ZRANGEBYLEX_1.default,
      zRangeByLex: ZRANGEBYLEX_1.default,
      ZRANGEBYSCORE_WITHSCORES: ZRANGEBYSCORE_WITHSCORES_1.default,
      zRangeByScoreWithScores: ZRANGEBYSCORE_WITHSCORES_1.default,
      ZRANGEBYSCORE: ZRANGEBYSCORE_1.default,
      zRangeByScore: ZRANGEBYSCORE_1.default,
      ZRANGESTORE: ZRANGESTORE_1.default,
      zRangeStore: ZRANGESTORE_1.default,
      ZRANK_WITHSCORE: ZRANK_WITHSCORE_1.default,
      zRankWithScore: ZRANK_WITHSCORE_1.default,
      ZRANK: ZRANK_1.default,
      zRank: ZRANK_1.default,
      ZREM: ZREM_1.default,
      zRem: ZREM_1.default,
      ZREMRANGEBYLEX: ZREMRANGEBYLEX_1.default,
      zRemRangeByLex: ZREMRANGEBYLEX_1.default,
      ZREMRANGEBYRANK: ZREMRANGEBYRANK_1.default,
      zRemRangeByRank: ZREMRANGEBYRANK_1.default,
      ZREMRANGEBYSCORE: ZREMRANGEBYSCORE_1.default,
      zRemRangeByScore: ZREMRANGEBYSCORE_1.default,
      ZREVRANK: ZREVRANK_1.default,
      zRevRank: ZREVRANK_1.default,
      ZSCAN: ZSCAN_1.default,
      zScan: ZSCAN_1.default,
      ZSCORE: ZSCORE_1.default,
      zScore: ZSCORE_1.default,
      ZUNION_WITHSCORES: ZUNION_WITHSCORES_1.default,
      zUnionWithScores: ZUNION_WITHSCORES_1.default,
      ZUNION: ZUNION_1.default,
      zUnion: ZUNION_1.default,
      ZUNIONSTORE: ZUNIONSTORE_1.default,
      zUnionStore: ZUNIONSTORE_1.default,
      VADD: VADD_1.default,
      vAdd: VADD_1.default,
      VCARD: VCARD_1.default,
      vCard: VCARD_1.default,
      VDIM: VDIM_1.default,
      vDim: VDIM_1.default,
      VEMB: VEMB_1.default,
      vEmb: VEMB_1.default,
      VEMB_RAW: VEMB_RAW_1.default,
      vEmbRaw: VEMB_RAW_1.default,
      VGETATTR: VGETATTR_1.default,
      vGetAttr: VGETATTR_1.default,
      VINFO: VINFO_1.default,
      vInfo: VINFO_1.default,
      VLINKS: VLINKS_1.default,
      vLinks: VLINKS_1.default,
      VLINKS_WITHSCORES: VLINKS_WITHSCORES_1.default,
      vLinksWithScores: VLINKS_WITHSCORES_1.default,
      VRANDMEMBER: VRANDMEMBER_1.default,
      vRandMember: VRANDMEMBER_1.default,
      VREM: VREM_1.default,
      vRem: VREM_1.default,
      VSETATTR: VSETATTR_1.default,
      vSetAttr: VSETATTR_1.default,
      VSIM: VSIM_1.default,
      vSim: VSIM_1.default,
      VSIM_WITHSCORES: VSIM_WITHSCORES_1.default,
      vSimWithScores: VSIM_WITHSCORES_1.default
    };
  }
});
var require_enterprise_maintenance_manager = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/enterprise-maintenance-manager.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.emitDiagnostics = exports.dbgMaintenance = exports.MAINTENANCE_EVENTS = void 0;
    var net_1 = __require2("net");
    var promises_1 = __require2("dns/promises");
    var node_assert_1 = __importDefault(__require2("node:assert"));
    var promises_2 = __require2("node:timers/promises");
    var node_diagnostics_channel_1 = __importDefault(__require2("node:diagnostics_channel"));
    exports.MAINTENANCE_EVENTS = {
      PAUSE_WRITING: "pause-writing",
      RESUME_WRITING: "resume-writing",
      TIMEOUTS_UPDATE: "timeouts-update"
    };
    var PN = {
      MOVING: "MOVING",
      MIGRATING: "MIGRATING",
      MIGRATED: "MIGRATED",
      FAILING_OVER: "FAILING_OVER",
      FAILED_OVER: "FAILED_OVER"
    };
    var dbgMaintenance = (...args) => {
      if (!process.env.REDIS_DEBUG_MAINTENANCE)
        return;
      return console.log("[MNT]", ...args);
    };
    exports.dbgMaintenance = dbgMaintenance;
    var emitDiagnostics = (event) => {
      if (!process.env.REDIS_EMIT_DIAGNOSTICS)
        return;
      const channel = node_diagnostics_channel_1.default.channel("redis.maintenance");
      channel.publish(event);
    };
    exports.emitDiagnostics = emitDiagnostics;
    var EnterpriseMaintenanceManager = class {
      #commandsQueue;
      #options;
      #isMaintenance = 0;
      #client;
      static setupDefaultMaintOptions(options2) {
        if (options2.maintNotifications === void 0) {
          options2.maintNotifications = options2?.RESP === 3 ? "auto" : "disabled";
        }
        if (options2.maintEndpointType === void 0) {
          options2.maintEndpointType = "auto";
        }
        if (options2.maintRelaxedSocketTimeout === void 0) {
          options2.maintRelaxedSocketTimeout = 1e4;
        }
        if (options2.maintRelaxedCommandTimeout === void 0) {
          options2.maintRelaxedCommandTimeout = 1e4;
        }
      }
      static async getHandshakeCommand(options2) {
        if (options2.maintNotifications === "disabled")
          return;
        const host = options2.url ? new URL(options2.url).hostname : options2.socket?.host;
        if (!host)
          return;
        const tls = options2.socket?.tls ?? false;
        const movingEndpointType = await determineEndpoint(tls, host, options2);
        return {
          cmd: [
            "CLIENT",
            "MAINT_NOTIFICATIONS",
            "ON",
            "moving-endpoint-type",
            movingEndpointType
          ],
          errorHandler: (error) => {
            (0, exports.dbgMaintenance)("handshake failed:", error);
            if (options2.maintNotifications === "enabled") {
              throw error;
            }
          }
        };
      }
      constructor(commandsQueue, client, options2) {
        this.#commandsQueue = commandsQueue;
        this.#options = options2;
        this.#client = client;
        this.#commandsQueue.addPushHandler(this.#onPush);
      }
      #onPush = (push) => {
        (0, exports.dbgMaintenance)("ONPUSH:", push.map(String));
        if (!Array.isArray(push) || !["MOVING", "MIGRATING", "MIGRATED", "FAILING_OVER", "FAILED_OVER"].includes(String(push[0]))) {
          return false;
        }
        const type = String(push[0]);
        (0, exports.emitDiagnostics)({
          type,
          timestamp: Date.now(),
          data: {
            push: push.map(String)
          }
        });
        switch (type) {
          case PN.MOVING: {
            const afterSeconds = push[2];
            const url = push[3] ? String(push[3]) : null;
            (0, exports.dbgMaintenance)("Received MOVING:", afterSeconds, url);
            this.#onMoving(afterSeconds, url);
            return true;
          }
          case PN.MIGRATING:
          case PN.FAILING_OVER: {
            (0, exports.dbgMaintenance)("Received MIGRATING|FAILING_OVER");
            this.#onMigrating();
            return true;
          }
          case PN.MIGRATED:
          case PN.FAILED_OVER: {
            (0, exports.dbgMaintenance)("Received MIGRATED|FAILED_OVER");
            this.#onMigrated();
            return true;
          }
        }
        return false;
      };
      //  Queue:
      //     toWrite [ C D E ]
      //     waitingForReply [ A B ]   - aka In-flight commands
      //
      //  time: ---1-2---3-4-5-6---------------------------
      //
      //  1. [EVENT] MOVING PN received
      //  2. [ACTION] Pause writing ( we need to wait for new socket to connect and for all in-flight commands to complete )
      //  3. [EVENT] New socket connected
      //  4. [EVENT] In-flight commands completed
      //  5. [ACTION] Destroy old socket
      //  6. [ACTION] Resume writing -> we are going to write to the new socket from now on
      #onMoving = async (afterSeconds, url) => {
        this.#onMigrating();
        let host;
        let port;
        if (url === null) {
          (0, node_assert_1.default)(this.#options.maintEndpointType === "none");
          (0, node_assert_1.default)(this.#options.socket !== void 0);
          (0, node_assert_1.default)("host" in this.#options.socket);
          (0, node_assert_1.default)(typeof this.#options.socket.host === "string");
          host = this.#options.socket.host;
          (0, node_assert_1.default)(typeof this.#options.socket.port === "number");
          port = this.#options.socket.port;
          const waitTime = afterSeconds * 1e3 / 2;
          (0, exports.dbgMaintenance)(`Wait for ${waitTime}ms`);
          await (0, promises_2.setTimeout)(waitTime);
        } else {
          const split = url.split(":");
          host = split[0];
          port = Number(split[1]);
        }
        (0, exports.dbgMaintenance)("Pausing writing of new commands to old socket");
        this.#client._pause();
        (0, exports.dbgMaintenance)("Creating new tmp client");
        let start = performance.now();
        if (this.#options.url) {
          const u2 = new URL(this.#options.url);
          u2.hostname = host;
          u2.port = String(port);
          this.#options.url = u2.toString();
        } else {
          this.#options.socket = {
            ...this.#options.socket,
            host,
            port
          };
        }
        const tmpClient = this.#client.duplicate();
        tmpClient.on("error", (error) => {
          (0, exports.dbgMaintenance)(`[ERR]`, error);
        });
        (0, exports.dbgMaintenance)(`Tmp client created in ${(performance.now() - start).toFixed(2)}ms`);
        (0, exports.dbgMaintenance)(`Set timeout for tmp client to ${this.#options.maintRelaxedSocketTimeout}`);
        tmpClient._maintenanceUpdate({
          relaxedCommandTimeout: this.#options.maintRelaxedCommandTimeout,
          relaxedSocketTimeout: this.#options.maintRelaxedSocketTimeout
        });
        (0, exports.dbgMaintenance)(`Connecting tmp client: ${host}:${port}`);
        start = performance.now();
        await tmpClient.connect();
        (0, exports.dbgMaintenance)(`Connected to tmp client in ${(performance.now() - start).toFixed(2)}ms`);
        (0, exports.dbgMaintenance)(`Wait for all in-flight commands to complete`);
        await this.#commandsQueue.waitForInflightCommandsToComplete();
        (0, exports.dbgMaintenance)(`In-flight commands completed`);
        (0, exports.dbgMaintenance)("Swap client sockets...");
        const oldSocket = this.#client._ejectSocket();
        const newSocket = tmpClient._ejectSocket();
        this.#client._insertSocket(newSocket);
        tmpClient._insertSocket(oldSocket);
        tmpClient.destroy();
        (0, exports.dbgMaintenance)("Swap client sockets done.");
        (0, exports.dbgMaintenance)("Resume writing");
        this.#client._unpause();
        this.#onMigrated();
      };
      #onMigrating = () => {
        this.#isMaintenance++;
        if (this.#isMaintenance > 1) {
          (0, exports.dbgMaintenance)(`Timeout relaxation already done`);
          return;
        }
        const update = {
          relaxedCommandTimeout: this.#options.maintRelaxedCommandTimeout,
          relaxedSocketTimeout: this.#options.maintRelaxedSocketTimeout
        };
        this.#client._maintenanceUpdate(update);
      };
      #onMigrated = () => {
        this.#isMaintenance = Math.max(this.#isMaintenance - 1, 0);
        if (this.#isMaintenance > 0) {
          (0, exports.dbgMaintenance)(`Not ready to unrelax timeouts yet`);
          return;
        }
        const update = {
          relaxedCommandTimeout: void 0,
          relaxedSocketTimeout: void 0
        };
        this.#client._maintenanceUpdate(update);
      };
    };
    exports.default = EnterpriseMaintenanceManager;
    function isPrivateIP(ip) {
      const version = (0, net_1.isIP)(ip);
      if (version === 4) {
        const octets = ip.split(".").map(Number);
        return octets[0] === 10 || octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31 || octets[0] === 192 && octets[1] === 168;
      }
      if (version === 6) {
        return ip.startsWith("fc") || // Unique local
        ip.startsWith("fd") || // Unique local
        ip === "::1" || // Loopback
        ip.startsWith("fe80");
      }
      return false;
    }
    async function determineEndpoint(tlsEnabled, host, options2) {
      (0, node_assert_1.default)(options2.maintEndpointType !== void 0);
      if (options2.maintEndpointType !== "auto") {
        (0, exports.dbgMaintenance)(`Determine endpoint type: ${options2.maintEndpointType}`);
        return options2.maintEndpointType;
      }
      const ip = (0, net_1.isIP)(host) ? host : (await (0, promises_1.lookup)(host, { family: 0 })).address;
      const isPrivate = isPrivateIP(ip);
      let result;
      if (tlsEnabled) {
        result = isPrivate ? "internal-fqdn" : "external-fqdn";
      } else {
        result = isPrivate ? "internal-ip" : "external-ip";
      }
      (0, exports.dbgMaintenance)(`Determine endpoint type: ${result}`);
      return result;
    }
  }
});
var require_socket = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/socket.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_events_1 = __require2("node:events");
    var node_net_1 = __importDefault(__require2("node:net"));
    var node_tls_1 = __importDefault(__require2("node:tls"));
    var errors_1 = require_errors();
    var promises_1 = __require2("node:timers/promises");
    var enterprise_maintenance_manager_1 = require_enterprise_maintenance_manager();
    var RedisSocket = class extends node_events_1.EventEmitter {
      #initiator;
      #connectTimeout;
      #reconnectStrategy;
      #socketFactory;
      #socketTimeout;
      #maintenanceTimeout;
      #socket;
      #isOpen = false;
      get isOpen() {
        return this.#isOpen;
      }
      #isReady = false;
      get isReady() {
        return this.#isReady;
      }
      #isSocketUnrefed = false;
      #socketEpoch = 0;
      get socketEpoch() {
        return this.#socketEpoch;
      }
      constructor(initiator, options2) {
        super();
        this.#initiator = initiator;
        this.#connectTimeout = options2?.connectTimeout ?? 5e3;
        this.#reconnectStrategy = this.#createReconnectStrategy(options2);
        this.#socketFactory = this.#createSocketFactory(options2);
        this.#socketTimeout = options2?.socketTimeout;
      }
      #createReconnectStrategy(options2) {
        const strategy = options2?.reconnectStrategy;
        if (strategy === false || typeof strategy === "number") {
          return () => strategy;
        }
        if (strategy) {
          return (retries, cause) => {
            try {
              const retryIn = strategy(retries, cause);
              if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== "number") {
                throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
              }
              return retryIn;
            } catch (err) {
              this.emit("error", err);
              return this.defaultReconnectStrategy(retries, err);
            }
          };
        }
        return this.defaultReconnectStrategy;
      }
      #createSocketFactory(options2) {
        if (options2?.tls === true) {
          const withDefaults2 = {
            ...options2,
            port: options2?.port ?? 6379,
            // https://nodejs.org/api/tls.html#tlsconnectoptions-callback "Any socket.connect() option not already listed"
            // @types/node is... incorrect...
            // @ts-expect-error
            noDelay: options2?.noDelay ?? true,
            // https://nodejs.org/api/tls.html#tlsconnectoptions-callback "Any socket.connect() option not already listed"
            // @types/node is... incorrect...
            // @ts-expect-error
            keepAlive: options2?.keepAlive ?? true,
            // https://nodejs.org/api/tls.html#tlsconnectoptions-callback "Any socket.connect() option not already listed"
            // @types/node is... incorrect...
            // @ts-expect-error
            keepAliveInitialDelay: options2?.keepAliveInitialDelay ?? 5e3,
            timeout: void 0,
            onread: void 0,
            readable: true,
            writable: true
          };
          return {
            create() {
              return node_tls_1.default.connect(withDefaults2);
            },
            event: "secureConnect"
          };
        }
        if (options2 && "path" in options2) {
          const withDefaults2 = {
            ...options2,
            timeout: void 0,
            onread: void 0,
            readable: true,
            writable: true
          };
          return {
            create() {
              return node_net_1.default.createConnection(withDefaults2);
            },
            event: "connect"
          };
        }
        const withDefaults = {
          ...options2,
          port: options2?.port ?? 6379,
          noDelay: options2?.noDelay ?? true,
          keepAlive: options2?.keepAlive ?? true,
          keepAliveInitialDelay: options2?.keepAliveInitialDelay ?? 5e3,
          timeout: void 0,
          onread: void 0,
          readable: true,
          writable: true
        };
        return {
          create() {
            return node_net_1.default.createConnection(withDefaults);
          },
          event: "connect"
        };
      }
      #shouldReconnect(retries, cause) {
        const retryIn = this.#reconnectStrategy(retries, cause);
        if (retryIn === false) {
          this.#isOpen = false;
          this.emit("error", cause);
          return cause;
        } else if (retryIn instanceof Error) {
          this.#isOpen = false;
          this.emit("error", cause);
          return new errors_1.ReconnectStrategyError(retryIn, cause);
        }
        return retryIn;
      }
      async connect() {
        if (this.#isOpen) {
          throw new Error("Socket already opened");
        }
        this.#isOpen = true;
        return this.#connect();
      }
      async #connect() {
        let retries = 0;
        do {
          try {
            this.#socket = await this.#createSocket();
            this.emit("connect");
            try {
              await this.#initiator();
            } catch (err) {
              this.#socket.destroy();
              this.#socket = void 0;
              throw err;
            }
            this.#isReady = true;
            this.#socketEpoch++;
            this.emit("ready");
          } catch (err) {
            const retryIn = this.#shouldReconnect(retries++, err);
            if (typeof retryIn !== "number") {
              throw retryIn;
            }
            this.emit("error", err);
            await (0, promises_1.setTimeout)(retryIn);
            this.emit("reconnecting");
          }
        } while (this.#isOpen && !this.#isReady);
      }
      setMaintenanceTimeout(ms) {
        (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Set socket timeout to ${ms}`);
        if (this.#maintenanceTimeout === ms) {
          (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Socket already set maintenanceCommandTimeout to ${ms}, skipping`);
          return;
        }
        ;
        this.#maintenanceTimeout = ms;
        if (ms !== void 0) {
          this.#socket?.setTimeout(ms);
        } else {
          this.#socket?.setTimeout(this.#socketTimeout ?? 0);
        }
      }
      async #createSocket() {
        const socket = this.#socketFactory.create();
        let onTimeout;
        if (this.#connectTimeout !== void 0) {
          onTimeout = () => socket.destroy(new errors_1.ConnectionTimeoutError());
          socket.once("timeout", onTimeout);
          socket.setTimeout(this.#connectTimeout);
        }
        if (this.#isSocketUnrefed) {
          socket.unref();
        }
        await (0, node_events_1.once)(socket, this.#socketFactory.event);
        if (onTimeout) {
          socket.removeListener("timeout", onTimeout);
        }
        if (this.#socketTimeout) {
          socket.once("timeout", () => {
            const error = this.#maintenanceTimeout ? new errors_1.SocketTimeoutDuringMaintenanceError(this.#maintenanceTimeout) : new errors_1.SocketTimeoutError(this.#socketTimeout);
            socket.destroy(error);
          });
          socket.setTimeout(this.#socketTimeout);
        }
        socket.once("error", (err) => this.#onSocketError(err)).once("close", (hadError) => {
          if (hadError || !this.#isOpen || this.#socket !== socket)
            return;
          this.#onSocketError(new errors_1.SocketClosedUnexpectedlyError());
        }).on("drain", () => this.emit("drain")).on("data", (data) => this.emit("data", data));
        return socket;
      }
      #onSocketError(err) {
        const wasReady = this.#isReady;
        this.#isReady = false;
        this.emit("error", err);
        if (!wasReady || !this.#isOpen || typeof this.#shouldReconnect(0, err) !== "number")
          return;
        this.emit("reconnecting");
        this.#connect().catch(() => {
        });
      }
      write(iterable) {
        if (!this.#socket)
          return;
        this.#socket.cork();
        for (const args of iterable) {
          for (const toWrite of args) {
            this.#socket.write(toWrite);
          }
          if (this.#socket.writableNeedDrain)
            break;
        }
        this.#socket.uncork();
      }
      async quit(fn) {
        if (!this.#isOpen) {
          throw new errors_1.ClientClosedError();
        }
        this.#isOpen = false;
        const reply = await fn();
        this.destroySocket();
        return reply;
      }
      close() {
        if (!this.#isOpen) {
          throw new errors_1.ClientClosedError();
        }
        this.#isOpen = false;
      }
      destroy() {
        if (!this.#isOpen) {
          throw new errors_1.ClientClosedError();
        }
        this.#isOpen = false;
        this.destroySocket();
      }
      destroySocket() {
        this.#isReady = false;
        if (this.#socket) {
          this.#socket.destroy();
          this.#socket = void 0;
        }
        this.emit("end");
      }
      ref() {
        this.#isSocketUnrefed = false;
        this.#socket?.ref();
      }
      unref() {
        this.#isSocketUnrefed = true;
        this.#socket?.unref();
      }
      defaultReconnectStrategy(retries, cause) {
        if (cause instanceof errors_1.SocketTimeoutError) {
          return false;
        }
        const jitter = Math.floor(Math.random() * 200);
        const delay2 = Math.min(Math.pow(2, retries) * 50, 2e3);
        return delay2 + jitter;
      }
    };
    exports.default = RedisSocket;
  }
});
var require_token = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/authx/token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Token = void 0;
    var Token = class {
      value;
      expiresAtMs;
      receivedAtMs;
      constructor(value, expiresAtMs, receivedAtMs) {
        this.value = value;
        this.expiresAtMs = expiresAtMs;
        this.receivedAtMs = receivedAtMs;
      }
      /**
       * Returns the time-to-live of the token in milliseconds.
       * @param now The current time in milliseconds since the Unix epoch.
       */
      getTtlMs(now) {
        if (this.expiresAtMs < now) {
          return 0;
        }
        return this.expiresAtMs - now;
      }
    };
    exports.Token = Token;
  }
});
var require_token_manager = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/authx/token-manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenManager = exports.IDPError = void 0;
    var token_1 = require_token();
    var IDPError = class extends Error {
      message;
      isRetryable;
      constructor(message, isRetryable) {
        super(message);
        this.message = message;
        this.isRetryable = isRetryable;
        this.name = "IDPError";
      }
    };
    exports.IDPError = IDPError;
    var TokenManager = class {
      identityProvider;
      config;
      currentToken = null;
      refreshTimeout = null;
      listener = null;
      retryAttempt = 0;
      constructor(identityProvider, config) {
        this.identityProvider = identityProvider;
        this.config = config;
        if (this.config.expirationRefreshRatio > 1) {
          throw new Error("expirationRefreshRatio must be less than or equal to 1");
        }
        if (this.config.expirationRefreshRatio < 0) {
          throw new Error("expirationRefreshRatio must be greater or equal to 0");
        }
      }
      /**
       * Starts the token manager and returns a Disposable that can be used to stop the token manager.
       *
       * @param listener The listener that will receive token updates.
       * @param initialDelayMs The initial delay in milliseconds before the first token refresh.
       */
      start(listener, initialDelayMs = 0) {
        if (this.listener) {
          this.stop();
        }
        this.listener = listener;
        this.retryAttempt = 0;
        this.scheduleNextRefresh(initialDelayMs);
        return {
          dispose: () => this.stop()
        };
      }
      calculateRetryDelay() {
        if (!this.config.retry)
          return 0;
        const { initialDelayMs, maxDelayMs, backoffMultiplier, jitterPercentage } = this.config.retry;
        let delay2 = initialDelayMs * Math.pow(backoffMultiplier, this.retryAttempt - 1);
        delay2 = Math.min(delay2, maxDelayMs);
        if (jitterPercentage) {
          const jitterRange = delay2 * (jitterPercentage / 100);
          const jitterAmount = Math.random() * jitterRange - jitterRange / 2;
          delay2 += jitterAmount;
        }
        let result = Math.max(0, Math.floor(delay2));
        return result;
      }
      shouldRetry(error) {
        if (!this.config.retry)
          return false;
        const { maxAttempts, isRetryable } = this.config.retry;
        if (this.retryAttempt >= maxAttempts) {
          return false;
        }
        if (isRetryable) {
          return isRetryable(error, this.retryAttempt);
        }
        return false;
      }
      isRunning() {
        return this.listener !== null;
      }
      async refresh() {
        if (!this.listener) {
          throw new Error("TokenManager is not running, but refresh was called");
        }
        try {
          await this.identityProvider.requestToken().then(this.handleNewToken);
          this.retryAttempt = 0;
        } catch (error) {
          if (this.shouldRetry(error)) {
            this.retryAttempt++;
            const retryDelay = this.calculateRetryDelay();
            this.notifyError(`Token refresh failed (attempt ${this.retryAttempt}), retrying in ${retryDelay}ms: ${error}`, true);
            this.scheduleNextRefresh(retryDelay);
          } else {
            this.notifyError(error, false);
            this.stop();
          }
        }
      }
      handleNewToken = async ({ token: nativeToken, ttlMs }) => {
        if (!this.listener) {
          throw new Error("TokenManager is not running, but a new token was received");
        }
        const token = this.wrapAndSetCurrentToken(nativeToken, ttlMs);
        this.listener.onNext(token);
        this.scheduleNextRefresh(this.calculateRefreshTime(token));
      };
      /**
       * Creates a Token object from a native token and sets it as the current token.
       *
       * @param nativeToken - The raw token received from the identity provider
       * @param ttlMs - Time-to-live in milliseconds for the token
       *
       * @returns A new Token instance containing the wrapped native token and expiration details
       *
       */
      wrapAndSetCurrentToken(nativeToken, ttlMs) {
        const now = Date.now();
        const token = new token_1.Token(nativeToken, now + ttlMs, now);
        this.currentToken = token;
        return token;
      }
      scheduleNextRefresh(delayMs) {
        if (this.refreshTimeout) {
          clearTimeout(this.refreshTimeout);
          this.refreshTimeout = null;
        }
        if (delayMs === 0) {
          this.refresh();
        } else {
          this.refreshTimeout = setTimeout(() => this.refresh(), delayMs);
        }
      }
      /**
       * Calculates the time in milliseconds when the token should be refreshed
       * based on the token's TTL and the expirationRefreshRatio configuration.
       *
       * @param token The token to calculate the refresh time for.
       * @param now The current time in milliseconds. Defaults to Date.now().
       */
      calculateRefreshTime(token, now = Date.now()) {
        const ttlMs = token.getTtlMs(now);
        return Math.floor(ttlMs * this.config.expirationRefreshRatio);
      }
      stop() {
        if (this.refreshTimeout) {
          clearTimeout(this.refreshTimeout);
          this.refreshTimeout = null;
        }
        this.listener = null;
        this.currentToken = null;
        this.retryAttempt = 0;
      }
      /**
       * Returns the current token or null if no token is available.
       */
      getCurrentToken() {
        return this.currentToken;
      }
      notifyError(error, isRetryable) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (!this.listener) {
          throw new Error(`TokenManager is not running but received an error: ${errorMessage}`);
        }
        this.listener.onError(new IDPError(errorMessage, isRetryable));
      }
    };
    exports.TokenManager = TokenManager;
  }
});
var require_credentials_provider = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/authx/credentials-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnableToObtainNewCredentialsError = exports.CredentialsError = void 0;
    var CredentialsError = class extends Error {
      constructor(message) {
        super(`Re-authentication with latest credentials failed: ${message}`);
        this.name = "CredentialsError";
      }
    };
    exports.CredentialsError = CredentialsError;
    var UnableToObtainNewCredentialsError = class extends Error {
      constructor(message) {
        super(`Unable to obtain new credentials : ${message}`);
        this.name = "UnableToObtainNewCredentialsError";
      }
    };
    exports.UnableToObtainNewCredentialsError = UnableToObtainNewCredentialsError;
  }
});
var require_authx = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/authx/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Token = exports.CredentialsError = exports.UnableToObtainNewCredentialsError = exports.IDPError = exports.TokenManager = void 0;
    var token_manager_1 = require_token_manager();
    Object.defineProperty(exports, "TokenManager", { enumerable: true, get: function() {
      return token_manager_1.TokenManager;
    } });
    Object.defineProperty(exports, "IDPError", { enumerable: true, get: function() {
      return token_manager_1.IDPError;
    } });
    var credentials_provider_1 = require_credentials_provider();
    Object.defineProperty(exports, "UnableToObtainNewCredentialsError", { enumerable: true, get: function() {
      return credentials_provider_1.UnableToObtainNewCredentialsError;
    } });
    Object.defineProperty(exports, "CredentialsError", { enumerable: true, get: function() {
      return credentials_provider_1.CredentialsError;
    } });
    var token_1 = require_token();
    Object.defineProperty(exports, "Token", { enumerable: true, get: function() {
      return token_1.Token;
    } });
  }
});
var require_linked_list = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/linked-list.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptyAwareSinglyLinkedList = exports.SinglyLinkedList = exports.DoublyLinkedList = void 0;
    var events_1 = __importDefault(__require2("events"));
    var DoublyLinkedList = class {
      #length = 0;
      get length() {
        return this.#length;
      }
      #head;
      get head() {
        return this.#head;
      }
      #tail;
      get tail() {
        return this.#tail;
      }
      push(value) {
        ++this.#length;
        if (this.#tail === void 0) {
          return this.#head = this.#tail = {
            previous: this.#head,
            next: void 0,
            value
          };
        }
        return this.#tail = this.#tail.next = {
          previous: this.#tail,
          next: void 0,
          value
        };
      }
      unshift(value) {
        ++this.#length;
        if (this.#head === void 0) {
          return this.#head = this.#tail = {
            previous: void 0,
            next: void 0,
            value
          };
        }
        return this.#head = this.#head.previous = {
          previous: void 0,
          next: this.#head,
          value
        };
      }
      add(value, prepend = false) {
        return prepend ? this.unshift(value) : this.push(value);
      }
      shift() {
        if (this.#head === void 0)
          return void 0;
        --this.#length;
        const node = this.#head;
        if (node.next) {
          node.next.previous = void 0;
          this.#head = node.next;
          node.next = void 0;
        } else {
          this.#head = this.#tail = void 0;
        }
        return node.value;
      }
      remove(node) {
        if (this.#length === 0)
          return;
        --this.#length;
        if (this.#tail === node) {
          this.#tail = node.previous;
        }
        if (this.#head === node) {
          this.#head = node.next;
        } else {
          if (node.previous) {
            node.previous.next = node.next;
          }
          if (node.next) {
            node.next.previous = node.previous;
          }
        }
        node.previous = void 0;
        node.next = void 0;
      }
      reset() {
        this.#length = 0;
        this.#head = this.#tail = void 0;
      }
      *[Symbol.iterator]() {
        let node = this.#head;
        while (node !== void 0) {
          yield node.value;
          node = node.next;
        }
      }
      *nodes() {
        let node = this.#head;
        while (node) {
          const next = node.next;
          yield node;
          node = next;
        }
      }
    };
    exports.DoublyLinkedList = DoublyLinkedList;
    var SinglyLinkedList = class {
      #length = 0;
      get length() {
        return this.#length;
      }
      #head;
      get head() {
        return this.#head;
      }
      #tail;
      get tail() {
        return this.#tail;
      }
      push(value) {
        ++this.#length;
        const node = {
          value,
          next: void 0,
          removed: false
        };
        if (this.#head === void 0) {
          return this.#head = this.#tail = node;
        }
        return this.#tail.next = this.#tail = node;
      }
      remove(node, parent) {
        if (node.removed) {
          throw new Error("node already removed");
        }
        --this.#length;
        if (this.#head === node) {
          if (this.#tail === node) {
            this.#head = this.#tail = void 0;
          } else {
            this.#head = node.next;
          }
        } else if (this.#tail === node) {
          this.#tail = parent;
          parent.next = void 0;
        } else {
          parent.next = node.next;
        }
        node.removed = true;
      }
      shift() {
        if (this.#head === void 0)
          return void 0;
        const node = this.#head;
        if (--this.#length === 0) {
          this.#head = this.#tail = void 0;
        } else {
          this.#head = node.next;
        }
        node.removed = true;
        return node.value;
      }
      reset() {
        this.#length = 0;
        this.#head = this.#tail = void 0;
      }
      *[Symbol.iterator]() {
        let node = this.#head;
        while (node !== void 0) {
          yield node.value;
          node = node.next;
        }
      }
    };
    exports.SinglyLinkedList = SinglyLinkedList;
    var EmptyAwareSinglyLinkedList = class extends SinglyLinkedList {
      events = new events_1.default();
      reset() {
        const old = this.length;
        super.reset();
        if (old !== this.length && this.length === 0) {
          this.events.emit("empty");
        }
      }
      shift() {
        const old = this.length;
        const ret = super.shift();
        if (old !== this.length && this.length === 0) {
          this.events.emit("empty");
        }
        return ret;
      }
      remove(node, parent) {
        const old = this.length;
        super.remove(node, parent);
        if (old !== this.length && this.length === 0) {
          this.events.emit("empty");
        }
      }
    };
    exports.EmptyAwareSinglyLinkedList = EmptyAwareSinglyLinkedList;
  }
});
var require_encoder = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/RESP/encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CRLF2 = "\r\n";
    function encodeCommand(args) {
      const toWrite = [];
      let strings = "*" + args.length + CRLF2;
      for (let i2 = 0; i2 < args.length; i2++) {
        const arg = args[i2];
        if (typeof arg === "string") {
          strings += "$" + Buffer.byteLength(arg) + CRLF2 + arg + CRLF2;
        } else if (arg instanceof Buffer) {
          toWrite.push(strings + "$" + arg.length.toString() + CRLF2, arg);
          strings = CRLF2;
        } else {
          throw new TypeError(`"arguments[${i2}]" must be of type "string | Buffer", got ${typeof arg} instead.`);
        }
      }
      toWrite.push(strings);
      return toWrite;
    }
    exports.default = encodeCommand;
  }
});
var require_pub_sub = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/pub-sub.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PubSub = exports.PUBSUB_TYPE = void 0;
    exports.PUBSUB_TYPE = {
      CHANNELS: "CHANNELS",
      PATTERNS: "PATTERNS",
      SHARDED: "SHARDED"
    };
    var COMMANDS = {
      [exports.PUBSUB_TYPE.CHANNELS]: {
        subscribe: Buffer.from("subscribe"),
        unsubscribe: Buffer.from("unsubscribe"),
        message: Buffer.from("message")
      },
      [exports.PUBSUB_TYPE.PATTERNS]: {
        subscribe: Buffer.from("psubscribe"),
        unsubscribe: Buffer.from("punsubscribe"),
        message: Buffer.from("pmessage")
      },
      [exports.PUBSUB_TYPE.SHARDED]: {
        subscribe: Buffer.from("ssubscribe"),
        unsubscribe: Buffer.from("sunsubscribe"),
        message: Buffer.from("smessage")
      }
    };
    var PubSub = class _PubSub {
      static isStatusReply(reply) {
        return COMMANDS[exports.PUBSUB_TYPE.CHANNELS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.CHANNELS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.SHARDED].subscribe.equals(reply[0]);
      }
      static isShardedUnsubscribe(reply) {
        return COMMANDS[exports.PUBSUB_TYPE.SHARDED].unsubscribe.equals(reply[0]);
      }
      static #channelsArray(channels) {
        return Array.isArray(channels) ? channels : [channels];
      }
      static #listenersSet(listeners, returnBuffers) {
        return returnBuffers ? listeners.buffers : listeners.strings;
      }
      #subscribing = 0;
      #isActive = false;
      get isActive() {
        return this.#isActive;
      }
      listeners = {
        [exports.PUBSUB_TYPE.CHANNELS]: /* @__PURE__ */ new Map(),
        [exports.PUBSUB_TYPE.PATTERNS]: /* @__PURE__ */ new Map(),
        [exports.PUBSUB_TYPE.SHARDED]: /* @__PURE__ */ new Map()
      };
      subscribe(type, channels, listener, returnBuffers) {
        const args = [COMMANDS[type].subscribe], channelsArray = _PubSub.#channelsArray(channels);
        for (const channel of channelsArray) {
          let channelListeners = this.listeners[type].get(channel);
          if (!channelListeners || channelListeners.unsubscribing) {
            args.push(channel);
          }
        }
        if (args.length === 1) {
          for (const channel of channelsArray) {
            _PubSub.#listenersSet(this.listeners[type].get(channel), returnBuffers).add(listener);
          }
          return;
        }
        this.#isActive = true;
        this.#subscribing++;
        return {
          args,
          channelsCounter: args.length - 1,
          resolve: () => {
            this.#subscribing--;
            for (const channel of channelsArray) {
              let listeners = this.listeners[type].get(channel);
              if (!listeners) {
                listeners = {
                  unsubscribing: false,
                  buffers: /* @__PURE__ */ new Set(),
                  strings: /* @__PURE__ */ new Set()
                };
                this.listeners[type].set(channel, listeners);
              }
              _PubSub.#listenersSet(listeners, returnBuffers).add(listener);
            }
          },
          reject: () => {
            this.#subscribing--;
            this.#updateIsActive();
          }
        };
      }
      extendChannelListeners(type, channel, listeners) {
        if (!this.#extendChannelListeners(type, channel, listeners))
          return;
        this.#isActive = true;
        this.#subscribing++;
        return {
          args: [
            COMMANDS[type].subscribe,
            channel
          ],
          channelsCounter: 1,
          resolve: () => this.#subscribing--,
          reject: () => {
            this.#subscribing--;
            this.#updateIsActive();
          }
        };
      }
      #extendChannelListeners(type, channel, listeners) {
        const existingListeners = this.listeners[type].get(channel);
        if (!existingListeners) {
          this.listeners[type].set(channel, listeners);
          return true;
        }
        for (const listener of listeners.buffers) {
          existingListeners.buffers.add(listener);
        }
        for (const listener of listeners.strings) {
          existingListeners.strings.add(listener);
        }
        return false;
      }
      extendTypeListeners(type, listeners) {
        const args = [COMMANDS[type].subscribe];
        for (const [channel, channelListeners] of listeners) {
          if (this.#extendChannelListeners(type, channel, channelListeners)) {
            args.push(channel);
          }
        }
        if (args.length === 1)
          return;
        this.#isActive = true;
        this.#subscribing++;
        return {
          args,
          channelsCounter: args.length - 1,
          resolve: () => this.#subscribing--,
          reject: () => {
            this.#subscribing--;
            this.#updateIsActive();
          }
        };
      }
      unsubscribe(type, channels, listener, returnBuffers) {
        const listeners = this.listeners[type];
        if (!channels) {
          return this.#unsubscribeCommand(
            [COMMANDS[type].unsubscribe],
            // cannot use `this.#subscribed` because there might be some `SUBSCRIBE` commands in the queue
            // cannot use `this.#subscribed + this.#subscribing` because some `SUBSCRIBE` commands might fail
            NaN,
            () => listeners.clear()
          );
        }
        const channelsArray = _PubSub.#channelsArray(channels);
        if (!listener) {
          return this.#unsubscribeCommand([COMMANDS[type].unsubscribe, ...channelsArray], channelsArray.length, () => {
            for (const channel of channelsArray) {
              listeners.delete(channel);
            }
          });
        }
        const args = [COMMANDS[type].unsubscribe];
        for (const channel of channelsArray) {
          const sets = listeners.get(channel);
          if (sets) {
            let current, other;
            if (returnBuffers) {
              current = sets.buffers;
              other = sets.strings;
            } else {
              current = sets.strings;
              other = sets.buffers;
            }
            const currentSize = current.has(listener) ? current.size - 1 : current.size;
            if (currentSize !== 0 || other.size !== 0)
              continue;
            sets.unsubscribing = true;
          }
          args.push(channel);
        }
        if (args.length === 1) {
          for (const channel of channelsArray) {
            _PubSub.#listenersSet(listeners.get(channel), returnBuffers).delete(listener);
          }
          return;
        }
        return this.#unsubscribeCommand(args, args.length - 1, () => {
          for (const channel of channelsArray) {
            const sets = listeners.get(channel);
            if (!sets)
              continue;
            (returnBuffers ? sets.buffers : sets.strings).delete(listener);
            if (sets.buffers.size === 0 && sets.strings.size === 0) {
              listeners.delete(channel);
            }
          }
        });
      }
      #unsubscribeCommand(args, channelsCounter, removeListeners) {
        return {
          args,
          channelsCounter,
          resolve: () => {
            removeListeners();
            this.#updateIsActive();
          },
          reject: void 0
        };
      }
      #updateIsActive() {
        this.#isActive = this.listeners[exports.PUBSUB_TYPE.CHANNELS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.PATTERNS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.SHARDED].size !== 0 || this.#subscribing !== 0;
      }
      reset() {
        this.#isActive = false;
        this.#subscribing = 0;
      }
      resubscribe() {
        const commands = [];
        for (const [type, listeners] of Object.entries(this.listeners)) {
          if (!listeners.size)
            continue;
          this.#isActive = true;
          if (type === exports.PUBSUB_TYPE.SHARDED) {
            this.#shardedResubscribe(commands, listeners);
          } else {
            this.#normalResubscribe(commands, type, listeners);
          }
        }
        return commands;
      }
      #normalResubscribe(commands, type, listeners) {
        this.#subscribing++;
        const callback = () => this.#subscribing--;
        commands.push({
          args: [
            COMMANDS[type].subscribe,
            ...listeners.keys()
          ],
          channelsCounter: listeners.size,
          resolve: callback,
          reject: callback
        });
      }
      #shardedResubscribe(commands, listeners) {
        const callback = () => this.#subscribing--;
        for (const channel of listeners.keys()) {
          this.#subscribing++;
          commands.push({
            args: [
              COMMANDS[exports.PUBSUB_TYPE.SHARDED].subscribe,
              channel
            ],
            channelsCounter: 1,
            resolve: callback,
            reject: callback
          });
        }
      }
      handleMessageReply(reply) {
        if (COMMANDS[exports.PUBSUB_TYPE.CHANNELS].message.equals(reply[0])) {
          this.#emitPubSubMessage(exports.PUBSUB_TYPE.CHANNELS, reply[2], reply[1]);
          return true;
        } else if (COMMANDS[exports.PUBSUB_TYPE.PATTERNS].message.equals(reply[0])) {
          this.#emitPubSubMessage(exports.PUBSUB_TYPE.PATTERNS, reply[3], reply[2], reply[1]);
          return true;
        } else if (COMMANDS[exports.PUBSUB_TYPE.SHARDED].message.equals(reply[0])) {
          this.#emitPubSubMessage(exports.PUBSUB_TYPE.SHARDED, reply[2], reply[1]);
          return true;
        }
        return false;
      }
      removeShardedListeners(channel) {
        const listeners = this.listeners[exports.PUBSUB_TYPE.SHARDED].get(channel);
        this.listeners[exports.PUBSUB_TYPE.SHARDED].delete(channel);
        this.#updateIsActive();
        return listeners;
      }
      removeAllListeners() {
        const result = {
          [exports.PUBSUB_TYPE.CHANNELS]: this.listeners[exports.PUBSUB_TYPE.CHANNELS],
          [exports.PUBSUB_TYPE.PATTERNS]: this.listeners[exports.PUBSUB_TYPE.PATTERNS],
          [exports.PUBSUB_TYPE.SHARDED]: this.listeners[exports.PUBSUB_TYPE.SHARDED]
        };
        this.#updateIsActive();
        this.listeners[exports.PUBSUB_TYPE.CHANNELS] = /* @__PURE__ */ new Map();
        this.listeners[exports.PUBSUB_TYPE.PATTERNS] = /* @__PURE__ */ new Map();
        this.listeners[exports.PUBSUB_TYPE.SHARDED] = /* @__PURE__ */ new Map();
        return result;
      }
      #emitPubSubMessage(type, message, channel, pattern) {
        const keyString = (pattern ?? channel).toString(), listeners = this.listeners[type].get(keyString);
        if (!listeners)
          return;
        for (const listener of listeners.buffers) {
          listener(message, channel);
        }
        if (!listeners.strings.size)
          return;
        const channelString = pattern ? channel.toString() : keyString, messageString = channelString === "__redis__:invalidate" ? (
          // https://github.com/redis/redis/pull/7469
          // https://github.com/redis/redis/issues/7463
          message === null ? null : message.map((x2) => x2.toString())
        ) : message.toString();
        for (const listener of listeners.strings) {
          listener(messageString, channelString);
        }
      }
    };
    exports.PubSub = PubSub;
  }
});
var require_commands_queue = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/commands-queue.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var linked_list_1 = require_linked_list();
    var encoder_1 = __importDefault(require_encoder());
    var decoder_1 = require_decoder();
    var pub_sub_1 = require_pub_sub();
    var errors_1 = require_errors();
    var enterprise_maintenance_manager_1 = require_enterprise_maintenance_manager();
    var PONG = Buffer.from("pong");
    var RESET = Buffer.from("RESET");
    var RESP2_PUSH_TYPE_MAPPING = {
      ...decoder_1.PUSH_TYPE_MAPPING,
      [decoder_1.RESP_TYPES.SIMPLE_STRING]: Buffer
    };
    var RedisCommandsQueue = class _RedisCommandsQueue {
      #respVersion;
      #maxLength;
      #toWrite = new linked_list_1.DoublyLinkedList();
      #waitingForReply = new linked_list_1.EmptyAwareSinglyLinkedList();
      #onShardedChannelMoved;
      #chainInExecution;
      decoder;
      #pubSub = new pub_sub_1.PubSub();
      #pushHandlers = [this.#onPush.bind(this)];
      #maintenanceCommandTimeout;
      setMaintenanceCommandTimeout(ms) {
        if (this.#maintenanceCommandTimeout === ms) {
          (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Queue already set maintenanceCommandTimeout to ${ms}, skipping`);
          return;
        }
        ;
        (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Setting maintenance command timeout to ${ms}`);
        this.#maintenanceCommandTimeout = ms;
        if (this.#maintenanceCommandTimeout === void 0) {
          (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Queue will keep maintenanceCommandTimeout for exisitng commands, just to be on the safe side. New commands will receive normal timeouts`);
          return;
        }
        let counter = 0;
        const total = this.#toWrite.length;
        for (const node of this.#toWrite.nodes()) {
          const command = node.value;
          _RedisCommandsQueue.#removeTimeoutListener(command);
          counter++;
          const newTimeout = this.#maintenanceCommandTimeout;
          const signal = AbortSignal.timeout(newTimeout);
          command.timeout = {
            signal,
            listener: () => {
              this.#toWrite.remove(node);
              command.reject(new errors_1.CommandTimeoutDuringMaintenanceError(newTimeout));
            },
            originalTimeout: command.timeout?.originalTimeout
          };
          signal.addEventListener("abort", command.timeout.listener, { once: true });
        }
        ;
        (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Total of ${counter} of ${total} timeouts reset to ${ms}`);
      }
      get isPubSubActive() {
        return this.#pubSub.isActive;
      }
      constructor(respVersion, maxLength, onShardedChannelMoved) {
        this.#respVersion = respVersion;
        this.#maxLength = maxLength;
        this.#onShardedChannelMoved = onShardedChannelMoved;
        this.decoder = this.#initiateDecoder();
      }
      #onReply(reply) {
        this.#waitingForReply.shift().resolve(reply);
      }
      #onErrorReply(err) {
        this.#waitingForReply.shift().reject(err);
      }
      #onPush(push) {
        if (this.#pubSub.handleMessageReply(push))
          return true;
        const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(push);
        if (isShardedUnsubscribe && !this.#waitingForReply.length) {
          const channel = push[1].toString();
          this.#onShardedChannelMoved(channel, this.#pubSub.removeShardedListeners(channel));
          return true;
        } else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(push)) {
          const head = this.#waitingForReply.head.value;
          if (Number.isNaN(head.channelsCounter) && push[2] === 0 || --head.channelsCounter === 0) {
            this.#waitingForReply.shift().resolve();
          }
          return true;
        }
        return false;
      }
      #getTypeMapping() {
        return this.#waitingForReply.head.value.typeMapping ?? {};
      }
      #initiateDecoder() {
        return new decoder_1.Decoder({
          onReply: (reply) => this.#onReply(reply),
          onErrorReply: (err) => this.#onErrorReply(err),
          //TODO: we can shave off a few cycles by not adding onPush handler at all if CSC is not used
          onPush: (push) => {
            for (const pushHandler of this.#pushHandlers) {
              if (pushHandler(push))
                return;
            }
          },
          getTypeMapping: () => this.#getTypeMapping()
        });
      }
      addPushHandler(handler) {
        this.#pushHandlers.push(handler);
      }
      async waitForInflightCommandsToComplete() {
        if (this.#waitingForReply.length === 0) {
          return;
        }
        ;
        return new Promise((resolve42) => {
          this.#waitingForReply.events.on("empty", resolve42);
        });
      }
      addCommand(args, options2) {
        if (this.#maxLength && this.#toWrite.length + this.#waitingForReply.length >= this.#maxLength) {
          return Promise.reject(new Error("The queue is full"));
        } else if (options2?.abortSignal?.aborted) {
          return Promise.reject(new errors_1.AbortError());
        }
        return new Promise((resolve42, reject) => {
          let node;
          const value = {
            args,
            chainId: options2?.chainId,
            abort: void 0,
            timeout: void 0,
            resolve: resolve42,
            reject,
            channelsCounter: void 0,
            typeMapping: options2?.typeMapping
          };
          const timeout = this.#maintenanceCommandTimeout ?? options2?.timeout;
          const wasInMaintenance = this.#maintenanceCommandTimeout !== void 0;
          if (timeout) {
            const signal2 = AbortSignal.timeout(timeout);
            value.timeout = {
              signal: signal2,
              listener: () => {
                this.#toWrite.remove(node);
                value.reject(wasInMaintenance ? new errors_1.CommandTimeoutDuringMaintenanceError(timeout) : new errors_1.TimeoutError());
              },
              originalTimeout: options2?.timeout
            };
            signal2.addEventListener("abort", value.timeout.listener, { once: true });
          }
          const signal = options2?.abortSignal;
          if (signal) {
            value.abort = {
              signal,
              listener: () => {
                this.#toWrite.remove(node);
                value.reject(new errors_1.AbortError());
              }
            };
            signal.addEventListener("abort", value.abort.listener, { once: true });
          }
          node = this.#toWrite.add(value, options2?.asap);
        });
      }
      #addPubSubCommand(command, asap = false, chainId) {
        return new Promise((resolve42, reject) => {
          this.#toWrite.add({
            args: command.args,
            chainId,
            abort: void 0,
            timeout: void 0,
            resolve() {
              command.resolve();
              resolve42();
            },
            reject(err) {
              command.reject?.();
              reject(err);
            },
            channelsCounter: command.channelsCounter,
            typeMapping: decoder_1.PUSH_TYPE_MAPPING
          }, asap);
        });
      }
      #setupPubSubHandler() {
        if (this.#respVersion !== 2)
          return;
        this.decoder.onReply = (reply) => {
          if (Array.isArray(reply)) {
            if (this.#onPush(reply))
              return;
            if (PONG.equals(reply[0])) {
              const { resolve: resolve42, typeMapping } = this.#waitingForReply.shift(), buffer = reply[1].length === 0 ? reply[0] : reply[1];
              resolve42(typeMapping?.[decoder_1.RESP_TYPES.SIMPLE_STRING] === Buffer ? buffer : buffer.toString());
              return;
            }
          }
          return this.#onReply(reply);
        };
        this.decoder.getTypeMapping = () => RESP2_PUSH_TYPE_MAPPING;
      }
      subscribe(type, channels, listener, returnBuffers) {
        const command = this.#pubSub.subscribe(type, channels, listener, returnBuffers);
        if (!command)
          return;
        this.#setupPubSubHandler();
        return this.#addPubSubCommand(command);
      }
      #resetDecoderCallbacks() {
        this.decoder.onReply = (reply) => this.#onReply(reply);
        this.decoder.getTypeMapping = () => this.#getTypeMapping();
      }
      unsubscribe(type, channels, listener, returnBuffers) {
        const command = this.#pubSub.unsubscribe(type, channels, listener, returnBuffers);
        if (!command)
          return;
        if (command && this.#respVersion === 2) {
          const { resolve: resolve42 } = command;
          command.resolve = () => {
            if (!this.#pubSub.isActive) {
              this.#resetDecoderCallbacks();
            }
            resolve42();
          };
        }
        return this.#addPubSubCommand(command);
      }
      removeAllPubSubListeners() {
        return this.#pubSub.removeAllListeners();
      }
      resubscribe(chainId) {
        const commands = this.#pubSub.resubscribe();
        if (!commands.length)
          return;
        this.#setupPubSubHandler();
        return Promise.all(commands.map((command) => this.#addPubSubCommand(command, true, chainId)));
      }
      extendPubSubChannelListeners(type, channel, listeners) {
        const command = this.#pubSub.extendChannelListeners(type, channel, listeners);
        if (!command)
          return;
        this.#setupPubSubHandler();
        return this.#addPubSubCommand(command);
      }
      extendPubSubListeners(type, listeners) {
        const command = this.#pubSub.extendTypeListeners(type, listeners);
        if (!command)
          return;
        this.#setupPubSubHandler();
        return this.#addPubSubCommand(command);
      }
      getPubSubListeners(type) {
        return this.#pubSub.listeners[type];
      }
      monitor(callback, options2) {
        return new Promise((resolve42, reject) => {
          const typeMapping = options2?.typeMapping ?? {};
          this.#toWrite.add({
            args: ["MONITOR"],
            chainId: options2?.chainId,
            abort: void 0,
            timeout: void 0,
            // using `resolve` instead of using `.then`/`await` to make sure it'll be called before processing the next reply
            resolve: () => {
              if (this.#resetFallbackOnReply) {
                this.#resetFallbackOnReply = callback;
              } else {
                this.decoder.onReply = callback;
              }
              this.decoder.getTypeMapping = () => typeMapping;
              resolve42();
            },
            reject,
            channelsCounter: void 0,
            typeMapping
          }, options2?.asap);
        });
      }
      resetDecoder() {
        this.#resetDecoderCallbacks();
        this.decoder.reset();
      }
      #resetFallbackOnReply;
      async reset(chainId, typeMapping) {
        return new Promise((resolve42, reject) => {
          this.#resetFallbackOnReply = this.decoder.onReply;
          this.decoder.onReply = (reply) => {
            if (typeof reply === "string" && reply === "RESET" || reply instanceof Buffer && RESET.equals(reply)) {
              this.#resetDecoderCallbacks();
              this.#resetFallbackOnReply = void 0;
              this.#pubSub.reset();
              this.#waitingForReply.shift().resolve(reply);
              return;
            }
            this.#resetFallbackOnReply(reply);
          };
          this.#toWrite.push({
            args: ["RESET"],
            chainId,
            abort: void 0,
            timeout: void 0,
            resolve: resolve42,
            reject,
            channelsCounter: void 0,
            typeMapping
          });
        });
      }
      isWaitingToWrite() {
        return this.#toWrite.length > 0;
      }
      *commandsToWrite() {
        let toSend = this.#toWrite.shift();
        while (toSend) {
          let encoded;
          try {
            encoded = (0, encoder_1.default)(toSend.args);
          } catch (err) {
            toSend.reject(err);
            toSend = this.#toWrite.shift();
            continue;
          }
          toSend.args = void 0;
          if (toSend.abort) {
            _RedisCommandsQueue.#removeAbortListener(toSend);
            toSend.abort = void 0;
          }
          if (toSend.timeout) {
            _RedisCommandsQueue.#removeTimeoutListener(toSend);
            toSend.timeout = void 0;
          }
          this.#chainInExecution = toSend.chainId;
          toSend.chainId = void 0;
          this.#waitingForReply.push(toSend);
          yield encoded;
          toSend = this.#toWrite.shift();
        }
      }
      #flushWaitingForReply(err) {
        for (const node of this.#waitingForReply) {
          node.reject(err);
        }
        this.#waitingForReply.reset();
      }
      static #removeAbortListener(command) {
        command.abort.signal.removeEventListener("abort", command.abort.listener);
      }
      static #removeTimeoutListener(command) {
        command.timeout?.signal.removeEventListener("abort", command.timeout.listener);
      }
      static #flushToWrite(toBeSent, err) {
        if (toBeSent.abort) {
          _RedisCommandsQueue.#removeAbortListener(toBeSent);
        }
        if (toBeSent.timeout) {
          _RedisCommandsQueue.#removeTimeoutListener(toBeSent);
        }
        toBeSent.reject(err);
      }
      flushWaitingForReply(err) {
        this.resetDecoder();
        this.#pubSub.reset();
        this.#flushWaitingForReply(err);
        if (!this.#chainInExecution)
          return;
        while (this.#toWrite.head?.value.chainId === this.#chainInExecution) {
          _RedisCommandsQueue.#flushToWrite(this.#toWrite.shift(), err);
        }
        this.#chainInExecution = void 0;
      }
      flushAll(err) {
        this.resetDecoder();
        this.#pubSub.reset();
        this.#flushWaitingForReply(err);
        for (const node of this.#toWrite) {
          _RedisCommandsQueue.#flushToWrite(node, err);
        }
        this.#toWrite.reset();
      }
      isEmpty() {
        return this.#toWrite.length === 0 && this.#waitingForReply.length === 0;
      }
    };
    exports.default = RedisCommandsQueue;
  }
});
var require_commander = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/commander.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scriptArgumentsPrefix = exports.functionArgumentsPrefix = exports.getTransformReply = exports.attachConfig = void 0;
    function throwResp3SearchModuleUnstableError() {
      throw new Error("Some RESP3 results for Redis Query Engine responses may change. Refer to the readme for guidance");
    }
    function attachConfig({ BaseClass, commands, createCommand, createModuleCommand, createFunctionCommand, createScriptCommand, config }) {
      const RESP = config?.RESP ?? 2, Class = class extends BaseClass {
      };
      for (const [name, command] of Object.entries(commands)) {
        if (config?.RESP == 3 && command.unstableResp3 && !config.unstableResp3) {
          Class.prototype[name] = throwResp3SearchModuleUnstableError;
        } else {
          Class.prototype[name] = createCommand(command, RESP);
        }
      }
      if (config?.modules) {
        for (const [moduleName, module2] of Object.entries(config.modules)) {
          const fns = /* @__PURE__ */ Object.create(null);
          for (const [name, command] of Object.entries(module2)) {
            if (config.RESP == 3 && command.unstableResp3 && !config.unstableResp3) {
              fns[name] = throwResp3SearchModuleUnstableError;
            } else {
              fns[name] = createModuleCommand(command, RESP);
            }
          }
          attachNamespace(Class.prototype, moduleName, fns);
        }
      }
      if (config?.functions) {
        for (const [library, commands2] of Object.entries(config.functions)) {
          const fns = /* @__PURE__ */ Object.create(null);
          for (const [name, command] of Object.entries(commands2)) {
            fns[name] = createFunctionCommand(name, command, RESP);
          }
          attachNamespace(Class.prototype, library, fns);
        }
      }
      if (config?.scripts) {
        for (const [name, script] of Object.entries(config.scripts)) {
          Class.prototype[name] = createScriptCommand(script, RESP);
        }
      }
      return Class;
    }
    exports.attachConfig = attachConfig;
    function attachNamespace(prototype, name, fns) {
      Object.defineProperty(prototype, name, {
        get() {
          const value = Object.create(fns);
          value._self = this;
          Object.defineProperty(this, name, { value });
          return value;
        }
      });
    }
    function getTransformReply(command, resp) {
      switch (typeof command.transformReply) {
        case "function":
          return command.transformReply;
        case "object":
          return command.transformReply[resp];
      }
    }
    exports.getTransformReply = getTransformReply;
    function functionArgumentsPrefix(name, fn) {
      const prefix = [
        fn.IS_READ_ONLY ? "FCALL_RO" : "FCALL",
        name
      ];
      if (fn.NUMBER_OF_KEYS !== void 0) {
        prefix.push(fn.NUMBER_OF_KEYS.toString());
      }
      return prefix;
    }
    exports.functionArgumentsPrefix = functionArgumentsPrefix;
    function scriptArgumentsPrefix(script) {
      const prefix = [
        script.IS_READ_ONLY ? "EVALSHA_RO" : "EVALSHA",
        script.SHA1
      ];
      if (script.NUMBER_OF_KEYS !== void 0) {
        prefix.push(script.NUMBER_OF_KEYS.toString());
      }
      return prefix;
    }
    exports.scriptArgumentsPrefix = scriptArgumentsPrefix;
  }
});
var require_multi_command = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/multi-command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var RedisMultiCommand = class {
      typeMapping;
      constructor(typeMapping) {
        this.typeMapping = typeMapping;
      }
      queue = [];
      scriptsInUse = /* @__PURE__ */ new Set();
      addCommand(args, transformReply) {
        this.queue.push({
          args,
          transformReply
        });
      }
      addScript(script, args, transformReply) {
        const redisArgs = [];
        redisArgs.preserve = args.preserve;
        if (this.scriptsInUse.has(script.SHA1)) {
          redisArgs.push("EVALSHA", script.SHA1);
        } else {
          this.scriptsInUse.add(script.SHA1);
          redisArgs.push("EVAL", script.SCRIPT);
        }
        if (script.NUMBER_OF_KEYS !== void 0) {
          redisArgs.push(script.NUMBER_OF_KEYS.toString());
        }
        redisArgs.push(...args);
        this.addCommand(redisArgs, transformReply);
      }
      transformReplies(rawReplies) {
        const errorIndexes = [], replies = rawReplies.map((reply, i2) => {
          if (reply instanceof errors_1.ErrorReply) {
            errorIndexes.push(i2);
            return reply;
          }
          const { transformReply, args } = this.queue[i2];
          return transformReply ? transformReply(reply, args.preserve, this.typeMapping) : reply;
        });
        if (errorIndexes.length)
          throw new errors_1.MultiErrorReply(replies, errorIndexes);
        return replies;
      }
    };
    exports.default = RedisMultiCommand;
  }
});
var require_multi_command2 = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/multi-command.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = __importDefault(require_commands());
    var multi_command_1 = __importDefault(require_multi_command());
    var commander_1 = require_commander();
    var parser_1 = require_parser();
    var RedisClientMultiCommand = class _RedisClientMultiCommand {
      static #createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          return this.addCommand(redisArgs, transformReply);
        };
      }
      static #createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          return this._self.addCommand(redisArgs, transformReply);
        };
      }
      static #createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          fn.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          return this._self.addCommand(redisArgs, transformReply);
        };
      }
      static #createScriptCommand(script, resp) {
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          script.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          return this.#addScript(script, redisArgs, transformReply);
        };
      }
      static extend(config) {
        return (0, commander_1.attachConfig)({
          BaseClass: _RedisClientMultiCommand,
          commands: commands_1.default,
          createCommand: _RedisClientMultiCommand.#createCommand,
          createModuleCommand: _RedisClientMultiCommand.#createModuleCommand,
          createFunctionCommand: _RedisClientMultiCommand.#createFunctionCommand,
          createScriptCommand: _RedisClientMultiCommand.#createScriptCommand,
          config
        });
      }
      #multi;
      #executeMulti;
      #executePipeline;
      #selectedDB;
      constructor(executeMulti, executePipeline, typeMapping) {
        this.#multi = new multi_command_1.default(typeMapping);
        this.#executeMulti = executeMulti;
        this.#executePipeline = executePipeline;
      }
      SELECT(db2, transformReply) {
        this.#selectedDB = db2;
        this.#multi.addCommand(["SELECT", db2.toString()], transformReply);
        return this;
      }
      select = this.SELECT;
      addCommand(args, transformReply) {
        this.#multi.addCommand(args, transformReply);
        return this;
      }
      #addScript(script, args, transformReply) {
        this.#multi.addScript(script, args, transformReply);
        return this;
      }
      async exec(execAsPipeline = false) {
        if (execAsPipeline)
          return this.execAsPipeline();
        return this.#multi.transformReplies(await this.#executeMulti(this.#multi.queue, this.#selectedDB));
      }
      EXEC = this.exec;
      execTyped(execAsPipeline = false) {
        return this.exec(execAsPipeline);
      }
      async execAsPipeline() {
        if (this.#multi.queue.length === 0)
          return [];
        return this.#multi.transformReplies(await this.#executePipeline(this.#multi.queue, this.#selectedDB));
      }
      execAsPipelineTyped() {
        return this.execAsPipeline();
      }
    };
    exports.default = RedisClientMultiCommand;
  }
});
var require_legacy_mode = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/legacy-mode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RedisLegacyClient = void 0;
    var commander_1 = require_commander();
    var commands_1 = __importDefault(require_commands());
    var multi_command_1 = __importDefault(require_multi_command());
    var RedisLegacyClient = class _RedisLegacyClient {
      static #transformArguments(redisArgs, args) {
        let callback;
        if (typeof args[args.length - 1] === "function") {
          callback = args.pop();
        }
        _RedisLegacyClient.pushArguments(redisArgs, args);
        return callback;
      }
      static pushArguments(redisArgs, args) {
        for (let i2 = 0; i2 < args.length; ++i2) {
          const arg = args[i2];
          if (Array.isArray(arg)) {
            _RedisLegacyClient.pushArguments(redisArgs, arg);
          } else {
            redisArgs.push(typeof arg === "number" || arg instanceof Date ? arg.toString() : arg);
          }
        }
      }
      static getTransformReply(command, resp) {
        return command.TRANSFORM_LEGACY_REPLY ? (0, commander_1.getTransformReply)(command, resp) : void 0;
      }
      static #createCommand(name, command, resp) {
        const transformReply = _RedisLegacyClient.getTransformReply(command, resp);
        return function(...args) {
          const redisArgs = [name], callback = _RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
          if (!callback) {
            promise.catch((err) => this.#client.emit("error", err));
            return;
          }
          promise.then((reply) => callback(null, transformReply ? transformReply(reply) : reply)).catch((err) => callback(err));
        };
      }
      #client;
      #Multi;
      constructor(client) {
        this.#client = client;
        const RESP = client.options?.RESP ?? 2;
        for (const [name, command] of Object.entries(commands_1.default)) {
          this[name] = _RedisLegacyClient.#createCommand(name, command, RESP);
        }
        this.#Multi = LegacyMultiCommand.factory(RESP);
      }
      sendCommand(...args) {
        const redisArgs = [], callback = _RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
        if (!callback) {
          promise.catch((err) => this.#client.emit("error", err));
          return;
        }
        promise.then((reply) => callback(null, reply)).catch((err) => callback(err));
      }
      multi() {
        return this.#Multi(this.#client);
      }
    };
    exports.RedisLegacyClient = RedisLegacyClient;
    var LegacyMultiCommand = class _LegacyMultiCommand {
      static #createCommand(name, command, resp) {
        const transformReply = RedisLegacyClient.getTransformReply(command, resp);
        return function(...args) {
          const redisArgs = [name];
          RedisLegacyClient.pushArguments(redisArgs, args);
          this.#multi.addCommand(redisArgs, transformReply);
          return this;
        };
      }
      static factory(resp) {
        const Multi = class extends _LegacyMultiCommand {
        };
        for (const [name, command] of Object.entries(commands_1.default)) {
          Multi.prototype[name] = _LegacyMultiCommand.#createCommand(name, command, resp);
        }
        return (client) => {
          return new Multi(client);
        };
      }
      #multi = new multi_command_1.default();
      #client;
      constructor(client) {
        this.#client = client;
      }
      sendCommand(...args) {
        const redisArgs = [];
        RedisLegacyClient.pushArguments(redisArgs, args);
        this.#multi.addCommand(redisArgs);
        return this;
      }
      exec(cb) {
        const promise = this.#client._executeMulti(this.#multi.queue);
        if (!cb) {
          promise.catch((err) => this.#client.emit("error", err));
          return;
        }
        promise.then((results) => cb(null, this.#multi.transformReplies(results))).catch((err) => cb?.(err));
      }
    };
  }
});
var require_cache = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PooledNoRedirectClientSideCache = exports.BasicPooledClientSideCache = exports.PooledClientSideCacheProvider = exports.BasicClientSideCache = exports.ClientSideCacheProvider = exports.CacheStats = void 0;
    var stream_1 = __require2("stream");
    var CacheStats = class _CacheStats {
      hitCount;
      missCount;
      loadSuccessCount;
      loadFailureCount;
      totalLoadTime;
      evictionCount;
      /**
       * Creates a new CacheStats instance with the specified statistics.
       */
      constructor(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount) {
        this.hitCount = hitCount;
        this.missCount = missCount;
        this.loadSuccessCount = loadSuccessCount;
        this.loadFailureCount = loadFailureCount;
        this.totalLoadTime = totalLoadTime;
        this.evictionCount = evictionCount;
        if (hitCount < 0 || missCount < 0 || loadSuccessCount < 0 || loadFailureCount < 0 || totalLoadTime < 0 || evictionCount < 0) {
          throw new Error("All statistics values must be non-negative");
        }
      }
      /**
       * Creates a new CacheStats instance with the specified statistics.
       *
       * @param hitCount - Number of cache hits
       * @param missCount - Number of cache misses
       * @param loadSuccessCount - Number of successful cache loads
       * @param loadFailureCount - Number of failed cache loads
       * @param totalLoadTime - Total load time in milliseconds
       * @param evictionCount - Number of cache evictions
       */
      static of(hitCount = 0, missCount = 0, loadSuccessCount = 0, loadFailureCount = 0, totalLoadTime = 0, evictionCount = 0) {
        return new _CacheStats(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount);
      }
      /**
       * Returns a statistics instance where no cache events have been recorded.
       *
       * @returns An empty statistics instance
       */
      static empty() {
        return _CacheStats.EMPTY_STATS;
      }
      /**
       * An empty stats instance with all counters set to zero.
       */
      static EMPTY_STATS = new _CacheStats(0, 0, 0, 0, 0, 0);
      /**
      * Returns the total number of times cache lookup methods have returned
      * either a cached or uncached value.
      *
      * @returns Total number of requests (hits + misses)
      */
      requestCount() {
        return this.hitCount + this.missCount;
      }
      /**
       * Returns the hit rate of the cache.
       * This is defined as hitCount / requestCount, or 1.0 when requestCount is 0.
       *
       * @returns The ratio of cache requests that were hits (between 0.0 and 1.0)
       */
      hitRate() {
        const requestCount = this.requestCount();
        return requestCount === 0 ? 1 : this.hitCount / requestCount;
      }
      /**
       * Returns the miss rate of the cache.
       * This is defined as missCount / requestCount, or 0.0 when requestCount is 0.
       *
       * @returns The ratio of cache requests that were misses (between 0.0 and 1.0)
       */
      missRate() {
        const requestCount = this.requestCount();
        return requestCount === 0 ? 0 : this.missCount / requestCount;
      }
      /**
      * Returns the total number of load operations (successful + failed).
      *
      * @returns Total number of load operations
      */
      loadCount() {
        return this.loadSuccessCount + this.loadFailureCount;
      }
      /**
       * Returns the ratio of cache loading attempts that failed.
       * This is defined as loadFailureCount / loadCount, or 0.0 when loadCount is 0.
       *
       * @returns Ratio of load operations that failed (between 0.0 and 1.0)
       */
      loadFailureRate() {
        const loadCount = this.loadCount();
        return loadCount === 0 ? 0 : this.loadFailureCount / loadCount;
      }
      /**
       * Returns the average time spent loading new values, in milliseconds.
       * This is defined as totalLoadTime / loadCount, or 0.0 when loadCount is 0.
       *
       * @returns Average load time in milliseconds
       */
      averageLoadPenalty() {
        const loadCount = this.loadCount();
        return loadCount === 0 ? 0 : this.totalLoadTime / loadCount;
      }
      /**
      * Returns a new CacheStats representing the difference between this CacheStats
      * and another. Negative values are rounded up to zero.
      *
      * @param other - The statistics to subtract from this instance
      * @returns The difference between this instance and other
      */
      minus(other) {
        return _CacheStats.of(Math.max(0, this.hitCount - other.hitCount), Math.max(0, this.missCount - other.missCount), Math.max(0, this.loadSuccessCount - other.loadSuccessCount), Math.max(0, this.loadFailureCount - other.loadFailureCount), Math.max(0, this.totalLoadTime - other.totalLoadTime), Math.max(0, this.evictionCount - other.evictionCount));
      }
      /**
       * Returns a new CacheStats representing the sum of this CacheStats and another.
       *
       * @param other - The statistics to add to this instance
       * @returns The sum of this instance and other
       */
      plus(other) {
        return _CacheStats.of(this.hitCount + other.hitCount, this.missCount + other.missCount, this.loadSuccessCount + other.loadSuccessCount, this.loadFailureCount + other.loadFailureCount, this.totalLoadTime + other.totalLoadTime, this.evictionCount + other.evictionCount);
      }
    };
    exports.CacheStats = CacheStats;
    var DisabledStatsCounter = class _DisabledStatsCounter {
      static INSTANCE = new _DisabledStatsCounter();
      constructor() {
      }
      recordHits(count) {
      }
      recordMisses(count) {
      }
      recordLoadSuccess(loadTime) {
      }
      recordLoadFailure(loadTime) {
      }
      recordEvictions(count) {
      }
      snapshot() {
        return CacheStats.empty();
      }
    };
    function disabledStatsCounter() {
      return DisabledStatsCounter.INSTANCE;
    }
    var DefaultStatsCounter = class _DefaultStatsCounter {
      #hitCount = 0;
      #missCount = 0;
      #loadSuccessCount = 0;
      #loadFailureCount = 0;
      #totalLoadTime = 0;
      #evictionCount = 0;
      /**
       * Records cache hits.
       *
       * @param count - The number of hits to record
       */
      recordHits(count) {
        this.#hitCount += count;
      }
      /**
       * Records cache misses.
       *
       * @param count - The number of misses to record
       */
      recordMisses(count) {
        this.#missCount += count;
      }
      /**
       * Records the successful load of a new entry.
       *
       * @param loadTime - The number of milliseconds spent loading the entry
       */
      recordLoadSuccess(loadTime) {
        this.#loadSuccessCount++;
        this.#totalLoadTime += loadTime;
      }
      /**
       * Records the failed load of a new entry.
       *
       * @param loadTime - The number of milliseconds spent attempting to load the entry
       */
      recordLoadFailure(loadTime) {
        this.#loadFailureCount++;
        this.#totalLoadTime += loadTime;
      }
      /**
       * Records cache evictions.
       *
       * @param count - The number of evictions to record
       */
      recordEvictions(count) {
        this.#evictionCount += count;
      }
      /**
       * Returns a snapshot of the current statistics.
       *
       * @returns A snapshot of the current statistics
       */
      snapshot() {
        return CacheStats.of(this.#hitCount, this.#missCount, this.#loadSuccessCount, this.#loadFailureCount, this.#totalLoadTime, this.#evictionCount);
      }
      /**
       * Creates a new DefaultStatsCounter.
       *
       * @returns A new DefaultStatsCounter instance
       */
      static create() {
        return new _DefaultStatsCounter();
      }
    };
    function generateCacheKey(redisArgs) {
      const tmp = new Array(redisArgs.length * 2);
      for (let i2 = 0; i2 < redisArgs.length; i2++) {
        tmp[i2] = redisArgs[i2].length;
        tmp[i2 + redisArgs.length] = redisArgs[i2];
      }
      return tmp.join("_");
    }
    var ClientSideCacheEntryBase = class {
      #invalidated = false;
      #expireTime;
      constructor(ttl) {
        if (ttl == 0) {
          this.#expireTime = 0;
        } else {
          this.#expireTime = Date.now() + ttl;
        }
      }
      invalidate() {
        this.#invalidated = true;
      }
      validate() {
        return !this.#invalidated && (this.#expireTime == 0 || Date.now() < this.#expireTime);
      }
    };
    var ClientSideCacheEntryValue = class extends ClientSideCacheEntryBase {
      #value;
      get value() {
        return this.#value;
      }
      constructor(ttl, value) {
        super(ttl);
        this.#value = value;
      }
    };
    var ClientSideCacheEntryPromise = class extends ClientSideCacheEntryBase {
      #sendCommandPromise;
      get promise() {
        return this.#sendCommandPromise;
      }
      constructor(ttl, sendCommandPromise) {
        super(ttl);
        this.#sendCommandPromise = sendCommandPromise;
      }
    };
    var ClientSideCacheProvider = class extends stream_1.EventEmitter {
    };
    exports.ClientSideCacheProvider = ClientSideCacheProvider;
    var BasicClientSideCache = class extends ClientSideCacheProvider {
      #cacheKeyToEntryMap;
      #keyToCacheKeySetMap;
      ttl;
      maxEntries;
      lru;
      #statsCounter;
      recordEvictions(count) {
        this.#statsCounter.recordEvictions(count);
      }
      recordHits(count) {
        this.#statsCounter.recordHits(count);
      }
      recordMisses(count) {
        this.#statsCounter.recordMisses(count);
      }
      constructor(config) {
        super();
        this.#cacheKeyToEntryMap = /* @__PURE__ */ new Map();
        this.#keyToCacheKeySetMap = /* @__PURE__ */ new Map();
        this.ttl = config?.ttl ?? 0;
        this.maxEntries = config?.maxEntries ?? 0;
        this.lru = config?.evictPolicy !== "FIFO";
        const recordStats = config?.recordStats !== false;
        this.#statsCounter = recordStats ? DefaultStatsCounter.create() : disabledStatsCounter();
      }
      /* logic of how caching works:
      
        1. commands use a CommandParser
          it enables us to define/retrieve
            cacheKey - a unique key that corresponds to this command and its arguments
            redisKeys - an array of redis keys as strings that if the key is modified, will cause redis to invalidate this result when cached
        2. check if cacheKey is in our cache
          2b1. if its a value cacheEntry - return it
          2b2. if it's a promise cache entry - wait on promise and then go to 3c.
        3. if cacheEntry is not in cache
          3a. send the command save the promise into a a cacheEntry and then wait on result
          3b. transform reply (if required) based on transformReply
          3b. check the cacheEntry is still valid - in cache and hasn't been deleted)
          3c. if valid - overwrite with value entry
        4. return previously non cached result
        */
      async handleCache(client, parser, fn, transformReply, typeMapping) {
        let reply;
        const cacheKey = generateCacheKey(parser.redisArgs);
        let cacheEntry = this.get(cacheKey);
        if (cacheEntry) {
          if (cacheEntry instanceof ClientSideCacheEntryValue) {
            this.#statsCounter.recordHits(1);
            return structuredClone(cacheEntry.value);
          } else if (cacheEntry instanceof ClientSideCacheEntryPromise) {
            this.#statsCounter.recordMisses(1);
            reply = await cacheEntry.promise;
          } else {
            throw new Error("unknown cache entry type");
          }
        } else {
          this.#statsCounter.recordMisses(1);
          const startTime = performance.now();
          const promise = fn();
          cacheEntry = this.createPromiseEntry(client, promise);
          this.set(cacheKey, cacheEntry, parser.keys);
          try {
            reply = await promise;
            const loadTime = performance.now() - startTime;
            this.#statsCounter.recordLoadSuccess(loadTime);
          } catch (err) {
            const loadTime = performance.now() - startTime;
            this.#statsCounter.recordLoadFailure(loadTime);
            if (cacheEntry.validate()) {
              this.delete(cacheKey);
            }
            throw err;
          }
        }
        let val;
        if (transformReply) {
          val = transformReply(reply, parser.preserve, typeMapping);
        } else {
          val = reply;
        }
        if (cacheEntry.validate()) {
          cacheEntry = this.createValueEntry(client, val);
          this.set(cacheKey, cacheEntry, parser.keys);
          this.emit("cached-key", cacheKey);
        } else {
        }
        return structuredClone(val);
      }
      trackingOn() {
        return ["CLIENT", "TRACKING", "ON"];
      }
      invalidate(key) {
        if (key === null) {
          this.clear(false);
          this.emit("invalidate", key);
          return;
        }
        const keySet = this.#keyToCacheKeySetMap.get(key.toString());
        if (keySet) {
          for (const cacheKey of keySet) {
            const entry = this.#cacheKeyToEntryMap.get(cacheKey);
            if (entry) {
              entry.invalidate();
            }
            this.#cacheKeyToEntryMap.delete(cacheKey);
          }
          this.#keyToCacheKeySetMap.delete(key.toString());
        }
        this.emit("invalidate", key);
      }
      clear(resetStats = true) {
        const oldSize = this.#cacheKeyToEntryMap.size;
        this.#cacheKeyToEntryMap.clear();
        this.#keyToCacheKeySetMap.clear();
        if (resetStats) {
          if (!(this.#statsCounter instanceof DisabledStatsCounter)) {
            this.#statsCounter = DefaultStatsCounter.create();
          }
        } else {
          if (oldSize > 0) {
            this.#statsCounter.recordEvictions(oldSize);
          }
        }
      }
      get(cacheKey) {
        const val = this.#cacheKeyToEntryMap.get(cacheKey);
        if (val && !val.validate()) {
          this.delete(cacheKey);
          this.#statsCounter.recordEvictions(1);
          this.emit("cache-evict", cacheKey);
          return void 0;
        }
        if (val !== void 0 && this.lru) {
          this.#cacheKeyToEntryMap.delete(cacheKey);
          this.#cacheKeyToEntryMap.set(cacheKey, val);
        }
        return val;
      }
      delete(cacheKey) {
        const entry = this.#cacheKeyToEntryMap.get(cacheKey);
        if (entry) {
          entry.invalidate();
          this.#cacheKeyToEntryMap.delete(cacheKey);
        }
      }
      has(cacheKey) {
        return this.#cacheKeyToEntryMap.has(cacheKey);
      }
      set(cacheKey, cacheEntry, keys) {
        let count = this.#cacheKeyToEntryMap.size;
        const oldEntry = this.#cacheKeyToEntryMap.get(cacheKey);
        if (oldEntry) {
          count--;
          oldEntry.invalidate();
        }
        if (this.maxEntries > 0 && count >= this.maxEntries) {
          this.deleteOldest();
          this.#statsCounter.recordEvictions(1);
        }
        this.#cacheKeyToEntryMap.set(cacheKey, cacheEntry);
        for (const key of keys) {
          if (!this.#keyToCacheKeySetMap.has(key.toString())) {
            this.#keyToCacheKeySetMap.set(key.toString(), /* @__PURE__ */ new Set());
          }
          const cacheKeySet = this.#keyToCacheKeySetMap.get(key.toString());
          cacheKeySet.add(cacheKey);
        }
      }
      size() {
        return this.#cacheKeyToEntryMap.size;
      }
      createValueEntry(client, value) {
        return new ClientSideCacheEntryValue(this.ttl, value);
      }
      createPromiseEntry(client, sendCommandPromise) {
        return new ClientSideCacheEntryPromise(this.ttl, sendCommandPromise);
      }
      stats() {
        return this.#statsCounter.snapshot();
      }
      onError() {
        this.clear();
      }
      onClose() {
        this.clear();
      }
      /**
       * @internal
       */
      deleteOldest() {
        const it = this.#cacheKeyToEntryMap[Symbol.iterator]();
        const n = it.next();
        if (!n.done) {
          const key = n.value[0];
          const entry = this.#cacheKeyToEntryMap.get(key);
          if (entry) {
            entry.invalidate();
          }
          this.#cacheKeyToEntryMap.delete(key);
        }
      }
      /**
       * Get cache entries for debugging
       * @internal
       */
      entryEntries() {
        return this.#cacheKeyToEntryMap.entries();
      }
      /**
       * Get key set entries for debugging
       * @internal
       */
      keySetEntries() {
        return this.#keyToCacheKeySetMap.entries();
      }
    };
    exports.BasicClientSideCache = BasicClientSideCache;
    var PooledClientSideCacheProvider = class extends BasicClientSideCache {
      #disabled = false;
      disable() {
        this.#disabled = true;
      }
      enable() {
        this.#disabled = false;
      }
      get(cacheKey) {
        if (this.#disabled) {
          return void 0;
        }
        return super.get(cacheKey);
      }
      has(cacheKey) {
        if (this.#disabled) {
          return false;
        }
        return super.has(cacheKey);
      }
      onPoolClose() {
        this.clear();
      }
    };
    exports.PooledClientSideCacheProvider = PooledClientSideCacheProvider;
    var BasicPooledClientSideCache = class extends PooledClientSideCacheProvider {
      onError() {
        this.clear(false);
      }
      onClose() {
        this.clear(false);
      }
    };
    exports.BasicPooledClientSideCache = BasicPooledClientSideCache;
    var PooledClientSideCacheEntryValue = class extends ClientSideCacheEntryValue {
      #creator;
      constructor(ttl, creator, value) {
        super(ttl, value);
        this.#creator = creator;
      }
      validate() {
        let ret = super.validate();
        if (this.#creator) {
          ret = ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
        }
        return ret;
      }
    };
    var PooledClientSideCacheEntryPromise = class extends ClientSideCacheEntryPromise {
      #creator;
      constructor(ttl, creator, sendCommandPromise) {
        super(ttl, sendCommandPromise);
        this.#creator = creator;
      }
      validate() {
        let ret = super.validate();
        return ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
      }
    };
    var PooledNoRedirectClientSideCache = class extends BasicPooledClientSideCache {
      createValueEntry(client, value) {
        const creator = {
          epoch: client.socketEpoch,
          client
        };
        return new PooledClientSideCacheEntryValue(this.ttl, creator, value);
      }
      createPromiseEntry(client, sendCommandPromise) {
        const creator = {
          epoch: client.socketEpoch,
          client
        };
        return new PooledClientSideCacheEntryPromise(this.ttl, creator, sendCommandPromise);
      }
      onError() {
      }
      onClose() {
      }
    };
    exports.PooledNoRedirectClientSideCache = PooledNoRedirectClientSideCache;
  }
});
var require_single_entry_cache = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/single-entry-cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SingleEntryCache = class {
      #cached;
      #serializedKey;
      /**
       * Retrieves an instance from the cache based on the provided key object.
       *
       * @param keyObj - The key object to look up in the cache.
       * @returns The cached instance if found, undefined otherwise.
       *
       * @remarks
       * This method uses JSON.stringify for comparison, which may not work correctly
       * if the properties in the key object are rearranged or reordered.
       */
      get(keyObj) {
        return JSON.stringify(keyObj, makeCircularReplacer()) === this.#serializedKey ? this.#cached : void 0;
      }
      set(keyObj, obj) {
        this.#cached = obj;
        this.#serializedKey = JSON.stringify(keyObj, makeCircularReplacer());
      }
    };
    exports.default = SingleEntryCache;
    function makeCircularReplacer() {
      const seen = /* @__PURE__ */ new WeakSet();
      return function serialize(_, value) {
        if (value && typeof value === "object") {
          if (seen.has(value)) {
            return "circular";
          }
          seen.add(value);
          return value;
        }
        return value;
      };
    }
  }
});
var require_pool = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/pool.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RedisClientPool = void 0;
    var commands_1 = __importDefault(require_commands());
    var _1 = __importDefault(require_client());
    var node_events_1 = __require2("node:events");
    var linked_list_1 = require_linked_list();
    var errors_1 = require_errors();
    var commander_1 = require_commander();
    var multi_command_1 = __importDefault(require_multi_command2());
    var cache_1 = require_cache();
    var parser_1 = require_parser();
    var single_entry_cache_1 = __importDefault(require_single_entry_cache());
    var RedisClientPool = class _RedisClientPool extends node_events_1.EventEmitter {
      static #createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          return this.execute((client) => client._executeCommand(command, parser, this._commandOptions, transformReply));
        };
      }
      static #createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          return this._self.execute((client) => client._executeCommand(command, parser, this._self._commandOptions, transformReply));
        };
      }
      static #createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          fn.parseCommand(parser, ...args);
          return this._self.execute((client) => client._executeCommand(fn, parser, this._self._commandOptions, transformReply));
        };
      }
      static #createScriptCommand(script, resp) {
        const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.pushVariadic(prefix);
          script.parseCommand(parser, ...args);
          return this.execute((client) => client._executeScript(script, parser, this._commandOptions, transformReply));
        };
      }
      static #SingleEntryCache = new single_entry_cache_1.default();
      static create(clientOptions, options2) {
        let Pool = _RedisClientPool.#SingleEntryCache.get(clientOptions);
        if (!Pool) {
          Pool = (0, commander_1.attachConfig)({
            BaseClass: _RedisClientPool,
            commands: commands_1.default,
            createCommand: _RedisClientPool.#createCommand,
            createModuleCommand: _RedisClientPool.#createModuleCommand,
            createFunctionCommand: _RedisClientPool.#createFunctionCommand,
            createScriptCommand: _RedisClientPool.#createScriptCommand,
            config: clientOptions
          });
          Pool.prototype.Multi = multi_command_1.default.extend(clientOptions);
          _RedisClientPool.#SingleEntryCache.set(clientOptions, Pool);
        }
        return Object.create(new Pool(clientOptions, options2));
      }
      // TODO: defaults
      static #DEFAULTS = {
        minimum: 1,
        maximum: 100,
        acquireTimeout: 3e3,
        cleanupDelay: 3e3
      };
      #clientFactory;
      #options;
      #idleClients = new linked_list_1.SinglyLinkedList();
      /**
       * The number of idle clients.
       */
      get idleClients() {
        return this._self.#idleClients.length;
      }
      #clientsInUse = new linked_list_1.DoublyLinkedList();
      /**
       * The number of clients in use.
       */
      get clientsInUse() {
        return this._self.#clientsInUse.length;
      }
      /**
       * The total number of clients in the pool (including connecting, idle, and in use).
       */
      get totalClients() {
        return this._self.#idleClients.length + this._self.#clientsInUse.length;
      }
      #tasksQueue = new linked_list_1.SinglyLinkedList();
      /**
       * The number of tasks waiting for a client to become available.
       */
      get tasksQueueLength() {
        return this._self.#tasksQueue.length;
      }
      #isOpen = false;
      /**
       * Whether the pool is open (either connecting or connected).
       */
      get isOpen() {
        return this._self.#isOpen;
      }
      #isClosing = false;
      /**
       * Whether the pool is closing (*not* closed).
       */
      get isClosing() {
        return this._self.#isClosing;
      }
      #clientSideCache;
      get clientSideCache() {
        return this._self.#clientSideCache;
      }
      /**
       * You are probably looking for {@link RedisClient.createPool `RedisClient.createPool`},
       * {@link RedisClientPool.fromClient `RedisClientPool.fromClient`},
       * or {@link RedisClientPool.fromOptions `RedisClientPool.fromOptions`}...
       */
      constructor(clientOptions, options2) {
        super();
        this.#options = {
          ..._RedisClientPool.#DEFAULTS,
          ...options2
        };
        if (options2?.clientSideCache) {
          if (clientOptions === void 0) {
            clientOptions = {};
          }
          if (options2.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
            this.#clientSideCache = clientOptions.clientSideCache = options2.clientSideCache;
          } else {
            const cscConfig = options2.clientSideCache;
            this.#clientSideCache = clientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
          }
        }
        this.#clientFactory = _1.default.factory(clientOptions).bind(void 0, clientOptions);
      }
      _self = this;
      _commandOptions;
      withCommandOptions(options2) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = options2;
        return proxy;
      }
      #commandOptionsProxy(key, value) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = Object.create(this._commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
      }
      /**
       * Override the `typeMapping` command option
       */
      withTypeMapping(typeMapping) {
        return this._self.#commandOptionsProxy("typeMapping", typeMapping);
      }
      /**
       * Override the `abortSignal` command option
       */
      withAbortSignal(abortSignal) {
        return this._self.#commandOptionsProxy("abortSignal", abortSignal);
      }
      /**
       * Override the `asap` command option to `true`
       * TODO: remove?
       */
      asap() {
        return this._self.#commandOptionsProxy("asap", true);
      }
      async connect() {
        if (this._self.#isOpen)
          return;
        this._self.#isOpen = true;
        const promises = [];
        while (promises.length < this._self.#options.minimum) {
          promises.push(this._self.#create());
        }
        try {
          await Promise.all(promises);
        } catch (err) {
          this.destroy();
          throw err;
        }
        return this;
      }
      async #create() {
        const node = this._self.#clientsInUse.push(this._self.#clientFactory().on("error", (err) => this.emit("error", err)));
        try {
          const client = node.value;
          await client.connect();
        } catch (err) {
          this._self.#clientsInUse.remove(node);
          throw err;
        }
        this._self.#returnClient(node);
      }
      execute(fn) {
        return new Promise((resolve42, reject) => {
          const client = this._self.#idleClients.shift(), { tail } = this._self.#tasksQueue;
          if (!client) {
            let timeout;
            if (this._self.#options.acquireTimeout > 0) {
              timeout = setTimeout(() => {
                this._self.#tasksQueue.remove(task, tail);
                reject(new errors_1.TimeoutError("Timeout waiting for a client"));
              }, this._self.#options.acquireTimeout);
            }
            const task = this._self.#tasksQueue.push({
              timeout,
              // @ts-ignore
              resolve: resolve42,
              reject,
              fn
            });
            if (this.totalClients < this._self.#options.maximum) {
              this._self.#create();
            }
            return;
          }
          const node = this._self.#clientsInUse.push(client);
          this._self.#executeTask(node, resolve42, reject, fn);
        });
      }
      #executeTask(node, resolve42, reject, fn) {
        const result = fn(node.value);
        if (result instanceof Promise) {
          result.then(resolve42, reject).finally(() => this.#returnClient(node));
        } else {
          resolve42(result);
          this.#returnClient(node);
        }
      }
      #returnClient(node) {
        const task = this.#tasksQueue.shift();
        if (task) {
          clearTimeout(task.timeout);
          this.#executeTask(node, task.resolve, task.reject, task.fn);
          return;
        }
        this.#clientsInUse.remove(node);
        this.#idleClients.push(node.value);
        this.#scheduleCleanup();
      }
      cleanupTimeout;
      #scheduleCleanup() {
        if (this.totalClients <= this.#options.minimum)
          return;
        clearTimeout(this.cleanupTimeout);
        this.cleanupTimeout = setTimeout(() => this.#cleanup(), this.#options.cleanupDelay);
      }
      #cleanup() {
        const toDestroy = Math.min(this.#idleClients.length, this.totalClients - this.#options.minimum);
        for (let i2 = 0; i2 < toDestroy; i2++) {
          const client = this.#idleClients.shift();
          client.destroy();
        }
      }
      sendCommand(args, options2) {
        return this.execute((client) => client.sendCommand(args, options2));
      }
      MULTI() {
        return new this.Multi((commands, selectedDB) => this.execute((client) => client._executeMulti(commands, selectedDB)), (commands) => this.execute((client) => client._executePipeline(commands)), this._commandOptions?.typeMapping);
      }
      multi = this.MULTI;
      async close() {
        if (this._self.#isClosing)
          return;
        if (!this._self.#isOpen)
          return;
        this._self.#isClosing = true;
        try {
          const promises = [];
          for (const client of this._self.#idleClients) {
            promises.push(client.close());
          }
          for (const client of this._self.#clientsInUse) {
            promises.push(client.close());
          }
          await Promise.all(promises);
          this.#clientSideCache?.onPoolClose();
          this._self.#idleClients.reset();
          this._self.#clientsInUse.reset();
        } catch (err) {
        } finally {
          this._self.#isClosing = false;
        }
      }
      destroy() {
        for (const client of this._self.#idleClients) {
          client.destroy();
        }
        this._self.#idleClients.reset();
        for (const client of this._self.#clientsInUse) {
          client.destroy();
        }
        this._self.#clientSideCache?.onPoolClose();
        this._self.#clientsInUse.reset();
        this._self.#isOpen = false;
      }
    };
    exports.RedisClientPool = RedisClientPool;
  }
});
var require_package = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/package.json"(exports, module) {
    module.exports = {
      name: "@redis/client",
      version: "5.9.0-beta.3",
      license: "MIT",
      main: "./dist/index.js",
      types: "./dist/index.d.ts",
      files: [
        "dist/",
        "!dist/tsconfig.tsbuildinfo"
      ],
      scripts: {
        test: "nyc -r text-summary -r lcov mocha -r tsx './lib/**/*.spec.ts'",
        release: "release-it"
      },
      dependencies: {
        "cluster-key-slot": "1.1.2"
      },
      devDependencies: {
        "@redis/test-utils": "*",
        "@types/sinon": "^17.0.3",
        sinon: "^17.0.1"
      },
      engines: {
        node: ">= 18"
      },
      repository: {
        type: "git",
        url: "git://github.com/redis/node-redis.git"
      },
      bugs: {
        url: "https://github.com/redis/node-redis/issues"
      },
      homepage: "https://github.com/redis/node-redis/tree/master/packages/client",
      keywords: [
        "redis"
      ]
    };
  }
});
var require_client = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/client/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a2;
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = __importDefault(require_commands());
    var socket_1 = __importDefault(require_socket());
    var authx_1 = require_authx();
    var commands_queue_1 = __importDefault(require_commands_queue());
    var node_events_1 = __require2("node:events");
    var commander_1 = require_commander();
    var errors_1 = require_errors();
    var node_url_1 = __require2("node:url");
    var pub_sub_1 = require_pub_sub();
    var multi_command_1 = __importDefault(require_multi_command2());
    var HELLO_1 = __importDefault(require_HELLO());
    var legacy_mode_1 = require_legacy_mode();
    var pool_1 = require_pool();
    var generic_transformers_1 = require_generic_transformers();
    var cache_1 = require_cache();
    var parser_1 = require_parser();
    var single_entry_cache_1 = __importDefault(require_single_entry_cache());
    var package_json_1 = require_package();
    var enterprise_maintenance_manager_1 = __importDefault(require_enterprise_maintenance_manager());
    var RedisClient = class extends node_events_1.EventEmitter {
      static #createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          return this._self._executeCommand(command, parser, this._commandOptions, transformReply);
        };
      }
      static #createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          return this._self._executeCommand(command, parser, this._self._commandOptions, transformReply);
        };
      }
      static #createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          fn.parseCommand(parser, ...args);
          return this._self._executeCommand(fn, parser, this._self._commandOptions, transformReply);
        };
      }
      static #createScriptCommand(script, resp) {
        const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          script.parseCommand(parser, ...args);
          return this._executeScript(script, parser, this._commandOptions, transformReply);
        };
      }
      static #SingleEntryCache = new single_entry_cache_1.default();
      static factory(config) {
        let Client = _a2.#SingleEntryCache.get(config);
        if (!Client) {
          Client = (0, commander_1.attachConfig)({
            BaseClass: _a2,
            commands: commands_1.default,
            createCommand: _a2.#createCommand,
            createModuleCommand: _a2.#createModuleCommand,
            createFunctionCommand: _a2.#createFunctionCommand,
            createScriptCommand: _a2.#createScriptCommand,
            config
          });
          Client.prototype.Multi = multi_command_1.default.extend(config);
          _a2.#SingleEntryCache.set(config, Client);
        }
        return (options2) => {
          return Object.create(new Client(options2));
        };
      }
      static create(options2) {
        return _a2.factory(options2)(options2);
      }
      static parseOptions(options2) {
        if (options2?.url) {
          const parsed = _a2.parseURL(options2.url);
          if (options2.socket) {
            if (options2.socket.tls !== void 0 && options2.socket.tls !== parsed.socket.tls) {
              throw new TypeError(`tls socket option is set to ${options2.socket.tls} which is mismatch with protocol or the URL ${options2.url} passed`);
            }
            parsed.socket = Object.assign(options2.socket, parsed.socket);
          }
          Object.assign(options2, parsed);
        }
        return options2;
      }
      static parseURL(url) {
        const { hostname, port, protocol, username, password, pathname } = new node_url_1.URL(url), parsed = {
          socket: {
            host: hostname,
            tls: false
          }
        };
        if (protocol !== "redis:" && protocol !== "rediss:") {
          throw new TypeError("Invalid protocol");
        }
        parsed.socket.tls = protocol === "rediss:";
        if (port) {
          parsed.socket.port = Number(port);
        }
        if (username) {
          parsed.username = decodeURIComponent(username);
        }
        if (password) {
          parsed.password = decodeURIComponent(password);
        }
        if (username || password) {
          parsed.credentialsProvider = {
            type: "async-credentials-provider",
            credentials: async () => ({
              username: username ? decodeURIComponent(username) : void 0,
              password: password ? decodeURIComponent(password) : void 0
            })
          };
        }
        if (pathname.length > 1) {
          const database = Number(pathname.substring(1));
          if (isNaN(database)) {
            throw new TypeError("Invalid pathname");
          }
          parsed.database = database;
        }
        return parsed;
      }
      #options;
      #socket;
      #queue;
      #selectedDB = 0;
      #monitorCallback;
      _self = this;
      _commandOptions;
      // flag used to annotate that the client
      // was in a watch transaction when
      // a topology change occured
      #dirtyWatch;
      #watchEpoch;
      #clientSideCache;
      #credentialsSubscription = null;
      // Flag used to pause writing to the socket during maintenance windows.
      // When true, prevents new commands from being written while waiting for:
      // 1. New socket to be ready after maintenance redirect
      // 2. In-flight commands on the old socket to complete
      #paused = false;
      get clientSideCache() {
        return this._self.#clientSideCache;
      }
      get options() {
        return this._self.#options;
      }
      get isOpen() {
        return this._self.#socket.isOpen;
      }
      get isReady() {
        return this._self.#socket.isReady;
      }
      get isPubSubActive() {
        return this._self.#queue.isPubSubActive;
      }
      get socketEpoch() {
        return this._self.#socket.socketEpoch;
      }
      get isWatching() {
        return this._self.#watchEpoch !== void 0;
      }
      /**
       * Indicates whether the client's WATCH command has been invalidated by a topology change.
       * When this returns true, any transaction using WATCH will fail with a WatchError.
       * @returns true if the watched keys have been modified, false otherwise
       */
      get isDirtyWatch() {
        return this._self.#dirtyWatch !== void 0;
      }
      /**
       * Marks the client's WATCH command as invalidated due to a topology change.
       * This will cause any subsequent EXEC in a transaction to fail with a WatchError.
       * @param msg - The error message explaining why the WATCH is dirty
       */
      setDirtyWatch(msg) {
        this._self.#dirtyWatch = msg;
      }
      constructor(options2) {
        super();
        this.#validateOptions(options2);
        this.#options = this.#initiateOptions(options2);
        this.#queue = this.#initiateQueue();
        this.#socket = this.#initiateSocket();
        if (this.#options.maintNotifications !== "disabled") {
          new enterprise_maintenance_manager_1.default(this.#queue, this, this.#options);
        }
        ;
        if (this.#options.clientSideCache) {
          if (this.#options.clientSideCache instanceof cache_1.ClientSideCacheProvider) {
            this.#clientSideCache = this.#options.clientSideCache;
          } else {
            const cscConfig = this.#options.clientSideCache;
            this.#clientSideCache = new cache_1.BasicClientSideCache(cscConfig);
          }
          this.#queue.addPushHandler((push) => {
            if (push[0].toString() !== "invalidate")
              return false;
            if (push[1] !== null) {
              for (const key of push[1]) {
                this.#clientSideCache?.invalidate(key);
              }
            } else {
              this.#clientSideCache?.invalidate(null);
            }
            return true;
          });
        } else if (options2?.emitInvalidate) {
          this.#queue.addPushHandler((push) => {
            if (push[0].toString() !== "invalidate")
              return false;
            if (push[1] !== null) {
              for (const key of push[1]) {
                this.emit("invalidate", key);
              }
            } else {
              this.emit("invalidate", null);
            }
            return true;
          });
        }
      }
      #validateOptions(options2) {
        if (options2?.clientSideCache && options2?.RESP !== 3) {
          throw new Error("Client Side Caching is only supported with RESP3");
        }
        if (options2?.emitInvalidate && options2?.RESP !== 3) {
          throw new Error("emitInvalidate is only supported with RESP3");
        }
        if (options2?.clientSideCache && options2?.emitInvalidate) {
          throw new Error("emitInvalidate is not supported (or necessary) when clientSideCache is enabled");
        }
        if (options2?.maintNotifications && options2?.maintNotifications !== "disabled" && options2?.RESP !== 3) {
          throw new Error("Graceful Maintenance is only supported with RESP3");
        }
      }
      #initiateOptions(options2 = {}) {
        if (!options2.credentialsProvider && (options2.username || options2.password)) {
          options2.credentialsProvider = {
            type: "async-credentials-provider",
            credentials: async () => ({
              username: options2.username,
              password: options2.password
            })
          };
        }
        if (options2.database) {
          this._self.#selectedDB = options2.database;
        }
        if (options2.commandOptions) {
          this._commandOptions = options2.commandOptions;
        }
        if (options2.maintNotifications !== "disabled") {
          enterprise_maintenance_manager_1.default.setupDefaultMaintOptions(options2);
        }
        if (options2.url) {
          const parsedOptions = _a2.parseOptions(options2);
          if (parsedOptions?.database) {
            this._self.#selectedDB = parsedOptions.database;
          }
          return parsedOptions;
        }
        return options2;
      }
      #initiateQueue() {
        return new commands_queue_1.default(this.#options.RESP ?? 2, this.#options.commandsQueueMaxLength, (channel, listeners) => this.emit("sharded-channel-moved", channel, listeners));
      }
      /**
       * @param credentials
       */
      reAuthenticate = async (credentials) => {
        if (!(this.isPubSubActive && !this.#options.RESP)) {
          await this.sendCommand((0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
            username: credentials.username,
            password: credentials.password ?? ""
          }));
        }
      };
      #subscribeForStreamingCredentials(cp) {
        return cp.subscribe({
          onNext: (credentials) => {
            this.reAuthenticate(credentials).catch((error) => {
              const errorMessage = error instanceof Error ? error.message : String(error);
              cp.onReAuthenticationError(new authx_1.CredentialsError(errorMessage));
            });
          },
          onError: (e2) => {
            const errorMessage = `Error from streaming credentials provider: ${e2.message}`;
            cp.onReAuthenticationError(new authx_1.UnableToObtainNewCredentialsError(errorMessage));
          }
        });
      }
      async #handshake(chainId, asap) {
        const promises = [];
        const commandsWithErrorHandlers = await this.#getHandshakeCommands();
        if (asap)
          commandsWithErrorHandlers.reverse();
        for (const { cmd, errorHandler } of commandsWithErrorHandlers) {
          promises.push(this.#queue.addCommand(cmd, {
            chainId,
            asap
          }).catch(errorHandler));
        }
        return promises;
      }
      async #getHandshakeCommands() {
        const commands = [];
        const cp = this.#options.credentialsProvider;
        if (this.#options.RESP) {
          const hello = {};
          if (cp && cp.type === "async-credentials-provider") {
            const credentials = await cp.credentials();
            if (credentials.password) {
              hello.AUTH = {
                username: credentials.username ?? "default",
                password: credentials.password
              };
            }
          }
          if (cp && cp.type === "streaming-credentials-provider") {
            const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
            this.#credentialsSubscription = disposable;
            if (credentials.password) {
              hello.AUTH = {
                username: credentials.username ?? "default",
                password: credentials.password
              };
            }
          }
          if (this.#options.name) {
            hello.SETNAME = this.#options.name;
          }
          commands.push({ cmd: (0, generic_transformers_1.parseArgs)(HELLO_1.default, this.#options.RESP, hello) });
        } else {
          if (cp && cp.type === "async-credentials-provider") {
            const credentials = await cp.credentials();
            if (credentials.username || credentials.password) {
              commands.push({
                cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                  username: credentials.username,
                  password: credentials.password ?? ""
                })
              });
            }
          }
          if (cp && cp.type === "streaming-credentials-provider") {
            const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
            this.#credentialsSubscription = disposable;
            if (credentials.username || credentials.password) {
              commands.push({
                cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                  username: credentials.username,
                  password: credentials.password ?? ""
                })
              });
            }
          }
          if (this.#options.name) {
            commands.push({
              cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.CLIENT_SETNAME, this.#options.name)
            });
          }
        }
        if (this.#selectedDB !== 0) {
          commands.push({ cmd: ["SELECT", this.#selectedDB.toString()] });
        }
        if (this.#options.readonly) {
          commands.push({ cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.READONLY) });
        }
        if (!this.#options.disableClientInfo) {
          commands.push({
            cmd: ["CLIENT", "SETINFO", "LIB-VER", package_json_1.version],
            errorHandler: () => {
            }
          });
          commands.push({
            cmd: [
              "CLIENT",
              "SETINFO",
              "LIB-NAME",
              this.#options.clientInfoTag ? `node-redis(${this.#options.clientInfoTag})` : "node-redis"
            ],
            errorHandler: () => {
            }
          });
        }
        if (this.#clientSideCache) {
          commands.push({ cmd: this.#clientSideCache.trackingOn() });
        }
        if (this.#options?.emitInvalidate) {
          commands.push({ cmd: ["CLIENT", "TRACKING", "ON"] });
        }
        const maintenanceHandshakeCmd = await enterprise_maintenance_manager_1.default.getHandshakeCommand(this.#options);
        if (maintenanceHandshakeCmd) {
          commands.push(maintenanceHandshakeCmd);
        }
        ;
        return commands;
      }
      #attachListeners(socket) {
        socket.on("data", (chunk) => {
          try {
            this.#queue.decoder.write(chunk);
          } catch (err) {
            this.#queue.resetDecoder();
            this.emit("error", err);
          }
        }).on("error", (err) => {
          this.emit("error", err);
          this.#clientSideCache?.onError();
          if (this.#socket.isOpen && !this.#options.disableOfflineQueue) {
            this.#queue.flushWaitingForReply(err);
          } else {
            this.#queue.flushAll(err);
          }
        }).on("connect", () => this.emit("connect")).on("ready", () => {
          this.emit("ready");
          this.#setPingTimer();
          this.#maybeScheduleWrite();
        }).on("reconnecting", () => this.emit("reconnecting")).on("drain", () => this.#maybeScheduleWrite()).on("end", () => this.emit("end"));
      }
      #initiateSocket() {
        const socketInitiator = async () => {
          const promises = [], chainId = Symbol("Socket Initiator");
          const resubscribePromise = this.#queue.resubscribe(chainId);
          resubscribePromise?.catch((error) => {
            if (error.message && error.message.startsWith("MOVED")) {
              this.emit("__MOVED", this._self.#queue.removeAllPubSubListeners());
            }
          });
          if (resubscribePromise) {
            promises.push(resubscribePromise);
          }
          if (this.#monitorCallback) {
            promises.push(this.#queue.monitor(this.#monitorCallback, {
              typeMapping: this._commandOptions?.typeMapping,
              chainId,
              asap: true
            }));
          }
          promises.push(...await this.#handshake(chainId, true));
          if (promises.length) {
            this.#write();
            return Promise.all(promises);
          }
        };
        const socket = new socket_1.default(socketInitiator, this.#options.socket);
        this.#attachListeners(socket);
        return socket;
      }
      #pingTimer;
      #setPingTimer() {
        if (!this.#options.pingInterval || !this.#socket.isReady)
          return;
        clearTimeout(this.#pingTimer);
        this.#pingTimer = setTimeout(() => {
          if (!this.#socket.isReady)
            return;
          this.sendCommand(["PING"]).then((reply) => this.emit("ping-interval", reply)).catch((err) => this.emit("error", err)).finally(() => this.#setPingTimer());
        }, this.#options.pingInterval);
      }
      withCommandOptions(options2) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = options2;
        return proxy;
      }
      _commandOptionsProxy(key, value) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = Object.create(this._commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
      }
      /**
       * Override the `typeMapping` command option
       */
      withTypeMapping(typeMapping) {
        return this._commandOptionsProxy("typeMapping", typeMapping);
      }
      /**
       * Override the `abortSignal` command option
       */
      withAbortSignal(abortSignal) {
        return this._commandOptionsProxy("abortSignal", abortSignal);
      }
      /**
       * Override the `asap` command option to `true`
       */
      asap() {
        return this._commandOptionsProxy("asap", true);
      }
      /**
       * Create the "legacy" (v3/callback) interface
       */
      legacy() {
        return new legacy_mode_1.RedisLegacyClient(this);
      }
      /**
       * Create {@link RedisClientPool `RedisClientPool`} using this client as a prototype
       */
      createPool(options2) {
        return pool_1.RedisClientPool.create(this._self.#options, options2);
      }
      duplicate(overrides) {
        return new (Object.getPrototypeOf(this)).constructor({
          ...this._self.#options,
          commandOptions: this._commandOptions,
          ...overrides
        });
      }
      async connect() {
        await this._self.#socket.connect();
        return this;
      }
      /**
       * @internal
       */
      _ejectSocket() {
        const socket = this._self.#socket;
        this._self.#socket = null;
        socket.removeAllListeners();
        return socket;
      }
      /**
       * @internal
       */
      _insertSocket(socket) {
        if (this._self.#socket) {
          this._self._ejectSocket().destroy();
        }
        this._self.#socket = socket;
        this._self.#attachListeners(this._self.#socket);
      }
      /**
       * @internal
       */
      _maintenanceUpdate(update) {
        this._self.#socket.setMaintenanceTimeout(update.relaxedSocketTimeout);
        this._self.#queue.setMaintenanceCommandTimeout(update.relaxedCommandTimeout);
      }
      /**
       * @internal
       */
      _pause() {
        this._self.#paused = true;
      }
      /**
       * @internal
       */
      _unpause() {
        this._self.#paused = false;
        this._self.#maybeScheduleWrite();
      }
      /**
       * @internal
       */
      async _executeCommand(command, parser, commandOptions, transformReply) {
        const csc = this._self.#clientSideCache;
        const defaultTypeMapping = this._self.#options.commandOptions === commandOptions;
        const fn = () => {
          return this.sendCommand(parser.redisArgs, commandOptions);
        };
        if (csc && command.CACHEABLE && defaultTypeMapping) {
          return await csc.handleCache(this._self, parser, fn, transformReply, commandOptions?.typeMapping);
        } else {
          const reply = await fn();
          if (transformReply) {
            return transformReply(reply, parser.preserve, commandOptions?.typeMapping);
          }
          return reply;
        }
      }
      /**
       * @internal
       */
      async _executeScript(script, parser, options2, transformReply) {
        const args = parser.redisArgs;
        let reply;
        try {
          reply = await this.sendCommand(args, options2);
        } catch (err) {
          if (!err?.message?.startsWith?.("NOSCRIPT"))
            throw err;
          args[0] = "EVAL";
          args[1] = script.SCRIPT;
          reply = await this.sendCommand(args, options2);
        }
        return transformReply ? transformReply(reply, parser.preserve, options2?.typeMapping) : reply;
      }
      sendCommand(args, options2) {
        if (!this._self.#socket.isOpen) {
          return Promise.reject(new errors_1.ClientClosedError());
        } else if (!this._self.#socket.isReady && this._self.#options.disableOfflineQueue) {
          return Promise.reject(new errors_1.ClientOfflineError());
        }
        const opts = {
          ...this._self._commandOptions,
          ...options2
        };
        const promise = this._self.#queue.addCommand(args, opts);
        this._self.#scheduleWrite();
        return promise;
      }
      async SELECT(db2) {
        await this.sendCommand(["SELECT", db2.toString()]);
        this._self.#selectedDB = db2;
      }
      select = this.SELECT;
      #pubSubCommand(promise) {
        if (promise === void 0)
          return Promise.resolve();
        this.#scheduleWrite();
        return promise;
      }
      SUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
      }
      subscribe = this.SUBSCRIBE;
      UNSUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
      }
      unsubscribe = this.UNSUBSCRIBE;
      PSUBSCRIBE(patterns, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
      }
      pSubscribe = this.PSUBSCRIBE;
      PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
      }
      pUnsubscribe = this.PUNSUBSCRIBE;
      SSUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
      }
      sSubscribe = this.SSUBSCRIBE;
      SUNSUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
      }
      sUnsubscribe = this.SUNSUBSCRIBE;
      async WATCH(key) {
        const reply = await this._self.sendCommand((0, generic_transformers_1.pushVariadicArguments)(["WATCH"], key));
        this._self.#watchEpoch ??= this._self.socketEpoch;
        return reply;
      }
      watch = this.WATCH;
      async UNWATCH() {
        const reply = await this._self.sendCommand(["UNWATCH"]);
        this._self.#watchEpoch = void 0;
        return reply;
      }
      unwatch = this.UNWATCH;
      getPubSubListeners(type) {
        return this._self.#queue.getPubSubListeners(type);
      }
      extendPubSubChannelListeners(type, channel, listeners) {
        return this._self.#pubSubCommand(this._self.#queue.extendPubSubChannelListeners(type, channel, listeners));
      }
      extendPubSubListeners(type, listeners) {
        return this._self.#pubSubCommand(this._self.#queue.extendPubSubListeners(type, listeners));
      }
      #write() {
        if (this.#paused) {
          return;
        }
        this.#socket.write(this.#queue.commandsToWrite());
      }
      #scheduledWrite;
      #scheduleWrite() {
        if (!this.#socket.isReady || this.#scheduledWrite)
          return;
        this.#scheduledWrite = setImmediate(() => {
          this.#write();
          this.#scheduledWrite = void 0;
        });
      }
      #maybeScheduleWrite() {
        if (!this.#queue.isWaitingToWrite())
          return;
        this.#scheduleWrite();
      }
      /**
       * @internal
       */
      async _executePipeline(commands, selectedDB) {
        if (!this._self.#socket.isOpen) {
          return Promise.reject(new errors_1.ClientClosedError());
        }
        const chainId = Symbol("Pipeline Chain"), promise = Promise.all(commands.map(({ args }) => this._self.#queue.addCommand(args, {
          chainId,
          typeMapping: this._commandOptions?.typeMapping
        })));
        this._self.#scheduleWrite();
        const result = await promise;
        if (selectedDB !== void 0) {
          this._self.#selectedDB = selectedDB;
        }
        return result;
      }
      /**
       * @internal
       */
      async _executeMulti(commands, selectedDB) {
        const dirtyWatch = this._self.#dirtyWatch;
        this._self.#dirtyWatch = void 0;
        const watchEpoch = this._self.#watchEpoch;
        this._self.#watchEpoch = void 0;
        if (!this._self.#socket.isOpen) {
          throw new errors_1.ClientClosedError();
        }
        if (dirtyWatch) {
          throw new errors_1.WatchError(dirtyWatch);
        }
        if (watchEpoch && watchEpoch !== this._self.socketEpoch) {
          throw new errors_1.WatchError("Client reconnected after WATCH");
        }
        const typeMapping = this._commandOptions?.typeMapping;
        const chainId = Symbol("MULTI Chain");
        const promises = [
          this._self.#queue.addCommand(["MULTI"], { chainId })
        ];
        for (const { args } of commands) {
          promises.push(this._self.#queue.addCommand(args, {
            chainId,
            typeMapping
          }));
        }
        promises.push(this._self.#queue.addCommand(["EXEC"], { chainId }));
        this._self.#scheduleWrite();
        const results = await Promise.all(promises), execResult = results[results.length - 1];
        if (execResult === null) {
          throw new errors_1.WatchError();
        }
        if (selectedDB !== void 0) {
          this._self.#selectedDB = selectedDB;
        }
        return execResult;
      }
      MULTI() {
        return new this.Multi(this._executeMulti.bind(this), this._executePipeline.bind(this), this._commandOptions?.typeMapping);
      }
      multi = this.MULTI;
      async *scanIterator(options2) {
        let cursor = options2?.cursor ?? "0";
        do {
          const reply = await this.scan(cursor, options2);
          cursor = reply.cursor;
          yield reply.keys;
        } while (cursor !== "0");
      }
      async *hScanIterator(key, options2) {
        let cursor = options2?.cursor ?? "0";
        do {
          const reply = await this.hScan(key, cursor, options2);
          cursor = reply.cursor;
          yield reply.entries;
        } while (cursor !== "0");
      }
      async *hScanValuesIterator(key, options2) {
        let cursor = options2?.cursor ?? "0";
        do {
          const reply = await this.hScanNoValues(key, cursor, options2);
          cursor = reply.cursor;
          yield reply.fields;
        } while (cursor !== "0");
      }
      async *hScanNoValuesIterator(key, options2) {
        let cursor = options2?.cursor ?? "0";
        do {
          const reply = await this.hScanNoValues(key, cursor, options2);
          cursor = reply.cursor;
          yield reply.fields;
        } while (cursor !== "0");
      }
      async *sScanIterator(key, options2) {
        let cursor = options2?.cursor ?? "0";
        do {
          const reply = await this.sScan(key, cursor, options2);
          cursor = reply.cursor;
          yield reply.members;
        } while (cursor !== "0");
      }
      async *zScanIterator(key, options2) {
        let cursor = options2?.cursor ?? "0";
        do {
          const reply = await this.zScan(key, cursor, options2);
          cursor = reply.cursor;
          yield reply.members;
        } while (cursor !== "0");
      }
      async MONITOR(callback) {
        const promise = this._self.#queue.monitor(callback, {
          typeMapping: this._commandOptions?.typeMapping
        });
        this._self.#scheduleWrite();
        await promise;
        this._self.#monitorCallback = callback;
      }
      monitor = this.MONITOR;
      /**
       * Reset the client to its default state (i.e. stop PubSub, stop monitoring, select default DB, etc.)
       */
      async reset() {
        const chainId = Symbol("Reset Chain"), promises = [this._self.#queue.reset(chainId)], selectedDB = this._self.#options?.database ?? 0;
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
        promises.push(...await this._self.#handshake(chainId, false));
        this._self.#scheduleWrite();
        await Promise.all(promises);
        this._self.#selectedDB = selectedDB;
        this._self.#monitorCallback = void 0;
        this._self.#dirtyWatch = void 0;
        this._self.#watchEpoch = void 0;
      }
      /**
       * If the client has state, reset it.
       * An internal function to be used by wrapper class such as `RedisClientPool`.
       * @internal
       */
      resetIfDirty() {
        let shouldReset = false;
        if (this._self.#selectedDB !== (this._self.#options?.database ?? 0)) {
          console.warn("Returning a client with a different selected DB");
          shouldReset = true;
        }
        if (this._self.#monitorCallback) {
          console.warn("Returning a client with active MONITOR");
          shouldReset = true;
        }
        if (this._self.#queue.isPubSubActive) {
          console.warn("Returning a client with active PubSub");
          shouldReset = true;
        }
        if (this._self.#dirtyWatch || this._self.#watchEpoch) {
          console.warn("Returning a client with active WATCH");
          shouldReset = true;
        }
        if (shouldReset) {
          return this.reset();
        }
      }
      /**
       * @deprecated use .close instead
       */
      QUIT() {
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
        return this._self.#socket.quit(async () => {
          clearTimeout(this._self.#pingTimer);
          const quitPromise = this._self.#queue.addCommand(["QUIT"]);
          this._self.#scheduleWrite();
          return quitPromise;
        });
      }
      quit = this.QUIT;
      /**
       * @deprecated use .destroy instead
       */
      disconnect() {
        return Promise.resolve(this.destroy());
      }
      /**
       * Close the client. Wait for pending commands.
       */
      close() {
        return new Promise((resolve42) => {
          clearTimeout(this._self.#pingTimer);
          this._self.#socket.close();
          this._self.#clientSideCache?.onClose();
          if (this._self.#queue.isEmpty()) {
            this._self.#socket.destroySocket();
            return resolve42();
          }
          const maybeClose = () => {
            if (!this._self.#queue.isEmpty())
              return;
            this._self.#socket.off("data", maybeClose);
            this._self.#socket.destroySocket();
            resolve42();
          };
          this._self.#socket.on("data", maybeClose);
          this._self.#credentialsSubscription?.dispose();
          this._self.#credentialsSubscription = null;
        });
      }
      /**
       * Destroy the client. Rejects all commands immediately.
       */
      destroy() {
        clearTimeout(this._self.#pingTimer);
        this._self.#queue.flushAll(new errors_1.DisconnectsClientError());
        this._self.#socket.destroy();
        this._self.#clientSideCache?.onClose();
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
      }
      ref() {
        this._self.#socket.ref();
      }
      unref() {
        this._self.#socket.unref();
      }
    };
    _a2 = RedisClient;
    exports.default = RedisClient;
  }
});
var require_lib3 = __commonJS({
  "node_modules/.deno/cluster-key-slot@1.1.2/node_modules/cluster-key-slot/lib/index.js"(exports, module) {
    var lookup = [
      0,
      4129,
      8258,
      12387,
      16516,
      20645,
      24774,
      28903,
      33032,
      37161,
      41290,
      45419,
      49548,
      53677,
      57806,
      61935,
      4657,
      528,
      12915,
      8786,
      21173,
      17044,
      29431,
      25302,
      37689,
      33560,
      45947,
      41818,
      54205,
      50076,
      62463,
      58334,
      9314,
      13379,
      1056,
      5121,
      25830,
      29895,
      17572,
      21637,
      42346,
      46411,
      34088,
      38153,
      58862,
      62927,
      50604,
      54669,
      13907,
      9842,
      5649,
      1584,
      30423,
      26358,
      22165,
      18100,
      46939,
      42874,
      38681,
      34616,
      63455,
      59390,
      55197,
      51132,
      18628,
      22757,
      26758,
      30887,
      2112,
      6241,
      10242,
      14371,
      51660,
      55789,
      59790,
      63919,
      35144,
      39273,
      43274,
      47403,
      23285,
      19156,
      31415,
      27286,
      6769,
      2640,
      14899,
      10770,
      56317,
      52188,
      64447,
      60318,
      39801,
      35672,
      47931,
      43802,
      27814,
      31879,
      19684,
      23749,
      11298,
      15363,
      3168,
      7233,
      60846,
      64911,
      52716,
      56781,
      44330,
      48395,
      36200,
      40265,
      32407,
      28342,
      24277,
      20212,
      15891,
      11826,
      7761,
      3696,
      65439,
      61374,
      57309,
      53244,
      48923,
      44858,
      40793,
      36728,
      37256,
      33193,
      45514,
      41451,
      53516,
      49453,
      61774,
      57711,
      4224,
      161,
      12482,
      8419,
      20484,
      16421,
      28742,
      24679,
      33721,
      37784,
      41979,
      46042,
      49981,
      54044,
      58239,
      62302,
      689,
      4752,
      8947,
      13010,
      16949,
      21012,
      25207,
      29270,
      46570,
      42443,
      38312,
      34185,
      62830,
      58703,
      54572,
      50445,
      13538,
      9411,
      5280,
      1153,
      29798,
      25671,
      21540,
      17413,
      42971,
      47098,
      34713,
      38840,
      59231,
      63358,
      50973,
      55100,
      9939,
      14066,
      1681,
      5808,
      26199,
      30326,
      17941,
      22068,
      55628,
      51565,
      63758,
      59695,
      39368,
      35305,
      47498,
      43435,
      22596,
      18533,
      30726,
      26663,
      6336,
      2273,
      14466,
      10403,
      52093,
      56156,
      60223,
      64286,
      35833,
      39896,
      43963,
      48026,
      19061,
      23124,
      27191,
      31254,
      2801,
      6864,
      10931,
      14994,
      64814,
      60687,
      56684,
      52557,
      48554,
      44427,
      40424,
      36297,
      31782,
      27655,
      23652,
      19525,
      15522,
      11395,
      7392,
      3265,
      61215,
      65342,
      53085,
      57212,
      44955,
      49082,
      36825,
      40952,
      28183,
      32310,
      20053,
      24180,
      11923,
      16050,
      3793,
      7920
    ];
    var toUTF8Array = function toUTF8Array2(str) {
      var char;
      var i2 = 0;
      var p = 0;
      var utf8 = [];
      var len = str.length;
      for (; i2 < len; i2++) {
        char = str.charCodeAt(i2);
        if (char < 128) {
          utf8[p++] = char;
        } else if (char < 2048) {
          utf8[p++] = char >> 6 | 192;
          utf8[p++] = char & 63 | 128;
        } else if ((char & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
          char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
          utf8[p++] = char >> 18 | 240;
          utf8[p++] = char >> 12 & 63 | 128;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        } else {
          utf8[p++] = char >> 12 | 224;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        }
      }
      return utf8;
    };
    var generate = module.exports = function generate2(str) {
      var char;
      var i2 = 0;
      var start = -1;
      var result = 0;
      var resultHash = 0;
      var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
      var len = utf8.length;
      while (i2 < len) {
        char = utf8[i2++];
        if (start === -1) {
          if (char === 123) {
            start = i2;
          }
        } else if (char !== 125) {
          resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
        } else if (i2 - 1 !== start) {
          return resultHash & 16383;
        }
        result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
      }
      return result & 16383;
    };
    module.exports.generateMulti = function generateMulti(keys) {
      var i2 = 1;
      var len = keys.length;
      var base2 = generate(keys[0]);
      while (i2 < len) {
        if (generate(keys[i2++]) !== base2) return -1;
      }
      return base2;
    };
  }
});
var require_cluster_slots = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/cluster/cluster-slots.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a2;
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var client_1 = __importDefault(require_client());
    var pub_sub_1 = require_pub_sub();
    var cluster_key_slot_1 = __importDefault(require_lib3());
    var cache_1 = require_cache();
    var RedisClusterSlots = class {
      static #SLOTS = 16384;
      #options;
      #clientFactory;
      #emit;
      slots = new Array(_a2.#SLOTS);
      masters = new Array();
      replicas = new Array();
      nodeByAddress = /* @__PURE__ */ new Map();
      pubSubNode;
      clientSideCache;
      #isOpen = false;
      get isOpen() {
        return this.#isOpen;
      }
      #validateOptions(options2) {
        if (options2?.clientSideCache && options2?.RESP !== 3) {
          throw new Error("Client Side Caching is only supported with RESP3");
        }
      }
      constructor(options2, emit) {
        this.#validateOptions(options2);
        this.#options = options2;
        if (options2?.clientSideCache) {
          if (options2.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
            this.clientSideCache = options2.clientSideCache;
          } else {
            this.clientSideCache = new cache_1.BasicPooledClientSideCache(options2.clientSideCache);
          }
        }
        this.#clientFactory = client_1.default.factory(this.#options);
        this.#emit = emit;
      }
      async connect() {
        if (this.#isOpen) {
          throw new Error("Cluster already open");
        }
        this.#isOpen = true;
        try {
          await this.#discoverWithRootNodes();
          this.#emit("connect");
        } catch (err) {
          this.#isOpen = false;
          throw err;
        }
      }
      async #discoverWithRootNodes() {
        let start = Math.floor(Math.random() * this.#options.rootNodes.length);
        for (let i2 = start; i2 < this.#options.rootNodes.length; i2++) {
          if (!this.#isOpen)
            throw new Error("Cluster closed");
          if (await this.#discover(this.#options.rootNodes[i2]))
            return;
        }
        for (let i2 = 0; i2 < start; i2++) {
          if (!this.#isOpen)
            throw new Error("Cluster closed");
          if (await this.#discover(this.#options.rootNodes[i2]))
            return;
        }
        throw new errors_1.RootNodesUnavailableError();
      }
      #resetSlots() {
        this.slots = new Array(_a2.#SLOTS);
        this.masters = [];
        this.replicas = [];
        this._randomNodeIterator = void 0;
      }
      async #discover(rootNode) {
        this.clientSideCache?.clear();
        this.clientSideCache?.disable();
        try {
          const addressesInUse = /* @__PURE__ */ new Set(), promises = [], eagerConnect = this.#options.minimizeConnections !== true;
          const shards = await this.#getShards(rootNode);
          this.#resetSlots();
          for (const { from: from3, to, master, replicas } of shards) {
            const shard = {
              master: this.#initiateSlotNode(master, false, eagerConnect, addressesInUse, promises)
            };
            if (this.#options.useReplicas) {
              shard.replicas = replicas.map((replica) => this.#initiateSlotNode(replica, true, eagerConnect, addressesInUse, promises));
            }
            for (let i2 = from3; i2 <= to; i2++) {
              this.slots[i2] = shard;
            }
          }
          if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
            const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS);
            this.pubSubNode.client.destroy();
            if (channelsListeners.size || patternsListeners.size) {
              promises.push(this.#initiatePubSubClient({
                [pub_sub_1.PUBSUB_TYPE.CHANNELS]: channelsListeners,
                [pub_sub_1.PUBSUB_TYPE.PATTERNS]: patternsListeners
              }));
            }
          }
          for (const [address, node] of this.nodeByAddress.entries()) {
            if (addressesInUse.has(address))
              continue;
            if (node.client) {
              node.client.destroy();
            }
            const { pubSub } = node;
            if (pubSub) {
              pubSub.client.destroy();
            }
            this.nodeByAddress.delete(address);
          }
          await Promise.all(promises);
          this.clientSideCache?.enable();
          return true;
        } catch (err) {
          this.#emit("error", err);
          return false;
        }
      }
      async #getShards(rootNode) {
        const options2 = this.#clientOptionsDefaults(rootNode);
        options2.socket ??= {};
        options2.socket.reconnectStrategy = false;
        options2.RESP = this.#options.RESP;
        options2.commandOptions = void 0;
        const client = await this.#clientFactory(options2).on("error", (err) => this.#emit("error", err)).connect();
        try {
          return await client.clusterSlots();
        } finally {
          client.destroy();
        }
      }
      #getNodeAddress(address) {
        switch (typeof this.#options.nodeAddressMap) {
          case "object":
            return this.#options.nodeAddressMap[address];
          case "function":
            return this.#options.nodeAddressMap(address);
        }
      }
      #clientOptionsDefaults(options2) {
        if (!this.#options.defaults)
          return options2;
        let socket;
        if (this.#options.defaults.socket) {
          socket = {
            ...this.#options.defaults.socket,
            ...options2?.socket
          };
        } else {
          socket = options2?.socket;
        }
        return {
          ...this.#options.defaults,
          ...options2,
          socket
        };
      }
      #initiateSlotNode(shard, readonly, eagerConnent, addressesInUse, promises) {
        const address = `${shard.host}:${shard.port}`;
        let node = this.nodeByAddress.get(address);
        if (!node) {
          node = {
            ...shard,
            address,
            readonly,
            client: void 0,
            connectPromise: void 0
          };
          if (eagerConnent) {
            promises.push(this.#createNodeClient(node));
          }
          this.nodeByAddress.set(address, node);
        }
        if (!addressesInUse.has(address)) {
          addressesInUse.add(address);
          (readonly ? this.replicas : this.masters).push(node);
        }
        return node;
      }
      #createClient(node, readonly = node.readonly) {
        const socket = this.#getNodeAddress(node.address) ?? { host: node.host, port: node.port };
        const clientInfo = Object.freeze({
          host: socket.host,
          port: socket.port
        });
        const emit = this.#emit;
        const client = this.#clientFactory(this.#clientOptionsDefaults({
          clientSideCache: this.clientSideCache,
          RESP: this.#options.RESP,
          socket,
          readonly
        })).on("error", (error) => emit("node-error", error, clientInfo)).on("reconnecting", () => emit("node-reconnecting", clientInfo)).once("ready", () => emit("node-ready", clientInfo)).once("connect", () => emit("node-connect", clientInfo)).once("end", () => emit("node-disconnect", clientInfo)).on("__MOVED", async (allPubSubListeners) => {
          await this.rediscover(client);
          this.#emit("__resubscribeAllPubSubListeners", allPubSubListeners);
        });
        return client;
      }
      #createNodeClient(node, readonly) {
        const client = node.client = this.#createClient(node, readonly);
        return node.connectPromise = client.connect().finally(() => node.connectPromise = void 0);
      }
      nodeClient(node) {
        return node.connectPromise ?? // if the node is connecting
        node.client ?? // if the node is connected
        this.#createNodeClient(node);
      }
      #runningRediscoverPromise;
      async rediscover(startWith) {
        this.#runningRediscoverPromise ??= this.#rediscover(startWith).finally(() => {
          this.#runningRediscoverPromise = void 0;
        });
        return this.#runningRediscoverPromise;
      }
      async #rediscover(startWith) {
        if (await this.#discover(startWith.options))
          return;
        return this.#discoverWithRootNodes();
      }
      /**
       * @deprecated Use `close` instead.
       */
      quit() {
        return this.#destroy((client) => client.quit());
      }
      /**
       * @deprecated Use `destroy` instead.
       */
      disconnect() {
        return this.#destroy((client) => client.disconnect());
      }
      close() {
        return this.#destroy((client) => client.close());
      }
      destroy() {
        this.#isOpen = false;
        for (const client of this.#clients()) {
          client.destroy();
        }
        if (this.pubSubNode) {
          this.pubSubNode.client.destroy();
          this.pubSubNode = void 0;
        }
        this.#resetSlots();
        this.nodeByAddress.clear();
        this.#emit("disconnect");
      }
      *#clients() {
        for (const master of this.masters) {
          if (master.client) {
            yield master.client;
          }
          if (master.pubSub) {
            yield master.pubSub.client;
          }
        }
        for (const replica of this.replicas) {
          if (replica.client) {
            yield replica.client;
          }
        }
      }
      async #destroy(fn) {
        this.#isOpen = false;
        const promises = [];
        for (const client of this.#clients()) {
          promises.push(fn(client));
        }
        if (this.pubSubNode) {
          promises.push(fn(this.pubSubNode.client));
          this.pubSubNode = void 0;
        }
        this.#resetSlots();
        this.nodeByAddress.clear();
        await Promise.allSettled(promises);
        this.#emit("disconnect");
      }
      getClient(firstKey, isReadonly) {
        if (!firstKey) {
          return this.nodeClient(this.getRandomNode());
        }
        const slotNumber = (0, cluster_key_slot_1.default)(firstKey);
        if (!isReadonly) {
          return this.nodeClient(this.slots[slotNumber].master);
        }
        return this.nodeClient(this.getSlotRandomNode(slotNumber));
      }
      *#iterateAllNodes() {
        if (this.masters.length + this.replicas.length === 0)
          return;
        let i2 = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
        if (i2 < this.masters.length) {
          do {
            yield this.masters[i2];
          } while (++i2 < this.masters.length);
          for (const replica of this.replicas) {
            yield replica;
          }
        } else {
          i2 -= this.masters.length;
          do {
            yield this.replicas[i2];
          } while (++i2 < this.replicas.length);
        }
        while (true) {
          for (const master of this.masters) {
            yield master;
          }
          for (const replica of this.replicas) {
            yield replica;
          }
        }
      }
      _randomNodeIterator;
      getRandomNode() {
        this._randomNodeIterator ??= this.#iterateAllNodes();
        return this._randomNodeIterator.next().value;
      }
      *#slotNodesIterator(slot) {
        let i2 = Math.floor(Math.random() * (1 + slot.replicas.length));
        if (i2 < slot.replicas.length) {
          do {
            yield slot.replicas[i2];
          } while (++i2 < slot.replicas.length);
        }
        while (true) {
          yield slot.master;
          for (const replica of slot.replicas) {
            yield replica;
          }
        }
      }
      getSlotRandomNode(slotNumber) {
        const slot = this.slots[slotNumber];
        if (!slot.replicas?.length) {
          return slot.master;
        }
        slot.nodesIterator ??= this.#slotNodesIterator(slot);
        return slot.nodesIterator.next().value;
      }
      getMasterByAddress(address) {
        const master = this.nodeByAddress.get(address);
        if (!master)
          return;
        return this.nodeClient(master);
      }
      getPubSubClient() {
        if (!this.pubSubNode)
          return this.#initiatePubSubClient();
        return this.pubSubNode.connectPromise ?? this.pubSubNode.client;
      }
      async #initiatePubSubClient(toResubscribe) {
        const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node = index < this.masters.length ? this.masters[index] : this.replicas[index - this.masters.length], client = this.#createClient(node, false);
        this.pubSubNode = {
          address: node.address,
          client,
          connectPromise: client.connect().then(async (client2) => {
            if (toResubscribe) {
              await Promise.all([
                client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, toResubscribe[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
                client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, toResubscribe[pub_sub_1.PUBSUB_TYPE.PATTERNS])
              ]);
            }
            this.pubSubNode.connectPromise = void 0;
            return client2;
          }).catch((err) => {
            this.pubSubNode = void 0;
            throw err;
          })
        };
        return this.pubSubNode.connectPromise;
      }
      async executeUnsubscribeCommand(unsubscribe) {
        const client = await this.getPubSubClient();
        await unsubscribe(client);
        if (!client.isPubSubActive) {
          client.destroy();
          this.pubSubNode = void 0;
        }
      }
      getShardedPubSubClient(channel) {
        const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
        if (!master.pubSub)
          return this.#initiateShardedPubSubClient(master);
        return master.pubSub.connectPromise ?? master.pubSub.client;
      }
      async #initiateShardedPubSubClient(master) {
        const client = this.#createClient(master, false).on("server-sunsubscribe", async (channel, listeners) => {
          try {
            await this.rediscover(client);
            const redirectTo = await this.getShardedPubSubClient(channel);
            await redirectTo.extendPubSubChannelListeners(pub_sub_1.PUBSUB_TYPE.SHARDED, channel, listeners);
          } catch (err) {
            this.#emit("sharded-shannel-moved-error", err, channel, listeners);
          }
        });
        master.pubSub = {
          client,
          connectPromise: client.connect().then((client2) => {
            master.pubSub.connectPromise = void 0;
            return client2;
          }).catch((err) => {
            master.pubSub = void 0;
            throw err;
          })
        };
        return master.pubSub.connectPromise;
      }
      async executeShardedUnsubscribeCommand(channel, unsubscribe) {
        const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
        if (!master.pubSub)
          return;
        const client = master.pubSub.connectPromise ? await master.pubSub.connectPromise : master.pubSub.client;
        await unsubscribe(client);
        if (!client.isPubSubActive) {
          client.destroy();
          master.pubSub = void 0;
        }
      }
    };
    _a2 = RedisClusterSlots;
    exports.default = RedisClusterSlots;
  }
});
var require_multi_command3 = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/cluster/multi-command.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = __importDefault(require_commands());
    var multi_command_1 = __importDefault(require_multi_command());
    var commander_1 = require_commander();
    var parser_1 = require_parser();
    var RedisClusterMultiCommand = class _RedisClusterMultiCommand {
      static #createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          const firstKey = parser.firstKey;
          return this.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
        };
      }
      static #createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          const firstKey = parser.firstKey;
          return this._self.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
        };
      }
      static #createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          fn.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          const firstKey = parser.firstKey;
          return this._self.addCommand(firstKey, fn.IS_READ_ONLY, redisArgs, transformReply);
        };
      }
      static #createScriptCommand(script, resp) {
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          script.parseCommand(parser, ...args);
          const scriptArgs = parser.redisArgs;
          scriptArgs.preserve = parser.preserve;
          const firstKey = parser.firstKey;
          return this.#addScript(firstKey, script.IS_READ_ONLY, script, scriptArgs, transformReply);
        };
      }
      static extend(config) {
        return (0, commander_1.attachConfig)({
          BaseClass: _RedisClusterMultiCommand,
          commands: commands_1.default,
          createCommand: _RedisClusterMultiCommand.#createCommand,
          createModuleCommand: _RedisClusterMultiCommand.#createModuleCommand,
          createFunctionCommand: _RedisClusterMultiCommand.#createFunctionCommand,
          createScriptCommand: _RedisClusterMultiCommand.#createScriptCommand,
          config
        });
      }
      #multi;
      #executeMulti;
      #executePipeline;
      #firstKey;
      #isReadonly = true;
      constructor(executeMulti, executePipeline, routing, typeMapping) {
        this.#multi = new multi_command_1.default(typeMapping);
        this.#executeMulti = executeMulti;
        this.#executePipeline = executePipeline;
        this.#firstKey = routing;
      }
      #setState(firstKey, isReadonly) {
        this.#firstKey ??= firstKey;
        this.#isReadonly &&= isReadonly;
      }
      addCommand(firstKey, isReadonly, args, transformReply) {
        this.#setState(firstKey, isReadonly);
        this.#multi.addCommand(args, transformReply);
        return this;
      }
      #addScript(firstKey, isReadonly, script, args, transformReply) {
        this.#setState(firstKey, isReadonly);
        this.#multi.addScript(script, args, transformReply);
        return this;
      }
      async exec(execAsPipeline = false) {
        if (execAsPipeline)
          return this.execAsPipeline();
        return this.#multi.transformReplies(await this.#executeMulti(this.#firstKey, this.#isReadonly, this.#multi.queue));
      }
      EXEC = this.exec;
      execTyped(execAsPipeline = false) {
        return this.exec(execAsPipeline);
      }
      async execAsPipeline() {
        if (this.#multi.queue.length === 0)
          return [];
        return this.#multi.transformReplies(await this.#executePipeline(this.#firstKey, this.#isReadonly, this.#multi.queue));
      }
      execAsPipelineTyped() {
        return this.execAsPipeline();
      }
    };
    exports.default = RedisClusterMultiCommand;
  }
});
var require_cluster = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/cluster/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = __importDefault(require_commands());
    var node_events_1 = __require2("node:events");
    var commander_1 = require_commander();
    var cluster_slots_1 = __importDefault(require_cluster_slots());
    var multi_command_1 = __importDefault(require_multi_command3());
    var errors_1 = require_errors();
    var parser_1 = require_parser();
    var ASKING_1 = require_ASKING();
    var single_entry_cache_1 = __importDefault(require_single_entry_cache());
    var RedisCluster = class _RedisCluster extends node_events_1.EventEmitter {
      static #createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
        };
      }
      static #createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
        };
      }
      static #createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          fn.parseCommand(parser, ...args);
          return this._self._execute(parser.firstKey, fn.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(fn, parser, opts, transformReply));
        };
      }
      static #createScriptCommand(script, resp) {
        const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return async function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          script.parseCommand(parser, ...args);
          return this._self._execute(parser.firstKey, script.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeScript(script, parser, opts, transformReply));
        };
      }
      static #SingleEntryCache = new single_entry_cache_1.default();
      static factory(config) {
        let Cluster = _RedisCluster.#SingleEntryCache.get(config);
        if (!Cluster) {
          Cluster = (0, commander_1.attachConfig)({
            BaseClass: _RedisCluster,
            commands: commands_1.default,
            createCommand: _RedisCluster.#createCommand,
            createModuleCommand: _RedisCluster.#createModuleCommand,
            createFunctionCommand: _RedisCluster.#createFunctionCommand,
            createScriptCommand: _RedisCluster.#createScriptCommand,
            config
          });
          Cluster.prototype.Multi = multi_command_1.default.extend(config);
          _RedisCluster.#SingleEntryCache.set(config, Cluster);
        }
        return (options2) => {
          return Object.create(new Cluster(options2));
        };
      }
      static create(options2) {
        return _RedisCluster.factory(options2)(options2);
      }
      _options;
      _slots;
      _self = this;
      _commandOptions;
      /**
       * An array of the cluster slots, each slot contain its `master` and `replicas`.
       * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific node (master or replica).
       */
      get slots() {
        return this._self._slots.slots;
      }
      get clientSideCache() {
        return this._self._slots.clientSideCache;
      }
      /**
       * An array of the cluster masters.
       * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific master node.
       */
      get masters() {
        return this._self._slots.masters;
      }
      /**
       * An array of the cluster replicas.
       * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific replica node.
       */
      get replicas() {
        return this._self._slots.replicas;
      }
      /**
       * A map form a node address (`<host>:<port>`) to its shard, each shard contain its `master` and `replicas`.
       * Use with {@link RedisCluster.prototype.nodeClient} to get the client for a specific node (master or replica).
       */
      get nodeByAddress() {
        return this._self._slots.nodeByAddress;
      }
      /**
       * The current pub/sub node.
       */
      get pubSubNode() {
        return this._self._slots.pubSubNode;
      }
      get isOpen() {
        return this._self._slots.isOpen;
      }
      constructor(options2) {
        super();
        this._options = options2;
        this._slots = new cluster_slots_1.default(options2, this.emit.bind(this));
        this.on("__resubscribeAllPubSubListeners", this.resubscribeAllPubSubListeners.bind(this));
        if (options2?.commandOptions) {
          this._commandOptions = options2.commandOptions;
        }
      }
      duplicate(overrides) {
        return new (Object.getPrototypeOf(this)).constructor({
          ...this._self._options,
          commandOptions: this._commandOptions,
          ...overrides
        });
      }
      async connect() {
        await this._self._slots.connect();
        return this;
      }
      withCommandOptions(options2) {
        const proxy = Object.create(this);
        proxy._commandOptions = options2;
        return proxy;
      }
      _commandOptionsProxy(key, value) {
        const proxy = Object.create(this);
        proxy._commandOptions = Object.create(this._commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
      }
      /**
       * Override the `typeMapping` command option
       */
      withTypeMapping(typeMapping) {
        return this._commandOptionsProxy("typeMapping", typeMapping);
      }
      // /**
      //  * Override the `policies` command option
      //  * TODO
      //  */
      // withPolicies<POLICIES extends CommandPolicies> (policies: POLICIES) {
      //   return this._commandOptionsProxy('policies', policies);
      // }
      _handleAsk(fn) {
        return async (client, options2) => {
          const chainId = Symbol("asking chain");
          const opts = options2 ? { ...options2 } : {};
          opts.chainId = chainId;
          const ret = await Promise.all([
            client.sendCommand([ASKING_1.ASKING_CMD], { chainId }),
            fn(client, opts)
          ]);
          return ret[1];
        };
      }
      async _execute(firstKey, isReadonly, options2, fn) {
        const maxCommandRedirections = this._options.maxCommandRedirections ?? 16;
        let client = await this._slots.getClient(firstKey, isReadonly);
        let i2 = 0;
        let myFn = fn;
        while (true) {
          try {
            return await myFn(client, options2);
          } catch (err) {
            myFn = fn;
            if (++i2 > maxCommandRedirections || !(err instanceof Error)) {
              throw err;
            }
            if (err.message.startsWith("ASK")) {
              const address = err.message.substring(err.message.lastIndexOf(" ") + 1);
              let redirectTo = await this._slots.getMasterByAddress(address);
              if (!redirectTo) {
                await this._slots.rediscover(client);
                redirectTo = await this._slots.getMasterByAddress(address);
              }
              if (!redirectTo) {
                throw new Error(`Cannot find node ${address}`);
              }
              client = redirectTo;
              myFn = this._handleAsk(fn);
              continue;
            }
            if (err.message.startsWith("MOVED")) {
              await this._slots.rediscover(client);
              client = await this._slots.getClient(firstKey, isReadonly);
              continue;
            }
            throw err;
          }
        }
      }
      async sendCommand(firstKey, isReadonly, args, options2) {
        const opts = {
          ...this._self._commandOptions,
          ...options2
        };
        return this._self._execute(firstKey, isReadonly, opts, (client, opts2) => client.sendCommand(args, opts2));
      }
      MULTI(routing) {
        return new this.Multi(async (firstKey, isReadonly, commands) => {
          const client = await this._self._slots.getClient(firstKey, isReadonly);
          return client._executeMulti(commands);
        }, async (firstKey, isReadonly, commands) => {
          const client = await this._self._slots.getClient(firstKey, isReadonly);
          return client._executePipeline(commands);
        }, routing, this._commandOptions?.typeMapping);
      }
      multi = this.MULTI;
      async SUBSCRIBE(channels, listener, bufferMode) {
        return (await this._self._slots.getPubSubClient()).SUBSCRIBE(channels, listener, bufferMode);
      }
      subscribe = this.SUBSCRIBE;
      async UNSUBSCRIBE(channels, listener, bufferMode) {
        return this._self._slots.executeUnsubscribeCommand((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
      }
      unsubscribe = this.UNSUBSCRIBE;
      async PSUBSCRIBE(patterns, listener, bufferMode) {
        return (await this._self._slots.getPubSubClient()).PSUBSCRIBE(patterns, listener, bufferMode);
      }
      pSubscribe = this.PSUBSCRIBE;
      async PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return this._self._slots.executeUnsubscribeCommand((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
      }
      pUnsubscribe = this.PUNSUBSCRIBE;
      async SSUBSCRIBE(channels, listener, bufferMode) {
        const maxCommandRedirections = this._self._options.maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
        let client = await this._self._slots.getShardedPubSubClient(firstChannel);
        for (let i2 = 0; ; i2++) {
          try {
            return await client.SSUBSCRIBE(channels, listener, bufferMode);
          } catch (err) {
            if (++i2 > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
              throw err;
            }
            if (err.message.startsWith("MOVED")) {
              await this._self._slots.rediscover(client);
              client = await this._self._slots.getShardedPubSubClient(firstChannel);
              continue;
            }
            throw err;
          }
        }
      }
      sSubscribe = this.SSUBSCRIBE;
      SUNSUBSCRIBE(channels, listener, bufferMode) {
        return this._self._slots.executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, (client) => client.SUNSUBSCRIBE(channels, listener, bufferMode));
      }
      resubscribeAllPubSubListeners(allListeners) {
        for (const [channel, listeners] of allListeners.CHANNELS) {
          listeners.buffers.forEach((bufListener) => {
            this.subscribe(channel, bufListener, true);
          });
          listeners.strings.forEach((strListener) => {
            this.subscribe(channel, strListener);
          });
        }
        ;
        for (const [channel, listeners] of allListeners.PATTERNS) {
          listeners.buffers.forEach((bufListener) => {
            this.pSubscribe(channel, bufListener, true);
          });
          listeners.strings.forEach((strListener) => {
            this.pSubscribe(channel, strListener);
          });
        }
        ;
        for (const [channel, listeners] of allListeners.SHARDED) {
          listeners.buffers.forEach((bufListener) => {
            this.sSubscribe(channel, bufListener, true);
          });
          listeners.strings.forEach((strListener) => {
            this.sSubscribe(channel, strListener);
          });
        }
        ;
      }
      sUnsubscribe = this.SUNSUBSCRIBE;
      /**
       * @deprecated Use `close` instead.
       */
      quit() {
        return this._self._slots.quit();
      }
      /**
       * @deprecated Use `destroy` instead.
       */
      disconnect() {
        return this._self._slots.disconnect();
      }
      close() {
        this._self._slots.clientSideCache?.onPoolClose();
        return this._self._slots.close();
      }
      destroy() {
        this._self._slots.clientSideCache?.onPoolClose();
        return this._self._slots.destroy();
      }
      nodeClient(node) {
        return this._self._slots.nodeClient(node);
      }
      /**
       * Returns a random node from the cluster.
       * Userful for running "forward" commands (like PUBLISH) on a random node.
       */
      getRandomNode() {
        return this._self._slots.getRandomNode();
      }
      /**
       * Get a random node from a slot.
       * Useful for running readonly commands on a slot.
       */
      getSlotRandomNode(slot) {
        return this._self._slots.getSlotRandomNode(slot);
      }
      /**
       * @deprecated use `.masters` instead
       * TODO
       */
      getMasters() {
        return this.masters;
      }
      /**
       * @deprecated use `.slots[<SLOT>]` instead
       * TODO
       */
      getSlotMaster(slot) {
        return this.slots[slot].master;
      }
    };
    exports.default = RedisCluster;
  }
});
var require_utils2 = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScriptCommand = exports.createModuleCommand = exports.createFunctionCommand = exports.createCommand = exports.clientSocketToNode = exports.createNodeList = exports.parseNode = void 0;
    var parser_1 = require_parser();
    var commander_1 = require_commander();
    function parseNode(node) {
      if (node.flags.includes("s_down") || node.flags.includes("disconnected") || node.flags.includes("failover_in_progress")) {
        return void 0;
      }
      return { host: node.ip, port: Number(node.port) };
    }
    exports.parseNode = parseNode;
    function createNodeList(nodes) {
      var nodeList = [];
      for (const nodeData of nodes) {
        const node = parseNode(nodeData);
        if (node === void 0) {
          continue;
        }
        nodeList.push(node);
      }
      return nodeList;
    }
    exports.createNodeList = createNodeList;
    function clientSocketToNode(socket) {
      const s = socket;
      return {
        host: s.host,
        port: s.port
      };
    }
    exports.clientSocketToNode = clientSocketToNode;
    function createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser();
        command.parseCommand(parser, ...args);
        return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this.commandOptions, transformReply));
      };
    }
    exports.createCommand = createCommand;
    function createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser();
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self._execute(fn.IS_READ_ONLY, (client) => client._executeCommand(fn, parser, this._self.commandOptions, transformReply));
      };
    }
    exports.createFunctionCommand = createFunctionCommand;
    function createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser();
        command.parseCommand(parser, ...args);
        return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this._self.commandOptions, transformReply));
      };
    }
    exports.createModuleCommand = createModuleCommand;
    function createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser();
        parser.push(...prefix);
        script.parseCommand(parser, ...args);
        return this._self._execute(script.IS_READ_ONLY, (client) => client._executeScript(script, parser, this.commandOptions, transformReply));
      };
    }
    exports.createScriptCommand = createScriptCommand;
  }
});
var require_multi_commands = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/multi-commands.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = __importDefault(require_commands());
    var multi_command_1 = __importDefault(require_multi_command());
    var commander_1 = require_commander();
    var parser_1 = require_parser();
    var RedisSentinelMultiCommand = class _RedisSentinelMultiCommand {
      static _createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          return this.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
        };
      }
      static _createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          command.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          return this._self.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
        };
      }
      static _createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          parser.push(...prefix);
          fn.parseCommand(parser, ...args);
          const redisArgs = parser.redisArgs;
          redisArgs.preserve = parser.preserve;
          return this._self.addCommand(fn.IS_READ_ONLY, redisArgs, transformReply);
        };
      }
      static _createScriptCommand(script, resp) {
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return function(...args) {
          const parser = new parser_1.BasicCommandParser();
          script.parseCommand(parser, ...args);
          const scriptArgs = parser.redisArgs;
          scriptArgs.preserve = parser.preserve;
          return this.#addScript(script.IS_READ_ONLY, script, scriptArgs, transformReply);
        };
      }
      static extend(config) {
        return (0, commander_1.attachConfig)({
          BaseClass: _RedisSentinelMultiCommand,
          commands: commands_1.default,
          createCommand: _RedisSentinelMultiCommand._createCommand,
          createModuleCommand: _RedisSentinelMultiCommand._createModuleCommand,
          createFunctionCommand: _RedisSentinelMultiCommand._createFunctionCommand,
          createScriptCommand: _RedisSentinelMultiCommand._createScriptCommand,
          config
        });
      }
      #multi = new multi_command_1.default();
      #sentinel;
      #isReadonly = true;
      constructor(sentinel, typeMapping) {
        this.#multi = new multi_command_1.default(typeMapping);
        this.#sentinel = sentinel;
      }
      #setState(isReadonly) {
        this.#isReadonly &&= isReadonly;
      }
      addCommand(isReadonly, args, transformReply) {
        this.#setState(isReadonly);
        this.#multi.addCommand(args, transformReply);
        return this;
      }
      #addScript(isReadonly, script, args, transformReply) {
        this.#setState(isReadonly);
        this.#multi.addScript(script, args, transformReply);
        return this;
      }
      async exec(execAsPipeline = false) {
        if (execAsPipeline)
          return this.execAsPipeline();
        return this.#multi.transformReplies(await this.#sentinel._executeMulti(this.#isReadonly, this.#multi.queue));
      }
      EXEC = this.exec;
      execTyped(execAsPipeline = false) {
        return this.exec(execAsPipeline);
      }
      async execAsPipeline() {
        if (this.#multi.queue.length === 0)
          return [];
        return this.#multi.transformReplies(await this.#sentinel._executePipeline(this.#isReadonly, this.#multi.queue));
      }
      execAsPipelineTyped() {
        return this.execAsPipeline();
      }
    };
    exports.default = RedisSentinelMultiCommand;
  }
});
var require_pub_sub_proxy = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/pub-sub-proxy.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PubSubProxy = void 0;
    var node_events_1 = __importDefault(__require2("node:events"));
    var pub_sub_1 = require_pub_sub();
    var client_1 = __importDefault(require_client());
    var PubSubProxy = class extends node_events_1.default {
      #clientOptions;
      #onError;
      #node;
      #state;
      #subscriptions;
      constructor(clientOptions, onError) {
        super();
        this.#clientOptions = clientOptions;
        this.#onError = onError;
      }
      #createClient() {
        if (this.#node === void 0) {
          throw new Error("pubSubProxy: didn't define node to do pubsub against");
        }
        return new client_1.default({
          ...this.#clientOptions,
          socket: {
            ...this.#clientOptions.socket,
            host: this.#node.host,
            port: this.#node.port
          }
        });
      }
      async #initiatePubSubClient(withSubscriptions = false) {
        const client = this.#createClient().on("error", this.#onError);
        const connectPromise = client.connect().then(async (client2) => {
          if (this.#state?.client !== client2) {
            client2.destroy();
            return this.#state?.connectPromise;
          }
          if (withSubscriptions && this.#subscriptions) {
            await Promise.all([
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.PATTERNS])
            ]);
          }
          if (this.#state.client !== client2) {
            client2.destroy();
            return this.#state?.connectPromise;
          }
          this.#state.connectPromise = void 0;
          return client2;
        }).catch((err) => {
          this.#state = void 0;
          throw err;
        });
        this.#state = {
          client,
          connectPromise
        };
        return connectPromise;
      }
      #getPubSubClient() {
        if (!this.#state)
          return this.#initiatePubSubClient();
        return this.#state.connectPromise ?? this.#state.client;
      }
      async changeNode(node) {
        this.#node = node;
        if (!this.#state)
          return;
        if (this.#state.connectPromise === void 0) {
          this.#subscriptions = {
            [pub_sub_1.PUBSUB_TYPE.CHANNELS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS),
            [pub_sub_1.PUBSUB_TYPE.PATTERNS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS)
          };
          this.#state.client.destroy();
        }
        await this.#initiatePubSubClient(true);
      }
      #executeCommand(fn) {
        const client = this.#getPubSubClient();
        if (client instanceof client_1.default) {
          return fn(client);
        }
        return client.then((client2) => {
          if (client2 === void 0)
            return;
          return fn(client2);
        }).catch((err) => {
          if (this.#state?.client.isPubSubActive) {
            this.#state.client.destroy();
            this.#state = void 0;
          }
          throw err;
        });
      }
      subscribe(channels, listener, bufferMode) {
        return this.#executeCommand((client) => client.SUBSCRIBE(channels, listener, bufferMode));
      }
      #unsubscribe(fn) {
        return this.#executeCommand(async (client) => {
          const reply = await fn(client);
          if (!client.isPubSubActive) {
            client.destroy();
            this.#state = void 0;
          }
          return reply;
        });
      }
      async unsubscribe(channels, listener, bufferMode) {
        return this.#unsubscribe((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
      }
      async pSubscribe(patterns, listener, bufferMode) {
        return this.#executeCommand((client) => client.PSUBSCRIBE(patterns, listener, bufferMode));
      }
      async pUnsubscribe(patterns, listener, bufferMode) {
        return this.#unsubscribe((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
      }
      destroy() {
        this.#subscriptions = void 0;
        if (this.#state === void 0)
          return;
        if (!this.#state.connectPromise) {
          this.#state.client.destroy();
        }
        this.#state = void 0;
      }
    };
    exports.PubSubProxy = PubSubProxy;
  }
});
var require_SENTINEL_MASTER = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MASTER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Returns information about the specified master.
       * @param parser - The Redis command parser.
       * @param dbname - Name of the master.
       */
      parseCommand(parser, dbname) {
        parser.push("SENTINEL", "MASTER", dbname);
      },
      transformReply: {
        2: generic_transformers_1.transformTuplesReply,
        3: void 0
      }
    };
  }
});
var require_SENTINEL_MONITOR = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MONITOR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Instructs a Sentinel to monitor a new master with the specified parameters.
       * @param parser - The Redis command parser.
       * @param dbname - Name that identifies the master.
       * @param host - Host of the master.
       * @param port - Port of the master.
       * @param quorum - Number of Sentinels that need to agree to trigger a failover.
       */
      parseCommand(parser, dbname, host, port, quorum) {
        parser.push("SENTINEL", "MONITOR", dbname, host, port, quorum);
      },
      transformReply: void 0
    };
  }
});
var require_SENTINEL_REPLICAS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_REPLICAS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Returns a list of replicas for the specified master.
       * @param parser - The Redis command parser.
       * @param dbname - Name of the master.
       */
      parseCommand(parser, dbname) {
        parser.push("SENTINEL", "REPLICAS", dbname);
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          const inferred = reply;
          const initial = [];
          return inferred.reduce((sentinels, x2) => {
            sentinels.push((0, generic_transformers_1.transformTuplesReply)(x2, void 0, typeMapping));
            return sentinels;
          }, initial);
        },
        3: void 0
      }
    };
  }
});
var require_SENTINEL_SENTINELS = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SENTINELS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      /**
       * Returns a list of Sentinel instances for the specified master.
       * @param parser - The Redis command parser.
       * @param dbname - Name of the master.
       */
      parseCommand(parser, dbname) {
        parser.push("SENTINEL", "SENTINELS", dbname);
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          const inferred = reply;
          const initial = [];
          return inferred.reduce((sentinels, x2) => {
            sentinels.push((0, generic_transformers_1.transformTuplesReply)(x2, void 0, typeMapping));
            return sentinels;
          }, initial);
        },
        3: void 0
      }
    };
  }
});
var require_SENTINEL_SET = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      /**
       * Sets configuration parameters for a specific master.
       * @param parser - The Redis command parser.
       * @param dbname - Name of the master.
       * @param options - Configuration options to set as option-value pairs.
       */
      parseCommand(parser, dbname, options2) {
        parser.push("SENTINEL", "SET", dbname);
        for (const option of options2) {
          parser.push(option.option, option.value);
        }
      },
      transformReply: void 0
    };
  }
});
var require_commands2 = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/commands/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SENTINEL_MASTER_1 = __importDefault(require_SENTINEL_MASTER());
    var SENTINEL_MONITOR_1 = __importDefault(require_SENTINEL_MONITOR());
    var SENTINEL_REPLICAS_1 = __importDefault(require_SENTINEL_REPLICAS());
    var SENTINEL_SENTINELS_1 = __importDefault(require_SENTINEL_SENTINELS());
    var SENTINEL_SET_1 = __importDefault(require_SENTINEL_SET());
    exports.default = {
      SENTINEL_SENTINELS: SENTINEL_SENTINELS_1.default,
      sentinelSentinels: SENTINEL_SENTINELS_1.default,
      SENTINEL_MASTER: SENTINEL_MASTER_1.default,
      sentinelMaster: SENTINEL_MASTER_1.default,
      SENTINEL_REPLICAS: SENTINEL_REPLICAS_1.default,
      sentinelReplicas: SENTINEL_REPLICAS_1.default,
      SENTINEL_MONITOR: SENTINEL_MONITOR_1.default,
      sentinelMonitor: SENTINEL_MONITOR_1.default,
      SENTINEL_SET: SENTINEL_SET_1.default,
      sentinelSet: SENTINEL_SET_1.default
    };
  }
});
var require_module = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/module.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands_1 = __importDefault(require_commands2());
    exports.default = {
      sentinel: commands_1.default
    };
  }
});
var require_wait_queue = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/wait-queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WaitQueue = void 0;
    var linked_list_1 = require_linked_list();
    var WaitQueue = class {
      #list = new linked_list_1.SinglyLinkedList();
      #queue = new linked_list_1.SinglyLinkedList();
      push(value) {
        const resolve42 = this.#queue.shift();
        if (resolve42 !== void 0) {
          resolve42(value);
          return;
        }
        this.#list.push(value);
      }
      shift() {
        return this.#list.shift();
      }
      wait() {
        return new Promise((resolve42) => this.#queue.push(resolve42));
      }
    };
    exports.WaitQueue = WaitQueue;
  }
});
var require_sentinel = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/lib/sentinel/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RedisSentinelFactory = exports.RedisSentinelClient = void 0;
    var node_events_1 = __require2("node:events");
    var client_1 = __importDefault(require_client());
    var commander_1 = require_commander();
    var commands_1 = __importDefault(require_commands());
    var utils_1 = require_utils2();
    var multi_commands_1 = __importDefault(require_multi_commands());
    var pub_sub_proxy_1 = require_pub_sub_proxy();
    var promises_1 = __require2("node:timers/promises");
    var module_1 = __importDefault(require_module());
    var wait_queue_1 = require_wait_queue();
    var cache_1 = require_cache();
    var RedisSentinelClient = class _RedisSentinelClient {
      #clientInfo;
      #internal;
      _self;
      /**
       * Indicates if the client connection is open
       *
       * @returns `true` if the client connection is open, `false` otherwise
       */
      get isOpen() {
        return this._self.#internal.isOpen;
      }
      /**
       * Indicates if the client connection is ready to accept commands
       *
       * @returns `true` if the client connection is ready, `false` otherwise
       */
      get isReady() {
        return this._self.#internal.isReady;
      }
      /**
       * Gets the command options configured for this client
       *
       * @returns The command options for this client or `undefined` if none were set
       */
      get commandOptions() {
        return this._self.#commandOptions;
      }
      #commandOptions;
      constructor(internal, clientInfo, commandOptions) {
        this._self = this;
        this.#internal = internal;
        this.#clientInfo = clientInfo;
        this.#commandOptions = commandOptions;
      }
      static factory(config) {
        const SentinelClient = (0, commander_1.attachConfig)({
          BaseClass: _RedisSentinelClient,
          commands: commands_1.default,
          createCommand: utils_1.createCommand,
          createModuleCommand: utils_1.createModuleCommand,
          createFunctionCommand: utils_1.createFunctionCommand,
          createScriptCommand: utils_1.createScriptCommand,
          config
        });
        SentinelClient.prototype.Multi = multi_commands_1.default.extend(config);
        return (internal, clientInfo, commandOptions) => {
          return Object.create(new SentinelClient(internal, clientInfo, commandOptions));
        };
      }
      static create(options2, internal, clientInfo, commandOptions) {
        return _RedisSentinelClient.factory(options2)(internal, clientInfo, commandOptions);
      }
      withCommandOptions(options2) {
        const proxy = Object.create(this);
        proxy._commandOptions = options2;
        return proxy;
      }
      _commandOptionsProxy(key, value) {
        const proxy = Object.create(this);
        proxy._commandOptions = Object.create(this._self.#commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
      }
      /**
       * Override the `typeMapping` command option
       */
      withTypeMapping(typeMapping) {
        return this._commandOptionsProxy("typeMapping", typeMapping);
      }
      async _execute(isReadonly, fn) {
        if (this._self.#clientInfo === void 0) {
          throw new Error("Attempted execution on released RedisSentinelClient lease");
        }
        return await this._self.#internal.execute(fn, this._self.#clientInfo);
      }
      async sendCommand(isReadonly, args, options2) {
        return this._execute(isReadonly, (client) => client.sendCommand(args, options2));
      }
      /**
       * @internal
       */
      async _executePipeline(isReadonly, commands) {
        return this._execute(isReadonly, (client) => client._executePipeline(commands));
      }
      /**f
        * @internal
        */
      async _executeMulti(isReadonly, commands) {
        return this._execute(isReadonly, (client) => client._executeMulti(commands));
      }
      MULTI() {
        return new this.Multi(this);
      }
      multi = this.MULTI;
      WATCH(key) {
        if (this._self.#clientInfo === void 0) {
          throw new Error("Attempted execution on released RedisSentinelClient lease");
        }
        return this._execute(false, (client) => client.watch(key));
      }
      watch = this.WATCH;
      UNWATCH() {
        if (this._self.#clientInfo === void 0) {
          throw new Error("Attempted execution on released RedisSentinelClient lease");
        }
        return this._execute(false, (client) => client.unwatch());
      }
      unwatch = this.UNWATCH;
      /**
       * Releases the client lease back to the pool
       *
       * After calling this method, the client instance should no longer be used as it
       * will be returned to the client pool and may be given to other operations.
       *
       * @returns A promise that resolves when the client is ready to be reused, or undefined
       *          if the client was immediately ready
       * @throws Error if the lease has already been released
       */
      release() {
        if (this._self.#clientInfo === void 0) {
          throw new Error("RedisSentinelClient lease already released");
        }
        const result = this._self.#internal.releaseClientLease(this._self.#clientInfo);
        this._self.#clientInfo = void 0;
        return result;
      }
    };
    exports.RedisSentinelClient = RedisSentinelClient;
    var RedisSentinel = class _RedisSentinel extends node_events_1.EventEmitter {
      _self;
      #internal;
      #options;
      /**
       * Indicates if the sentinel connection is open
       *
       * @returns `true` if the sentinel connection is open, `false` otherwise
       */
      get isOpen() {
        return this._self.#internal.isOpen;
      }
      /**
       * Indicates if the sentinel connection is ready to accept commands
       *
       * @returns `true` if the sentinel connection is ready, `false` otherwise
       */
      get isReady() {
        return this._self.#internal.isReady;
      }
      get commandOptions() {
        return this._self.#commandOptions;
      }
      #commandOptions;
      #trace = () => {
      };
      #reservedClientInfo;
      #masterClientCount = 0;
      #masterClientInfo;
      get clientSideCache() {
        return this._self.#internal.clientSideCache;
      }
      constructor(options2) {
        super();
        this._self = this;
        this.#options = options2;
        if (options2.commandOptions) {
          this.#commandOptions = options2.commandOptions;
        }
        this.#internal = new RedisSentinelInternal(options2);
        this.#internal.on("error", (err) => this.emit("error", err));
        this.#internal.on("topology-change", (event) => {
          if (!this.emit("topology-change", event)) {
            this._self.#trace(`RedisSentinel: re-emit for topology-change for ${event.type} event returned false`);
          }
        });
      }
      static factory(config) {
        const Sentinel = (0, commander_1.attachConfig)({
          BaseClass: _RedisSentinel,
          commands: commands_1.default,
          createCommand: utils_1.createCommand,
          createModuleCommand: utils_1.createModuleCommand,
          createFunctionCommand: utils_1.createFunctionCommand,
          createScriptCommand: utils_1.createScriptCommand,
          config
        });
        Sentinel.prototype.Multi = multi_commands_1.default.extend(config);
        return (options2) => {
          return Object.create(new Sentinel(options2));
        };
      }
      static create(options2) {
        return _RedisSentinel.factory(options2)(options2);
      }
      withCommandOptions(options2) {
        const proxy = Object.create(this);
        proxy._commandOptions = options2;
        return proxy;
      }
      _commandOptionsProxy(key, value) {
        const proxy = Object.create(this);
        proxy._self.#commandOptions = {
          ...this._self.#commandOptions || {},
          [key]: value
        };
        return proxy;
      }
      /**
       * Override the `typeMapping` command option
       */
      withTypeMapping(typeMapping) {
        return this._commandOptionsProxy("typeMapping", typeMapping);
      }
      async connect() {
        await this._self.#internal.connect();
        if (this._self.#options.reserveClient) {
          this._self.#reservedClientInfo = await this._self.#internal.getClientLease();
        }
        return this;
      }
      async _execute(isReadonly, fn) {
        let clientInfo;
        if (!isReadonly || !this._self.#internal.useReplicas) {
          if (this._self.#reservedClientInfo) {
            clientInfo = this._self.#reservedClientInfo;
          } else {
            this._self.#masterClientInfo ??= await this._self.#internal.getClientLease();
            clientInfo = this._self.#masterClientInfo;
            this._self.#masterClientCount++;
          }
        }
        try {
          return await this._self.#internal.execute(fn, clientInfo);
        } finally {
          if (clientInfo !== void 0 && clientInfo === this._self.#masterClientInfo && --this._self.#masterClientCount === 0) {
            const promise = this._self.#internal.releaseClientLease(clientInfo);
            this._self.#masterClientInfo = void 0;
            if (promise)
              await promise;
          }
        }
      }
      async use(fn) {
        const clientInfo = await this._self.#internal.getClientLease();
        try {
          return await fn(RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions));
        } finally {
          const promise = this._self.#internal.releaseClientLease(clientInfo);
          if (promise)
            await promise;
        }
      }
      async sendCommand(isReadonly, args, options2) {
        return this._execute(isReadonly, (client) => client.sendCommand(args, options2));
      }
      /**
       * @internal
       */
      async _executePipeline(isReadonly, commands) {
        return this._execute(isReadonly, (client) => client._executePipeline(commands));
      }
      /**f
        * @internal
        */
      async _executeMulti(isReadonly, commands) {
        return this._execute(isReadonly, (client) => client._executeMulti(commands));
      }
      MULTI() {
        return new this.Multi(this);
      }
      multi = this.MULTI;
      async close() {
        return this._self.#internal.close();
      }
      destroy() {
        return this._self.#internal.destroy();
      }
      async SUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#internal.subscribe(channels, listener, bufferMode);
      }
      subscribe = this.SUBSCRIBE;
      async UNSUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#internal.unsubscribe(channels, listener, bufferMode);
      }
      unsubscribe = this.UNSUBSCRIBE;
      async PSUBSCRIBE(patterns, listener, bufferMode) {
        return this._self.#internal.pSubscribe(patterns, listener, bufferMode);
      }
      pSubscribe = this.PSUBSCRIBE;
      async PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return this._self.#internal.pUnsubscribe(patterns, listener, bufferMode);
      }
      pUnsubscribe = this.PUNSUBSCRIBE;
      /**
       * Acquires a master client lease for exclusive operations
       *
       * Used when multiple commands need to run on an exclusive client (for example, using `WATCH/MULTI/EXEC`).
       * The returned client must be released after use with the `release()` method.
       *
       * @returns A promise that resolves to a Redis client connected to the master node
       * @example
       * ```javascript
       * const clientLease = await sentinel.acquire();
       *
       * try {
       *   await clientLease.watch('key');
       *   const resp = await clientLease.multi()
       *     .get('key')
       *     .exec();
       * } finally {
       *   clientLease.release();
       * }
       * ```
       */
      async acquire() {
        const clientInfo = await this._self.#internal.getClientLease();
        return RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions);
      }
      getSentinelNode() {
        return this._self.#internal.getSentinelNode();
      }
      getMasterNode() {
        return this._self.#internal.getMasterNode();
      }
      getReplicaNodes() {
        return this._self.#internal.getReplicaNodes();
      }
      setTracer(tracer) {
        if (tracer) {
          this._self.#trace = (msg) => {
            tracer.push(msg);
          };
        } else {
          this._self.#trace = () => {
          };
        }
        this._self.#internal.setTracer(tracer);
      }
    };
    exports.default = RedisSentinel;
    var RedisSentinelInternal = class extends node_events_1.EventEmitter {
      #isOpen = false;
      get isOpen() {
        return this.#isOpen;
      }
      #isReady = false;
      get isReady() {
        return this.#isReady;
      }
      #name;
      #nodeClientOptions;
      #sentinelClientOptions;
      #scanInterval;
      #passthroughClientErrorEvents;
      #RESP;
      #anotherReset = false;
      #configEpoch = 0;
      #sentinelRootNodes;
      #sentinelClient;
      #masterClients = [];
      #masterClientQueue;
      #masterPoolSize;
      #replicaClients = [];
      #replicaClientsIdx = 0;
      #replicaPoolSize;
      get useReplicas() {
        return this.#replicaPoolSize > 0;
      }
      #connectPromise;
      #maxCommandRediscovers;
      #pubSubProxy;
      #scanTimer;
      #destroy = false;
      #trace = () => {
      };
      #clientSideCache;
      get clientSideCache() {
        return this.#clientSideCache;
      }
      #validateOptions(options2) {
        if (options2?.clientSideCache && options2?.RESP !== 3) {
          throw new Error("Client Side Caching is only supported with RESP3");
        }
      }
      constructor(options2) {
        super();
        this.#validateOptions(options2);
        this.#name = options2.name;
        this.#RESP = options2.RESP;
        this.#sentinelRootNodes = Array.from(options2.sentinelRootNodes);
        this.#maxCommandRediscovers = options2.maxCommandRediscovers ?? 16;
        this.#masterPoolSize = options2.masterPoolSize ?? 1;
        this.#replicaPoolSize = options2.replicaPoolSize ?? 0;
        this.#scanInterval = options2.scanInterval ?? 0;
        this.#passthroughClientErrorEvents = options2.passthroughClientErrorEvents ?? false;
        this.#nodeClientOptions = options2.nodeClientOptions ? { ...options2.nodeClientOptions } : {};
        if (this.#nodeClientOptions.url !== void 0) {
          throw new Error("invalid nodeClientOptions for Sentinel");
        }
        if (options2.clientSideCache) {
          if (options2.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
            this.#clientSideCache = this.#nodeClientOptions.clientSideCache = options2.clientSideCache;
          } else {
            const cscConfig = options2.clientSideCache;
            this.#clientSideCache = this.#nodeClientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
          }
        }
        this.#sentinelClientOptions = options2.sentinelClientOptions ? Object.assign({}, options2.sentinelClientOptions) : {};
        this.#sentinelClientOptions.modules = module_1.default;
        if (this.#sentinelClientOptions.url !== void 0) {
          throw new Error("invalid sentinelClientOptions for Sentinel");
        }
        this.#masterClientQueue = new wait_queue_1.WaitQueue();
        for (let i2 = 0; i2 < this.#masterPoolSize; i2++) {
          this.#masterClientQueue.push(i2);
        }
        this.#pubSubProxy = new pub_sub_proxy_1.PubSubProxy(this.#nodeClientOptions, (err) => this.emit("error", err));
      }
      #createClient(node, clientOptions, reconnectStrategy) {
        return client_1.default.create({
          //first take the globally set RESP
          RESP: this.#RESP,
          //then take the client options, which can in theory overwrite it
          ...clientOptions,
          socket: {
            ...clientOptions.socket,
            host: node.host,
            port: node.port,
            ...reconnectStrategy !== void 0 && { reconnectStrategy }
          }
        });
      }
      /**
       * Gets a client lease from the master client pool
       *
       * @returns A client info object or a promise that resolves to a client info object
       *          when a client becomes available
       */
      getClientLease() {
        const id = this.#masterClientQueue.shift();
        if (id !== void 0) {
          return { id };
        }
        return this.#masterClientQueue.wait().then((id2) => ({ id: id2 }));
      }
      /**
       * Releases a client lease back to the pool
       *
       * If the client was used for a transaction that might have left it in a dirty state,
       * it will be reset before being returned to the pool.
       *
       * @param clientInfo The client info object representing the client to release
       * @returns A promise that resolves when the client is ready to be reused, or undefined
       *          if the client was immediately ready or no longer exists
       */
      releaseClientLease(clientInfo) {
        const client = this.#masterClients[clientInfo.id];
        if (client !== void 0) {
          const dirtyPromise = client.resetIfDirty();
          if (dirtyPromise) {
            return dirtyPromise.then(() => this.#masterClientQueue.push(clientInfo.id));
          }
        }
        this.#masterClientQueue.push(clientInfo.id);
      }
      async connect() {
        if (this.#isOpen) {
          throw new Error("already attempting to open");
        }
        try {
          this.#isOpen = true;
          this.#connectPromise = this.#connect();
          await this.#connectPromise;
          this.#isReady = true;
        } finally {
          this.#connectPromise = void 0;
          if (this.#scanInterval > 0) {
            this.#scanTimer = setInterval(this.#reset.bind(this), this.#scanInterval);
          }
        }
      }
      async #connect() {
        let count = 0;
        while (true) {
          this.#trace("starting connect loop");
          count += 1;
          if (this.#destroy) {
            this.#trace("in #connect and want to destroy");
            return;
          }
          try {
            this.#anotherReset = false;
            await this.transform(this.analyze(await this.observe()));
            if (this.#anotherReset) {
              this.#trace("#connect: anotherReset is true, so continuing");
              continue;
            }
            this.#trace("#connect: returning");
            return;
          } catch (e2) {
            this.#trace(`#connect: exception ${e2.message}`);
            if (!this.#isReady && count > this.#maxCommandRediscovers) {
              throw e2;
            }
            if (e2.message !== "no valid master node") {
              console.log(e2);
            }
            await (0, promises_1.setTimeout)(1e3);
          } finally {
            this.#trace("finished connect");
          }
        }
      }
      async execute(fn, clientInfo) {
        let iter = 0;
        while (true) {
          if (this.#connectPromise !== void 0) {
            await this.#connectPromise;
          }
          const client = this.#getClient(clientInfo);
          if (!client.isReady) {
            await this.#reset();
            continue;
          }
          const sockOpts = client.options?.socket;
          this.#trace("attemping to send command to " + sockOpts?.host + ":" + sockOpts?.port);
          try {
            return await fn(client);
          } catch (err) {
            if (++iter > this.#maxCommandRediscovers || !(err instanceof Error)) {
              throw err;
            }
            if (clientInfo !== void 0 && (err.message.startsWith("READONLY") || !client.isReady)) {
              await this.#reset();
              continue;
            }
            throw err;
          }
        }
      }
      async #createPubSub(client) {
        await client.pSubscribe(["switch-master", "[-+]sdown", "+slave", "+sentinel", "[-+]odown", "+slave-reconf-done"], (message, channel) => {
          this.#handlePubSubControlChannel(channel, message);
        }, true);
        return client;
      }
      async #handlePubSubControlChannel(channel, message) {
        this.#trace("pubsub control channel message on " + channel);
        this.#reset();
      }
      // if clientInfo is defined, it corresponds to a master client in the #masterClients array, otherwise loop around replicaClients
      #getClient(clientInfo) {
        if (clientInfo !== void 0) {
          return this.#masterClients[clientInfo.id];
        }
        if (this.#replicaClientsIdx >= this.#replicaClients.length) {
          this.#replicaClientsIdx = 0;
        }
        if (this.#replicaClients.length == 0) {
          throw new Error("no replicas available for read");
        }
        return this.#replicaClients[this.#replicaClientsIdx++];
      }
      async #reset() {
        if (this.#isReady == false || this.#destroy == true) {
          return;
        }
        if (this.#connectPromise !== void 0) {
          this.#anotherReset = true;
          return await this.#connectPromise;
        }
        try {
          this.#connectPromise = this.#connect();
          return await this.#connectPromise;
        } finally {
          this.#trace("finished reconfgure");
          this.#connectPromise = void 0;
        }
      }
      #handleSentinelFailure(node) {
        const found = this.#sentinelRootNodes.findIndex((rootNode) => rootNode.host === node.host && rootNode.port === node.port);
        if (found !== -1) {
          this.#sentinelRootNodes.splice(found, 1);
        }
        this.#reset();
      }
      async close() {
        this.#destroy = true;
        if (this.#connectPromise != void 0) {
          await this.#connectPromise;
        }
        this.#isReady = false;
        this.#clientSideCache?.onPoolClose();
        if (this.#scanTimer) {
          clearInterval(this.#scanTimer);
          this.#scanTimer = void 0;
        }
        const promises = [];
        if (this.#sentinelClient !== void 0) {
          if (this.#sentinelClient.isOpen) {
            promises.push(this.#sentinelClient.close());
          }
          this.#sentinelClient = void 0;
        }
        for (const client of this.#masterClients) {
          if (client.isOpen) {
            promises.push(client.close());
          }
        }
        this.#masterClients = [];
        for (const client of this.#replicaClients) {
          if (client.isOpen) {
            promises.push(client.close());
          }
        }
        this.#replicaClients = [];
        await Promise.all(promises);
        this.#pubSubProxy.destroy();
        this.#isOpen = false;
      }
      // destroy has to be async because its stopping others async events, timers and the like
      // and shouldn't return until its finished.
      async destroy() {
        this.#destroy = true;
        if (this.#connectPromise != void 0) {
          await this.#connectPromise;
        }
        this.#isReady = false;
        this.#clientSideCache?.onPoolClose();
        if (this.#scanTimer) {
          clearInterval(this.#scanTimer);
          this.#scanTimer = void 0;
        }
        if (this.#sentinelClient !== void 0) {
          if (this.#sentinelClient.isOpen) {
            this.#sentinelClient.destroy();
          }
          this.#sentinelClient = void 0;
        }
        for (const client of this.#masterClients) {
          if (client.isOpen) {
            client.destroy();
          }
        }
        this.#masterClients = [];
        for (const client of this.#replicaClients) {
          if (client.isOpen) {
            client.destroy();
          }
        }
        this.#replicaClients = [];
        this.#pubSubProxy.destroy();
        this.#isOpen = false;
        this.#destroy = false;
      }
      async subscribe(channels, listener, bufferMode) {
        return this.#pubSubProxy.subscribe(channels, listener, bufferMode);
      }
      async unsubscribe(channels, listener, bufferMode) {
        return this.#pubSubProxy.unsubscribe(channels, listener, bufferMode);
      }
      async pSubscribe(patterns, listener, bufferMode) {
        return this.#pubSubProxy.pSubscribe(patterns, listener, bufferMode);
      }
      async pUnsubscribe(patterns, listener, bufferMode) {
        return this.#pubSubProxy.pUnsubscribe(patterns, listener, bufferMode);
      }
      // observe/analyze/transform remediation functions
      async observe() {
        for (const node of this.#sentinelRootNodes) {
          let client;
          try {
            this.#trace(`observe: trying to connect to sentinel: ${node.host}:${node.port}`);
            client = this.#createClient(node, this.#sentinelClientOptions, false);
            client.on("error", (err) => this.emit("error", `obseve client error: ${err}`));
            await client.connect();
            this.#trace(`observe: connected to sentinel`);
            const [sentinelData, masterData, replicaData] = await Promise.all([
              client.sentinel.sentinelSentinels(this.#name),
              client.sentinel.sentinelMaster(this.#name),
              client.sentinel.sentinelReplicas(this.#name)
            ]);
            this.#trace("observe: got all sentinel data");
            const ret = {
              sentinelConnected: node,
              sentinelData,
              masterData,
              replicaData,
              currentMaster: this.getMasterNode(),
              currentReplicas: this.getReplicaNodes(),
              currentSentinel: this.getSentinelNode(),
              replicaPoolSize: this.#replicaPoolSize,
              useReplicas: this.useReplicas
            };
            return ret;
          } catch (err) {
            this.#trace(`observe: error ${err}`);
            this.emit("error", err);
          } finally {
            if (client !== void 0 && client.isOpen) {
              this.#trace(`observe: destroying sentinel client`);
              client.destroy();
            }
          }
        }
        this.#trace(`observe: none of the sentinels are available`);
        throw new Error("None of the sentinels are available");
      }
      analyze(observed) {
        let master = (0, utils_1.parseNode)(observed.masterData);
        if (master === void 0) {
          this.#trace(`analyze: no valid master node because ${observed.masterData.flags}`);
          throw new Error("no valid master node");
        }
        if (master.host === observed.currentMaster?.host && master.port === observed.currentMaster?.port) {
          this.#trace(`analyze: master node hasn't changed from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
          master = void 0;
        } else {
          this.#trace(`analyze: master node has changed to ${master.host}:${master.port} from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
        }
        let sentinel = observed.sentinelConnected;
        if (sentinel.host === observed.currentSentinel?.host && sentinel.port === observed.currentSentinel.port) {
          this.#trace(`analyze: sentinel node hasn't changed`);
          sentinel = void 0;
        } else {
          this.#trace(`analyze: sentinel node has changed to ${sentinel.host}:${sentinel.port}`);
        }
        const replicasToClose = [];
        const replicasToOpen = /* @__PURE__ */ new Map();
        const desiredSet = /* @__PURE__ */ new Set();
        const seen = /* @__PURE__ */ new Set();
        if (observed.useReplicas) {
          const replicaList = (0, utils_1.createNodeList)(observed.replicaData);
          for (const node of replicaList) {
            desiredSet.add(JSON.stringify(node));
          }
          for (const [node, value] of observed.currentReplicas) {
            if (!desiredSet.has(JSON.stringify(node))) {
              replicasToClose.push(node);
              this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToClose`);
            } else {
              seen.add(JSON.stringify(node));
              if (value != observed.replicaPoolSize) {
                replicasToOpen.set(node, observed.replicaPoolSize - value);
                this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
              }
            }
          }
          for (const node of replicaList) {
            if (!seen.has(JSON.stringify(node))) {
              replicasToOpen.set(node, observed.replicaPoolSize);
              this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
            }
          }
        }
        const ret = {
          sentinelList: [observed.sentinelConnected].concat((0, utils_1.createNodeList)(observed.sentinelData)),
          epoch: Number(observed.masterData["config-epoch"]),
          sentinelToOpen: sentinel,
          masterToOpen: master,
          replicasToClose,
          replicasToOpen
        };
        return ret;
      }
      async transform(analyzed) {
        this.#trace("transform: enter");
        let promises = [];
        if (analyzed.sentinelToOpen) {
          this.#trace(`transform: opening a new sentinel`);
          if (this.#sentinelClient !== void 0 && this.#sentinelClient.isOpen) {
            this.#trace(`transform: destroying old sentinel as open`);
            this.#sentinelClient.destroy();
            this.#sentinelClient = void 0;
          } else {
            this.#trace(`transform: not destroying old sentinel as not open`);
          }
          this.#trace(`transform: creating new sentinel to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
          const node = analyzed.sentinelToOpen;
          const client = this.#createClient(analyzed.sentinelToOpen, this.#sentinelClientOptions, false);
          client.on("error", (err) => {
            if (this.#passthroughClientErrorEvents) {
              this.emit("error", new Error(`Sentinel Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
            }
            const event2 = {
              type: "SENTINEL",
              node: (0, utils_1.clientSocketToNode)(client.options.socket),
              error: err
            };
            this.emit("client-error", event2);
            this.#handleSentinelFailure(node);
          }).on("end", () => this.#handleSentinelFailure(node));
          this.#sentinelClient = client;
          this.#trace(`transform: adding sentinel client connect() to promise list`);
          const promise = this.#sentinelClient.connect().then((client2) => {
            return this.#createPubSub(client2);
          });
          promises.push(promise);
          this.#trace(`created sentinel client to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
          const event = {
            type: "SENTINEL_CHANGE",
            node: analyzed.sentinelToOpen
          };
          this.#trace(`transform: emiting topology-change event for sentinel_change`);
          if (!this.emit("topology-change", event)) {
            this.#trace(`transform: emit for topology-change for sentinel_change returned false`);
          }
        }
        if (analyzed.masterToOpen) {
          this.#trace(`transform: opening a new master`);
          const masterPromises = [];
          const masterWatches = [];
          this.#trace(`transform: destroying old masters if open`);
          for (const client of this.#masterClients) {
            masterWatches.push(client.isWatching || client.isDirtyWatch);
            if (client.isOpen) {
              client.destroy();
            }
          }
          this.#masterClients = [];
          this.#trace(`transform: creating all master clients and adding connect promises`);
          for (let i2 = 0; i2 < this.#masterPoolSize; i2++) {
            const node = analyzed.masterToOpen;
            const client = this.#createClient(analyzed.masterToOpen, this.#nodeClientOptions);
            client.on("error", (err) => {
              if (this.#passthroughClientErrorEvents) {
                this.emit("error", new Error(`Master Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
              }
              const event2 = {
                type: "MASTER",
                node: (0, utils_1.clientSocketToNode)(client.options.socket),
                error: err
              };
              this.emit("client-error", event2);
            });
            if (masterWatches[i2]) {
              client.setDirtyWatch("sentinel config changed in middle of a WATCH Transaction");
            }
            this.#masterClients.push(client);
            masterPromises.push(client.connect());
            this.#trace(`created master client to ${analyzed.masterToOpen.host}:${analyzed.masterToOpen.port}`);
          }
          this.#trace(`transform: adding promise to change #pubSubProxy node`);
          masterPromises.push(this.#pubSubProxy.changeNode(analyzed.masterToOpen));
          promises.push(...masterPromises);
          const event = {
            type: "MASTER_CHANGE",
            node: analyzed.masterToOpen
          };
          this.#trace(`transform: emiting topology-change event for master_change`);
          if (!this.emit("topology-change", event)) {
            this.#trace(`transform: emit for topology-change for master_change returned false`);
          }
          this.#configEpoch++;
        }
        const replicaCloseSet = /* @__PURE__ */ new Set();
        for (const node of analyzed.replicasToClose) {
          const str = JSON.stringify(node);
          replicaCloseSet.add(str);
        }
        const newClientList = [];
        const removedSet = /* @__PURE__ */ new Set();
        for (const replica of this.#replicaClients) {
          const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
          const str = JSON.stringify(node);
          if (replicaCloseSet.has(str) || !replica.isOpen) {
            if (replica.isOpen) {
              const sockOpts = replica.options?.socket;
              this.#trace(`destroying replica client to ${sockOpts?.host}:${sockOpts?.port}`);
              replica.destroy();
            }
            if (!removedSet.has(str)) {
              const event = {
                type: "REPLICA_REMOVE",
                node
              };
              this.emit("topology-change", event);
              removedSet.add(str);
            }
          } else {
            newClientList.push(replica);
          }
        }
        this.#replicaClients = newClientList;
        if (analyzed.replicasToOpen.size != 0) {
          for (const [node, size] of analyzed.replicasToOpen) {
            for (let i2 = 0; i2 < size; i2++) {
              const client = this.#createClient(node, this.#nodeClientOptions);
              client.on("error", (err) => {
                if (this.#passthroughClientErrorEvents) {
                  this.emit("error", new Error(`Replica Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
                }
                const event2 = {
                  type: "REPLICA",
                  node: (0, utils_1.clientSocketToNode)(client.options.socket),
                  error: err
                };
                this.emit("client-error", event2);
              });
              this.#replicaClients.push(client);
              promises.push(client.connect());
              this.#trace(`created replica client to ${node.host}:${node.port}`);
            }
            const event = {
              type: "REPLICA_ADD",
              node
            };
            this.emit("topology-change", event);
          }
        }
        if (analyzed.sentinelList.length != this.#sentinelRootNodes.length) {
          this.#sentinelRootNodes = analyzed.sentinelList;
          const event = {
            type: "SENTINE_LIST_CHANGE",
            size: analyzed.sentinelList.length
          };
          this.emit("topology-change", event);
        }
        await Promise.all(promises);
        this.#trace("transform: exit");
      }
      // introspection functions
      getMasterNode() {
        if (this.#masterClients.length == 0) {
          return void 0;
        }
        for (const master of this.#masterClients) {
          if (master.isReady) {
            return (0, utils_1.clientSocketToNode)(master.options.socket);
          }
        }
        return void 0;
      }
      getSentinelNode() {
        if (this.#sentinelClient === void 0) {
          return void 0;
        }
        return (0, utils_1.clientSocketToNode)(this.#sentinelClient.options.socket);
      }
      getReplicaNodes() {
        const ret = /* @__PURE__ */ new Map();
        const initialMap = /* @__PURE__ */ new Map();
        for (const replica of this.#replicaClients) {
          const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
          const hash2 = JSON.stringify(node);
          if (replica.isReady) {
            initialMap.set(hash2, (initialMap.get(hash2) ?? 0) + 1);
          } else {
            if (!initialMap.has(hash2)) {
              initialMap.set(hash2, 0);
            }
          }
        }
        for (const [key, value] of initialMap) {
          ret.set(JSON.parse(key), value);
        }
        return ret;
      }
      setTracer(tracer) {
        if (tracer) {
          this.#trace = (msg) => {
            tracer.push(msg);
          };
        } else {
          this.#trace = () => {
          };
        }
      }
    };
    var RedisSentinelFactory = class extends node_events_1.EventEmitter {
      options;
      #sentinelRootNodes;
      #replicaIdx = -1;
      constructor(options2) {
        super();
        this.options = options2;
        this.#sentinelRootNodes = options2.sentinelRootNodes;
      }
      async updateSentinelRootNodes() {
        for (const node of this.#sentinelRootNodes) {
          const client = client_1.default.create({
            ...this.options.sentinelClientOptions,
            socket: {
              ...this.options.sentinelClientOptions?.socket,
              host: node.host,
              port: node.port,
              reconnectStrategy: false
            },
            modules: module_1.default
          }).on("error", (err) => this.emit(`updateSentinelRootNodes: ${err}`));
          try {
            await client.connect();
          } catch {
            if (client.isOpen) {
              client.destroy();
            }
            continue;
          }
          try {
            const sentinelData = await client.sentinel.sentinelSentinels(this.options.name);
            this.#sentinelRootNodes = [node].concat((0, utils_1.createNodeList)(sentinelData));
            return;
          } finally {
            client.destroy();
          }
        }
        throw new Error("Couldn't connect to any sentinel node");
      }
      async getMasterNode() {
        let connected = false;
        for (const node of this.#sentinelRootNodes) {
          const client = client_1.default.create({
            ...this.options.sentinelClientOptions,
            socket: {
              ...this.options.sentinelClientOptions?.socket,
              host: node.host,
              port: node.port,
              reconnectStrategy: false
            },
            modules: module_1.default
          }).on("error", (err) => this.emit(`getMasterNode: ${err}`));
          try {
            await client.connect();
          } catch {
            if (client.isOpen) {
              client.destroy();
            }
            continue;
          }
          connected = true;
          try {
            const masterData = await client.sentinel.sentinelMaster(this.options.name);
            let master = (0, utils_1.parseNode)(masterData);
            if (master === void 0) {
              continue;
            }
            return master;
          } finally {
            client.destroy();
          }
        }
        if (connected) {
          throw new Error("Master Node Not Enumerated");
        }
        throw new Error("couldn't connect to any sentinels");
      }
      async getMasterClient() {
        const master = await this.getMasterNode();
        return client_1.default.create({
          ...this.options.nodeClientOptions,
          socket: {
            ...this.options.nodeClientOptions?.socket,
            host: master.host,
            port: master.port
          }
        });
      }
      async getReplicaNodes() {
        let connected = false;
        for (const node of this.#sentinelRootNodes) {
          const client = client_1.default.create({
            ...this.options.sentinelClientOptions,
            socket: {
              ...this.options.sentinelClientOptions?.socket,
              host: node.host,
              port: node.port,
              reconnectStrategy: false
            },
            modules: module_1.default
          }).on("error", (err) => this.emit(`getReplicaNodes: ${err}`));
          try {
            await client.connect();
          } catch {
            if (client.isOpen) {
              client.destroy();
            }
            continue;
          }
          connected = true;
          try {
            const replicaData = await client.sentinel.sentinelReplicas(this.options.name);
            const replicas = (0, utils_1.createNodeList)(replicaData);
            if (replicas.length == 0) {
              continue;
            }
            return replicas;
          } finally {
            client.destroy();
          }
        }
        if (connected) {
          throw new Error("No Replicas Nodes Enumerated");
        }
        throw new Error("couldn't connect to any sentinels");
      }
      async getReplicaClient() {
        const replicas = await this.getReplicaNodes();
        if (replicas.length == 0) {
          throw new Error("no available replicas");
        }
        this.#replicaIdx++;
        if (this.#replicaIdx >= replicas.length) {
          this.#replicaIdx = 0;
        }
        return client_1.default.create({
          ...this.options.nodeClientOptions,
          socket: {
            ...this.options.nodeClientOptions?.socket,
            host: replicas[this.#replicaIdx].host,
            port: replicas[this.#replicaIdx].port
          }
        });
      }
    };
    exports.RedisSentinelFactory = RedisSentinelFactory;
  }
});
var require_dist = __commonJS({
  "node_modules/.deno/@redis+client@5.9.0/node_modules/@redis/client/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p in m3) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m3, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicPooledClientSideCache = exports.BasicClientSideCache = exports.REDIS_FLUSH_MODES = exports.COMMAND_LIST_FILTER_BY = exports.CLUSTER_SLOT_STATES = exports.FAILOVER_MODES = exports.CLIENT_KILL_FILTERS = exports.GEO_REPLY_WITH = exports.createSentinel = exports.createCluster = exports.createClientPool = exports.createClient = exports.defineScript = exports.VerbatimString = exports.RESP_TYPES = void 0;
    var decoder_1 = require_decoder();
    Object.defineProperty(exports, "RESP_TYPES", { enumerable: true, get: function() {
      return decoder_1.RESP_TYPES;
    } });
    var verbatim_string_1 = require_verbatim_string();
    Object.defineProperty(exports, "VerbatimString", { enumerable: true, get: function() {
      return verbatim_string_1.VerbatimString;
    } });
    var lua_script_1 = require_lua_script();
    Object.defineProperty(exports, "defineScript", { enumerable: true, get: function() {
      return lua_script_1.defineScript;
    } });
    __exportStar(require_errors(), exports);
    var client_1 = __importDefault(require_client());
    exports.createClient = client_1.default.create;
    var pool_1 = require_pool();
    exports.createClientPool = pool_1.RedisClientPool.create;
    var cluster_1 = __importDefault(require_cluster());
    exports.createCluster = cluster_1.default.create;
    var sentinel_1 = __importDefault(require_sentinel());
    exports.createSentinel = sentinel_1.default.create;
    var GEOSEARCH_WITH_1 = require_GEOSEARCH_WITH();
    Object.defineProperty(exports, "GEO_REPLY_WITH", { enumerable: true, get: function() {
      return GEOSEARCH_WITH_1.GEO_REPLY_WITH;
    } });
    var commands_1 = require_commands();
    Object.defineProperty(exports, "CLIENT_KILL_FILTERS", { enumerable: true, get: function() {
      return commands_1.CLIENT_KILL_FILTERS;
    } });
    Object.defineProperty(exports, "FAILOVER_MODES", { enumerable: true, get: function() {
      return commands_1.FAILOVER_MODES;
    } });
    Object.defineProperty(exports, "CLUSTER_SLOT_STATES", { enumerable: true, get: function() {
      return commands_1.CLUSTER_SLOT_STATES;
    } });
    Object.defineProperty(exports, "COMMAND_LIST_FILTER_BY", { enumerable: true, get: function() {
      return commands_1.COMMAND_LIST_FILTER_BY;
    } });
    Object.defineProperty(exports, "REDIS_FLUSH_MODES", { enumerable: true, get: function() {
      return commands_1.REDIS_FLUSH_MODES;
    } });
    var cache_1 = require_cache();
    Object.defineProperty(exports, "BasicClientSideCache", { enumerable: true, get: function() {
      return cache_1.BasicClientSideCache;
    } });
    Object.defineProperty(exports, "BasicPooledClientSideCache", { enumerable: true, get: function() {
      return cache_1.BasicPooledClientSideCache;
    } });
  }
});
var require_ADD = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/ADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds an item to a Bloom Filter
       * @param parser - The command parser
       * @param key - The name of the Bloom filter
       * @param item - The item to add to the filter
       */
      parseCommand(parser, key, item) {
        parser.push("BF.ADD");
        parser.pushKey(key);
        parser.push(item);
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_CARD = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/CARD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the cardinality (number of items) in a Bloom Filter
       * @param parser - The command parser
       * @param key - The name of the Bloom filter to query
       */
      parseCommand(parser, key) {
        parser.push("BF.CARD");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_EXISTS2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/EXISTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Checks if an item exists in a Bloom Filter
       * @param parser - The command parser
       * @param key - The name of the Bloom filter
       * @param item - The item to check for existence
       */
      parseCommand(parser, key, item) {
        parser.push("BF.EXISTS");
        parser.pushKey(key);
        parser.push(item);
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_helpers = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformInfoV2Reply = void 0;
    var client_1 = require_dist();
    function transformInfoV2Reply(reply, typeMapping) {
      const mapType = typeMapping ? typeMapping[client_1.RESP_TYPES.MAP] : void 0;
      switch (mapType) {
        case Array: {
          return reply;
        }
        case Map: {
          const ret = /* @__PURE__ */ new Map();
          for (let i2 = 0; i2 < reply.length; i2 += 2) {
            ret.set(reply[i2].toString(), reply[i2 + 1]);
          }
          return ret;
        }
        default: {
          const ret = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < reply.length; i2 += 2) {
            ret[reply[i2].toString()] = reply[i2 + 1];
          }
          return ret;
        }
      }
    }
    exports.transformInfoV2Reply = transformInfoV2Reply;
  }
});
var require_INFO2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_helpers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns information about a Bloom Filter, including capacity, size, number of filters, items inserted, and expansion rate
       * @param parser - The command parser
       * @param key - The name of the Bloom filter to get information about
       */
      parseCommand(parser, key) {
        parser.push("BF.INFO");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply, _, typeMapping) => {
          return (0, helpers_1.transformInfoV2Reply)(reply, typeMapping);
        },
        3: void 0
      }
    };
  }
});
var require_INSERT = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/INSERT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds one or more items to a Bloom Filter, creating it if it does not exist
       * @param parser - The command parser
       * @param key - The name of the Bloom filter
       * @param items - One or more items to add to the filter
       * @param options - Optional parameters for filter creation
       * @param options.CAPACITY - Desired capacity for a new filter
       * @param options.ERROR - Desired error rate for a new filter
       * @param options.EXPANSION - Expansion rate for a new filter
       * @param options.NOCREATE - If true, prevents automatic filter creation
       * @param options.NONSCALING - Prevents the filter from creating additional sub-filters
       */
      parseCommand(parser, key, items, options2) {
        parser.push("BF.INSERT");
        parser.pushKey(key);
        if (options2?.CAPACITY !== void 0) {
          parser.push("CAPACITY", options2.CAPACITY.toString());
        }
        if (options2?.ERROR !== void 0) {
          parser.push("ERROR", options2.ERROR.toString());
        }
        if (options2?.EXPANSION !== void 0) {
          parser.push("EXPANSION", options2.EXPANSION.toString());
        }
        if (options2?.NOCREATE) {
          parser.push("NOCREATE");
        }
        if (options2?.NONSCALING) {
          parser.push("NONSCALING");
        }
        parser.push("ITEMS");
        parser.pushVariadic(items);
      },
      transformReply: generic_transformers_1.transformBooleanArrayReply
    };
  }
});
var require_LOADCHUNK = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/LOADCHUNK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Restores a Bloom Filter chunk previously saved using SCANDUMP
       * @param parser - The command parser
       * @param key - The name of the Bloom filter to restore
       * @param iterator - Iterator value from the SCANDUMP command
       * @param chunk - Data chunk from the SCANDUMP command
       */
      parseCommand(parser, key, iterator, chunk) {
        parser.push("BF.LOADCHUNK");
        parser.pushKey(key);
        parser.push(iterator.toString(), chunk);
      },
      transformReply: void 0
    };
  }
});
var require_MADD = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/MADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds multiple items to a Bloom Filter in a single call
       * @param parser - The command parser
       * @param key - The name of the Bloom filter
       * @param items - One or more items to add to the filter
       */
      parseCommand(parser, key, items) {
        parser.push("BF.MADD");
        parser.pushKey(key);
        parser.pushVariadic(items);
      },
      transformReply: generic_transformers_1.transformBooleanArrayReply
    };
  }
});
var require_MEXISTS = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/MEXISTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Checks if multiple items exist in a Bloom Filter in a single call
       * @param parser - The command parser
       * @param key - The name of the Bloom filter
       * @param items - One or more items to check for existence
       */
      parseCommand(parser, key, items) {
        parser.push("BF.MEXISTS");
        parser.pushKey(key);
        parser.pushVariadic(items);
      },
      transformReply: generic_transformers_1.transformBooleanArrayReply
    };
  }
});
var require_RESERVE = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/RESERVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Creates an empty Bloom Filter with a given desired error ratio and initial capacity
       * @param parser - The command parser
       * @param key - The name of the Bloom filter to create
       * @param errorRate - The desired probability for false positives (between 0 and 1)
       * @param capacity - The number of entries intended to be added to the filter
       * @param options - Optional parameters to tune the filter
       * @param options.EXPANSION - Expansion rate for the filter
       * @param options.NONSCALING - Prevents the filter from creating additional sub-filters
       */
      parseCommand(parser, key, errorRate, capacity, options2) {
        parser.push("BF.RESERVE");
        parser.pushKey(key);
        parser.push(errorRate.toString(), capacity.toString());
        if (options2?.EXPANSION) {
          parser.push("EXPANSION", options2.EXPANSION.toString());
        }
        if (options2?.NONSCALING) {
          parser.push("NONSCALING");
        }
      },
      transformReply: void 0
    };
  }
});
var require_SCANDUMP = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/SCANDUMP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Begins an incremental save of a Bloom Filter. This is useful for large filters that can't be saved at once
       * @param parser - The command parser
       * @param key - The name of the Bloom filter to save
       * @param iterator - Iterator value; Start at 0, and use the iterator from the response for the next chunk
       */
      parseCommand(parser, key, iterator) {
        parser.push("BF.SCANDUMP");
        parser.pushKey(key);
        parser.push(iterator.toString());
      },
      transformReply(reply) {
        return {
          iterator: reply[0],
          chunk: reply[1]
        };
      }
    };
  }
});
var require_bloom = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/bloom/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p in m3) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m3, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ADD_1 = __importDefault(require_ADD());
    var CARD_1 = __importDefault(require_CARD());
    var EXISTS_1 = __importDefault(require_EXISTS2());
    var INFO_1 = __importDefault(require_INFO2());
    var INSERT_1 = __importDefault(require_INSERT());
    var LOADCHUNK_1 = __importDefault(require_LOADCHUNK());
    var MADD_1 = __importDefault(require_MADD());
    var MEXISTS_1 = __importDefault(require_MEXISTS());
    var RESERVE_1 = __importDefault(require_RESERVE());
    var SCANDUMP_1 = __importDefault(require_SCANDUMP());
    __exportStar(require_helpers(), exports);
    exports.default = {
      ADD: ADD_1.default,
      add: ADD_1.default,
      CARD: CARD_1.default,
      card: CARD_1.default,
      EXISTS: EXISTS_1.default,
      exists: EXISTS_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      INSERT: INSERT_1.default,
      insert: INSERT_1.default,
      LOADCHUNK: LOADCHUNK_1.default,
      loadChunk: LOADCHUNK_1.default,
      MADD: MADD_1.default,
      mAdd: MADD_1.default,
      MEXISTS: MEXISTS_1.default,
      mExists: MEXISTS_1.default,
      RESERVE: RESERVE_1.default,
      reserve: RESERVE_1.default,
      SCANDUMP: SCANDUMP_1.default,
      scanDump: SCANDUMP_1.default
    };
  }
});
var require_INCRBY2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INCRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Increases the count of one or more items in a Count-Min Sketch
       * @param parser - The command parser
       * @param key - The name of the sketch
       * @param items - A single item or array of items to increment, each with an item and increment value
       */
      parseCommand(parser, key, items) {
        parser.push("CMS.INCRBY");
        parser.pushKey(key);
        if (Array.isArray(items)) {
          for (const item of items) {
            pushIncrByItem(parser, item);
          }
        } else {
          pushIncrByItem(parser, items);
        }
      },
      transformReply: void 0
    };
    function pushIncrByItem(parser, { item, incrementBy }) {
      parser.push(item, incrementBy.toString());
    }
  }
});
var require_INFO3 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bloom_1 = require_bloom();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns width, depth, and total count of items in a Count-Min Sketch
       * @param parser - The command parser
       * @param key - The name of the sketch to get information about
       */
      parseCommand(parser, key) {
        parser.push("CMS.INFO");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply, _, typeMapping) => {
          return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
        },
        3: void 0
      }
    };
  }
});
var require_INITBYDIM = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYDIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Initialize a Count-Min Sketch using width and depth parameters
       * @param parser - The command parser
       * @param key - The name of the sketch
       * @param width - Number of counters in each array (must be a multiple of 2)
       * @param depth - Number of counter arrays (determines accuracy of estimates)
       */
      parseCommand(parser, key, width, depth) {
        parser.push("CMS.INITBYDIM");
        parser.pushKey(key);
        parser.push(width.toString(), depth.toString());
      },
      transformReply: void 0
    };
  }
});
var require_INITBYPROB = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYPROB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Initialize a Count-Min Sketch using error rate and probability parameters
       * @param parser - The command parser
       * @param key - The name of the sketch
       * @param error - Estimate error, as a decimal between 0 and 1
       * @param probability - The desired probability for inflated count, as a decimal between 0 and 1
       */
      parseCommand(parser, key, error, probability) {
        parser.push("CMS.INITBYPROB");
        parser.pushKey(key);
        parser.push(error.toString(), probability.toString());
      },
      transformReply: void 0
    };
  }
});
var require_MERGE = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/MERGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Merges multiple Count-Min Sketches into a single sketch, with optional weights
       * @param parser - The command parser
       * @param destination - The name of the destination sketch
       * @param source - Array of sketch names or array of sketches with weights
       */
      parseCommand(parser, destination, source) {
        parser.push("CMS.MERGE");
        parser.pushKey(destination);
        parser.push(source.length.toString());
        if (isPlainSketches(source)) {
          parser.pushVariadic(source);
        } else {
          for (let i2 = 0; i2 < source.length; i2++) {
            parser.push(source[i2].name);
          }
          parser.push("WEIGHTS");
          for (let i2 = 0; i2 < source.length; i2++) {
            parser.push(source[i2].weight.toString());
          }
        }
      },
      transformReply: void 0
    };
    function isPlainSketches(src2) {
      return typeof src2[0] === "string" || src2[0] instanceof Buffer;
    }
  }
});
var require_QUERY = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/QUERY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the count for one or more items in a Count-Min Sketch
       * @param parser - The command parser
       * @param key - The name of the sketch
       * @param items - One or more items to get counts for
       */
      parseCommand(parser, key, items) {
        parser.push("CMS.QUERY");
        parser.pushKey(key);
        parser.pushVariadic(items);
      },
      transformReply: void 0
    };
  }
});
var require_count_min_sketch = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var INCRBY_1 = __importDefault(require_INCRBY2());
    var INFO_1 = __importDefault(require_INFO3());
    var INITBYDIM_1 = __importDefault(require_INITBYDIM());
    var INITBYPROB_1 = __importDefault(require_INITBYPROB());
    var MERGE_1 = __importDefault(require_MERGE());
    var QUERY_1 = __importDefault(require_QUERY());
    exports.default = {
      INCRBY: INCRBY_1.default,
      incrBy: INCRBY_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      INITBYDIM: INITBYDIM_1.default,
      initByDim: INITBYDIM_1.default,
      INITBYPROB: INITBYPROB_1.default,
      initByProb: INITBYPROB_1.default,
      MERGE: MERGE_1.default,
      merge: MERGE_1.default,
      QUERY: QUERY_1.default,
      query: QUERY_1.default
    };
  }
});
var require_ADD2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds an item to a Cuckoo Filter, creating the filter if it does not exist
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter
       * @param item - The item to add to the filter
       */
      parseCommand(parser, key, item) {
        parser.push("CF.ADD");
        parser.pushKey(key);
        parser.push(item);
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_ADDNX = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADDNX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds an item to a Cuckoo Filter only if it does not exist
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter
       * @param item - The item to add to the filter if it doesn't exist
       */
      parseCommand(parser, key, item) {
        parser.push("CF.ADDNX");
        parser.pushKey(key);
        parser.push(item);
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_COUNT = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the number of times an item appears in a Cuckoo Filter
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter
       * @param item - The item to count occurrences of
       */
      parseCommand(parser, key, item) {
        parser.push("CF.COUNT");
        parser.pushKey(key);
        parser.push(item);
      },
      transformReply: void 0
    };
  }
});
var require_DEL2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/DEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes an item from a Cuckoo Filter if it exists
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter
       * @param item - The item to remove from the filter
       */
      parseCommand(parser, key, item) {
        parser.push("CF.DEL");
        parser.pushKey(key);
        parser.push(item);
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_EXISTS3 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/EXISTS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Checks if an item exists in a Cuckoo Filter
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter
       * @param item - The item to check for existence
       */
      parseCommand(parser, key, item) {
        parser.push("CF.EXISTS");
        parser.pushKey(key);
        parser.push(item);
      },
      transformReply: generic_transformers_1.transformBooleanReply
    };
  }
});
var require_INFO4 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bloom_1 = require_bloom();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns detailed information about a Cuckoo Filter including size, buckets, filters count, items statistics and configuration
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter to get information about
       */
      parseCommand(parser, key) {
        parser.push("CF.INFO");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply, _, typeMapping) => {
          return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
        },
        3: void 0
      }
    };
  }
});
var require_INSERT2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCfInsertArguments = void 0;
    var generic_transformers_1 = require_generic_transformers();
    function parseCfInsertArguments(parser, key, items, options2) {
      parser.pushKey(key);
      if (options2?.CAPACITY !== void 0) {
        parser.push("CAPACITY", options2.CAPACITY.toString());
      }
      if (options2?.NOCREATE) {
        parser.push("NOCREATE");
      }
      parser.push("ITEMS");
      parser.pushVariadic(items);
    }
    exports.parseCfInsertArguments = parseCfInsertArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds one or more items to a Cuckoo Filter, creating it if it does not exist
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter
       * @param items - One or more items to add to the filter
       * @param options - Optional parameters for filter creation
       * @param options.CAPACITY - The number of entries intended to be added to the filter
       * @param options.NOCREATE - If true, prevents automatic filter creation
       */
      parseCommand(...args) {
        args[0].push("CF.INSERT");
        parseCfInsertArguments(...args);
      },
      transformReply: generic_transformers_1.transformBooleanArrayReply
    };
  }
});
var require_INSERTNX = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERTNX.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var INSERT_1 = __importStar(require_INSERT2());
    exports.default = {
      IS_READ_ONLY: INSERT_1.default.IS_READ_ONLY,
      parseCommand(...args) {
        args[0].push("CF.INSERTNX");
        (0, INSERT_1.parseCfInsertArguments)(...args);
      },
      transformReply: INSERT_1.default.transformReply
    };
  }
});
var require_LOADCHUNK2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/LOADCHUNK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Restores a Cuckoo Filter chunk previously saved using SCANDUMP
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter to restore
       * @param iterator - Iterator value from the SCANDUMP command
       * @param chunk - Data chunk from the SCANDUMP command
       */
      parseCommand(parser, key, iterator, chunk) {
        parser.push("CF.LOADCHUNK");
        parser.pushKey(key);
        parser.push(iterator.toString(), chunk);
      },
      transformReply: void 0
    };
  }
});
var require_RESERVE2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/RESERVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Creates an empty Cuckoo Filter with specified capacity and parameters
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter to create
       * @param capacity - The number of entries intended to be added to the filter
       * @param options - Optional parameters to tune the filter
       * @param options.BUCKETSIZE - Number of items in each bucket
       * @param options.MAXITERATIONS - Maximum number of iterations before declaring filter full
       * @param options.EXPANSION - Number of additional buckets per expansion
       */
      parseCommand(parser, key, capacity, options2) {
        parser.push("CF.RESERVE");
        parser.pushKey(key);
        parser.push(capacity.toString());
        if (options2?.BUCKETSIZE !== void 0) {
          parser.push("BUCKETSIZE", options2.BUCKETSIZE.toString());
        }
        if (options2?.MAXITERATIONS !== void 0) {
          parser.push("MAXITERATIONS", options2.MAXITERATIONS.toString());
        }
        if (options2?.EXPANSION !== void 0) {
          parser.push("EXPANSION", options2.EXPANSION.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_SCANDUMP2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/SCANDUMP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Begins an incremental save of a Cuckoo Filter. This is useful for large filters that can't be saved at once
       * @param parser - The command parser
       * @param key - The name of the Cuckoo filter to save
       * @param iterator - Iterator value; Start at 0, and use the iterator from the response for the next chunk
       */
      parseCommand(parser, key, iterator) {
        parser.push("CF.SCANDUMP");
        parser.pushKey(key);
        parser.push(iterator.toString());
      },
      transformReply(reply) {
        return {
          iterator: reply[0],
          chunk: reply[1]
        };
      }
    };
  }
});
var require_cuckoo = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/cuckoo/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ADD_1 = __importDefault(require_ADD2());
    var ADDNX_1 = __importDefault(require_ADDNX());
    var COUNT_1 = __importDefault(require_COUNT());
    var DEL_1 = __importDefault(require_DEL2());
    var EXISTS_1 = __importDefault(require_EXISTS3());
    var INFO_1 = __importDefault(require_INFO4());
    var INSERT_1 = __importDefault(require_INSERT2());
    var INSERTNX_1 = __importDefault(require_INSERTNX());
    var LOADCHUNK_1 = __importDefault(require_LOADCHUNK2());
    var RESERVE_1 = __importDefault(require_RESERVE2());
    var SCANDUMP_1 = __importDefault(require_SCANDUMP2());
    exports.default = {
      ADD: ADD_1.default,
      add: ADD_1.default,
      ADDNX: ADDNX_1.default,
      addNX: ADDNX_1.default,
      COUNT: COUNT_1.default,
      count: COUNT_1.default,
      DEL: DEL_1.default,
      del: DEL_1.default,
      EXISTS: EXISTS_1.default,
      exists: EXISTS_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      INSERT: INSERT_1.default,
      insert: INSERT_1.default,
      INSERTNX: INSERTNX_1.default,
      insertNX: INSERTNX_1.default,
      LOADCHUNK: LOADCHUNK_1.default,
      loadChunk: LOADCHUNK_1.default,
      RESERVE: RESERVE_1.default,
      reserve: RESERVE_1.default,
      SCANDUMP: SCANDUMP_1.default,
      scanDump: SCANDUMP_1.default
    };
  }
});
var require_ADD3 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/ADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds one or more observations to a t-digest sketch
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       * @param values - Array of numeric values to add to the sketch
       */
      parseCommand(parser, key, values) {
        parser.push("TDIGEST.ADD");
        parser.pushKey(key);
        for (const value of values) {
          parser.push(value.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_BYRANK = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/BYRANK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformByRankArguments = void 0;
    var generic_transformers_1 = require_generic_transformers();
    function transformByRankArguments(parser, key, ranks) {
      parser.pushKey(key);
      for (const rank of ranks) {
        parser.push(rank.toString());
      }
    }
    exports.transformByRankArguments = transformByRankArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns value estimates for one or more ranks in a t-digest sketch
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       * @param ranks - Array of ranks to get value estimates for (ascending order)
       */
      parseCommand(...args) {
        args[0].push("TDIGEST.BYRANK");
        transformByRankArguments(...args);
      },
      transformReply: generic_transformers_1.transformDoubleArrayReply
    };
  }
});
var require_BYREVRANK = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/BYREVRANK.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BYRANK_1 = __importStar(require_BYRANK());
    exports.default = {
      IS_READ_ONLY: BYRANK_1.default.IS_READ_ONLY,
      parseCommand(...args) {
        args[0].push("TDIGEST.BYREVRANK");
        (0, BYRANK_1.transformByRankArguments)(...args);
      },
      transformReply: BYRANK_1.default.transformReply
    };
  }
});
var require_CDF = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/CDF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Estimates the cumulative distribution function for values in a t-digest sketch
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       * @param values - Array of values to get CDF estimates for
       */
      parseCommand(parser, key, values) {
        parser.push("TDIGEST.CDF");
        parser.pushKey(key);
        for (const item of values) {
          parser.push(item.toString());
        }
      },
      transformReply: generic_transformers_1.transformDoubleArrayReply
    };
  }
});
var require_CREATE = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/CREATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Creates a new t-digest sketch for storing distributions
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       * @param options - Optional parameters for sketch creation
       * @param options.COMPRESSION - Compression parameter that affects performance and accuracy
       */
      parseCommand(parser, key, options2) {
        parser.push("TDIGEST.CREATE");
        parser.pushKey(key);
        if (options2?.COMPRESSION !== void 0) {
          parser.push("COMPRESSION", options2.COMPRESSION.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_INFO5 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bloom_1 = require_bloom();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns information about a t-digest sketch including compression, capacity, nodes, weights, observations and memory usage
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch to get information about
       */
      parseCommand(parser, key) {
        parser.push("TDIGEST.INFO");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply, _, typeMapping) => {
          return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
        },
        3: void 0
      }
    };
  }
});
var require_MAX = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/MAX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the maximum value from a t-digest sketch
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       */
      parseCommand(parser, key) {
        parser.push("TDIGEST.MAX");
        parser.pushKey(key);
      },
      transformReply: generic_transformers_1.transformDoubleReply
    };
  }
});
var require_MERGE2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/MERGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Merges multiple t-digest sketches into one, with optional compression and override settings
       * @param parser - The command parser
       * @param destination - The name of the destination t-digest sketch
       * @param source - One or more source sketch names to merge from
       * @param options - Optional parameters for merge operation
       * @param options.COMPRESSION - New compression value for merged sketch
       * @param options.OVERRIDE - If true, override destination sketch if it exists
       */
      parseCommand(parser, destination, source, options2) {
        parser.push("TDIGEST.MERGE");
        parser.pushKey(destination);
        parser.pushKeysLength(source);
        if (options2?.COMPRESSION !== void 0) {
          parser.push("COMPRESSION", options2.COMPRESSION.toString());
        }
        if (options2?.OVERRIDE) {
          parser.push("OVERRIDE");
        }
      },
      transformReply: void 0
    };
  }
});
var require_MIN = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/MIN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the minimum value from a t-digest sketch
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       */
      parseCommand(parser, key) {
        parser.push("TDIGEST.MIN");
        parser.pushKey(key);
      },
      transformReply: generic_transformers_1.transformDoubleReply
    };
  }
});
var require_QUANTILE = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/QUANTILE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns value estimates at requested quantiles from a t-digest sketch
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       * @param quantiles - Array of quantiles (between 0 and 1) to get value estimates for
       */
      parseCommand(parser, key, quantiles) {
        parser.push("TDIGEST.QUANTILE");
        parser.pushKey(key);
        for (const quantile of quantiles) {
          parser.push(quantile.toString());
        }
      },
      transformReply: generic_transformers_1.transformDoubleArrayReply
    };
  }
});
var require_RANK = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/RANK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformRankArguments = void 0;
    function transformRankArguments(parser, key, values) {
      parser.pushKey(key);
      for (const value of values) {
        parser.push(value.toString());
      }
    }
    exports.transformRankArguments = transformRankArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the rank of one or more values in a t-digest sketch (number of values that are lower than each value)
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       * @param values - Array of values to get ranks for
       */
      parseCommand(...args) {
        args[0].push("TDIGEST.RANK");
        transformRankArguments(...args);
      },
      transformReply: void 0
    };
  }
});
var require_RESET = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/RESET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Resets a t-digest sketch, clearing all previously added observations
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch to reset
       */
      parseCommand(parser, key) {
        parser.push("TDIGEST.RESET");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_REVRANK = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/REVRANK.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var RANK_1 = __importStar(require_RANK());
    exports.default = {
      IS_READ_ONLY: RANK_1.default.IS_READ_ONLY,
      parseCommand(...args) {
        args[0].push("TDIGEST.REVRANK");
        (0, RANK_1.transformRankArguments)(...args);
      },
      transformReply: RANK_1.default.transformReply
    };
  }
});
var require_TRIMMED_MEAN = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/TRIMMED_MEAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the mean value from a t-digest sketch after trimming values at specified percentiles
       * @param parser - The command parser
       * @param key - The name of the t-digest sketch
       * @param lowCutPercentile - Lower percentile cutoff (between 0 and 100)
       * @param highCutPercentile - Higher percentile cutoff (between 0 and 100)
       */
      parseCommand(parser, key, lowCutPercentile, highCutPercentile) {
        parser.push("TDIGEST.TRIMMED_MEAN");
        parser.pushKey(key);
        parser.push(lowCutPercentile.toString(), highCutPercentile.toString());
      },
      transformReply: generic_transformers_1.transformDoubleReply
    };
  }
});
var require_t_digest = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/t-digest/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ADD_1 = __importDefault(require_ADD3());
    var BYRANK_1 = __importDefault(require_BYRANK());
    var BYREVRANK_1 = __importDefault(require_BYREVRANK());
    var CDF_1 = __importDefault(require_CDF());
    var CREATE_1 = __importDefault(require_CREATE());
    var INFO_1 = __importDefault(require_INFO5());
    var MAX_1 = __importDefault(require_MAX());
    var MERGE_1 = __importDefault(require_MERGE2());
    var MIN_1 = __importDefault(require_MIN());
    var QUANTILE_1 = __importDefault(require_QUANTILE());
    var RANK_1 = __importDefault(require_RANK());
    var RESET_1 = __importDefault(require_RESET());
    var REVRANK_1 = __importDefault(require_REVRANK());
    var TRIMMED_MEAN_1 = __importDefault(require_TRIMMED_MEAN());
    exports.default = {
      ADD: ADD_1.default,
      add: ADD_1.default,
      BYRANK: BYRANK_1.default,
      byRank: BYRANK_1.default,
      BYREVRANK: BYREVRANK_1.default,
      byRevRank: BYREVRANK_1.default,
      CDF: CDF_1.default,
      cdf: CDF_1.default,
      CREATE: CREATE_1.default,
      create: CREATE_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      MAX: MAX_1.default,
      max: MAX_1.default,
      MERGE: MERGE_1.default,
      merge: MERGE_1.default,
      MIN: MIN_1.default,
      min: MIN_1.default,
      QUANTILE: QUANTILE_1.default,
      quantile: QUANTILE_1.default,
      RANK: RANK_1.default,
      rank: RANK_1.default,
      RESET: RESET_1.default,
      reset: RESET_1.default,
      REVRANK: REVRANK_1.default,
      revRank: REVRANK_1.default,
      TRIMMED_MEAN: TRIMMED_MEAN_1.default,
      trimmedMean: TRIMMED_MEAN_1.default
    };
  }
});
var require_ADD4 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/ADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds one or more items to a Top-K filter and returns items dropped from the top-K list
       * @param parser - The command parser
       * @param key - The name of the Top-K filter
       * @param items - One or more items to add to the filter
       */
      parseCommand(parser, key, items) {
        parser.push("TOPK.ADD");
        parser.pushKey(key);
        parser.pushVariadic(items);
      },
      transformReply: void 0
    };
  }
});
var require_COUNT2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/COUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the count of occurrences for one or more items in a Top-K filter
       * @param parser - The command parser
       * @param key - The name of the Top-K filter
       * @param items - One or more items to get counts for
       */
      parseCommand(parser, key, items) {
        parser.push("TOPK.COUNT");
        parser.pushKey(key);
        parser.pushVariadic(items);
      },
      transformReply: void 0
    };
  }
});
var require_INCRBY3 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/INCRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function pushIncrByItem(parser, { item, incrementBy }) {
      parser.push(item, incrementBy.toString());
    }
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Increases the score of one or more items in a Top-K filter by specified increments
       * @param parser - The command parser
       * @param key - The name of the Top-K filter
       * @param items - A single item or array of items to increment, each with an item name and increment value
       */
      parseCommand(parser, key, items) {
        parser.push("TOPK.INCRBY");
        parser.pushKey(key);
        if (Array.isArray(items)) {
          for (const item of items) {
            pushIncrByItem(parser, item);
          }
        } else {
          pushIncrByItem(parser, items);
        }
      },
      transformReply: void 0
    };
  }
});
var require_INFO6 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var bloom_1 = require_bloom();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns configuration and statistics of a Top-K filter, including k, width, depth, and decay parameters
       * @param parser - The command parser
       * @param key - The name of the Top-K filter to get information about
       */
      parseCommand(parser, key) {
        parser.push("TOPK.INFO");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          reply[7] = generic_transformers_1.transformDoubleReply[2](reply[7], preserve, typeMapping);
          return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
        },
        3: void 0
      }
    };
  }
});
var require_LIST_WITHCOUNT = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/LIST_WITHCOUNT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns all items in a Top-K filter with their respective counts
       * @param parser - The command parser
       * @param key - The name of the Top-K filter
       */
      parseCommand(parser, key) {
        parser.push("TOPK.LIST");
        parser.pushKey(key);
        parser.push("WITHCOUNT");
      },
      transformReply(rawReply) {
        const reply = [];
        for (let i2 = 0; i2 < rawReply.length; i2++) {
          reply.push({
            item: rawReply[i2],
            count: rawReply[++i2]
          });
        }
        return reply;
      }
    };
  }
});
var require_LIST = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/LIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns all items in a Top-K filter
       * @param parser - The command parser
       * @param key - The name of the Top-K filter
       */
      parseCommand(parser, key) {
        parser.push("TOPK.LIST");
        parser.pushKey(key);
      },
      transformReply: void 0
    };
  }
});
var require_QUERY2 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/QUERY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Checks if one or more items are in the Top-K list
       * @param parser - The command parser
       * @param key - The name of the Top-K filter
       * @param items - One or more items to check in the filter
       */
      parseCommand(parser, key, items) {
        parser.push("TOPK.QUERY");
        parser.pushKey(key);
        parser.pushVariadic(items);
      },
      transformReply: generic_transformers_1.transformBooleanArrayReply
    };
  }
});
var require_RESERVE3 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/RESERVE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Creates a new Top-K filter with specified parameters
       * @param parser - The command parser
       * @param key - The name of the Top-K filter
       * @param topK - Number of top occurring items to keep
       * @param options - Optional parameters for filter configuration
       * @param options.width - Number of counters in each array
       * @param options.depth - Number of counter-arrays
       * @param options.decay - Counter decay factor
       */
      parseCommand(parser, key, topK, options2) {
        parser.push("TOPK.RESERVE");
        parser.pushKey(key);
        parser.push(topK.toString());
        if (options2) {
          parser.push(options2.width.toString(), options2.depth.toString(), options2.decay.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_top_k = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/top-k/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ADD_1 = __importDefault(require_ADD4());
    var COUNT_1 = __importDefault(require_COUNT2());
    var INCRBY_1 = __importDefault(require_INCRBY3());
    var INFO_1 = __importDefault(require_INFO6());
    var LIST_WITHCOUNT_1 = __importDefault(require_LIST_WITHCOUNT());
    var LIST_1 = __importDefault(require_LIST());
    var QUERY_1 = __importDefault(require_QUERY2());
    var RESERVE_1 = __importDefault(require_RESERVE3());
    exports.default = {
      ADD: ADD_1.default,
      add: ADD_1.default,
      COUNT: COUNT_1.default,
      count: COUNT_1.default,
      INCRBY: INCRBY_1.default,
      incrBy: INCRBY_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      LIST_WITHCOUNT: LIST_WITHCOUNT_1.default,
      listWithCount: LIST_WITHCOUNT_1.default,
      LIST: LIST_1.default,
      list: LIST_1.default,
      QUERY: QUERY_1.default,
      query: QUERY_1.default,
      RESERVE: RESERVE_1.default,
      reserve: RESERVE_1.default
    };
  }
});
var require_commands3 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/commands/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bloom_1 = __importDefault(require_bloom());
    var count_min_sketch_1 = __importDefault(require_count_min_sketch());
    var cuckoo_1 = __importDefault(require_cuckoo());
    var t_digest_1 = __importDefault(require_t_digest());
    var top_k_1 = __importDefault(require_top_k());
    exports.default = {
      bf: bloom_1.default,
      cms: count_min_sketch_1.default,
      cf: cuckoo_1.default,
      tDigest: t_digest_1.default,
      topK: top_k_1.default
    };
  }
});
var require_lib4 = __commonJS({
  "node_modules/.deno/@redis+bloom@5.9.0/node_modules/@redis/bloom/dist/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = void 0;
    var commands_1 = require_commands3();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return __importDefault(commands_1).default;
    } });
  }
});
var require_ARRAPPEND = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/ARRAPPEND.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Appends one or more values to the end of an array in a JSON document.
       * Returns the new array length after append, or null if the path does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key to append to
       * @param path - Path to the array in the JSON document
       * @param json - The first value to append
       * @param jsons - Additional values to append
       */
      parseCommand(parser, key, path2, json, ...jsons) {
        parser.push("JSON.ARRAPPEND");
        parser.pushKey(key);
        parser.push(path2, (0, generic_transformers_1.transformRedisJsonArgument)(json));
        for (let i2 = 0; i2 < jsons.length; i2++) {
          parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i2]));
        }
      },
      transformReply: void 0
    };
  }
});
var require_ARRINDEX = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/ARRINDEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the index of the first occurrence of a value in a JSON array.
       * If the specified value is not found, it returns -1, or null if the path does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the array
       * @param path - Path to the array in the JSON document
       * @param json - The value to search for
       * @param options - Optional range parameters for the search
       * @param options.range.start - Starting index for the search
       * @param options.range.stop - Optional ending index for the search
       */
      parseCommand(parser, key, path2, json, options2) {
        parser.push("JSON.ARRINDEX");
        parser.pushKey(key);
        parser.push(path2, (0, generic_transformers_1.transformRedisJsonArgument)(json));
        if (options2?.range) {
          parser.push(options2.range.start.toString());
          if (options2.range.stop !== void 0) {
            parser.push(options2.range.stop.toString());
          }
        }
      },
      transformReply: void 0
    };
  }
});
var require_ARRINSERT = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/ARRINSERT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Inserts one or more values into an array at the specified index.
       * Returns the new array length after insert, or null if the path does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the array
       * @param path - Path to the array in the JSON document
       * @param index - The position where to insert the values
       * @param json - The first value to insert
       * @param jsons - Additional values to insert
       */
      parseCommand(parser, key, path2, index, json, ...jsons) {
        parser.push("JSON.ARRINSERT");
        parser.pushKey(key);
        parser.push(path2, index.toString(), (0, generic_transformers_1.transformRedisJsonArgument)(json));
        for (let i2 = 0; i2 < jsons.length; i2++) {
          parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i2]));
        }
      },
      transformReply: void 0
    };
  }
});
var require_ARRLEN = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/ARRLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the length of an array in a JSON document.
       * Returns null if the path does not exist or the value is not an array.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the array
       * @param options - Optional parameters
       * @param options.path - Path to the array in the JSON document
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.ARRLEN");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_ARRPOP = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/ARRPOP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Removes and returns an element from an array in a JSON document.
       * Returns null if the path does not exist or the value is not an array.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the array
       * @param options - Optional parameters
       * @param options.path - Path to the array in the JSON document
       * @param options.index - Optional index to pop from. Default is -1 (last element)
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.ARRPOP");
        parser.pushKey(key);
        if (options2) {
          parser.push(options2.path);
          if (options2.index !== void 0) {
            parser.push(options2.index.toString());
          }
        }
      },
      transformReply(reply) {
        return (0, generic_transformers_1.isArrayReply)(reply) ? reply.map((item) => (0, generic_transformers_1.transformRedisJsonNullReply)(item)) : (0, generic_transformers_1.transformRedisJsonNullReply)(reply);
      }
    };
  }
});
var require_ARRTRIM = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/ARRTRIM.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Trims an array in a JSON document to include only elements within the specified range.
       * Returns the new array length after trimming, or null if the path does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the array
       * @param path - Path to the array in the JSON document
       * @param start - Starting index (inclusive)
       * @param stop - Ending index (inclusive)
       */
      parseCommand(parser, key, path2, start, stop) {
        parser.push("JSON.ARRTRIM");
        parser.pushKey(key);
        parser.push(path2, start.toString(), stop.toString());
      },
      transformReply: void 0
    };
  }
});
var require_CLEAR = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/CLEAR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Clears container values (arrays/objects) in a JSON document.
       * Returns the number of values cleared (0 or 1), or null if the path does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to the container to clear
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.CLEAR");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_DEBUG_MEMORY = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/DEBUG_MEMORY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Reports memory usage details for a JSON document value.
       * Returns size in bytes of the value, or null if the key or path does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to the value to examine
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.DEBUG", "MEMORY");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_DEL3 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/DEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Deletes a value from a JSON document.
       * Returns the number of paths deleted (0 or 1), or null if the key does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to the value to delete
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.DEL");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_FORGET = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/FORGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Alias for JSON.DEL - Deletes a value from a JSON document.
       * Returns the number of paths deleted (0 or 1), or null if the key does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to the value to delete
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.FORGET");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_GET2 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/GET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Gets values from a JSON document.
       * Returns the value at the specified path, or null if the key or path does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path(s) to the value(s) to retrieve
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.GET");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.pushVariadic(options2.path);
        }
      },
      transformReply: generic_transformers_1.transformRedisJsonNullReply
    };
  }
});
var require_MERGE3 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/MERGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Merges a given JSON value into a JSON document.
       * Returns OK on success, or null if the key does not exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param path - Path to merge into
       * @param value - JSON value to merge
       */
      parseCommand(parser, key, path2, value) {
        parser.push("JSON.MERGE");
        parser.pushKey(key);
        parser.push(path2, (0, generic_transformers_1.transformRedisJsonArgument)(value));
      },
      transformReply: void 0
    };
  }
});
var require_MGET2 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/MGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets values at a specific path from multiple JSON documents.
       * Returns an array of values at the path from each key, null for missing keys/paths.
       *
       * @param parser - The Redis command parser
       * @param keys - Array of keys containing JSON documents
       * @param path - Path to retrieve from each document
       */
      parseCommand(parser, keys, path2) {
        parser.push("JSON.MGET");
        parser.pushKeys(keys);
        parser.push(path2);
      },
      transformReply(reply) {
        return reply.map((json) => (0, generic_transformers_1.transformRedisJsonNullReply)(json));
      }
    };
  }
});
var require_MSET2 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/MSET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Sets multiple JSON values in multiple documents.
       * Returns OK on success.
       *
       * @param parser - The Redis command parser
       * @param items - Array of objects containing key, path, and value to set
       * @param items[].key - The key containing the JSON document
       * @param items[].path - Path in the document to set
       * @param items[].value - JSON value to set at the path
       */
      parseCommand(parser, items) {
        parser.push("JSON.MSET");
        for (let i2 = 0; i2 < items.length; i2++) {
          parser.pushKey(items[i2].key);
          parser.push(items[i2].path, (0, generic_transformers_1.transformRedisJsonArgument)(items[i2].value));
        }
      },
      transformReply: void 0
    };
  }
});
var require_NUMINCRBY = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/NUMINCRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Increments a numeric value stored in a JSON document by a given number.
       * Returns the value after increment, or null if the key/path doesn't exist or value is not numeric.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param path - Path to the numeric value
       * @param by - Amount to increment by
       */
      parseCommand(parser, key, path2, by) {
        parser.push("JSON.NUMINCRBY");
        parser.pushKey(key);
        parser.push(path2, by.toString());
      },
      transformReply: {
        2: (reply) => {
          return JSON.parse(reply.toString());
        },
        3: void 0
      }
    };
  }
});
var require_NUMMULTBY = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/NUMMULTBY.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Multiplies a numeric value stored in a JSON document by a given number.
       * Returns the value after multiplication, or null if the key/path doesn't exist or value is not numeric.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param path - Path to the numeric value
       * @param by - Amount to multiply by
       */
      parseCommand(parser, key, path2, by) {
        parser.push("JSON.NUMMULTBY");
        parser.pushKey(key);
        parser.push(path2, by.toString());
      },
      transformReply: NUMINCRBY_1.default.transformReply
    };
  }
});
var require_OBJKEYS = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/OBJKEYS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Returns the keys in the object stored in a JSON document.
       * Returns array of keys, array of arrays for multiple paths, or null if path doesn't exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to the object to examine
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.OBJKEYS");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_OBJLEN = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/OBJLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the number of keys in the object stored in a JSON document.
       * Returns length of object, array of lengths for multiple paths, or null if path doesn't exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to the object to examine
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.OBJLEN");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_SET2 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/SET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Sets a JSON value at a specific path in a JSON document.
       * Returns OK on success, or null if condition (NX/XX) is not met.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param path - Path in the document to set
       * @param json - JSON value to set at the path
       * @param options - Optional parameters
       * @param options.condition - Set condition: NX (only if doesn't exist) or XX (only if exists)
       * @deprecated options.NX - Use options.condition instead
       * @deprecated options.XX - Use options.condition instead
       */
      parseCommand(parser, key, path2, json, options2) {
        parser.push("JSON.SET");
        parser.pushKey(key);
        parser.push(path2, (0, generic_transformers_1.transformRedisJsonArgument)(json));
        if (options2?.condition) {
          parser.push(options2?.condition);
        } else if (options2?.NX) {
          parser.push("NX");
        } else if (options2?.XX) {
          parser.push("XX");
        }
      },
      transformReply: void 0
    };
  }
});
var require_STRAPPEND = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/STRAPPEND.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Appends a string to a string value stored in a JSON document.
       * Returns new string length after append, or null if the path doesn't exist or value is not a string.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param append - String to append
       * @param options - Optional parameters
       * @param options.path - Path to the string value
       */
      parseCommand(parser, key, append, options2) {
        parser.push("JSON.STRAPPEND");
        parser.pushKey(key);
        if (options2?.path !== void 0) {
          parser.push(options2.path);
        }
        parser.push((0, generic_transformers_1.transformRedisJsonArgument)(append));
      },
      transformReply: void 0
    };
  }
});
var require_STRLEN2 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/STRLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the length of a string value stored in a JSON document.
       * Returns string length, array of lengths for multiple paths, or null if path doesn't exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to the string value
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.STRLEN");
        parser.pushKey(key);
        if (options2?.path) {
          parser.push(options2.path);
        }
      },
      transformReply: void 0
    };
  }
});
var require_TOGGLE = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/TOGGLE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Toggles a boolean value stored in a JSON document.
       * Returns 1 if value was toggled to true, 0 if toggled to false, or null if path doesn't exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param path - Path to the boolean value
       */
      parseCommand(parser, key, path2) {
        parser.push("JSON.TOGGLE");
        parser.pushKey(key);
        parser.push(path2);
      },
      transformReply: void 0
    };
  }
});
var require_TYPE2 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/TYPE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Returns the type of JSON value at a specific path in a JSON document.
       * Returns the type as a string, array of types for multiple paths, or null if path doesn't exist.
       *
       * @param parser - The Redis command parser
       * @param key - The key containing the JSON document
       * @param options - Optional parameters
       * @param options.path - Path to examine
       */
      parseCommand(parser, key, options2) {
        parser.push("JSON.TYPE");
        parser.pushKey(key);
        if (options2?.path) {
          parser.push(options2.path);
        }
      },
      transformReply: {
        2: void 0,
        // TODO: RESP3 wraps the response in another array, but only returns 1 
        3: (reply) => {
          return reply[0];
        }
      }
    };
  }
});
var require_commands4 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/commands/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = void 0;
    var ARRAPPEND_1 = __importDefault(require_ARRAPPEND());
    var ARRINDEX_1 = __importDefault(require_ARRINDEX());
    var ARRINSERT_1 = __importDefault(require_ARRINSERT());
    var ARRLEN_1 = __importDefault(require_ARRLEN());
    var ARRPOP_1 = __importDefault(require_ARRPOP());
    var ARRTRIM_1 = __importDefault(require_ARRTRIM());
    var CLEAR_1 = __importDefault(require_CLEAR());
    var DEBUG_MEMORY_1 = __importDefault(require_DEBUG_MEMORY());
    var DEL_1 = __importDefault(require_DEL3());
    var FORGET_1 = __importDefault(require_FORGET());
    var GET_1 = __importDefault(require_GET2());
    var MERGE_1 = __importDefault(require_MERGE3());
    var MGET_1 = __importDefault(require_MGET2());
    var MSET_1 = __importDefault(require_MSET2());
    var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
    var NUMMULTBY_1 = __importDefault(require_NUMMULTBY());
    var OBJKEYS_1 = __importDefault(require_OBJKEYS());
    var OBJLEN_1 = __importDefault(require_OBJLEN());
    var SET_1 = __importDefault(require_SET2());
    var STRAPPEND_1 = __importDefault(require_STRAPPEND());
    var STRLEN_1 = __importDefault(require_STRLEN2());
    var TOGGLE_1 = __importDefault(require_TOGGLE());
    var TYPE_1 = __importDefault(require_TYPE2());
    var generic_transformers_1 = require_generic_transformers();
    Object.defineProperty(exports, "transformRedisJsonArgument", { enumerable: true, get: function() {
      return generic_transformers_1.transformRedisJsonArgument;
    } });
    Object.defineProperty(exports, "transformRedisJsonReply", { enumerable: true, get: function() {
      return generic_transformers_1.transformRedisJsonReply;
    } });
    Object.defineProperty(exports, "transformRedisJsonNullReply", { enumerable: true, get: function() {
      return generic_transformers_1.transformRedisJsonNullReply;
    } });
    exports.default = {
      ARRAPPEND: ARRAPPEND_1.default,
      arrAppend: ARRAPPEND_1.default,
      ARRINDEX: ARRINDEX_1.default,
      arrIndex: ARRINDEX_1.default,
      ARRINSERT: ARRINSERT_1.default,
      arrInsert: ARRINSERT_1.default,
      ARRLEN: ARRLEN_1.default,
      arrLen: ARRLEN_1.default,
      ARRPOP: ARRPOP_1.default,
      arrPop: ARRPOP_1.default,
      ARRTRIM: ARRTRIM_1.default,
      arrTrim: ARRTRIM_1.default,
      CLEAR: CLEAR_1.default,
      clear: CLEAR_1.default,
      DEBUG_MEMORY: DEBUG_MEMORY_1.default,
      debugMemory: DEBUG_MEMORY_1.default,
      DEL: DEL_1.default,
      del: DEL_1.default,
      FORGET: FORGET_1.default,
      forget: FORGET_1.default,
      GET: GET_1.default,
      get: GET_1.default,
      MERGE: MERGE_1.default,
      merge: MERGE_1.default,
      MGET: MGET_1.default,
      mGet: MGET_1.default,
      MSET: MSET_1.default,
      mSet: MSET_1.default,
      NUMINCRBY: NUMINCRBY_1.default,
      numIncrBy: NUMINCRBY_1.default,
      /**
       * @deprecated since JSON version 2.0
       */
      NUMMULTBY: NUMMULTBY_1.default,
      /**
       * @deprecated since JSON version 2.0
       */
      numMultBy: NUMMULTBY_1.default,
      OBJKEYS: OBJKEYS_1.default,
      objKeys: OBJKEYS_1.default,
      OBJLEN: OBJLEN_1.default,
      objLen: OBJLEN_1.default,
      // RESP,
      // resp: RESP,
      SET: SET_1.default,
      set: SET_1.default,
      STRAPPEND: STRAPPEND_1.default,
      strAppend: STRAPPEND_1.default,
      STRLEN: STRLEN_1.default,
      strLen: STRLEN_1.default,
      TOGGLE: TOGGLE_1.default,
      toggle: TOGGLE_1.default,
      TYPE: TYPE_1.default,
      type: TYPE_1.default
    };
  }
});
var require_lib5 = __commonJS({
  "node_modules/.deno/@redis+json@5.9.0/node_modules/@redis/json/dist/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = void 0;
    var commands_1 = require_commands4();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return __importDefault(commands_1).default;
    } });
  }
});
var require_LIST2 = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/_LIST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Lists all existing indexes in the database.
       * @param parser - The command parser
       */
      parseCommand(parser) {
        parser.push("FT._LIST");
      },
      transformReply: {
        2: void 0,
        3: void 0
      }
    };
  }
});
var require_CREATE2 = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/CREATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.REDISEARCH_LANGUAGE = exports.parseSchema = exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = exports.VAMANA_COMPRESSION_ALGORITHM = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = void 0;
    var generic_transformers_1 = require_generic_transformers();
    exports.SCHEMA_FIELD_TYPE = {
      TEXT: "TEXT",
      NUMERIC: "NUMERIC",
      GEO: "GEO",
      TAG: "TAG",
      VECTOR: "VECTOR",
      GEOSHAPE: "GEOSHAPE"
    };
    exports.SCHEMA_TEXT_FIELD_PHONETIC = {
      DM_EN: "dm:en",
      DM_FR: "dm:fr",
      FM_PT: "dm:pt",
      DM_ES: "dm:es"
    };
    exports.SCHEMA_VECTOR_FIELD_ALGORITHM = {
      FLAT: "FLAT",
      HNSW: "HNSW",
      /**
       * available since 8.2
      */
      VAMANA: "SVS-VAMANA"
    };
    exports.VAMANA_COMPRESSION_ALGORITHM = {
      LVQ4: "LVQ4",
      LVQ8: "LVQ8",
      LVQ4x4: "LVQ4x4",
      LVQ4x8: "LVQ4x8",
      LeanVec4x8: "LeanVec4x8",
      LeanVec8x8: "LeanVec8x8"
    };
    exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = {
      SPHERICAL: "SPHERICAL",
      FLAT: "FLAT"
    };
    function parseCommonSchemaFieldOptions(parser, fieldOptions) {
      if (fieldOptions.SORTABLE) {
        parser.push("SORTABLE");
        if (fieldOptions.SORTABLE === "UNF") {
          parser.push("UNF");
        }
      }
      if (fieldOptions.NOINDEX) {
        parser.push("NOINDEX");
      }
    }
    function parseSchema(parser, schema) {
      for (const [field, fieldOptions] of Object.entries(schema)) {
        parser.push(field);
        if (typeof fieldOptions === "string") {
          parser.push(fieldOptions);
          continue;
        }
        if (fieldOptions.AS) {
          parser.push("AS", fieldOptions.AS);
        }
        parser.push(fieldOptions.type);
        if (fieldOptions.INDEXMISSING) {
          parser.push("INDEXMISSING");
        }
        switch (fieldOptions.type) {
          case exports.SCHEMA_FIELD_TYPE.TEXT:
            if (fieldOptions.NOSTEM) {
              parser.push("NOSTEM");
            }
            if (fieldOptions.WEIGHT !== void 0) {
              parser.push("WEIGHT", fieldOptions.WEIGHT.toString());
            }
            if (fieldOptions.PHONETIC) {
              parser.push("PHONETIC", fieldOptions.PHONETIC);
            }
            if (fieldOptions.WITHSUFFIXTRIE) {
              parser.push("WITHSUFFIXTRIE");
            }
            if (fieldOptions.INDEXEMPTY) {
              parser.push("INDEXEMPTY");
            }
            parseCommonSchemaFieldOptions(parser, fieldOptions);
            break;
          case exports.SCHEMA_FIELD_TYPE.NUMERIC:
          case exports.SCHEMA_FIELD_TYPE.GEO:
            parseCommonSchemaFieldOptions(parser, fieldOptions);
            break;
          case exports.SCHEMA_FIELD_TYPE.TAG:
            if (fieldOptions.SEPARATOR) {
              parser.push("SEPARATOR", fieldOptions.SEPARATOR);
            }
            if (fieldOptions.CASESENSITIVE) {
              parser.push("CASESENSITIVE");
            }
            if (fieldOptions.WITHSUFFIXTRIE) {
              parser.push("WITHSUFFIXTRIE");
            }
            if (fieldOptions.INDEXEMPTY) {
              parser.push("INDEXEMPTY");
            }
            parseCommonSchemaFieldOptions(parser, fieldOptions);
            break;
          case exports.SCHEMA_FIELD_TYPE.VECTOR:
            parser.push(fieldOptions.ALGORITHM);
            const args = [];
            args.push("TYPE", fieldOptions.TYPE, "DIM", fieldOptions.DIM.toString(), "DISTANCE_METRIC", fieldOptions.DISTANCE_METRIC);
            if (fieldOptions.INITIAL_CAP !== void 0) {
              args.push("INITIAL_CAP", fieldOptions.INITIAL_CAP.toString());
            }
            switch (fieldOptions.ALGORITHM) {
              case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.FLAT:
                if (fieldOptions.BLOCK_SIZE !== void 0) {
                  args.push("BLOCK_SIZE", fieldOptions.BLOCK_SIZE.toString());
                }
                break;
              case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.HNSW:
                if (fieldOptions.M !== void 0) {
                  args.push("M", fieldOptions.M.toString());
                }
                if (fieldOptions.EF_CONSTRUCTION !== void 0) {
                  args.push("EF_CONSTRUCTION", fieldOptions.EF_CONSTRUCTION.toString());
                }
                if (fieldOptions.EF_RUNTIME !== void 0) {
                  args.push("EF_RUNTIME", fieldOptions.EF_RUNTIME.toString());
                }
                break;
              case exports.SCHEMA_VECTOR_FIELD_ALGORITHM["VAMANA"]:
                if (fieldOptions.COMPRESSION) {
                  args.push("COMPRESSION", fieldOptions.COMPRESSION);
                }
                if (fieldOptions.CONSTRUCTION_WINDOW_SIZE !== void 0) {
                  args.push("CONSTRUCTION_WINDOW_SIZE", fieldOptions.CONSTRUCTION_WINDOW_SIZE.toString());
                }
                if (fieldOptions.GRAPH_MAX_DEGREE !== void 0) {
                  args.push("GRAPH_MAX_DEGREE", fieldOptions.GRAPH_MAX_DEGREE.toString());
                }
                if (fieldOptions.SEARCH_WINDOW_SIZE !== void 0) {
                  args.push("SEARCH_WINDOW_SIZE", fieldOptions.SEARCH_WINDOW_SIZE.toString());
                }
                if (fieldOptions.EPSILON !== void 0) {
                  args.push("EPSILON", fieldOptions.EPSILON.toString());
                }
                if (fieldOptions.TRAINING_THRESHOLD !== void 0) {
                  args.push("TRAINING_THRESHOLD", fieldOptions.TRAINING_THRESHOLD.toString());
                }
                if (fieldOptions.REDUCE !== void 0) {
                  args.push("REDUCE", fieldOptions.REDUCE.toString());
                }
                break;
            }
            parser.pushVariadicWithLength(args);
            break;
          case exports.SCHEMA_FIELD_TYPE.GEOSHAPE:
            if (fieldOptions.COORD_SYSTEM !== void 0) {
              parser.push("COORD_SYSTEM", fieldOptions.COORD_SYSTEM);
            }
            break;
        }
      }
    }
    exports.parseSchema = parseSchema;
    exports.REDISEARCH_LANGUAGE = {
      ARABIC: "Arabic",
      BASQUE: "Basque",
      CATALANA: "Catalan",
      DANISH: "Danish",
      DUTCH: "Dutch",
      ENGLISH: "English",
      FINNISH: "Finnish",
      FRENCH: "French",
      GERMAN: "German",
      GREEK: "Greek",
      HUNGARIAN: "Hungarian",
      INDONESAIN: "Indonesian",
      IRISH: "Irish",
      ITALIAN: "Italian",
      LITHUANIAN: "Lithuanian",
      NEPALI: "Nepali",
      NORWEIGAN: "Norwegian",
      PORTUGUESE: "Portuguese",
      ROMANIAN: "Romanian",
      RUSSIAN: "Russian",
      SPANISH: "Spanish",
      SWEDISH: "Swedish",
      TAMIL: "Tamil",
      TURKISH: "Turkish",
      CHINESE: "Chinese"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Creates a new search index with the given schema and options.
       * @param parser - The command parser
       * @param index - Name of the index to create
       * @param schema - Index schema defining field names and types (TEXT, NUMERIC, GEO, TAG, VECTOR, GEOSHAPE)
       * @param options - Optional parameters:
       *   - ON: Type of container to index (HASH or JSON)
       *   - PREFIX: Prefixes for document keys to index
       *   - FILTER: Expression that filters indexed documents
       *   - LANGUAGE/LANGUAGE_FIELD: Default language for indexing
       *   - SCORE/SCORE_FIELD: Document ranking parameters
       *   - MAXTEXTFIELDS: Index all text fields without specifying them
       *   - TEMPORARY: Create a temporary index
       *   - NOOFFSETS/NOHL/NOFIELDS/NOFREQS: Index optimization flags
       *   - STOPWORDS: Custom stopword list
       */
      parseCommand(parser, index, schema, options2) {
        parser.push("FT.CREATE", index);
        if (options2?.ON) {
          parser.push("ON", options2.ON);
        }
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "PREFIX", options2?.PREFIX);
        if (options2?.FILTER) {
          parser.push("FILTER", options2.FILTER);
        }
        if (options2?.LANGUAGE) {
          parser.push("LANGUAGE", options2.LANGUAGE);
        }
        if (options2?.LANGUAGE_FIELD) {
          parser.push("LANGUAGE_FIELD", options2.LANGUAGE_FIELD);
        }
        if (options2?.SCORE) {
          parser.push("SCORE", options2.SCORE.toString());
        }
        if (options2?.SCORE_FIELD) {
          parser.push("SCORE_FIELD", options2.SCORE_FIELD);
        }
        if (options2?.MAXTEXTFIELDS) {
          parser.push("MAXTEXTFIELDS");
        }
        if (options2?.TEMPORARY) {
          parser.push("TEMPORARY", options2.TEMPORARY.toString());
        }
        if (options2?.NOOFFSETS) {
          parser.push("NOOFFSETS");
        }
        if (options2?.NOHL) {
          parser.push("NOHL");
        }
        if (options2?.NOFIELDS) {
          parser.push("NOFIELDS");
        }
        if (options2?.NOFREQS) {
          parser.push("NOFREQS");
        }
        if (options2?.SKIPINITIALSCAN) {
          parser.push("SKIPINITIALSCAN");
        }
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "STOPWORDS", options2?.STOPWORDS);
        parser.push("SCHEMA");
        parseSchema(parser, schema);
      },
      transformReply: void 0
    };
  }
});
var require_ALTER = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/ALTER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CREATE_1 = require_CREATE2();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Alters an existing RediSearch index schema by adding new fields.
       * @param parser - The command parser
       * @param index - The index to alter
       * @param schema - The schema definition containing new fields to add
       */
      parseCommand(parser, index, schema) {
        parser.push("FT.ALTER", index, "SCHEMA", "ADD");
        (0, CREATE_1.parseSchema)(parser, schema);
      },
      transformReply: void 0
    };
  }
});
var require_default = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/dialect/default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_DIALECT = void 0;
    exports.DEFAULT_DIALECT = "2";
  }
});
var require_SEARCH = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SEARCH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSearchOptions = exports.parseParamsArgument = void 0;
    var generic_transformers_1 = require_generic_transformers();
    var default_1 = require_default();
    function parseParamsArgument(parser, params) {
      if (params) {
        parser.push("PARAMS");
        const args = [];
        for (const key in params) {
          if (!Object.hasOwn(params, key))
            continue;
          const value = params[key];
          args.push(key, typeof value === "number" ? value.toString() : value);
        }
        parser.pushVariadicWithLength(args);
      }
    }
    exports.parseParamsArgument = parseParamsArgument;
    function parseSearchOptions(parser, options2) {
      if (options2?.VERBATIM) {
        parser.push("VERBATIM");
      }
      if (options2?.NOSTOPWORDS) {
        parser.push("NOSTOPWORDS");
      }
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INKEYS", options2?.INKEYS);
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INFIELDS", options2?.INFIELDS);
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "RETURN", options2?.RETURN);
      if (options2?.SUMMARIZE) {
        parser.push("SUMMARIZE");
        if (typeof options2.SUMMARIZE === "object") {
          (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options2.SUMMARIZE.FIELDS);
          if (options2.SUMMARIZE.FRAGS !== void 0) {
            parser.push("FRAGS", options2.SUMMARIZE.FRAGS.toString());
          }
          if (options2.SUMMARIZE.LEN !== void 0) {
            parser.push("LEN", options2.SUMMARIZE.LEN.toString());
          }
          if (options2.SUMMARIZE.SEPARATOR !== void 0) {
            parser.push("SEPARATOR", options2.SUMMARIZE.SEPARATOR);
          }
        }
      }
      if (options2?.HIGHLIGHT) {
        parser.push("HIGHLIGHT");
        if (typeof options2.HIGHLIGHT === "object") {
          (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options2.HIGHLIGHT.FIELDS);
          if (options2.HIGHLIGHT.TAGS) {
            parser.push("TAGS", options2.HIGHLIGHT.TAGS.open, options2.HIGHLIGHT.TAGS.close);
          }
        }
      }
      if (options2?.SLOP !== void 0) {
        parser.push("SLOP", options2.SLOP.toString());
      }
      if (options2?.TIMEOUT !== void 0) {
        parser.push("TIMEOUT", options2.TIMEOUT.toString());
      }
      if (options2?.INORDER) {
        parser.push("INORDER");
      }
      if (options2?.LANGUAGE) {
        parser.push("LANGUAGE", options2.LANGUAGE);
      }
      if (options2?.EXPANDER) {
        parser.push("EXPANDER", options2.EXPANDER);
      }
      if (options2?.SCORER) {
        parser.push("SCORER", options2.SCORER);
      }
      if (options2?.SORTBY) {
        parser.push("SORTBY");
        if (typeof options2.SORTBY === "string" || options2.SORTBY instanceof Buffer) {
          parser.push(options2.SORTBY);
        } else {
          parser.push(options2.SORTBY.BY);
          if (options2.SORTBY.DIRECTION) {
            parser.push(options2.SORTBY.DIRECTION);
          }
        }
      }
      if (options2?.LIMIT) {
        parser.push("LIMIT", options2.LIMIT.from.toString(), options2.LIMIT.size.toString());
      }
      parseParamsArgument(parser, options2?.PARAMS);
      if (options2?.DIALECT) {
        parser.push("DIALECT", options2.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    }
    exports.parseSearchOptions = parseSearchOptions;
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Searches a RediSearch index with the given query.
       * @param parser - The command parser
       * @param index - The index name to search
       * @param query - The text query to search. For syntax, see https://redis.io/docs/stack/search/reference/query_syntax
       * @param options - Optional search parameters including:
       *   - VERBATIM: do not try to use stemming for query expansion
       *   - NOSTOPWORDS: do not filter stopwords from the query
       *   - INKEYS/INFIELDS: restrict the search to specific keys/fields
       *   - RETURN: limit which fields are returned
       *   - SUMMARIZE/HIGHLIGHT: create search result highlights
       *   - LIMIT: pagination control
       *   - SORTBY: sort results by a specific field
       *   - PARAMS: bind parameters to the query
       */
      parseCommand(parser, index, query, options2) {
        parser.push("FT.SEARCH", index, query);
        parseSearchOptions(parser, options2);
      },
      transformReply: {
        2: (reply) => {
          const withoutDocuments = reply.length > 2 && !Array.isArray(reply[2]);
          const documents = [];
          let i2 = 1;
          while (i2 < reply.length) {
            documents.push({
              id: reply[i2++],
              value: withoutDocuments ? /* @__PURE__ */ Object.create(null) : documentValue(reply[i2++])
            });
          }
          return {
            total: reply[0],
            documents
          };
        },
        3: void 0
      },
      unstableResp3: true
    };
    function documentValue(tuples) {
      const message = /* @__PURE__ */ Object.create(null);
      if (!tuples) {
        return message;
      }
      let i2 = 0;
      while (i2 < tuples.length) {
        const key = tuples[i2++], value = tuples[i2++];
        if (key === "$") {
          try {
            Object.assign(message, JSON.parse(value));
            continue;
          } catch {
          }
        }
        message[key] = value;
      }
      return message;
    }
  }
});
var require_AGGREGATE = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/AGGREGATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAggregateOptions = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.FT_AGGREGATE_STEPS = void 0;
    var SEARCH_1 = require_SEARCH();
    var generic_transformers_1 = require_generic_transformers();
    var default_1 = require_default();
    exports.FT_AGGREGATE_STEPS = {
      GROUPBY: "GROUPBY",
      SORTBY: "SORTBY",
      APPLY: "APPLY",
      LIMIT: "LIMIT",
      FILTER: "FILTER"
    };
    exports.FT_AGGREGATE_GROUP_BY_REDUCERS = {
      COUNT: "COUNT",
      COUNT_DISTINCT: "COUNT_DISTINCT",
      COUNT_DISTINCTISH: "COUNT_DISTINCTISH",
      SUM: "SUM",
      MIN: "MIN",
      MAX: "MAX",
      AVG: "AVG",
      STDDEV: "STDDEV",
      QUANTILE: "QUANTILE",
      TOLIST: "TOLIST",
      FIRST_VALUE: "FIRST_VALUE",
      RANDOM_SAMPLE: "RANDOM_SAMPLE"
    };
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: false,
      /**
       * Performs an aggregation query on a RediSearch index.
       * @param parser - The command parser
       * @param index - The index name to query
       * @param query - The text query to use as filter, use * to indicate no filtering
       * @param options - Optional parameters for aggregation:
       *   - VERBATIM: disable stemming in query evaluation
       *   - LOAD: specify fields to load from documents
       *   - STEPS: sequence of aggregation steps (GROUPBY, SORTBY, APPLY, LIMIT, FILTER)
       *   - PARAMS: bind parameters for query evaluation
       *   - TIMEOUT: maximum time to run the query
       */
      parseCommand(parser, index, query, options2) {
        parser.push("FT.AGGREGATE", index, query);
        return parseAggregateOptions(parser, options2);
      },
      transformReply: {
        2: (rawReply, preserve, typeMapping) => {
          const results = [];
          for (let i2 = 1; i2 < rawReply.length; i2++) {
            results.push((0, generic_transformers_1.transformTuplesReply)(rawReply[i2], preserve, typeMapping));
          }
          return {
            //  https://redis.io/docs/latest/commands/ft.aggregate/#return
            //  FT.AGGREGATE returns an array reply where each row is an array reply and represents a single aggregate result.
            // The integer reply at position 1 does not represent a valid value.
            total: Number(rawReply[0]),
            results
          };
        },
        3: void 0
      },
      unstableResp3: true
    };
    function parseAggregateOptions(parser, options2) {
      if (options2?.VERBATIM) {
        parser.push("VERBATIM");
      }
      if (options2?.ADDSCORES) {
        parser.push("ADDSCORES");
      }
      if (options2?.LOAD) {
        const args = [];
        if (Array.isArray(options2.LOAD)) {
          for (const load of options2.LOAD) {
            pushLoadField(args, load);
          }
        } else {
          pushLoadField(args, options2.LOAD);
        }
        parser.push("LOAD");
        parser.pushVariadicWithLength(args);
      }
      if (options2?.TIMEOUT !== void 0) {
        parser.push("TIMEOUT", options2.TIMEOUT.toString());
      }
      if (options2?.STEPS) {
        for (const step of options2.STEPS) {
          parser.push(step.type);
          switch (step.type) {
            case exports.FT_AGGREGATE_STEPS.GROUPBY:
              if (!step.properties) {
                parser.push("0");
              } else {
                parser.pushVariadicWithLength(step.properties);
              }
              if (Array.isArray(step.REDUCE)) {
                for (const reducer of step.REDUCE) {
                  parseGroupByReducer(parser, reducer);
                }
              } else {
                parseGroupByReducer(parser, step.REDUCE);
              }
              break;
            case exports.FT_AGGREGATE_STEPS.SORTBY:
              const args = [];
              if (Array.isArray(step.BY)) {
                for (const by of step.BY) {
                  pushSortByProperty(args, by);
                }
              } else {
                pushSortByProperty(args, step.BY);
              }
              if (step.MAX) {
                args.push("MAX", step.MAX.toString());
              }
              parser.pushVariadicWithLength(args);
              break;
            case exports.FT_AGGREGATE_STEPS.APPLY:
              parser.push(step.expression, "AS", step.AS);
              break;
            case exports.FT_AGGREGATE_STEPS.LIMIT:
              parser.push(step.from.toString(), step.size.toString());
              break;
            case exports.FT_AGGREGATE_STEPS.FILTER:
              parser.push(step.expression);
              break;
          }
        }
      }
      (0, SEARCH_1.parseParamsArgument)(parser, options2?.PARAMS);
      if (options2?.DIALECT) {
        parser.push("DIALECT", options2.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    }
    exports.parseAggregateOptions = parseAggregateOptions;
    function pushLoadField(args, toLoad) {
      if (typeof toLoad === "string" || toLoad instanceof Buffer) {
        args.push(toLoad);
      } else {
        args.push(toLoad.identifier);
        if (toLoad.AS) {
          args.push("AS", toLoad.AS);
        }
      }
    }
    function parseGroupByReducer(parser, reducer) {
      parser.push("REDUCE", reducer.type);
      switch (reducer.type) {
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT:
          parser.push("0");
          break;
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCT:
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCTISH:
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.SUM:
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MIN:
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MAX:
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.AVG:
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.STDDEV:
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.TOLIST:
          parser.push("1", reducer.property);
          break;
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.QUANTILE:
          parser.push("2", reducer.property, reducer.quantile.toString());
          break;
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.FIRST_VALUE: {
          const args = [reducer.property];
          if (reducer.BY) {
            args.push("BY");
            if (typeof reducer.BY === "string" || reducer.BY instanceof Buffer) {
              args.push(reducer.BY);
            } else {
              args.push(reducer.BY.property);
              if (reducer.BY.direction) {
                args.push(reducer.BY.direction);
              }
            }
          }
          parser.pushVariadicWithLength(args);
          break;
        }
        case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.RANDOM_SAMPLE:
          parser.push("2", reducer.property, reducer.sampleSize.toString());
          break;
      }
      if (reducer.AS) {
        parser.push("AS", reducer.AS);
      }
    }
    function pushSortByProperty(args, sortBy) {
      if (typeof sortBy === "string" || sortBy instanceof Buffer) {
        args.push(sortBy);
      } else {
        args.push(sortBy.BY);
        if (sortBy.DIRECTION) {
          args.push(sortBy.DIRECTION);
        }
      }
    }
  }
});
var require_AGGREGATE_WITHCURSOR = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/AGGREGATE_WITHCURSOR.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AGGREGATE_1 = __importDefault(require_AGGREGATE());
    exports.default = {
      IS_READ_ONLY: AGGREGATE_1.default.IS_READ_ONLY,
      /**
       * Performs an aggregation with a cursor for retrieving large result sets.
       * @param parser - The command parser
       * @param index - Name of the index to query
       * @param query - The aggregation query
       * @param options - Optional parameters:
       *   - All options supported by FT.AGGREGATE
       *   - COUNT: Number of results to return per cursor fetch
       *   - MAXIDLE: Maximum idle time for cursor in milliseconds
       */
      parseCommand(parser, index, query, options2) {
        AGGREGATE_1.default.parseCommand(parser, index, query, options2);
        parser.push("WITHCURSOR");
        if (options2?.COUNT !== void 0) {
          parser.push("COUNT", options2.COUNT.toString());
        }
        if (options2?.MAXIDLE !== void 0) {
          parser.push("MAXIDLE", options2.MAXIDLE.toString());
        }
      },
      transformReply: {
        2: (reply) => {
          return {
            ...AGGREGATE_1.default.transformReply[2](reply[0]),
            cursor: reply[1]
          };
        },
        3: void 0
      },
      unstableResp3: true
    };
  }
});
var require_ALIASADD = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/ALIASADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Adds an alias to a RediSearch index.
       * @param parser - The command parser
       * @param alias - The alias to add
       * @param index - The index name to alias
       */
      parseCommand(parser, alias, index) {
        parser.push("FT.ALIASADD", alias, index);
      },
      transformReply: void 0
    };
  }
});
var require_ALIASDEL = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/ALIASDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Removes an existing alias from a RediSearch index.
       * @param parser - The command parser
       * @param alias - The alias to remove
       */
      parseCommand(parser, alias) {
        parser.push("FT.ALIASDEL", alias);
      },
      transformReply: void 0
    };
  }
});
var require_ALIASUPDATE = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/ALIASUPDATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Updates the index pointed to by an existing alias.
       * @param parser - The command parser
       * @param alias - The existing alias to update
       * @param index - The new index name that the alias should point to
       */
      parseCommand(parser, alias, index) {
        parser.push("FT.ALIASUPDATE", alias, index);
      },
      transformReply: void 0
    };
  }
});
var require_CONFIG_GET2 = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/CONFIG_GET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Gets a RediSearch configuration option value.
       * @param parser - The command parser
       * @param option - The name of the configuration option to retrieve
       */
      parseCommand(parser, option) {
        parser.push("FT.CONFIG", "GET", option);
      },
      transformReply(reply) {
        const transformedReply = /* @__PURE__ */ Object.create(null);
        for (const item of reply) {
          const [key, value] = item;
          transformedReply[key.toString()] = value;
        }
        return transformedReply;
      }
    };
  }
});
var require_CONFIG_SET2 = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/CONFIG_SET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Sets a RediSearch configuration option value.
       * @param parser - The command parser
       * @param property - The name of the configuration option to set
       * @param value - The value to set for the configuration option
       */
      parseCommand(parser, property, value) {
        parser.push("FT.CONFIG", "SET", property, value);
      },
      transformReply: void 0
    };
  }
});
var require_CURSOR_DEL = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/CURSOR_DEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Deletes a cursor from an index.
       * @param parser - The command parser
       * @param index - The index name that contains the cursor
       * @param cursorId - The cursor ID to delete
       */
      parseCommand(parser, index, cursorId) {
        parser.push("FT.CURSOR", "DEL", index, cursorId.toString());
      },
      transformReply: void 0
    };
  }
});
var require_CURSOR_READ = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/CURSOR_READ.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Reads from an existing cursor to get more results from an index.
       * @param parser - The command parser
       * @param index - The index name that contains the cursor
       * @param cursor - The cursor ID to read from
       * @param options - Optional parameters:
       *   - COUNT: Maximum number of results to return
       */
      parseCommand(parser, index, cursor, options2) {
        parser.push("FT.CURSOR", "READ", index, cursor.toString());
        if (options2?.COUNT !== void 0) {
          parser.push("COUNT", options2.COUNT.toString());
        }
      },
      transformReply: AGGREGATE_WITHCURSOR_1.default.transformReply,
      unstableResp3: true
    };
  }
});
var require_DICTADD = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/DICTADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Adds terms to a dictionary.
       * @param parser - The command parser
       * @param dictionary - Name of the dictionary to add terms to
       * @param term - One or more terms to add to the dictionary
       */
      parseCommand(parser, dictionary, term) {
        parser.push("FT.DICTADD", dictionary);
        parser.pushVariadic(term);
      },
      transformReply: void 0
    };
  }
});
var require_DICTDEL = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/DICTDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Deletes terms from a dictionary.
       * @param parser - The command parser
       * @param dictionary - Name of the dictionary to remove terms from
       * @param term - One or more terms to delete from the dictionary
       */
      parseCommand(parser, dictionary, term) {
        parser.push("FT.DICTDEL", dictionary);
        parser.pushVariadic(term);
      },
      transformReply: void 0
    };
  }
});
var require_DICTDUMP = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/DICTDUMP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns all terms in a dictionary.
       * @param parser - The command parser
       * @param dictionary - Name of the dictionary to dump
       */
      parseCommand(parser, dictionary) {
        parser.push("FT.DICTDUMP", dictionary);
      },
      transformReply: {
        2: void 0,
        3: void 0
      }
    };
  }
});
var require_DROPINDEX = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/DROPINDEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Deletes an index and all associated documents.
       * @param parser - The command parser
       * @param index - Name of the index to delete
       * @param options - Optional parameters:
       *   - DD: Also delete the indexed documents themselves
       */
      parseCommand(parser, index, options2) {
        parser.push("FT.DROPINDEX", index);
        if (options2?.DD) {
          parser.push("DD");
        }
      },
      transformReply: {
        2: void 0,
        3: void 0
      }
    };
  }
});
var require_EXPLAIN = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/EXPLAIN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SEARCH_1 = require_SEARCH();
    var default_1 = require_default();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the execution plan for a complex query.
       * @param parser - The command parser
       * @param index - Name of the index to explain query against
       * @param query - The query string to explain
       * @param options - Optional parameters:
       *   - PARAMS: Named parameters to use in the query
       *   - DIALECT: Version of query dialect to use (defaults to 1)
       */
      parseCommand(parser, index, query, options2) {
        parser.push("FT.EXPLAIN", index, query);
        (0, SEARCH_1.parseParamsArgument)(parser, options2?.PARAMS);
        if (options2?.DIALECT) {
          parser.push("DIALECT", options2.DIALECT.toString());
        } else {
          parser.push("DIALECT", default_1.DEFAULT_DIALECT);
        }
      },
      transformReply: void 0
    };
  }
});
var require_EXPLAINCLI = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/EXPLAINCLI.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var default_1 = require_default();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the execution plan for a complex query in a more verbose format than FT.EXPLAIN.
       * @param parser - The command parser
       * @param index - Name of the index to explain query against
       * @param query - The query string to explain
       * @param options - Optional parameters:
       *   - DIALECT: Version of query dialect to use (defaults to 1)
       */
      parseCommand(parser, index, query, options2) {
        parser.push("FT.EXPLAINCLI", index, query);
        if (options2?.DIALECT) {
          parser.push("DIALECT", options2.DIALECT.toString());
        } else {
          parser.push("DIALECT", default_1.DEFAULT_DIALECT);
        }
      },
      transformReply: void 0
    };
  }
});
var require_INFO7 = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns information and statistics about an index.
       * @param parser - The command parser
       * @param index - Name of the index to get information about
       */
      parseCommand(parser, index) {
        parser.push("FT.INFO", index);
      },
      transformReply: {
        2: transformV2Reply,
        3: void 0
      },
      unstableResp3: true
    };
    function transformV2Reply(reply, preserve, typeMapping) {
      const myTransformFunc = (0, generic_transformers_1.createTransformTuplesReplyFunc)(preserve, typeMapping);
      const ret = {};
      for (let i2 = 0; i2 < reply.length; i2 += 2) {
        const key = reply[i2].toString();
        switch (key) {
          case "index_name":
          case "index_options":
          case "num_docs":
          case "max_doc_id":
          case "num_terms":
          case "num_records":
          case "total_inverted_index_blocks":
          case "hash_indexing_failures":
          case "indexing":
          case "number_of_uses":
          case "cleaning":
          case "stopwords_list":
            ret[key] = reply[i2 + 1];
            break;
          case "inverted_sz_mb":
          case "vector_index_sz_mb":
          case "offset_vectors_sz_mb":
          case "doc_table_size_mb":
          case "sortable_values_size_mb":
          case "key_table_size_mb":
          case "text_overhead_sz_mb":
          case "tag_overhead_sz_mb":
          case "total_index_memory_sz_mb":
          case "geoshapes_sz_mb":
          case "records_per_doc_avg":
          case "bytes_per_record_avg":
          case "offsets_per_term_avg":
          case "offset_bits_per_record_avg":
          case "total_indexing_time":
          case "percent_indexed":
            ret[key] = generic_transformers_1.transformDoubleReply[2](reply[i2 + 1], void 0, typeMapping);
            break;
          case "index_definition":
            ret[key] = myTransformFunc(reply[i2 + 1]);
            break;
          case "attributes":
            ret[key] = reply[i2 + 1].map((attribute) => myTransformFunc(attribute));
            break;
          case "gc_stats": {
            const innerRet = {};
            const array = reply[i2 + 1];
            for (let i3 = 0; i3 < array.length; i3 += 2) {
              const innerKey = array[i3].toString();
              switch (innerKey) {
                case "bytes_collected":
                case "total_ms_run":
                case "total_cycles":
                case "average_cycle_time_ms":
                case "last_run_time_ms":
                case "gc_numeric_trees_missed":
                case "gc_blocks_denied":
                  innerRet[innerKey] = generic_transformers_1.transformDoubleReply[2](array[i3 + 1], void 0, typeMapping);
                  break;
              }
            }
            ret[key] = innerRet;
            break;
          }
          case "cursor_stats": {
            const innerRet = {};
            const array = reply[i2 + 1];
            for (let i3 = 0; i3 < array.length; i3 += 2) {
              const innerKey = array[i3].toString();
              switch (innerKey) {
                case "global_idle":
                case "global_total":
                case "index_capacity":
                case "index_total":
                  innerRet[innerKey] = array[i3 + 1];
                  break;
              }
            }
            ret[key] = innerRet;
            break;
          }
        }
      }
      return ret;
    }
  }
});
var require_PROFILE_SEARCH = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/PROFILE_SEARCH.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SEARCH_1 = __importStar(require_SEARCH());
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Profiles the execution of a search query for performance analysis.
       * @param parser - The command parser
       * @param index - Name of the index to profile query against
       * @param query - The search query to profile
       * @param options - Optional parameters:
       *   - LIMITED: Collect limited timing information only
       *   - All options supported by FT.SEARCH command
       */
      parseCommand(parser, index, query, options2) {
        parser.push("FT.PROFILE", index, "SEARCH");
        if (options2?.LIMITED) {
          parser.push("LIMITED");
        }
        parser.push("QUERY", query);
        (0, SEARCH_1.parseSearchOptions)(parser, options2);
      },
      transformReply: {
        2: (reply) => {
          return {
            results: SEARCH_1.default.transformReply[2](reply[0]),
            profile: reply[1]
          };
        },
        3: (reply) => reply
      },
      unstableResp3: true
    };
  }
});
var require_PROFILE_AGGREGATE = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/PROFILE_AGGREGATE.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AGGREGATE_1 = __importStar(require_AGGREGATE());
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Profiles the execution of an aggregation query for performance analysis.
       * @param parser - The command parser
       * @param index - Name of the index to profile query against
       * @param query - The aggregation query to profile
       * @param options - Optional parameters:
       *   - LIMITED: Collect limited timing information only
       *   - All options supported by FT.AGGREGATE command
       */
      parseCommand(parser, index, query, options2) {
        parser.push("FT.PROFILE", index, "AGGREGATE");
        if (options2?.LIMITED) {
          parser.push("LIMITED");
        }
        parser.push("QUERY", query);
        (0, AGGREGATE_1.parseAggregateOptions)(parser, options2);
      },
      transformReply: {
        2: (reply) => {
          return {
            results: AGGREGATE_1.default.transformReply[2](reply[0]),
            profile: reply[1]
          };
        },
        3: (reply) => reply
      },
      unstableResp3: true
    };
  }
});
var require_SEARCH_NOCONTENT = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SEARCH_NOCONTENT.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SEARCH_1 = __importDefault(require_SEARCH());
    exports.default = {
      NOT_KEYED_COMMAND: SEARCH_1.default.NOT_KEYED_COMMAND,
      IS_READ_ONLY: SEARCH_1.default.IS_READ_ONLY,
      /**
       * Performs a search query but returns only document ids without their contents.
       * @param args - Same parameters as FT.SEARCH:
       *   - parser: The command parser
       *   - index: Name of the index to search
       *   - query: The text query to search
       *   - options: Optional search parameters
       */
      parseCommand(...args) {
        SEARCH_1.default.parseCommand(...args);
        args[0].push("NOCONTENT");
      },
      transformReply: {
        2: (reply) => {
          return {
            total: reply[0],
            documents: reply.slice(1)
          };
        },
        3: void 0
      },
      unstableResp3: true
    };
  }
});
var require_SPELLCHECK = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SPELLCHECK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var default_1 = require_default();
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Performs spelling correction on a search query.
       * @param parser - The command parser
       * @param index - Name of the index to use for spelling corrections
       * @param query - The search query to check for spelling
       * @param options - Optional parameters:
       *   - DISTANCE: Maximum Levenshtein distance for spelling suggestions
       *   - TERMS: Custom dictionary terms to include/exclude
       *   - DIALECT: Version of query dialect to use (defaults to 1)
       */
      parseCommand(parser, index, query, options2) {
        parser.push("FT.SPELLCHECK", index, query);
        if (options2?.DISTANCE) {
          parser.push("DISTANCE", options2.DISTANCE.toString());
        }
        if (options2?.TERMS) {
          if (Array.isArray(options2.TERMS)) {
            for (const term of options2.TERMS) {
              parseTerms(parser, term);
            }
          } else {
            parseTerms(parser, options2.TERMS);
          }
        }
        if (options2?.DIALECT) {
          parser.push("DIALECT", options2.DIALECT.toString());
        } else {
          parser.push("DIALECT", default_1.DEFAULT_DIALECT);
        }
      },
      transformReply: {
        2: (rawReply) => {
          return rawReply.map(([, term, suggestions]) => ({
            term,
            suggestions: suggestions.map(([score, suggestion]) => ({
              score: Number(score),
              suggestion
            }))
          }));
        },
        3: void 0
      },
      unstableResp3: true
    };
    function parseTerms(parser, { mode, dictionary }) {
      parser.push("TERMS", mode, dictionary);
    }
  }
});
var require_SUGADD = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SUGADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Adds a suggestion string to an auto-complete suggestion dictionary.
       * @param parser - The command parser
       * @param key - The suggestion dictionary key
       * @param string - The suggestion string to add
       * @param score - The suggestion score used for sorting
       * @param options - Optional parameters:
       *   - INCR: If true, increment the existing entry's score
       *   - PAYLOAD: Optional payload to associate with the suggestion
       */
      parseCommand(parser, key, string, score, options2) {
        parser.push("FT.SUGADD");
        parser.pushKey(key);
        parser.push(string, score.toString());
        if (options2?.INCR) {
          parser.push("INCR");
        }
        if (options2?.PAYLOAD) {
          parser.push("PAYLOAD", options2.PAYLOAD);
        }
      },
      transformReply: void 0
    };
  }
});
var require_SUGDEL = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SUGDEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Deletes a string from a suggestion dictionary.
       * @param parser - The command parser
       * @param key - The suggestion dictionary key
       * @param string - The suggestion string to delete
       */
      parseCommand(parser, key, string) {
        parser.push("FT.SUGDEL");
        parser.pushKey(key);
        parser.push(string);
      },
      transformReply: void 0
    };
  }
});
var require_SUGGET = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SUGGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets completion suggestions for a prefix from a suggestion dictionary.
       * @param parser - The command parser
       * @param key - The suggestion dictionary key
       * @param prefix - The prefix to get completion suggestions for
       * @param options - Optional parameters:
       *   - FUZZY: Enable fuzzy prefix matching
       *   - MAX: Maximum number of results to return
       */
      parseCommand(parser, key, prefix, options2) {
        parser.push("FT.SUGGET");
        parser.pushKey(key);
        parser.push(prefix);
        if (options2?.FUZZY) {
          parser.push("FUZZY");
        }
        if (options2?.MAX !== void 0) {
          parser.push("MAX", options2.MAX.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_SUGGET_WITHPAYLOADS = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SUGGET_WITHPAYLOADS.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var SUGGET_1 = __importDefault(require_SUGGET());
    exports.default = {
      IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
      /**
       * Gets completion suggestions with their payloads from a suggestion dictionary.
       * @param args - Same parameters as FT.SUGGET:
       *   - parser: The command parser
       *   - key: The suggestion dictionary key
       *   - prefix: The prefix to get completion suggestions for
       *   - options: Optional parameters for fuzzy matching and max results
       */
      parseCommand(...args) {
        SUGGET_1.default.parseCommand(...args);
        args[0].push("WITHPAYLOADS");
      },
      transformReply(reply) {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 2);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            payload: reply[replyIndex++]
          };
        }
        return transformedReply;
      }
    };
  }
});
var require_SUGGET_WITHSCORES_WITHPAYLOADS = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES_WITHPAYLOADS.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var SUGGET_1 = __importDefault(require_SUGGET());
    exports.default = {
      IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
      /**
       * Gets completion suggestions with their scores and payloads from a suggestion dictionary.
       * @param args - Same parameters as FT.SUGGET:
       *   - parser: The command parser
       *   - key: The suggestion dictionary key
       *   - prefix: The prefix to get completion suggestions for
       *   - options: Optional parameters for fuzzy matching and max results
       */
      parseCommand(...args) {
        SUGGET_1.default.parseCommand(...args);
        args[0].push("WITHSCORES", "WITHPAYLOADS");
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          if ((0, generic_transformers_1.isNullReply)(reply))
            return null;
          const transformedReply = new Array(reply.length / 3);
          let replyIndex = 0, arrIndex = 0;
          while (replyIndex < reply.length) {
            transformedReply[arrIndex++] = {
              suggestion: reply[replyIndex++],
              score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping),
              payload: reply[replyIndex++]
            };
          }
          return transformedReply;
        },
        3: (reply) => {
          if ((0, generic_transformers_1.isNullReply)(reply))
            return null;
          const transformedReply = new Array(reply.length / 3);
          let replyIndex = 0, arrIndex = 0;
          while (replyIndex < reply.length) {
            transformedReply[arrIndex++] = {
              suggestion: reply[replyIndex++],
              score: reply[replyIndex++],
              payload: reply[replyIndex++]
            };
          }
          return transformedReply;
        }
      }
    };
  }
});
var require_SUGGET_WITHSCORES = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    var SUGGET_1 = __importDefault(require_SUGGET());
    exports.default = {
      IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
      /**
       * Gets completion suggestions with their scores from a suggestion dictionary.
       * @param args - Same parameters as FT.SUGGET:
       *   - parser: The command parser
       *   - key: The suggestion dictionary key
       *   - prefix: The prefix to get completion suggestions for
       *   - options: Optional parameters for fuzzy matching and max results
       */
      parseCommand(...args) {
        SUGGET_1.default.parseCommand(...args);
        args[0].push("WITHSCORES");
      },
      transformReply: {
        2: (reply, preserve, typeMapping) => {
          if ((0, generic_transformers_1.isNullReply)(reply))
            return null;
          const transformedReply = new Array(reply.length / 2);
          let replyIndex = 0, arrIndex = 0;
          while (replyIndex < reply.length) {
            transformedReply[arrIndex++] = {
              suggestion: reply[replyIndex++],
              score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping)
            };
          }
          return transformedReply;
        },
        3: (reply) => {
          if ((0, generic_transformers_1.isNullReply)(reply))
            return null;
          const transformedReply = new Array(reply.length / 2);
          let replyIndex = 0, arrIndex = 0;
          while (replyIndex < reply.length) {
            transformedReply[arrIndex++] = {
              suggestion: reply[replyIndex++],
              score: reply[replyIndex++]
            };
          }
          return transformedReply;
        }
      }
    };
  }
});
var require_SUGLEN = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SUGLEN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets the size of a suggestion dictionary.
       * @param parser - The command parser
       * @param key - The suggestion dictionary key
       */
      parseCommand(parser, key) {
        parser.push("FT.SUGLEN", key);
      },
      transformReply: void 0
    };
  }
});
var require_SYNDUMP = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SYNDUMP.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Dumps the contents of a synonym group.
       * @param parser - The command parser
       * @param index - Name of the index that contains the synonym group
       */
      parseCommand(parser, index) {
        parser.push("FT.SYNDUMP", index);
      },
      transformReply: {
        2: (reply) => {
          const result = {};
          let i2 = 0;
          while (i2 < reply.length) {
            const key = reply[i2++].toString(), value = reply[i2++];
            result[key] = value;
          }
          return result;
        },
        3: void 0
      }
    };
  }
});
var require_SYNUPDATE = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/SYNUPDATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Updates a synonym group with new terms.
       * @param parser - The command parser
       * @param index - Name of the index that contains the synonym group
       * @param groupId - ID of the synonym group to update
       * @param terms - One or more synonym terms to add to the group
       * @param options - Optional parameters:
       *   - SKIPINITIALSCAN: Skip the initial scan for existing documents
       */
      parseCommand(parser, index, groupId, terms, options2) {
        parser.push("FT.SYNUPDATE", index, groupId);
        if (options2?.SKIPINITIALSCAN) {
          parser.push("SKIPINITIALSCAN");
        }
        parser.pushVariadic(terms);
      },
      transformReply: void 0
    };
  }
});
var require_TAGVALS = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/TAGVALS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Returns the distinct values in a TAG field.
       * @param parser - The command parser
       * @param index - Name of the index
       * @param fieldName - Name of the TAG field to get values from
       */
      parseCommand(parser, index, fieldName) {
        parser.push("FT.TAGVALS", index, fieldName);
      },
      transformReply: {
        2: void 0,
        3: void 0
      }
    };
  }
});
var require_commands5 = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/commands/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _LIST_1 = __importDefault(require_LIST2());
    var ALTER_1 = __importDefault(require_ALTER());
    var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
    var AGGREGATE_1 = __importDefault(require_AGGREGATE());
    var ALIASADD_1 = __importDefault(require_ALIASADD());
    var ALIASDEL_1 = __importDefault(require_ALIASDEL());
    var ALIASUPDATE_1 = __importDefault(require_ALIASUPDATE());
    var CONFIG_GET_1 = __importDefault(require_CONFIG_GET2());
    var CONFIG_SET_1 = __importDefault(require_CONFIG_SET2());
    var CREATE_1 = __importDefault(require_CREATE2());
    var CURSOR_DEL_1 = __importDefault(require_CURSOR_DEL());
    var CURSOR_READ_1 = __importDefault(require_CURSOR_READ());
    var DICTADD_1 = __importDefault(require_DICTADD());
    var DICTDEL_1 = __importDefault(require_DICTDEL());
    var DICTDUMP_1 = __importDefault(require_DICTDUMP());
    var DROPINDEX_1 = __importDefault(require_DROPINDEX());
    var EXPLAIN_1 = __importDefault(require_EXPLAIN());
    var EXPLAINCLI_1 = __importDefault(require_EXPLAINCLI());
    var INFO_1 = __importDefault(require_INFO7());
    var PROFILE_SEARCH_1 = __importDefault(require_PROFILE_SEARCH());
    var PROFILE_AGGREGATE_1 = __importDefault(require_PROFILE_AGGREGATE());
    var SEARCH_NOCONTENT_1 = __importDefault(require_SEARCH_NOCONTENT());
    var SEARCH_1 = __importDefault(require_SEARCH());
    var SPELLCHECK_1 = __importDefault(require_SPELLCHECK());
    var SUGADD_1 = __importDefault(require_SUGADD());
    var SUGDEL_1 = __importDefault(require_SUGDEL());
    var SUGGET_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHPAYLOADS());
    var SUGGET_WITHSCORES_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHSCORES_WITHPAYLOADS());
    var SUGGET_WITHSCORES_1 = __importDefault(require_SUGGET_WITHSCORES());
    var SUGGET_1 = __importDefault(require_SUGGET());
    var SUGLEN_1 = __importDefault(require_SUGLEN());
    var SYNDUMP_1 = __importDefault(require_SYNDUMP());
    var SYNUPDATE_1 = __importDefault(require_SYNUPDATE());
    var TAGVALS_1 = __importDefault(require_TAGVALS());
    exports.default = {
      _LIST: _LIST_1.default,
      _list: _LIST_1.default,
      ALTER: ALTER_1.default,
      alter: ALTER_1.default,
      AGGREGATE_WITHCURSOR: AGGREGATE_WITHCURSOR_1.default,
      aggregateWithCursor: AGGREGATE_WITHCURSOR_1.default,
      AGGREGATE: AGGREGATE_1.default,
      aggregate: AGGREGATE_1.default,
      ALIASADD: ALIASADD_1.default,
      aliasAdd: ALIASADD_1.default,
      ALIASDEL: ALIASDEL_1.default,
      aliasDel: ALIASDEL_1.default,
      ALIASUPDATE: ALIASUPDATE_1.default,
      aliasUpdate: ALIASUPDATE_1.default,
      /**
       * @deprecated Redis >=8 uses the standard CONFIG command
       */
      CONFIG_GET: CONFIG_GET_1.default,
      /**
       * @deprecated Redis >=8 uses the standard CONFIG command
       */
      configGet: CONFIG_GET_1.default,
      /**
       * @deprecated Redis >=8 uses the standard CONFIG command
       */
      CONFIG_SET: CONFIG_SET_1.default,
      /**
       * @deprecated Redis >=8 uses the standard CONFIG command
       */
      configSet: CONFIG_SET_1.default,
      CREATE: CREATE_1.default,
      create: CREATE_1.default,
      CURSOR_DEL: CURSOR_DEL_1.default,
      cursorDel: CURSOR_DEL_1.default,
      CURSOR_READ: CURSOR_READ_1.default,
      cursorRead: CURSOR_READ_1.default,
      DICTADD: DICTADD_1.default,
      dictAdd: DICTADD_1.default,
      DICTDEL: DICTDEL_1.default,
      dictDel: DICTDEL_1.default,
      DICTDUMP: DICTDUMP_1.default,
      dictDump: DICTDUMP_1.default,
      DROPINDEX: DROPINDEX_1.default,
      dropIndex: DROPINDEX_1.default,
      EXPLAIN: EXPLAIN_1.default,
      explain: EXPLAIN_1.default,
      EXPLAINCLI: EXPLAINCLI_1.default,
      explainCli: EXPLAINCLI_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      PROFILESEARCH: PROFILE_SEARCH_1.default,
      profileSearch: PROFILE_SEARCH_1.default,
      PROFILEAGGREGATE: PROFILE_AGGREGATE_1.default,
      profileAggregate: PROFILE_AGGREGATE_1.default,
      SEARCH_NOCONTENT: SEARCH_NOCONTENT_1.default,
      searchNoContent: SEARCH_NOCONTENT_1.default,
      SEARCH: SEARCH_1.default,
      search: SEARCH_1.default,
      SPELLCHECK: SPELLCHECK_1.default,
      spellCheck: SPELLCHECK_1.default,
      SUGADD: SUGADD_1.default,
      sugAdd: SUGADD_1.default,
      SUGDEL: SUGDEL_1.default,
      sugDel: SUGDEL_1.default,
      SUGGET_WITHPAYLOADS: SUGGET_WITHPAYLOADS_1.default,
      sugGetWithPayloads: SUGGET_WITHPAYLOADS_1.default,
      SUGGET_WITHSCORES_WITHPAYLOADS: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
      sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
      SUGGET_WITHSCORES: SUGGET_WITHSCORES_1.default,
      sugGetWithScores: SUGGET_WITHSCORES_1.default,
      SUGGET: SUGGET_1.default,
      sugGet: SUGGET_1.default,
      SUGLEN: SUGLEN_1.default,
      sugLen: SUGLEN_1.default,
      SYNDUMP: SYNDUMP_1.default,
      synDump: SYNDUMP_1.default,
      SYNUPDATE: SYNUPDATE_1.default,
      synUpdate: SYNUPDATE_1.default,
      TAGVALS: TAGVALS_1.default,
      tagVals: TAGVALS_1.default
    };
  }
});
var require_lib6 = __commonJS({
  "node_modules/.deno/@redis+search@5.9.0/node_modules/@redis/search/dist/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FT_AGGREGATE_STEPS = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = exports.REDISEARCH_LANGUAGE = exports.default = void 0;
    var commands_1 = require_commands5();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return __importDefault(commands_1).default;
    } });
    var CREATE_1 = require_CREATE2();
    Object.defineProperty(exports, "REDISEARCH_LANGUAGE", { enumerable: true, get: function() {
      return CREATE_1.REDISEARCH_LANGUAGE;
    } });
    Object.defineProperty(exports, "SCHEMA_FIELD_TYPE", { enumerable: true, get: function() {
      return CREATE_1.SCHEMA_FIELD_TYPE;
    } });
    Object.defineProperty(exports, "SCHEMA_TEXT_FIELD_PHONETIC", { enumerable: true, get: function() {
      return CREATE_1.SCHEMA_TEXT_FIELD_PHONETIC;
    } });
    Object.defineProperty(exports, "SCHEMA_VECTOR_FIELD_ALGORITHM", { enumerable: true, get: function() {
      return CREATE_1.SCHEMA_VECTOR_FIELD_ALGORITHM;
    } });
    var AGGREGATE_1 = require_AGGREGATE();
    Object.defineProperty(exports, "FT_AGGREGATE_GROUP_BY_REDUCERS", { enumerable: true, get: function() {
      return AGGREGATE_1.FT_AGGREGATE_GROUP_BY_REDUCERS;
    } });
    Object.defineProperty(exports, "FT_AGGREGATE_STEPS", { enumerable: true, get: function() {
      return AGGREGATE_1.FT_AGGREGATE_STEPS;
    } });
  }
});
var require_helpers2 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformRESP2LabelsWithSources = exports.transformRESP2Labels = exports.parseSelectedLabelsArguments = exports.resp3MapToValue = exports.resp2MapToValue = exports.transformSamplesReply = exports.transformSampleReply = exports.parseLabelsArgument = exports.transformTimestampArgument = exports.parseDuplicatePolicy = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.parseChunkSizeArgument = exports.parseEncodingArgument = exports.TIME_SERIES_ENCODING = exports.parseRetentionArgument = exports.parseIgnoreArgument = void 0;
    var client_1 = require_dist();
    function parseIgnoreArgument(parser, ignore) {
      if (ignore !== void 0) {
        parser.push("IGNORE", ignore.maxTimeDiff.toString(), ignore.maxValDiff.toString());
      }
    }
    exports.parseIgnoreArgument = parseIgnoreArgument;
    function parseRetentionArgument(parser, retention) {
      if (retention !== void 0) {
        parser.push("RETENTION", retention.toString());
      }
    }
    exports.parseRetentionArgument = parseRetentionArgument;
    exports.TIME_SERIES_ENCODING = {
      COMPRESSED: "COMPRESSED",
      UNCOMPRESSED: "UNCOMPRESSED"
    };
    function parseEncodingArgument(parser, encoding) {
      if (encoding !== void 0) {
        parser.push("ENCODING", encoding);
      }
    }
    exports.parseEncodingArgument = parseEncodingArgument;
    function parseChunkSizeArgument(parser, chunkSize) {
      if (chunkSize !== void 0) {
        parser.push("CHUNK_SIZE", chunkSize.toString());
      }
    }
    exports.parseChunkSizeArgument = parseChunkSizeArgument;
    exports.TIME_SERIES_DUPLICATE_POLICIES = {
      BLOCK: "BLOCK",
      FIRST: "FIRST",
      LAST: "LAST",
      MIN: "MIN",
      MAX: "MAX",
      SUM: "SUM"
    };
    function parseDuplicatePolicy(parser, duplicatePolicy) {
      if (duplicatePolicy !== void 0) {
        parser.push("DUPLICATE_POLICY", duplicatePolicy);
      }
    }
    exports.parseDuplicatePolicy = parseDuplicatePolicy;
    function transformTimestampArgument(timestamp) {
      if (typeof timestamp === "string")
        return timestamp;
      return (typeof timestamp === "number" ? timestamp : timestamp.getTime()).toString();
    }
    exports.transformTimestampArgument = transformTimestampArgument;
    function parseLabelsArgument(parser, labels) {
      if (labels) {
        parser.push("LABELS");
        for (const [label, value] of Object.entries(labels)) {
          parser.push(label, value);
        }
      }
    }
    exports.parseLabelsArgument = parseLabelsArgument;
    exports.transformSampleReply = {
      2(reply) {
        const [timestamp, value] = reply;
        return {
          timestamp,
          value: Number(value)
          // TODO: use double type mapping instead
        };
      },
      3(reply) {
        const [timestamp, value] = reply;
        return {
          timestamp,
          value
        };
      }
    };
    exports.transformSamplesReply = {
      2(reply) {
        return reply.map((sample) => exports.transformSampleReply[2](sample));
      },
      3(reply) {
        return reply.map((sample) => exports.transformSampleReply[3](sample));
      }
    };
    function resp2MapToValue(wrappedReply, parseFunc, typeMapping) {
      const reply = wrappedReply;
      switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
        case Map: {
          const ret = /* @__PURE__ */ new Map();
          for (const wrappedTuple of reply) {
            const tuple = wrappedTuple;
            const key = tuple[0];
            ret.set(key.toString(), parseFunc(tuple));
          }
          return ret;
        }
        case Array: {
          for (const wrappedTuple of reply) {
            const tuple = wrappedTuple;
            tuple[1] = parseFunc(tuple);
          }
          return reply;
        }
        default: {
          const ret = /* @__PURE__ */ Object.create(null);
          for (const wrappedTuple of reply) {
            const tuple = wrappedTuple;
            const key = tuple[0];
            ret[key.toString()] = parseFunc(tuple);
          }
          return ret;
        }
      }
    }
    exports.resp2MapToValue = resp2MapToValue;
    function resp3MapToValue(wrappedReply, parseFunc) {
      const reply = wrappedReply;
      if (reply instanceof Array) {
        for (let i2 = 1; i2 < reply.length; i2 += 2) {
          reply[i2] = parseFunc(reply[i2]);
        }
      } else if (reply instanceof Map) {
        for (const [key, value] of reply.entries()) {
          reply.set(key, parseFunc(value));
        }
      } else {
        for (const [key, value] of Object.entries(reply)) {
          reply[key] = parseFunc(value);
        }
      }
      return reply;
    }
    exports.resp3MapToValue = resp3MapToValue;
    function parseSelectedLabelsArguments(parser, selectedLabels) {
      parser.push("SELECTED_LABELS");
      parser.pushVariadic(selectedLabels);
    }
    exports.parseSelectedLabelsArguments = parseSelectedLabelsArguments;
    function transformRESP2Labels(labels, typeMapping) {
      const unwrappedLabels = labels;
      switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
        case Map:
          const map = /* @__PURE__ */ new Map();
          for (const tuple of unwrappedLabels) {
            const [key, value] = tuple;
            const unwrappedKey = key;
            map.set(unwrappedKey.toString(), value);
          }
          return map;
        case Array:
          return unwrappedLabels.flat();
        case Object:
        default:
          const labelsObject = /* @__PURE__ */ Object.create(null);
          for (const tuple of unwrappedLabels) {
            const [key, value] = tuple;
            const unwrappedKey = key;
            labelsObject[unwrappedKey.toString()] = value;
          }
          return labelsObject;
      }
    }
    exports.transformRESP2Labels = transformRESP2Labels;
    function transformRESP2LabelsWithSources(labels, typeMapping) {
      const unwrappedLabels = labels;
      const to = unwrappedLabels.length - 2;
      let transformedLabels;
      switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
        case Map:
          const map = /* @__PURE__ */ new Map();
          for (let i2 = 0; i2 < to; i2++) {
            const [key, value] = unwrappedLabels[i2];
            const unwrappedKey = key;
            map.set(unwrappedKey.toString(), value);
          }
          transformedLabels = map;
          break;
        case Array:
          transformedLabels = unwrappedLabels.slice(0, to).flat();
          break;
        case Object:
        default:
          const labelsObject = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < to; i2++) {
            const [key, value] = unwrappedLabels[i2];
            const unwrappedKey = key;
            labelsObject[unwrappedKey.toString()] = value;
          }
          transformedLabels = labelsObject;
          break;
      }
      const sourcesTuple = unwrappedLabels[unwrappedLabels.length - 1];
      const unwrappedSourcesTuple = sourcesTuple;
      const transformedSources = transformRESP2Sources(unwrappedSourcesTuple[1]);
      return {
        labels: transformedLabels,
        sources: transformedSources
      };
    }
    exports.transformRESP2LabelsWithSources = transformRESP2LabelsWithSources;
    function transformRESP2Sources(sourcesRaw) {
      const unwrappedSources = sourcesRaw;
      if (typeof unwrappedSources === "string") {
        return unwrappedSources.split(",");
      }
      const indexOfComma = unwrappedSources.indexOf(",");
      if (indexOfComma === -1) {
        return [unwrappedSources];
      }
      const sourcesArray = [
        unwrappedSources.subarray(0, indexOfComma)
      ];
      let previousComma = indexOfComma + 1;
      while (true) {
        const indexOf = unwrappedSources.indexOf(",", previousComma);
        if (indexOf === -1) {
          sourcesArray.push(unwrappedSources.subarray(previousComma));
          break;
        }
        const source = unwrappedSources.subarray(previousComma, indexOf);
        sourcesArray.push(source);
        previousComma = indexOf + 1;
      }
      return sourcesArray;
    }
  }
});
var require_ADD5 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/ADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_helpers2();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Creates or appends a sample to a time series
       * @param parser - The command parser
       * @param key - The key name for the time series
       * @param timestamp - The timestamp of the sample
       * @param value - The value of the sample
       * @param options - Optional configuration parameters
       */
      parseCommand(parser, key, timestamp, value, options2) {
        parser.push("TS.ADD");
        parser.pushKey(key);
        parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
        (0, helpers_1.parseRetentionArgument)(parser, options2?.RETENTION);
        (0, helpers_1.parseEncodingArgument)(parser, options2?.ENCODING);
        (0, helpers_1.parseChunkSizeArgument)(parser, options2?.CHUNK_SIZE);
        if (options2?.ON_DUPLICATE) {
          parser.push("ON_DUPLICATE", options2.ON_DUPLICATE);
        }
        (0, helpers_1.parseLabelsArgument)(parser, options2?.LABELS);
        (0, helpers_1.parseIgnoreArgument)(parser, options2?.IGNORE);
      },
      transformReply: void 0
    };
  }
});
var require_ALTER2 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/ALTER.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_helpers2();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Alters the configuration of an existing time series
       * @param parser - The command parser
       * @param key - The key name for the time series
       * @param options - Configuration parameters to alter
       */
      parseCommand(parser, key, options2) {
        parser.push("TS.ALTER");
        parser.pushKey(key);
        (0, helpers_1.parseRetentionArgument)(parser, options2?.RETENTION);
        (0, helpers_1.parseChunkSizeArgument)(parser, options2?.CHUNK_SIZE);
        (0, helpers_1.parseDuplicatePolicy)(parser, options2?.DUPLICATE_POLICY);
        (0, helpers_1.parseLabelsArgument)(parser, options2?.LABELS);
        (0, helpers_1.parseIgnoreArgument)(parser, options2?.IGNORE);
      },
      transformReply: void 0
    };
  }
});
var require_CREATE3 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/CREATE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_helpers2();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Creates a new time series
       * @param parser - The command parser
       * @param key - The key name for the new time series
       * @param options - Optional configuration parameters
       */
      parseCommand(parser, key, options2) {
        parser.push("TS.CREATE");
        parser.pushKey(key);
        (0, helpers_1.parseRetentionArgument)(parser, options2?.RETENTION);
        (0, helpers_1.parseEncodingArgument)(parser, options2?.ENCODING);
        (0, helpers_1.parseChunkSizeArgument)(parser, options2?.CHUNK_SIZE);
        (0, helpers_1.parseDuplicatePolicy)(parser, options2?.DUPLICATE_POLICY);
        (0, helpers_1.parseLabelsArgument)(parser, options2?.LABELS);
        (0, helpers_1.parseIgnoreArgument)(parser, options2?.IGNORE);
      },
      transformReply: void 0
    };
  }
});
var require_CREATERULE = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/CREATERULE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TIME_SERIES_AGGREGATION_TYPE = void 0;
    exports.TIME_SERIES_AGGREGATION_TYPE = {
      AVG: "AVG",
      FIRST: "FIRST",
      LAST: "LAST",
      MIN: "MIN",
      MAX: "MAX",
      SUM: "SUM",
      RANGE: "RANGE",
      COUNT: "COUNT",
      STD_P: "STD.P",
      STD_S: "STD.S",
      VAR_P: "VAR.P",
      VAR_S: "VAR.S",
      TWA: "TWA"
    };
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Creates a compaction rule from source time series to destination time series
       * @param parser - The command parser
       * @param sourceKey - The source time series key
       * @param destinationKey - The destination time series key
       * @param aggregationType - The aggregation type to use
       * @param bucketDuration - The duration of each bucket in milliseconds
       * @param alignTimestamp - Optional timestamp for alignment
       */
      parseCommand(parser, sourceKey, destinationKey, aggregationType, bucketDuration, alignTimestamp) {
        parser.push("TS.CREATERULE");
        parser.pushKeys([sourceKey, destinationKey]);
        parser.push("AGGREGATION", aggregationType, bucketDuration.toString());
        if (alignTimestamp !== void 0) {
          parser.push(alignTimestamp.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_INCRBY4 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/INCRBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseIncrByArguments = void 0;
    var helpers_1 = require_helpers2();
    function parseIncrByArguments(parser, key, value, options2) {
      parser.pushKey(key);
      parser.push(value.toString());
      if (options2?.TIMESTAMP !== void 0 && options2?.TIMESTAMP !== null) {
        parser.push("TIMESTAMP", (0, helpers_1.transformTimestampArgument)(options2.TIMESTAMP));
      }
      (0, helpers_1.parseRetentionArgument)(parser, options2?.RETENTION);
      if (options2?.UNCOMPRESSED) {
        parser.push("UNCOMPRESSED");
      }
      (0, helpers_1.parseChunkSizeArgument)(parser, options2?.CHUNK_SIZE);
      (0, helpers_1.parseLabelsArgument)(parser, options2?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options2?.IGNORE);
    }
    exports.parseIncrByArguments = parseIncrByArguments;
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Increases the value of a time series by a given amount
       * @param args - Arguments passed to the {@link parseIncrByArguments} function
       */
      parseCommand(...args) {
        const parser = args[0];
        parser.push("TS.INCRBY");
        parseIncrByArguments(...args);
      },
      transformReply: void 0
    };
  }
});
var require_DECRBY2 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/DECRBY.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var INCRBY_1 = __importStar(require_INCRBY4());
    exports.default = {
      IS_READ_ONLY: INCRBY_1.default.IS_READ_ONLY,
      /**
       * Decreases the value of a time series by a given amount
       * @param args - Arguments passed to the parseIncrByArguments function
       */
      parseCommand(...args) {
        const parser = args[0];
        parser.push("TS.DECRBY");
        (0, INCRBY_1.parseIncrByArguments)(...args);
      },
      transformReply: INCRBY_1.default.transformReply
    };
  }
});
var require_DEL4 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/DEL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_helpers2();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Deletes samples between two timestamps from a time series
       * @param parser - The command parser
       * @param key - The key name of the time series
       * @param fromTimestamp - Start timestamp to delete from
       * @param toTimestamp - End timestamp to delete until
       */
      parseCommand(parser, key, fromTimestamp, toTimestamp) {
        parser.push("TS.DEL");
        parser.pushKey(key);
        parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
      },
      transformReply: void 0
    };
  }
});
var require_DELETERULE = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/DELETERULE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Deletes a compaction rule between source and destination time series
       * @param parser - The command parser
       * @param sourceKey - The source time series key
       * @param destinationKey - The destination time series key
       */
      parseCommand(parser, sourceKey, destinationKey) {
        parser.push("TS.DELETERULE");
        parser.pushKeys([sourceKey, destinationKey]);
      },
      transformReply: void 0
    };
  }
});
var require_GET3 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/GET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets the last sample of a time series
       * @param parser - The command parser
       * @param key - The key name of the time series
       * @param options - Optional parameters for the command
       */
      parseCommand(parser, key, options2) {
        parser.push("TS.GET");
        parser.pushKey(key);
        if (options2?.LATEST) {
          parser.push("LATEST");
        }
      },
      transformReply: {
        2(reply) {
          return reply.length === 0 ? null : {
            timestamp: reply[0],
            value: Number(reply[1])
          };
        },
        3(reply) {
          return reply.length === 0 ? null : {
            timestamp: reply[0],
            value: reply[1]
          };
        }
      }
    };
  }
});
var require_INFO8 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/INFO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generic_transformers_1 = require_generic_transformers();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets information about a time series
       * @param parser - The command parser
       * @param key - The key name of the time series
       */
      parseCommand(parser, key) {
        parser.push("TS.INFO");
        parser.pushKey(key);
      },
      transformReply: {
        2: (reply, _, typeMapping) => {
          const ret = {};
          for (let i2 = 0; i2 < reply.length; i2 += 2) {
            const key = reply[i2].toString();
            switch (key) {
              case "totalSamples":
              case "memoryUsage":
              case "firstTimestamp":
              case "lastTimestamp":
              case "retentionTime":
              case "chunkCount":
              case "chunkSize":
              case "chunkType":
              case "duplicatePolicy":
              case "sourceKey":
              case "ignoreMaxTimeDiff":
                ret[key] = reply[i2 + 1];
                break;
              case "labels":
                ret[key] = reply[i2 + 1].map(([name, value]) => ({
                  name,
                  value
                }));
                break;
              case "rules":
                ret[key] = reply[i2 + 1].map(([key2, timeBucket, aggregationType]) => ({
                  key: key2,
                  timeBucket,
                  aggregationType
                }));
                break;
              case "ignoreMaxValDiff":
                ret[key] = generic_transformers_1.transformDoubleReply[2](reply[27], void 0, typeMapping);
                break;
            }
          }
          return ret;
        },
        3: void 0
      },
      unstableResp3: true
    };
  }
});
var require_INFO_DEBUG = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/INFO_DEBUG.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var INFO_1 = __importDefault(require_INFO8());
    exports.default = {
      IS_READ_ONLY: INFO_1.default.IS_READ_ONLY,
      /**
       * Gets debug information about a time series
       * @param parser - The command parser
       * @param key - The key name of the time series
       */
      parseCommand(parser, key) {
        INFO_1.default.parseCommand(parser, key);
        parser.push("DEBUG");
      },
      transformReply: {
        2: (reply, _, typeMapping) => {
          const ret = INFO_1.default.transformReply[2](reply, _, typeMapping);
          for (let i2 = 0; i2 < reply.length; i2 += 2) {
            const key = reply[i2].toString();
            switch (key) {
              case "keySelfName": {
                ret[key] = reply[i2 + 1];
                break;
              }
              case "Chunks": {
                ret["chunks"] = reply[i2 + 1].map((chunk) => ({
                  startTimestamp: chunk[1],
                  endTimestamp: chunk[3],
                  samples: chunk[5],
                  size: chunk[7],
                  bytesPerSample: chunk[9]
                }));
                break;
              }
            }
          }
          return ret;
        },
        3: void 0
      },
      unstableResp3: true
    };
  }
});
var require_MADD2 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MADD.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_helpers2();
    exports.default = {
      IS_READ_ONLY: false,
      /**
       * Adds multiple samples to multiple time series
       * @param parser - The command parser
       * @param toAdd - Array of samples to add to different time series
       */
      parseCommand(parser, toAdd) {
        parser.push("TS.MADD");
        for (const { key, timestamp, value } of toAdd) {
          parser.pushKey(key);
          parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
        }
      },
      transformReply: void 0
    };
  }
});
var require_MGET3 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MGET.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFilterArgument = exports.parseLatestArgument = void 0;
    var helpers_1 = require_helpers2();
    function parseLatestArgument(parser, latest) {
      if (latest) {
        parser.push("LATEST");
      }
    }
    exports.parseLatestArgument = parseLatestArgument;
    function parseFilterArgument(parser, filter) {
      parser.push("FILTER");
      parser.pushVariadic(filter);
    }
    exports.parseFilterArgument = parseFilterArgument;
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Gets the last samples matching a specific filter from multiple time series
       * @param parser - The command parser
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand(parser, filter, options2) {
        parser.push("TS.MGET");
        parseLatestArgument(parser, options2?.LATEST);
        parseFilterArgument(parser, filter);
      },
      transformReply: {
        2(reply, _, typeMapping) {
          return (0, helpers_1.resp2MapToValue)(reply, ([, , sample]) => {
            return {
              sample: helpers_1.transformSampleReply[2](sample)
            };
          }, typeMapping);
        },
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([, sample]) => {
            return {
              sample: helpers_1.transformSampleReply[3](sample)
            };
          });
        }
      }
    };
  }
});
var require_MGET_WITHLABELS = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MGET_WITHLABELS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransformMGetLabelsReply = void 0;
    var MGET_1 = require_MGET3();
    var helpers_1 = require_helpers2();
    function createTransformMGetLabelsReply() {
      return {
        2(reply, _, typeMapping) {
          return (0, helpers_1.resp2MapToValue)(reply, ([, labels, sample]) => {
            return {
              labels: (0, helpers_1.transformRESP2Labels)(labels),
              sample: helpers_1.transformSampleReply[2](sample)
            };
          }, typeMapping);
        },
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([labels, sample]) => {
            return {
              labels,
              sample: helpers_1.transformSampleReply[3](sample)
            };
          });
        }
      };
    }
    exports.createTransformMGetLabelsReply = createTransformMGetLabelsReply;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets the last samples matching a specific filter with labels
       * @param parser - The command parser
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand(parser, filter, options2) {
        parser.push("TS.MGET");
        (0, MGET_1.parseLatestArgument)(parser, options2?.LATEST);
        parser.push("WITHLABELS");
        (0, MGET_1.parseFilterArgument)(parser, filter);
      },
      transformReply: createTransformMGetLabelsReply()
    };
  }
});
var require_MGET_SELECTED_LABELS = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MGET_SELECTED_LABELS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MGET_1 = require_MGET3();
    var helpers_1 = require_helpers2();
    var MGET_WITHLABELS_1 = require_MGET_WITHLABELS();
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets the last samples matching a specific filter with selected labels
       * @param parser - The command parser
       * @param filter - Filter to match time series keys
       * @param selectedLabels - Labels to include in the output
       * @param options - Optional parameters for the command
       */
      parseCommand(parser, filter, selectedLabels, options2) {
        parser.push("TS.MGET");
        (0, MGET_1.parseLatestArgument)(parser, options2?.LATEST);
        (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
        (0, MGET_1.parseFilterArgument)(parser, filter);
      },
      transformReply: (0, MGET_WITHLABELS_1.createTransformMGetLabelsReply)()
    };
  }
});
var require_RANGE = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/RANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformRangeArguments = exports.parseRangeArguments = exports.TIME_SERIES_BUCKET_TIMESTAMP = void 0;
    var helpers_1 = require_helpers2();
    exports.TIME_SERIES_BUCKET_TIMESTAMP = {
      LOW: "-",
      MIDDLE: "~",
      END: "+"
    };
    function parseRangeArguments(parser, fromTimestamp, toTimestamp, options2) {
      parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
      if (options2?.LATEST) {
        parser.push("LATEST");
      }
      if (options2?.FILTER_BY_TS) {
        parser.push("FILTER_BY_TS");
        for (const timestamp of options2.FILTER_BY_TS) {
          parser.push((0, helpers_1.transformTimestampArgument)(timestamp));
        }
      }
      if (options2?.FILTER_BY_VALUE) {
        parser.push("FILTER_BY_VALUE", options2.FILTER_BY_VALUE.min.toString(), options2.FILTER_BY_VALUE.max.toString());
      }
      if (options2?.COUNT !== void 0) {
        parser.push("COUNT", options2.COUNT.toString());
      }
      if (options2?.AGGREGATION) {
        if (options2?.ALIGN !== void 0) {
          parser.push("ALIGN", (0, helpers_1.transformTimestampArgument)(options2.ALIGN));
        }
        parser.push("AGGREGATION", options2.AGGREGATION.type, (0, helpers_1.transformTimestampArgument)(options2.AGGREGATION.timeBucket));
        if (options2.AGGREGATION.BUCKETTIMESTAMP) {
          parser.push("BUCKETTIMESTAMP", options2.AGGREGATION.BUCKETTIMESTAMP);
        }
        if (options2.AGGREGATION.EMPTY) {
          parser.push("EMPTY");
        }
      }
    }
    exports.parseRangeArguments = parseRangeArguments;
    function transformRangeArguments(parser, key, fromTimestamp, toTimestamp, options2) {
      parser.pushKey(key);
      parseRangeArguments(parser, fromTimestamp, toTimestamp, options2);
    }
    exports.transformRangeArguments = transformRangeArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets samples from a time series within a time range
       * @param args - Arguments passed to the {@link transformRangeArguments} function
       */
      parseCommand(...args) {
        const parser = args[0];
        parser.push("TS.RANGE");
        transformRangeArguments(...args);
      },
      transformReply: {
        2(reply) {
          return helpers_1.transformSamplesReply[2](reply);
        },
        3(reply) {
          return helpers_1.transformSamplesReply[3](reply);
        }
      }
    };
  }
});
var require_MRANGE_GROUPBY = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MRANGE_GROUPBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractResp3MRangeSources = exports.createTransformMRangeGroupByArguments = exports.parseGroupByArguments = exports.TIME_SERIES_REDUCERS = void 0;
    var helpers_1 = require_helpers2();
    var RANGE_1 = require_RANGE();
    var MGET_1 = require_MGET3();
    exports.TIME_SERIES_REDUCERS = {
      AVG: "AVG",
      SUM: "SUM",
      MIN: "MIN",
      MAX: "MAX",
      RANGE: "RANGE",
      COUNT: "COUNT",
      STD_P: "STD.P",
      STD_S: "STD.S",
      VAR_P: "VAR.P",
      VAR_S: "VAR.S"
    };
    function parseGroupByArguments(parser, groupBy) {
      parser.push("GROUPBY", groupBy.label, "REDUCE", groupBy.REDUCE);
    }
    exports.parseGroupByArguments = parseGroupByArguments;
    function createTransformMRangeGroupByArguments(command) {
      return (parser, fromTimestamp, toTimestamp, filter, groupBy, options2) => {
        parser.push(command);
        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options2);
        (0, MGET_1.parseFilterArgument)(parser, filter);
        parseGroupByArguments(parser, groupBy);
      };
    }
    exports.createTransformMRangeGroupByArguments = createTransformMRangeGroupByArguments;
    function extractResp3MRangeSources(raw) {
      const unwrappedMetadata2 = raw;
      if (unwrappedMetadata2 instanceof Map) {
        return unwrappedMetadata2.get("sources");
      } else if (unwrappedMetadata2 instanceof Array) {
        return unwrappedMetadata2[1];
      } else {
        return unwrappedMetadata2.sources;
      }
    }
    exports.extractResp3MRangeSources = extractResp3MRangeSources;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets samples for time series matching a filter within a time range with grouping
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param groupBy - Group by parameters
       * @param options - Optional parameters for the command
       */
      parseCommand: createTransformMRangeGroupByArguments("TS.MRANGE"),
      transformReply: {
        2(reply, _, typeMapping) {
          return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
            return {
              samples: helpers_1.transformSamplesReply[2](samples)
            };
          }, typeMapping);
        },
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata1, metadata2, samples]) => {
            return {
              sources: extractResp3MRangeSources(metadata2),
              samples: helpers_1.transformSamplesReply[3](samples)
            };
          });
        }
      }
    };
  }
});
var require_MRANGE_SELECTED_LABELS = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransformMRangeSelectedLabelsArguments = void 0;
    var helpers_1 = require_helpers2();
    var RANGE_1 = require_RANGE();
    var MGET_1 = require_MGET3();
    function createTransformMRangeSelectedLabelsArguments(command) {
      return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, options2) => {
        parser.push(command);
        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options2);
        (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
        (0, MGET_1.parseFilterArgument)(parser, filter);
      };
    }
    exports.createTransformMRangeSelectedLabelsArguments = createTransformMRangeSelectedLabelsArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets samples for time series matching a filter with selected labels
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param selectedLabels - Labels to include in the output
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand: createTransformMRangeSelectedLabelsArguments("TS.MRANGE"),
      transformReply: {
        2(reply, _, typeMapping) {
          return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
            return {
              labels: (0, helpers_1.transformRESP2Labels)(labels, typeMapping),
              samples: helpers_1.transformSamplesReply[2](samples)
            };
          }, typeMapping);
        },
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([_key, labels, samples]) => {
            return {
              labels,
              samples: helpers_1.transformSamplesReply[3](samples)
            };
          });
        }
      }
    };
  }
});
var require_MRANGE_SELECTED_LABELS_GROUPBY = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS_GROUPBY.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMRangeSelectedLabelsGroupByTransformArguments = void 0;
    var helpers_1 = require_helpers2();
    var RANGE_1 = require_RANGE();
    var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
    var MGET_1 = require_MGET3();
    var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
    function createMRangeSelectedLabelsGroupByTransformArguments(command) {
      return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, groupBy, options2) => {
        parser.push(command);
        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options2);
        (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
        (0, MGET_1.parseFilterArgument)(parser, filter);
        (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
      };
    }
    exports.createMRangeSelectedLabelsGroupByTransformArguments = createMRangeSelectedLabelsGroupByTransformArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets samples for time series matching a filter with selected labels and grouping
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param selectedLabels - Labels to include in the output
       * @param filter - Filter to match time series keys
       * @param groupBy - Group by parameters
       * @param options - Optional parameters for the command
       */
      parseCommand: createMRangeSelectedLabelsGroupByTransformArguments("TS.MRANGE"),
      transformReply: {
        2: MRANGE_SELECTED_LABELS_1.default.transformReply[2],
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
            return {
              labels,
              sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
              samples: helpers_1.transformSamplesReply[3](samples)
            };
          });
        }
      }
    };
  }
});
var require_MRANGE_WITHLABELS_GROUPBY = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS_GROUPBY.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMRangeWithLabelsGroupByTransformArguments = void 0;
    var helpers_1 = require_helpers2();
    var RANGE_1 = require_RANGE();
    var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
    var MGET_1 = require_MGET3();
    function createMRangeWithLabelsGroupByTransformArguments(command) {
      return (parser, fromTimestamp, toTimestamp, filter, groupBy, options2) => {
        parser.push(command);
        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options2);
        parser.push("WITHLABELS");
        (0, MGET_1.parseFilterArgument)(parser, filter);
        (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
      };
    }
    exports.createMRangeWithLabelsGroupByTransformArguments = createMRangeWithLabelsGroupByTransformArguments;
    exports.default = {
      IS_READ_ONLY: true,
      /**
       * Gets samples for time series matching a filter with labels and grouping
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param groupBy - Group by parameters
       * @param options - Optional parameters for the command
       */
      parseCommand: createMRangeWithLabelsGroupByTransformArguments("TS.MRANGE"),
      transformReply: {
        2(reply, _, typeMapping) {
          return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
            const transformed = (0, helpers_1.transformRESP2LabelsWithSources)(labels);
            return {
              labels: transformed.labels,
              sources: transformed.sources,
              samples: helpers_1.transformSamplesReply[2](samples)
            };
          }, typeMapping);
        },
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
            return {
              labels,
              sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
              samples: helpers_1.transformSamplesReply[3](samples)
            };
          });
        }
      }
    };
  }
});
var require_MRANGE_WITHLABELS = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransformMRangeWithLabelsArguments = void 0;
    var helpers_1 = require_helpers2();
    var RANGE_1 = require_RANGE();
    var MGET_1 = require_MGET3();
    function createTransformMRangeWithLabelsArguments(command) {
      return (parser, fromTimestamp, toTimestamp, filter, options2) => {
        parser.push(command);
        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options2);
        parser.push("WITHLABELS");
        (0, MGET_1.parseFilterArgument)(parser, filter);
      };
    }
    exports.createTransformMRangeWithLabelsArguments = createTransformMRangeWithLabelsArguments;
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Gets samples for time series matching a filter with labels
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand: createTransformMRangeWithLabelsArguments("TS.MRANGE"),
      transformReply: {
        2(reply, _, typeMapping) {
          return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
            const unwrappedLabels = labels;
            const labelsObject = /* @__PURE__ */ Object.create(null);
            for (const tuple of unwrappedLabels) {
              const [key, value] = tuple;
              const unwrappedKey = key;
              labelsObject[unwrappedKey.toString()] = value;
            }
            return {
              labels: labelsObject,
              samples: helpers_1.transformSamplesReply[2](samples)
            };
          }, typeMapping);
        },
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, samples]) => {
            return {
              labels,
              samples: helpers_1.transformSamplesReply[3](samples)
            };
          });
        }
      }
    };
  }
});
var require_MRANGE = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MRANGE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransformMRangeArguments = void 0;
    var helpers_1 = require_helpers2();
    var RANGE_1 = require_RANGE();
    var MGET_1 = require_MGET3();
    function createTransformMRangeArguments(command) {
      return (parser, fromTimestamp, toTimestamp, filter, options2) => {
        parser.push(command);
        (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options2);
        (0, MGET_1.parseFilterArgument)(parser, filter);
      };
    }
    exports.createTransformMRangeArguments = createTransformMRangeArguments;
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Gets samples for time series matching a specific filter within a time range
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand: createTransformMRangeArguments("TS.MRANGE"),
      transformReply: {
        2(reply, _, typeMapping) {
          return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
            return helpers_1.transformSamplesReply[2](samples);
          }, typeMapping);
        },
        3(reply) {
          return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata, samples]) => {
            return helpers_1.transformSamplesReply[3](samples);
          });
        }
      }
    };
  }
});
var require_MREVRANGE_GROUPBY = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_GROUPBY.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MRANGE_GROUPBY_1 = __importStar(require_MRANGE_GROUPBY());
    exports.default = {
      IS_READ_ONLY: MRANGE_GROUPBY_1.default.IS_READ_ONLY,
      /**
       * Gets samples for time series matching a filter within a time range with grouping (in reverse order)
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param groupBy - Group by parameters
       * @param options - Optional parameters for the command
       */
      parseCommand: (0, MRANGE_GROUPBY_1.createTransformMRangeGroupByArguments)("TS.MREVRANGE"),
      transformReply: MRANGE_GROUPBY_1.default.transformReply
    };
  }
});
var require_MREVRANGE_SELECTED_LABELS_GROUPBY = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS_GROUPBY.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importStar(require_MRANGE_SELECTED_LABELS_GROUPBY());
    exports.default = {
      IS_READ_ONLY: MRANGE_SELECTED_LABELS_GROUPBY_1.default.IS_READ_ONLY,
      /**
       * Gets samples for time series matching a filter with selected labels and grouping (in reverse order)
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param selectedLabels - Labels to include in the output
       * @param filter - Filter to match time series keys
       * @param groupBy - Group by parameters
       * @param options - Optional parameters for the command
       */
      parseCommand: (0, MRANGE_SELECTED_LABELS_GROUPBY_1.createMRangeSelectedLabelsGroupByTransformArguments)("TS.MREVRANGE"),
      transformReply: MRANGE_SELECTED_LABELS_GROUPBY_1.default.transformReply
    };
  }
});
var require_MREVRANGE_SELECTED_LABELS = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MRANGE_SELECTED_LABELS_1 = __importStar(require_MRANGE_SELECTED_LABELS());
    exports.default = {
      IS_READ_ONLY: MRANGE_SELECTED_LABELS_1.default.IS_READ_ONLY,
      /**
       * Gets samples for time series matching a filter with selected labels (in reverse order)
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param selectedLabels - Labels to include in the output
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand: (0, MRANGE_SELECTED_LABELS_1.createTransformMRangeSelectedLabelsArguments)("TS.MREVRANGE"),
      transformReply: MRANGE_SELECTED_LABELS_1.default.transformReply
    };
  }
});
var require_MREVRANGE_WITHLABELS_GROUPBY = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS_GROUPBY.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MRANGE_WITHLABELS_GROUPBY_1 = __importStar(require_MRANGE_WITHLABELS_GROUPBY());
    exports.default = {
      IS_READ_ONLY: MRANGE_WITHLABELS_GROUPBY_1.default.IS_READ_ONLY,
      /**
       * Gets samples for time series matching a filter with labels and grouping (in reverse order)
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param groupBy - Group by parameters
       * @param options - Optional parameters for the command
       */
      parseCommand: (0, MRANGE_WITHLABELS_GROUPBY_1.createMRangeWithLabelsGroupByTransformArguments)("TS.MREVRANGE"),
      transformReply: MRANGE_WITHLABELS_GROUPBY_1.default.transformReply
    };
  }
});
var require_MREVRANGE_WITHLABELS = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MRANGE_WITHLABELS_1 = __importStar(require_MRANGE_WITHLABELS());
    exports.default = {
      NOT_KEYED_COMMAND: MRANGE_WITHLABELS_1.default.NOT_KEYED_COMMAND,
      IS_READ_ONLY: MRANGE_WITHLABELS_1.default.IS_READ_ONLY,
      /**
       * Gets samples for time series matching a filter with labels (in reverse order)
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand: (0, MRANGE_WITHLABELS_1.createTransformMRangeWithLabelsArguments)("TS.MREVRANGE"),
      transformReply: MRANGE_WITHLABELS_1.default.transformReply
    };
  }
});
var require_MREVRANGE = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/MREVRANGE.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MRANGE_1 = __importStar(require_MRANGE());
    exports.default = {
      NOT_KEYED_COMMAND: MRANGE_1.default.NOT_KEYED_COMMAND,
      IS_READ_ONLY: MRANGE_1.default.IS_READ_ONLY,
      /**
       * Gets samples for time series matching a specific filter within a time range (in reverse order)
       * @param parser - The command parser
       * @param fromTimestamp - Start timestamp for range
       * @param toTimestamp - End timestamp for range
       * @param filter - Filter to match time series keys
       * @param options - Optional parameters for the command
       */
      parseCommand: (0, MRANGE_1.createTransformMRangeArguments)("TS.MREVRANGE"),
      transformReply: MRANGE_1.default.transformReply
    };
  }
});
var require_QUERYINDEX = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/QUERYINDEX.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      NOT_KEYED_COMMAND: true,
      IS_READ_ONLY: true,
      /**
       * Queries the index for time series matching a specific filter
       * @param parser - The command parser
       * @param filter - Filter to match time series labels
       */
      parseCommand(parser, filter) {
        parser.push("TS.QUERYINDEX");
        parser.pushVariadic(filter);
      },
      transformReply: {
        2: void 0,
        3: void 0
      }
    };
  }
});
var require_REVRANGE = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/REVRANGE.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var RANGE_1 = __importStar(require_RANGE());
    exports.default = {
      IS_READ_ONLY: RANGE_1.default.IS_READ_ONLY,
      /**
       * Gets samples from a time series within a time range (in reverse order)
       * @param args - Arguments passed to the {@link transformRangeArguments} function
       */
      parseCommand(...args) {
        const parser = args[0];
        parser.push("TS.REVRANGE");
        (0, RANGE_1.transformRangeArguments)(...args);
      },
      transformReply: RANGE_1.default.transformReply
    };
  }
});
var require_commands6 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/commands/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p in m3) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m3, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ADD_1 = __importDefault(require_ADD5());
    var ALTER_1 = __importDefault(require_ALTER2());
    var CREATE_1 = __importDefault(require_CREATE3());
    var CREATERULE_1 = __importDefault(require_CREATERULE());
    var DECRBY_1 = __importDefault(require_DECRBY2());
    var DEL_1 = __importDefault(require_DEL4());
    var DELETERULE_1 = __importDefault(require_DELETERULE());
    var GET_1 = __importDefault(require_GET3());
    var INCRBY_1 = __importDefault(require_INCRBY4());
    var INFO_DEBUG_1 = __importDefault(require_INFO_DEBUG());
    var INFO_1 = __importDefault(require_INFO8());
    var MADD_1 = __importDefault(require_MADD2());
    var MGET_SELECTED_LABELS_1 = __importDefault(require_MGET_SELECTED_LABELS());
    var MGET_WITHLABELS_1 = __importDefault(require_MGET_WITHLABELS());
    var MGET_1 = __importDefault(require_MGET3());
    var MRANGE_GROUPBY_1 = __importDefault(require_MRANGE_GROUPBY());
    var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MRANGE_SELECTED_LABELS_GROUPBY());
    var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
    var MRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MRANGE_WITHLABELS_GROUPBY());
    var MRANGE_WITHLABELS_1 = __importDefault(require_MRANGE_WITHLABELS());
    var MRANGE_1 = __importDefault(require_MRANGE());
    var MREVRANGE_GROUPBY_1 = __importDefault(require_MREVRANGE_GROUPBY());
    var MREVRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS_GROUPBY());
    var MREVRANGE_SELECTED_LABELS_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS());
    var MREVRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_WITHLABELS_GROUPBY());
    var MREVRANGE_WITHLABELS_1 = __importDefault(require_MREVRANGE_WITHLABELS());
    var MREVRANGE_1 = __importDefault(require_MREVRANGE());
    var QUERYINDEX_1 = __importDefault(require_QUERYINDEX());
    var RANGE_1 = __importDefault(require_RANGE());
    var REVRANGE_1 = __importDefault(require_REVRANGE());
    __exportStar(require_helpers2(), exports);
    exports.default = {
      ADD: ADD_1.default,
      add: ADD_1.default,
      ALTER: ALTER_1.default,
      alter: ALTER_1.default,
      CREATE: CREATE_1.default,
      create: CREATE_1.default,
      CREATERULE: CREATERULE_1.default,
      createRule: CREATERULE_1.default,
      DECRBY: DECRBY_1.default,
      decrBy: DECRBY_1.default,
      DEL: DEL_1.default,
      del: DEL_1.default,
      DELETERULE: DELETERULE_1.default,
      deleteRule: DELETERULE_1.default,
      GET: GET_1.default,
      get: GET_1.default,
      INCRBY: INCRBY_1.default,
      incrBy: INCRBY_1.default,
      INFO_DEBUG: INFO_DEBUG_1.default,
      infoDebug: INFO_DEBUG_1.default,
      INFO: INFO_1.default,
      info: INFO_1.default,
      MADD: MADD_1.default,
      mAdd: MADD_1.default,
      MGET_SELECTED_LABELS: MGET_SELECTED_LABELS_1.default,
      mGetSelectedLabels: MGET_SELECTED_LABELS_1.default,
      MGET_WITHLABELS: MGET_WITHLABELS_1.default,
      mGetWithLabels: MGET_WITHLABELS_1.default,
      MGET: MGET_1.default,
      mGet: MGET_1.default,
      MRANGE_GROUPBY: MRANGE_GROUPBY_1.default,
      mRangeGroupBy: MRANGE_GROUPBY_1.default,
      MRANGE_SELECTED_LABELS_GROUPBY: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
      mRangeSelectedLabelsGroupBy: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
      MRANGE_SELECTED_LABELS: MRANGE_SELECTED_LABELS_1.default,
      mRangeSelectedLabels: MRANGE_SELECTED_LABELS_1.default,
      MRANGE_WITHLABELS_GROUPBY: MRANGE_WITHLABELS_GROUPBY_1.default,
      mRangeWithLabelsGroupBy: MRANGE_WITHLABELS_GROUPBY_1.default,
      MRANGE_WITHLABELS: MRANGE_WITHLABELS_1.default,
      mRangeWithLabels: MRANGE_WITHLABELS_1.default,
      MRANGE: MRANGE_1.default,
      mRange: MRANGE_1.default,
      MREVRANGE_GROUPBY: MREVRANGE_GROUPBY_1.default,
      mRevRangeGroupBy: MREVRANGE_GROUPBY_1.default,
      MREVRANGE_SELECTED_LABELS_GROUPBY: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
      mRevRangeSelectedLabelsGroupBy: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
      MREVRANGE_SELECTED_LABELS: MREVRANGE_SELECTED_LABELS_1.default,
      mRevRangeSelectedLabels: MREVRANGE_SELECTED_LABELS_1.default,
      MREVRANGE_WITHLABELS_GROUPBY: MREVRANGE_WITHLABELS_GROUPBY_1.default,
      mRevRangeWithLabelsGroupBy: MREVRANGE_WITHLABELS_GROUPBY_1.default,
      MREVRANGE_WITHLABELS: MREVRANGE_WITHLABELS_1.default,
      mRevRangeWithLabels: MREVRANGE_WITHLABELS_1.default,
      MREVRANGE: MREVRANGE_1.default,
      mRevRange: MREVRANGE_1.default,
      QUERYINDEX: QUERYINDEX_1.default,
      queryIndex: QUERYINDEX_1.default,
      RANGE: RANGE_1.default,
      range: RANGE_1.default,
      REVRANGE: REVRANGE_1.default,
      revRange: REVRANGE_1.default
    };
  }
});
var require_lib7 = __commonJS({
  "node_modules/.deno/@redis+time-series@5.9.0/node_modules/@redis/time-series/dist/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TIME_SERIES_REDUCERS = exports.TIME_SERIES_BUCKET_TIMESTAMP = exports.TIME_SERIES_AGGREGATION_TYPE = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.TIME_SERIES_ENCODING = exports.default = void 0;
    var commands_1 = require_commands6();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return __importDefault(commands_1).default;
    } });
    Object.defineProperty(exports, "TIME_SERIES_ENCODING", { enumerable: true, get: function() {
      return commands_1.TIME_SERIES_ENCODING;
    } });
    Object.defineProperty(exports, "TIME_SERIES_DUPLICATE_POLICIES", { enumerable: true, get: function() {
      return commands_1.TIME_SERIES_DUPLICATE_POLICIES;
    } });
    var CREATERULE_1 = require_CREATERULE();
    Object.defineProperty(exports, "TIME_SERIES_AGGREGATION_TYPE", { enumerable: true, get: function() {
      return CREATERULE_1.TIME_SERIES_AGGREGATION_TYPE;
    } });
    var RANGE_1 = require_RANGE();
    Object.defineProperty(exports, "TIME_SERIES_BUCKET_TIMESTAMP", { enumerable: true, get: function() {
      return RANGE_1.TIME_SERIES_BUCKET_TIMESTAMP;
    } });
    var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
    Object.defineProperty(exports, "TIME_SERIES_REDUCERS", { enumerable: true, get: function() {
      return MRANGE_GROUPBY_1.TIME_SERIES_REDUCERS;
    } });
  }
});
var require_dist2 = __commonJS({
  "node_modules/.deno/redis@5.9.0/node_modules/redis/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m3, k);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m3, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m3[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p in m3) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m3, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSentinel = exports.createCluster = exports.createClientPool = exports.createClient = void 0;
    var client_1 = require_dist();
    var bloom_1 = __importDefault(require_lib4());
    var json_1 = __importDefault(require_lib5());
    var search_1 = __importDefault(require_lib6());
    var time_series_1 = __importDefault(require_lib7());
    __exportStar(require_dist(), exports);
    __exportStar(require_lib4(), exports);
    __exportStar(require_lib5(), exports);
    __exportStar(require_lib6(), exports);
    __exportStar(require_lib7(), exports);
    var modules = {
      ...bloom_1.default,
      json: json_1.default,
      ft: search_1.default,
      ts: time_series_1.default
    };
    function createClient3(options2) {
      return (0, client_1.createClient)({
        ...options2,
        modules: {
          ...modules,
          ...options2?.modules
        }
      });
    }
    exports.createClient = createClient3;
    function createClientPool(clientOptions, options2) {
      return (0, client_1.createClientPool)({
        ...clientOptions,
        modules: {
          ...modules,
          ...clientOptions?.modules
        }
      }, options2);
    }
    exports.createClientPool = createClientPool;
    function createCluster(options2) {
      return (0, client_1.createCluster)({
        ...options2,
        modules: {
          ...modules,
          ...options2?.modules
        }
      });
    }
    exports.createCluster = createCluster;
    function createSentinel(options2) {
      return (0, client_1.createSentinel)({
        ...options2,
        modules: {
          ...modules,
          ...options2?.modules
        }
      });
    }
    exports.createSentinel = createSentinel;
  }
});
var database_redis_exports = {};
__export(database_redis_exports, {
  default: () => RedisBackend
});
var import_npm_redis;
var RedisBackend;
var init_database_redis = __esm({
  "src/serve/database-redis.ts"() {
    "use strict";
    import_npm_redis = __toESM(require_dist2());
    init_DatabaseBackend();
    RedisBackend = class extends DatabaseBackend {
      db = null;
      url;
      constructor(options2 = {}) {
        super();
        this.url = options2.url;
      }
      async init() {
        const db2 = (0, import_npm_redis.createClient)({
          RESP: 3,
          url: this.url
        }).withTypeMapping({
          [import_npm_redis.RESP_TYPES.BLOB_STRING]: Buffer10
        });
        await db2.connect();
        this.db = db2;
      }
      // Useful in test hooks.
      async clear() {
        await this.db.flushAll();
      }
      async readData(key) {
        return await this.db.get(key) ?? void 0;
      }
      async writeData(key, value) {
        await this.db.set(key, value);
      }
      async deleteData(key) {
        await this.db.del(key);
      }
      close() {
        this.db.destroy();
      }
      async *iterKeys() {
        const keys = await this.db.keys("*");
        for (const key of keys) {
          yield key;
        }
      }
    };
  }
});
var database_sqlite_exports = {};
__export(database_sqlite_exports, {
  default: () => SqliteBackend
});
var SqliteBackend;
var init_database_sqlite = __esm({
  "src/serve/database-sqlite.ts"() {
    "use strict";
    init_DatabaseBackend();
    SqliteBackend = class extends DatabaseBackend {
      dataFolder = "";
      db = null;
      filename = "";
      readStatement = null;
      writeStatement = null;
      deleteStatement = null;
      iterKeysStatement = null;
      constructor(options2 = {}) {
        super();
        const { filepath } = options2;
        const resolvedPath = resolve22(filepath);
        this.dataFolder = dirname22(resolvedPath);
        this.filename = basename22(resolvedPath);
      }
      run(sql) {
        this.db.prepare(sql).run();
      }
      async init() {
        const { dataFolder: dataFolder2, filename } = this;
        await mkdir2(dataFolder2, { mode: 488, recursive: true });
        if (this.db) {
          throw new Error(`The ${filename} SQLite database is already open.`);
        }
        this.db = new Database(join22(dataFolder2, filename));
        this.run("CREATE TABLE IF NOT EXISTS Data(key TEXT NOT NULL PRIMARY KEY, value TEXT NOT NULL)");
        console.info(`Connected to the ${filename} SQLite database.`);
        this.readStatement = this.db.prepare("SELECT value FROM Data WHERE key = ?");
        this.writeStatement = this.db.prepare("REPLACE INTO Data(key, value) VALUES(?, ?)");
        this.deleteStatement = this.db.prepare("DELETE FROM Data WHERE key = ?");
        this.iterKeysStatement = this.db.prepare("SELECT key FROM Data");
      }
      // Useful in test hooks.
      // deno-lint-ignore require-await
      async clear() {
        this.run("DELETE FROM Data");
      }
      // deno-lint-ignore require-await
      async readData(key) {
        const row = this.readStatement.get(key);
        return row?.value;
      }
      async writeData(key, value) {
        await this.writeStatement.run(key, value);
      }
      async deleteData(key) {
        await this.deleteStatement.run(key);
      }
      close() {
        this.db.close();
      }
      async *iterKeys() {
        for (const row of this.iterKeysStatement.iter()) {
          yield row[0];
        }
      }
    };
  }
});
var globImport_database_ts;
var init_ = __esm({
  'import("./database-*.ts") in src/serve/database-router.ts'() {
    globImport_database_ts = __glob({
      "./database-fs.ts": () => Promise.resolve().then(() => (init_database_fs(), database_fs_exports)),
      "./database-redis.ts": () => Promise.resolve().then(() => (init_database_redis(), database_redis_exports)),
      "./database-router.test.ts": () => Promise.resolve().then(() => (init_database_router_test(), database_router_test_exports)),
      "./database-router.ts": () => Promise.resolve().then(() => (init_database_router(), database_router_exports)),
      "./database-sqlite.ts": () => Promise.resolve().then(() => (init_database_sqlite(), database_sqlite_exports))
    });
  }
});
var database_router_exports = {};
__export(database_router_exports, {
  default: () => RouterBackend
});
var GI_PERSIST_ROUTER_CONFIG;
var GI_PERSIST_ROUTER_CONFIG_PATH;
var RouterBackend;
var init_database_router = __esm({
  "src/serve/database-router.ts"() {
    "use strict";
    init_DatabaseBackend();
    init_();
    ({
      GI_PERSIST_ROUTER_CONFIG: (
        // Tried first by the config lookup.
        // Define this if your config JSON comes as a string from an envar's contents.
        GI_PERSIST_ROUTER_CONFIG
      ),
      GI_PERSIST_ROUTER_CONFIG_PATH: (
        // Tried next.
        // Define this if your config comes from a JSON file.
        GI_PERSIST_ROUTER_CONFIG_PATH
      ) = "./database-router-config.json"
    } = process4.env);
    RouterBackend = class extends DatabaseBackend {
      backends;
      config;
      constructor(options2 = {}) {
        super();
        if (options2.config) this.config = options2.config;
      }
      lookupBackend(key) {
        const { backends, config } = this;
        const keyPrefixes = Object.keys(config);
        for (let i2 = 0; i2 < keyPrefixes.length; i2++) {
          if (key.startsWith(keyPrefixes[i2])) {
            return backends[keyPrefixes[i2]];
          }
        }
        return backends["*"];
      }
      async readConfig() {
        if (GI_PERSIST_ROUTER_CONFIG) {
          console.info("[database-router] Reading config from envar GI_PERSIST_ROUTER_CONFIG");
        } else {
          console.info("[database-router] Reading config from path", GI_PERSIST_ROUTER_CONFIG_PATH);
        }
        const configString = GI_PERSIST_ROUTER_CONFIG || await readFile2(resolve32(GI_PERSIST_ROUTER_CONFIG_PATH), "utf8");
        const config = JSON.parse(configString);
        return Object.fromEntries(Object.entries(config).sort((a, b) => b[0].length - a[0].length));
      }
      validateConfig(config) {
        const errors = [];
        if (!config["*"]) {
          errors.push({ msg: 'Missing key: "*" (fallback storage is required)' });
        }
        for (const entry of Object.entries(config)) {
          const value = entry[1];
          if (typeof value?.name !== "string" || typeof value?.options !== "object") {
            errors.push({ msg: "entry value must be of type { name: string, options: Object }", entry });
            continue;
          }
          if (value.name === "router") {
            errors.push({ msg: "Router backends cannot be nested.", entry });
            continue;
          }
        }
        return errors;
      }
      async init() {
        if (!this.config) this.config = await this.readConfig();
        const errors = this.validateConfig(this.config);
        if (errors.length) {
          throw new Error(`[${this.constructor.name}] ${errors.length} error(s) found in your config.`, { cause: errors });
        }
        this.backends = /* @__PURE__ */ Object.create(null);
        const entries = Object.entries(this.config);
        await Promise.all(entries.map(async (entry) => {
          const [keyPrefix, { name, options: options2 }] = entry;
          const Ctor = (await globImport_database_ts(`./database-${name}.ts`)).default;
          const backend = new Ctor(options2);
          await backend.init();
          this.backends[keyPrefix] = backend;
        }));
      }
      async readData(key) {
        return await this.lookupBackend(key).readData(key);
      }
      async writeData(key, value) {
        return await this.lookupBackend(key).writeData(key, value);
      }
      async deleteData(key) {
        return await this.lookupBackend(key).deleteData(key);
      }
      async clear() {
        for (const backend of new Set(Object.values(this.backends))) {
          try {
            await backend.clear();
          } catch (e2) {
            const prefix = Object.entries(this.backends).find(([, b]) => b === backend)[0];
            console.error(e2, `Error clearing DB for prefix ${prefix}`);
          }
        }
      }
      async close() {
        for (const backend of new Set(Object.values(this.backends))) {
          try {
            await backend.close();
          } catch (e2) {
            const prefix = Object.entries(this.backends).find(([, b]) => b === backend)[0];
            console.error(e2, `Error closing DB for prefix ${prefix}`);
          }
        }
      }
      async *iterKeys() {
        for (const backend of new Set(Object.values(this.backends))) {
          yield* backend.iterKeys();
        }
      }
    };
  }
});
var database_router_test_exports = {};
var CID2;
var randomKeyWithPrefix;
var validConfig;
var db;
var init_database_router_test = __esm({
  "src/serve/database-router.test.ts"() {
    "use strict";
    init_esm4();
    init_database_router();
    CID2 = "Q";
    randomKeyWithPrefix = (prefix) => `${prefix}${globalThis.crypto.randomUUID().replaceAll("-", "")}`;
    validConfig = {
      [CID2]: {
        name: "sqlite",
        options: {
          filepath: "./test/temp/sqlite.db"
        }
      },
      "*": {
        name: "fs",
        options: {
          dirname: "./test/temp"
        }
      }
    };
    db = new RouterBackend({ config: validConfig });
    Deno.test({
      name: "DatabaseRouter::validateConfig",
      async fn(t) {
        await t.step("should accept a valid config", () => {
          const errors = db.validateConfig(validConfig);
          if (errors.length !== 0) throw new Error(`Expected 0 errors but got ${errors.length}`);
        });
        await t.step("should reject configs missing a * key", () => {
          const config = omit(validConfig, ["*"]);
          const errors = db.validateConfig(config);
          if (errors.length !== 1) throw new Error(`Expected 1 error but got ${errors.length}`);
        });
        await t.step("should reject config entries missing a name", () => {
          const config = cloneDeep(validConfig);
          delete config["*"].name;
          const errors = db.validateConfig(config);
          if (errors.length !== 1) throw new Error(`Expected 1 error but got ${errors.length}`);
        });
      }
    });
    Deno.test({
      name: "DatabaseRouter::lookupBackend",
      async fn(t) {
        await db.init();
        try {
          await t.step("should find the right backend for keys starting with configured prefixes", () => {
            for (const keyPrefix of Object.keys(db.config)) {
              if (keyPrefix === "*") continue;
              const key = randomKeyWithPrefix(keyPrefix);
              const actual = db.lookupBackend(key);
              const expected = db.backends[keyPrefix];
              if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
            }
          });
          await t.step("should find the right backend for keys equal to configured prefixes", () => {
            for (const keyPrefix of Object.keys(db.config)) {
              const key = keyPrefix;
              const actual = db.lookupBackend(key);
              const expected = db.backends[keyPrefix];
              if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
            }
          });
          await t.step("should return the fallback backend for keys not matching any configured prefix", () => {
            const key = "foo";
            const actual = db.lookupBackend(key);
            const expected = db.backends["*"];
            if (actual !== expected) throw new Error(`Expected ${expected} but got ${actual}`);
          });
        } finally {
          await db.clear();
        }
      }
    });
  }
});
var require_err_helpers = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js"(exports, module) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});
var require_err_proto = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js"(exports, module) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});
var require_err = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js"(exports, module) {
    "use strict";
    module.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});
var require_err_with_cause = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports, module) {
    "use strict";
    module.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});
var require_req = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js"(exports, module) {
    "use strict";
    module.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path2 = req.path;
        _req.url = typeof path2 === "string" ? path2 : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});
var require_res = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js"(exports, module) {
    "use strict";
    module.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});
var require_pino_std_serializers = __commonJS({
  "node_modules/.deno/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/index.js"(exports, module) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});
var require_caller = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/caller.js"(exports, module) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});
var require_validator = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js"(exports, module) {
    "use strict";
    module.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
      } = opts;
      return function validate({ paths }) {
        paths.forEach((s) => {
          if (typeof s !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (/〇/.test(s)) throw Error();
            const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr)) throw Error();
            if (/\/\*/.test(expr)) throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e2) {
            throw Error(ERR_INVALID_PATH(s));
          }
        });
      };
    }
  }
});
var require_rx = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js"(exports, module) {
    "use strict";
    module.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});
var require_parse = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js"(exports, module) {
    "use strict";
    var rx = require_rx();
    module.exports = parse5;
    function parse5({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o2, strPath, ix) {
        var path2 = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path2 = path2.map((p) => {
          if (p[0] === "[") return p.substr(1, p.length - 2);
          else return p;
        });
        const star = path2.indexOf("*");
        if (star > -1) {
          const before = path2.slice(0, star);
          const beforeStr = before.join(".");
          const after = path2.slice(star + 1, path2.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o2[strPath] = {
            path: path2,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o2;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});
var require_redactor = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js"(exports, module) {
    "use strict";
    var rx = require_rx();
    module.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);
      redact.state = state;
      if (serialize === false) {
        redact.restore = (o2) => state.restore(o2);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path2) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path2];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path2)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0) existence += `o${delim}${path2} != null`;
        else existence += ` && o${delim}${path2} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path2}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path2} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});
var require_modifiers = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js"(exports, module) {
    "use strict";
    module.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null || typeof target === "string") return;
      const length2 = keys.length;
      for (var i2 = 0; i2 < length2; i2++) {
        const k = keys[i2];
        target[k] = values[i2];
      }
    }
    function groupRedact(o2, path2, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o2, path2);
      if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path2.length;
      const pathWithKey = censorFctTakesPath ? [...path2] : void 0;
      const values = new Array(keysLength);
      for (var i2 = 0; i2 < keysLength; i2++) {
        const key = keys[i2];
        values[i2] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i2 = 0; i2 < instructions.length; i2++) {
        const { target, path: path2, value } = instructions[i2];
        let current = target;
        for (let i3 = path2.length - 1; i3 > 0; i3--) {
          current = current[path2[i3]];
        }
        current[path2[0]] = value;
      }
    }
    function nestedRedact(store, o2, path2, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o2, path2);
      if (target == null) return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i2 = 0; i2 < keysLength; i2++) {
        const key = keys[i2];
        specialSet(store, target, key, path2, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has2(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o2, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i2 = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n = o2[k];
      if (typeof n !== "object") return;
      while (n != null && ++i2 < afterPathLen) {
        depth += 1;
        k = afterPath[i2];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i2 !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i2;
              ov = iterateNthLevel(wcov, level - 1, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, o2[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o2[originalKey]);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o2[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has2(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o2[originalKey]);
            store.push(rv);
            n[k] = nv;
          }
          n = n[k];
        }
        if (typeof n !== "object") break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get(o2, p) {
      var i2 = -1;
      var l = p.length;
      var n = o2;
      while (n != null && ++i2 < l) {
        n = n[p[i2]];
      }
      return n;
    }
    function iterateNthLevel(wcov, level, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i2 !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i2, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path2 = [];
      do {
        path2.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path: path2, value, target };
    }
  }
});
var require_restorer = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js"(exports, module) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module.exports = restorer;
    function restorer() {
      return function compileRestore() {
        if (this.restore) {
          this.restore.state.secret = this.secret;
          return;
        }
        const { secret, wcLen } = this;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function(
          "o",
          restoreTmpl(resetters, paths, hasWildcards)
        ).bind(state);
        this.restore.state = state;
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path2) => {
        const { circle, escPath, leadingBracket } = secret[path2];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path2} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});
var require_state = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js"(exports, module) {
    "use strict";
    module.exports = state;
    function state(o2) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o2;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize !== false) builder.push({ serialize });
      if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});
var require_fast_redact = __commonJS({
  "node_modules/.deno/fast-redact@3.5.0/node_modules/fast-redact/index.js"(exports, module) {
    "use strict";
    var validator = require_validator();
    var parse5 = require_parse();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state();
    var rx = require_rx();
    var validate = validator();
    var noop = (o2) => o2;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0) return serialize || noop;
      validate({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse5({ paths, censor });
      const compileRestore = restorer();
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});
var require_symbols = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/symbols.js"(exports, module) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var levelCompSym = Symbol("pino.levelComp");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});
var require_redaction = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/redaction.js"(exports, module) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols();
    var { rx, validator } = fastRedact;
    var validate = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o2, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o2[ns] = null;
          return o2;
        }
        if (o2[ns] === null) {
          return o2;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o2[ns] = o2[ns] || [];
        if (ns !== wildcardFirstSym && o2[ns].length === 0) {
          o2[ns].push(...o2[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o2).forEach(function(k) {
            if (o2[k]) {
              o2[k].push(nextPath);
            }
          });
        }
        o2[ns].push(nextPath);
        return o2;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o2, k) => {
        if (shape[k] === null) {
          o2[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path2) => {
            return censor(value, [k, ...path2]);
          } : censor;
          o2[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o2;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      validate({ paths, censor });
      return { paths, censor };
    }
    module.exports = redaction;
  }
});
var require_time = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/time.js"(exports, module) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});
var require_quick_format_unescaped = __commonJS({
  "node_modules/.deno/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o2) {
      try {
        return JSON.stringify(o2);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module.exports = format22;
    function format22(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0) return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i2 = 0; i2 < flen; ) {
        if (f.charCodeAt(i2) === 37 && i2 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i2 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += Number(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += Math.floor(Number(args[a]));
              lastPos = i2 + 2;
              i2++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0) break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              str += ss(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += String(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 37:
              if (lastPos < i2)
                str += f.slice(lastPos, i2);
              str += "%";
              lastPos = i2 + 2;
              i2++;
              a--;
              break;
          }
          ++a;
        }
        ++i2;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});
var require_atomic_sleep = __commonJS({
  "node_modules/.deno/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports, module) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module.exports = sleep;
    }
  }
});
var require_sonic_boom = __commonJS({
  "node_modules/.deno/sonic-boom@3.8.1/node_modules/sonic-boom/index.js"(exports, module) {
    "use strict";
    var fs2 = __require2("fs");
    var EventEmitter = __require2("events");
    var inherits = __require2("util").inherits;
    var path2 = __require2("path");
    var sleep = require_atomic_sleep();
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs2.mkdirSync(path2.dirname(file), { recursive: true });
          const fd = fs2.openSync(file, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs2.mkdir(path2.dirname(file), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs2.open(file, flags, mode, fileOpened);
        });
      } else {
        fs2.open(file, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, sync, append = true, mkdir: mkdir3, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir3 || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs2.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs2.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n2 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs2.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
    }
    function releaseWritingBuf(writingBuf, len, n) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
      }
      len = Math.max(len - n, 0);
      writingBuf = writingBuf.slice(n);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([data]);
        lens.push(data.length);
      } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          fs2.fsync(this.fd, (err) => {
            this._flushPending = false;
            cb(err);
          });
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file) {
        this.file = file;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs2.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf2 = "";
      while (this._bufs.length || buf2) {
        if (buf2.length <= 0) {
          buf2 = this._bufs[0];
        }
        try {
          const n = fs2.writeSync(this.fd, buf2, "utf8");
          const releasedBufObj = releaseWritingBuf(buf2, this._len, n);
          buf2 = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf2.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs2.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf2 = kEmptyBuffer;
      while (this._bufs.length || buf2.length) {
        if (buf2.length <= 0) {
          buf2 = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n = fs2.writeSync(this.fd, buf2);
          buf2 = buf2.subarray(n);
          this._len = Math.max(this._len - n, 0);
          if (buf2.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs2.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs2.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs2.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs2.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      fs2.fsync(sonic.fd, closeWrapped);
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs2.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module.exports = SonicBoom;
  }
});
var require_on_exit_leak_free = __commonJS({
  "node_modules/.deno/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js"(exports, module) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry;
    function ensureRegistry() {
      if (registry === void 0) {
        registry = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry === void 0) {
        return;
      }
      registry.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});
var require_package2 = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/package.json"(exports, module) {
    module.exports = {
      name: "thread-stream",
      version: "2.7.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^3.0.0",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        test: 'standard && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});
var require_wait2 = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/wait.js"(exports, module) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index);
            if (current === prior) {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check(1);
    }
    function waitDiff(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check(1);
    }
    module.exports = { wait, waitDiff };
  }
});
var require_indexes = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/lib/indexes.js"(exports, module) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});
var require_thread_stream = __commonJS({
  "node_modules/.deno/thread-stream@2.7.0/node_modules/thread-stream/index.js"(exports, module) {
    "use strict";
    var { version } = require_package2();
    var { EventEmitter } = __require2("events");
    var { Worker } = __require2("worker_threads");
    var { join: join32 } = __require2("path");
    var { pathToFileURL } = __require2("url");
    var { wait } = require_wait2();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = __require2("buffer");
    var assert2 = __require2("assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join32(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert2(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code2) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code2 !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length2 = Buffer.byteLength(data);
      stream[kImpl].data.write(data, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length2);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module.exports = ThreadStream;
  }
});
var require_transport = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/transport.js"(exports, module) {
    "use strict";
    var { createRequire } = __require2("module");
    var getCallers = require_caller();
    var { join: join32, isAbsolute: isAbsolute6, sep } = __require2("path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, options: options2 = {}, worker = {}, caller = getCallers() } = fullOptions;
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join32(__dirname, "worker.js");
        options2.targets = targets.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-pipeline-worker"] || join32(__dirname, "worker-pipeline.js");
        options2.targets = pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      }
      if (levels) {
        options2.levels = levels;
      }
      if (dedupe) {
        options2.dedupe = dedupe;
      }
      return buildStream(fixTarget(target), options2, worker);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute6(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join32(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module.exports = transport;
  }
});
var require_tools = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/tools.js"(exports, module) {
    "use strict";
    var format22 = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols();
    var { isMainThread } = __require2("worker_threads");
    var transport = require_transport();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o2, ...n) {
        if (typeof o2 === "object") {
          let msg = o2;
          if (o2 !== null) {
            if (o2.method && o2.headers && o2.socket) {
              o2 = mapHttpRequest(o2);
            } else if (typeof o2.setHeader === "function") {
              o2 = mapHttpResponse(o2);
            }
          }
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o2, format22(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o2 === void 0 ? n.shift() : o2;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format22(msg, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i2 = 0; i2 < l && point >= 32; i2++) {
        point = str.charCodeAt(i2);
        if (point === 34 || point === 92) {
          result += str.slice(last, i2) + "\\";
          last = i2;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify2 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time;
      data = data + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
          if (value === void 0) continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions2) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions2, opts);
        opts.serializers = Object.assign({}, defaultOptions2.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions2.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled: enabled2, onChild } = opts;
        if (enabled2 === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify2 = stringifySafeFn || this[stringifySafeSym];
          return stringify2(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});
var require_constants = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/constants.js"(exports, module) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});
var require_levels = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/levels.js"(exports, module) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e2) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o2, k) => {
      o2[DEFAULT_LEVELS[k]] = k;
      return o2;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o2, k) => {
      o2[k] = '{"level":' + Number(k);
      return o2;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache2 = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache2[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache2;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel2) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel2];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o2, k) => {
        o2[customLevels[k]] = k;
        return o2;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});
var require_meta = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/meta.js"(exports, module) {
    "use strict";
    module.exports = { version: "8.19.0" };
  }
});
var require_proto = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/proto.js"(exports, module) {
    "use strict";
    var { EventEmitter } = __require2("events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym
    } = require_symbols();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify
    } = require_tools();
    var {
      version
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options2) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options2 = options2 || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options2.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i2 = 0; i2 < parentSymbols.length; i2++) {
          const ks = parentSymbols[i2];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options2.serializers) {
          instance[serializersSym][bk] = options2.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options2.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options2.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options2.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options2.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options2.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options2.customLevels);
        instance.levels = mappings(options2.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options2.redact === "object" && options2.redact !== null || Array.isArray(options2.redact)) {
        instance.redact = options2.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options2.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options2.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options2.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(s);
    }
    function noop() {
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});
var require_safe_stable_stringify = __commonJS({
  "node_modules/.deno/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports, module) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports.stringify = stringify;
    exports.configure = configure;
    module.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i2 = 1; i2 < array.length; i2++) {
        const currentValue = array[i2];
        let position = i2;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i2 = 1; i2 < maximumBreadth; i2++) {
        res += `${separator}"${i2}":${whitespace}${array[i2]}`;
      }
      return res;
    }
    function getCircularValueOption(options2) {
      if (hasOwnProperty.call(options2, "circularValue")) {
        const circularValue = options2.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options2) {
      let value;
      if (hasOwnProperty.call(options2, "deterministic")) {
        value = options2.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options2, key) {
      let value;
      if (hasOwnProperty.call(options2, key)) {
        value = options2[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options2, key) {
      let value;
      if (hasOwnProperty.call(options2, key)) {
        value = options2[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options2) {
      if (hasOwnProperty.call(options2, "strict")) {
        const value = options2.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options2) {
      options2 = { ...options2 };
      const fail = getStrictOption(options2);
      if (fail) {
        if (options2.bigint === void 0) {
          options2.bigint = false;
        }
        if (!("circularValue" in options2)) {
          options2.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options2);
      const bigint = getBooleanOption(options2, "bigint");
      const deterministic = getDeterministicOption(options2);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options2, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options2, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join32 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join32 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyFnReplacer(String(i2), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join32;
              }
              const tmp = stringifyFnReplacer(String(i2), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join32}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join32 = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join32;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join32;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join32 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join32 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyArrayReplacer(String(i2), value[i2], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join32;
              }
              const tmp = stringifyArrayReplacer(String(i2), value[i2], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join32}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join32 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join32;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join42 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifyIndent(String(i2), value[i2], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join42;
              }
              const tmp = stringifyIndent(String(i2), value[i2], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join42}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join32 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join32, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join32;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join32;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join32;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i2 = 0;
              for (; i2 < maximumValuesToStringify - 1; i2++) {
                const tmp2 = stringifySimple(String(i2), value[i2], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i2), value[i2], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i2 = 0; i2 < maximumPropertiesToStringify; i2++) {
              const key2 = keys[i2];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});
var require_multistream = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/lib/multistream.js"(exports, module) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i2) => {
          streamLevels[i2] = opts.levels[i2];
        });
      }
      const res = {
        write,
        add,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i2 = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i2, streams.length, opts.dedupe); i2 = adjustLoopVar(i2, opts.dedupe)) {
          dest = streams[i2];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone(level) {
        const streams = new Array(this.streams.length);
        for (let i2 = 0; i2 < streams.length; i2++) {
          streams[i2] = {
            level,
            stream: this.streams[i2].stream
          };
        }
        return {
          write,
          add,
          minLevel: level,
          streams,
          clone,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a, b) {
      return a.level - b.level;
    }
    function initLoopVar(length2, dedupe) {
      return dedupe ? length2 - 1 : 0;
    }
    function adjustLoopVar(i2, dedupe) {
      return dedupe ? i2 - 1 : i2 + 1;
    }
    function checkLoopVar(i2, length2, dedupe) {
      return dedupe ? i2 >= 0 : i2 < length2;
    }
    module.exports = multistream;
  }
});
var require_pino = __commonJS({
  "node_modules/.deno/pino@8.19.0/node_modules/pino/pino.js"(exports, module) {
    "use strict";
    var os = __require2("os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time = require_time();
    var proto3 = require_proto();
    var symbols2 = require_symbols();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify,
      normalizeDestFileDescriptor,
      noop
    } = require_tools();
    var { version } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols2;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions2 = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number) {
          return { level: number };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize22 = createArgsNormalizer(defaultOptions2);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino2(...args) {
      const instance = {};
      const { opts, stream } = normalize22(instance, caller(), ...args);
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base: base2,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base2 !== null) {
        if (name === void 0) {
          chindings = coreChindings(base2);
        } else {
          chindings = coreChindings(Object.assign({}, base2, { name }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto3());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module.exports = pino2;
    module.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module.exports.transport = require_transport();
    module.exports.multistream = require_multistream();
    module.exports.levels = mappings();
    module.exports.stdSerializers = serializers;
    module.exports.stdTimeFunctions = Object.assign({}, time);
    module.exports.symbols = symbols2;
    module.exports.version = version;
    module.exports.default = pino2;
    module.exports.pino = pino2;
  }
});
init_esm();
var OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL = 3e4;
init_esm2();
init_esm();
init_esm3();
var listenKey = (evt) => `events/${evt}/listeners`;
var esm_default4 = esm_default("sbp/selectors/register", {
  "okTurtles.events/_init": function() {
    this.errorHandler = (event, e2) => {
      console.error(`[okTurtles.events] Error at handler for ${event}`, e2);
    };
  },
  "okTurtles.events/on": function(event, handler) {
    esm_default("okTurtles.data/add", listenKey(event), handler);
    return () => esm_default("okTurtles.events/off", event, handler);
  },
  "okTurtles.events/once": function(event, handler) {
    const cbWithOff = (...args) => {
      handler(...args);
      esm_default("okTurtles.events/off", event, cbWithOff);
    };
    return esm_default("okTurtles.events/on", event, cbWithOff);
  },
  "okTurtles.events/emit": function(event, ...data) {
    var _a2;
    for (const listener of esm_default("okTurtles.data/get", listenKey(event)) || []) {
      try {
        listener(...data);
      } catch (e2) {
        (_a2 = this.errorHandler) === null || _a2 === void 0 ? void 0 : _a2.call(this, event, e2);
      }
    }
  },
  // almost identical to Vue.prototype.$off, except we require `event` argument
  "okTurtles.events/off": function(event, handler) {
    if (handler) {
      esm_default("okTurtles.data/remove", listenKey(event), handler);
    } else {
      esm_default("okTurtles.data/delete", listenKey(event));
    }
  },
  "okTurtles.events/setErrorHandler": function(errorHandler) {
    this.errorHandler = errorHandler;
  }
});
init_esm();
init_esm4();
init_functions();
init_esm();
var NOTIFICATION_TYPE = Object.freeze({
  ENTRY: "entry",
  DELETION: "deletion",
  KV: "kv",
  KV_FILTER: "kv_filter",
  PING: "ping",
  PONG: "pong",
  PUB: "pub",
  SUB: "sub",
  UNSUB: "unsub",
  VERSION_INFO: "version_info"
});
var REQUEST_TYPE = Object.freeze({
  PUB: "pub",
  SUB: "sub",
  UNSUB: "unsub",
  PUSH_ACTION: "push_action",
  KV_FILTER: "kv_filter"
});
var RESPONSE_TYPE = Object.freeze({
  ERROR: "error",
  OK: "ok"
});
var PUSH_SERVER_ACTION_TYPE = Object.freeze({
  SEND_PUBLIC_KEY: "send-public-key",
  STORE_SUBSCRIPTION: "store-subscription",
  DELETE_SUBSCRIPTION: "delete-subscription",
  SEND_PUSH_NOTIFICATION: "send-push-notification"
});
var defaultOptions = {
  logPingMessages: !process.env.CI,
  pingTimeout: 45e3,
  maxReconnectionDelay: 6e4,
  maxRetries: 10,
  minReconnectionDelay: 500,
  reconnectOnDisconnection: true,
  reconnectOnOnline: true,
  // Defaults to false to avoid reconnection attempts in case the server doesn't
  // respond because of a failed authentication.
  reconnectOnTimeout: false,
  reconnectionDelayGrowFactor: 2,
  timeout: 6e4
};
var PUBSUB_ERROR = "pubsub-error";
var PUBSUB_RECONNECTION_ATTEMPT = "pubsub-reconnection-attempt";
var PUBSUB_RECONNECTION_FAILED = "pubsub-reconnection-failed";
var PUBSUB_RECONNECTION_SCHEDULED = "pubsub-reconnection-scheduled";
var PUBSUB_RECONNECTION_SUCCEEDED = "pubsub-reconnection-succeeded";
var PUBSUB_SUBSCRIPTION_SUCCEEDED = "pubsub-subscription-succeeded";
function createClient(url, options2 = {}) {
  const client = {
    customEventHandlers: options2.handlers || {},
    // The current number of connection attempts that failed.
    // Reset to 0 upon successful connection.
    // Used to compute how long to wait before the next reconnection attempt.
    failedConnectionAttempts: 0,
    isLocal: /\/\/(localhost|127\.0\.0\.1)([:?/]|$)/.test(url),
    // True if this client has never been connected yet.
    isNew: true,
    listeners: /* @__PURE__ */ Object.create(null),
    messageHandlers: { ...defaultMessageHandlers, ...options2.messageHandlers },
    nextConnectionAttemptDelayID: void 0,
    options: { ...defaultOptions, ...options2 },
    // Requested subscriptions for which we didn't receive a response yet.
    pendingSubscriptionSet: /* @__PURE__ */ new Set(),
    pendingUnsubscriptionSet: /* @__PURE__ */ new Set(),
    pingTimeoutID: void 0,
    shouldReconnect: true,
    // The underlying WebSocket object.
    // A new one is necessary for every connection or reconnection attempt.
    socket: null,
    subscriptionSet: /* @__PURE__ */ new Set(),
    kvFilter: /* @__PURE__ */ new Map(),
    connectionTimeoutID: void 0,
    url: url.replace(/^http/, "ws"),
    ...publicMethods
  };
  for (const name of Object.keys(defaultClientEventHandlers)) {
    client.listeners[name] = (event) => {
      try {
        defaultClientEventHandlers[name].call(client, event);
        client.customEventHandlers[name]?.call(client, event);
      } catch (error) {
        esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, error?.message);
      }
    };
  }
  if (typeof self === "object" && self instanceof EventTarget) {
    for (const name of globalEventNames) {
      globalEventMap.set(name, client.listeners[name]);
    }
  }
  if (!client.options.manual) {
    client.connect();
  }
  return client;
}
function createMessage(type, data, meta) {
  const message = { ...meta, type, data };
  let string;
  const stringify = function() {
    if (!string)
      string = JSON.stringify(this);
    return string;
  };
  Object.defineProperties(message, {
    [Symbol.toPrimitive]: {
      value: stringify
    }
  });
  return message;
}
function createPubMessage(channelID, data) {
  return JSON.stringify({ type: NOTIFICATION_TYPE.PUB, channelID, data });
}
function createRequest(type, data) {
  return JSON.stringify(Object.assign({ type }, data));
}
var defaultClientEventHandlers = {
  // Emitted when the connection is closed.
  close(event) {
    const client = this;
    console.debug("[pubsub] Event: close", event.code, event.reason);
    client.failedConnectionAttempts++;
    if (client.socket) {
      for (const name of socketEventNames) {
        client.socket.removeEventListener(name, client.listeners[name]);
      }
    }
    client.socket = null;
    client.clearAllTimers();
    if (client.shouldReconnect) {
      client.subscriptionSet.forEach((channelID) => {
        if (!client.pendingUnsubscriptionSet.has(channelID)) {
          client.pendingSubscriptionSet.add(channelID);
        }
      });
    }
    client.subscriptionSet.clear();
    client.pendingUnsubscriptionSet.clear();
    if (client.shouldReconnect && client.options.reconnectOnDisconnection) {
      if (client.failedConnectionAttempts > client.options.maxRetries) {
        esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_FAILED, client);
      } else {
        if (!isDefinetelyOffline() || client.isLocal) {
          client.scheduleConnectionAttempt();
        }
      }
    }
  },
  // Emitted when an error has occured.
  // The socket will be closed automatically by the engine if necessary.
  error(event) {
    const client = this;
    console.warn("[pubsub] Event: error", event);
    clearTimeout(client.pingTimeoutID);
  },
  // Emitted when a message is received.
  // The connection will be terminated if the message is malformed or has an
  // unexpected data type (e.g. binary instead of text).
  message(event) {
    const client = this;
    const { data } = event;
    if (typeof data !== "string") {
      esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, {
        message: `Wrong data type: ${typeof data}`
      });
      return client.destroy();
    }
    let msg = { type: "" };
    try {
      msg = messageParser(data);
    } catch (error) {
      esm_default("okTurtles.events/emit", PUBSUB_ERROR, client, {
        message: `Malformed message: ${error?.message}`
      });
      return client.destroy();
    }
    const handler = client.messageHandlers[msg.type];
    if (handler) {
      handler.call(client, msg);
    } else {
      throw new Error(`Unhandled message type: ${msg.type}`);
    }
  },
  offline() {
    console.info("[pubsub] Event: offline");
    const client = this;
    client.clearAllTimers();
    client.failedConnectionAttempts = 0;
    client.socket?.close();
  },
  online() {
    console.info("[pubsub] Event: online");
    const client = this;
    if (client.options.reconnectOnOnline && client.shouldReconnect) {
      if (!client.socket) {
        client.failedConnectionAttempts = 0;
        client.scheduleConnectionAttempt();
      }
    }
  },
  // Emitted when the connection is established.
  open() {
    console.debug("[pubsub] Event: open");
    const client = this;
    const { options: options2 } = this;
    client.connectionTimeUsed = void 0;
    client.clearAllTimers();
    esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_SUCCEEDED, client);
    client.failedConnectionAttempts = -1;
    client.isNew = false;
    if (options2.pingTimeout > 0 && options2.pingTimeout < Infinity) {
      client.pingTimeoutID = setTimeout(() => {
        client.socket?.close();
      }, options2.pingTimeout);
    }
    client.pendingSubscriptionSet.forEach((channelID) => {
      const kvFilter = this.kvFilter.get(channelID);
      client.socket?.send(createRequest(REQUEST_TYPE.SUB, kvFilter ? { channelID, kvFilter } : { channelID }));
    });
  },
  "reconnection-attempt"() {
    console.info("[pubsub] Trying to reconnect...");
  },
  "reconnection-succeeded"() {
    console.info("[pubsub] Connection re-established");
  },
  "reconnection-failed"() {
    console.warn("[pubsub] Reconnection failed");
    const client = this;
    client.destroy();
  },
  "reconnection-scheduled"(event) {
    const { delay: delay2, nth } = event.detail;
    console.info(`[pubsub] Scheduled connection attempt ${nth} in ~${delay2} ms`);
  },
  "subscription-succeeded"(event) {
    const { channelID } = event.detail;
    console.debug(`[pubsub] Subscribed to channel ${channelID}`);
  }
};
var defaultMessageHandlers = {
  [NOTIFICATION_TYPE.ENTRY](msg) {
    console.debug("[pubsub] Received ENTRY:", msg);
  },
  [NOTIFICATION_TYPE.PING]({ data }) {
    const client = this;
    if (client.options.logPingMessages) {
      console.debug(`[pubsub] Ping received in ${Date.now() - Number(data)} ms`);
    }
    client.socket?.send(createMessage(NOTIFICATION_TYPE.PONG, data));
    clearTimeout(client.pingTimeoutID);
    client.pingTimeoutID = setTimeout(() => {
      client.socket?.close();
    }, client.options.pingTimeout);
  },
  [NOTIFICATION_TYPE.PUB]({ channelID, data }) {
    console.log(`[pubsub] Received data from channel ${channelID}:`, data);
  },
  [NOTIFICATION_TYPE.KV]({ channelID, key, data }) {
    console.log(`[pubsub] Received KV update from channel ${channelID} ${key}:`, data);
  },
  [NOTIFICATION_TYPE.SUB](msg) {
    console.debug(`[pubsub] Ignoring ${msg.type} message:`, msg.data);
  },
  [NOTIFICATION_TYPE.UNSUB](msg) {
    console.debug(`[pubsub] Ignoring ${msg.type} message:`, msg.data);
  },
  [RESPONSE_TYPE.ERROR]({ data }) {
    const { type, channelID, reason } = data;
    console.warn(`[pubsub] Received ERROR response for ${type} request to ${channelID}`);
    const client = this;
    switch (type) {
      case REQUEST_TYPE.SUB: {
        console.warn(`[pubsub] Could not subscribe to ${channelID}: ${reason}`);
        client.pendingSubscriptionSet.delete(channelID);
        break;
      }
      case REQUEST_TYPE.UNSUB: {
        console.warn(`[pubsub] Could not unsubscribe from ${channelID}: ${reason}`);
        client.pendingUnsubscriptionSet.delete(channelID);
        break;
      }
      case REQUEST_TYPE.PUSH_ACTION: {
        const { actionType, message } = data;
        console.warn(`[pubsub] Received ERROR for PUSH_ACTION request with the action type '${actionType}' and the following message: ${message}`);
        break;
      }
      default: {
        console.error(`[pubsub] Malformed response: invalid request type ${type}`);
      }
    }
  },
  [RESPONSE_TYPE.OK]({ data: { type, channelID } }) {
    const client = this;
    switch (type) {
      case REQUEST_TYPE.SUB: {
        client.pendingSubscriptionSet.delete(channelID);
        client.subscriptionSet.add(channelID);
        esm_default("okTurtles.events/emit", PUBSUB_SUBSCRIPTION_SUCCEEDED, client, { channelID });
        break;
      }
      case REQUEST_TYPE.UNSUB: {
        console.debug(`[pubsub] Unsubscribed from ${channelID}`);
        client.pendingUnsubscriptionSet.delete(channelID);
        client.subscriptionSet.delete(channelID);
        client.kvFilter.delete(channelID);
        break;
      }
      case REQUEST_TYPE.KV_FILTER: {
        console.debug(`[pubsub] Set KV filter for ${channelID}`);
        break;
      }
      default: {
        console.error(`[pubsub] Malformed response: invalid request type ${type}`);
      }
    }
  }
};
var globalEventNames = ["offline", "online"];
var socketEventNames = ["close", "error", "message", "open"];
var globalEventMap = /* @__PURE__ */ new Map();
if (typeof self === "object" && self instanceof EventTarget) {
  for (const name of globalEventNames) {
    const handler = (ev) => {
      const h2 = globalEventMap.get(name);
      return h2?.(ev);
    };
    self.addEventListener(name, handler, false);
  }
}
var isDefinetelyOffline = () => typeof navigator === "object" && navigator.onLine === false;
var messageParser = (data) => {
  const msg = JSON.parse(data);
  if (typeof msg !== "object" || msg === null) {
    throw new TypeError("Message is null or not an object");
  }
  const { type } = msg;
  if (typeof type !== "string" || type === "") {
    throw new TypeError("Message type must be a non-empty string");
  }
  return msg;
};
var publicMethods = {
  clearAllTimers() {
    const client = this;
    clearTimeout(client.connectionTimeoutID);
    clearTimeout(client.nextConnectionAttemptDelayID);
    clearTimeout(client.pingTimeoutID);
    client.connectionTimeoutID = void 0;
    client.nextConnectionAttemptDelayID = void 0;
    client.pingTimeoutID = void 0;
  },
  // Performs a connection or reconnection attempt.
  connect() {
    const client = this;
    if (client.socket !== null) {
      throw new Error("connect() can only be called if there is no current socket.");
    }
    if (client.nextConnectionAttemptDelayID) {
      throw new Error("connect() must not be called during a reconnection delay.");
    }
    if (!client.shouldReconnect) {
      throw new Error("connect() should no longer be called on this instance.");
    }
    client.socket = new WebSocket(client.url);
    client.socket.send = function(data) {
      const send = WebSocket.prototype.send.bind(this);
      if (typeof data === "object" && typeof data[Symbol.toPrimitive] === "function") {
        return send(data[Symbol.toPrimitive]());
      }
      return send(data);
    };
    if (client.options.timeout) {
      const start = performance.now();
      client.connectionTimeoutID = setTimeout(() => {
        client.connectionTimeoutID = void 0;
        if (client.options.reconnectOnTimeout) {
          client.connectionTimeUsed = performance.now() - start;
        }
        client.socket?.close(4e3, "timeout");
      }, client.options.timeout);
    }
    for (const name of socketEventNames) {
      client.socket.addEventListener(name, client.listeners[name]);
    }
  },
  /**
   * Immediately close the socket, stop listening for events and clear any cache.
   *
   * This method is used in unit tests.
   * - In particular, no 'close' event handler will be called.
   * - Any incoming or outgoing buffered data will be discarded.
   * - Any pending messages will be discarded.
   */
  destroy() {
    const client = this;
    client.clearAllTimers();
    client.pendingSubscriptionSet.clear();
    client.pendingUnsubscriptionSet.clear();
    client.subscriptionSet.clear();
    if (typeof self === "object" && self instanceof EventTarget) {
      for (const name of globalEventNames) {
        globalEventMap.delete(name);
      }
    }
    if (client.socket) {
      for (const name of socketEventNames) {
        client.socket.removeEventListener(name, client.listeners[name]);
      }
      client.socket.close();
    }
    client.listeners = /* @__PURE__ */ Object.create(null);
    client.socket = null;
    client.shouldReconnect = false;
  },
  getNextRandomDelay() {
    const client = this;
    const { maxReconnectionDelay, minReconnectionDelay, reconnectionDelayGrowFactor } = client.options;
    const minDelay = minReconnectionDelay * reconnectionDelayGrowFactor ** client.failedConnectionAttempts;
    const maxDelay = minDelay * reconnectionDelayGrowFactor;
    const connectionTimeUsed = client.connectionTimeUsed;
    client.connectionTimeUsed = void 0;
    return Math.min(
      // See issue #1943: Have the connection time used 'eat into' the
      // reconnection time used
      Math.max(minReconnectionDelay, connectionTimeUsed ? maxReconnectionDelay - connectionTimeUsed : maxReconnectionDelay),
      Math.round(minDelay + (0, Math.random)() * (maxDelay - minDelay))
    );
  },
  // Schedules a connection attempt to happen after a delay computed according to
  // a randomized exponential backoff algorithm variant.
  scheduleConnectionAttempt() {
    const client = this;
    if (!client.shouldReconnect) {
      throw new Error("Cannot call `scheduleConnectionAttempt()` when `shouldReconnect` is false.");
    }
    if (client.nextConnectionAttemptDelayID) {
      return console.warn("[pubsub] A reconnection attempt is already scheduled.");
    }
    const delay2 = client.getNextRandomDelay();
    const nth = client.failedConnectionAttempts + 1;
    client.nextConnectionAttemptDelayID = setTimeout(() => {
      esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_ATTEMPT, client);
      client.nextConnectionAttemptDelayID = void 0;
      client.connect();
    }, delay2);
    esm_default("okTurtles.events/emit", PUBSUB_RECONNECTION_SCHEDULED, client, { delay: delay2, nth });
  },
  // Can be used to send ephemeral messages outside of any contract log.
  // Does nothing if the socket is not in the OPEN state.
  pub(channelID, data) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(createPubMessage(channelID, data));
    }
  },
  /**
   * Sends a SUB request to the server as soon as possible.
   *
   * - The given channel ID will be cached until we get a relevant server
   * response, allowing us to resend the same request if necessary.
   * - Any identical UNSUB request that has not been sent yet will be cancelled.
   * - Calling this method again before the server has responded has no effect.
   * @param channelID - The ID of the channel whose updates we want to subscribe to.
   */
  sub(channelID) {
    const client = this;
    const { socket } = this;
    if (!client.pendingSubscriptionSet.has(channelID)) {
      client.pendingSubscriptionSet.add(channelID);
      client.pendingUnsubscriptionSet.delete(channelID);
      if (socket?.readyState === WebSocket.OPEN) {
        const kvFilter = client.kvFilter.get(channelID);
        socket.send(createRequest(REQUEST_TYPE.SUB, kvFilter ? { channelID, kvFilter } : { channelID }));
      }
    }
  },
  /**
   * Sends a KV_FILTER request to the server as soon as possible.
   */
  setKvFilter(channelID, kvFilter) {
    const client = this;
    const { socket } = this;
    if (kvFilter) {
      client.kvFilter.set(channelID, kvFilter);
    } else {
      client.kvFilter.delete(channelID);
    }
    if (client.subscriptionSet.has(channelID)) {
      if (socket?.readyState === WebSocket.OPEN) {
        socket.send(createRequest(REQUEST_TYPE.KV_FILTER, kvFilter ? { channelID, kvFilter } : { channelID }));
      }
    }
  },
  /**
   * Sends an UNSUB request to the server as soon as possible.
   *
   * - The given channel ID will be cached until we get a relevant server
   * response, allowing us to resend the same request if necessary.
   * - Any identical SUB request that has not been sent yet will be cancelled.
   * - Calling this method again before the server has responded has no effect.
   * @param channelID - The ID of the channel whose updates we want to unsubscribe from.
   */
  unsub(channelID) {
    const client = this;
    const { socket } = this;
    if (!client.pendingUnsubscriptionSet.has(channelID)) {
      client.pendingSubscriptionSet.delete(channelID);
      client.pendingUnsubscriptionSet.add(channelID);
      if (socket?.readyState === WebSocket.OPEN) {
        socket.send(createRequest(REQUEST_TYPE.UNSUB, { channelID }));
      }
    }
  }
};
for (const name of Object.keys(defaultClientEventHandlers)) {
  if (name === "error" || !socketEventNames.includes(name)) {
    esm_default("okTurtles.events/on", `pubsub-${name}`, (target, detail) => {
      const ev = new CustomEvent(name, { detail });
      target.listeners[name].call(target, ev);
    });
  }
}
init_esm6();
init_errors();
var CHELONIA_RESET = "chelonia-reset";
var CONTRACT_IS_SYNCING = "contract-is-syncing";
var CONTRACTS_MODIFIED = "contracts-modified";
var EVENT_HANDLED = "event-handled";
var EVENT_PUBLISHED = "event-published";
var EVENT_PUBLISHING_ERROR = "event-publishing-error";
var CONTRACT_REGISTERED = "contract-registered";
var CONTRACT_IS_PENDING_KEY_REQUESTS = "contract-is-pending-key-requests";
var CONTRACT_HAS_RECEIVED_KEYS = "contract-has-received-keys";
init_SPMessage();
init_esm();
var chelonia_utils_default = esm_default("sbp/selectors/register", {
  // This selector is a wrapper for the `chelonia/kv/set` selector that uses
  // the contract queue and allows referring to keys by name, with default key
  // names set to `csk` and `cek` for signatures and encryption, respectively.
  // For most 'simple' use cases, this selector is a better choice than
  // `chelonia/kv/set`. However, the `chelonia/kv/set` primitive is needed if
  // the queueing logic needs to be more advanced, the key to use requires
  // custom logic or _if the `onconflict` callback also needs to be queued_.
  "chelonia/kv/queuedSet": ({ contractID, key, data, onconflict, ifMatch, encryptionKeyName = "cek", signingKeyName = "csk" }) => {
    return esm_default("chelonia/queueInvocation", contractID, () => {
      return esm_default("chelonia/kv/set", contractID, key, data, {
        ifMatch,
        encryptionKeyId: esm_default("chelonia/contract/currentKeyIdByName", contractID, encryptionKeyName),
        signingKeyId: esm_default("chelonia/contract/currentKeyIdByName", contractID, signingKeyName),
        onconflict
      });
    });
  }
});
init_encryptedData();
var m = /;\s*boundary=(?:"([0-9a-zA-Z'()+_,\-./:=? ]{0,69}[0-9a-zA-Z'()+_,\-./:=?])"|([0-9a-zA-Z'+_\-.]{0,69}[0-9a-zA-Z'+_\-.]))/;
var M = (a) => new ReadableStream({ pull(r) {
  if (ArrayBuffer.isView(a)) r.enqueue(a.buffer.slice(a.byteOffset, a.byteOffset + a.byteLength));
  else if (a instanceof ArrayBuffer) r.enqueue(a);
  else throw new TypeError("Expected ArrayBuffer or an ArrayBuffer view.");
  r.close();
} });
var u = M;
var T = /;\s*boundary=(?:"([^"]+)"|([^;",]+))/;
var h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_-.";
var A = () => {
  let a = new Uint8Array(24);
  return globalThis.crypto.getRandomValues(a), Array.from(a).map((s) => h[s % h.length]).join("");
};
var i = { preventClose: true };
async function* g(a, s, r) {
  let d = new TextEncoder(), y = d.encode(`\r
--${a}`);
  if (Array.isArray(s) && s.length < 1) {
    await r.abort(Error("At least one part is required"));
    return;
  }
  let l = 0;
  for await (let e2 of s) {
    l++;
    let n, t;
    if (!e2.body && e2.parts) if (t = e2.headers.get("content-type"), !t) n = A(), t = `multipart/mixed; boundary="${n}"`;
    else if (!t.startsWith("multipart/") || !T.test(t)) {
      await r.abort(Error("Invalid multipart content type: " + t));
      return;
    } else {
      let o2 = t.match(m);
      (!o2 || !(n = o2[1] || o2[2])) && (n = A(), t = t.replace(T, `; boundary="${n}"`));
    }
    await u(y).pipeTo(r, i), yield;
    {
      let o2 = [""];
      if (t) {
        let p = false;
        e2.headers.forEach((f, c) => {
          c !== "content-type" ? o2.push(`${c}: ${f}`) : (p = true, o2.push(`${c}: ${t}`));
        }), p || o2.push(`content-type: ${t}`);
      } else e2.headers.forEach((p, f) => {
        o2.push(`${f}: ${p}`);
      });
      e2.parts || !e2.body ? o2.push("") : o2.push("", "");
      let B3 = d.encode(o2.join(`\r
`));
      o2.length = 0, await u(B3).pipeTo(r, i), yield;
    }
    if (e2.body) {
      if (e2.body instanceof ArrayBuffer || ArrayBuffer.isView(e2.body)) await u(e2.body).pipeTo(r, i);
      else if (e2.body instanceof Blob) await e2.body.stream().pipeTo(r, i);
      else if (e2.body instanceof ReadableStream) await e2.body.pipeTo(r, i);
      else {
        await r.abort(Error("Invalid body type"));
        return;
      }
      yield;
    } else if (e2.parts) {
      if (!n) {
        await r.abort(Error("Runtime exception: undefined part boundary"));
        return;
      }
      yield* g(n, e2.parts, r), yield;
    }
  }
  if (!l) {
    await r.abort(Error("At least one part is required"));
    return;
  }
  let b = d.encode(`\r
--${a}--`);
  await u(b).pipeTo(r, i);
}
var w = (a, s) => {
  let r = new TransformStream(), d = g(a, s, r.writable), y = false, l = r.readable.getReader();
  return new ReadableStream({ start(e2) {
    (async () => {
      for (; ; ) try {
        let n = await l.read();
        if (n.done) {
          let t = new Uint8Array([13, 10]);
          e2.enqueue(t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)), e2.close();
          return;
        }
        e2.enqueue(n.value);
      } catch (n) {
        e2.error(n);
        return;
      }
    })().catch(() => {
    });
  }, async pull() {
    if (y) return;
    (await d.next()).done && (y = true, await r.writable.close());
  } });
};
var x = w;
var v = async (n, T2, w3, L) => {
  let u2 = await globalThis.crypto.subtle.importKey("raw", T2, "HKDF", false, ["deriveKey", "deriveBits"]), d = await globalThis.crypto.subtle.deriveKey({ name: "HKDF", hash: "SHA-256", info: n.cek_info, salt: w3 }, u2, n.params, false, L), A2 = await globalThis.crypto.subtle.deriveBits({ name: "HKDF", hash: "SHA-256", info: n.nonce_info, salt: w3 }, u2, n.nonce_length << 3);
  return [d, function* () {
    let s = new ArrayBuffer(n.nonce_length), e2 = new DataView(s), y = new Uint8Array(s), i2 = new Uint8Array(A2), b = 4294967295, f = (n.nonce_length >> 2) - 1, l = new Array(f).fill(0);
    for (; ; ) {
      for (let a = 0; a <= b; a++) {
        e2.setUint32(e2.byteLength - 4, a, false);
        let t = new Uint8Array(n.nonce_length);
        for (let r = 0; r < t.length; r++) t[r] = i2[r] ^ y[r];
        yield t;
      }
      for (let a = 0; a < f; a++) {
        if (a === f - 1 && l[a] === b) throw new RangeError("Maximum number of segments exceeded");
        if (l[a] = (l[a] + 1) % (b + 1), e2.setUint32(e2.byteLength - 4 * (a + 2), l[a], false), l[a] !== 0) break;
      }
    }
  }()];
};
var I = v;
var B = (n) => ArrayBuffer.isView(n) ? new Uint8Array(n.buffer).subarray(n.byteOffset, n.byteOffset + n.byteLength) : new Uint8Array(n);
var m2 = B;
var o = { salt: {}, recordSize: {}, keyIdLen: {}, keyId: {}, payload: {}, done: {} };
var R = (n, T2, w3, L) => {
  let u2 = new Uint8Array(16), d, A2, E2, s = 0, e2 = 0, y = new Uint8Array(256), i2 = o.salt, b = new TransformStream({ start: () => {
  }, transform: async (f, l) => {
    let a = m2(f), t = 0;
    for (; t < f.byteLength; ) switch (i2) {
      case o.salt: {
        let r = a.subarray(t, t + u2.byteLength - e2);
        if (u2.set(r, e2), e2 += r.byteLength, t += r.byteLength, e2 === u2.byteLength) {
          e2 = 0, i2 = o.recordSize;
          continue;
        }
        break;
      }
      case o.recordSize: {
        let r = a.subarray(t, t + 4 - e2), g2 = new ArrayBuffer(4), h2 = new Uint8Array(g2), c = new DataView(g2);
        if (h2.set(r, e2), s |= c.getUint32(0, false), e2 += r.byteLength, t += r.byteLength, e2 === 4) {
          if (s <= n.tag_length + 1 || s > (L == null ? 4294967295 : Math.min(4294967295, L))) throw new RangeError("Invalid record size: " + s);
          e2 = 0, i2 = o.keyIdLen;
          continue;
        }
        break;
      }
      case o.keyIdLen: {
        y[0] = a[t++], i2 = o.keyId;
        continue;
      }
      case o.keyId: {
        let r = a.subarray(t, t + y[0] - e2);
        if (y.set(r, 1 + e2), e2 += r.byteLength, t += r.byteLength, e2 === y[0]) {
          let g2 = await w3(y.subarray(1, 1 + y[0]));
          w3 = void 0;
          let h2 = await I(n, g2, u2, ["decrypt"]);
          A2 = h2[0], E2 = h2[1], d = new Uint8Array(s), e2 = 0, i2 = o.payload;
          continue;
        }
        break;
      }
      case o.payload: {
        let r = a.subarray(t, t + s - e2);
        if (d.set(r, e2), e2 += r.byteLength, t += r.byteLength, e2 === s) {
          let h2 = E2.next().value, c = m2(await globalThis.crypto.subtle.decrypt({ name: n.params.name, iv: h2, tagLength: n.tag_length << 3 }, A2, d.subarray(0, e2))), p = c.byteLength - 1;
          for (; p > 0 && c[p] === 0; p--) ;
          if (c[p] === 2) {
            if (t !== f.byteLength) throw new Error("Unexpected terminal padding delimiter");
            i2 = o.done;
          } else if (c[p] !== 1) throw new Error("Invalid padding delimiter");
          l.enqueue(c.buffer.slice(0, p)), c.fill(0), e2 = 0;
          continue;
        }
        break;
      }
      default:
        throw new Error("Invalid state");
    }
  }, flush: async (f) => {
    switch (i2) {
      case o.done:
        return;
      case o.payload: {
        if (e2 < 1 + n.tag_length) throw new Error("Unexpected end of data");
        let a = E2.next().value, t = m2(await globalThis.crypto.subtle.decrypt({ name: n.params.name, iv: a, tagLength: n.tag_length << 3 }, A2, d.subarray(0, e2))), r = t.byteLength - 1;
        for (; r > 0 && t[r] === 0; r--) ;
        if (t[r] !== 2) throw new Error("Unexpected non-terminal padding delimiter");
        f.enqueue(t.buffer.slice(0, r)), t.fill(0);
        return;
      }
      default:
        throw new Error("Invalid state");
    }
  } });
  return T2.pipeThrough(b), b.readable;
};
var S = R;
var e = { params: { name: "AES-GCM", length: 256 }, get cek_info() {
  return new Uint8Array([67, 111, 110, 116, 101, 110, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103, 58, 32, 97, 101, 115, 50, 53, 54, 103, 99, 109, 0]);
}, get nonce_info() {
  return new Uint8Array([67, 111, 110, 116, 101, 110, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103, 58, 32, 110, 111, 110, 99, 101, 0]);
}, block_size: 16, tag_length: 16, nonce_length: 12 };
var R2 = async (e2, b, f, i2) => {
  let A2 = await globalThis.crypto.subtle.importKey("raw", b, "HKDF", false, ["deriveKey", "deriveBits"]), y = await globalThis.crypto.subtle.deriveKey({ name: "HKDF", hash: "SHA-256", info: e2.cek_info, salt: f }, A2, e2.params, false, i2), u2 = await globalThis.crypto.subtle.deriveBits({ name: "HKDF", hash: "SHA-256", info: e2.nonce_info, salt: f }, A2, e2.nonce_length << 3);
  return [y, function* () {
    let L = new ArrayBuffer(e2.nonce_length), c = new DataView(L), h2 = new Uint8Array(L), a = new Uint8Array(u2), g2 = 4294967295, o2 = (e2.nonce_length >> 2) - 1, s = new Array(o2).fill(0);
    for (; ; ) {
      for (let t = 0; t <= g2; t++) {
        c.setUint32(c.byteLength - 4, t, false);
        let n = new Uint8Array(e2.nonce_length);
        for (let r = 0; r < n.length; r++) n[r] = a[r] ^ h2[r];
        yield n;
      }
      for (let t = 0; t < o2; t++) {
        if (t === o2 - 1 && s[t] === g2) throw new RangeError("Maximum number of segments exceeded");
        if (s[t] = (s[t] + 1) % (g2 + 1), c.setUint32(c.byteLength - 4 * (t + 2), s[t], false), s[t] !== 0) break;
      }
    }
  }()];
};
var E = R2;
var B2 = (e2) => ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer).subarray(e2.byteOffset, e2.byteOffset + e2.byteLength) : new Uint8Array(e2);
var w2 = B2;
var N = () => {
  let e2 = new Uint8Array(16);
  return globalThis.crypto.getRandomValues(e2), e2;
};
var U = async (e2, b, f, i2, A2, y) => {
  if (f <= e2.tag_length + 1 || f > 4294967295) throw new RangeError("Invalid record size: " + f);
  if (i2.byteLength > 255) throw new RangeError("Key ID too long");
  if (y && y.byteLength !== 16) throw new RangeError("Invald salt length: " + y.byteLength);
  let u2 = f - e2.tag_length - 1, l = y ? w2(y) : N(), [L, c] = await E(e2, A2, l, ["encrypt"]);
  A2 = void 0;
  let h2 = new Uint8Array(u2), a = 0, g2 = new TransformStream({ start: (o2) => {
    let s = l.byteLength + 4 + 1 + i2.byteLength, t = new ArrayBuffer(s);
    new Uint8Array(t, 0, l.byteLength).set(l);
    let r = new DataView(t, l.byteLength, 5);
    r.setUint32(0, f, false), r.setUint8(4, i2.byteLength);
    let d = new Uint8Array(t, l.byteLength + 4 + 1, i2.byteLength), m3 = w2(i2);
    d.set(m3), o2.enqueue(t);
  }, transform: async (o2, s) => {
    let t = w2(o2), n = 0;
    for (; n < o2.byteLength; ) {
      let r = t.subarray(n, n + u2 - a);
      if (h2.set(r, a), a += r.byteLength, n += r.byteLength, a === u2) {
        let m3 = c.next().value, p = new Uint8Array(u2 + 1);
        p.set(h2.subarray(0, a)), p[a] = 1;
        let T2 = await globalThis.crypto.subtle.encrypt({ name: e2.params.name, iv: m3, tagLength: e2.tag_length << 3 }, L, p);
        s.enqueue(T2), a = 0;
      }
    }
  }, flush: async (o2) => {
    let t = c.next().value, n = new Uint8Array(a + 1);
    n.set(h2.subarray(0, a)), n[a] = 2;
    let r = await globalThis.crypto.subtle.encrypt({ name: e2.params.name, iv: t, tagLength: e2.tag_length << 3 }, L, n);
    o2.enqueue(r), h2.fill(0), n.fill(0);
  } });
  return b.pipeThrough(g2), g2.readable;
};
var K = U;
init_esm6();
init_bytes();
init_esm();
init_esm4();
init_functions();
init_esm6();
init_esm();
init_esm4();
init_SPMessage();
init_esm7();
var wm = /* @__PURE__ */ new WeakMap();
var Secret = class {
  static [serdesDeserializeSymbol](secret) {
    return new this(secret);
  }
  static [serdesSerializeSymbol](secret) {
    return wm.get(secret);
  }
  static get [serdesTagSymbol]() {
    return "__chelonia_Secret";
  }
  constructor(value) {
    wm.set(this, value);
  }
  valueOf() {
    return wm.get(this);
  }
};
var INVITE_STATUS = {
  REVOKED: "revoked",
  VALID: "valid",
  USED: "used"
};
init_errors();
init_functions();
init_signedData();
var MAX_EVENTS_AFTER = Number.parseInt(process.env.MAX_EVENTS_AFTER || "", 10) || Infinity;
var copiedExistingData = Symbol("copiedExistingData");
var findKeyIdByName = (state, name) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).find((k) => k.name === name && k._notAfterHeight == null)?.id;
var findForeignKeysByContractID = (state, contractID) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => k._notAfterHeight == null && k.foreignKey?.includes(contractID)).map((k) => k.id);
var findRevokedKeyIdsByName = (state, name) => state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys || {}).filter((k) => k.name === name && k._notAfterHeight != null).map((k) => k.id);
var findSuitableSecretKeyId = (state, permissions, purposes, ringLevel, allowedActions) => {
  return state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => {
    return k._notAfterHeight == null && k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY) && esm_default("chelonia/haveSecretKey", k.id) && (Array.isArray(permissions) ? permissions.reduce((acc, permission) => acc && (k.permissions === "*" || k.permissions.includes(permission)), true) : permissions === k.permissions) && purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true) && (Array.isArray(allowedActions) ? allowedActions.reduce((acc, action) => acc && (k.allowedActions === "*" || !!k.allowedActions?.includes(action)), true) : allowedActions ? allowedActions === k.allowedActions : true);
  }).sort((a, b) => b.ringLevel - a.ringLevel)[0]?.id;
};
var findSuitablePublicKeyIds = (state, permissions, purposes, ringLevel) => {
  return state._vm?.authorizedKeys && Object.values(state._vm.authorizedKeys).filter((k) => k._notAfterHeight == null && k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY) && (Array.isArray(permissions) ? permissions.reduce((acc, permission) => acc && (k.permissions === "*" || k.permissions.includes(permission)), true) : permissions === k.permissions) && purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true)).sort((a, b) => b.ringLevel - a.ringLevel).map((k) => k.id);
};
var validateActionPermissions = (msg, signingKey, state, opT, opV) => {
  const data = isSignedData(opV) ? opV.valueOf() : opV;
  if (signingKey.allowedActions !== "*" && (!Array.isArray(signingKey.allowedActions) || !signingKey.allowedActions.includes(data.action))) {
    logEvtError(msg, `Signing key ${signingKey.id} is not allowed for action ${data.action}`);
    return false;
  }
  if (isSignedData(opV)) {
    const s = opV;
    const innerSigningKey = state._vm?.authorizedKeys?.[s.signingKeyId];
    if (!innerSigningKey && msg._direction === "outgoing")
      return true;
    if (!innerSigningKey || !Array.isArray(innerSigningKey.purpose) || !innerSigningKey.purpose.includes("sig") || innerSigningKey.permissions !== "*" && (!Array.isArray(innerSigningKey.permissions) || !innerSigningKey.permissions.includes(opT + "#inner"))) {
      logEvtError(msg, `Signing key ${s.signingKeyId} is missing permissions for operation ${opT}`);
      return false;
    }
    if (innerSigningKey.allowedActions !== "*" && (!Array.isArray(innerSigningKey.allowedActions) || !innerSigningKey.allowedActions.includes(data.action + "#inner"))) {
      logEvtError(msg, `Signing key ${innerSigningKey.id} is not allowed for action ${data.action}`);
      return false;
    }
  }
  return true;
};
var validateKeyPermissions = (msg, config, state, signingKeyId, opT, opV) => {
  const signingKey = state._vm?.authorizedKeys?.[signingKeyId];
  if (!signingKey || !Array.isArray(signingKey.purpose) || !signingKey.purpose.includes("sig") || signingKey.permissions !== "*" && (!Array.isArray(signingKey.permissions) || !signingKey.permissions.includes(opT))) {
    logEvtError(msg, `Signing key ${signingKeyId} is missing permissions for operation ${opT}`);
    return false;
  }
  if (opT === SPMessage.OP_ACTION_UNENCRYPTED && !validateActionPermissions(msg, signingKey, state, opT, opV)) {
    return false;
  }
  if (!config.skipActionProcessing && opT === SPMessage.OP_ACTION_ENCRYPTED && !validateActionPermissions(msg, signingKey, state, opT, opV.valueOf())) {
    return false;
  }
  return true;
};
var validateKeyAddPermissions = function(contractID, signingKey, state, v2, skipPrivateCheck) {
  const signingKeyPermissions = Array.isArray(signingKey.permissions) ? new Set(signingKey.permissions) : signingKey.permissions;
  const signingKeyAllowedActions = Array.isArray(signingKey.allowedActions) ? new Set(signingKey.allowedActions) : signingKey.allowedActions;
  if (!state._vm?.authorizedKeys?.[signingKey.id]) {
    throw new Error("Singing key for OP_KEY_ADD or OP_KEY_UPDATE must exist in _vm.authorizedKeys. contractID=" + contractID + " signingKeyId=" + signingKey.id);
  }
  const localSigningKey = state._vm.authorizedKeys[signingKey.id];
  v2.forEach((wk) => {
    const data = this.config.unwrapMaybeEncryptedData(wk);
    if (!data)
      return;
    const k = data.data;
    if (!skipPrivateCheck && signingKey._private && !data.encryptionKeyId) {
      throw new Error("Signing key is private but it tried adding a public key");
    }
    if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {
      throw new Error("Signing key has ringLevel " + localSigningKey.ringLevel + " but attempted to add or update a key with ringLevel " + k.ringLevel);
    }
    if (signingKeyPermissions !== "*") {
      if (!Array.isArray(k.permissions) || !k.permissions.reduce((acc, cv) => acc && signingKeyPermissions.has(cv), true)) {
        throw new Error("Unable to add or update a key with more permissions than the signing key. signingKey permissions: " + String(signingKey?.permissions) + "; key add permissions: " + String(k.permissions));
      }
    }
    if (signingKeyAllowedActions !== "*" && k.allowedActions) {
      if (!signingKeyAllowedActions || !Array.isArray(k.allowedActions) || !k.allowedActions.reduce((acc, cv) => acc && signingKeyAllowedActions.has(cv), true)) {
        throw new Error("Unable to add or update a key with more allowed actions than the signing key. signingKey allowed actions: " + String(signingKey?.allowedActions) + "; key add allowed actions: " + String(k.allowedActions));
      }
    }
  });
};
var validateKeyDelPermissions = function(contractID, signingKey, state, v2) {
  if (!state._vm?.authorizedKeys?.[signingKey.id]) {
    throw new Error("Singing key for OP_KEY_DEL must exist in _vm.authorizedKeys. contractID=" + contractID + " signingKeyId=" + signingKey.id);
  }
  const localSigningKey = state._vm.authorizedKeys[signingKey.id];
  v2.forEach((wid) => {
    const data = this.config.unwrapMaybeEncryptedData(wid);
    if (!data)
      return;
    const id = data.data;
    const k = state._vm.authorizedKeys[id];
    if (!k) {
      throw new Error("Nonexisting key ID " + id);
    }
    if (signingKey._private) {
      throw new Error("Signing key is private");
    }
    if (!k._private !== !data.encryptionKeyId) {
      throw new Error("_private attribute must be preserved");
    }
    if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {
      throw new Error("Signing key has ringLevel " + localSigningKey.ringLevel + " but attempted to remove a key with ringLevel " + k.ringLevel);
    }
  });
};
var validateKeyUpdatePermissions = function(contractID, signingKey, state, v2) {
  const updatedMap = /* @__PURE__ */ Object.create(null);
  const keys = v2.map((wuk) => {
    const data = this.config.unwrapMaybeEncryptedData(wuk);
    if (!data)
      return void 0;
    const uk = data.data;
    const existingKey = state._vm.authorizedKeys[uk.oldKeyId];
    if (!existingKey) {
      throw new ChelErrorWarning("Missing old key ID " + uk.oldKeyId);
    }
    if (!existingKey._private !== !data.encryptionKeyId) {
      throw new Error("_private attribute must be preserved");
    }
    if (uk.name !== existingKey.name) {
      throw new Error("Name cannot be updated");
    }
    if (!uk.id !== !uk.data) {
      throw new Error("Both or none of the id and data attributes must be provided. Old key ID: " + uk.oldKeyId);
    }
    if (uk.data && existingKey.meta?.private && !uk.meta?.private) {
      throw new Error("Missing private key. Old key ID: " + uk.oldKeyId);
    }
    if (uk.id && uk.id !== uk.oldKeyId) {
      updatedMap[uk.id] = uk.oldKeyId;
    }
    const updatedKey = omit(existingKey, [
      "_notAfterHeight",
      "_notBeforeHeight"
    ]);
    if (uk.permissions) {
      updatedKey.permissions = uk.permissions;
    }
    if (uk.allowedActions) {
      updatedKey.allowedActions = uk.allowedActions;
    }
    if (uk.purpose) {
      updatedKey.purpose = uk.purpose;
    }
    if (uk.meta) {
      updatedKey.meta = uk.meta;
    } else if (updatedKey.meta) {
      Object.defineProperty(updatedKey.meta, copiedExistingData, { value: true });
    }
    if (uk.id) {
      updatedKey.id = uk.id;
    }
    if (uk.data) {
      updatedKey.data = uk.data;
    }
    return updatedKey;
  }).filter(Boolean);
  validateKeyAddPermissions.call(this, contractID, signingKey, state, keys, true);
  return [keys, updatedMap];
};
var keyAdditionProcessor = function(_msg, hash2, keys, state, contractID, _signingKey, internalSideEffectStack) {
  const decryptedKeys = [];
  const keysToPersist = [];
  const storeSecretKey = (key, decryptedKey) => {
    const decryptedDeserializedKey = deserializeKey(decryptedKey);
    const transient = !!key.meta?.private?.transient;
    esm_default("chelonia/storeSecretKeys", new Secret([
      {
        key: decryptedDeserializedKey,
        // We always set this to true because this could be done from
        // an outgoing message
        transient: true
      }
    ]));
    if (!transient) {
      keysToPersist.push({ key: decryptedDeserializedKey, transient });
    }
  };
  for (const wkey of keys) {
    const data = this.config.unwrapMaybeEncryptedData(wkey);
    if (!data)
      continue;
    const key = data.data;
    let decryptedKey;
    if (key.meta?.private?.content && !has(key.meta, copiedExistingData)) {
      if (key.id && !esm_default("chelonia/haveSecretKey", key.id, !key.meta.private.transient)) {
        const decryptedKeyResult = this.config.unwrapMaybeEncryptedData(key.meta.private.content);
        if (decryptedKeyResult) {
          if (decryptedKeyResult.encryptionKeyId == null) {
            throw new Error("Expected encrypted data but got unencrypted data for key with ID: " + key.id);
          }
          decryptedKey = decryptedKeyResult.data;
          decryptedKeys.push([key.id, decryptedKey]);
          storeSecretKey(key, decryptedKey);
        }
      }
    }
    if (key.name === "#sak") {
      if (data.encryptionKeyId) {
        throw new Error("#sak may not be encrypted");
      }
      if (key.permissions && (!Array.isArray(key.permissions) || key.permissions.length !== 0)) {
        throw new Error("#sak may not have permissions");
      }
      if (!Array.isArray(key.purpose) || key.purpose.length !== 1 || key.purpose[0] !== "sak") {
        throw new Error("#sak must have exactly one purpose: 'sak'");
      }
      if (key.ringLevel !== 0) {
        throw new Error("#sak must have ringLevel 0");
      }
    }
    if (key.name.startsWith("#inviteKey-")) {
      if (!state._vm.invites)
        state._vm.invites = /* @__PURE__ */ Object.create(null);
      const inviteSecret = decryptedKey || (has(this.transientSecretKeys, key.id) ? serializeKey(this.transientSecretKeys[key.id], true) : void 0);
      state._vm.invites[key.id] = {
        status: INVITE_STATUS.VALID,
        initialQuantity: key.meta.quantity,
        quantity: key.meta.quantity,
        expires: key.meta.expires,
        inviteSecret,
        responses: []
      };
    }
    if (key.meta?.keyRequest?.contractID && findSuitableSecretKeyId(state, [SPMessage.OP_KEY_ADD], ["sig"])) {
      const data2 = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.contractID);
      if (data2 && internalSideEffectStack) {
        const keyRequestContractID = data2.data;
        const reference = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.reference);
        internalSideEffectStack.push(() => {
          esm_default("chelonia/private/queueEvent", keyRequestContractID, () => {
            const rootState = esm_default(this.config.stateSelector);
            const originatingContractState = rootState[contractID];
            if (esm_default("chelonia/contract/hasKeyShareBeenRespondedBy", originatingContractState, keyRequestContractID, reference)) {
              return;
            }
            if (!has(rootState, keyRequestContractID)) {
              this.config.reactiveSet(rootState, keyRequestContractID, /* @__PURE__ */ Object.create(null));
            }
            const targetState = rootState[keyRequestContractID];
            if (!targetState._volatile) {
              this.config.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
            }
            if (!targetState._volatile.pendingKeyRequests) {
              this.config.reactiveSet(rootState[keyRequestContractID]._volatile, "pendingKeyRequests", []);
            }
            if (targetState._volatile.pendingKeyRequests.some((pkr) => {
              return pkr && pkr.contractID === contractID && pkr.hash === hash2;
            })) {
              return;
            }
            targetState._volatile.pendingKeyRequests.push({
              contractID,
              name: key.name,
              hash: hash2,
              reference: reference?.data
            });
            this.setPostSyncOp(contractID, "pending-keys-for-" + keyRequestContractID, [
              "okTurtles.events/emit",
              CONTRACT_IS_PENDING_KEY_REQUESTS,
              { contractID: keyRequestContractID }
            ]);
          }).catch((e2) => {
            console.error("Error while setting or updating pendingKeyRequests", { contractID, keyRequestContractID, reference }, e2);
          });
        });
      }
    }
  }
  if (keysToPersist.length) {
    internalSideEffectStack?.push(() => {
      esm_default("chelonia/storeSecretKeys", new Secret(keysToPersist));
    });
  }
  internalSideEffectStack?.push(() => subscribeToForeignKeyContracts.call(this, contractID, state));
};
var subscribeToForeignKeyContracts = function(contractID, state) {
  try {
    Object.values(state._vm.authorizedKeys).filter((key) => !!key.foreignKey && findKeyIdByName(state, key.name) != null).forEach((key) => {
      const foreignKey = String(key.foreignKey);
      const fkUrl = new URL(foreignKey);
      const foreignContract = fkUrl.pathname;
      const foreignKeyName = fkUrl.searchParams.get("keyName");
      if (!foreignContract || !foreignKeyName) {
        console.warn("Invalid foreign key: missing contract or key name", {
          contractID,
          keyId: key.id
        });
        return;
      }
      const rootState = esm_default(this.config.stateSelector);
      const signingKey = findSuitableSecretKeyId(state, [SPMessage.OP_KEY_DEL], ["sig"], key.ringLevel);
      const canMirrorOperations = !!signingKey;
      if (!canMirrorOperations)
        return;
      if (Array.isArray(rootState?.[foreignContract]?._volatile?.watch)) {
        if (rootState[foreignContract]._volatile.watch.find((v2) => v2[0] === key.name && v2[1] === contractID)) {
          return;
        }
      }
      if (!has(state._vm, "pendingWatch")) {
        this.config.reactiveSet(state._vm, "pendingWatch", /* @__PURE__ */ Object.create(null));
      }
      if (!has(state._vm.pendingWatch, foreignContract)) {
        this.config.reactiveSet(state._vm.pendingWatch, foreignContract, []);
      }
      if (!state._vm.pendingWatch[foreignContract].find(([n]) => n === foreignKeyName)) {
        state._vm.pendingWatch[foreignContract].push([foreignKeyName, key.id]);
      }
      this.setPostSyncOp(contractID, `watchForeignKeys-${contractID}`, [
        "chelonia/private/watchForeignKeys",
        contractID
      ]);
    });
  } catch (e2) {
    console.warn("Error at subscribeToForeignKeyContracts: " + (e2.message || e2));
  }
};
var recreateEvent = (entry, state, contractsState, disableAutoDedup) => {
  const { HEAD: previousHEAD, height: previousHeight, previousKeyOp } = contractsState || {};
  if (!previousHEAD) {
    throw new Error("recreateEvent: Giving up because the contract has been removed");
  }
  const head = entry.head();
  const [opT, rawOpV] = entry.rawOp();
  const recreateOperation = (opT2, rawOpV2) => {
    const opV = rawOpV2.valueOf();
    const recreateOperationInternal = (opT3, opV2) => {
      let newOpV2;
      if (opT3 === SPMessage.OP_KEY_ADD) {
        if (!Array.isArray(opV2))
          throw new Error("Invalid message format");
        newOpV2 = opV2.filter((k) => {
          const kId = k.valueOf().id;
          return !has(state._vm.authorizedKeys, kId) || state._vm.authorizedKeys[kId]._notAfterHeight != null;
        });
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_KEY_ADD", { head });
        } else if (newOpV2.length === opV2.length) {
          return opV2;
        }
      } else if (opT3 === SPMessage.OP_KEY_DEL) {
        if (!Array.isArray(opV2))
          throw new Error("Invalid message format");
        newOpV2 = opV2.filter((keyId2) => {
          const kId = Object(keyId2).valueOf();
          return has(state._vm.authorizedKeys, kId) && state._vm.authorizedKeys[kId]._notAfterHeight == null;
        });
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_KEY_DEL", { head });
        } else if (newOpV2.length === opV2.length) {
          return opV2;
        }
      } else if (opT3 === SPMessage.OP_KEY_UPDATE) {
        if (!Array.isArray(opV2))
          throw new Error("Invalid message format");
        newOpV2 = opV2.filter((k) => {
          const oKId = k.valueOf().oldKeyId;
          const nKId = k.valueOf().id;
          return nKId == null || has(state._vm.authorizedKeys, oKId) && state._vm.authorizedKeys[oKId]._notAfterHeight == null;
        });
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_KEY_UPDATE", { head });
        } else if (newOpV2.length === opV2.length) {
          return opV2;
        }
      } else if (opT3 === SPMessage.OP_ATOMIC) {
        if (!Array.isArray(opV2))
          throw new Error("Invalid message format");
        newOpV2 = opV2.map(([t, v2]) => [t, recreateOperationInternal(t, v2)]).filter(([, v2]) => !!v2);
        if (newOpV2.length === 0) {
          console.info("Omitting empty OP_ATOMIC", { head });
        } else if (newOpV2.length === opV2.length && newOpV2.reduce((acc, cv, i2) => acc && cv === opV2[i2], true)) {
          return opV2;
        } else {
          return newOpV2;
        }
      } else {
        return opV2;
      }
    };
    const newOpV = recreateOperationInternal(opT2, opV);
    if (newOpV === opV) {
      return rawOpV2;
    } else if (newOpV === void 0) {
      return;
    }
    if (typeof rawOpV2.recreate !== "function") {
      throw new Error("Unable to recreate operation");
    }
    return rawOpV2.recreate(newOpV);
  };
  const newRawOpV = disableAutoDedup ? rawOpV : recreateOperation(opT, rawOpV);
  if (!newRawOpV)
    return;
  const newOp = [opT, newRawOpV];
  entry = SPMessage.cloneWith(head, newOp, {
    previousKeyOp,
    previousHEAD,
    height: previousHeight + 1
  });
  return entry;
};
var getContractIDfromKeyId = (contractID, signingKeyId, state) => {
  if (!signingKeyId)
    return;
  return signingKeyId && state._vm?.authorizedKeys?.[signingKeyId]?.foreignKey ? new URL(state._vm.authorizedKeys[signingKeyId].foreignKey).pathname : contractID;
};
function eventsAfter(contractID, { sinceHeight, limit, sinceHash, stream = true }) {
  if (!contractID) {
    throw new Error("Missing contract ID");
  }
  let lastUrl;
  const fetchEventsStreamReader = async () => {
    requestLimit = Math.min(limit ?? MAX_EVENTS_AFTER, remainingEvents);
    lastUrl = `${this.config.connectionURL}/eventsAfter/${contractID}/${sinceHeight}${Number.isInteger(requestLimit) ? `/${requestLimit}` : ""}`;
    const eventsResponse = await this.config.fetch(lastUrl, { signal });
    if (!eventsResponse.ok) {
      const msg = `${eventsResponse.status}: ${eventsResponse.statusText}`;
      if (eventsResponse.status === 404 || eventsResponse.status === 410) {
        throw new ChelErrorResourceGone(msg, { cause: eventsResponse.status });
      }
      throw new ChelErrorUnexpectedHttpResponseCode(msg, { cause: eventsResponse.status });
    }
    if (!eventsResponse.body)
      throw new Error("Missing body");
    latestHeight = parseInt(eventsResponse.headers.get("shelter-headinfo-height"), 10);
    if (!Number.isSafeInteger(latestHeight))
      throw new Error("Invalid latest height");
    requestCount++;
    return eventsResponse.body.getReader();
  };
  if (!Number.isSafeInteger(sinceHeight) || sinceHeight < 0) {
    throw new TypeError("Invalid since height value. Expected positive integer.");
  }
  const signal = this.abortController.signal;
  let requestCount = 0;
  let remainingEvents = limit ?? Number.POSITIVE_INFINITY;
  let eventsStreamReader;
  let latestHeight;
  let state = "fetch";
  let requestLimit;
  let count;
  let buffer = "";
  let currentEvent;
  const s = new ReadableStream({
    // The pull function is called whenever the internal buffer of the stream
    // becomes empty and needs more data.
    async pull(controller) {
      try {
        for (; ; ) {
          switch (state) {
            // When in 'fetch' state, initiate a new fetch request to obtain a
            // stream reader for events.
            case "fetch": {
              eventsStreamReader = await fetchEventsStreamReader();
              state = "read-new-response";
              count = 0;
              break;
            }
            case "read-eos":
            // End of stream case
            case "read-new-response":
            // Just started reading a new response
            case "read": {
              const { done, value } = await eventsStreamReader.read();
              if (done) {
                if (remainingEvents === 0 || sinceHeight >= latestHeight) {
                  controller.close();
                  return;
                } else if (state === "read-new-response" || buffer) {
                  throw new Error("Invalid response: done too early");
                } else {
                  state = "fetch";
                  break;
                }
              }
              if (!value) {
                throw new Error("Invalid response: missing body");
              }
              buffer = buffer + Buffer3.from(value).toString().trim();
              if (!buffer)
                break;
              if (state === "read-new-response") {
                if (buffer[0] !== "[") {
                  throw new Error("Invalid response: no array start delimiter");
                }
                buffer = buffer.slice(1);
              } else if (state === "read-eos") {
                throw new Error("Invalid data at the end of response");
              }
              state = "events";
              break;
            }
            case "events": {
              const nextIdx = buffer.search(/(?<=\s*)[,\]]/);
              if (nextIdx < 0) {
                state = "read";
                break;
              }
              let enqueued = false;
              try {
                const eventValue = buffer.slice(0, nextIdx).trim();
                if (eventValue) {
                  if (count === requestLimit) {
                    throw new Error("Received too many events");
                  }
                  currentEvent = JSON.parse(b64ToStr(JSON.parse(eventValue))).message;
                  if (count === 0) {
                    const hash2 = SPMessage.deserializeHEAD(currentEvent).hash;
                    const height = SPMessage.deserializeHEAD(currentEvent).head.height;
                    if (height !== sinceHeight || sinceHash && sinceHash !== hash2) {
                      if (height === sinceHeight && sinceHash && sinceHash !== hash2) {
                        throw new ChelErrorForkedChain(`Forked chain: hash(${hash2}) !== since(${sinceHash})`);
                      } else {
                        throw new Error(`Unexpected data: hash(${hash2}) !== since(${sinceHash || ""}) or height(${height}) !== since(${sinceHeight})`);
                      }
                    }
                  }
                  if (count++ !== 0 || requestCount !== 0) {
                    controller.enqueue(currentEvent);
                    enqueued = true;
                    remainingEvents--;
                  }
                }
                if (buffer[nextIdx] === "]") {
                  if (currentEvent) {
                    const deserialized = SPMessage.deserializeHEAD(currentEvent);
                    sinceHeight = deserialized.head.height;
                    sinceHash = deserialized.hash;
                    state = "read-eos";
                  } else {
                    state = "eod";
                  }
                  buffer = buffer.slice(nextIdx + 1).trim();
                } else if (currentEvent) {
                  buffer = buffer.slice(nextIdx + 1).trimStart();
                } else {
                  throw new Error("Missing end delimiter");
                }
                if (enqueued) {
                  return;
                }
              } catch (e2) {
                console.error("[chelonia] Error during event parsing", e2);
                throw e2;
              }
              break;
            }
            case "eod": {
              if (remainingEvents === 0 || sinceHeight >= latestHeight) {
                controller.close();
              } else {
                throw new Error("Unexpected end of data");
              }
              return;
            }
          }
        }
      } catch (e2) {
        console.error("[eventsAfter] Error", { lastUrl }, e2);
        eventsStreamReader?.cancel("Error during pull").catch((e22) => {
          console.error("Error canceling underlying event stream reader on error", e2, e22);
        });
        throw e2;
      }
    }
  });
  if (stream)
    return s;
  return collectEventStream(s);
}
function buildShelterAuthorizationHeader(contractID, state) {
  if (!state)
    state = esm_default(this.config.stateSelector)[contractID];
  const SAKid = findKeyIdByName(state, "#sak");
  if (!SAKid) {
    throw new Error(`Missing #sak in ${contractID}`);
  }
  const SAK = this.transientSecretKeys[SAKid];
  if (!SAK) {
    throw new Error(`Missing secret #sak (${SAKid}) in ${contractID}`);
  }
  const deserializedSAK = typeof SAK === "string" ? deserializeKey(SAK) : SAK;
  const nonceBytes = new Uint8Array(15);
  globalThis.crypto.getRandomValues(nonceBytes);
  const data = `${contractID} ${esm_default("chelonia/time")}.${Buffer3.from(nonceBytes).toString("base64")}`;
  return `shelter ${data}.${sign(deserializedSAK, data)}`;
}
var clearObject = (o2) => {
  Object.keys(o2).forEach((k) => delete o2[k]);
};
var reactiveClearObject = (o2, fn) => {
  Object.keys(o2).forEach((k) => fn(o2, k));
};
var checkCanBeGarbageCollected = function(id) {
  const rootState = esm_default(this.config.stateSelector);
  return (
    // Check persistent references
    (!has(rootState.contracts, id) || !rootState.contracts[id] || !has(rootState.contracts[id], "references")) && // Check ephemeral references
    !has(this.ephemeralReferenceCount, id) && // Check foreign keys (i.e., that no keys from this contract are being watched)
    (!has(rootState, id) || !has(rootState[id], "_volatile") || !has(rootState[id]._volatile, "watch") || rootState[id]._volatile.watch.length === 0 || rootState[id]._volatile.watch.filter(([, cID]) => this.subscriptionSet.has(cID)).length === 0)
  );
};
var collectEventStream = async (s) => {
  const reader = s.getReader();
  const r = [];
  for (; ; ) {
    const { done, value } = await reader.read();
    if (done)
      break;
    r.push(value);
  }
  return r;
};
var logEvtError = (msg, ...args) => {
  if (msg._direction === "outgoing") {
    console.warn(...args);
  } else {
    console.error(...args);
  }
};
var handleFetchResult = (type) => {
  return function(r) {
    if (!r.ok) {
      const msg = `${r.status}: ${r.statusText}`;
      if (r.status === 404 || r.status === 410) {
        throw new ChelErrorResourceGone(msg, { cause: r.status });
      }
      throw new ChelErrorUnexpectedHttpResponseCode(msg, { cause: r.status });
    }
    return r[type]();
  };
};
var supportsRequestStreams = typeof window !== "object" || (() => {
  let duplexAccessed = false;
  const hasContentType = new Request("", {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("content-type");
  return duplexAccessed && !hasContentType;
})();
var streamToUint8Array = async (s) => {
  const reader = s.getReader();
  const chunks = [];
  let length2 = 0;
  for (; ; ) {
    const result = await reader.read();
    if (result.done)
      break;
    chunks.push(coerce(result.value));
    length2 += result.value.byteLength;
  }
  const body = new Uint8Array(length2);
  chunks.reduce((offset, chunk) => {
    body.set(chunk, offset);
    return offset + chunk.byteLength;
  }, 0);
  return body;
};
var ArrayBufferToUint8ArrayStream = async function(connectionURL, s) {
  if (supportsRequestStreams === true) {
    await this.config.fetch(`${connectionURL}/streams-test`, {
      method: "POST",
      body: new ReadableStream({
        start(c) {
          c.enqueue(Buffer4.from("ok"));
          c.close();
        }
      }),
      duplex: "half"
    }).then((r) => {
      if (!r.ok)
        throw new Error("Unexpected response");
      supportsRequestStreams = 2;
    }).catch(() => {
      console.info("files: Disabling streams support because the streams test failed");
      supportsRequestStreams = false;
    });
  }
  if (!supportsRequestStreams) {
    return await streamToUint8Array(s);
  }
  return s.pipeThrough(
    // eslint-disable-next-line no-undef
    new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(coerce(chunk));
      }
    })
  );
};
var computeChunkDescriptors = (inStream) => {
  let length2 = 0;
  const [lengthStream, cidStream] = inStream.tee();
  const lengthPromise = new Promise((resolve42, reject) => {
    lengthStream.pipeTo(new WritableStream({
      write(chunk) {
        length2 += chunk.byteLength;
      },
      close() {
        resolve42(length2);
      },
      abort(reason) {
        reject(reason);
      }
    }));
  });
  const cidPromise = createCIDfromStream(cidStream, multicodes.SHELTER_FILE_CHUNK);
  return Promise.all([lengthPromise, cidPromise]);
};
var fileStream = (chelonia, manifest) => {
  const dataGenerator = async function* () {
    let readSize = 0;
    for (const chunk of manifest.chunks) {
      if (!Array.isArray(chunk) || typeof chunk[0] !== "number" || typeof chunk[1] !== "string") {
        throw new Error("Invalid chunk descriptor");
      }
      const chunkResponse = await chelonia.config.fetch(`${chelonia.config.connectionURL}/file/${chunk[1]}`, {
        method: "GET",
        signal: chelonia.abortController.signal
      });
      if (!chunkResponse.ok) {
        throw new Error("Unable to retrieve manifest");
      }
      const chunkBinary = await chunkResponse.arrayBuffer();
      if (chunkBinary.byteLength !== chunk[0])
        throw new Error("mismatched chunk size");
      readSize += chunkBinary.byteLength;
      if (readSize > manifest.size)
        throw new Error("read size exceeds declared size");
      if (createCID(coerce(chunkBinary), multicodes.SHELTER_FILE_CHUNK) !== chunk[1]) {
        throw new Error("mismatched chunk hash");
      }
      yield chunkBinary;
    }
    if (readSize !== manifest.size)
      throw new Error("mismatched size");
  };
  const dataIterator = dataGenerator();
  return new ReadableStream({
    async pull(controller) {
      try {
        const chunk = await dataIterator.next();
        if (chunk.done) {
          controller.close();
          return;
        }
        controller.enqueue(chunk.value);
      } catch (e2) {
        controller.error(e2);
      }
    }
  });
};
var aes256gcmHandlers = {
  upload: (_chelonia, manifestOptions) => {
    const params = manifestOptions["cipher-params"];
    let IKM = params?.IKM;
    const recordSize = params?.rs ?? 1 << 16;
    if (!IKM) {
      IKM = new Uint8Array(33);
      self.crypto.getRandomValues(IKM);
    }
    const keyId2 = blake32Hash("aes256gcm-keyId" + blake32Hash(IKM)).slice(-8);
    const binaryKeyId = Buffer4.from(keyId2);
    return {
      cipherParams: {
        keyId: keyId2
      },
      streamHandler: async (stream) => {
        return await K(e, stream, recordSize, binaryKeyId, IKM);
      },
      downloadParams: {
        IKM: Buffer4.from(IKM).toString("base64"),
        rs: recordSize
      }
    };
  },
  download: (chelonia, downloadParams, manifest) => {
    const IKMb64 = downloadParams.IKM;
    if (!IKMb64) {
      throw new Error("Missing IKM in downloadParams");
    }
    const IKM = Buffer4.from(IKMb64, "base64");
    const keyId2 = blake32Hash("aes256gcm-keyId" + blake32Hash(IKM)).slice(-8);
    if (!manifest["cipher-params"] || !manifest["cipher-params"].keyId) {
      throw new Error("Missing cipher-params");
    }
    if (keyId2 !== manifest["cipher-params"].keyId) {
      throw new Error("Key ID mismatch");
    }
    const maxRecordSize = downloadParams.rs ?? 1 << 27;
    return {
      payloadHandler: async () => {
        const bytes = await streamToUint8Array(S(e, fileStream(chelonia, manifest), (actualKeyId) => {
          if (Buffer4.from(actualKeyId).toString() !== keyId2) {
            throw new Error("Invalid key ID");
          }
          return IKM;
        }, maxRecordSize));
        return new Blob([bytes], { type: manifest.type || "application/octet-stream" });
      }
    };
  }
};
var noneHandlers = {
  upload: () => {
    return {
      cipherParams: void 0,
      streamHandler: (stream) => {
        return stream;
      },
      downloadParams: void 0
    };
  },
  download: (chelonia, _downloadParams, manifest) => {
    return {
      payloadHandler: async () => {
        const bytes = await streamToUint8Array(fileStream(chelonia, manifest));
        return new Blob([bytes], { type: manifest.type || "application/octet-stream" });
      }
    };
  }
};
var cipherHandlers = {
  aes256gcm: aes256gcmHandlers,
  none: noneHandlers
};
var files_default = esm_default("sbp/selectors/register", {
  "chelonia/fileUpload": async function(chunks, manifestOptions, { billableContractID } = {}) {
    if (!Array.isArray(chunks))
      chunks = [chunks];
    const chunkDescriptors = [];
    const cipherHandler = await cipherHandlers[manifestOptions.cipher]?.upload?.(this, manifestOptions);
    if (!cipherHandler)
      throw new Error("Unsupported cipher");
    const cipherParams = cipherHandler.cipherParams;
    const transferParts = await Promise.all(chunks.map(async (chunk, i2) => {
      const stream2 = chunk.stream();
      const encryptedStream = await cipherHandler.streamHandler(stream2);
      const [body, s] = encryptedStream.tee();
      chunkDescriptors.push(computeChunkDescriptors(s));
      return {
        headers: new Headers([
          ["content-disposition", `form-data; name="${i2}"; filename="${i2}"`],
          ["content-type", "application/octet-stream"]
        ]),
        body
      };
    }));
    transferParts.push({
      headers: new Headers([
        ["content-disposition", 'form-data; name="manifest"; filename="manifest.json"'],
        ["content-type", "application/vnd.shelter.filemanifest"]
      ]),
      body: new ReadableStream({
        async start(controller) {
          const chunks2 = await Promise.all(chunkDescriptors);
          const manifest = {
            version: "1.0.0",
            // ?? undefined coerces null and undefined to undefined
            // This ensures that null or undefined values don't make it to the
            // JSON (otherwise, null values _would_ be stringified as 'null')
            type: manifestOptions.type ?? void 0,
            meta: manifestOptions.meta ?? void 0,
            cipher: manifestOptions.cipher,
            "cipher-params": cipherParams,
            size: chunks2.reduce((acc, [cv]) => acc + cv, 0),
            chunks: chunks2,
            "name-map": manifestOptions["name-map"] ?? void 0,
            alternatives: manifestOptions.alternatives ?? void 0
          };
          controller.enqueue(Buffer4.from(JSON.stringify(manifest)));
          controller.close();
        }
      })
    });
    const boundary = typeof self.crypto?.randomUUID === "function" ? self.crypto.randomUUID() : new Array(36).fill("").map(() => "abcdefghijklmnopqrstuvwxyz"[(0, Math.random)() * 26 | 0]).join("");
    const stream = x(boundary, transferParts);
    const deletionToken = "deletionToken" + generateSalt();
    const deletionTokenHash = blake32Hash(deletionToken);
    const uploadResponse = await this.config.fetch(`${this.config.connectionURL}/file`, {
      method: "POST",
      signal: this.abortController.signal,
      body: await ArrayBufferToUint8ArrayStream.call(this, this.config.connectionURL, stream),
      headers: new Headers([
        ...billableContractID ? [["authorization", buildShelterAuthorizationHeader.call(this, billableContractID)]] : [],
        ["content-type", `multipart/form-data; boundary=${boundary}`],
        ["shelter-deletion-token-digest", deletionTokenHash]
      ]),
      duplex: "half"
    });
    if (!uploadResponse.ok)
      throw new Error("Error uploading file");
    return {
      download: {
        manifestCid: await uploadResponse.text(),
        downloadParams: cipherHandler.downloadParams
      },
      delete: deletionToken
    };
  },
  "chelonia/fileDownload": async function(downloadOptions, manifestChecker) {
    const { manifestCid, downloadParams } = downloadOptions.valueOf();
    const manifestResponse = await this.config.fetch(`${this.config.connectionURL}/file/${manifestCid}`, {
      method: "GET",
      signal: this.abortController.signal
    });
    if (!manifestResponse.ok) {
      throw new Error("Unable to retrieve manifest");
    }
    const manifestBinary = await manifestResponse.arrayBuffer();
    if (createCID(coerce(manifestBinary), multicodes.SHELTER_FILE_MANIFEST) !== manifestCid) {
      throw new Error("mismatched manifest hash");
    }
    const manifest = JSON.parse(Buffer4.from(manifestBinary).toString());
    if (typeof manifest !== "object")
      throw new Error("manifest format is invalid");
    if (manifest.version !== "1.0.0")
      throw new Error("unsupported manifest version");
    if (!Array.isArray(manifest.chunks))
      throw new Error("missing required field: chunks");
    if (manifestChecker) {
      const proceed = await manifestChecker?.(manifest);
      if (!proceed)
        return false;
    }
    const cipherHandler = await cipherHandlers[manifest.cipher]?.download?.(this, downloadParams, manifest);
    if (!cipherHandler)
      throw new Error("Unsupported cipher");
    return cipherHandler.payloadHandler();
  },
  "chelonia/fileDelete": async function(manifestCid, credentials = {}) {
    if (!manifestCid) {
      throw new TypeError("A manifest CID must be provided");
    }
    if (!Array.isArray(manifestCid))
      manifestCid = [manifestCid];
    return await Promise.allSettled(manifestCid.map(async (cid) => {
      const hasCredential = has(credentials, cid);
      const hasToken = has(credentials[cid], "token") && credentials[cid].token;
      const hasBillableContractID = has(credentials[cid], "billableContractID") && credentials[cid].billableContractID;
      if (!hasCredential || hasToken === hasBillableContractID) {
        throw new TypeError(`Either a token or a billable contract ID must be provided for ${cid}`);
      }
      const response = await this.config.fetch(`${this.config.connectionURL}/deleteFile/${cid}`, {
        method: "POST",
        signal: this.abortController.signal,
        headers: new Headers([
          [
            "authorization",
            hasToken ? `bearer ${credentials[cid].token.valueOf()}` : buildShelterAuthorizationHeader.call(this, credentials[cid].billableContractID)
          ]
        ])
      });
      if (!response.ok) {
        throw new Error(`Unable to delete file ${cid}`);
      }
    }));
  }
});
init_esm();
init_functions();
init_esm4();
init_SPMessage();
init_esm6();
init_db();
init_encryptedData();
init_errors();
init_signedData();
var missingDecryptionKeyIdsMap = /* @__PURE__ */ new WeakMap();
var getMsgMeta = function(message, contractID, state, index) {
  const signingKeyId = message.signingKeyId();
  let innerSigningKeyId = null;
  const config = this.config;
  const result = {
    signingKeyId,
    get signingContractID() {
      return getContractIDfromKeyId(contractID, signingKeyId, state);
    },
    get innerSigningKeyId() {
      if (innerSigningKeyId === null) {
        const value = message.message();
        const data = config.unwrapMaybeEncryptedData(value);
        if (data?.data && isSignedData(data.data)) {
          innerSigningKeyId = data.data.signingKeyId;
        } else {
          innerSigningKeyId = void 0;
        }
        return innerSigningKeyId;
      }
    },
    get innerSigningContractID() {
      return getContractIDfromKeyId(contractID, result.innerSigningKeyId, state);
    },
    index
  };
  return result;
};
var keysToMap = function(keys_, height, authorizedKeys) {
  const keys = keys_.map((key) => {
    const data = this.config.unwrapMaybeEncryptedData(key);
    if (!data)
      return void 0;
    if (data.encryptionKeyId) {
      data.data._private = data.encryptionKeyId;
    }
    return data.data;
  }).filter(Boolean);
  const keysCopy = cloneDeep(keys);
  return Object.fromEntries(keysCopy.map((key) => {
    key._notBeforeHeight = height;
    if (authorizedKeys?.[key.id]) {
      if (authorizedKeys[key.id]._notAfterHeight == null) {
        throw new ChelErrorKeyAlreadyExists(`Cannot set existing unrevoked key: ${key.id}`);
      }
      key._notBeforeHeight = Math.min(height, authorizedKeys[key.id]._notBeforeHeight ?? 0);
    } else {
      key._notBeforeHeight = height;
    }
    delete key._notAfterHeight;
    return [key.id, key];
  }));
};
var keyRotationHelper = (contractID, state, config, updatedKeysMap, requiredPermissions, outputSelector, outputMapper, internalSideEffectStack) => {
  if (!internalSideEffectStack || !Array.isArray(state._volatile?.watch))
    return;
  const rootState = esm_default(config.stateSelector);
  const watchMap = /* @__PURE__ */ Object.create(null);
  state._volatile.watch.forEach(([name, cID]) => {
    if (!updatedKeysMap[name] || watchMap[cID] === null) {
      return;
    }
    if (!watchMap[cID]) {
      if (!rootState.contracts[cID]?.type || !findSuitableSecretKeyId(rootState[cID], [SPMessage.OP_KEY_UPDATE], ["sig"])) {
        watchMap[cID] = null;
        return;
      }
      watchMap[cID] = [];
    }
    watchMap[cID].push(name);
  });
  Object.entries(watchMap).forEach(([cID, names]) => {
    if (!Array.isArray(names) || !names.length)
      return;
    const [keyNamesToUpdate, signingKeyId] = names.map((name) => {
      const foreignContractKey = rootState[cID]?._vm?.authorizedKeys?.[updatedKeysMap[name].oldKeyId];
      if (!foreignContractKey)
        return void 0;
      const signingKeyId2 = findSuitableSecretKeyId(rootState[cID], requiredPermissions, ["sig"], foreignContractKey.ringLevel);
      if (signingKeyId2) {
        return [
          [name, foreignContractKey.name],
          signingKeyId2,
          rootState[cID]._vm.authorizedKeys[signingKeyId2].ringLevel
        ];
      }
      return void 0;
    }).filter(Boolean).reduce((acc, [name, signingKeyId2, ringLevel]) => {
      acc[0].push(name);
      return ringLevel < acc[2] ? [acc[0], signingKeyId2, ringLevel] : acc;
    }, [[], void 0, Number.POSITIVE_INFINITY]);
    if (!signingKeyId)
      return;
    const contractName = rootState.contracts[cID]?.type;
    internalSideEffectStack?.push(() => {
      esm_default(outputSelector, {
        contractID: cID,
        contractName,
        data: keyNamesToUpdate.map(outputMapper).map((v2) => {
          return v2;
        }),
        signingKeyId
      }).catch((e2) => {
        console.warn(`Error mirroring key operation (${outputSelector}) from ${contractID} to ${cID}: ${e2?.message || e2}`);
      });
    });
  });
};
var internals_default = esm_default("sbp/selectors/register", {
  //     DO NOT CALL ANY OF THESE YOURSELF!
  "chelonia/private/state": function() {
    return this.state;
  },
  "chelonia/private/invoke": function(instance, invocation) {
    if (this._instance !== instance) {
      console.info("['chelonia/private/invoke] Not proceeding with invocation as Chelonia was restarted", { invocation });
      return;
    }
    if (Array.isArray(invocation)) {
      return esm_default(...invocation);
    } else if (typeof invocation === "function") {
      return invocation();
    } else {
      throw new TypeError(`[chelonia/private/invoke] Expected invocation to be an array or a function. Saw ${typeof invocation} instead.`);
    }
  },
  "chelonia/private/queueEvent": function(queueName, invocation) {
    return esm_default("okTurtles.eventQueue/queueEvent", queueName, [
      "chelonia/private/invoke",
      this._instance,
      invocation
    ]);
  },
  "chelonia/private/verifyManifestSignature": function(contractName, manifestHash, manifest) {
    if (!has(manifest, "signature") || typeof manifest.signature.keyId !== "string" || typeof manifest.signature.value !== "string") {
      throw new Error(`Invalid or missing signature field for manifest ${manifestHash} (named ${contractName})`);
    }
    const rootState = esm_default(this.config.stateSelector);
    if (!has(rootState, "contractSigningKeys")) {
      this.config.reactiveSet(rootState, "contractSigningKeys", /* @__PURE__ */ Object.create(null));
    }
    const contractNameLookupKey = `name:${contractName}`;
    let signatureValidated = false;
    if (process.env.UNSAFE_TRUST_ALL_MANIFEST_SIGNING_KEYS !== "true" && has(rootState.contractSigningKeys, contractNameLookupKey)) {
      console.info(`[chelonia] verifying signature for ${manifestHash} with an existing key`);
      if (!has(rootState.contractSigningKeys[contractNameLookupKey], manifest.signature.keyId)) {
        console.error(`The manifest with ${manifestHash} (named ${contractName}) claims to be signed with a key with ID ${manifest.signature.keyId}, which is not trusted. The trusted key IDs for this name are:`, Object.keys(rootState.contractSigningKeys[contractNameLookupKey]));
        throw new Error(`Invalid or missing signature in manifest ${manifestHash} (named ${contractName}). It claims to be signed with a key with ID ${manifest.signature.keyId}, which has not been authorized for this contract before.`);
      }
      const signingKey = rootState.contractSigningKeys[contractNameLookupKey][manifest.signature.keyId];
      verifySignature(signingKey, manifest.body + manifest.head, manifest.signature.value);
      console.info(`[chelonia] successful signature verification for ${manifestHash} (named ${contractName}) using the already-trusted key ${manifest.signature.keyId}.`);
      signatureValidated = true;
    }
    const body = JSON.parse(manifest.body);
    if (!signatureValidated) {
      console.info(`[chelonia] verifying signature for ${manifestHash} (named ${contractName}) for the first time`);
      if (!has(body, "signingKeys") || !Array.isArray(body.signingKeys)) {
        throw new Error(`Invalid manifest file ${manifestHash} (named ${contractName}). Its body doesn't contain a 'signingKeys' list'`);
      }
      let contractSigningKeys;
      try {
        contractSigningKeys = Object.fromEntries(body.signingKeys.map((serializedKey) => {
          return [keyId(serializedKey), serializedKey];
        }));
      } catch (e2) {
        console.error(`[chelonia] Error parsing the public keys list for ${manifestHash} (named ${contractName})`, e2);
        throw e2;
      }
      if (!has(contractSigningKeys, manifest.signature.keyId)) {
        throw new Error(`Invalid or missing signature in manifest ${manifestHash} (named ${contractName}). It claims to be signed with a key with ID ${manifest.signature.keyId}, which is not listed in its 'signingKeys' field.`);
      }
      verifySignature(contractSigningKeys[manifest.signature.keyId], manifest.body + manifest.head, manifest.signature.value);
      console.info(`[chelonia] successful signature verification for ${manifestHash} (named ${contractName}) using ${manifest.signature.keyId}. The following key IDs will now be trusted for this contract name`, Object.keys(contractSigningKeys));
      signatureValidated = true;
      rootState.contractSigningKeys[contractNameLookupKey] = contractSigningKeys;
    }
    return body;
  },
  "chelonia/private/loadManifest": async function(contractName, manifestHash) {
    if (!contractName || typeof contractName !== "string") {
      throw new Error("Invalid or missing contract name");
    }
    if (this.manifestToContract[manifestHash]) {
      console.warn("[chelonia]: already loaded manifest", manifestHash);
      return;
    }
    const manifestSource = await esm_default("chelonia/out/fetchResource", manifestHash, {
      code: multicodes.SHELTER_CONTRACT_MANIFEST
    });
    const manifest = JSON.parse(manifestSource);
    const body = esm_default("chelonia/private/verifyManifestSignature", contractName, manifestHash, manifest);
    if (body.name !== contractName) {
      throw new Error(`Mismatched contract name. Expected ${contractName} but got ${body.name}`);
    }
    const contractInfo = this.config.contracts.defaults.preferSlim && body.contractSlim || body.contract;
    console.info(`[chelonia] loading contract '${contractInfo.file}'@'${body.version}' from manifest: ${manifestHash}`);
    const source = await esm_default("chelonia/out/fetchResource", contractInfo.hash, {
      code: multicodes.SHELTER_CONTRACT_TEXT
    });
    const reduceAllow = (acc, v2) => {
      acc[v2] = true;
      return acc;
    };
    const allowedSels = [
      "okTurtles.events/on",
      "chelonia/defineContract",
      "chelonia/out/keyRequest"
    ].concat(this.config.contracts.defaults.allowedSelectors).reduce(reduceAllow, {});
    const allowedDoms = this.config.contracts.defaults.allowedDomains.reduce(reduceAllow, {});
    const contractSBP = (selector, ...args) => {
      const domain = domainFromSelector(selector);
      if (selector.startsWith(contractName + "/")) {
        selector = `${manifestHash}/${selector}`;
      }
      if (allowedSels[selector] || allowedDoms[domain]) {
        return esm_default(selector, ...args);
      } else {
        console.error("[chelonia] selector not on allowlist", {
          selector,
          allowedSels,
          allowedDoms
        });
        throw new Error(`[chelonia] selector not on allowlist: '${selector}'`);
      }
    };
    const saferEval = new Function(`
      return function (globals) {
        // almost a real sandbox
        // stops (() => this)().fetch
        // needs additional step of locking down Function constructor to stop:
        // new (()=>{}).constructor("console.log(typeof this.fetch)")()
        globals.self = globals
        globals.globalThis = globals
        with (new Proxy(globals, {
          get (o, p) { return o[p] },
          has (o, p) { /* console.log('has', p); */ return true }
        })) {
          (function () {
            'use strict'
            ${source}
          })()
        }
      }
    `)();
    this.defContractSBP = contractSBP;
    this.defContractManifest = manifestHash;
    saferEval({
      // pass in globals that we want access to by default in the sandbox
      // note: you can undefine these by setting them to undefined in exposedGlobals
      crypto: {
        getRandomValues: (v2) => globalThis.crypto.getRandomValues(v2)
      },
      ...typeof window === "object" && window && {
        alert: window.alert.bind(window),
        confirm: window.confirm.bind(window),
        prompt: window.prompt.bind(window)
      },
      isNaN,
      console,
      Object,
      Error,
      TypeError,
      RangeError,
      Math,
      Symbol,
      Date,
      Array,
      BigInt,
      Boolean,
      String,
      Number,
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Float32Array,
      Float64Array,
      ArrayBuffer,
      JSON,
      RegExp,
      parseFloat,
      parseInt,
      Promise,
      Function,
      Map,
      WeakMap,
      ...this.config.contracts.defaults.exposedGlobals,
      require: (dep) => {
        return dep === "@sbp/sbp" ? contractSBP : this.config.contracts.defaults.modules[dep];
      },
      sbp: contractSBP,
      fetchServerTime: async (fallback = true) => {
        try {
          const response = await this.config.fetch(`${this.config.connectionURL}/time`, {
            signal: this.abortController.signal
          });
          return handleFetchResult("text")(response);
        } catch (e2) {
          console.warn("[fetchServerTime] Error", e2);
          if (fallback) {
            return new Date(esm_default("chelonia/time")).toISOString();
          }
          throw new ChelErrorFetchServerTimeFailed("Can not fetch server time. Please check your internet connection.");
        }
      }
    });
    if (contractName !== this.defContract.name) {
      throw new Error(`Invalid contract name for manifest ${manifestHash}. Expected ${contractName} but got ${this.defContract.name}`);
    }
    this.defContractSelectors.forEach((s) => {
      allowedSels[s] = true;
    });
    this.manifestToContract[manifestHash] = {
      slim: contractInfo === body.contractSlim,
      info: contractInfo,
      contract: this.defContract
    };
  },
  // Warning: avoid using this unless you know what you're doing. Prefer using /remove.
  "chelonia/private/removeImmediately": function(contractID, params) {
    const state = esm_default(this.config.stateSelector);
    const contractName = state.contracts[contractID]?.type;
    if (!contractName) {
      console.error("[chelonia/private/removeImmediately] Missing contract name for contract", {
        contractID
      });
      return;
    }
    const manifestHash = this.config.contracts.manifests[contractName];
    if (manifestHash) {
      const destructor = `${manifestHash}/${contractName}/_cleanup`;
      if (esm_default("sbp/selectors/fn", destructor)) {
        try {
          esm_default(destructor, { contractID, resync: !!params?.resync, state: state[contractID] });
        } catch (e2) {
          console.error(`[chelonia/private/removeImmediately] Error at destructor for ${contractID}`, e2);
        }
      }
    }
    if (params?.resync) {
      Object.keys(state.contracts[contractID]).filter((k) => k !== "references").forEach((k) => this.config.reactiveDel(state.contracts[contractID], k));
      Object.keys(state[contractID]).filter((k) => k !== "_volatile").forEach((k) => this.config.reactiveDel(state[contractID], k));
      if (state[contractID]._volatile) {
        Object.keys(state[contractID]._volatile).filter((k) => k !== "watch").forEach((k) => this.config.reactiveDel(state[contractID]._volatile, k));
      }
    } else {
      delete this.ephemeralReferenceCount[contractID];
      if (params?.permanent) {
        this.config.reactiveSet(state.contracts, contractID, null);
      } else {
        this.config.reactiveDel(state.contracts, contractID);
      }
      this.config.reactiveDel(state, contractID);
    }
    this.subscriptionSet.delete(contractID);
    esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
      added: [],
      removed: [contractID],
      permanent: params?.permanent,
      resync: params?.resync
    });
  },
  // used by, e.g. 'chelonia/contract/wait'
  "chelonia/private/noop": function() {
  },
  "chelonia/private/out/sync": function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
    const forcedSync = !!params?.force;
    return Promise.all(listOfIds.map((contractID) => {
      if (!forcedSync && this.subscriptionSet.has(contractID)) {
        const rootState = esm_default(this.config.stateSelector);
        if (!rootState[contractID]?._volatile?.dirty) {
          return esm_default("chelonia/private/queueEvent", contractID, ["chelonia/private/noop"]);
        }
      }
      return esm_default("chelonia/private/queueEvent", contractID, [
        "chelonia/private/in/syncContract",
        contractID,
        params
      ]).catch((err) => {
        console.error(`[chelonia] failed to sync ${contractID}:`, err);
        throw err;
      });
    }));
  },
  "chelonia/private/out/publishEvent": function(entry, { maxAttempts = 5, headers, billableContractID, bearer, disableAutoDedup } = {}, hooks) {
    const contractID = entry.contractID();
    const originalEntry = entry;
    return esm_default("chelonia/private/queueEvent", `publish:${contractID}`, async () => {
      let attempt = 1;
      let lastAttemptedHeight;
      await hooks?.prepublish?.(entry);
      const onreceivedHandler = (_contractID, message) => {
        if (entry.hash() === message.hash()) {
          esm_default("okTurtles.events/off", EVENT_HANDLED, onreceivedHandler);
          hooks.onprocessed(entry);
        }
      };
      if (typeof hooks?.onprocessed === "function") {
        esm_default("okTurtles.events/on", EVENT_HANDLED, onreceivedHandler);
      }
      while (true) {
        lastAttemptedHeight = entry.height();
        const newEntry = await esm_default("chelonia/private/queueEvent", contractID, async () => {
          const rootState = esm_default(this.config.stateSelector);
          const state = rootState[contractID];
          const isFirstMessage = entry.isFirstMessage();
          if (!state && !isFirstMessage) {
            console.info(`[chelonia] Not sending message as contract state has been removed: ${entry.description()}`);
            return;
          }
          if (hooks?.preSendCheck) {
            if (!await hooks.preSendCheck(entry, state)) {
              console.info(`[chelonia] Not sending message as preSendCheck hook returned non-truish value: ${entry.description()}`);
              return;
            }
          }
          await esm_default("chelonia/private/in/processMessage", entry, cloneDeep(state || {}));
          if (!isFirstMessage) {
            return recreateEvent(entry, state, rootState.contracts[contractID], disableAutoDedup);
          }
          return entry;
        });
        if (!newEntry)
          return;
        await hooks?.beforeRequest?.(newEntry, entry);
        entry = newEntry;
        const r = await this.config.fetch(`${this.config.connectionURL}/event`, {
          method: "POST",
          body: entry.serialize(),
          headers: {
            ...headers,
            ...bearer && {
              Authorization: `Bearer ${bearer}`
            },
            ...billableContractID && {
              Authorization: buildShelterAuthorizationHeader.call(this, billableContractID)
            },
            "Content-Type": "text/plain"
          },
          signal: this.abortController.signal
        });
        if (r.ok) {
          await hooks?.postpublish?.(entry);
          return entry;
        }
        try {
          if (r.status === 409) {
            if (attempt + 1 > maxAttempts) {
              console.error(`[chelonia] failed to publish ${entry.description()} after ${attempt} attempts`, entry);
              throw new Error(`publishEvent: ${r.status} - ${r.statusText}. attempt ${attempt}`);
            }
            const randDelay = randomIntFromRange(0, 1500);
            console.warn(`[chelonia] publish attempt ${attempt} of ${maxAttempts} failed. Waiting ${randDelay} msec before resending ${entry.description()}`);
            attempt += 1;
            await delay(randDelay);
            if (!entry.isFirstMessage() && entry.height() === lastAttemptedHeight) {
              await esm_default("chelonia/private/out/sync", contractID, { force: true });
            }
          } else {
            const message = (await r.json())?.message;
            console.error(`[chelonia] ERROR: failed to publish ${entry.description()}: ${r.status} - ${r.statusText}: ${message}`, entry);
            throw new Error(`publishEvent: ${r.status} - ${r.statusText}: ${message}`);
          }
        } catch (e2) {
          esm_default("okTurtles.events/off", EVENT_HANDLED, onreceivedHandler);
          throw e2;
        }
      }
    }).then((entry2) => {
      esm_default("okTurtles.events/emit", EVENT_PUBLISHED, {
        contractID,
        message: entry2,
        originalMessage: originalEntry
      });
      return entry2;
    }).catch((e2) => {
      esm_default("okTurtles.events/emit", EVENT_PUBLISHING_ERROR, {
        contractID,
        message: entry,
        originalMessage: originalEntry,
        error: e2
      });
      throw e2;
    });
  },
  "chelonia/private/out/latestHEADinfo": function(contractID) {
    return this.config.fetch(`${this.config.connectionURL}/latestHEADinfo/${contractID}`, {
      cache: "no-store",
      signal: this.abortController.signal
    }).then(handleFetchResult("json"));
  },
  "chelonia/private/postKeyShare": function(contractID, previousVolatileState, signingKey) {
    const cheloniaState = esm_default(this.config.stateSelector);
    const targetState = cheloniaState[contractID];
    if (!targetState)
      return;
    if (previousVolatileState && has(previousVolatileState, "watch")) {
      if (!targetState._volatile) {
        this.config.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
      }
      if (!targetState._volatile.watch) {
        this.config.reactiveSet(targetState._volatile, "watch", previousVolatileState.watch);
      } else if (targetState._volatile.watch !== previousVolatileState.watch) {
        previousVolatileState.watch.forEach((pWatch) => {
          if (!targetState._volatile.watch.some((tWatch) => {
            return tWatch[0] === pWatch[0] && tWatch[1] === pWatch[1];
          })) {
            targetState._volatile.watch.push(pWatch);
          }
        });
      }
    }
    if (!Array.isArray(targetState._volatile?.pendingKeyRequests))
      return;
    this.config.reactiveSet(targetState._volatile, "pendingKeyRequests", targetState._volatile.pendingKeyRequests.filter((pkr) => pkr?.name !== signingKey.name));
  },
  "chelonia/private/in/processMessage": async function(message, state, internalSideEffectStack, contractName) {
    const [opT, opV] = message.op();
    const hash2 = message.hash();
    const height = message.height();
    const contractID = message.contractID();
    const manifestHash = message.manifest();
    const signingKeyId = message.signingKeyId();
    const direction = message.direction();
    const config = this.config;
    const self2 = this;
    const opName = Object.entries(SPMessage).find(([, y]) => y === opT)?.[0];
    console.debug("PROCESSING OPCODE:", opName, "to", contractID);
    if (state?._volatile?.dirty) {
      console.debug("IGNORING OPCODE BECAUSE CONTRACT STATE IS MARKED AS DIRTY.", "OPCODE:", opName, "CONTRACT:", contractID);
      return;
    }
    if (!state._vm)
      state._vm = /* @__PURE__ */ Object.create(null);
    const opFns = {
      /*
        There are two types of "errors" that we need to consider:
        1. "Ignoring" errors
        2. "Failure" errors
        Example: OP_KEY_ADD
        1. IGNORING: an error is thrown because we wanted to add a key but the
        key we wanted to add is already there. This is not a hard error, it's an
        ignoring error. We don't care that the operation failed in this case because the intent was accomplished.
        2. FAILURE: an error is thrown while attempting to add a key that doesn't exist.
        Example: OP_ACTION_ENCRYPTED
        1. IGNORING: An error is thrown because we don't have the key to decrypt the action. We ignore it.
        2. FAILURE: An error is thrown by the process function during processing.
        Handling these in OP_ATOMIC
        • ALL errors of class "IGNORING" should be ignored. They should not
        impact our ability to process the rest of the operations in the OP_ATOMIC.
        No matter how many of these are thrown, it doesn't affect the rest of the operations.
        • ANY error of class "FAILURE" will call the rest of the operations to
        fail and the state to be reverted to prior to the OP_ATOMIC. No side-effects should be run. Because an intention failed.
      */
      async [SPMessage.OP_ATOMIC](v2) {
        for (let i2 = 0; i2 < v2.length; i2++) {
          const u2 = v2[i2];
          try {
            if (u2[0] === SPMessage.OP_ATOMIC)
              throw new Error("Cannot nest OP_ATOMIC");
            if (!validateKeyPermissions(message, config, state, signingKeyId, u2[0], u2[1])) {
              throw new Error("Inside OP_ATOMIC: no matching signing key was defined");
            }
            await opFns[u2[0]](u2[1]);
          } catch (e_) {
            const e2 = e_;
            if (e2 && typeof e2 === "object") {
              if (e2.name === "ChelErrorDecryptionKeyNotFound") {
                console.warn(`[chelonia] [OP_ATOMIC] WARN '${e2.name}' in processMessage for ${message.description()}: ${e2.message}`, e2, message.serialize());
                if (e2.cause) {
                  const missingDecryptionKeyIds = missingDecryptionKeyIdsMap.get(message);
                  if (missingDecryptionKeyIds) {
                    missingDecryptionKeyIds.add(e2.cause);
                  } else {
                    missingDecryptionKeyIdsMap.set(message, /* @__PURE__ */ new Set([e2.cause]));
                  }
                }
                continue;
              } else {
                logEvtError(message, `[chelonia] [OP_ATOMIC] ERROR '${e2.name}' in processMessage for ${message.description()}: ${e2.message || e2}`, e2, message.serialize());
              }
              console.warn(`[chelonia] [OP_ATOMIC] Error processing ${message.description()}: ${message.serialize()}. Any side effects will be skipped!`);
              if (config.strictProcessing) {
                throw e2;
              }
              config.hooks.processError?.(e2, message, getMsgMeta.call(self2, message, contractID, state));
              if (e2.name === "ChelErrorWarning")
                continue;
            } else {
              logEvtError(message, "Inside OP_ATOMIC: Non-object or null error thrown", contractID, message, i2, e2);
            }
            throw e2;
          }
        }
      },
      [SPMessage.OP_CONTRACT](v2) {
        state._vm.type = v2.type;
        const keys = keysToMap.call(self2, v2.keys, height);
        state._vm.authorizedKeys = keys;
        keyAdditionProcessor.call(self2, message, hash2, v2.keys, state, contractID, signingKey, internalSideEffectStack);
      },
      [SPMessage.OP_ACTION_ENCRYPTED](v2) {
        if (config.skipActionProcessing) {
          if (!config.skipDecryptionAttempts) {
            console.log("OP_ACTION_ENCRYPTED: skipped action processing");
          }
          return;
        }
        return opFns[SPMessage.OP_ACTION_UNENCRYPTED](v2.valueOf());
      },
      async [SPMessage.OP_ACTION_UNENCRYPTED](v2) {
        if (!config.skipActionProcessing) {
          let innerSigningKeyId;
          if (isSignedData(v2)) {
            innerSigningKeyId = v2.signingKeyId;
            v2 = v2.valueOf();
          }
          const { data, meta, action } = v2;
          if (!config.whitelisted(action)) {
            throw new Error(`chelonia: action not whitelisted: '${action}'`);
          }
          await esm_default(`${manifestHash}/${action}/process`, {
            data,
            meta,
            hash: hash2,
            height,
            contractID,
            direction: message.direction(),
            signingKeyId,
            get signingContractID() {
              return getContractIDfromKeyId(contractID, signingKeyId, state);
            },
            innerSigningKeyId,
            get innerSigningContractID() {
              return getContractIDfromKeyId(contractID, innerSigningKeyId, state);
            }
          }, state);
        }
      },
      [SPMessage.OP_KEY_SHARE](wv) {
        const data = config.unwrapMaybeEncryptedData(wv);
        if (!data)
          return;
        const v2 = data.data;
        for (const key of v2.keys) {
          if (key.id && key.meta?.private?.content) {
            if (!has(state._vm, "sharedKeyIds"))
              state._vm.sharedKeyIds = [];
            if (!state._vm.sharedKeyIds.some((sK) => sK.id === key.id)) {
              state._vm.sharedKeyIds.push({
                id: key.id,
                contractID: v2.contractID,
                height,
                keyRequestHash: v2.keyRequestHash,
                keyRequestHeight: v2.keyRequestHeight
              });
            }
          }
        }
        if (has(v2, "keyRequestHash") && state._vm.authorizedKeys[signingKeyId].meta?.keyRequest) {
          state._vm.authorizedKeys[signingKeyId].meta.keyRequest.responded = hash2;
        }
        internalSideEffectStack?.push(async () => {
          delete self2.postSyncOperations[contractID]?.["pending-keys-for-" + v2.contractID];
          const cheloniaState = esm_default(self2.config.stateSelector);
          const targetState = cheloniaState[v2.contractID];
          const missingDecryptionKeyIds = cheloniaState.contracts[v2.contractID]?.missingDecryptionKeyIds;
          let newestEncryptionKeyHeight = Number.POSITIVE_INFINITY;
          for (const key of v2.keys) {
            if (key.id && key.meta?.private?.content) {
              const transient = direction === "outgoing" || key.meta.private.transient;
              if (!esm_default("chelonia/haveSecretKey", key.id, !transient)) {
                try {
                  const decrypted = key.meta.private.content.valueOf();
                  esm_default("chelonia/storeSecretKeys", new Secret([
                    {
                      key: deserializeKey(decrypted),
                      transient
                    }
                  ]));
                  if (missingDecryptionKeyIds?.includes(key.id)) {
                    newestEncryptionKeyHeight = Number.NEGATIVE_INFINITY;
                  } else if (
                    // Otherwise, we make an educated guess on whether a re-sync
                    // is needed based on the height.
                    targetState?._vm?.authorizedKeys?.[key.id]?._notBeforeHeight != null && Array.isArray(targetState._vm.authorizedKeys[key.id].purpose) && targetState._vm.authorizedKeys[key.id].purpose.includes("enc")
                  ) {
                    newestEncryptionKeyHeight = Math.min(newestEncryptionKeyHeight, targetState._vm.authorizedKeys[key.id]._notBeforeHeight);
                  }
                } catch (e_) {
                  const e2 = e_;
                  if (e2?.name === "ChelErrorDecryptionKeyNotFound") {
                    console.warn(`OP_KEY_SHARE (${hash2} of ${contractID}) missing secret key: ${e2.message}`, e2);
                  } else {
                    console.error(`OP_KEY_SHARE (${hash2} of ${contractID}) error '${e2.message || e2}':`, e2);
                  }
                }
              }
            }
          }
          const mustResync = !!(newestEncryptionKeyHeight < cheloniaState.contracts[v2.contractID]?.height);
          if (mustResync) {
            if (!has(targetState, "_volatile")) {
              config.reactiveSet(targetState, "_volatile", /* @__PURE__ */ Object.create(null));
            }
            config.reactiveSet(targetState._volatile, "dirty", true);
            if (!Object.keys(targetState).some((k) => k !== "_volatile")) {
              return;
            }
            const keyDict = /* @__PURE__ */ Object.create(null);
            targetState._volatile?.watch?.forEach(([keyName, contractID2]) => {
              if (!keyDict[keyName]) {
                keyDict[keyName] = [contractID2];
                return;
              }
              keyDict[keyName].push(contractID2);
            });
            const contractIdsToUpdate = Array.from(new Set(Object.entries(keyDict).flatMap(([keyName, contractIDs]) => {
              const keyId2 = findKeyIdByName(targetState, keyName);
              if (
                // Does the key exist? (i.e., is it a current key)
                keyId2 && // Is it an encryption key? (signing keys don't build up a
                // potentially invalid state because the private key isn't
                // required for validation; however, missing encryption keys
                // prevent message processing)
                targetState._vm.authorizedKeys[keyId2].purpose.includes("enc") && // Is this a newly set key? (avoid re-syncing contracts that
                // haven't been affected by the `OP_KEY_SHARE`)
                targetState._vm.authorizedKeys[keyId2]._notBeforeHeight >= newestEncryptionKeyHeight
              ) {
                return contractIDs;
              }
              return [];
            })));
            contractIdsToUpdate.forEach((contractID2) => {
              const targetState2 = cheloniaState[contractID2];
              if (!targetState2)
                return;
              if (!has(targetState2, "_volatile")) {
                config.reactiveSet(targetState2, "_volatile", /* @__PURE__ */ Object.create(null));
              }
              config.reactiveSet(targetState2._volatile, "dirty", true);
            });
            if (self2.subscriptionSet.has(v2.contractID)) {
              const resync = esm_default("chelonia/private/queueEvent", v2.contractID, [
                "chelonia/private/in/syncContract",
                v2.contractID
              ]).then(() => {
                esm_default("chelonia/private/out/sync", contractIdsToUpdate.filter((contractID2) => {
                  return self2.subscriptionSet.has(contractID2);
                }), { force: true, resync: true }).catch((e2) => {
                  console.error("[chelonia] Error resyncing contracts with foreign key references after key rotation", e2);
                });
              }).catch((e2) => {
                console.error(`[chelonia] Error during sync for ${v2.contractID} during OP_KEY_SHARE for ${contractID}`);
                if (v2.contractID === contractID) {
                  throw e2;
                }
              });
              if (v2.contractID !== contractID) {
                await resync;
              }
            }
          }
          const previousVolatileState = targetState?._volatile;
          esm_default("chelonia/private/queueEvent", v2.contractID, [
            "chelonia/private/postKeyShare",
            v2.contractID,
            mustResync ? previousVolatileState : null,
            signingKey
          ]).then(() => {
            esm_default("chelonia/private/queueEvent", contractID, () => {
              esm_default("okTurtles.events/emit", CONTRACT_HAS_RECEIVED_KEYS, {
                contractID: v2.contractID,
                sharedWithContractID: contractID,
                signingKeyId,
                get signingKeyName() {
                  return state._vm?.authorizedKeys?.[signingKeyId]?.name;
                }
              });
            }).catch((e2) => {
              console.error(`[chelonia] Error while emitting the CONTRACT_HAS_RECEIVED_KEYS event for ${contractID}`, e2);
            });
          });
        });
      },
      [SPMessage.OP_KEY_REQUEST](wv) {
        const data = config.unwrapMaybeEncryptedData(wv);
        const v2 = data?.data || {
          contractID: "(private)",
          replyWith: { context: void 0 },
          request: "*"
        };
        const originatingContractID = v2.contractID;
        if (state._vm?.invites?.[signingKeyId]?.quantity != null) {
          if (state._vm.invites[signingKeyId].quantity > 0) {
            if (--state._vm.invites[signingKeyId].quantity <= 0) {
              state._vm.invites[signingKeyId].status = INVITE_STATUS.USED;
            }
          } else {
            logEvtError(message, "Ignoring OP_KEY_REQUEST because it exceeds allowed quantity: " + originatingContractID);
            return;
          }
        }
        if (state._vm?.invites?.[signingKeyId]?.expires != null) {
          if (state._vm.invites[signingKeyId].expires < Date.now()) {
            logEvtError(message, "Ignoring OP_KEY_REQUEST because it expired at " + state._vm.invites[signingKeyId].expires + ": " + originatingContractID);
            return;
          }
        }
        if (config.skipActionProcessing || direction === "outgoing") {
          return;
        }
        if (!has(v2.replyWith, "context")) {
          logEvtError(message, "Ignoring OP_KEY_REQUEST because it is missing the context attribute");
          return;
        }
        const context = v2.replyWith.context;
        if (data && (!Array.isArray(context) || context[0] !== originatingContractID)) {
          logEvtError(message, "Ignoring OP_KEY_REQUEST because it is signed by the wrong contract");
          return;
        }
        if (v2.request !== "*") {
          logEvtError(message, "Ignoring OP_KEY_REQUEST because it has an unsupported request attribute", v2.request);
          return;
        }
        if (!state._vm.pendingKeyshares)
          state._vm.pendingKeyshares = /* @__PURE__ */ Object.create(null);
        state._vm.pendingKeyshares[message.hash()] = context ? [
          // Full-encryption (i.e., KRS encryption) requires that this request
          // was encrypted and that the invite is marked as private
          !!data?.encryptionKeyId,
          message.height(),
          signingKeyId,
          context
        ] : [!!data?.encryptionKeyId, message.height(), signingKeyId];
        if (data) {
          internalSideEffectStack?.push(() => {
            self2.setPostSyncOp(contractID, "respondToAllKeyRequests-" + message.contractID(), [
              "chelonia/private/respondToAllKeyRequests",
              contractID
            ]);
          });
        }
      },
      [SPMessage.OP_KEY_REQUEST_SEEN](wv) {
        if (config.skipActionProcessing) {
          return;
        }
        const data = config.unwrapMaybeEncryptedData(wv);
        if (!data)
          return;
        const v2 = data.data;
        if (state._vm.pendingKeyshares && v2.keyRequestHash in state._vm.pendingKeyshares) {
          const hash3 = v2.keyRequestHash;
          const pending = state._vm.pendingKeyshares[hash3];
          delete state._vm.pendingKeyshares[hash3];
          if (pending.length !== 4)
            return;
          const keyId2 = pending[2];
          const originatingContractID = pending[3][0];
          if (Array.isArray(state._vm?.invites?.[keyId2]?.responses)) {
            state._vm?.invites?.[keyId2]?.responses.push(originatingContractID);
          }
          if (!has(state._vm, "keyshares"))
            state._vm.keyshares = /* @__PURE__ */ Object.create(null);
          const success = v2.success;
          state._vm.keyshares[hash3] = {
            contractID: originatingContractID,
            height,
            success,
            ...success && {
              hash: v2.keyShareHash
            }
          };
        }
      },
      [SPMessage.OP_PROP_DEL]: notImplemented,
      [SPMessage.OP_PROP_SET](v2) {
        if (!state._vm.props)
          state._vm.props = {};
        state._vm.props[v2.key] = v2.value;
      },
      [SPMessage.OP_KEY_ADD](v2) {
        const keys = keysToMap.call(self2, v2, height, state._vm.authorizedKeys);
        const keysArray = Object.values(v2);
        keysArray.forEach((k) => {
          if (has(state._vm.authorizedKeys, k.id) && state._vm.authorizedKeys[k.id]._notAfterHeight == null) {
            throw new ChelErrorWarning("Cannot use OP_KEY_ADD on existing keys. Key ID: " + k.id);
          }
        });
        validateKeyAddPermissions.call(self2, contractID, signingKey, state, v2);
        state._vm.authorizedKeys = { ...state._vm.authorizedKeys, ...keys };
        keyAdditionProcessor.call(self2, message, hash2, v2, state, contractID, signingKey, internalSideEffectStack);
      },
      [SPMessage.OP_KEY_DEL](v2) {
        if (!state._vm.authorizedKeys)
          state._vm.authorizedKeys = /* @__PURE__ */ Object.create(null);
        if (!state._volatile)
          state._volatile = /* @__PURE__ */ Object.create(null);
        if (!state._volatile.pendingKeyRevocations) {
          state._volatile.pendingKeyRevocations = /* @__PURE__ */ Object.create(null);
        }
        validateKeyDelPermissions.call(self2, contractID, signingKey, state, v2);
        const keyIds = v2.map((k) => {
          const data = config.unwrapMaybeEncryptedData(k);
          if (!data)
            return void 0;
          return data.data;
        }).filter((keyId2) => {
          if (!keyId2 || typeof keyId2 !== "string")
            return false;
          if (!has(state._vm.authorizedKeys, keyId2) || state._vm.authorizedKeys[keyId2]._notAfterHeight != null) {
            console.warn("Attempted to delete non-existent key from contract", {
              contractID,
              keyId: keyId2
            });
            return false;
          }
          return true;
        });
        keyIds.forEach((keyId2) => {
          const key = state._vm.authorizedKeys[keyId2];
          state._vm.authorizedKeys[keyId2]._notAfterHeight = height;
          if (has(state._volatile.pendingKeyRevocations, keyId2)) {
            delete state._volatile.pendingKeyRevocations[keyId2];
          }
          if (key.foreignKey) {
            const fkUrl = new URL(key.foreignKey);
            const foreignContract = fkUrl.pathname;
            const foreignKeyName = fkUrl.searchParams.get("keyName");
            if (!foreignContract || !foreignKeyName) {
              throw new Error("Invalid foreign key: missing contract or key name");
            }
            internalSideEffectStack?.push(() => {
              esm_default("chelonia/private/queueEvent", foreignContract, () => {
                const rootState = esm_default(config.stateSelector);
                if (Array.isArray(rootState[foreignContract]?._volatile?.watch)) {
                  const oldWatch = rootState[foreignContract]._volatile.watch;
                  rootState[foreignContract]._volatile.watch = oldWatch.filter(([name, cID]) => name !== foreignKeyName || cID !== contractID);
                  if (oldWatch.length !== rootState[foreignContract]._volatile.watch.length) {
                    esm_default("chelonia/contract/release", foreignContract, { try: true }).catch((e2) => {
                      console.error(`[chelonia] Error at OP_KEY_DEL internalSideEffectStack while attempting to release foreign contract ${foreignContract}`, e2);
                    });
                  }
                }
              }).catch((e2) => {
                console.error("Error stopping watching events after removing key", { contractID, foreignContract, foreignKeyName, fkUrl }, e2);
              });
            });
            const pendingWatch = state._vm.pendingWatch?.[foreignContract];
            if (pendingWatch) {
              state._vm.pendingWatch[foreignContract] = pendingWatch.filter(([, kId]) => kId !== keyId2);
            }
          }
          if (key.name.startsWith("#inviteKey-") && state._vm.invites[key.id]) {
            state._vm.invites[key.id].status = INVITE_STATUS.REVOKED;
          }
        });
        if (Array.isArray(state._volatile?.watch)) {
          const updatedKeysMap = /* @__PURE__ */ Object.create(null);
          keyIds.forEach((keyId2) => {
            updatedKeysMap[state._vm.authorizedKeys[keyId2].name] = {
              name: state._vm.authorizedKeys[keyId2].name,
              oldKeyId: keyId2
            };
          });
          keyRotationHelper(contractID, state, config, updatedKeysMap, [SPMessage.OP_KEY_DEL], "chelonia/out/keyDel", (name) => updatedKeysMap[name[0]].oldKeyId, internalSideEffectStack);
        }
      },
      [SPMessage.OP_KEY_UPDATE](v2) {
        if (!state._volatile)
          state._volatile = /* @__PURE__ */ Object.create(null);
        if (!state._volatile.pendingKeyRevocations) {
          state._volatile.pendingKeyRevocations = /* @__PURE__ */ Object.create(null);
        }
        const [updatedKeys, updatedMap] = validateKeyUpdatePermissions.call(self2, contractID, signingKey, state, v2);
        const keysToDelete = Object.values(updatedMap);
        for (const keyId2 of keysToDelete) {
          if (has(state._volatile.pendingKeyRevocations, keyId2)) {
            delete state._volatile.pendingKeyRevocations[keyId2];
          }
          state._vm.authorizedKeys[keyId2]._notAfterHeight = height;
        }
        for (const key of updatedKeys) {
          if (!has(state._vm.authorizedKeys, key.id)) {
            key._notBeforeHeight = height;
            state._vm.authorizedKeys[key.id] = cloneDeep(key);
          }
        }
        keyAdditionProcessor.call(self2, message, hash2, updatedKeys, state, contractID, signingKey, internalSideEffectStack);
        if (Array.isArray(state._volatile?.watch)) {
          const updatedKeysMap = /* @__PURE__ */ Object.create(null);
          updatedKeys.forEach((key) => {
            if (key.data) {
              updatedKeysMap[key.name] = cloneDeep(key);
              updatedKeysMap[key.name].oldKeyId = updatedMap[key.id];
            }
          });
          keyRotationHelper(contractID, state, config, updatedKeysMap, [SPMessage.OP_KEY_UPDATE], "chelonia/out/keyUpdate", (name) => ({
            name: name[1],
            oldKeyId: updatedKeysMap[name[0]].oldKeyId,
            id: updatedKeysMap[name[0]].id,
            data: updatedKeysMap[name[0]].data
          }), internalSideEffectStack);
        }
      },
      [SPMessage.OP_PROTOCOL_UPGRADE]: notImplemented
    };
    if (!this.config.skipActionProcessing && !this.manifestToContract[manifestHash]) {
      const rootState = esm_default(this.config.stateSelector);
      if (!contractName) {
        contractName = has(rootState.contracts, contractID) && rootState.contracts[contractID] && has(rootState.contracts[contractID], "type") ? rootState.contracts[contractID].type : opT === SPMessage.OP_CONTRACT ? opV.type : "";
      }
      if (!contractName) {
        throw new Error(`Unable to determine the name for a contract and refusing to load it (contract ID was ${contractID} and its manifest hash was ${manifestHash})`);
      }
      await esm_default("chelonia/private/loadManifest", contractName, manifestHash);
    }
    let processOp = true;
    if (config.preOp) {
      processOp = config.preOp(message, state) !== false && processOp;
    }
    let signingKey;
    {
      const stateForValidation = opT === SPMessage.OP_CONTRACT && !state?._vm?.authorizedKeys ? {
        _vm: {
          authorizedKeys: keysToMap.call(this, opV.keys, height)
        }
      } : state;
      if (!validateKeyPermissions(message, config, stateForValidation, signingKeyId, opT, opV)) {
        throw new Error("No matching signing key was defined");
      }
      signingKey = stateForValidation._vm.authorizedKeys[signingKeyId];
    }
    if (config[`preOp_${opT}`]) {
      processOp = config[`preOp_${opT}`](message, state) !== false && processOp;
    }
    if (processOp) {
      await opFns[opT](opV);
      config.postOp?.(message, state);
      config[`postOp_${opT}`]?.(message, state);
    }
  },
  "chelonia/private/in/enqueueHandleEvent": function(contractID, event) {
    return esm_default("chelonia/private/queueEvent", contractID, async () => {
      await esm_default("chelonia/private/in/handleEvent", contractID, event);
      esm_default("chelonia/private/enqueuePostSyncOps", contractID);
    });
  },
  "chelonia/private/in/syncContract": async function(contractID, params) {
    const state = esm_default(this.config.stateSelector);
    if (state.contracts[contractID] === null) {
      throw new ChelErrorResourceGone("Cannot sync permanently deleted contract " + contractID);
    }
    try {
      this.currentSyncs[contractID] = { firstSync: !state.contracts[contractID]?.type };
      esm_default("okTurtles.events/emit", CONTRACT_IS_SYNCING, contractID, true);
      const currentVolatileState = state[contractID]?._volatile || /* @__PURE__ */ Object.create(null);
      if (currentVolatileState?.dirty || params?.resync) {
        delete currentVolatileState.dirty;
        currentVolatileState.resyncing = true;
        esm_default("chelonia/private/removeImmediately", contractID, { resync: true });
        this.config.reactiveSet(state, contractID, /* @__PURE__ */ Object.create(null));
        this.config.reactiveSet(state[contractID], "_volatile", currentVolatileState);
      }
      const { HEAD: latestHEAD } = await esm_default("chelonia/out/latestHEADInfo", contractID);
      console.debug(`[chelonia] syncContract: ${contractID} latestHash is: ${latestHEAD}`);
      const { HEAD: recentHEAD, height: recentHeight } = state.contracts[contractID] || {};
      const isSubscribed = this.subscriptionSet.has(contractID);
      if (!isSubscribed) {
        const entry = this.pending.find((entry2) => entry2?.contractID === contractID);
        if (!entry) {
          this.pending.push({ contractID });
        }
      }
      this.postSyncOperations[contractID] = this.postSyncOperations[contractID] ?? /* @__PURE__ */ Object.create(null);
      if (latestHEAD !== recentHEAD) {
        console.debug(`[chelonia] Synchronizing Contract ${contractID}: our recent was ${recentHEAD || "undefined"} but the latest is ${latestHEAD}`);
        const eventsStream = esm_default("chelonia/out/eventsAfter", contractID, {
          sinceHeight: recentHeight ?? 0,
          sinceHash: recentHEAD ?? contractID
        });
        let latestHashFound = false;
        const eventReader = eventsStream.getReader();
        for (let skip = has(state.contracts, contractID) && has(state.contracts[contractID], "HEAD"); ; skip = false) {
          const { done, value: event } = await eventReader.read();
          if (done) {
            if (!latestHashFound) {
              throw new ChelErrorForkedChain(`expected hash ${latestHEAD} in list of events for contract ${contractID}`);
            }
            break;
          }
          if (!latestHashFound) {
            latestHashFound = SPMessage.deserializeHEAD(event).hash === latestHEAD;
          }
          if (skip)
            continue;
          await esm_default("chelonia/private/in/handleEvent", contractID, event);
        }
      } else if (!isSubscribed) {
        this.subscriptionSet.add(contractID);
        esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
          added: [contractID],
          removed: []
        });
        const entryIndex = this.pending.findIndex((entry) => entry?.contractID === contractID);
        if (entryIndex !== -1) {
          this.pending.splice(entryIndex, 1);
        }
        console.debug(`[chelonia] added already synchronized ${contractID} to subscription set`);
      } else {
        console.debug(`[chelonia] contract ${contractID} was already synchronized`);
      }
      esm_default("chelonia/private/enqueuePostSyncOps", contractID);
    } catch (e2) {
      console.error(`[chelonia] syncContract error: ${e2.message || e2}`, e2);
      this.config.hooks.syncContractError?.(e2, contractID);
      throw e2;
    } finally {
      if (state[contractID]?._volatile?.resyncing) {
        this.config.reactiveDel(state[contractID]._volatile, "resyncing");
      }
      delete this.currentSyncs[contractID];
      esm_default("okTurtles.events/emit", CONTRACT_IS_SYNCING, contractID, false);
    }
  },
  "chelonia/private/enqueuePostSyncOps": function(contractID) {
    if (!has(this.postSyncOperations, contractID))
      return;
    Object.entries(this.postSyncOperations[contractID]).forEach(([key, op]) => {
      delete this.postSyncOperations[contractID][key];
      esm_default("chelonia/private/queueEvent", contractID, op).catch((e2) => {
        console.error(`Post-sync operation for ${contractID} failed`, { contractID, op, error: e2 });
      });
    });
  },
  "chelonia/private/watchForeignKeys": function(externalContractID) {
    const state = esm_default(this.config.stateSelector);
    const externalContractState = state[externalContractID];
    const pendingWatch = externalContractState?._vm?.pendingWatch;
    if (!pendingWatch || !Object.keys(pendingWatch).length)
      return;
    const signingKey = findSuitableSecretKeyId(externalContractState, [SPMessage.OP_KEY_DEL], ["sig"]);
    const canMirrorOperations = !!signingKey;
    if (!canMirrorOperations) {
      console.info("[chelonia/private/watchForeignKeys]: Returning as operations cannot be mirrored", { externalContractID });
      return;
    }
    Object.entries(pendingWatch).forEach(([contractID, keys]) => {
      if (!Array.isArray(keys) || // Check that the keys exist and haven't been revoked
      !keys.reduce((acc, [, id]) => {
        return acc || has(externalContractState._vm.authorizedKeys, id);
      }, false)) {
        console.info("[chelonia/private/watchForeignKeys]: Skipping as none of the keys to watch exist", {
          externalContractID,
          contractID
        });
        return;
      }
      esm_default("chelonia/private/queueEvent", contractID, [
        "chelonia/private/in/syncContractAndWatchKeys",
        contractID,
        externalContractID
      ]).catch((e2) => {
        console.error(`Error at syncContractAndWatchKeys for contractID ${contractID} and externalContractID ${externalContractID}`, e2);
      });
    });
  },
  "chelonia/private/in/syncContractAndWatchKeys": async function(contractID, externalContractID) {
    const rootState = esm_default(this.config.stateSelector);
    const externalContractState = rootState[externalContractID];
    const pendingWatch = externalContractState?._vm?.pendingWatch?.[contractID]?.splice(0);
    if (!Array.isArray(pendingWatch) || // Check that the keys exist and haven't been revoked
    !pendingWatch.reduce((acc, [, id]) => {
      return acc || has(externalContractState._vm.authorizedKeys, id) && findKeyIdByName(externalContractState, externalContractState._vm.authorizedKeys[id].name) != null;
    }, false)) {
      console.info("[chelonia/private/syncContractAndWatchKeys]: Skipping as none of the keys to watch exist", {
        externalContractID,
        contractID
      });
      return;
    }
    if (!this.subscriptionSet.has(contractID)) {
      await esm_default("chelonia/private/in/syncContract", contractID);
    }
    const contractState = rootState[contractID];
    const keysToDelete = [];
    const keysToUpdate = [];
    pendingWatch.forEach(([keyName, externalId]) => {
      const keyId2 = findKeyIdByName(contractState, keyName);
      if (!keyId2) {
        keysToDelete.push(externalId);
        return;
      } else if (keyId2 !== externalId) {
        keysToUpdate.push(externalId);
      }
      if (!contractState._volatile) {
        this.config.reactiveSet(contractState, "_volatile", Object.create(null, {
          watch: {
            value: [[keyName, externalContractID]],
            configurable: true,
            enumerable: true,
            writable: true
          }
        }));
      } else {
        if (!contractState._volatile.watch) {
          this.config.reactiveSet(contractState._volatile, "watch", [
            [keyName, externalContractID]
          ]);
        }
        if (Array.isArray(contractState._volatile.watch) && !contractState._volatile.watch.find((v2) => v2[0] === keyName && v2[1] === externalContractID)) {
          contractState._volatile.watch.push([keyName, externalContractID]);
        }
      }
    });
    if (keysToDelete.length || keysToUpdate.length) {
      if (!externalContractState._volatile) {
        this.config.reactiveSet(externalContractState, "_volatile", /* @__PURE__ */ Object.create(null));
      }
      if (!externalContractState._volatile.pendingKeyRevocations) {
        this.config.reactiveSet(externalContractState._volatile, "pendingKeyRevocations", /* @__PURE__ */ Object.create(null));
      }
      keysToDelete.forEach((id) => this.config.reactiveSet(externalContractState._volatile.pendingKeyRevocations, id, "del"));
      keysToUpdate.forEach((id) => this.config.reactiveSet(externalContractState._volatile.pendingKeyRevocations, id, true));
      esm_default("chelonia/private/queueEvent", externalContractID, [
        "chelonia/private/deleteOrRotateRevokedKeys",
        externalContractID
      ]).catch((e2) => {
        console.error(`Error at deleteOrRotateRevokedKeys for contractID ${contractID} and externalContractID ${externalContractID}`, e2);
      });
    }
  },
  // The following function gets called when we start watching a contract for
  // foreign keys for the first time, and it ensures that, at the point the
  // watching starts, keys are in sync between the two contracts (later on,
  // this will be handled automatically for incoming OP_KEY_DEL and
  // OP_KEY_UPDATE).
  // For any given foreign key, there are three possible states:
  //   1. The key is in sync with the foreign contract. In this case, there's
  //      nothing left to do.
  //   2. The key has been rotated in the foreign contract (replaced by another
  //      key of the same name). We need to mirror this operation manually
  //      since watching only affects new messages we receive.
  //   3. The key has been removed in the foreign contract. We also need to
  //      mirror the operation.
  "chelonia/private/deleteOrRotateRevokedKeys": function(contractID) {
    const rootState = esm_default(this.config.stateSelector);
    const contractState = rootState[contractID];
    const pendingKeyRevocations = contractState?._volatile?.pendingKeyRevocations;
    if (!pendingKeyRevocations || Object.keys(pendingKeyRevocations).length === 0)
      return;
    const keysToUpdate = Object.entries(pendingKeyRevocations).filter(([, v2]) => v2 === true).map(([id]) => id);
    const [, keyUpdateSigningKeyId, keyUpdateArgs] = keysToUpdate.reduce((acc, keyId2) => {
      const key = contractState._vm?.authorizedKeys?.[keyId2];
      if (!key || !key.foreignKey)
        return acc;
      const foreignKey = String(key.foreignKey);
      const fkUrl = new URL(foreignKey);
      const foreignContractID = fkUrl.pathname;
      const foreignKeyName = fkUrl.searchParams.get("keyName");
      if (!foreignKeyName)
        throw new Error("Missing foreign key name");
      const foreignState = rootState[foreignContractID];
      if (!foreignState)
        return acc;
      const fKeyId = findKeyIdByName(foreignState, foreignKeyName);
      if (!fKeyId) {
        if (pendingKeyRevocations[keyId2] === true) {
          this.config.reactiveSet(pendingKeyRevocations, keyId2, "del");
        }
        return acc;
      }
      const [currentRingLevel, currentSigningKeyId, currentKeyArgs] = acc;
      const ringLevel = Math.min(currentRingLevel, key.ringLevel ?? Number.POSITIVE_INFINITY);
      if (ringLevel >= currentRingLevel) {
        currentKeyArgs.push({
          name: key.name,
          oldKeyId: keyId2,
          id: fKeyId,
          data: foreignState._vm.authorizedKeys[fKeyId].data
        });
        return [currentRingLevel, currentSigningKeyId, currentKeyArgs];
      } else if (Number.isFinite(ringLevel)) {
        const signingKeyId = findSuitableSecretKeyId(contractState, [SPMessage.OP_KEY_UPDATE], ["sig"], ringLevel);
        if (signingKeyId) {
          currentKeyArgs.push({
            name: key.name,
            oldKeyId: keyId2,
            id: fKeyId,
            data: foreignState._vm.authorizedKeys[fKeyId].data
          });
          return [ringLevel, signingKeyId, currentKeyArgs];
        }
      }
      return acc;
    }, [
      Number.POSITIVE_INFINITY,
      "",
      []
    ]);
    if (keyUpdateArgs.length !== 0) {
      const contractName = contractState._vm.type;
      esm_default("chelonia/out/keyUpdate", {
        contractID,
        contractName,
        data: keyUpdateArgs,
        signingKeyId: keyUpdateSigningKeyId
      }).catch((e2) => {
        console.error(`[chelonia/private/deleteOrRotateRevokedKeys] Error sending OP_KEY_UPDATE for ${contractID}`, e2.message);
      });
    }
    const keysToDelete = Object.entries(pendingKeyRevocations).filter(([, v2]) => v2 === "del").map(([id]) => id);
    const [, keyDelSigningKeyId, keyIdsToDelete] = keysToDelete.reduce((acc, keyId2) => {
      const [currentRingLevel, currentSigningKeyId, currentKeyIds] = acc;
      const ringLevel = Math.min(currentRingLevel, contractState._vm?.authorizedKeys?.[keyId2]?.ringLevel ?? Number.POSITIVE_INFINITY);
      if (ringLevel >= currentRingLevel) {
        currentKeyIds.push(keyId2);
        return [currentRingLevel, currentSigningKeyId, currentKeyIds];
      } else if (Number.isFinite(ringLevel)) {
        const signingKeyId = findSuitableSecretKeyId(contractState, [SPMessage.OP_KEY_DEL], ["sig"], ringLevel);
        if (signingKeyId) {
          currentKeyIds.push(keyId2);
          return [ringLevel, signingKeyId, currentKeyIds];
        }
      }
      return acc;
    }, [Number.POSITIVE_INFINITY, "", []]);
    if (keyIdsToDelete.length !== 0) {
      const contractName = contractState._vm.type;
      esm_default("chelonia/out/keyDel", {
        contractID,
        contractName,
        data: keyIdsToDelete,
        signingKeyId: keyDelSigningKeyId
      }).catch((e2) => {
        console.error(`[chelonia/private/deleteRevokedKeys] Error sending OP_KEY_DEL for ${contractID}`, e2.message);
      });
    }
  },
  "chelonia/private/respondToAllKeyRequests": function(contractID) {
    const state = esm_default(this.config.stateSelector);
    const contractState = state[contractID] ?? {};
    const pending = contractState?._vm?.pendingKeyshares;
    if (!pending)
      return;
    const signingKeyId = findSuitableSecretKeyId(contractState, [SPMessage.OP_ATOMIC, SPMessage.OP_KEY_REQUEST_SEEN, SPMessage.OP_KEY_SHARE], ["sig"]);
    if (!signingKeyId) {
      console.log("Unable to respond to key request because there is no suitable secret key with OP_KEY_REQUEST_SEEN permission");
      return;
    }
    Object.entries(pending).map(([hash2, entry]) => {
      if (!Array.isArray(entry) || entry.length !== 4) {
        return void 0;
      }
      const [, , , [originatingContractID]] = entry;
      return esm_default("chelonia/private/queueEvent", originatingContractID, [
        "chelonia/private/respondToKeyRequest",
        contractID,
        signingKeyId,
        hash2
      ]).catch((e2) => {
        console.error(`respondToAllKeyRequests: Error responding to key request ${hash2} from ${originatingContractID} to ${contractID}`, e2);
      });
    });
  },
  "chelonia/private/respondToKeyRequest": async function(contractID, signingKeyId, hash2) {
    const state = esm_default(this.config.stateSelector);
    const contractState = state[contractID];
    const entry = contractState?._vm?.pendingKeyshares?.[hash2];
    const instance = this._instance;
    if (!Array.isArray(entry) || entry.length !== 4) {
      return;
    }
    const [keyShareEncryption, height, , [originatingContractID, rv, originatingContractHeight, headJSON]] = entry;
    entry.pop();
    const krsEncryption = !!contractState._vm.authorizedKeys?.[signingKeyId]?._private;
    await esm_default("chelonia/private/in/syncContract", originatingContractID);
    if (instance !== this._instance)
      return;
    const originatingState = state[originatingContractID];
    const contractName = state.contracts[contractID].type;
    const originatingContractName = originatingState._vm.type;
    const v2 = signedIncomingData(originatingContractID, originatingState, rv, originatingContractHeight, headJSON).valueOf();
    const { encryptionKeyId } = v2;
    const responseKey = encryptedIncomingData(contractID, contractState, v2.responseKey, height, this.transientSecretKeys, headJSON).valueOf();
    const deserializedResponseKey = deserializeKey(responseKey);
    const responseKeyId = keyId(deserializedResponseKey);
    Promise.resolve().then(() => {
      if (instance !== this._instance)
        return;
      if (!has(originatingState._vm.authorizedKeys, responseKeyId) || originatingState._vm.authorizedKeys[responseKeyId]._notAfterHeight != null) {
        throw new Error(`Unable to respond to key request for ${originatingContractID}. Key ${responseKeyId} is not valid.`);
      }
      esm_default("chelonia/storeSecretKeys", new Secret([{ key: deserializedResponseKey }]));
      const keys = pick(state.secretKeys, Object.entries(contractState._vm.authorizedKeys).filter(([, key]) => !!key.meta?.private?.shareable).map(([kId]) => kId));
      if (!keys || Object.keys(keys).length === 0) {
        console.info("respondToAllKeyRequests: no keys to share", {
          contractID,
          originatingContractID
        });
        return;
      }
      const keySharePayload = {
        contractID,
        keys: Object.entries(keys).map(([keyId2, key]) => ({
          id: keyId2,
          meta: {
            private: {
              content: encryptedOutgoingData(originatingContractID, encryptionKeyId, key),
              shareable: true
            }
          }
        })),
        keyRequestHash: hash2,
        keyRequestHeight: height
      };
      if (!contractState?._vm?.pendingKeyshares?.[hash2]) {
        return;
      }
      return keySharePayload;
    }).then((keySharePayload) => {
      if (instance !== this._instance || !keySharePayload)
        return;
      return esm_default("chelonia/out/keyShare", {
        contractID: originatingContractID,
        contractName: originatingContractName,
        data: keyShareEncryption ? encryptedOutgoingData(originatingContractID, findSuitablePublicKeyIds(originatingState, [SPMessage.OP_KEY_SHARE], ["enc"])?.[0] || "", keySharePayload) : keySharePayload,
        signingKeyId: responseKeyId
      }).then((msg) => {
        if (instance !== this._instance)
          return;
        const payload = { keyRequestHash: hash2, keyShareHash: msg.hash(), success: true };
        const connectionKeyPayload = {
          contractID: originatingContractID,
          keys: [
            {
              id: responseKeyId,
              meta: {
                private: {
                  content: encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_REQUEST_SEEN], ["enc"])?.[0] || "", responseKey),
                  shareable: true
                }
              }
            }
          ]
        };
        esm_default("chelonia/out/atomic", {
          contractID,
          contractName,
          signingKeyId,
          data: [
            [
              "chelonia/out/keyRequestResponse",
              {
                data: krsEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_REQUEST_SEEN], ["enc"])?.[0] || "", payload) : payload
              }
            ],
            [
              // Upon successful key share, we want to share deserializedResponseKey
              // with ourselves
              "chelonia/out/keyShare",
              {
                data: keyShareEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_SHARE], ["enc"])?.[0] || "", connectionKeyPayload) : connectionKeyPayload
              }
            ]
          ]
        }).catch((e2) => {
          console.error("Error at respondToKeyRequest while sending keyRequestResponse", e2);
        });
      });
    }).catch((e2) => {
      console.error("Error at respondToKeyRequest", e2);
      const payload = { keyRequestHash: hash2, success: false };
      if (!contractState?._vm?.pendingKeyshares?.[hash2]) {
        return;
      }
      esm_default("chelonia/out/keyRequestResponse", {
        contractID,
        contractName,
        signingKeyId,
        data: krsEncryption ? encryptedOutgoingData(contractID, findSuitablePublicKeyIds(contractState, [SPMessage.OP_KEY_REQUEST_SEEN], ["enc"])?.[0] || "", payload) : payload
      }).catch((e3) => {
        console.error("Error at respondToKeyRequest while sending keyRequestResponse in error handler", e3);
      });
    });
  },
  "chelonia/private/in/handleEvent": async function(contractID, rawMessage) {
    const state = esm_default(this.config.stateSelector);
    const { preHandleEvent, postHandleEvent, handleEventError } = this.config.hooks;
    let processingErrored = false;
    let message;
    try {
      if (!this.config.acceptAllMessages && !this.pending.some((entry) => entry?.contractID === contractID) && !this.subscriptionSet.has(contractID)) {
        console.warn(`[chelonia] WARN: ignoring unexpected event for ${contractID}:`, rawMessage);
        return;
      }
      const contractStateCopy = state[contractID] ? cloneDeep(state[contractID]) : /* @__PURE__ */ Object.create(null);
      message = SPMessage.deserialize(rawMessage, this.transientSecretKeys, contractStateCopy, this.config.unwrapMaybeEncryptedData);
      if (message.contractID() !== contractID) {
        throw new Error(`[chelonia] Wrong contract ID. Expected ${contractID} but got ${message.contractID()}`);
      }
      if (!message.isFirstMessage() && (!has(state.contracts, contractID) || !has(state, contractID))) {
        throw new ChelErrorUnrecoverable("The event is not for a first message but the contract state is missing");
      }
      preHandleEvent?.(message);
      const proceed = handleEvent.checkMessageOrdering.call(this, message);
      if (proceed === false)
        return;
      if (state[contractID]?._volatile?.dirty) {
        console.info(`[chelonia] Ignoring message ${message.description()} as the contract is marked as dirty`);
        return;
      }
      const internalSideEffectStack = !this.config.skipSideEffects ? [] : void 0;
      missingDecryptionKeyIdsMap.delete(message);
      try {
        await handleEvent.processMutation.call(this, message, contractStateCopy, internalSideEffectStack);
      } catch (e_) {
        const e2 = e_;
        if (e2?.name === "ChelErrorDecryptionKeyNotFound") {
          console.warn(`[chelonia] WARN '${e2.name}' in processMutation for ${message.description()}: ${e2.message}`, e2, message.serialize());
          if (e2.cause) {
            const missingDecryptionKeyIds = missingDecryptionKeyIdsMap.get(message);
            if (missingDecryptionKeyIds) {
              missingDecryptionKeyIds.add(e2.cause);
            } else {
              missingDecryptionKeyIdsMap.set(message, /* @__PURE__ */ new Set([e2.cause]));
            }
          }
        } else {
          console.error(`[chelonia] ERROR '${e2.name}' in processMutation for ${message.description()}: ${e2.message || e2}`, e2, message.serialize());
        }
        console.warn(`[chelonia] Error processing ${message.description()}: ${message.serialize()}. Any side effects will be skipped!`);
        if (this.config.strictProcessing) {
          throw e2;
        }
        processingErrored = e2?.name !== "ChelErrorWarning";
        this.config.hooks.processError?.(e2, message, getMsgMeta.call(this, message, contractID, contractStateCopy));
        if (e2.name === "ChelErrorUnrecoverable" || e2.name === "ChelErrorForkedChain" || message.isFirstMessage()) {
          throw e2;
        }
      }
      if (!processingErrored) {
        if (Array.isArray(internalSideEffectStack) && internalSideEffectStack.length > 0) {
          await Promise.all(internalSideEffectStack.map((fn) => Promise.resolve(fn({ state: contractStateCopy, message })).catch((e_) => {
            const e2 = e_;
            console.error(`[chelonia] ERROR '${e2.name}' in internal side effect for ${message.description()}: ${e2.message}`, e2, { message: message.serialize() });
          })));
        }
        if (!this.config.skipActionProcessing && !this.config.skipSideEffects) {
          await handleEvent.processSideEffects.call(this, message, contractStateCopy)?.catch((e_) => {
            const e2 = e_;
            console.error(`[chelonia] ERROR '${e2.name}' in sideEffect for ${message.description()}: ${e2.message}`, e2, { message: message.serialize() });
            this.config.hooks.sideEffectError?.(e2, message);
          });
        }
      }
      try {
        const state2 = esm_default(this.config.stateSelector);
        await handleEvent.applyProcessResult.call(this, {
          message,
          state: state2,
          contractState: contractStateCopy,
          processingErrored,
          postHandleEvent
        });
      } catch (e_) {
        const e2 = e_;
        console.error(`[chelonia] ERROR '${e2.name}' for ${message.description()} marking the event as processed: ${e2.message}`, e2, { message: message.serialize() });
      }
    } catch (e_) {
      const e2 = e_;
      console.error(`[chelonia] ERROR in handleEvent: ${e2.message || e2}`, e2);
      try {
        handleEventError?.(e2, message);
      } catch (e22) {
        console.error("[chelonia] Ignoring user error in handleEventError hook:", e22);
      }
      throw e2;
    } finally {
      if (message) {
        missingDecryptionKeyIdsMap.delete(message);
      }
    }
  }
});
var eventsToReingest = [];
var reprocessDebounced = debounce((contractID) => esm_default("chelonia/private/out/sync", contractID, { force: true }).catch((e2) => {
  console.error(`[chelonia] Error at reprocessDebounced for ${contractID}`, e2);
}), 1e3);
var handleEvent = {
  checkMessageOrdering(message) {
    const contractID = message.contractID();
    const hash2 = message.hash();
    const height = message.height();
    const state = esm_default(this.config.stateSelector);
    const latestProcessedHeight = state.contracts[contractID]?.height;
    if (!Number.isSafeInteger(height)) {
      throw new ChelErrorDBBadPreviousHEAD(`Message ${hash2} in contract ${contractID} has an invalid height.`);
    }
    if (message.isFirstMessage() ? latestProcessedHeight != null : !(latestProcessedHeight < height)) {
      if (!this.config.strictOrdering) {
        return false;
      }
      throw new ChelErrorAlreadyProcessed(`Message ${hash2} with height ${height} in contract ${contractID} has already been processed. Current height: ${latestProcessedHeight}.`);
    }
    if (latestProcessedHeight + 1 < height) {
      if (this.config.strictOrdering) {
        throw new ChelErrorDBBadPreviousHEAD(`Unexpected message ${hash2} with height ${height} in contract ${contractID}: height is too high. Current height: ${latestProcessedHeight}.`);
      }
      if (eventsToReingest.length > 100) {
        throw new ChelErrorUnrecoverable("more than 100 different bad previousHEAD errors");
      }
      if (!eventsToReingest.includes(hash2)) {
        console.warn(`[chelonia] WARN bad previousHEAD for ${message.description()}, will attempt to re-sync contract to reingest message`);
        eventsToReingest.push(hash2);
        reprocessDebounced(contractID);
        return false;
      } else {
        console.error(`[chelonia] ERROR already attempted to reingest ${message.description()}, will not attempt again!`);
        throw new ChelErrorDBBadPreviousHEAD(`Already attempted to reingest ${hash2}`);
      }
    }
    const reprocessIdx = eventsToReingest.indexOf(hash2);
    if (reprocessIdx !== -1) {
      console.warn(`[chelonia] WARN: successfully reingested ${message.description()}`);
      eventsToReingest.splice(reprocessIdx, 1);
    }
  },
  async processMutation(message, state, internalSideEffectStack) {
    const contractID = message.contractID();
    if (message.isFirstMessage()) {
      if (Object.keys(state).some((k) => k !== "_volatile")) {
        throw new ChelErrorUnrecoverable(`state for ${contractID} is already set`);
      }
    }
    await esm_default("chelonia/private/in/processMessage", message, state, internalSideEffectStack);
  },
  processSideEffects(message, state) {
    const opT = message.opType();
    if (![
      SPMessage.OP_ATOMIC,
      SPMessage.OP_ACTION_ENCRYPTED,
      SPMessage.OP_ACTION_UNENCRYPTED
    ].includes(opT)) {
      return;
    }
    const contractID = message.contractID();
    const manifestHash = message.manifest();
    const hash2 = message.hash();
    const height = message.height();
    const signingKeyId = message.signingKeyId();
    const callSideEffect = async (field) => {
      const wv = this.config.unwrapMaybeEncryptedData(field);
      if (!wv)
        return;
      let v2 = wv.data;
      let innerSigningKeyId;
      if (isSignedData(v2)) {
        innerSigningKeyId = v2.signingKeyId;
        v2 = v2.valueOf();
      }
      const { action, data, meta } = v2;
      const mutation = {
        data,
        meta,
        hash: hash2,
        height,
        contractID,
        description: message.description(),
        direction: message.direction(),
        signingKeyId,
        get signingContractID() {
          return getContractIDfromKeyId(contractID, signingKeyId, state);
        },
        innerSigningKeyId,
        get innerSigningContractID() {
          return getContractIDfromKeyId(contractID, innerSigningKeyId, state);
        }
      };
      return await esm_default(`${manifestHash}/${action}/sideEffect`, mutation, state);
    };
    const msg = Object(message.message());
    if (opT !== SPMessage.OP_ATOMIC) {
      return callSideEffect(msg);
    }
    const reducer = (acc, [opT2, opV]) => {
      if ([SPMessage.OP_ACTION_ENCRYPTED, SPMessage.OP_ACTION_UNENCRYPTED].includes(opT2)) {
        acc.push(Object(opV));
      }
      return acc;
    };
    const actionsOpV = msg.reduce(reducer, []);
    return Promise.allSettled(actionsOpV.map((action) => callSideEffect(action))).then((results) => {
      const errors = results.filter((r) => r.status === "rejected").map((r) => r.reason);
      if (errors.length > 0) {
        console.error("Side-effect errors", contractID, errors);
        throw new AggregateError(errors, `Error at side effects for ${contractID}`);
      }
    });
  },
  async applyProcessResult({ message, state, contractState, processingErrored, postHandleEvent }) {
    const contractID = message.contractID();
    const hash2 = message.hash();
    const height = message.height();
    await esm_default("chelonia/db/addEntry", message);
    if (!processingErrored) {
      this.config.reactiveSet(state, contractID, contractState);
      try {
        postHandleEvent?.(message);
      } catch (e2) {
        console.error(`[chelonia] ERROR '${e2.name}' for ${message.description()} in event post-handling: ${e2.message}`, e2, { message: message.serialize() });
      }
    }
    if (message.isFirstMessage()) {
      const { type } = message.opValue();
      if (!has(state.contracts, contractID)) {
        this.config.reactiveSet(state.contracts, contractID, /* @__PURE__ */ Object.create(null));
      }
      this.config.reactiveSet(state.contracts[contractID], "type", type);
      console.debug(`contract ${type} registered for ${contractID}`);
    }
    if (message.isKeyOp()) {
      this.config.reactiveSet(state.contracts[contractID], "previousKeyOp", hash2);
    }
    this.config.reactiveSet(state.contracts[contractID], "HEAD", hash2);
    this.config.reactiveSet(state.contracts[contractID], "height", height);
    const missingDecryptionKeyIdsForMessage = missingDecryptionKeyIdsMap.get(message);
    if (missingDecryptionKeyIdsForMessage) {
      let missingDecryptionKeyIds = state.contracts[contractID].missingDecryptionKeyIds;
      if (!missingDecryptionKeyIds) {
        missingDecryptionKeyIds = [];
        this.config.reactiveSet(state.contracts[contractID], "missingDecryptionKeyIds", missingDecryptionKeyIds);
      }
      missingDecryptionKeyIdsForMessage.forEach((keyId2) => {
        if (missingDecryptionKeyIds.includes(keyId2))
          return;
        missingDecryptionKeyIds.push(keyId2);
      });
    }
    if (!this.subscriptionSet.has(contractID)) {
      const entry = this.pending.find((entry2) => entry2?.contractID === contractID);
      if (entry) {
        const index = this.pending.indexOf(entry);
        if (index !== -1) {
          this.pending.splice(index, 1);
        }
      }
      this.subscriptionSet.add(contractID);
      esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
        added: [contractID],
        removed: []
      });
    }
    if (!processingErrored) {
      esm_default("okTurtles.events/emit", hash2, contractID, message);
      esm_default("okTurtles.events/emit", EVENT_HANDLED, contractID, message);
    }
  }
};
var notImplemented = (v2) => {
  throw new Error(`chelonia: action not implemented to handle: ${JSON.stringify(v2)}.`);
};
init_signedData();
init_esm();
var wallBase = Date.now();
var monotonicBase = performance.now();
var resyncTimeout;
var watchdog;
var syncServerTime = async function() {
  const startTime = performance.now();
  const time = await this.config.fetch(`${this.config.connectionURL}/time`, {
    signal: this.abortController.signal
  });
  const requestTimeElapsed = performance.now();
  if (requestTimeElapsed - startTime > 8e3) {
    throw new Error("Error fetching server time: request took too long");
  }
  if (!time.ok)
    throw new Error("Error fetching server time");
  const serverTime = new Date(await time.text()).valueOf();
  if (Number.isNaN(serverTime))
    throw new Error("Unable to parse server time");
  const newMonotonicBase = performance.now();
  wallBase = serverTime + (requestTimeElapsed - startTime) / 2 + // Also take into account the time elapsed between `requestTimeElapsed`
  // and this line (which should be very little)
  (newMonotonicBase - requestTimeElapsed);
  monotonicBase = newMonotonicBase;
};
var time_sync_default = esm_default("sbp/selectors/register", {
  "chelonia/private/startClockSync": function() {
    if (resyncTimeout !== void 0) {
      throw new Error("chelonia/private/startClockSync has already been called");
    }
    const resync = (delay2 = 3e5) => {
      if (resyncTimeout !== null)
        return;
      const timeout = setTimeout(() => {
        syncServerTime.call(this).then(() => {
          if (resyncTimeout === timeout)
            resyncTimeout = null;
          resync();
        }).catch((e2) => {
          if (resyncTimeout === timeout) {
            resyncTimeout = null;
            console.error("Error re-syncing server time; will re-attempt in 5s", e2);
            setTimeout(() => resync(0), 5e3);
          } else {
            console.error("Error re-syncing server time; another attempt is in progress", e2);
          }
        });
      }, delay2);
      resyncTimeout = timeout;
    };
    let wallLast = Date.now();
    let monotonicLast = performance.now();
    watchdog = setInterval(() => {
      const wallNow = Date.now();
      const monotonicNow = performance.now();
      const difference2 = Math.abs(Math.abs(wallNow - wallLast) - Math.abs(monotonicNow - monotonicLast));
      if (difference2 > 10) {
        if (resyncTimeout != null)
          clearTimeout(resyncTimeout);
        resyncTimeout = null;
        resync(0);
      }
      wallLast = wallNow;
      monotonicLast = monotonicNow;
    }, 1e4);
    resyncTimeout = null;
    resync(0);
  },
  "chelonia/private/stopClockSync": () => {
    if (resyncTimeout !== void 0) {
      if (watchdog != null)
        clearInterval(watchdog);
      if (resyncTimeout != null)
        clearTimeout(resyncTimeout);
      watchdog = void 0;
      resyncTimeout = void 0;
    }
  },
  // Get an estimate of the server's current time based on the time elapsed as
  // measured locally (using a monotonic clock), which is used as an offset, and
  // a previously retrieved server time. The time value is returned as a UNIX
  // _millisecond_ timestamp (milliseconds since 1 Jan 1970 00:00:00 UTC)
  "chelonia/time": function() {
    const monotonicNow = performance.now();
    const wallNow = wallBase - monotonicBase + monotonicNow;
    return Math.round(wallNow);
  }
});
var ACTION_REGEX = /^((([\w.]+)\/([^/]+))(?:\/(?:([^/]+)\/)?)?)\w*/;
var chelonia_default = esm_default("sbp/selectors/register", {
  // https://www.wordnik.com/words/chelonia
  // https://gitlab.okturtles.org/okturtles/group-income/-/wikis/E2E-Protocol/Framework.md#alt-names
  "chelonia/_init": function() {
    this.config = {
      // TODO: handle connecting to multiple servers for federation
      get connectionURL() {
        throw new Error("Invalid use of connectionURL before initialization");
      },
      // override!
      set connectionURL(value) {
        Object.defineProperty(this, "connectionURL", { value, writable: true });
      },
      stateSelector: "chelonia/private/state",
      // override to integrate with, for example, vuex
      contracts: {
        defaults: {
          modules: {},
          // '<module name>' => resolved module import
          exposedGlobals: {},
          allowedDomains: [],
          allowedSelectors: [],
          preferSlim: false
        },
        overrides: {},
        // override default values per-contract
        manifests: {}
        // override! contract names => manifest hashes
      },
      whitelisted: (action) => !!this.whitelistedActions[action],
      reactiveSet: (obj, key, value) => {
        obj[key] = value;
        return value;
      },
      // example: set to Vue.set
      fetch: (...args) => fetch(...args),
      reactiveDel: (obj, key) => {
        delete obj[key];
      },
      // acceptAllMessages disables checking whether we are expecting a message
      // or not for processing
      acceptAllMessages: false,
      skipActionProcessing: false,
      skipDecryptionAttempts: false,
      skipSideEffects: false,
      // Strict processing will treat all processing errors as unrecoverable
      // This is useful, e.g., in the server, to prevent invalid messages from
      // being added to the database
      strictProcessing: false,
      // Strict ordering will throw on past events with ChelErrorAlreadyProcessed
      // Similarly, future events will not be reingested and will throw
      // with ChelErrorDBBadPreviousHEAD
      strictOrdering: false,
      connectionOptions: {
        maxRetries: Infinity,
        // See https://github.com/okTurtles/group-income/issues/1183
        reconnectOnTimeout: true
        // can be enabled since we are not doing auth via web sockets
      },
      hooks: {
        preHandleEvent: null,
        // async (message: SPMessage) => {}
        postHandleEvent: null,
        // async (message: SPMessage) => {}
        processError: null,
        // (e: Error, message: SPMessage) => {}
        sideEffectError: null,
        // (e: Error, message: SPMessage) => {}
        handleEventError: null,
        // (e: Error, message: SPMessage) => {}
        syncContractError: null,
        // (e: Error, contractID: string) => {}
        pubsubError: null
        // (e:Error, socket: Socket)
      },
      unwrapMaybeEncryptedData
    };
    this._instance = /* @__PURE__ */ Object.create(null);
    this.abortController = new AbortController();
    this.state = {
      contracts: {},
      // contractIDs => { type, HEAD } (contracts we've subscribed to)
      pending: []
      // prevents processing unexpected data from a malicious server
    };
    this.manifestToContract = {};
    this.whitelistedActions = {};
    this.currentSyncs = /* @__PURE__ */ Object.create(null);
    this.postSyncOperations = /* @__PURE__ */ Object.create(null);
    this.sideEffectStacks = /* @__PURE__ */ Object.create(null);
    this.sideEffectStack = (contractID) => {
      let stack = this.sideEffectStacks[contractID];
      if (!stack) {
        this.sideEffectStacks[contractID] = stack = [];
      }
      return stack;
    };
    this.setPostSyncOp = (contractID, key, op) => {
      this.postSyncOperations[contractID] = this.postSyncOperations[contractID] || /* @__PURE__ */ Object.create(null);
      this.postSyncOperations[contractID][key] = op;
    };
    const secretKeyGetter = (o2, p) => {
      if (has(o2, p))
        return o2[p];
      const rootState = esm_default(this.config.stateSelector);
      if (rootState?.secretKeys && has(rootState.secretKeys, p)) {
        const key = deserializeKey(rootState.secretKeys[p]);
        o2[p] = key;
        return key;
      }
    };
    const secretKeyList = (o2) => {
      const rootState = esm_default(this.config.stateSelector);
      const stateKeys = Object.keys(rootState?.secretKeys || {});
      return Array.from(/* @__PURE__ */ new Set([...Object.keys(o2), ...stateKeys]));
    };
    this.transientSecretKeys = new Proxy(/* @__PURE__ */ Object.create(null), {
      get: secretKeyGetter,
      ownKeys: secretKeyList
    });
    this.ephemeralReferenceCount = /* @__PURE__ */ Object.create(null);
    this.subscriptionSet = /* @__PURE__ */ new Set();
    this.pending = [];
  },
  "chelonia/config": function() {
    return {
      ...cloneDeep(this.config),
      fetch: this.config.fetch,
      reactiveSet: this.config.reactiveSet,
      reactiveDel: this.config.reactiveDel
    };
  },
  "chelonia/configure": async function(config) {
    merge(this.config, config);
    Object.assign(this.config.hooks, config.hooks || {});
    if (config.contracts) {
      Object.assign(this.config.contracts.defaults, config.contracts.defaults || {});
      const manifests = this.config.contracts.manifests;
      console.debug("[chelonia] preloading manifests:", Object.keys(manifests));
      for (const contractName in manifests) {
        await esm_default("chelonia/private/loadManifest", contractName, manifests[contractName]);
      }
    }
    if (has(config, "skipDecryptionAttempts")) {
      if (config.skipDecryptionAttempts) {
        this.config.unwrapMaybeEncryptedData = (data) => {
          if (data == null)
            return;
          if (!isEncryptedData(data)) {
            return {
              encryptionKeyId: null,
              data
            };
          }
        };
      } else {
        this.config.unwrapMaybeEncryptedData = unwrapMaybeEncryptedData;
      }
    }
  },
  "chelonia/reset": async function(newState, postCleanupFn) {
    if (typeof newState === "function" && typeof postCleanupFn === "undefined") {
      postCleanupFn = newState;
      newState = void 0;
    }
    if (this.pubsub) {
      esm_default("chelonia/private/stopClockSync");
    }
    Object.keys(this.postSyncOperations).forEach((cID) => {
      esm_default("chelonia/private/enqueuePostSyncOps", cID);
    });
    await esm_default("chelonia/contract/waitPublish");
    await esm_default("chelonia/contract/wait");
    Object.keys(this.postSyncOperations).forEach((cID) => {
      esm_default("chelonia/private/enqueuePostSyncOps", cID);
    });
    await esm_default("chelonia/contract/waitPublish");
    await esm_default("chelonia/contract/wait");
    const result = await postCleanupFn?.();
    const rootState = esm_default(this.config.stateSelector);
    this._instance = /* @__PURE__ */ Object.create(null);
    this.abortController.abort();
    this.abortController = new AbortController();
    reactiveClearObject(rootState, this.config.reactiveDel);
    this.config.reactiveSet(rootState, "contracts", /* @__PURE__ */ Object.create(null));
    clearObject(this.ephemeralReferenceCount);
    this.pending.splice(0);
    clearObject(this.currentSyncs);
    clearObject(this.postSyncOperations);
    clearObject(this.sideEffectStacks);
    const removedContractIDs = Array.from(this.subscriptionSet);
    this.subscriptionSet.clear();
    esm_default("chelonia/clearTransientSecretKeys");
    esm_default("okTurtles.events/emit", CHELONIA_RESET);
    esm_default("okTurtles.events/emit", CONTRACTS_MODIFIED, Array.from(this.subscriptionSet), {
      added: [],
      removed: removedContractIDs
    });
    if (this.pubsub) {
      esm_default("chelonia/private/startClockSync");
    }
    if (newState) {
      Object.entries(newState).forEach(([key, value]) => {
        this.config.reactiveSet(rootState, key, value);
      });
    }
    return result;
  },
  "chelonia/storeSecretKeys": function(wkeys) {
    const rootState = esm_default(this.config.stateSelector);
    if (!rootState.secretKeys) {
      this.config.reactiveSet(rootState, "secretKeys", /* @__PURE__ */ Object.create(null));
    }
    let keys = wkeys.valueOf();
    if (!keys)
      return;
    if (!Array.isArray(keys))
      keys = [keys];
    keys.forEach(({ key, transient }) => {
      if (!key)
        return;
      if (typeof key === "string") {
        key = deserializeKey(key);
      }
      const id = keyId(key);
      if (!has(this.transientSecretKeys, id)) {
        this.transientSecretKeys[id] = key;
      }
      if (transient)
        return;
      if (!has(rootState.secretKeys, id)) {
        this.config.reactiveSet(rootState.secretKeys, id, serializeKey(key, true));
      }
    });
  },
  "chelonia/clearTransientSecretKeys": function(ids) {
    if (Array.isArray(ids)) {
      ids.forEach((id) => {
        delete this.transientSecretKeys[id];
      });
    } else {
      Object.keys(this.transientSecretKeys).forEach((id) => {
        delete this.transientSecretKeys[id];
      });
    }
  },
  "chelonia/haveSecretKey": function(keyId2, persistent) {
    if (!persistent && has(this.transientSecretKeys, keyId2))
      return true;
    const rootState = esm_default(this.config.stateSelector);
    return !!rootState?.secretKeys && has(rootState.secretKeys, keyId2);
  },
  "chelonia/contract/isResyncing": function(contractIDOrState) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    return !!contractIDOrState?._volatile?.dirty || !!contractIDOrState?._volatile?.resyncing;
  },
  "chelonia/contract/hasKeyShareBeenRespondedBy": function(contractIDOrState, requestedToContractID, reference) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const result = Object.values(contractIDOrState?._vm.authorizedKeys || {}).some((r) => {
      return r?.meta?.keyRequest?.responded && r.meta.keyRequest.contractID === requestedToContractID && (!reference || r.meta.keyRequest.reference === reference);
    });
    return result;
  },
  "chelonia/contract/waitingForKeyShareTo": function(contractIDOrState, requestingContractID, reference) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const result = contractIDOrState._volatile?.pendingKeyRequests?.filter((r) => {
      return r && (!requestingContractID || r.contractID === requestingContractID) && (!reference || r.reference === reference);
    })?.map(({ name }) => name);
    if (!result?.length)
      return null;
    return result;
  },
  "chelonia/contract/successfulKeySharesByContractID": function(contractIDOrState, requestingContractID) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const keyShares = Object.values(contractIDOrState._vm.keyshares || {});
    if (!keyShares?.length)
      return;
    const result = /* @__PURE__ */ Object.create(null);
    keyShares.forEach((kS) => {
      if (!kS.success)
        return;
      if (requestingContractID && kS.contractID !== requestingContractID)
        return;
      if (!result[kS.contractID])
        result[kS.contractID] = [];
      result[kS.contractID].push({ height: kS.height, hash: kS.hash });
    });
    Object.keys(result).forEach((cID) => {
      result[cID].sort((a, b) => {
        return b.height - a.height;
      });
    });
    return result;
  },
  "chelonia/contract/hasKeysToPerformOperation": function(contractIDOrState, operation) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const op = operation !== "*" ? [operation] : operation;
    return !!findSuitableSecretKeyId(contractIDOrState, op, ["sig"]);
  },
  // Did sourceContractIDOrState receive an OP_KEY_SHARE to perform the given
  // operation on contractIDOrState?
  "chelonia/contract/receivedKeysToPerformOperation": function(sourceContractIDOrState, contractIDOrState, operation) {
    const rootState = esm_default(this.config.stateSelector);
    if (typeof sourceContractIDOrState === "string") {
      sourceContractIDOrState = rootState[sourceContractIDOrState];
    }
    if (typeof contractIDOrState === "string") {
      contractIDOrState = rootState[contractIDOrState];
    }
    const op = operation !== "*" ? [operation] : operation;
    const keyId2 = findSuitableSecretKeyId(contractIDOrState, op, ["sig"]);
    return sourceContractIDOrState?._vm?.sharedKeyIds?.some((sK) => sK.id === keyId2);
  },
  "chelonia/contract/currentKeyIdByName": function(contractIDOrState, name, requireSecretKey) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const currentKeyId = findKeyIdByName(contractIDOrState, name);
    if (requireSecretKey && !esm_default("chelonia/haveSecretKey", currentKeyId)) {
      return;
    }
    return currentKeyId;
  },
  "chelonia/contract/foreignKeysByContractID": function(contractIDOrState, foreignContractID) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    return findForeignKeysByContractID(contractIDOrState, foreignContractID);
  },
  "chelonia/contract/historicalKeyIdsByName": function(contractIDOrState, name) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const currentKeyId = findKeyIdByName(contractIDOrState, name);
    const revokedKeyIds = findRevokedKeyIdsByName(contractIDOrState, name);
    return currentKeyId ? [currentKeyId, ...revokedKeyIds] : revokedKeyIds;
  },
  "chelonia/contract/suitableSigningKey": function(contractIDOrState, permissions, purposes, ringLevel, allowedActions) {
    if (typeof contractIDOrState === "string") {
      const rootState = esm_default(this.config.stateSelector);
      contractIDOrState = rootState[contractIDOrState];
    }
    const keyId2 = findSuitableSecretKeyId(contractIDOrState, permissions, purposes, ringLevel, allowedActions);
    return keyId2;
  },
  "chelonia/contract/setPendingKeyRevocation": function(contractID, names) {
    const rootState = esm_default(this.config.stateSelector);
    const state = rootState[contractID];
    if (!state._volatile)
      this.config.reactiveSet(state, "_volatile", /* @__PURE__ */ Object.create(null));
    if (!state._volatile.pendingKeyRevocations) {
      this.config.reactiveSet(state._volatile, "pendingKeyRevocations", /* @__PURE__ */ Object.create(null));
    }
    for (const name of names) {
      const keyId2 = findKeyIdByName(state, name);
      if (keyId2) {
        this.config.reactiveSet(state._volatile.pendingKeyRevocations, keyId2, true);
      } else {
        console.warn("[setPendingKeyRevocation] Unable to find keyId for name", {
          contractID,
          name
        });
      }
    }
  },
  "chelonia/shelterAuthorizationHeader"(contractID) {
    return buildShelterAuthorizationHeader.call(this, contractID);
  },
  // The purpose of the 'chelonia/crypto/*' selectors is so that they can be called
  // from contracts without including the crypto code (i.e., importing crypto.js)
  // This function takes a function as a parameter that returns a string
  // It does not a string directly to prevent accidentally logging the value,
  // which is a secret
  "chelonia/crypto/keyId": (inKey) => {
    return keyId(inKey.valueOf());
  },
  // TODO: allow connecting to multiple servers at once
  "chelonia/connect": function(options2 = {}) {
    if (!this.config.connectionURL)
      throw new Error("config.connectionURL missing");
    if (!this.config.connectionOptions)
      throw new Error("config.connectionOptions missing");
    if (this.pubsub) {
      this.pubsub.destroy();
    }
    let pubsubURL = this.config.connectionURL;
    if (true) {
      pubsubURL += `?debugID=${randomHexString(6)}`;
    }
    if (this.pubsub) {
      esm_default("chelonia/private/stopClockSync");
    }
    esm_default("chelonia/private/startClockSync");
    this.pubsub = createClient(pubsubURL, {
      ...this.config.connectionOptions,
      handlers: {
        ...options2.handlers,
        // Every time we get a REQUEST_TYPE.SUB response, which happens for
        // 'new' subscriptions as well as every time the connection is reset
        "subscription-succeeded": function(event) {
          const { channelID } = event.detail;
          if (this.subscriptionSet.has(channelID)) {
            esm_default("chelonia/private/out/sync", channelID, { force: true }).catch((err) => {
              console.warn(`[chelonia] Syncing contract ${channelID} failed: ${err.message}`);
            });
          }
          options2.handlers?.["subscription-succeeded"]?.call(this, event);
        }
      },
      // Map message handlers to transparently handle encryption and signatures
      messageHandlers: {
        ...Object.fromEntries(Object.entries(options2.messageHandlers || {}).map(([k, v2]) => {
          switch (k) {
            case NOTIFICATION_TYPE.PUB:
              return [
                k,
                (msg) => {
                  if (!msg.channelID) {
                    console.info("[chelonia] Discarding pub event without channelID");
                    return;
                  }
                  if (!this.subscriptionSet.has(msg.channelID)) {
                    console.info(`[chelonia] Discarding pub event for ${msg.channelID} because it's not in the current subscriptionSet`);
                    return;
                  }
                  esm_default("chelonia/queueInvocation", msg.channelID, () => {
                    v2.call(this.pubsub, parseEncryptedOrUnencryptedMessage(this, {
                      contractID: msg.channelID,
                      serializedData: msg.data
                    }));
                  }).catch((e2) => {
                    console.error(`[chelonia] Error processing pub event for ${msg.channelID}`, e2);
                  });
                }
              ];
            case NOTIFICATION_TYPE.KV:
              return [
                k,
                (msg) => {
                  if (!msg.channelID || !msg.key) {
                    console.info("[chelonia] Discarding kv event without channelID or key");
                    return;
                  }
                  if (!this.subscriptionSet.has(msg.channelID)) {
                    console.info(`[chelonia] Discarding kv event for ${msg.channelID} because it's not in the current subscriptionSet`);
                    return;
                  }
                  esm_default("chelonia/queueInvocation", msg.channelID, () => {
                    v2.call(this.pubsub, [
                      msg.key,
                      parseEncryptedOrUnencryptedMessage(this, {
                        contractID: msg.channelID,
                        meta: msg.key,
                        serializedData: JSON.parse(Buffer6.from(msg.data).toString())
                      })
                    ]);
                  }).catch((e2) => {
                    console.error(`[chelonia] Error processing kv event for ${msg.channelID} and key ${msg.key}`, msg, e2);
                  });
                }
              ];
            case NOTIFICATION_TYPE.DELETION:
              return [
                k,
                (msg) => v2.call(this.pubsub, msg.data)
              ];
            default:
              return [k, v2];
          }
        })),
        [NOTIFICATION_TYPE.ENTRY](msg) {
          const { contractID } = SPMessage.deserializeHEAD(msg.data);
          esm_default("chelonia/private/in/enqueueHandleEvent", contractID, msg.data);
        }
      }
    });
    if (!this.contractsModifiedListener) {
      this.contractsModifiedListener = () => esm_default("chelonia/pubsub/update");
      esm_default("okTurtles.events/on", CONTRACTS_MODIFIED, this.contractsModifiedListener);
    }
    return this.pubsub;
  },
  // This selector is defined primarily for ingesting web push notifications,
  // although it can be used as a general-purpose API to process events received
  // from other external sources that are not managed by Chelonia itself (i.e. sources
  // other than the Chelonia-managed websocket connection and RESTful API).
  "chelonia/handleEvent": async function(event) {
    const { contractID } = SPMessage.deserializeHEAD(event);
    return await esm_default("chelonia/private/in/enqueueHandleEvent", contractID, event);
  },
  "chelonia/defineContract": function(contract) {
    if (!ACTION_REGEX.exec(contract.name))
      throw new Error(`bad contract name: ${contract.name}`);
    if (!contract.metadata)
      contract.metadata = { validate() {
      }, create: () => ({}) };
    if (!contract.getters)
      contract.getters = {};
    contract.state = (contractID) => esm_default(this.config.stateSelector)[contractID];
    contract.manifest = this.defContractManifest;
    contract.sbp = this.defContractSBP;
    this.defContractSelectors = [];
    this.defContract = contract;
    this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
      // expose getters for Vuex integration and other conveniences
      [`${contract.manifest}/${contract.name}/getters`]: () => contract.getters,
      // 2 ways to cause sideEffects to happen: by defining a sideEffect function in the
      // contract, or by calling /pushSideEffect w/async SBP call. Can also do both.
      [`${contract.manifest}/${contract.name}/pushSideEffect`]: (contractID, asyncSbpCall) => {
        const [sel] = asyncSbpCall;
        if (sel.startsWith(contract.name + "/")) {
          asyncSbpCall[0] = `${contract.manifest}/${sel}`;
        }
        this.sideEffectStack(contractID).push(asyncSbpCall);
      }
    }));
    for (const action in contract.actions) {
      contractNameFromAction(action);
      this.whitelistedActions[action] = true;
      this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
        [`${contract.manifest}/${action}/process`]: async (message, state) => {
          const { meta, data, contractID } = message;
          state = state || contract.state(contractID);
          const gProxy = gettersProxy(state, contract.getters);
          await contract.metadata.validate(meta, { state, ...gProxy, contractID });
          await contract.actions[action].validate(data, {
            state,
            ...gProxy,
            meta,
            message,
            contractID
          });
          this.sideEffectStacks[contractID] = [];
          await contract.actions[action].process(message, { state, ...gProxy });
        },
        // 'mutation' is an object that's similar to 'message', but not identical
        [`${contract.manifest}/${action}/sideEffect`]: async (mutation, state) => {
          if (contract.actions[action].sideEffect) {
            state = state || contract.state(mutation.contractID);
            if (!state) {
              console.warn(`[${contract.manifest}/${action}/sideEffect]: Skipping side-effect since there is no contract state for contract ${mutation.contractID}`);
              return;
            }
            const stateCopy = cloneDeep(state);
            const gProxy = gettersProxy(stateCopy, contract.getters);
            await contract.actions[action].sideEffect(mutation, { state: stateCopy, ...gProxy });
          }
          const sideEffects = this.sideEffectStack(mutation.contractID);
          while (sideEffects.length > 0) {
            const sideEffect = sideEffects.shift();
            try {
              await contract.sbp(...sideEffect);
            } catch (e_) {
              const e2 = e_;
              console.error(`[chelonia] ERROR: '${e2.name}' ${e2.message}, for pushed sideEffect of ${mutation.description}:`, sideEffect);
              this.sideEffectStacks[mutation.contractID] = [];
              throw e2;
            }
          }
        }
      }));
    }
    for (const method in contract.methods) {
      this.defContractSelectors.push(...esm_default("sbp/selectors/register", {
        [`${contract.manifest}/${method}`]: contract.methods[method]
      }));
    }
    esm_default("okTurtles.events/emit", CONTRACT_REGISTERED, contract);
  },
  "chelonia/queueInvocation": (contractID, sbpInvocation) => {
    return esm_default("chelonia/private/queueEvent", contractID, ["chelonia/private/noop"]).then(() => esm_default("chelonia/private/queueEvent", "public:" + contractID, sbpInvocation));
  },
  "chelonia/begin": async (...invocations) => {
    for (const invocation of invocations) {
      await esm_default(...invocation);
    }
  },
  // call this manually to resubscribe/unsubscribe from contracts as needed
  // if you are using a custom stateSelector and reload the state (e.g. upon login)
  "chelonia/pubsub/update": function() {
    const client = this.pubsub;
    const subscribedIDs = [...client.subscriptionSet];
    const currentIDs = Array.from(this.subscriptionSet);
    const leaveSubscribed = intersection(subscribedIDs, currentIDs);
    const toUnsubscribe = difference(subscribedIDs, leaveSubscribed);
    const toSubscribe = difference(currentIDs, leaveSubscribed);
    try {
      for (const contractID of toUnsubscribe) {
        client.unsub(contractID);
      }
      for (const contractID of toSubscribe) {
        client.sub(contractID);
      }
    } catch (e2) {
      console.error(`[chelonia] pubsub/update: error ${e2.name}: ${e2.message}`, { toUnsubscribe, toSubscribe }, e2);
      this.config.hooks.pubsubError?.(e2, client);
    }
  },
  // resolves when all pending actions for these contractID(s) finish
  "chelonia/contract/wait": function(contractIDs) {
    const listOfIds = contractIDs ? typeof contractIDs === "string" ? [contractIDs] : contractIDs : Object.keys(esm_default(this.config.stateSelector).contracts);
    return Promise.all(listOfIds.flatMap((cID) => {
      return esm_default("chelonia/queueInvocation", cID, ["chelonia/private/noop"]);
    }));
  },
  // resolves when all pending *writes* for these contractID(s) finish
  "chelonia/contract/waitPublish": function(contractIDs) {
    const listOfIds = contractIDs ? typeof contractIDs === "string" ? [contractIDs] : contractIDs : Object.keys(esm_default(this.config.stateSelector).contracts);
    return Promise.all(listOfIds.flatMap((cID) => {
      return esm_default("chelonia/private/queueEvent", `publish:${cID}`, ["chelonia/private/noop"]);
    }));
  },
  // 'chelonia/contract' - selectors related to injecting remote data and monitoring contracts
  // TODO: add an optional parameter to "retain" the contract (see #828)
  // eslint-disable-next-line require-await
  "chelonia/contract/sync": async function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
    listOfIds.forEach((id) => {
      if (checkCanBeGarbageCollected.call(this, id)) {
        if (process.env.CI) {
          Promise.reject(new Error("[chelonia] Missing reference count for contract " + id));
        }
        console.error("[chelonia] Missing reference count for contract " + id);
        throw new Error("Missing reference count for contract");
      }
    });
    return esm_default("chelonia/private/out/sync", listOfIds, { ...params, force: true });
  },
  "chelonia/contract/isSyncing": function(contractID, { firstSync = false } = {}) {
    const isSyncing = !!this.currentSyncs[contractID];
    return firstSync ? isSyncing && this.currentSyncs[contractID].firstSync : isSyncing;
  },
  "chelonia/contract/currentSyncs": function() {
    return Object.keys(this.currentSyncs);
  },
  // Because `/remove` is done asynchronously and a contract might be removed
  // much later than when the call to remove was made, an optional callback
  // can be passed to verify whether to proceed with removal. This is used as
  // part of the `/release` mechanism to prevent removing contracts that have
  // acquired new references since the call to `/remove`.
  "chelonia/contract/remove": function(contractIDs, { confirmRemovalCallback, permanent } = {}) {
    const rootState = esm_default(this.config.stateSelector);
    const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
    return Promise.all(listOfIds.map((contractID) => {
      if (!rootState?.contracts?.[contractID]) {
        return void 0;
      }
      return esm_default("chelonia/private/queueEvent", contractID, () => {
        if (confirmRemovalCallback && !confirmRemovalCallback(contractID)) {
          return;
        }
        const rootState2 = esm_default(this.config.stateSelector);
        const fkContractIDs = Array.from(new Set(Object.values(rootState2[contractID]?._vm?.authorizedKeys ?? {}).filter((k) => {
          return !!k.foreignKey;
        }).map((k) => {
          try {
            const fkUrl = new URL(k.foreignKey);
            return fkUrl.pathname;
          } catch {
            return void 0;
          }
        }).filter(Boolean)));
        esm_default("chelonia/private/removeImmediately", contractID, { permanent });
        if (fkContractIDs.length) {
          esm_default("chelonia/contract/release", fkContractIDs, { try: true }).catch((e2) => {
            console.error("[chelonia] Error attempting to release foreign key contracts", e2);
          });
        }
      });
    }));
  },
  "chelonia/contract/retain": async function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
    const rootState = esm_default(this.config.stateSelector);
    if (listOfIds.length === 0)
      return Promise.resolve();
    const checkIfDeleted = (id) => {
      if (rootState.contracts[id] === null) {
        console.error("[chelonia/contract/retain] Called /retain on permanently deleted contract.", id);
        throw new ChelErrorResourceGone("Unable to retain permanently deleted contract " + id);
      }
    };
    if (!params?.ephemeral) {
      listOfIds.forEach((id) => {
        checkIfDeleted(id);
        if (!has(rootState.contracts, id)) {
          this.config.reactiveSet(rootState.contracts, id, /* @__PURE__ */ Object.create(null));
        }
        this.config.reactiveSet(rootState.contracts[id], "references", (rootState.contracts[id].references ?? 0) + 1);
      });
    } else {
      listOfIds.forEach((id) => {
        checkIfDeleted(id);
        if (!has(this.ephemeralReferenceCount, id)) {
          this.ephemeralReferenceCount[id] = 1;
        } else {
          this.ephemeralReferenceCount[id] = this.ephemeralReferenceCount[id] + 1;
        }
      });
    }
    return await esm_default("chelonia/private/out/sync", listOfIds);
  },
  // the `try` parameter does not affect (ephemeral or persistent) reference
  // counts, but rather removes a contract if the reference count is zero
  // and the contract isn't being monitored for foreign keys. This parameter
  // is meant mostly for internal chelonia use, so that removing or releasing
  // a contract can also remove other contracts that this first contract
  // was monitoring.
  "chelonia/contract/release": async function(contractIDs, params) {
    const listOfIds = typeof contractIDs === "string" ? [contractIDs] : contractIDs;
    const rootState = esm_default(this.config.stateSelector);
    if (!params?.try) {
      if (!params?.ephemeral) {
        listOfIds.forEach((id) => {
          if (rootState.contracts[id] === null) {
            console.warn("[chelonia/contract/release] Called /release on permanently deleted contract. This has no effect.", id);
            return;
          }
          if (has(rootState.contracts, id) && has(rootState.contracts[id], "references")) {
            const current = rootState.contracts[id].references;
            if (current === 0) {
              console.error("[chelonia/contract/release] Invalid negative reference count for", id);
              if (process.env.CI) {
                Promise.reject(new Error("Invalid negative reference count: " + id));
              }
              throw new Error("Invalid negative reference count");
            }
            if (current <= 1) {
              this.config.reactiveDel(rootState.contracts[id], "references");
            } else {
              this.config.reactiveSet(rootState.contracts[id], "references", current - 1);
            }
          } else {
            console.error("[chelonia/contract/release] Invalid negative reference count for", id);
            if (process.env.CI) {
              Promise.reject(new Error("Invalid negative reference count: " + id));
            }
            throw new Error("Invalid negative reference count");
          }
        });
      } else {
        listOfIds.forEach((id) => {
          if (rootState.contracts[id] === null) {
            console.warn("[chelonia/contract/release] Called /release on permanently deleted contract. This has no effect.", id);
            return;
          }
          if (has(this.ephemeralReferenceCount, id)) {
            const current = this.ephemeralReferenceCount[id] ?? 0;
            if (current <= 1) {
              delete this.ephemeralReferenceCount[id];
            } else {
              this.ephemeralReferenceCount[id] = current - 1;
            }
          } else {
            console.error("[chelonia/contract/release] Invalid negative ephemeral reference count for", id);
            if (process.env.CI) {
              Promise.reject(new Error("Invalid negative ephemeral reference count: " + id));
            }
            throw new Error("Invalid negative ephemeral reference count");
          }
        });
      }
    }
    const boundCheckCanBeGarbageCollected = checkCanBeGarbageCollected.bind(this);
    const idsToRemove = listOfIds.filter(boundCheckCanBeGarbageCollected);
    return idsToRemove.length ? await esm_default("chelonia/contract/remove", idsToRemove, {
      confirmRemovalCallback: boundCheckCanBeGarbageCollected
    }) : void 0;
  },
  "chelonia/contract/disconnect": async function(contractID, contractIDToDisconnect) {
    const state = esm_default(this.config.stateSelector);
    const contractState = state[contractID];
    const keyIds = Object.values(contractState._vm.authorizedKeys).filter((k) => {
      return k._notAfterHeight == null && k.meta?.keyRequest?.contractID === contractIDToDisconnect;
    }).map((k) => k.id);
    if (!keyIds.length)
      return;
    return await esm_default("chelonia/out/keyDel", {
      contractID,
      contractName: contractState._vm.type,
      data: keyIds,
      signingKeyId: findSuitableSecretKeyId(contractState, [SPMessage.OP_KEY_DEL], ["sig"])
    });
  },
  "chelonia/in/processMessage": function(messageOrRawMessage, state) {
    const stateCopy = cloneDeep(state);
    const message = typeof messageOrRawMessage === "string" ? SPMessage.deserialize(messageOrRawMessage, this.transientSecretKeys, stateCopy, this.config.unwrapMaybeEncryptedData) : messageOrRawMessage;
    return esm_default("chelonia/private/in/processMessage", message, stateCopy).then(() => stateCopy).catch((e2) => {
      console.warn(`chelonia/in/processMessage: reverting mutation ${message.description()}: ${message.serialize()}`, e2);
      return state;
    });
  },
  "chelonia/out/fetchResource": async function(cid, { code: code2 } = {}) {
    const parsedCID = parseCID(cid);
    if (code2 != null) {
      if (parsedCID.code !== code2) {
        throw new Error(`Invalid CID content type. Expected ${code2}, got ${parsedCID.code}`);
      }
    }
    const local = await esm_default("chelonia.db/get", cid);
    if (local != null)
      return local;
    const url = `${this.config.connectionURL}/file/${cid}`;
    const data = await this.config.fetch(url, { signal: this.abortController.signal }).then(handleFetchResult("text"));
    const ourHash = createCID(data, parsedCID.code);
    if (ourHash !== cid) {
      throw new Error(`expected hash ${cid}. Got: ${ourHash}`);
    }
    await esm_default("chelonia.db/set", cid, data);
    return data;
  },
  "chelonia/out/latestHEADInfo": function(contractID) {
    return this.config.fetch(`${this.config.connectionURL}/latestHEADinfo/${contractID}`, {
      cache: "no-store",
      signal: this.abortController.signal
    }).then(handleFetchResult("json"));
  },
  "chelonia/out/deserializedHEAD": async function(hash2, { contractID } = {}) {
    const message = await esm_default("chelonia/out/fetchResource", hash2, {
      code: multicodes.SHELTER_CONTRACT_DATA
    });
    const deserializedHEAD = SPMessage.deserializeHEAD(message);
    if (contractID && deserializedHEAD.contractID !== contractID) {
      throw new Error("chelonia/out/deserializedHEAD: Mismatched contract ID");
    }
    return deserializedHEAD;
  },
  "chelonia/out/eventsAfter": eventsAfter,
  "chelonia/out/eventsBefore": function(contractID, { beforeHeight, limit, stream }) {
    if (limit <= 0) {
      console.error('[chelonia] invalid params error: "limit" needs to be positive integer');
    }
    const offset = Math.max(0, beforeHeight - limit + 1);
    const eventsAfterLimit = Math.min(beforeHeight + 1, limit);
    return esm_default("chelonia/out/eventsAfter", contractID, {
      sinceHeight: offset,
      limit: eventsAfterLimit,
      stream
    });
  },
  "chelonia/out/eventsBetween": function(contractID, { startHash, endHeight = Number.POSITIVE_INFINITY, offset = 0, limit = 0, stream = true }) {
    if (offset < 0) {
      console.error('[chelonia] invalid params error: "offset" needs to be positive integer or zero');
      return;
    }
    let reader;
    const s = new ReadableStream({
      start: async (controller) => {
        const deserializedHEAD = await esm_default("chelonia/out/deserializedHEAD", startHash, { contractID });
        const startOffset = Math.max(0, deserializedHEAD.head.height - offset);
        const ourLimit = limit ? Math.min(endHeight - startOffset + 1, limit) : endHeight - startOffset + 1;
        if (ourLimit < 1) {
          controller.close();
          return;
        }
        reader = esm_default("chelonia/out/eventsAfter", contractID, {
          sinceHeight: startOffset,
          limit: ourLimit
        }).getReader();
      },
      async pull(controller) {
        const { done, value } = await reader.read();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      }
    });
    if (stream)
      return s;
    return collectEventStream(s);
  },
  "chelonia/rootState": function() {
    return esm_default(this.config.stateSelector);
  },
  "chelonia/latestContractState": async function(contractID, options2 = { forceSync: false }) {
    const rootState = esm_default(this.config.stateSelector);
    if (rootState.contracts[contractID] === null) {
      throw new ChelErrorResourceGone("Permanently deleted contract " + contractID);
    }
    if (!options2.forceSync && rootState[contractID] && Object.keys(rootState[contractID]).some((x2) => x2 !== "_volatile")) {
      return cloneDeep(rootState[contractID]);
    }
    let state = /* @__PURE__ */ Object.create(null);
    let contractName = rootState.contracts[contractID]?.type;
    const eventsStream = esm_default("chelonia/out/eventsAfter", contractID, {
      sinceHeight: 0,
      sinceHash: contractID
    });
    const eventsStreamReader = eventsStream.getReader();
    if (rootState[contractID])
      state._volatile = rootState[contractID]._volatile;
    for (; ; ) {
      const { value: event, done } = await eventsStreamReader.read();
      if (done)
        return state;
      const stateCopy = cloneDeep(state);
      try {
        await esm_default("chelonia/private/in/processMessage", SPMessage.deserialize(event, this.transientSecretKeys, state, this.config.unwrapMaybeEncryptedData), state, void 0, contractName);
        if (!contractName && state._vm) {
          contractName = state._vm.type;
        }
      } catch (e2) {
        console.warn(`[chelonia] latestContractState: '${e2.name}': ${e2.message} processing:`, event, e2.stack);
        if (e2 instanceof ChelErrorUnrecoverable)
          throw e2;
        state = stateCopy;
      }
    }
  },
  "chelonia/contract/state": function(contractID, height) {
    const state = esm_default(this.config.stateSelector)[contractID];
    const stateCopy = state && cloneDeep(state);
    if (stateCopy?._vm && height != null) {
      Object.keys(stateCopy._vm.authorizedKeys).forEach((keyId2) => {
        if (stateCopy._vm.authorizedKeys[keyId2]._notBeforeHeight > height) {
          delete stateCopy._vm.authorizedKeys[keyId2];
        }
      });
    }
    return stateCopy;
  },
  "chelonia/contract/fullState": function(contractID) {
    const rootState = esm_default(this.config.stateSelector);
    if (Array.isArray(contractID)) {
      return Object.fromEntries(contractID.map((contractID2) => {
        return [
          contractID2,
          {
            contractState: rootState[contractID2],
            cheloniaState: rootState.contracts[contractID2]
          }
        ];
      }));
    }
    return {
      contractState: rootState[contractID],
      cheloniaState: rootState.contracts[contractID]
    };
  },
  // 'chelonia/out' - selectors that send data out to the server
  "chelonia/out/registerContract": async function(params) {
    const { contractName, keys, hooks, publishOptions, signingKeyId, actionSigningKeyId, actionEncryptionKeyId } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contractInfo = this.manifestToContract[manifestHash];
    if (!contractInfo)
      throw new Error(`contract not defined: ${contractName}`);
    const signingKey = this.transientSecretKeys[signingKeyId];
    if (!signingKey)
      throw new Error(`Signing key ${signingKeyId} is not defined`);
    const payload = {
      type: contractName,
      keys
    };
    const contractMsg = SPMessage.createV1_0({
      contractID: null,
      height: 0,
      op: [
        SPMessage.OP_CONTRACT,
        signedOutgoingDataWithRawKey(signingKey, payload)
      ],
      manifest: manifestHash
    });
    const contractID = contractMsg.hash();
    await esm_default("chelonia/private/out/publishEvent", contractMsg, params.namespaceRegistration ? {
      ...publishOptions,
      headers: {
        ...publishOptions?.headers,
        "shelter-namespace-registration": params.namespaceRegistration
      }
    } : publishOptions, hooks && {
      prepublish: hooks.prepublishContract,
      postpublish: hooks.postpublishContract
    });
    await esm_default("chelonia/private/out/sync", contractID);
    const msg = await esm_default(actionEncryptionKeyId ? "chelonia/out/actionEncrypted" : "chelonia/out/actionUnencrypted", {
      action: contractName,
      contractID,
      data: params.data,
      signingKeyId: actionSigningKeyId ?? signingKeyId,
      encryptionKeyId: actionEncryptionKeyId,
      hooks,
      publishOptions
    });
    return msg;
  },
  "chelonia/out/ownResources": async function(contractID) {
    if (!contractID) {
      throw new TypeError("A contract ID must be provided");
    }
    const response = await this.config.fetch(`${this.config.connectionURL}/ownResources`, {
      method: "GET",
      signal: this.abortController.signal,
      headers: new Headers([
        ["authorization", buildShelterAuthorizationHeader.call(this, contractID)]
      ])
    });
    if (!response.ok) {
      console.error("Unable to fetch own resources", contractID, response.status);
      throw new Error(`Unable to fetch own resources for ${contractID}: ${response.status}`);
    }
    return response.json();
  },
  "chelonia/out/deleteContract": async function(contractID, credentials = {}) {
    if (!contractID) {
      throw new TypeError("A contract ID must be provided");
    }
    if (!Array.isArray(contractID))
      contractID = [contractID];
    return await Promise.allSettled(contractID.map(async (cid) => {
      const hasCredential = has(credentials, cid);
      const hasToken = has(credentials[cid], "token") && credentials[cid].token;
      const hasBillableContractID = has(credentials[cid], "billableContractID") && credentials[cid].billableContractID;
      if (!hasCredential || hasToken === hasBillableContractID) {
        throw new TypeError(`Either a token or a billable contract ID must be provided for ${cid}`);
      }
      const response = await this.config.fetch(`${this.config.connectionURL}/deleteContract/${cid}`, {
        method: "POST",
        signal: this.abortController.signal,
        headers: new Headers([
          [
            "authorization",
            hasToken ? `bearer ${credentials[cid].token.valueOf()}` : buildShelterAuthorizationHeader.call(this, credentials[cid].billableContractID)
          ]
        ])
      });
      if (!response.ok) {
        if (response.status === 404 || response.status === 410) {
          console.warn("Contract appears to have been deleted already", cid, response.status);
          return;
        }
        console.error("Unable to delete contract", cid, response.status);
        throw new Error(`Unable to delete contract ${cid}: ${response.status}`);
      }
    }));
  },
  // all of these functions will do both the creation of the SPMessage
  // and the sending of it via 'chelonia/private/out/publishEvent'
  "chelonia/out/actionEncrypted": function(params) {
    return outEncryptedOrUnencryptedAction.call(this, SPMessage.OP_ACTION_ENCRYPTED, params);
  },
  "chelonia/out/actionUnencrypted": function(params) {
    return outEncryptedOrUnencryptedAction.call(this, SPMessage.OP_ACTION_UNENCRYPTED, params);
  },
  "chelonia/out/keyShare": async function(params) {
    const { atomic, originatingContractName, originatingContractID, contractName, contractID, data, hooks, publishOptions } = params;
    const originatingManifestHash = this.config.contracts.manifests[originatingContractName];
    const destinationManifestHash = this.config.contracts.manifests[contractName];
    const originatingContract = originatingContractID ? this.manifestToContract[originatingManifestHash]?.contract : void 0;
    const destinationContract = this.manifestToContract[destinationManifestHash]?.contract;
    if (originatingContractID && !originatingContract || !destinationContract) {
      throw new Error("Contract name not found");
    }
    const payload = data;
    if (!params.signingKeyId && !params.signingKey) {
      throw new TypeError("Either signingKeyId or signingKey must be specified");
    }
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_SHARE,
        params.signingKeyId ? signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys) : signedOutgoingDataWithRawKey(params.signingKey, payload)
      ],
      manifest: destinationManifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyAdd": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const state = contract.state(contractID);
    const payload = params.skipExistingKeyCheck ? data : data.filter((wk) => {
      const k = isEncryptedData(wk) ? wk.valueOf() : wk;
      if (has(state._vm.authorizedKeys, k.id)) {
        if (state._vm.authorizedKeys[k.id]._notAfterHeight == null) {
          return false;
        }
      }
      return true;
    });
    if (payload.length === 0)
      return;
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_ADD,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyDel": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const state = contract.state(contractID);
    const payload = data.map((keyId2) => {
      if (isEncryptedData(keyId2))
        return keyId2;
      if (!has(state._vm.authorizedKeys, keyId2) || state._vm.authorizedKeys[keyId2]._notAfterHeight != null) {
        return void 0;
      }
      if (state._vm.authorizedKeys[keyId2]._private) {
        return encryptedOutgoingData(contractID, state._vm.authorizedKeys[keyId2]._private, keyId2);
      } else {
        return keyId2;
      }
    }).filter(Boolean);
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_DEL,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyUpdate": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const state = contract.state(contractID);
    const payload = data.map((key) => {
      if (isEncryptedData(key))
        return key;
      const { oldKeyId } = key;
      if (state._vm.authorizedKeys[oldKeyId]._private) {
        return encryptedOutgoingData(contractID, state._vm.authorizedKeys[oldKeyId]._private, key);
      } else {
        return key;
      }
    });
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_UPDATE,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    }
    return msg;
  },
  "chelonia/out/keyRequest": async function(params) {
    const { originatingContractID, originatingContractName, contractID, contractName, hooks, publishOptions, innerSigningKeyId, encryptionKeyId, innerEncryptionKeyId, encryptKeyRequestMetadata, reference } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const originatingManifestHash = this.config.contracts.manifests[originatingContractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    const originatingContract = this.manifestToContract[originatingManifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const rootState = esm_default(this.config.stateSelector);
    try {
      await esm_default("chelonia/contract/retain", contractID, { ephemeral: true });
      const state = contract.state(contractID);
      const originatingState = originatingContract.state(originatingContractID);
      const havePendingKeyRequest = Object.values(originatingState._vm.authorizedKeys).findIndex((k) => {
        return k._notAfterHeight == null && k.meta?.keyRequest?.contractID === contractID && state?._volatile?.pendingKeyRequests?.some((pkr) => pkr.name === k.name);
      }) !== -1;
      if (havePendingKeyRequest) {
        return;
      }
      const keyRequestReplyKey = keygen(EDWARDS25519SHA512BATCH);
      const keyRequestReplyKeyId = keyId(keyRequestReplyKey);
      const keyRequestReplyKeyP = serializeKey(keyRequestReplyKey, false);
      const keyRequestReplyKeyS = serializeKey(keyRequestReplyKey, true);
      const signingKeyId = findSuitableSecretKeyId(originatingState, [SPMessage.OP_KEY_ADD], ["sig"]);
      if (!signingKeyId) {
        throw new ChelErrorUnexpected(`Unable to send key request. Originating contract is missing a key with OP_KEY_ADD permission. contractID=${contractID} originatingContractID=${originatingContractID}`);
      }
      const keyAddOp = () => esm_default("chelonia/out/keyAdd", {
        contractID: originatingContractID,
        contractName: originatingContractName,
        data: [
          {
            id: keyRequestReplyKeyId,
            name: "#krrk-" + keyRequestReplyKeyId,
            purpose: ["sig"],
            ringLevel: Number.MAX_SAFE_INTEGER,
            permissions: params.permissions === "*" ? "*" : Array.isArray(params.permissions) ? [...params.permissions, SPMessage.OP_KEY_SHARE] : [SPMessage.OP_KEY_SHARE],
            allowedActions: params.allowedActions,
            meta: {
              private: {
                content: encryptedOutgoingData(originatingContractID, encryptionKeyId, keyRequestReplyKeyS),
                shareable: false
              },
              keyRequest: {
                ...reference && {
                  reference: encryptKeyRequestMetadata ? encryptedOutgoingData(originatingContractID, encryptionKeyId, reference) : reference
                },
                contractID: encryptKeyRequestMetadata ? encryptedOutgoingData(originatingContractID, encryptionKeyId, contractID) : contractID
              }
            },
            data: keyRequestReplyKeyP
          }
        ],
        signingKeyId
      }).catch((e2) => {
        console.error(`[chelonia] Error sending OP_KEY_ADD for ${originatingContractID} during key request to ${contractID}`, e2);
        throw e2;
      });
      const payload = {
        contractID: originatingContractID,
        height: rootState.contracts[originatingContractID].height,
        replyWith: signedOutgoingData(originatingContractID, innerSigningKeyId, {
          encryptionKeyId,
          responseKey: encryptedOutgoingData(contractID, innerEncryptionKeyId, keyRequestReplyKeyS)
        }, this.transientSecretKeys),
        request: "*"
      };
      let msg = SPMessage.createV1_0({
        contractID,
        op: [
          SPMessage.OP_KEY_REQUEST,
          signedOutgoingData(contractID, params.signingKeyId, encryptKeyRequestMetadata ? encryptedOutgoingData(contractID, innerEncryptionKeyId, payload) : payload, this.transientSecretKeys)
        ],
        manifest: manifestHash
      });
      msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, {
        ...hooks,
        // We ensure that both messages are placed into the publish queue
        prepublish: (...args) => {
          return keyAddOp().then(() => hooks?.prepublish?.(...args));
        }
      });
      return msg;
    } finally {
      await esm_default("chelonia/contract/release", contractID, { ephemeral: true });
    }
  },
  "chelonia/out/keyRequestResponse": async function(params) {
    const { atomic, contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const payload = data;
    let message = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_KEY_REQUEST_SEEN,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    if (!atomic) {
      message = await esm_default("chelonia/private/out/publishEvent", message, publishOptions, hooks);
    }
    return message;
  },
  "chelonia/out/atomic": async function(params) {
    const { contractID, contractName, data, hooks, publishOptions } = params;
    const manifestHash = this.config.contracts.manifests[contractName];
    const contract = this.manifestToContract[manifestHash]?.contract;
    if (!contract) {
      throw new Error("Contract name not found");
    }
    const payload = (await Promise.all(data.map(([selector, opParams]) => {
      if (![
        "chelonia/out/actionEncrypted",
        "chelonia/out/actionUnencrypted",
        "chelonia/out/keyAdd",
        "chelonia/out/keyDel",
        "chelonia/out/keyUpdate",
        "chelonia/out/keyRequestResponse",
        "chelonia/out/keyShare"
      ].includes(selector)) {
        throw new Error("Selector not allowed in OP_ATOMIC: " + selector);
      }
      return esm_default(selector, {
        ...opParams,
        ...params,
        data: opParams.data,
        atomic: true
      });
    }))).flat().filter(Boolean).map((msg2) => {
      return [msg2.opType(), msg2.opValue()];
    });
    let msg = SPMessage.createV1_0({
      contractID,
      op: [
        SPMessage.OP_ATOMIC,
        signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
      ],
      manifest: manifestHash
    });
    msg = await esm_default("chelonia/private/out/publishEvent", msg, publishOptions, hooks);
    return msg;
  },
  "chelonia/out/protocolUpgrade": async function() {
  },
  "chelonia/out/propSet": async function() {
  },
  "chelonia/out/propDel": async function() {
  },
  "chelonia/out/encryptedOrUnencryptedPubMessage": function({ contractID, innerSigningKeyId, encryptionKeyId, signingKeyId, data }) {
    const serializedData = outputEncryptedOrUnencryptedMessage.call(this, {
      contractID,
      innerSigningKeyId,
      encryptionKeyId,
      signingKeyId,
      data
    });
    this.pubsub.pub(contractID, serializedData);
  },
  // Note: This is a bare-bones function designed for precise control. In many
  // situations, the `chelonia/kv/queuedSet` selector (in chelonia-utils.js)
  // will be simpler and more appropriate to use.
  // In most situations, you want to use some queuing strategy (which this
  // selector doesn't provide) alongside writing to the KV store. Therefore, as
  // a general rule, you shouldn't be calling this selector directly unless
  // you're building a utility library or if you have very specific needs. In
  // this case, see if `chelonia/kv/queuedSet` covers your needs.
  // `data` is allowed to be falsy, in which case a fetch will occur first and
  // the `onconflict` handler will be called.
  "chelonia/kv/set": async function(contractID, key, data, { ifMatch, innerSigningKeyId, encryptionKeyId, signingKeyId, maxAttempts, onconflict }) {
    maxAttempts = maxAttempts ?? 3;
    const url = `${this.config.connectionURL}/kv/${encodeURIComponent(contractID)}/${encodeURIComponent(key)}`;
    const hasOnconflict = typeof onconflict === "function";
    let response;
    const resolveData = async () => {
      let currentValue;
      if (response.ok || response.status === 409 || response.status === 412) {
        const serializedDataText = await response.text();
        currentValue = serializedDataText ? parseEncryptedOrUnencryptedMessage(this, {
          contractID,
          serializedData: JSON.parse(serializedDataText),
          meta: key
        }) : void 0;
      } else if (response.status !== 404 && response.status !== 410) {
        throw new ChelErrorUnexpectedHttpResponseCode("[kv/set] Invalid response code: " + response.status);
      }
      const result = await onconflict({
        contractID,
        key,
        failedData: data,
        status: response.status,
        // If no x-cid or etag header was returned, `ifMatch` would likely be
        // returned as undefined, which will then use the `''` fallback value
        // when writing. This allows 404 / 410 responses to work even if no
        // etag is explicitly given
        etag: response.headers.get("x-cid") || response.headers.get("etag"),
        get currentData() {
          return currentValue?.data;
        },
        currentValue
      });
      if (!result)
        return false;
      data = result[0];
      ifMatch = result[1];
      return true;
    };
    for (; ; ) {
      if (data !== void 0) {
        const serializedData = outputEncryptedOrUnencryptedMessage.call(this, {
          contractID,
          innerSigningKeyId,
          encryptionKeyId,
          signingKeyId,
          data,
          meta: key
        });
        response = await this.config.fetch(url, {
          headers: new Headers([
            ["authorization", buildShelterAuthorizationHeader.call(this, contractID)],
            ["if-match", ifMatch || '""']
          ]),
          method: "POST",
          body: JSON.stringify(serializedData),
          signal: this.abortController.signal
        });
      } else {
        if (!hasOnconflict) {
          throw TypeError("onconflict required with empty data");
        }
        response = await this.config.fetch(url, {
          headers: new Headers([
            ["authorization", buildShelterAuthorizationHeader.call(this, contractID)]
          ]),
          signal: this.abortController.signal
        });
        if (await resolveData()) {
          continue;
        } else {
          break;
        }
      }
      if (!response.ok) {
        if (response.status === 409 || response.status === 412) {
          if (--maxAttempts <= 0) {
            throw new Error("kv/set conflict setting KV value");
          }
          await delay(randomIntFromRange(0, 1500));
          if (hasOnconflict) {
            if (await resolveData()) {
              continue;
            } else {
              break;
            }
          } else {
            throw new Error(`kv/set failed with status ${response.status} and no onconflict handler was provided`);
          }
        }
        throw new ChelErrorUnexpectedHttpResponseCode("kv/set invalid response status: " + response.status);
      }
      break;
    }
  },
  "chelonia/kv/get": async function(contractID, key) {
    const response = await this.config.fetch(`${this.config.connectionURL}/kv/${encodeURIComponent(contractID)}/${encodeURIComponent(key)}`, {
      headers: new Headers([
        ["authorization", buildShelterAuthorizationHeader.call(this, contractID)]
      ]),
      signal: this.abortController.signal
    });
    if (response.status === 404) {
      return null;
    }
    if (!response.ok) {
      throw new Error("Invalid response status: " + response.status);
    }
    const data = await response.json();
    return parseEncryptedOrUnencryptedMessage(this, {
      contractID,
      serializedData: data,
      meta: key
    });
  },
  // To set filters for a contract, call with `filter` set to an array of KV
  // keys to receive updates for over the WebSocket. An empty array means that
  // no KV updates will be sent.
  // Calling with a single argument (the contract ID) will remove filters,
  // meaning that KV updates will be sent for _any_ KV key.
  // The last call takes precedence, so, for example, calling with filter
  // set to `['foo', 'bar']` and then with `['baz']` means that KV updates will
  // be received for `baz` only, not for `foo`, `bar` or any other keys.
  "chelonia/kv/setFilter": function(contractID, filter) {
    this.pubsub.setKvFilter(contractID, filter);
  },
  "chelonia/parseEncryptedOrUnencryptedDetachedMessage": function({ contractID, serializedData, meta }) {
    return parseEncryptedOrUnencryptedMessage(this, {
      contractID,
      serializedData,
      meta
    });
  }
});
function contractNameFromAction(action) {
  const regexResult = ACTION_REGEX.exec(action);
  const contractName = regexResult?.[2];
  if (!contractName)
    throw new Error(`Poorly named action '${action}': missing contract name.`);
  return contractName;
}
function outputEncryptedOrUnencryptedMessage({ contractID, innerSigningKeyId, encryptionKeyId, signingKeyId, data, meta }) {
  const state = esm_default(this.config.stateSelector)[contractID];
  const signedMessage = innerSigningKeyId ? state._vm.authorizedKeys[innerSigningKeyId] && state._vm.authorizedKeys[innerSigningKeyId]?._notAfterHeight == null ? signedOutgoingData(contractID, innerSigningKeyId, data, this.transientSecretKeys) : signedOutgoingDataWithRawKey(this.transientSecretKeys[innerSigningKeyId], data) : data;
  const payload = !encryptionKeyId ? signedMessage : encryptedOutgoingData(contractID, encryptionKeyId, signedMessage);
  const message = signedOutgoingData(contractID, signingKeyId, payload, this.transientSecretKeys);
  const rootState = esm_default(this.config.stateSelector);
  const height = String(rootState.contracts[contractID].height);
  const serializedData = { ...message.serialize((meta ?? "") + height), height };
  return serializedData;
}
function parseEncryptedOrUnencryptedMessage(ctx, { contractID, serializedData, meta }) {
  if (!serializedData) {
    throw new TypeError("[chelonia] parseEncryptedOrUnencryptedMessage: serializedData is required");
  }
  const state = esm_default(ctx.config.stateSelector)[contractID];
  const numericHeight = parseInt(serializedData.height);
  const rootState = esm_default(ctx.config.stateSelector);
  const currentHeight = rootState.contracts[contractID].height;
  if (!(numericHeight >= 0) || !(numericHeight <= currentHeight)) {
    throw new Error(`[chelonia] parseEncryptedOrUnencryptedMessage: Invalid height ${serializedData.height}; it must be between 0 and ${currentHeight}`);
  }
  const aad = (meta ?? "") + serializedData.height;
  const v2 = signedIncomingData(contractID, state, serializedData, numericHeight, aad, (message) => {
    return maybeEncryptedIncomingData(contractID, state, message, numericHeight, ctx.transientSecretKeys, aad, void 0);
  });
  let encryptionKeyId;
  let innerSigningKeyId;
  const unwrap2 = /* @__PURE__ */ (() => {
    let result2;
    return () => {
      if (!result2) {
        try {
          let unwrapped;
          unwrapped = v2.valueOf();
          if (isEncryptedData(unwrapped)) {
            encryptionKeyId = unwrapped.encryptionKeyId;
            unwrapped = unwrapped.valueOf();
            if (isSignedData(unwrapped)) {
              innerSigningKeyId = unwrapped.signingKeyId;
              unwrapped = unwrapped.valueOf();
            } else {
              innerSigningKeyId = null;
            }
          } else {
            encryptionKeyId = null;
            innerSigningKeyId = null;
          }
          result2 = [unwrapped];
        } catch (e2) {
          result2 = [void 0, e2];
        }
      }
      if (result2.length === 2) {
        throw result2[1];
      }
      return result2[0];
    };
  })();
  const result = {
    get contractID() {
      return contractID;
    },
    get innerSigningKeyId() {
      if (innerSigningKeyId === void 0) {
        try {
          unwrap2();
        } catch {
        }
      }
      return innerSigningKeyId;
    },
    get encryptionKeyId() {
      if (encryptionKeyId === void 0) {
        try {
          unwrap2();
        } catch {
        }
      }
      return encryptionKeyId;
    },
    get signingKeyId() {
      return v2.signingKeyId;
    },
    get data() {
      return unwrap2();
    },
    get signingContractID() {
      return getContractIDfromKeyId(contractID, result.signingKeyId, state);
    },
    get innerSigningContractID() {
      return getContractIDfromKeyId(contractID, result.innerSigningKeyId, state);
    }
  };
  return result;
}
async function outEncryptedOrUnencryptedAction(opType, params) {
  const { atomic, action, contractID, data, hooks, publishOptions } = params;
  const contractName = contractNameFromAction(action);
  const manifestHash = this.config.contracts.manifests[contractName];
  const { contract } = this.manifestToContract[manifestHash];
  const state = contract.state(contractID);
  const meta = await contract.metadata.create();
  const unencMessage = { action, data, meta };
  const signedMessage = params.innerSigningKeyId ? state._vm.authorizedKeys[params.innerSigningKeyId] && state._vm.authorizedKeys[params.innerSigningKeyId]?._notAfterHeight == null ? signedOutgoingData(contractID, params.innerSigningKeyId, unencMessage, this.transientSecretKeys) : signedOutgoingDataWithRawKey(this.transientSecretKeys[params.innerSigningKeyId], unencMessage) : unencMessage;
  if (opType === SPMessage.OP_ACTION_ENCRYPTED && !params.encryptionKeyId) {
    throw new Error("OP_ACTION_ENCRYPTED requires an encryption key ID be given");
  }
  if (params.encryptionKey) {
    if (params.encryptionKeyId !== keyId(params.encryptionKey)) {
      throw new Error("OP_ACTION_ENCRYPTED raw encryption key does not match encryptionKeyId");
    }
  }
  const payload = opType === SPMessage.OP_ACTION_UNENCRYPTED ? signedMessage : params.encryptionKey ? encryptedOutgoingDataWithRawKey(params.encryptionKey, signedMessage) : encryptedOutgoingData(contractID, params.encryptionKeyId, signedMessage);
  let message = SPMessage.createV1_0({
    contractID,
    op: [
      opType,
      signedOutgoingData(contractID, params.signingKeyId, payload, this.transientSecretKeys)
    ],
    manifest: manifestHash
  });
  if (!atomic) {
    message = await esm_default("chelonia/private/out/publishEvent", message, publishOptions, hooks);
  }
  return message;
}
function gettersProxy(state, getters) {
  const proxyGetters = new Proxy({}, {
    get(_target, prop) {
      return getters[prop](state, proxyGetters);
    }
  });
  return { getters: proxyGetters };
}
esm_default("sbp/domains/lock", ["chelonia"]);
init_db();
init_db();
init_functions();
var import_boom = __toESM(require_lib2());
init_esm();
var import_npm_lru_cache = __toESM(require_lru_cache());
var SERVER_EXITING = "server-exiting";
init_esm();
var vapidPublicKey;
var vapidPrivateKey;
if (!process2.env.VAPID_EMAIL) {
  console.warn('Missing VAPID identification. Please set VAPID_EMAIL to a value like "mailto:some@example".');
}
var vapid = { VAPID_EMAIL: process2.env.VAPID_EMAIL || "mailto:test@example.com" };
var initVapid = async () => {
  const vapidKeyPair = await esm_default("chelonia.db/get", "_private_immutable_vapid_key").then(async (vapidKeyPair2) => {
    if (!vapidKeyPair2) {
      console.info("Generating new VAPID keypair...");
      const keyPair = await crypto.subtle.generateKey(
        {
          name: "ECDSA",
          namedCurve: "P-256"
          // Use P-256 curve
        },
        true,
        // Whether the key is extractable
        ["sign", "verify"]
        // Usages
      );
      const serializedKeyPair2 = await Promise.all([
        crypto.subtle.exportKey("jwk", keyPair.privateKey),
        crypto.subtle.exportKey("raw", keyPair.publicKey).then(
          (key) => Buffer7.from(key).toString("base64url")
        )
      ]);
      return esm_default("chelonia.db/set", "_private_immutable_vapid_key", JSON.stringify(serializedKeyPair2)).then(() => {
        console.info("Successfully saved newly generated VAPID keys");
        return [keyPair.privateKey, serializedKeyPair2[1]];
      });
    }
    const serializedKeyPair = JSON.parse(vapidKeyPair2);
    return [
      await crypto.subtle.importKey(
        "jwk",
        serializedKeyPair[0],
        { name: "ECDSA", namedCurve: "P-256" },
        false,
        ["sign"]
      ),
      serializedKeyPair[1]
    ];
  });
  vapidPrivateKey = vapidKeyPair[0];
  vapidPublicKey = vapidKeyPair[1];
};
var import_scrypt_async2 = __toESM(require_scrypt_async(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var hashStringArray = (...args) => {
  return import_tweetnacl2.default.hash(Buffer8.concat(args.map((s) => import_tweetnacl2.default.hash(Buffer8.from(s)))));
};
init_esm();
var import_npm_tweetnacl = __toESM(require_nacl_fast());
var recordSecret;
var challengeSecret;
var registrationSecret;
var hashUpdateSecret;
var initZkpp = async () => {
  const IKM = await esm_default("chelonia.db/get", "_private_immutable_zkpp_ikm").then((IKM2) => {
    if (!IKM2) {
      const secret = randomBytes2(33).toString("base64");
      return esm_default("chelonia.db/set", "_private_immutable_zkpp_ikm", secret).then(() => {
        return secret;
      });
    }
    return IKM2;
  });
  recordSecret = Buffer9.from(hashStringArray("private/recordSecret", IKM)).toString("base64");
  challengeSecret = Buffer9.from(hashStringArray("private/challengeSecret", IKM)).toString("base64");
  registrationSecret = Buffer9.from(hashStringArray("private/registrationSecret", IKM)).toString("base64");
  hashUpdateSecret = Buffer9.from(hashStringArray("private/hashUpdateSecret", IKM)).toString("base64");
};
var globImport_database_ts2 = __glob({
  "./database-fs.ts": () => Promise.resolve().then(() => (init_database_fs(), database_fs_exports)),
  "./database-redis.ts": () => Promise.resolve().then(() => (init_database_redis(), database_redis_exports)),
  "./database-router.test.ts": () => Promise.resolve().then(() => (init_database_router_test(), database_router_test_exports)),
  "./database-router.ts": () => Promise.resolve().then(() => (init_database_router(), database_router_exports)),
  "./database-sqlite.ts": () => Promise.resolve().then(() => (init_database_sqlite(), database_sqlite_exports))
});
var production = process5.env.NODE_ENV === "production";
var persistence = process5.env.GI_PERSIST || (production ? "fs" : void 0);
var dbRootPath = process5.env.DB_PATH || "./data";
var options = {
  fs: {
    depth: 0,
    dirname: dbRootPath,
    keyChunkLength: 2
  },
  sqlite: {
    filepath: path.join(dbRootPath, "groupincome.db")
  }
};
var KEYOP_SEGMENT_LENGTH = 1e4;
var dataFolder = path.resolve(options.fs.dirname);
if (!fs.existsSync(dataFolder)) {
  fs.mkdirSync(dataFolder, { mode: 488 });
}
var updateSize = async (resourceID, sizeKey, size, skipIfDeleted) => {
  if (!Number.isSafeInteger(size)) {
    throw new TypeError(`Invalid given size ${size} for ${resourceID}`);
  }
  await esm_default("okTurtles.eventQueue/queueEvent", sizeKey, async () => {
    const storedSize = await esm_default("chelonia.db/get", sizeKey, { bypassCache: true });
    if (skipIfDeleted && storedSize == null) return;
    const existingSize = parseInt(storedSize ?? "0", 10);
    if (!(existingSize >= 0)) {
      throw new TypeError(`Invalid stored size ${existingSize} for ${resourceID}`);
    }
    const updatedSize = existingSize + size;
    if (!(updatedSize >= 0)) {
      throw new TypeError(`Invalid stored updated size ${updatedSize} for ${resourceID}`);
    }
    await esm_default("chelonia.db/set", sizeKey, updatedSize.toString(10));
  });
};
var database_default = esm_default("sbp/selectors/register", {
  "backend/db/streamEntriesAfter": async function(contractID, height, requestedLimit, options2 = {}) {
    const limit = Math.min(requestedLimit ?? Number.POSITIVE_INFINITY, process5.env.MAX_EVENTS_BATCH_SIZE ? parseInt(process5.env.MAX_EVENTS_BATCH_SIZE) : 500);
    const latestHEADinfo = await esm_default("chelonia/db/latestHEADinfo", contractID);
    if (latestHEADinfo === "") {
      throw import_boom.default.resourceGone(`contractID ${contractID} has been deleted!`);
    }
    if (!latestHEADinfo) {
      throw import_boom.default.notFound(`contractID ${contractID} doesn't exist!`);
    }
    let counter = 0;
    let currentHeight = height;
    let currentHash, serverMeta;
    let prefix = "";
    const nextKeyOp = /* @__PURE__ */ (() => {
      let index;
      return async () => {
        if (!index) {
          index = (await esm_default("chelonia.db/get", `_private_keyop_idx_${contractID}_${currentHeight - currentHeight % KEYOP_SEGMENT_LENGTH}`))?.split("\0");
        }
        const value = index?.find((h2, i2) => {
          if (Number(h2) >= currentHeight) {
            index = index.slice(i2 + 1);
            return true;
          } else {
            return false;
          }
        });
        if (value != null) {
          const newHeight = Number(value);
          currentHeight = newHeight;
        } else {
          currentHeight = currentHeight - currentHeight % KEYOP_SEGMENT_LENGTH + KEYOP_SEGMENT_LENGTH;
          index = void 0;
          if (currentHeight > latestHEADinfo.height) {
            return false;
          } else {
            return null;
          }
        }
        return true;
      };
    })();
    const fetchMeta = async () => {
      if (currentHeight > latestHEADinfo.height) {
        return false;
      }
      const meta = await esm_default("chelonia/db/getEntryMeta", contractID, currentHeight);
      if (!meta) {
        return false;
      }
      const { hash: newCurrentHash, ...newServerMeta } = meta;
      currentHash = newCurrentHash;
      serverMeta = newServerMeta;
      return true;
    };
    const stream = Readable.from(async function* () {
      yield "[";
      await fetchMeta();
      while (serverMeta && counter < limit) {
        try {
          const entry = await esm_default("chelonia/db/getEntry", currentHash);
          if (!entry) break;
          const currentPrefix = prefix;
          prefix = ",";
          counter++;
          yield `${currentPrefix}"${strToB64(
            JSON.stringify({ serverMeta, message: entry.serialize() })
          )}"`;
          currentHeight++;
          currentHash = void 0;
          serverMeta = void 0;
          if (options2.keyOps) {
            while (await nextKeyOp() === null) ;
          }
          await fetchMeta();
        } catch (e2) {
          console.error(e2, "[backend] streamEntriesAfter: read()");
          break;
        }
      }
      yield "]";
    }(), { encoding: "utf-8", objectMode: false });
    stream.headers = {
      "shelter-headinfo-head": latestHEADinfo.HEAD,
      "shelter-headinfo-height": latestHEADinfo.height
    };
    return stream;
  },
  // =======================
  // wrapper methods to add / lookup names
  // =======================
  "backend/db/registerName": async function(name, value) {
    const exists = await esm_default("backend/db/lookupName", name);
    if (exists) {
      throw import_boom.default.conflict("exists");
    }
    await esm_default("chelonia.db/set", namespaceKey(name), value);
    await esm_default("chelonia.db/set", `_private_cid2name_${value}`, name);
    await appendToNamesIndex(name);
    return { name, value };
  },
  "backend/db/lookupName": async function(name) {
    const value = await esm_default("chelonia.db/get", namespaceKey(name));
    return value;
  }
});
function namespaceKey(name) {
  return "name=" + name;
}
var initDB = async ({ skipDbPreloading } = {}) => {
  if (persistence) {
    const Ctor = (await globImport_database_ts2(`./database-${persistence}.ts`)).default;
    const { init: init2, readData, writeData, deleteData, close } = new Ctor(options[persistence]);
    await init2();
    esm_default("okTurtles.events/once", SERVER_EXITING, () => {
      esm_default("okTurtles.eventQueue/queueEvent", SERVER_EXITING, async () => {
        try {
          await close();
        } catch (e2) {
          console.error(e2, `Error closing DB ${persistence}`);
        }
      });
    });
    const cache2 = new import_npm_lru_cache.default({
      max: Number(process5.env.GI_LRU_NUM_ITEMS) || 1e4
    });
    const prefixes = Object.keys(prefixHandlers);
    esm_default("sbp/selectors/overwrite", {
      "chelonia.db/get": async function(prefixableKey, { bypassCache } = {}) {
        if (!bypassCache) {
          const lookupValue = cache2.get(prefixableKey);
          if (lookupValue !== void 0) {
            return lookupValue;
          }
        }
        const [prefix, key] = parsePrefixableKey(prefixableKey);
        let value = await readData(key);
        if (value === void 0) {
          return;
        }
        value = prefixHandlers[prefix](value);
        cache2.set(prefixableKey, value);
        return value;
      },
      "chelonia.db/set": async function(key, value) {
        if (process5.env.CHELONIA_ARCHIVE_MODE) throw new Error("Unable to write in archive mode");
        checkKey(key);
        if (key.startsWith("_private_immutable")) {
          const existingValue = await readData(key);
          if (existingValue !== void 0) {
            throw new Error("Cannot set already set immutable key");
          }
        }
        await writeData(key, value);
        prefixes.forEach((prefix) => {
          cache2.delete(prefix + key);
        });
      },
      "chelonia.db/delete": async function(key) {
        if (process5.env.CHELONIA_ARCHIVE_MODE) throw new Error("Unable to write in archive mode");
        checkKey(key);
        if (key.startsWith("_private_immutable")) {
          throw new Error("Cannot delete immutable key");
        }
        await deleteData(key);
        prefixes.forEach((prefix) => {
          cache2.delete(prefix + key);
        });
      }
    });
    esm_default("sbp/selectors/lock", ["chelonia.db/get", "chelonia.db/set", "chelonia.db/delete"]);
  }
  if (skipDbPreloading) return;
  if (persistence !== "fs" || options.fs.dirname !== dbRootPath) {
    const HASH_LENGTH = 56;
    const keys = (await readdir2(dataFolder)).filter((k) => {
      if (k.length !== HASH_LENGTH) return false;
      const parsed = maybeParseCID(k);
      return parsed && [
        multicodes.SHELTER_CONTRACT_MANIFEST,
        multicodes.SHELTER_CONTRACT_TEXT
      ].includes(parsed.code);
    });
    const numKeys = keys.length;
    let numVisitedKeys = 0;
    let numNewKeys = 0;
    const savedProgress = { value: 0, numKeys: 0 };
    console.info("[chelonia.db] Preloading...");
    for (const key of keys) {
      if (!persistence || !await esm_default("chelonia.db/get", key)) {
        const value = await readFile3(path.join(dataFolder, key), "utf8");
        await esm_default("chelonia.db/set", key, value);
        numNewKeys++;
      }
      numVisitedKeys++;
      const progress = numVisitedKeys === numKeys ? 100 : Math.floor(100 * numVisitedKeys / numKeys);
      if (progress === 100 || progress - savedProgress.value >= 10 && numVisitedKeys - savedProgress.numKeys >= 10) {
        console.info(`[chelonia.db] Preloading... ${progress}% done`);
        savedProgress.numKeys = numVisitedKeys;
        savedProgress.value = progress;
      }
    }
    numNewKeys && console.info(`[chelonia.db] Preloaded ${numNewKeys} new entries`);
  }
  await Promise.all([initVapid(), initZkpp()]);
};
var appendToIndexFactory = (key) => {
  return (value) => {
    return esm_default("okTurtles.eventQueue/queueEvent", key, async () => {
      const currentIndex = await esm_default("chelonia.db/get", key, { bypassCache: true });
      if (currentIndex) {
        if (
          // Check if the value is at the end
          currentIndex.endsWith("\0" + value) || // Check if the value is at the start
          currentIndex.startsWith(value + "\0") || // Check if the current index is exactly the value
          currentIndex === value
        ) {
          return;
        }
        await esm_default("chelonia.db/set", key, `${currentIndex}\0${value}`);
        return;
      }
      await esm_default("chelonia.db/set", key, value);
    });
  };
};
var appendToNamesIndex = appendToIndexFactory("_private_names_index");
var removeFromIndexFactory = (key) => {
  return (values) => {
    return esm_default("okTurtles.eventQueue/queueEvent", key, async () => {
      let existingEntries = await esm_default("chelonia.db/get", key, { bypassCache: true });
      if (!existingEntries) return;
      if (!Array.isArray(values)) {
        values = [values];
      }
      for (const value of values) {
        if (existingEntries.endsWith("\0" + value)) {
          existingEntries = existingEntries.slice(0, -value.length - 1);
          continue;
        }
        if (existingEntries.startsWith(value + "\0")) {
          existingEntries = existingEntries.slice(value.length + 1);
          continue;
        }
        if (existingEntries === value) {
          existingEntries = void 0;
          break;
        }
        const entryIndex = existingEntries.indexOf("\0" + value + "\0");
        if (entryIndex === -1) continue;
        existingEntries = existingEntries.slice(0, entryIndex) + existingEntries.slice(entryIndex + value.length + 1);
      }
      if (existingEntries) {
        await esm_default("chelonia.db/set", key, existingEntries);
      } else {
        await esm_default("chelonia.db/delete", key);
      }
    });
  };
};
var lookupUltimateOwner = async (resourceID) => {
  let ownerID = resourceID;
  for (let depth = 128; depth >= 0; depth--) {
    const newOwnerID = await esm_default("chelonia.db/get", `_private_owner_${ownerID}`, { bypassCache: true });
    if (!newOwnerID) break;
    if (!depth) {
      throw new Error("Exceeded max depth looking up owner for " + resourceID);
    }
    ownerID = newOwnerID;
  }
  return ownerID;
};
init_esm();
var import_npm_pino = __toESM(require_pino());
var prettyPrint = process6.env.NODE_ENV === "development" || process6.env.CI || process6.env.CYPRESS_RECORD_KEY || process6.env.PRETTY;
function logMethod(args, method) {
  const stringIdx = typeof args[0] === "string" ? 0 : 1;
  if (args.length > 1) {
    for (let i2 = stringIdx + 1; i2 < args.length; ++i2) {
      args[stringIdx] += typeof args[i2] === "string" ? " %s" : " %o";
    }
  }
  method.apply(this, args);
}
var logger;
if (prettyPrint) {
  try {
    logger = (0, import_npm_pino.default)({
      hooks: { logMethod },
      transport: {
        target: "pino-pretty",
        options: {
          colorize: true
        }
      }
    });
  } catch (e2) {
    console.warn("pino-pretty transport unavailable, using basic logging", e2);
    logger = (0, import_npm_pino.default)({ hooks: { logMethod } });
  }
} else {
  logger = (0, import_npm_pino.default)({ hooks: { logMethod } });
}
var logLevel = process6.env.LOG_LEVEL || (prettyPrint ? "debug" : "info");
if (Object.keys(logger.levels.values).includes(logLevel)) {
  logger.level = logLevel;
} else {
  logger.warn(`Unknown log level: ${logLevel}`);
}
globalThis.logger = logger;
console.debug = logger.debug.bind(logger);
console.info = logger.info.bind(logger);
console.log = logger.info.bind(logger);
console.warn = logger.warn.bind(logger);
console.error = logger.error.bind(logger);
var readyQueueName = "parentPort";
parentPort.on("message", ([port, ...msg]) => {
  esm_default("okTurtles.eventQueue/queueEvent", readyQueueName, () => {
    (async () => {
      try {
        port?.postMessage([true, await esm_default(...msg)]);
      } catch (e2) {
        port?.postMessage([false, e2]);
      }
    })();
  });
});
esm_default("okTurtles.eventQueue/queueEvent", readyQueueName, async () => {
  await initDB({ skipDbPreloading: true });
  parentPort.postMessage("ready");
});
var updatedSizeList = /* @__PURE__ */ new Set();
var updatedSizeMap = /* @__PURE__ */ new Map();
var cachedUltimateOwnerMap = /* @__PURE__ */ new Map();
var fastBase58Hash = (cid) => {
  const len = cid.length;
  const a = cid.codePointAt(len - 2) || 0;
  const b = cid.codePointAt(len - 1) || 0;
  return a * 19 + (b + 19) & 255;
};
var addToTempIndex = (cid) => {
  return appendToIndexFactory(`_private_pendingIdx_ownerTotalSize_${fastBase58Hash(cid)}`)(cid);
};
var removeFromTempIndex = (cids) => {
  const cidsByBucket = cids.reduce((acc, cv) => {
    const bucket = fastBase58Hash(cv);
    const ownedResourcesSet = acc.get(bucket);
    if (ownedResourcesSet) {
      ownedResourcesSet.add(cv);
    } else {
      acc.set(bucket, /* @__PURE__ */ new Set([cv]));
    }
    return acc;
  }, /* @__PURE__ */ new Map());
  return Promise.all([...cidsByBucket].map(([bucket, cids2]) => {
    return removeFromIndexFactory(`_private_pendingIdx_ownerTotalSize_${bucket}`)([...cids2]);
  }));
};
esm_default("okTurtles.eventQueue/queueEvent", readyQueueName, async () => {
  for (let i2 = 0; i2 < 256; i2++) {
    const data = await esm_default("chelonia.db/get", `_private_pendingIdx_ownerTotalSize_${i2}`, { bypassCache: true });
    if (data) {
      data.split("\0").forEach((cid) => {
        updatedSizeList.add(cid);
      });
    }
  }
  console.info(`[ownerSizeTotalWorker] Loaded ${updatedSizeList.size} CIDs for full recalculation.`);
  if (updatedSizeList.size) {
    esm_default("backend/server/computeSizeTask");
  }
  setTimeout(esm_default, OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL, "backend/server/computeSizeTaskDeltas");
});
esm_default("sbp/selectors/register", {
  /**
   * Selector: 'worker/updateSizeSideEffects'
   * Handles incoming size update events for a specific resource.
   * It adds the CID to the temporary persistent index (if not already processed
   * or pending full recalc) and updates the in-memory delta map (`updatedSizeMap`).
   *
   * IMPORTANT: This should only be called for keys where this is relevant,
   * such as `_private_size_` keys.
   */
  "worker/updateSizeSideEffects": async ({ resourceID, size, ultimateOwnerID }) => {
    if (updatedSizeList.has(resourceID)) return;
    const current = updatedSizeMap.get(resourceID);
    if (current === void 0) {
      try {
        await addToTempIndex(ultimateOwnerID || resourceID);
        updatedSizeMap.set(resourceID, size);
      } catch (e2) {
        console.error(e2, `[ownerSizeTotalWorker] Error adding ${resourceID} to temp index:`);
      }
    } else {
      updatedSizeMap.set(resourceID, current + size);
    }
    if (ultimateOwnerID) {
      cachedUltimateOwnerMap.set(resourceID, ultimateOwnerID);
    }
  },
  /**
   * Selector: 'backend/server/computeSizeTaskDeltas'
   * Periodically executed task (via setTimeout) to process accumulated
   * size _deltas_.
   * Calculates the change in total size for ultimate owners based on the deltas
   * stored in `updatedSizeMap` and updates the database.
   */
  "backend/server/computeSizeTaskDeltas": async function() {
    const deltaEntries = Array.from(updatedSizeMap);
    updatedSizeMap.clear();
    const ultimateOwners = /* @__PURE__ */ new Map();
    const orphansSet = /* @__PURE__ */ new Set();
    await Promise.all(deltaEntries.map(async ([contractID, delta]) => {
      const cachedOwnerID = cachedUltimateOwnerMap.get(contractID);
      const ownerID = cachedOwnerID || await lookupUltimateOwner(contractID);
      if (!cachedOwnerID && ownerID === contractID) {
        if (!await esm_default("chelonia.db/get", contractID)) {
          const current = updatedSizeMap.get(contractID) ?? 0;
          updatedSizeMap.set(contractID, current + delta);
          orphansSet.add(contractID);
          return;
        }
      }
      cachedUltimateOwnerMap.delete(contractID);
      const [val, ownedResourcesSet] = ultimateOwners.get(ownerID) || [0, /* @__PURE__ */ new Set([ownerID])];
      ownedResourcesSet.add(contractID);
      ultimateOwners.set(ownerID, [val + delta, ownedResourcesSet]);
    }));
    await Promise.all(Array.from(ultimateOwners).map(async ([id, [totalDelta, contributingResources]]) => {
      await updateSize(id, `_private_ownerTotalSize_${id}`, totalDelta);
      await removeFromTempIndex(Array.from(contributingResources));
    }));
    await removeFromTempIndex(Array.from(orphansSet));
    setTimeout(esm_default, OWNER_SIZE_TOTAL_WORKER_TASK_TIME_INTERVAL, "backend/server/computeSizeTaskDeltas");
  },
  /**
   * Selector: 'backend/server/computeSizeTask'
   * Task to perform a full recalculation of total owner sizes.
   * Triggered on startup if `updatedSizeList` is populated (from
   * persistent index).
   * Processes resource IDs from `updatedSizeList`.
   */
  "backend/server/computeSizeTask": async function() {
    const start = performance.now();
    const resourcesToRecalculate = Array.from(updatedSizeList);
    const ultimateOwners = /* @__PURE__ */ new Map();
    await Promise.all(resourcesToRecalculate.map(async (contractID) => {
      const ownerID = await lookupUltimateOwner(contractID);
      const resources = ultimateOwners.get(ownerID);
      if (resources) {
        resources.add(contractID);
      } else {
        ultimateOwners.set(ownerID, /* @__PURE__ */ new Set([contractID]));
      }
    }));
    await Promise.all(Array.from(ultimateOwners).map(async ([ownerID, contractIDs]) => {
      const resources = await esm_default("chelonia.db/get", `_private_resources_${ownerID}`);
      const indirectResources = resources ? await esm_default("chelonia.db/get", `_private_indirectResources_${ownerID}`) : void 0;
      const allSubresources = Array.from(/* @__PURE__ */ new Set([
        ownerID,
        ...resources ? resources.split("\0") : [],
        ...indirectResources ? indirectResources.split("\0") : []
      ]));
      const totalSize = (await Promise.all(allSubresources.map((id) => {
        return esm_default("chelonia.db/get", `_private_size_${id}`);
      }))).reduce((acc, cv) => {
        if (cv) {
          const parsed = parseInt(cv, 10);
          if (parsed) return parsed + acc;
        }
        return acc;
      }, 0);
      await esm_default("okTurtles.eventQueue/queueEvent", `_private_ownerTotalSize_${ownerID}`, async () => {
        allSubresources.forEach((id) => {
          updatedSizeList.delete(id);
          if (updatedSizeMap.delete(id)) {
            contractIDs.add(id);
          }
        });
        await esm_default("chelonia.db/set", `_private_ownerTotalSize_${ownerID}`, totalSize.toString(10));
        await removeFromTempIndex(Array.from(contractIDs).filter((id) => {
          return !updatedSizeMap.has(id);
        }));
      });
    }));
    console.info(`[ownerSizeTotalWorker] Computed size for ${updatedSizeList.size} CIDs in ${((performance.now() - start) / 1e3).toFixed(2)} seconds.`);
  }
});
/*! Bundled license information:

scrypt-async/scrypt-async.js:
  (*!
   * Fast "async" scrypt implementation in JavaScript.
   * Copyright (c) 2013-2016 Dmitry Chestnykh | BSD License
   * https://github.com/dchest/scrypt-async-js
   *)
*/
