{
  "version": 3,
  "sources": ["../../../frontend/model/contracts/shared/functions.js"],
  "sourcesContent": ["'use strict'\n\nimport sbp from '@sbp/sbp'\nimport { L } from '@common/common.js'\nimport {\n  MESSAGE_TYPES,\n  POLL_STATUS,\n  PROPOSAL_GROUP_SETTING_CHANGE,\n  PROPOSAL_INVITE_MEMBER,\n  PROPOSAL_REMOVE_MEMBER,\n  PROPOSAL_PROPOSAL_SETTING_CHANGE,\n  PROPOSAL_GENERIC,\n  CHATROOM_MEMBER_MENTION_SPECIAL_CHAR\n} from './constants.js'\nimport { NEW_CHATROOM_UNREAD_POSITION } from '@utils/events.js'\nimport { humanDate } from './time.js'\n\n// !!!!!!!!!!!!!!!\n// !! IMPORTANT !!\n// !!!!!!!!!!!!!!!\n//\n// DO NOT CHANGE THE LOGIC TO ANY OF THESE FUNCTIONS!\n// INSTEAD, CREATE NEW FUNCTIONS WITH DIFFERENT NAMES\n// AND USE THOSE INSTEAD!\n//\n// THIS IS A CONSEQUENCE OF SHARING THIS CODE WITH THE REST OF THE APP.\n// IF YOU DO NOT NEED TO SHARE CODE WITH THE REST OF THE APP (AND CAN\n// KEEP IT WITHIN THE CONTRACT ONLY), THEN YOU DON'T NEED TO WORRY ABOUT\n// THIS, AND SHOULD INCLUDE THOSE FUNCTIONS (WITHOUT EXPORTING THEM),\n// DIRECTLY IN YOUR CONTRACT DEFINITION FILE. THEN YOU CAN MODIFY\n// THEM AS MUCH AS YOU LIKE (and generate new contract versions out of them).\n\n// group.js related\n\nexport function paymentHashesFromPaymentPeriod (periodPayments        )           {\n  let hashes = []\n  if (periodPayments) {\n    const { paymentsFrom } = periodPayments\n    for (const fromMemberID in paymentsFrom) {\n      for (const toMemberID in paymentsFrom[fromMemberID]) {\n        hashes = hashes.concat(paymentsFrom[fromMemberID][toMemberID])\n      }\n    }\n  }\n\n  return hashes\n}\n\nexport function createPaymentInfo (paymentHash        , payment        )   \n                                                                                                       \n  {\n  return {\n    fromMemberID: payment.data.fromMemberID,\n    toMemberID: payment.data.toMemberID,\n    hash: paymentHash,\n    amount: payment.data.amount,\n    isLate: !!payment.data.isLate,\n    when: payment.data.completedDate\n  }\n}\n\nexport function getProposalDetails (proposal        )         {\n  const { creatorID, status } = proposal\n  const { proposalType, proposalData } = proposal.data\n\n  const settingsTranslationMap = {\n    'mincomeAmount': L('mincome'),\n    'distributionDate': L('distribution date'),\n    'votingSystem': L('voting system'),\n    'votingRule': L('voting rules')\n  }\n  const options = {}\n  if (proposalType === PROPOSAL_PROPOSAL_SETTING_CHANGE) {\n    if (proposalData.ruleName !== proposalData.current.ruleName) {\n      options['settingType'] = 'votingSystem'\n    } else if (proposalData.ruleThreshold !== proposalData.current.ruleThreshold) {\n      options['settingType'] = 'votingRule'\n    }\n  } else if (proposalType === PROPOSAL_GROUP_SETTING_CHANGE) {\n    options['settingType'] = proposalData.setting\n  } else if (proposalType === PROPOSAL_GENERIC) {\n    options['title'] = proposalData.name\n  } else if (proposalType === PROPOSAL_INVITE_MEMBER) {\n    options['member'] = proposalData.memberName\n  } else if (proposalType === PROPOSAL_REMOVE_MEMBER) {\n    options['memberID'] = proposalData.memberID\n    // options['member'] is not set as it's part of external state. The code\n    // responsible for notifications (`frontend/model/notifications/templates.js`)\n    // will set it\n  }\n\n  const { proposedValue } = proposalData\n  if (proposedValue) {\n    if (options.settingType === 'distributionDate') {\n      options['value'] = humanDate(proposedValue, { month: 'long', year: 'numeric', day: 'numeric' })\n    } else {\n      options['value'] = proposedValue\n    }\n  }\n  if (options.settingType) {\n    options['setting'] = settingsTranslationMap[options.settingType]\n  }\n\n  return { creatorID, status, type: proposalType, options }\n}\n\n// chatroom.js related\n\nexport function createMessage ({ meta, data, hash, height, state, pending, innerSigningContractID }   \n               \n               \n               \n                 \n                 \n                    \n                                 \n )         {\n  const { type, text, replyingMessage, attachments } = data\n  const { createdDate } = meta\n\n  const newMessage      = {\n    type,\n    hash,\n    height,\n    from: innerSigningContractID,\n    datetime: new Date(createdDate).toISOString()\n  }\n\n  if (pending) {\n    newMessage.pending = true\n  }\n\n  if (type === MESSAGE_TYPES.TEXT) {\n    newMessage.text = text\n    if (replyingMessage) {\n      newMessage.replyingMessage = replyingMessage\n    }\n    if (attachments) {\n      newMessage.attachments = attachments\n    }\n  } else if (type === MESSAGE_TYPES.POLL) {\n    newMessage.pollData = {\n      ...data.pollData,\n      creatorID: innerSigningContractID,\n      status: POLL_STATUS.ACTIVE,\n      // 'voted' field below will contain the user names of the users who has voted for this option\n      options: data.pollData.options.map(opt => ({ ...opt, voted: [] }))\n    }\n  } else if (type === MESSAGE_TYPES.NOTIFICATION) {\n    const params = {\n      channelName: state?.attributes.name,\n      channelDescription: state?.attributes.description,\n      ...data.notification\n    }\n    delete params.type\n    newMessage.notification = { type: data.notification.type, params }\n  } else if (type === MESSAGE_TYPES.INTERACTIVE) {\n    newMessage.proposal = data.proposal\n  }\n  return newMessage\n}\n\nexport async function postLeaveChatRoomCleanup (contractID        , state        ) {\n  if (await sbp('chelonia/contract/isSyncing', contractID, { firstSync: true })) {\n    return\n  }\n\n  sbp('gi.actions/identity/kv/deleteChatRoomUnreadMessages', { contractID }).catch((e) => {\n    console.error('[leaveChatroom] Error at deleteChatRoomUnreadMessages ', contractID, e)\n  })\n  sbp('okTurtles.events/emit', NEW_CHATROOM_UNREAD_POSITION, { chatRoomID: contractID })\n  // NOTE: The contract that keeps track of chatrooms should now call `/release`\n  // This would be the group contract (for group chatrooms) or the identity\n  // contract (for DMs).\n}\n\nexport function findMessageIdx (hash        , messages                = [])         {\n  for (let i = messages.length - 1; i >= 0; i--) {\n    if (messages[i].hash === hash) {\n      return i\n    }\n  }\n  return -1\n}\n\nexport function makeMentionFromUserID (userID        )   \n                         \n  {\n  return {\n    me: userID ? `${CHATROOM_MEMBER_MENTION_SPECIAL_CHAR}${userID}` : '',\n    all: `${CHATROOM_MEMBER_MENTION_SPECIAL_CHAR}all`\n  }\n}\n\n// The `referenceTally` function is meant as an utility function to handle\n// reference counting in contracts that import other contracts.\n// The selector returned is to be called in side-effects that 'retain' or\n// 'release' other contracts, and it works by pushing a single callback into\n// the contract queue that maintains a temporary reference count to be applied\n// at the end of a chain processing events.\n// For example, a chatroom supports the 'join' and 'leave' actions, and those\n// call 'retain' or 'release', respectively, on the identity contracts of\n// members.\n// Now, imagine this sequence of events: `[join, leave, join, leave]` (all\n// involving the same member).\n// Imagine all actions are processed at once (for example, the chatroom is being\n// synced from scratch). By calling the `referenceTally` selector, this would\n// happen in the event queue:\n//   queue slot 0: [sync]:\n//        (join)    event 0: [process]\n//                  event 0: [sideEffect]: this calls `referenceTally`, which\n//                             increases the temp count to 1 and pushes a\n//                             function into the queue.\n//        (leave)   event 1: [process]\n//                  event 1: [sideEffect]: this calls `referenceTally`, which\n//                             decreases the temp count to 0. No function is\n//                             pushed into the queue as one already exists.\n//        (join)    event 2: [process]\n//                  event 2: [sideEffect]: this calls `referenceTally`, which\n//                             increases the temp count to 1. No function is\n//                             pushed into the queue as one already exists.\n//        (leave)   event 3: [process]\n//                  event 3: [sideEffect]: this calls `referenceTally`, which\n//                             decreases the temp count to 0. No function is\n//                             pushed into the queue as one already exists.\n//   queue slot 1: [referenceTally]: Function pushed onto the queue by event 0.\n//                              Since the temp count is 0, no call to retain\n//                              or release happens.\n//\n// Now, imagine a different scenario, where the same events happen but they are\n// processed differently. Let's say that the grouping is:\n//    1. [join, leave]\n//    2. [join]\n//    3. [leave]\n// This situation could happen when syncing the chatroom from scratch (with\n// only the first two events having happened at this point in time) with the\n// other events being received over the web socket later.\n//   queue slot 0: [sync]:\n//        (join)    event 0: [process]\n//                  event 0: [sideEffect]: this calls `referenceTally`, which\n//                             increases the temp count to 1 and pushes a\n//                             function into the queue.\n//        (leave)   event 1: [process]\n//                  event 1: [sideEffect]: this calls `referenceTally`, which\n//                             decreases the temp count to 0. No function is\n//                             pushed into the queue as one already exists.\n//   queue slot 1: [referenceTally]: Function pushed onto the queue by event 0.\n//                              Since the temp count is 0, no call to retain\n//                              or release happens.\n//   queue slot 2: [sync]:\n//        (join)    event 2: [process]\n//                  event 2: [sideEffect]: this calls `referenceTally`, which\n//                             increases the temp count to and pushes a\n//                             function into the queue.\n//   queue slot 3: [referenceTally]: Function pushed onto the queue by event 2.\n//                              Since the temp count is 1, retain is called.\n//   queue slot 4: [sync]:\n//        (leave)   event 3: [process]\n//                  event 3: [sideEffect]: this calls `referenceTally`, which\n//                             decreases the temp count to -1 and pushes a\n//                             function into the queue.\n//   queue slot 5: [referenceTally]: Function pushed onto the queue by event 3.\n//                              Since the temp count is -1, release is called.\nexport const referenceTally = (selector        )         => {\n  const delta = {\n    'retain': 1,\n    'release': -1\n  }\n  return {\n    [selector]: (parentContractID        , childContractIDs                   , op                      ) => {\n      if (!Array.isArray(childContractIDs)) childContractIDs = [childContractIDs]\n      if (op !== 'retain' && op !== 'release') throw new Error('Invalid operation')\n      for (const childContractID of childContractIDs) {\n        const key = `${selector}-${parentContractID}-${childContractID}`\n        const count = sbp('okTurtles.data/get', key)\n        sbp('okTurtles.data/set', key, (count || 0) + delta[op])\n        if (count != null) return\n        sbp('chelonia/queueInvocation', parentContractID, () => {\n          const count = sbp('okTurtles.data/get', key)\n          sbp('okTurtles.data/delete', key)\n          if (count && count !== Math.sign(count)) {\n            console.warn(`[${selector}] Unexpected value`, parentContractID, childContractID, count)\n            // If we're running tests, we enforce checking that the temporary\n            // count _must_ be either of 0, 1 or -1. This is a correct\n            // assumption, based on the fact that a single contract should only\n            // call retain or release at most once after all operations are\n            // processed, per chunk of operations (e.g., there is no valid\n            // reason for a group contract to call `retain` twice on the same\n            // contract ID, without having called `release` first).\n            // This rule (or assumption) also applies to non-CI environments,\n            // but we are more lax in this case to allow for more leniency when\n            // running contracts with real users. However, this type of error\n            // indicates faulty reference bookkeeping that must be corrected.\n            if (process.env.CI) {\n              Promise.reject(new Error(`[${selector}] Unexpected value ${parentContractID} ${childContractID}: ${count}`))\n            }\n          }\n          switch (Math.sign(count)) {\n            case -1:\n              sbp('chelonia/contract/release', childContractID).catch(e => {\n                console.error(`[${selector}] Error calling release`, parentContractID, childContractID, e)\n              })\n              break\n            case 1:\n              sbp('chelonia/contract/retain', childContractID).catch(e => console.error(`[${selector}] Error calling retain`, parentContractID, childContractID, e))\n              break\n          }\n        }).catch(e => {\n          console.error(`[${selector}] Error in queued invocation`, parentContractID, childContractID, e)\n        })\n      }\n    }\n  }\n}\n"],
  "mappings": "gLAkCO,SAASA,EAAgCC,EAAkC,CAChF,IAAIC,EAAS,CAAC,EACd,GAAID,EAAgB,CAClB,GAAM,CAAE,aAAAE,CAAa,EAAIF,EACzB,QAAWG,KAAgBD,EACzB,QAAWE,KAAcF,EAAaC,CAAY,EAChDF,EAASA,EAAO,OAAOC,EAAaC,CAAY,EAAEC,CAAU,CAAC,CAGnE,CAEA,OAAOH,CACT,CAEO,SAASI,EAAmBC,EAAqBC,EAEtD,CACA,MAAO,CACL,aAAcA,EAAQ,KAAK,aAC3B,WAAYA,EAAQ,KAAK,WACzB,KAAMD,EACN,OAAQC,EAAQ,KAAK,OACrB,OAAQ,CAAC,CAACA,EAAQ,KAAK,OACvB,KAAMA,EAAQ,KAAK,aACrB,CACF,CAEO,SAASC,EAAoBC,EAA0B,CAC5D,GAAM,CAAE,UAAAC,EAAW,OAAAC,CAAO,EAAIF,EACxB,CAAE,aAAAG,EAAc,aAAAC,CAAa,EAAIJ,EAAS,KAE1CK,EAAyB,CAC7B,cAAiBC,EAAE,SAAS,EAC5B,iBAAoBA,EAAE,mBAAmB,EACzC,aAAgBA,EAAE,eAAe,EACjC,WAAcA,EAAE,cAAc,CAChC,EACMC,EAAU,CAAC,EACbJ,IAAiBK,EACfJ,EAAa,WAAaA,EAAa,QAAQ,SACjDG,EAAQ,YAAiB,eAChBH,EAAa,gBAAkBA,EAAa,QAAQ,gBAC7DG,EAAQ,YAAiB,cAElBJ,IAAiBM,EAC1BF,EAAQ,YAAiBH,EAAa,QAC7BD,IAAiBO,EAC1BH,EAAQ,MAAWH,EAAa,KACvBD,IAAiBQ,EAC1BJ,EAAQ,OAAYH,EAAa,WACxBD,IAAiBS,IAC1BL,EAAQ,SAAcH,EAAa,UAMrC,GAAM,CAAE,cAAAS,CAAc,EAAIT,EAC1B,OAAIS,IACEN,EAAQ,cAAgB,mBAC1BA,EAAQ,MAAWO,EAAUD,EAAe,CAAE,MAAO,OAAQ,KAAM,UAAW,IAAK,SAAU,CAAC,EAE9FN,EAAQ,MAAWM,GAGnBN,EAAQ,cACVA,EAAQ,QAAaF,EAAuBE,EAAQ,WAAW,GAG1D,CAAE,UAAAN,EAAW,OAAAC,EAAQ,KAAMC,EAAc,QAAAI,CAAQ,CAC1D,CAwEO,SAASQ,EAAgBC,EAAcC,EAA0B,CAAC,EAAW,CAClF,QAASC,EAAID,EAAS,OAAS,EAAGC,GAAK,EAAGA,IACxC,GAAID,EAASC,CAAC,EAAE,OAASF,EACvB,OAAOE,EAGX,MAAO,EACT,CAEO,SAASC,EAAuBC,EAErC,CACA,MAAO,CACL,GAAIA,EAAS,GAAGC,CAAoC,GAAGD,CAAM,GAAK,GAClE,IAAK,GAAGC,CAAoC,KAC9C,CACF",
  "names": ["paymentHashesFromPaymentPeriod", "periodPayments", "hashes", "paymentsFrom", "fromMemberID", "toMemberID", "createPaymentInfo", "paymentHash", "payment", "getProposalDetails", "proposal", "creatorID", "status", "proposalType", "proposalData", "settingsTranslationMap", "L", "options", "PROPOSAL_PROPOSAL_SETTING_CHANGE", "PROPOSAL_GROUP_SETTING_CHANGE", "PROPOSAL_GENERIC", "PROPOSAL_INVITE_MEMBER", "PROPOSAL_REMOVE_MEMBER", "proposedValue", "humanDate", "findMessageIdx", "hash", "messages", "i", "makeMentionFromUserID", "userID", "CHATROOM_MEMBER_MENTION_SPECIAL_CHAR"]
}
