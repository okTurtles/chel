{
  "version": 3,
  "sources": ["../../../frontend/views/containers/payments/PaymentsMixin.js"],
  "sourcesContent": ["import sbp from '@sbp/sbp'\nimport { mapState, mapGetters } from 'vuex'\nimport { PAYMENT_COMPLETED } from '@model/contracts/shared/payments/index.js'\nimport { createPaymentInfo, paymentHashesFromPaymentPeriod } from '@model/contracts/shared/functions.js'\nimport { humanDate, dateFromPeriodStamp, periodStampsForDate } from '@model/contracts/shared/time.js'\nimport { cloneDeep } from 'turtledash'\n\n// NOTE: this mixin combines payment information\n// from both the current in-memory state and the archived payments on disk\nconst PaymentsMixin         = {\n  computed: {\n    ...mapState(['currentGroupId']),\n    ...mapGetters([\n      'currentGroupState',\n      'dueDateForPeriod',\n      'groupPeriodPayments',\n      'groupSettings',\n      'groupCreatedDate',\n      'groupSortedPeriodKeys',\n      'ourIdentityContractId',\n      'ourPayments',\n      'periodAfterPeriod',\n      'periodBeforePeriod',\n      'periodStampGivenDate',\n      'paymentHashesForPeriod'\n    ])\n  },\n  methods: {\n    async historicalPeriodStampGivenPayment (payment) {\n      return await this.historicalPeriodStampGivenDate(payment.date)\n    },\n\n    async getAllPeriodPayments () {\n      return { ...await this.getHistoricalPeriodPayments(), ...this.groupPeriodPayments }\n    },\n\n    // Oldest key first.\n    async getAllSortedPeriodKeys () {\n      const currentDate = new Date()\n      const distributionDate = new Date(this.groupSettings.distributionDate)\n      const groupCreatedDate = new Date(this.groupCreatedDate)\n      const historicalPeriodPayments = Object.keys(await this.getHistoricalPeriodPayments()).sort()\n      const periods = [\n        ...historicalPeriodPayments,\n        ...this.groupSortedPeriodKeys\n      ].filter(period => {\n        const dPeriod = new Date(period)\n        return dPeriod > new Date(groupCreatedDate) && dPeriod <= currentDate // show only started periods & filter out the 'waiting' period\n      })\n      // remove the waiting period from the list. it's useful for the contract but not in the UI\n      if (periods.length === 1 && new Date(periods[0]) < distributionDate) {\n        return []\n      }\n      return periods\n    },\n\n    async historicalPeriodStampGivenDate (givenDate               ) {\n      return periodStampsForDate(givenDate, {\n        knownSortedStamps: await this.getAllSortedPeriodKeys(),\n        periodLength: this.groupSettings.distributionPeriodLength\n      }).current\n    },\n\n    async historicalPeriodBeforePeriod (periodStamp        ) {\n      return periodStampsForDate(periodStamp, {\n        knownSortedStamps: await this.getAllSortedPeriodKeys(),\n        periodLength: this.groupSettings.distributionPeriodLength\n      }).previous\n    },\n\n    async historicalPeriodAfterPeriod (periodStamp        ) {\n      return periodStampsForDate(periodStamp, {\n        knownSortedStamps: await this.getAllSortedPeriodKeys(),\n        periodLength: this.groupSettings.distributionPeriodLength\n      }).next\n    },\n\n    async getDueDateForPeriod (periodStamp        ) {\n      return await this.historicalPeriodAfterPeriod(periodStamp)\n    },\n\n    // ====================\n    async getHistoricalPeriodPayments () {\n      const ourArchiveKey = `paymentsByPeriod/${this.ourIdentityContractId}/${this.currentGroupId}`\n      return await sbp('gi.db/archive/load', ourArchiveKey) ?? {}\n    },\n\n    async getAllPaymentsInTypes () {\n      const sent = []\n      const received = []\n      const todo = cloneDeep(this.ourPayments?.todo ?? [])\n      const periodPayments = await this.getAllPeriodPayments()\n      const sortPayments = (f, l) => f.meta.createdDate > l.meta.createdDate ? 1 : -1\n\n      for (const periodStamp of Object.keys(periodPayments).sort().reverse()) {\n        const paymentsByHash = await this.getPaymentDetailsByPeriod(periodStamp)\n        const { paymentsFrom } = periodPayments[periodStamp]\n        for (const fromMemberID of Object.keys(paymentsFrom)) {\n          for (const toMemberID of Object.keys(paymentsFrom[fromMemberID])) {\n            if (toMemberID === this.ourIdentityContractId || fromMemberID === this.ourIdentityContractId) {\n              const receivedOrSent = toMemberID === this.ourIdentityContractId ? received : sent\n              for (const hash of paymentsFrom[fromMemberID][toMemberID]) {\n                if (hash in paymentsByHash) {\n                  const { data, meta } = paymentsByHash[hash]\n                  receivedOrSent.push({ hash, data, meta, amount: data.amount, toMemberID, period: periodStamp })\n                } else {\n                  console.error(`getAllPaymentsInTypes: couldn't find payment ${hash} for period ${periodStamp}!`)\n                }\n              }\n            }\n          }\n        }\n      }\n      sent.sort(sortPayments)\n      received.sort(sortPayments)\n      return { received, sent, todo }\n    },\n    // Returns archived or in-memory stored data by payment hash for the given period.\n    async getPaymentDetailsByPeriod (period        ) {\n      let detailedPayments = {}\n      if (period in this.groupPeriodPayments) {\n        const paymentHashes = this.paymentHashesForPeriod(period) || []\n        detailedPayments = Object.fromEntries(paymentHashes.map(hash => [hash, this.currentGroupState.payments[hash]]))\n      } else {\n        const paymentsByPeriod = await this.getHistoricalPeriodPayments()\n        const paymentHashes = paymentHashesFromPaymentPeriod(paymentsByPeriod[period])\n        const historicalPaymentDetails = await this.getHistoricalPaymentDetailsByPeriod(period)\n\n        for (const hash of paymentHashes) {\n          detailedPayments[hash] = historicalPaymentDetails[hash]\n        }\n      }\n      return detailedPayments\n    },\n    // Returns a list of payment info objects for completed payments during the given period.\n    async getPaymentsByPeriod (period        ) {\n      const payments = []\n      const paymentsByHash = await this.getPaymentDetailsByPeriod(period)\n      for (const hash of Object.keys(paymentsByHash)) {\n        const payment = paymentsByHash[hash]\n        if (payment.data.status === PAYMENT_COMPLETED) {\n          payments.push(createPaymentInfo(hash, payment))\n        }\n      }\n      return payments\n    },\n    async getHistoricalPaymentDetailsByPeriod (period        ) {\n      const paymentsKey = `payments/${this.ourIdentityContractId}/${period}/${this.currentGroupId}`\n      const paymentDetails = await sbp('gi.db/archive/load', paymentsKey) || {}\n\n      return paymentDetails\n    },\n    async getHaveNeedsSnapshotByPeriod (period        ) {\n      if (Object.keys(this.groupPeriodPayments).includes(period)) {\n        return this.groupPeriodPayments[period].haveNeedsSnapshot || []\n      }\n\n      const paymentsByPeriod = await this.getHistoricalPeriodPayments()\n      return Object.keys(paymentsByPeriod).includes(period)\n        ? paymentsByPeriod[period].haveNeedsSnapshot || []\n        : []\n    },\n    async getTotalTodoAmountForPeriod (period        ) {\n      const haveNeeds = await this.getHaveNeedsSnapshotByPeriod(period)\n      let total = 0\n\n      for (const { haveNeed } of haveNeeds) {\n        if (haveNeed < 0) { total += -1 * haveNeed }\n      }\n      return total\n    },\n    async getTotalPledgesDoneForPeriod (period        ) {\n      const payments = await this.getPaymentsByPeriod(period)\n      let total = 0\n\n      for (const { amount } of payments) {\n        total += amount\n      }\n      return total\n    },\n    // Returns the stored payment period object for a given period stamp,\n    // or an empty object if not found.\n    // TODOs: rename to getPaymentPeriod, and maybe avoid loading all historical payment periods.\n    async getPaymentPeriod (period        ) {\n      return this.groupPeriodPayments[period] ?? (await this.getHistoricalPeriodPayments())[period] ?? {}\n    },\n    // Returns a human-readable description of the time interval identified by a given period stamp.\n    getPeriodFromStartToDueDate (period, knownPeriods) {\n      const dueDate = this.dueDateForPeriod(period, knownPeriods)\n      return `${humanDate(dateFromPeriodStamp(period))} - ${humanDate(dateFromPeriodStamp(dueDate))}`\n    }\n  }\n}\n\nexport default PaymentsMixin\n"],
  "mappings": "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",
  "names": ["PaymentsMixin", "mapState", "mapGetters", "payment", "currentDate", "distributionDate", "groupCreatedDate", "periods", "period", "dPeriod", "givenDate", "periodStampsForDate", "periodStamp", "ourArchiveKey", "esm_default", "sent", "received", "todo", "cloneDeep", "periodPayments", "sortPayments", "f", "l", "paymentsByHash", "paymentsFrom", "fromMemberID", "toMemberID", "receivedOrSent", "hash", "data", "meta", "detailedPayments", "paymentHashes", "paymentsByPeriod", "paymentHashesFromPaymentPeriod", "historicalPaymentDetails", "payments", "PAYMENT_COMPLETED", "createPaymentInfo", "paymentsKey", "haveNeeds", "total", "haveNeed", "amount", "knownPeriods", "dueDate", "humanDate", "dateFromPeriodStamp", "PaymentsMixin_default"]
}
