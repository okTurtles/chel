{
  "version": 3,
  "sources": ["../../../frontend/utils/image.js"],
  "sourcesContent": ["'use strict'\n\nimport sbp from '@sbp/sbp'\nimport { KILOBYTE, IMAGE_ATTACHMENT_MAX_SIZE } from './constants.js'\n\n// Copied from https://stackoverflow.com/questions/11876175/how-to-get-a-file-or-blob-from-an-object-url\nexport function objectURLtoBlob (url        )                {\n  return fetch(url).then(r => r.blob())\n}\n\n// Copied from https://stackoverflow.com/a/27980815/4737729\nexport function imageDataURItoBlob (dataURI        )       {\n  const [prefix, data] = dataURI.split(',')\n  const [imageType] = (/image\\/[^;]+/.exec(prefix) || [''])\n  const byteString = atob(data)\n  const ab = new ArrayBuffer(byteString.length)\n  const ia = new Uint8Array(ab)\n\n  for (let i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i)\n  }\n\n  return new Blob([ab], { type: imageType })\n}\n\nexport const imageUpload = async (imageFile      , params         )                  => {\n  const file = imageFile\n  console.debug('will upload a picture of type:', file.type)\n  const { download } = await sbp('chelonia/fileUpload', imageFile, { type: file.type, cipher: 'aes256gcm' }, params)\n  return download\n}\n\n// Image compression\n\nexport function supportsWebP ()                   {\n  // Uses a very small webP image to check if the browser supports 'image/webp' format.\n  // (reference: https://developers.google.com/speed/webp/faq#in_your_own_javascript)\n  const verySmallWebP = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n  const img = new Image()\n\n  return new Promise(resolve => {\n    img.onload = () => { resolve(img.height > 0) }\n    img.onerror = (e) => { resolve(false) }\n    img.src = verySmallWebP\n  })\n}\n\nfunction loadImage (url)      {\n  const imgEl = new Image()\n\n  return new Promise((resolve) => {\n    imgEl.onload = () => { resolve(imgEl) }\n    imgEl.src = url\n  })\n}\n\nfunction generateImageBlobByCanvas ({\n  sourceImage,\n  resizingFactor,\n  quality,\n  compressToType\n}) {\n  const { naturalWidth, naturalHeight } = sourceImage\n  const canvasEl = document.createElement('canvas')\n  const c = canvasEl.getContext('2d')\n\n  canvasEl.width = naturalWidth * resizingFactor\n  canvasEl.height = naturalHeight * resizingFactor\n\n  c.drawImage(\n    sourceImage,\n    0,\n    0,\n    canvasEl.width,\n    canvasEl.height\n  )\n\n  return new Promise((resolve) => {\n    canvasEl.toBlob(blob => {\n      resolve(blob)\n    }, compressToType, quality)\n  })\n}\n\nfunction getResizingFactor (sourceImage) {\n  // If image's physical size is greater than the max dimension, resize the image to the max dimension.\n  const imageMaxDimension = { width: 2048, height: 1536 }\n  const { naturalWidth, naturalHeight } = sourceImage\n\n  if (naturalWidth > imageMaxDimension.width || naturalHeight > imageMaxDimension.height) {\n    return Math.min(imageMaxDimension.width / naturalWidth, imageMaxDimension.height / naturalHeight)\n  }\n\n  return 1\n}\n\nexport async function compressImage (imgUrl        , sourceMimeType         )               {\n  // Takes a source image url and generate a blob of the compressed image.\n\n  // According to the testing result, webP format has a better compression ratio than jpeg.\n  const compressToType = await supportsWebP() ? 'image/webp' : 'image/jpeg'\n  const sourceImage = await loadImage(imgUrl)\n\n  // According to the testing result, 0.8 is a good starting point for quality for .jpeg and .webp.\n  // For other image types, use 0.9 as the starting point.\n  let quality = ['image/jpeg', 'image/webp'].includes(sourceMimeType) ? 0.8 : 0.9\n  const resizingFactor = getResizingFactor(sourceImage)\n\n  while (true) {\n    const blob = await generateImageBlobByCanvas({\n      sourceImage,\n      resizingFactor,\n      quality,\n      compressToType\n    })\n    const sizeDiff = blob.size - IMAGE_ATTACHMENT_MAX_SIZE\n\n    if (sizeDiff <= 0 || // if the compressed image is already smaller than the max size, return the compressed image.\n      quality <= 0.3) { // Do not sacrifice the image quality too much.\n      return blob\n    } else {\n      // if the size difference is greater than 100KB, reduce the next compression factors by 10%, otherwise 5%.\n      const minusFactor = sizeDiff > 100 * KILOBYTE ? 0.1 : 0.05\n      quality -= minusFactor\n    }\n  }\n}\n"],
  "mappings": "+CAWO,SAASA,EAAoBC,EAAuB,CACzD,GAAM,CAACC,EAAQC,CAAI,EAAIF,EAAQ,MAAM,GAAG,EAClC,CAACG,CAAS,EAAK,eAAe,KAAKF,CAAM,GAAK,CAAC,EAAE,EACjDG,EAAa,KAAKF,CAAI,EACtBG,EAAK,IAAI,YAAYD,EAAW,MAAM,EACtCE,EAAK,IAAI,WAAWD,CAAE,EAE5B,QAASE,EAAI,EAAGA,EAAIH,EAAW,OAAQG,IACrCD,EAAGC,CAAC,EAAIH,EAAW,WAAWG,CAAC,EAGjC,OAAO,IAAI,KAAK,CAACF,CAAE,EAAG,CAAE,KAAMF,CAAU,CAAC,CAC3C,CAEO,IAAMK,EAAc,MAAOC,EAAiBC,IAAqC,CACtF,IAAMC,EAAOF,EACb,QAAQ,MAAM,iCAAkCE,EAAK,IAAI,EACzD,GAAM,CAAE,SAAAC,CAAS,EAAI,MAAMC,EAAI,sBAAuBJ,EAAW,CAAE,KAAME,EAAK,KAAM,OAAQ,WAAY,EAAGD,CAAM,EACjH,OAAOE,CACT,EAIO,SAASE,GAAkC,CAGhD,IAAMC,EAAgB,kFAChBC,EAAM,IAAI,MAEhB,OAAO,IAAI,QAAQC,GAAW,CAC5BD,EAAI,OAAS,IAAM,CAAEC,EAAQD,EAAI,OAAS,CAAC,CAAE,EAC7CA,EAAI,QAAWE,GAAM,CAAED,EAAQ,EAAK,CAAE,EACtCD,EAAI,IAAMD,CACZ,CAAC,CACH,CAEA,SAASI,EAAWC,EAAU,CAC5B,IAAMC,EAAQ,IAAI,MAElB,OAAO,IAAI,QAASJ,GAAY,CAC9BI,EAAM,OAAS,IAAM,CAAEJ,EAAQI,CAAK,CAAE,EACtCA,EAAM,IAAMD,CACd,CAAC,CACH,CAEA,SAASE,EAA2B,CAClC,YAAAC,EACA,eAAAC,EACA,QAAAC,EACA,eAAAC,CACF,EAAG,CACD,GAAM,CAAE,aAAAC,EAAc,cAAAC,CAAc,EAAIL,EAClCM,EAAW,SAAS,cAAc,QAAQ,EAC1CC,EAAID,EAAS,WAAW,IAAI,EAElC,OAAAA,EAAS,MAAQF,EAAeH,EAChCK,EAAS,OAASD,EAAgBJ,EAElCM,EAAE,UACAP,EACA,EACA,EACAM,EAAS,MACTA,EAAS,MACX,EAEO,IAAI,QAASZ,GAAY,CAC9BY,EAAS,OAAOE,GAAQ,CACtBd,EAAQc,CAAI,CACd,EAAGL,EAAgBD,CAAO,CAC5B,CAAC,CACH,CAEA,SAASO,EAAmBT,EAAa,CAEvC,IAAMU,EAAoB,CAAE,MAAO,KAAM,OAAQ,IAAK,EAChD,CAAE,aAAAN,EAAc,cAAAC,CAAc,EAAIL,EAExC,OAAII,EAAeM,EAAkB,OAASL,EAAgBK,EAAkB,OACvE,KAAK,IAAIA,EAAkB,MAAQN,EAAcM,EAAkB,OAASL,CAAa,EAG3F,CACT,CAEA,eAAsBM,EAAeC,EAAgBC,EAAuC,CAI1F,IAAMV,EAAiB,MAAMZ,EAAa,EAAI,aAAe,aACvDS,EAAc,MAAMJ,EAAUgB,CAAM,EAItCV,EAAU,CAAC,aAAc,YAAY,EAAE,SAASW,CAAc,EAAI,GAAM,GACtEZ,EAAiBQ,EAAkBT,CAAW,EAEpD,OAAa,CACX,IAAMQ,EAAO,MAAMT,EAA0B,CAC3C,YAAAC,EACA,eAAAC,EACA,QAAAC,EACA,eAAAC,CACF,CAAC,EACKW,EAAWN,EAAK,KAAO,OAE7B,GAAIM,GAAY,GACdZ,GAAW,GACX,OAAOM,EACF,CAEL,IAAMO,EAAcD,EAAW,IAAM,KAAW,GAAM,IACtDZ,GAAWa,CACb,CACF,CACF",
  "names": ["imageDataURItoBlob", "dataURI", "prefix", "data", "imageType", "byteString", "ab", "ia", "i", "imageUpload", "imageFile", "params", "file", "download", "esm_default", "supportsWebP", "verySmallWebP", "img", "resolve", "e", "loadImage", "url", "imgEl", "generateImageBlobByCanvas", "sourceImage", "resizingFactor", "quality", "compressToType", "naturalWidth", "naturalHeight", "canvasEl", "c", "blob", "getResizingFactor", "imageMaxDimension", "compressImage", "imgUrl", "sourceMimeType", "sizeDiff", "minusFactor"]
}
