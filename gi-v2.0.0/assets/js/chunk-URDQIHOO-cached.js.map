{
  "version": 3,
  "sources": ["../../../frontend/model/contracts/shared/distribution/mincome-proportional.js", "../../../frontend/model/contracts/shared/distribution/payments-minimizer.js", "../../../frontend/model/contracts/shared/distribution/distribution.js"],
  "sourcesContent": ["'use strict'\n\n                              \n                   \n                  \n \n\nexport default function mincomeProportional (haveNeeds                       )                {\n  let totalHave = 0\n  let totalNeed = 0\n  const havers = []\n  const needers = []\n  for (const haveNeed of haveNeeds) {\n    if (haveNeed.haveNeed > 0) {\n      havers.push(haveNeed)\n      totalHave += haveNeed.haveNeed\n    } else if (haveNeed.haveNeed < 0) {\n      needers.push(haveNeed)\n      totalNeed += Math.abs(haveNeed.haveNeed)\n    }\n  }\n  const totalPercent = Math.min(1, totalNeed / totalHave)\n  const payments = []\n  for (const haver of havers) {\n    const distributionAmount = totalPercent * haver.haveNeed\n    for (const needer of needers) {\n      const belowPercentage = Math.abs(needer.haveNeed) / totalNeed\n      payments.push({\n        amount: distributionAmount * belowPercentage,\n        fromMemberID: haver.memberID,\n        toMemberID: needer.memberID\n      })\n    }\n  }\n  return payments\n}\n", "'use strict'\n\n// greedy algorithm responsible for \"balancing\" payments\n// such that the least number of payments are made.\nexport default function minimizeTotalPaymentsCount (\n  distribution               \n)                                                                            {\n  const neederTotalReceived = {}\n  const haverTotalHave = {}\n  const haversSorted = []\n  const needersSorted = []\n  const minimizedDistribution = []\n  for (const todo of distribution) {\n    neederTotalReceived[todo.toMemberID] = (neederTotalReceived[todo.toMemberID] || 0) + todo.amount\n    haverTotalHave[todo.fromMemberID] = (haverTotalHave[todo.fromMemberID] || 0) + todo.amount\n  }\n  for (const memberID in haverTotalHave) {\n    haversSorted.push({ memberID, amount: haverTotalHave[memberID] })\n  }\n  for (const memberID in neederTotalReceived) {\n    needersSorted.push({ memberID, amount: neederTotalReceived[memberID] })\n  }\n  // sort haves and needs: greatest to least\n  haversSorted.sort((a, b) => b.amount - a.amount)\n  needersSorted.sort((a, b) => b.amount - a.amount)\n  while (haversSorted.length > 0 && needersSorted.length > 0) {\n    const mostHaver = haversSorted.pop()\n    const mostNeeder = needersSorted.pop()\n    const diff = mostHaver.amount - mostNeeder.amount\n    if (diff < 0) {\n      // we used up everything the haver had\n      minimizedDistribution.push({ amount: mostHaver.amount, fromMemberID: mostHaver.memberID, toMemberID: mostNeeder.memberID })\n      mostNeeder.amount -= mostHaver.amount\n      needersSorted.push(mostNeeder)\n    } else if (diff > 0) {\n      // we completely filled up the needer's need and still have some left over\n      minimizedDistribution.push({ amount: mostNeeder.amount, fromMemberID: mostHaver.memberID, toMemberID: mostNeeder.memberID })\n      mostHaver.amount -= mostNeeder.amount\n      haversSorted.push(mostHaver)\n    } else {\n      // a perfect match\n      minimizedDistribution.push({ amount: mostNeeder.amount, fromMemberID: mostHaver.memberID, toMemberID: mostNeeder.memberID })\n    }\n  }\n  return minimizedDistribution\n}\n", "'use strict'\n\nimport { cloneDeep } from 'turtledash'\nimport { DECIMALS_MAX, saferFloat } from '../currencies.js'\nimport mincomeProportional from './mincome-proportional.js'\nimport minimizeTotalPaymentsCount from './payments-minimizer.js'\n\n                                  \n\nconst tinyNum = 1 / Math.pow(10, DECIMALS_MAX)\n\nexport function unadjustedDistribution ({ haveNeeds = [], minimize = true }   \n                                              \n )               {\n  const distribution = mincomeProportional(haveNeeds)\n  return minimize ? minimizeTotalPaymentsCount(distribution) : distribution\n}\n\nexport function adjustedDistribution (\n  { distribution, payments, dueOn }                                                                       \n)               {\n  distribution = cloneDeep(distribution)\n  // ensure the total is set because of how reduceDistribution works\n  for (const todo of distribution) {\n    todo.total = todo.amount\n  }\n  distribution = subtractDistributions(distribution, payments)\n    // remove any todos for containing miniscule amounts\n    // and pledgers who switched sides should have their todos removed\n    .filter(todo => todo.amount >= tinyNum)\n  for (const todo of distribution) {\n    todo.amount = saferFloat(todo.amount)\n    todo.total = saferFloat(todo.total)\n    todo.partial = todo.total !== todo.amount\n    todo.isLate = false\n    todo.dueOn = dueOn\n  }\n  // TODO: add in latePayments to the end of the distribution\n  //       consider passing in latePayments\n  return distribution\n}\n\n// Merges multiple payments between any combinations two of users:\nfunction reduceDistribution (payments              )               {\n  // Don't modify the payments list/object parameter in-place, as this is not intended:\n  payments = cloneDeep(payments)\n  for (let i = 0; i < payments.length; i++) {\n    const paymentA = payments[i]\n    for (let j = i + 1; j < payments.length; j++) {\n      const paymentB = payments[j]\n\n      // Were paymentA and paymentB between the same two users?\n      if ((paymentA.fromMemberID === paymentB.fromMemberID && paymentA.toMemberID === paymentB.toMemberID) ||\n        (paymentA.toMemberID === paymentB.fromMemberID && paymentA.fromMemberID === paymentB.toMemberID)) {\n        // Add or subtract paymentB's amount to paymentA's amount, depending on the relative\n        // direction of the two payments:\n        paymentA.amount += (paymentA.fromMemberID === paymentB.fromMemberID ? 1 : -1) * paymentB.amount\n        paymentA.total += (paymentA.fromMemberID === paymentB.fromMemberID ? 1 : -1) * paymentB.total\n        // Remove paymentB from payments, and decrement the inner sentinal loop variable:\n        payments.splice(j, 1)\n        j--\n      }\n    }\n  }\n  return payments\n}\n\nfunction addDistributions (paymentsA              , paymentsB              )               {\n  return reduceDistribution([...paymentsA, ...paymentsB])\n}\n\nfunction subtractDistributions (paymentsA              , paymentsB              )               {\n  // Don't modify any payment list/objects parameters in-place, as this is not intended:\n  paymentsB = cloneDeep(paymentsB)\n  // Reverse the sign of the second operand's amounts so that the final addition is actually subtraction:\n  for (const p of paymentsB) {\n    p.amount *= -1\n    p.total *= -1\n  }\n  return addDistributions(paymentsA, paymentsB)\n}\n"],
  "mappings": "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",
  "names": ["mincomeProportional", "haveNeeds", "totalHave", "totalNeed", "havers", "needers", "haveNeed", "totalPercent", "payments", "haver", "distributionAmount", "needer", "belowPercentage", "minimizeTotalPaymentsCount", "distribution", "neederTotalReceived", "haverTotalHave", "haversSorted", "needersSorted", "minimizedDistribution", "todo", "memberID", "a", "b", "mostHaver", "mostNeeder", "diff", "tinyNum", "unadjustedDistribution", "haveNeeds", "minimize", "distribution", "mincomeProportional", "minimizeTotalPaymentsCount", "adjustedDistribution", "payments", "dueOn", "cloneDeep", "todo", "subtractDistributions", "saferFloat", "reduceDistribution", "i", "paymentA", "j", "paymentB", "addDistributions", "paymentsA", "paymentsB", "p"]
}
