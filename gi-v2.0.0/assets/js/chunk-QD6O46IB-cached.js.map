{
  "version": 3,
  "sources": ["../../../node_modules/@chelonia/serdes/dist/esm/index.js", "../../../shared/domains/chelonia/Secret.js"],
  "sourcesContent": ["export const serdesTagSymbol = Symbol('tag');\nexport const serdesSerializeSymbol = Symbol('serialize');\nexport const serdesDeserializeSymbol = Symbol('deserialize');\n// This file is at attempt at addressing the lack of support for\n// custom objects in `structuredClone`. See <https://github.com/whatwg/html/issues/7428>.\n// We need this so that certain custom objects can be shared using a\n// `MessagePort`. To use this functionality, the `serializer` function must be\n// called on the _sending_ side and the `deserializer` function must be called\n// on the _receiving_ side.\n// Note that it's paramount that the _receiving_ side call `deserializer.register`\n// with all of the possible types that are supported.\n// For how to implement `serialize` and `deserialize` support for custom types,\n// see the example below for a class `X`.\n// These functions are meant to provide, more or less, an augmented version of\n// `structuredClone`, thus allowing messages to contain complex JavaScript\n// objects, in ways that JSON simply cannot support. For this, JSON.parse and\n// JSON.stringify are used to deeply traverse objects, which, combined with\n// reviver and replacer callbacks, allows for reconstructing custom object\n// types that neither structuredClone nor JSON support on their own (e.g.,\n// functions, GIMessage, Secret, etc.).\n// Internal function to mark the result of 'serializer' as internal, so that it\n// doesn't get accidentally reprocessed.\nconst rawResult = (rawResultSet, obj) => {\n    rawResultSet.add(obj);\n    return obj;\n};\n// The `serializer` function prepares data before sending it as a message\nexport const serializer = (data) => {\n    const rawResultSet = new WeakSet();\n    const verbatim = [];\n    const transferables = new Set();\n    const revokables = new Set();\n    // JSON.parse and JSON.stringify are called for their ability to do a deep\n    // clone and calling a reviver / replacer.\n    const result = JSON.parse(JSON.stringify(data, (_key, value) => {\n        // Return already processed values without modifications\n        if (value && typeof value === 'object' && rawResultSet.has(value))\n            return value;\n        // Encode undefined as ['_', '_']\n        if (value === undefined)\n            return rawResult(rawResultSet, ['_', '_']);\n        // Encode falsy values as they are (JSON.stringify can handle these well,\n        // except undefined, which can't be represented in JSON)\n        if (!value)\n            return value;\n        // Arrays starting with '_' hold special (internal) meaning. If we receive\n        // such a value to encode, we prepend '_', '_' to ensure they are properly\n        // handled (this will be undone when deserializing)\n        if (Array.isArray(value) && value[0] === '_')\n            return rawResult(rawResultSet, ['_', '_', ...value]);\n        // If something is a Map, encode it as such. It needs to be broken down into\n        // an array so that elements they contain can also be processed, since JSON\n        // does not support Map\n        if (value instanceof Map) {\n            return rawResult(rawResultSet, ['_', 'Map', Array.from(value.entries())]);\n        }\n        // Same for Sets\n        if (value instanceof Set) {\n            return rawResult(rawResultSet, ['_', 'Set', Array.from(value.values())]);\n        }\n        // Error, Blob, File, etc. are supported by structuredClone but not by JSON\n        // We mark these as 'refs', so that the reviver can undo this transformation\n        if (value instanceof Blob || value instanceof File) {\n            const pos = verbatim.length;\n            verbatim[verbatim.length] = value;\n            return rawResult(rawResultSet, ['_', '_ref', pos]);\n        }\n        // However, Error cloning doesn't preserve `.name`\n        if (value instanceof Error) {\n            const pos = verbatim.length;\n            verbatim[verbatim.length] = value;\n            // We need to also serialize `Error.cause` recursively\n            if (value.cause) {\n                value.cause = serializer(value.cause).data;\n            }\n            return rawResult(rawResultSet, ['_', '_err', rawResult(rawResultSet, ['_', '_ref', pos]), value.name]);\n        }\n        // Same for other types supported by structuredClone but not JSON\n        if (value instanceof MessagePort || value instanceof ReadableStream || value instanceof WritableStream || value instanceof ArrayBuffer) {\n            const pos = verbatim.length;\n            verbatim[verbatim.length] = value;\n            transferables.add(value);\n            return rawResult(rawResultSet, ['_', '_ref', pos]);\n        }\n        if (ArrayBuffer.isView(value)) {\n            const pos = verbatim.length;\n            verbatim[verbatim.length] = value;\n            transferables.add(value.buffer);\n            return rawResult(rawResultSet, ['_', '_ref', pos]);\n        }\n        // Functions aren't supported neither by structuredClone nor JSON. However,\n        // we can convert functions into a MessagePort, which is supported\n        if (typeof value === 'function') {\n            const mc = new MessageChannel();\n            mc.port1.onmessage = async (ev) => {\n                try {\n                    try {\n                        const result = await value(...deserializer(ev.data[1]));\n                        const { data, transferables } = serializer(result);\n                        ev.data[0].postMessage([true, data], transferables);\n                    }\n                    catch (e) {\n                        const { data, transferables } = serializer(e);\n                        ev.data[0].postMessage([false, data], transferables);\n                    }\n                }\n                catch (e) {\n                    console.error('Async error on onmessage handler', e);\n                }\n            };\n            transferables.add(mc.port2);\n            revokables.add(mc.port1);\n            return rawResult(rawResultSet, ['_', '_fn', mc.port2]);\n        }\n        const proto = Object.getPrototypeOf(value);\n        // This allows encoding custom arbitrary objects (e.g., GIMessage)\n        if (proto?.constructor?.[serdesTagSymbol] && proto.constructor[serdesSerializeSymbol]) {\n            return rawResult(rawResultSet, ['_', '_custom', proto.constructor[serdesTagSymbol], proto.constructor[serdesSerializeSymbol](value)]);\n        }\n        return value;\n    }), (_key, value) => {\n        // Undo _ref transformations so that structuredClone can send the correct\n        // object\n        if (Array.isArray(value) && value[0] === '_' && value[1] === '_ref') {\n            return verbatim[value[2]];\n        }\n        return value;\n    });\n    return {\n        data: result,\n        transferables: Array.from(transferables),\n        revokables: Array.from(revokables)\n    };\n};\n// Internal lookup table for registered deserializers\nconst deserializerTable = Object.create(null);\n// The `deserializer` function reconstructs data on the receiving side\nexport const deserializer = (data) => {\n    const rawResultSet = new WeakSet();\n    const verbatim = [];\n    // JSON.parse and JSON.stringify are called for their ability to do a deep\n    // clone and calling a reviver / replacer.\n    return JSON.parse(JSON.stringify(data, (_key, value) => {\n        if (value && typeof value === 'object' && !rawResultSet.has(value) && !Array.isArray(value) && Object.getPrototypeOf(value) !== Object.prototype) {\n            const pos = verbatim.length;\n            verbatim[verbatim.length] = value;\n            return rawResult(rawResultSet, ['_', '_ref', pos]);\n        }\n        return value;\n    }), (_key, value) => {\n        if (Array.isArray(value) && value[0] === '_') {\n            switch (value[1]) {\n                case '_':\n                    if (value.length >= 3) {\n                        // This was an input that was an array starting with [_, _]\n                        return value.slice(2);\n                    }\n                    else {\n                        // This was 'undefined' ([_, _])\n                        return;\n                    }\n                // Map input (reconstruct Map)\n                case 'Map':\n                    return new Map(value[2]);\n                // Set input (reconstruct Set)\n                case 'Set':\n                    return new Set(value[2]);\n                // Custom object type (reconstruct if possible, otherwise throw an error)\n                case '_custom':\n                    if (deserializerTable[value[2]]) {\n                        return deserializerTable[value[2]](value[3]);\n                    }\n                    else {\n                        throw new Error('Invalid or unknown tag: ' + value[2]);\n                    }\n                // These are literal values, return them\n                case '_ref':\n                    return verbatim[value[2]];\n                case '_err': {\n                    if (value[2].name !== value[3]) {\n                        value[2].name = value[3];\n                    }\n                    if (value[2].cause) {\n                        value[2].cause = deserializer(value[2].cause);\n                    }\n                    return value[2];\n                }\n                // These were functions converted to a MessagePort. Convert them on this\n                // end back into functions using that port.\n                case '_fn': {\n                    const mp = value[2];\n                    return (...args) => {\n                        return new Promise((resolve, reject) => {\n                            const mc = new MessageChannel();\n                            const { data, transferables } = serializer(args);\n                            mc.port1.onmessage = (ev) => {\n                                if (ev.data[0]) {\n                                    resolve(deserializer(ev.data[1]));\n                                }\n                                else {\n                                    reject(deserializer(ev.data[1]));\n                                }\n                            };\n                            mp.postMessage([mc.port2, data], [mc.port2, ...transferables]);\n                        });\n                    };\n                }\n            }\n        }\n        return value;\n    });\n};\n// The proper types are closer to the following commented out code, but it's\n// not supported or difficult to support with Flow\ndeserializer.register = (ctor) => {\n    if (typeof ctor === 'function' && typeof ctor[serdesTagSymbol] === 'string' && typeof ctor[serdesDeserializeSymbol] === 'function') {\n        deserializerTable[ctor[serdesTagSymbol]] = ctor[serdesDeserializeSymbol].bind(ctor);\n    }\n};\n/*\n// Example\n\nclass X {\n  __x: '11';\n  constructor () {\n    this.__x = '11'\n  }\n  static [serdesDeserializeSymbol] () {\n    return new this()\n  }\n  static get [serdesTagSymbol] () {\n    return 'X'\n  }\n  static [serdesSerializeSymbol] (x: InstanceType<typeof this>) {\n    return undefined\n  }\n}\n\ndeserializer.register(X)\n\nconsole.log(\n  deserializer(\n    structuredClone(\n      serializer(\n        [\n          '_',\n          '_',\n          [\n            '_',\n            '_',\n            '_',\n            new Map([['a', new X()], ['b', new Error('my error')]])\n          ]\n        ]\n      )\n    )\n  )\n)\n*/\n", "//      \n\nimport { serdesDeserializeSymbol, serdesSerializeSymbol, serdesTagSymbol } from '@chelonia/serdes'\n\n/* Wrapper class for secrets, which identifies them as such and prevents them\nfrom being logged */\n\n// Use a `WeakMap` to store the actual secret outside of the returned `Secret`\n// object. This ensures that the only way to access the secret is via the\n// `.valueOf()` method, and it prevents accidentally logging things that\n// shouldn't be logged.\nconst wm = new WeakMap()\nexport class Secret    {\n  // $FlowFixMe[unsupported-syntax]\n  static [serdesDeserializeSymbol] (secret) {\n    return new this(secret)\n  }\n\n  // $FlowFixMe[unsupported-syntax]\n  static [serdesSerializeSymbol] (secret        ) {\n    return wm.get(secret)\n  }\n\n  // $FlowFixMe[unsupported-syntax]\n  static get [serdesTagSymbol] () {\n    return '__chelonia_Secret'\n  }\n\n  constructor (value   ) {\n    // $FlowFixMe[escaped-generic]\n    wm.set(this, value)\n  }\n\n  valueOf ()    {\n    // $FlowFixMe[escaped-generic]\n    // $FlowFixMe[incompatible-return]\n    return wm.get(this)\n  }\n}\n"],
  "mappings": "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",
  "names": ["serdesTagSymbol", "serdesSerializeSymbol", "serdesDeserializeSymbol", "rawResult", "rawResultSet", "obj", "serializer", "data", "verbatim", "transferables", "revokables", "_key", "value", "pos", "mc", "ev", "result", "deserializer", "e", "proto", "deserializerTable", "mp", "args", "resolve", "reject", "ctor", "wm", "Secret", "serdesDeserializeSymbol", "secret", "serdesSerializeSymbol", "serdesTagSymbol", "value"]
}
