{
  "version": 3,
  "sources": ["../../../frontend/model/contracts/misc/flowTyper.js"],
  "sourcesContent": ["// to make rollup happy, I copied flowTyper-js\n// library into this file (it was refusing to\n// import because of the way functions were being\n// exported).\n//\n// GI EDIT NOTES:\n//\n// - The following functions can be used directly with 'validate'\n//   because they've had their '_scope' second parameter removed:\n//   - arrayOf\n//   - mapOf\n//   - object\n//   - objectOf\n//   - objectMaybeOf (this is a custom function that didn't exist in flowTyper)\n//\n// TODO: remove this file from eslintIgnore in package.json and fix errors\n\n                                             \n                                           \n                                                \n                                                      \n                                                       \n                                                            \n                                                 \n\n                                \n                   \n                  \n \n\n                                   \n                   \n                   \n                  \n \n\n                                      \n                   \n                   \n                   \n                   \n \n\n                                         \n                   \n                   \n                   \n                   \n                  \n \n\nexport const EMPTY_VALUE = Symbol('@@empty')\nexport const isEmpty = v => v === EMPTY_VALUE\nexport const isNil = v => v === null\nexport const isUndef = v => typeof v === 'undefined'\nexport const isBoolean = v => typeof v === 'boolean'\nexport const isNumber = v => typeof v === 'number'\nexport const isString = v => typeof v === 'string'\nexport const isObject = v => !isNil(v) && typeof v === 'object'\nexport const isFunction = v => typeof v === 'function'\n\nexport const isType = typeFn => (v, _scope = '') => {\n  try {\n    typeFn(v, _scope)\n    return true\n  } catch (_) {\n    return false\n  }\n}\n\n// This function will return value based on schema with inferred types. This\n// value can be used to define type in Flow with 'typeof' utility.\nexport const typeOf = schema => schema(EMPTY_VALUE, '')\nexport const getType = (typeFn, _options) => {\n  if (isFunction(typeFn.type)) return typeFn.type(_options)\n  return typeFn.name || '?'\n}\n\n// error\nexport class TypeValidatorError extends Error {\n  expectedType        \n  valueType        \n  value        \n  typeScope        \n  sourceFile        \n\n  constructor (\n    message         ,\n    expectedType        ,\n    valueType        ,\n    value        ,\n    typeName         = '',\n    typeScope          = ''\n  ) {\n    const errMessage = message ||\n      `invalid \"${valueType}\" value type; ${typeName || expectedType} type expected`\n    super(errMessage)\n    this.expectedType = expectedType\n    this.valueType = valueType\n    this.value = value\n    this.typeScope = typeScope || ''\n    this.sourceFile = this.getSourceFile()\n    this.message = `${errMessage}\\n${this.getErrorInfo()}`\n    this.name = this.constructor.name\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TypeValidatorError)\n    }\n  }\n\n  getSourceFile ()         {\n    const fileNames = this.stack.match(/(\\/[\\w_\\-.]+)+(\\.\\w+:\\d+:\\d+)/g) || []\n    return fileNames.find(fileName => fileName.indexOf('/flowTyper-js/dist/') === -1) || ''\n  }\n\n  getErrorInfo ()         {\n    return `\n    file     ${this.sourceFile}\n    scope    ${this.typeScope}\n    expected ${this.expectedType.replace(/\\n/g, '')}\n    type     ${this.valueType}\n    value    ${this.value}\n`\n  }\n}\n\n// TypeValidatorError.prototype.name = 'TypeValidatorError'\n// exports.TypeValidatorError = TypeValidatorError\n\nconst validatorError =    (\n  typeFn                  ,\n  value       ,\n  scope         ,\n  message         ,\n  expectedType         ,\n  valueType         \n)                     => {\n  return new TypeValidatorError(\n    message,\n    expectedType || getType(typeFn),\n    valueType || typeof value,\n    JSON.stringify(value),\n    typeFn.name,\n    scope\n  )\n}\n\nexport const arrayOf =\n     (typeFn                  , _scope          = 'Array')                        => {\n    function array (value) {\n      if (isEmpty(value)) return [typeFn(value)]\n      if (Array.isArray(value)) {\n        let index = 0\n        return value.map(v => typeFn(v, `${_scope}[${index++}]`))\n      }\n      throw validatorError(array, value, _scope)\n    }\n    array.type = () => `Array<${getType(typeFn)}>`\n    return array\n  }\n\nexport const literalOf =\n                   (primitive   )                   => {\n    function literal (value, _scope = '') {\n      if (isEmpty(value) || (value === primitive)) return primitive\n      throw validatorError(literal, value, _scope)\n    }\n    literal.type = () => {\n      if (isBoolean(primitive)) return `${primitive ? 'true' : 'false'}`\n      else return `\"${primitive}\"`\n    }\n    return literal\n  }\n\nexport const mapOf =       (\n  keyTypeFn                  ,\n  typeFn                  \n)                            => {\n  function mapOf (value) {\n    if (isEmpty(value)) return {}\n    const o = object(value)\n    const reducer = (acc, key) =>\n      Object.assign(\n        acc,\n        {\n          // $FlowFixMe\n          [keyTypeFn(key, 'Map[_]')]: typeFn(o[key], `Map.${key}`)\n        }\n      )\n    return Object.keys(o).reduce(reducer, {})\n  }\n  mapOf.type = () => `{ [_:${getType(keyTypeFn)}]: ${getType(typeFn)} }`\n  return mapOf\n}\n\nconst isPrimitiveFn = (typeName) =>\n  ['undefined', 'null', 'boolean', 'number', 'string'].includes(typeName)\n\nexport const maybe =\n     (typeFn                  )                        => {\n    function maybe (value, _scope = '') {\n      return (isNil(value) || isUndef(value)) ? value : typeFn(value, _scope)\n    }\n    maybe.type = () => !isPrimitiveFn(typeFn.name) ? `?(${getType(typeFn)})` : `?${getType(typeFn)}`\n    return maybe\n  }\n\nexport const mixed = (\n  function mixed (value) {\n    return value\n  }                  \n)\n\nexport const object = (\n  function (value) {\n    if (isEmpty(value)) return {}\n    if (isObject(value) && !Array.isArray(value)) {\n      return Object.assign({}, value)\n    }\n    throw validatorError(object, value)\n  }                                    \n)\n\nexport const objectOf =                            \n  (typeObj   , _scope          = 'Object')                                                        => {\n  function object2 (value) {\n    const o = object(value)\n    const typeAttrs = Object.keys(typeObj)\n    const unknownAttr = Object.keys(o).find(attr => !typeAttrs.includes(attr))\n    if (unknownAttr) {\n      throw validatorError(\n        object2,\n        value,\n        _scope,\n        `missing object property '${unknownAttr}' in ${_scope} type`\n      )\n    }\n    // IMPORTANT: because esbuild can actually rename the functions in the compiled source\n    //            (e.g. from 'optional' to 'optional2'), we use .includes() instead of ===\n    //            to check the .name of a function\n    const undefAttr = typeAttrs.find(property => {\n      const propertyTypeFn = typeObj[property]\n      return (propertyTypeFn.name.includes('maybe') && !o.hasOwnProperty(property))\n    })\n    if (undefAttr) {\n      throw validatorError(\n        object2,\n        o[undefAttr],\n        `${_scope}.${undefAttr}`,\n        `empty object property '${undefAttr}' for ${_scope} type`,\n        `void | null | ${getType(typeObj[undefAttr]).substr(1)}`,\n        '-'\n      )\n    }\n\n    const reducer = isEmpty(value)\n      ? (acc, key) => Object.assign(acc, { [key]: typeObj[key](value) })\n      : (acc, key) => {\n        const typeFn = typeObj[key]\n        if (typeFn.name.includes('optional') && !o.hasOwnProperty(key)) {\n          return Object.assign(acc, {})\n        } else {\n          return Object.assign(acc, { [key]: typeFn(o[key], `${_scope}.${key}`) })\n        }\n      }\n    return typeAttrs.reduce(reducer, {})\n  }\n  object2.type = () => {\n    const props = Object.keys(typeObj).map(\n      (key) => {\n        const ret = typeObj[key].name.includes('optional')\n        ? `${key}?: ${getType(typeObj[key], { noVoid: true })}`\n        : `${key}: ${getType(typeObj[key])}`\n        return ret\n      }\n    )\n    return `{|\\n ${props.join(',\\n  ')} \\n|}`\n  }\n  return object2\n}\n\n// TODO: add flow type annotations and make it use validatorError etc.\nexport function objectMaybeOf (validations        , _scope          = 'Object')         {\n  return function (data     ) {\n    object(data)\n    for (const key in data) {\n      validations[key]?.(data[key], `${_scope}.${key}`)\n    }\n    return data\n  }\n}\n\nexport const optional =\n     (typeFn                  )                          => {\n    const unionFn = unionOf(typeFn, undef)\n    function optional (v) {\n      return unionFn(v)\n    }\n    optional.type = ({ noVoid }) => !noVoid ? getType(unionFn) : getType(typeFn)\n    return optional\n  }\n\nexport const nil = (\n  function nil (value) {\n    if (isEmpty(value) || isNil(value)) return null\n    throw validatorError(nil, value)\n  }\n                       \n)\n\nexport function undef (value, _scope = '') {\n  if (isEmpty(value) || isUndef(value)) return undefined\n  throw validatorError(undef, value, _scope)\n}\nundef.type = () => 'void'\n// export const undef = (undef: TypeValidator<void>)\n\nexport const boolean = (\n  function boolean (value, _scope = '') {\n    if (isEmpty(value)) return false\n    if (isBoolean(value)) return value\n    throw validatorError(boolean, value, _scope)\n  }\n                          \n)\n\nexport const number = (\n  function number (value, _scope = '') {\n    if (isEmpty(value)) return 0\n    if (isNumber(value)) return value\n    throw validatorError(number, value, _scope)\n  }\n                         \n)\n\nexport const numberRange = (from        , to        , key         = '')                        => {\n  if (!isNumber(from) || !isNumber(to)) { throw new TypeError('Params for numberRange must be numbers') }\n  if (from >= to) { throw new TypeError('Params \"to\" should be bigger than \"from\"') }\n\n  function numberRange (value, _scope = '') {\n    number(value, _scope)\n    if (value >= from && value <= to) return value\n    throw validatorError(\n      numberRange,\n      value,\n      _scope,\n      key\n        ? `number type '${key}' must be within the range of [${from}, ${to}]`\n        : `must be within the range of [${from}, ${to}]`\n    )\n  }\n  numberRange.type = `number(range: [${from}, ${to}])`\n  return numberRange\n}\n\nexport const string = (\n  function string (value, _scope = '') {\n    if (isEmpty(value)) return ''\n    if (isString(value)) return value\n    throw validatorError(string, value, _scope)\n  }\n                         \n)\n\nexport const stringMax = (numChar        , key         = '')                        => {\n  if (!isNumber(numChar)) { throw new Error('param for stringMax must be number') }\n\n  function stringMax (value, _scope = '') {\n    string(value, _scope)\n    if (value.length <= numChar) return value\n    throw validatorError(\n      stringMax,\n      value,\n      _scope,\n      key\n        ? `string type '${key}' cannot exceed ${numChar} characters`\n        : `cannot exceed ${numChar} characters`\n    )\n  }\n  stringMax.type = () => `string(max: ${numChar})`\n  return stringMax\n}\n\n                            \n             \n                                     \n                                                 \n                                                             \n                                                                         \n                                                                                     \n                                                                                                 \n                                                                                                             \n                                                                                                                         \n                                                                                                                                     \n                                                                                                                                                 \n\nfunction tupleOf_ (...typeFuncs) {\n  function tuple (value       , _scope = '') {\n    const cardinality = typeFuncs.length\n    if (isEmpty(value)) return typeFuncs.map(fn => fn(value))\n    if (Array.isArray(value) && value.length === cardinality) {\n      const tupleValue = []\n      for (let i = 0; i < cardinality; i += 1) {\n        tupleValue.push(typeFuncs[i](value[i], _scope))\n      }\n      return tupleValue\n    }\n    throw validatorError(tuple, value, _scope)\n  }\n  tuple.type = () => `[${typeFuncs.map(fn => getType(fn)).join(', ')}]`\n  return tuple\n}\n\n// $FlowFixMe - $Tuple<(A, B, C, ...)[]>\n// const tupleOf: TupleT = tupleOf_\nexport const tupleOf = tupleOf_\n\n             \n                                   \n                                                \n                                                             \n                                                                          \n                                                                                       \n                                                                                                    \n                                                                                                                 \n                                                                                                                              \n                                                                                                                                           \n                                                                                                                                                        \n\nfunction unionOf_ (...typeFuncs) {\n  function union (value       , _scope = '') {\n    for (const typeFn of typeFuncs) {\n      try {\n        return typeFn(value, _scope)\n      } catch (_) {}\n    }\n    throw validatorError(union, value, _scope)\n  }\n  union.type = () => `(${typeFuncs.map(fn => getType(fn)).join(' | ')})`\n  return union\n}\n// $FlowFixMe\n// const unionOf: UnionT = (unionOf_)\nexport const unionOf = unionOf_\n\nexport const actionRequireInnerSignature = (next          )           => (data, props) => {\n  const innerSigningContractID = props.message.innerSigningContractID\n  if (!innerSigningContractID || innerSigningContractID === props.contractID) {\n    throw new Error('Missing inner signature')\n  }\n  return next(data, props)\n}\nexport const validatorFrom = (fn) => {\n  function customType (value       , _scope = '') {\n    if (!fn(value)) {\n      throw validatorError(customType, value, _scope)\n    }\n    return value\n  }\n  return customType\n}\n"],
  "mappings": "AAmDO,IAAMA,EAAc,OAAO,SAAS,EAC9BC,EAAUC,GAAKA,IAAMF,EACrBG,EAAQD,GAAKA,IAAM,KACnBE,EAAUF,GAAK,OAAOA,EAAM,IAC5BG,EAAYH,GAAK,OAAOA,GAAM,UAC9BI,EAAWJ,GAAK,OAAOA,GAAM,SAC7BK,EAAWL,GAAK,OAAOA,GAAM,SAC7BM,EAAWN,GAAK,CAACC,EAAMD,CAAC,GAAK,OAAOA,GAAM,SAC1CO,EAAaP,GAAK,OAAOA,GAAM,WAcrC,IAAMQ,EAAU,CAACC,EAAQC,IAC1BC,EAAWF,EAAO,IAAI,EAAUA,EAAO,KAAKC,CAAQ,EACjDD,EAAO,MAAQ,IAIXG,EAAN,MAAMC,UAA2B,KAAM,CAC5C,aACA,UACA,MACA,UACA,WAEA,YACEC,EACAC,EACAC,EACAC,EACAC,EAAmB,GACnBC,EAAqB,GACrB,CACA,IAAMC,EAAaN,GACjB,YAAYE,CAAS,iBAAiBE,GAAYH,CAAY,iBAChE,MAAMK,CAAU,EAChB,KAAK,aAAeL,EACpB,KAAK,UAAYC,EACjB,KAAK,MAAQC,EACb,KAAK,UAAYE,GAAa,GAC9B,KAAK,WAAa,KAAK,cAAc,EACrC,KAAK,QAAU,GAAGC,CAAU;AAAA,EAAK,KAAK,aAAa,CAAC,GACpD,KAAK,KAAO,KAAK,YAAY,KACzB,MAAM,mBACR,MAAM,kBAAkB,KAAMP,CAAkB,CAEpD,CAEA,eAAyB,CAEvB,OADkB,KAAK,MAAM,MAAM,gCAAgC,GAAK,CAAC,GACxD,KAAKQ,GAAYA,EAAS,QAAQ,qBAAqB,IAAM,EAAE,GAAK,EACvF,CAEA,cAAwB,CACtB,MAAO;AAAA,eACI,KAAK,UAAU;AAAA,eACf,KAAK,SAAS;AAAA,eACd,KAAK,aAAa,QAAQ,MAAO,EAAE,CAAC;AAAA,eACpC,KAAK,SAAS;AAAA,eACd,KAAK,KAAK;AAAA,CAEvB,CACF,EAKMC,EAAoB,CACxBb,EACAQ,EACAM,EACAT,EACAC,EACAC,IAEO,IAAIJ,EACTE,EACAC,GAAgBP,EAAQC,CAAM,EAC9BO,GAAa,OAAOC,EACpB,KAAK,UAAUA,CAAK,EACpBR,EAAO,KACPc,CACF,EAiBK,IAAMC,EACOC,GAAmC,CACnD,SAASC,EAASC,EAAOC,EAAS,GAAI,CACpC,GAAIC,EAAQF,CAAK,GAAMA,IAAUF,EAAY,OAAOA,EACpD,MAAMK,EAAeJ,EAASC,EAAOC,CAAM,CAC7C,CACA,OAAAF,EAAQ,KAAO,IACTK,EAAUN,CAAS,EAAU,GAAGA,EAAY,OAAS,OAAO,GACpD,IAAIA,CAAS,IAEpBC,CACT,EAyCK,IAAMM,EACX,SAAUC,EAAO,CACf,GAAIC,EAAQD,CAAK,EAAG,MAAO,CAAC,EAC5B,GAAIE,EAASF,CAAK,GAAK,CAAC,MAAM,QAAQA,CAAK,EACzC,OAAO,OAAO,OAAO,CAAC,EAAGA,CAAK,EAEhC,MAAMG,EAAeJ,EAAQC,CAAK,CACpC,EAGWI,EACX,CAACC,EAAYC,EAAkB,WAAoE,CACnG,SAASC,EAASP,EAAO,CACvB,IAAMQ,EAAIT,EAAOC,CAAK,EAChBS,EAAY,OAAO,KAAKJ,CAAO,EAC/BK,EAAc,OAAO,KAAKF,CAAC,EAAE,KAAKG,GAAQ,CAACF,EAAU,SAASE,CAAI,CAAC,EACzE,GAAID,EACF,MAAMP,EACJI,EACAP,EACAM,EACA,4BAA4BI,CAAW,QAAQJ,CAAM,OACvD,EAKF,IAAMM,EAAYH,EAAU,KAAKI,GACRR,EAAQQ,CAAQ,EAChB,KAAK,SAAS,OAAO,GAAK,CAACL,EAAE,eAAeK,CAAQ,CAC5E,EACD,GAAID,EACF,MAAMT,EACJI,EACAC,EAAEI,CAAS,EACX,GAAGN,CAAM,IAAIM,CAAS,GACtB,0BAA0BA,CAAS,SAASN,CAAM,QAClD,iBAAiBQ,EAAQT,EAAQO,CAAS,CAAC,EAAE,OAAO,CAAC,CAAC,GACtD,GACF,EAGF,IAAMG,EAAUd,EAAQD,CAAK,EACzB,CAACgB,EAAKC,IAAQ,OAAO,OAAOD,EAAK,CAAE,CAACC,CAAG,EAAGZ,EAAQY,CAAG,EAAEjB,CAAK,CAAE,CAAC,EAC/D,CAACgB,EAAKC,IAAQ,CACd,IAAMC,EAASb,EAAQY,CAAG,EAC1B,OAAIC,EAAO,KAAK,SAAS,UAAU,GAAK,CAACV,EAAE,eAAeS,CAAG,EACpD,OAAO,OAAOD,EAAK,CAAC,CAAC,EAErB,OAAO,OAAOA,EAAK,CAAE,CAACC,CAAG,EAAGC,EAAOV,EAAES,CAAG,EAAG,GAAGX,CAAM,IAAIW,CAAG,EAAE,CAAE,CAAC,CAE3E,EACF,OAAOR,EAAU,OAAOM,EAAS,CAAC,CAAC,CACrC,CACA,OAAAR,EAAQ,KAAO,IASN;AAAA,GARO,OAAO,KAAKF,CAAO,EAAE,IAChCY,GACaZ,EAAQY,CAAG,EAAE,KAAK,SAAS,UAAU,EAC/C,GAAGA,CAAG,MAAMH,EAAQT,EAAQY,CAAG,EAAG,CAAE,OAAQ,EAAK,CAAC,CAAC,GACnD,GAAGA,CAAG,KAAKH,EAAQT,EAAQY,CAAG,CAAC,CAAC,EAGtC,EACqB,KAAK;AAAA,GAAO,CAAC;AAAA,IAE7BV,CACT,EA+BO,SAASY,EAAOC,EAAOC,EAAS,GAAI,CACzC,GAAI,EAAAC,EAAQF,CAAK,GAAKG,EAAQH,CAAK,GACnC,MAAMI,EAAeL,EAAOC,EAAOC,CAAM,CAC3C,CACAF,EAAM,KAAO,IAAM,OAYZ,IAAMM,EACX,SAASA,EAAQC,EAAOC,EAAS,GAAI,CACnC,GAAIC,EAAQF,CAAK,EAAG,MAAO,GAC3B,GAAIG,EAASH,CAAK,EAAG,OAAOA,EAC5B,MAAMI,EAAeL,EAAQC,EAAOC,CAAM,CAC5C,EAwBK,IAAMI,EACX,SAASA,EAAQC,EAAOC,EAAS,GAAI,CACnC,GAAIC,EAAQF,CAAK,EAAG,MAAO,GAC3B,GAAIG,EAASH,CAAK,EAAG,OAAOA,EAC5B,MAAMI,EAAeL,EAAQC,EAAOC,CAAM,CAC5C,EAqEF,SAASI,KAAaC,EAAW,CAC/B,SAASC,EAAOC,EAAcC,EAAS,GAAI,CACzC,QAAWC,KAAUJ,EACnB,GAAI,CACF,OAAOI,EAAOF,EAAOC,CAAM,CAC7B,MAAY,CAAC,CAEf,MAAME,EAAeJ,EAAOC,EAAOC,CAAM,CAC3C,CACA,OAAAF,EAAM,KAAO,IAAM,IAAID,EAAU,IAAIM,GAAMC,EAAQD,CAAE,CAAC,EAAE,KAAK,KAAK,CAAC,IAC5DL,CACT,CAGO,IAAMO,EAAUT",
  "names": ["EMPTY_VALUE", "isEmpty", "v", "isNil", "isUndef", "isBoolean", "isNumber", "isString", "isObject", "isFunction", "getType", "typeFn", "_options", "isFunction", "TypeValidatorError", "_TypeValidatorError", "message", "expectedType", "valueType", "value", "typeName", "typeScope", "errMessage", "fileName", "validatorError", "scope", "literalOf", "primitive", "literal", "value", "_scope", "isEmpty", "validatorError", "isBoolean", "object", "value", "isEmpty", "isObject", "validatorError", "objectOf", "typeObj", "_scope", "object2", "o", "typeAttrs", "unknownAttr", "attr", "undefAttr", "property", "getType", "reducer", "acc", "key", "typeFn", "undef", "value", "_scope", "isEmpty", "isUndef", "validatorError", "number", "value", "_scope", "isEmpty", "isNumber", "validatorError", "string", "value", "_scope", "isEmpty", "isString", "validatorError", "unionOf_", "typeFuncs", "union", "value", "_scope", "typeFn", "validatorError", "fn", "getType", "unionOf"]
}
