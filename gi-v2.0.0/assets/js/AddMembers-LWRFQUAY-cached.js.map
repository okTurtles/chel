{
  "version": 3,
  "sources": ["../../../frontend/views/containers/proposals/AddMembers.vue", "../../../shared/domains/chelonia/utils.js", "../../../frontend/controller/actions/utils.js"],
  "sourcesContent": ["/* script */\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport sbp from '@sbp/sbp'\nimport Vue from '../../../../node_modules/vue/dist/vue.esm.js'\nimport { mapState, mapGetters } from 'vuex'\nimport { validationMixin } from 'vuelidate'\nimport { PROPOSAL_INVITE_MEMBER } from '../../../../frontend/model/contracts/shared/constants.js'\nimport ProposalTemplate from './ProposalTemplate.vue'\nimport { createInvite } from '../../../../frontend/controller/actions/utils.js'\nconst __vue_script__ = ({\n  name: 'AddMembers',\n  mixins: [validationMixin],\n  components: {\n    ProposalTemplate\n  },\n  data () {\n    return {\n      form: {\n        invitees: []\n      },\n      ephemeral: {\n        currentStep: 0,\n        isValid: false,\n        invitesCount: 1\n      },\n      config: {\n        steps: [\n          'Member'\n        ]\n      }\n    }\n  },\n  computed: {\n    ...mapState([\n      'currentGroupId',\n      'loggedIn'\n    ]),\n    ...mapGetters([\n      'ourIdentityContractId',\n      'currentGroupState',\n      'currentWelcomeInvite',\n      'groupShouldPropose',\n      'groupSettings'\n    ]),\n    shouldGenerateInvitesImmediately () {\n      return this.currentWelcomeInvite.expires < Date.now() && // 1. anyone-can-join invite has expired\n        !this.groupShouldPropose // 2. The group is not big enough to create a proposal\n    }\n  },\n  methods: {\n    inviteeUpdate (e, index) {\n      if (e.target.value.length > 0 && !this.ephemeral.isValid) {\n        this.ephemeral.isValid = true\n      }\n      if (e.target.value.length === 0 && this.ephemeral.invitesCount === 1 && this.ephemeral.isValid) {\n        this.ephemeral.isValid = false\n      }\n    },\n    removeInvitee (index) {\n      this.ephemeral.invitesCount -= 1\n      this.form.invitees.splice(index, 1)\n    },\n    addInviteeSlot (e) {\n      this.ephemeral.invitesCount += 1\n      Vue.nextTick(() => {\n        const inviteeSlots = this.$refs.fieldset.getElementsByTagName('label')\n        const newInviteeSlot = inviteeSlots[inviteeSlots.length - 1]\n        newInviteeSlot && newInviteeSlot.focus()\n      })\n    },\n    async generateInviteImmediately () {\n      const groupId = this.currentGroupId\n      for (const invitee of this.form.invitees) {\n        try {\n          const inviteCreated = await createInvite({\n            contractID: groupId,\n            invitee,\n            creatorID: this.ourIdentityContractId,\n            expires: this.groupSettings.inviteExpiryProposal\n          })\n\n          await sbp('gi.actions/group/invite', {\n            contractID: groupId,\n            data: inviteCreated\n          })\n        } catch (err) {\n          // TODO: add a logic to present the error in the UI\n          console.error(`Invite to ${invitee} failed to be sent!`, err?.message)\n          break\n        }\n      }\n    },\n    async submit (form) {\n      if (this.shouldGenerateInvitesImmediately) {\n        await this.generateInviteImmediately()\n\n        this.$refs.modalTemplate.close()\n      } else {\n        let hasFailed = false\n        // NOTE: All invitees proposals will expire at the exact same time.\n        // That plus the proposal creator is what we'll use to know\n        // which proposals should be displayed visually together.\n        const expiresDateMs = Date.now() + this.groupSettings.proposals[PROPOSAL_INVITE_MEMBER].expires_ms\n\n        for (const invitee of this.form.invitees) {\n          const groupId = this.currentGroupId\n          try {\n            await sbp('gi.actions/group/proposal', {\n              contractID: groupId,\n              data: {\n                proposalType: PROPOSAL_INVITE_MEMBER,\n                proposalData: {\n                  memberName: invitee,\n                  reason: form.reason\n                },\n                votingRule: this.groupSettings.proposals[PROPOSAL_INVITE_MEMBER].rule,\n                expires_date_ms: expiresDateMs\n              }\n            })\n          } catch (e) {\n            hasFailed = true\n            console.error(`Invite to ${invitee} failed to be sent!`, e.message)\n            break\n          }\n        }\n        if (!hasFailed) {\n          this.ephemeral.currentStep += 1 // Show Success step!\n        }\n      }\n    }\n  }\n}        )\n\n/* template */\nvar __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('proposal-template',{ref:\"modalTemplate\",attrs:{\"title\":_vm.L(\"Add new members\"),\"disabled\":!_vm.ephemeral.isValid,\"maxSteps\":_vm.config.steps.length,\"currentStep\":_vm.ephemeral.currentStep,\"variant\":_vm.shouldGenerateInvitesImmediately ? \"addMemberImmediate\" : \"addMember\"},on:{\"update:currentStep\":function($event){return _vm.$set(_vm.ephemeral, \"currentStep\", $event)},\"update:current-step\":function($event){return _vm.$set(_vm.ephemeral, \"currentStep\", $event)},\"submit\":_vm.submit}},[(_vm.ephemeral.currentStep === 0)?_c('fieldset',{ref:\"fieldset\",staticClass:\"c-fieldset\",class:{\"is-shifted\": _vm.ephemeral.invitesCount > 1}},[_c('i18n',{staticClass:\"label\",attrs:{\"tag\":\"legend\"}},[_vm._v(\"Full name\")]),_vm._l((_vm.ephemeral.invitesCount),function(member,index){return _c('div',{key:(\"member-\" + index),staticClass:\"field c-fields-item\",attrs:{\"data-test\":\"invitee\"}},[_c('i18n',{staticClass:\"label sr-only\"},[_vm._v(\"Invitee name\")]),_c('div',{staticClass:\"inputgroup\"},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.form.invitees[index]),expression:\"form.invitees[index]\"}],staticClass:\"input\",attrs:{\"type\":\"text\",\"aria-label\":_vm.L(\"Full name\"),\"aria-required\":\"aria-required\"},domProps:{\"value\":(_vm.form.invitees[index])},on:{\"keyup\":function (e) { return _vm.inviteeUpdate(e, index); },\"input\":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.invitees, index, $event.target.value)}}}),_c('button',{staticClass:\"is-icon-small is-btn-shifted\",attrs:{\"type\":\"button\",\"data-test\":\"remove\",\"aria-label\":_vm.L(\"Remove invitee\")},on:{\"click\":function($event){return _vm.removeInvitee(index)}}},[_c('i',{staticClass:\"icon-times\"})])])],1)}),_c('button',{staticClass:\"link has-icon\",attrs:{\"type\":\"button\",\"data-test\":\"addInviteeSlot\"},on:{\"click\":_vm.addInviteeSlot}},[_c('i',{staticClass:\"icon-plus\"}),_c('i18n',[_vm._v(\"Add more\")])],1)],2):_vm._e()])}\nvar __vue_staticRenderFns__ = []\n\n  /* style */\n  const __vue_inject_styles__ = function (inject) {\n    if (!inject) return\n    inject(\"data-v-c4728296_0\", { source: \".c-fields-item[data-v-c4728296]{margin-bottom:1rem}.c-feedback[data-v-c4728296]{text-align:center}.c-fieldset .is-btn-shifted[data-v-c4728296]{display:none}.c-fieldset.is-shifted .is-btn-shifted[data-v-c4728296]{display:block}\", map: undefined, media: undefined })\n\n  }\n  /* scoped */\n  const __vue_scope_id__ = \"data-v-c4728296\"\n  /* module identifier */\n  const __vue_module_identifier__ = undefined\n  /* functional template */\n  const __vue_is_functional_template__ = false\n  /* component normalizer */\n  function __vue_normalize__(\n    template, style, script,\n    scope, functional, moduleIdentifier, shadowMode,\n    createInjector, createInjectorSSR, createInjectorShadow\n  ) {\n    const component = (typeof script === 'function' ? script.options : script) || {}\n\n    // For security concerns, we use only base name in production mode.\n    component.__file = \"style>\\n\"\n\n    if (!component.render) {\n      component.render = template.render\n      component.staticRenderFns = template.staticRenderFns\n      component._compiled = true\n\n      if (functional) component.functional = true\n    }\n\n    component._scopeId = scope\n\n    if (true) {\n      let hook\n      if (false) {\n        // In SSR.\n        hook = function(context) {\n          // 2.3 injection\n          context =\n            context || // cached call\n            (this.$vnode && this.$vnode.ssrContext) || // stateful\n            (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n          // 2.2 with runInNewContext: true\n          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n            context = __VUE_SSR_CONTEXT__\n          }\n          // inject component styles\n          if (style) {\n            style.call(this, createInjectorSSR(context))\n          }\n          // register component module identifier for async chunk inference\n          if (context && context._registeredComponents) {\n            context._registeredComponents.add(moduleIdentifier)\n          }\n        }\n        // used by ssr in case component is cached and beforeCreate\n        // never gets called\n        component._ssrRegister = hook\n      }\n      else if (style) {\n        hook = shadowMode \n          ? function(context) {\n              style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot))\n            }\n          : function(context) {\n              style.call(this, createInjector(context))\n            }\n      }\n\n      if (hook !== undefined) {\n        if (component.functional) {\n          // register for functional component in vue file\n          const originalRender = component.render\n          component.render = function renderWithStyleInjection(h, context) {\n            hook.call(context)\n            return originalRender(h, context)\n          }\n        } else {\n          // inject component registration as beforeCreate hook\n          const existing = component.beforeCreate\n          component.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n        }\n      }\n    }\n\n    return component\n  }\n  /* style inject */\n  function __vue_create_injector__() {\n    const styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {})\n    const isOldIE =\n      typeof navigator !== 'undefined' &&\n      /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase())\n\n    return function addStyle(id, css) {\n      if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) return // SSR styles are present.\n\n      const group = isOldIE ? css.media || 'default' : id\n      const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined })\n\n      if (!style.ids.includes(id)) {\n        let code = css.source\n        let index = style.ids.length\n\n        style.ids.push(id)\n\n        if (true && css.map) {\n          // https://developer.chrome.com/devtools/docs/javascript-debugging\n          // this makes source maps inside style tags work properly in Chrome\n          code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */'\n          // http://stackoverflow.com/a/26603875\n          code +=\n            '\\n/*# sourceMappingURL=data:application/json;base64,' +\n            btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\n            ' */'\n        }\n\n        if (isOldIE) {\n          style.element = style.element || document.querySelector('style[data-group=' + group + ']')\n        }\n\n        if (!style.element) {\n          const head = document.head || document.getElementsByTagName('head')[0]\n          const el = style.element = document.createElement('style')\n          el.type = 'text/css'\n\n          if (css.media) el.setAttribute('media', css.media)\n          if (isOldIE) {\n            el.setAttribute('data-group', group)\n            el.setAttribute('data-next-index', '0')\n          }\n\n          head.appendChild(el)\n        }\n\n        if (isOldIE) {\n          index = parseInt(style.element.getAttribute('data-next-index'))\n          style.element.setAttribute('data-next-index', index + 1)\n        }\n\n        if (style.element.styleSheet) {\n          style.parts.push(code)\n          style.element.styleSheet.cssText = style.parts\n            .filter(Boolean)\n            .join('\\n')\n        } else {\n          const textNode = document.createTextNode(code)\n          const nodes = style.element.childNodes\n          if (nodes[index]) style.element.removeChild(nodes[index])\n          if (nodes.length) style.element.insertBefore(textNode, nodes[index])\n          else style.element.appendChild(textNode)\n        }\n      }\n    }\n  }\n  /* style inject SSR */\n  \n  /* style inject shadow dom */\n  \n\n  \n  const __vue_component__ = /*#__PURE__*/__vue_normalize__(\n    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },\n    __vue_inject_styles__,\n    __vue_script__,\n    __vue_scope_id__,\n    __vue_is_functional_template__,\n    __vue_module_identifier__,\n    false,\n    __vue_create_injector__,\n    undefined,\n    undefined\n  )\n\n  export default __vue_component__", "import sbp from '@sbp/sbp'\nimport { has, omit } from 'turtledash'\nimport { b64ToStr } from '~/shared/functions.js'\n                                                                                                                                                                           \nimport { SPMessage } from './SPMessage.js'\nimport { Secret } from './Secret.js'\nimport { INVITE_STATUS } from './constants.js'\nimport { deserializeKey, serializeKey, sign, verifySignature } from '@chelonia/crypto'\n                                                       \nimport { ChelErrorForkedChain, ChelErrorResourceGone, ChelErrorUnexpectedHttpResponseCode, ChelErrorWarning } from './errors.js'\nimport { CONTRACT_IS_PENDING_KEY_REQUESTS } from './events.js'\n                                                 \nimport { isSignedData } from './signedData.js'\n\nconst MAX_EVENTS_AFTER = Number.parseInt(process.env.MAX_EVENTS_AFTER || '', 10) || Infinity\n\nexport const findKeyIdByName = (state        , name        )          => state._vm?.authorizedKeys && ((Object.values((state._vm.authorizedKeys     ))     )         ).find((k) => k.name === name && k._notAfterHeight == null)?.id\n\nexport const findForeignKeysByContractID = (state        , contractID        )            => state._vm?.authorizedKeys && ((Object.values((state._vm.authorizedKeys     ))     )         ).filter((k) => k._notAfterHeight == null && k.foreignKey?.includes(contractID)).map(k => k.id)\n\nexport const findRevokedKeyIdsByName = (state        , name        )           => state._vm?.authorizedKeys && ((Object.values((state._vm.authorizedKeys     ) || {})     )         ).filter((k) => k.name === name && k._notAfterHeight != null).map(k => k.id)\n\nexport const findSuitableSecretKeyId = (state        , permissions                , purposes                , ringLevel         , allowedActions                 )          => {\n  return state._vm?.authorizedKeys &&\n    ((Object.values((state._vm.authorizedKeys     ))     )         )\n      .filter((k) => {\n        return k._notAfterHeight == null &&\n        (k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY)) &&\n        sbp('chelonia/haveSecretKey', k.id) &&\n        (Array.isArray(permissions)\n          ? permissions.reduce((acc, permission) =>\n            acc && (k.permissions === '*' || k.permissions.includes(permission)), true\n          )\n          : permissions === k.permissions\n        ) &&\n      purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true) &&\n      (Array.isArray(allowedActions)\n        ? allowedActions.reduce((acc, action) =>\n          acc && (k.allowedActions === '*' || !!k.allowedActions?.includes(action)), true\n        )\n        : allowedActions ? allowedActions === k.allowedActions : true\n      )\n      })\n      .sort((a, b) => b.ringLevel - a.ringLevel)[0]?.id\n}\n\nexport const findContractIDByForeignKeyId = (state        , keyId        )          => {\n  let fk         \n  if (!keyId || !(fk = state?._vm?.authorizedKeys?.[keyId]?.foreignKey)) return\n\n  try {\n    const fkUrl = new URL(fk)\n    return fkUrl.pathname\n  } catch {}\n}\n\n// TODO: Resolve inviteKey being added (doesn't have krs permission)\nexport const findSuitablePublicKeyIds = (state        , permissions                , purposes                , ringLevel         )            => {\n  return state._vm?.authorizedKeys &&\n    ((Object.values((state._vm.authorizedKeys     ))     )         ).filter((k) =>\n      (k._notAfterHeight == null) &&\n      (k.ringLevel <= (ringLevel ?? Number.POSITIVE_INFINITY)) &&\n      (Array.isArray(permissions)\n        ? permissions.reduce((acc, permission) => acc && (k.permissions === '*' || k.permissions.includes(permission)), true)\n        : permissions === k.permissions\n      ) &&\n      purposes.reduce((acc, purpose) => acc && k.purpose.includes(purpose), true))\n      .sort((a, b) => b.ringLevel - a.ringLevel)\n      .map((k) => k.id)\n}\n\nconst validateActionPermissions = (msg           , signingKey       , state        , opT        , opV                       ) => {\n  const data                             = isSignedData(opV)\n    ? (opV     ).valueOf()\n    : (opV     )\n\n  if (\n    signingKey.allowedActions !== '*' && (\n      !Array.isArray(signingKey.allowedActions) ||\n      !signingKey.allowedActions.includes(data.action)\n    )\n  ) {\n    logEvtError(msg, `Signing key ${signingKey.id} is not allowed for action ${data.action}`)\n    return false\n  }\n\n  if (isSignedData(opV)) {\n    const s = ((opV     )                  )\n    const innerSigningKey = state._vm?.authorizedKeys?.[s.signingKeyId]\n\n    // For outgoing messages, we may be using an inner signing key that isn't\n    // available for us to see. In this case, we ignore the missing key.\n    // For incoming messages, we must check permissions and a missing\n    // key means no permissions.\n    if (!innerSigningKey && msg._direction === 'outgoing') return true\n\n    if (\n      !innerSigningKey ||\n      !Array.isArray(innerSigningKey.purpose) ||\n        !innerSigningKey.purpose.includes('sig') ||\n        (innerSigningKey.permissions !== '*' &&\n          (\n            !Array.isArray(innerSigningKey.permissions) ||\n            !innerSigningKey.permissions.includes(opT + '#inner')\n          )\n        )\n    ) {\n      logEvtError(msg, `Signing key ${s.signingKeyId} is missing permissions for operation ${opT}`)\n      return false\n    }\n\n    if (\n      innerSigningKey.allowedActions !== '*' && (\n        !Array.isArray(innerSigningKey.allowedActions) ||\n        !innerSigningKey.allowedActions.includes(data.action + '#inner')\n      )\n    ) {\n      logEvtError(msg, `Signing key ${innerSigningKey.id} is not allowed for action ${data.action}`)\n      return false\n    }\n  }\n\n  return true\n}\n\nexport const validateKeyPermissions = (msg           , config        , state        , signingKeyId        , opT        , opV           )          => {\n  const signingKey = state._vm?.authorizedKeys?.[signingKeyId]\n  if (\n    !signingKey ||\n    !Array.isArray(signingKey.purpose) ||\n      !signingKey.purpose.includes('sig') ||\n      (signingKey.permissions !== '*' &&\n        (\n          !Array.isArray(signingKey.permissions) ||\n          !signingKey.permissions.includes(opT)\n        )\n      )\n  ) {\n    logEvtError(msg, `Signing key ${signingKeyId} is missing permissions for operation ${opT}`)\n    return false\n  }\n\n  if (\n    opT === SPMessage.OP_ACTION_UNENCRYPTED &&\n    !validateActionPermissions(msg, signingKey, state, opT, (opV     ))\n  ) {\n    return false\n  }\n\n  if (\n    !config.skipActionProcessing &&\n    opT === SPMessage.OP_ACTION_ENCRYPTED &&\n    !validateActionPermissions(msg, signingKey, state, opT, (opV     ).valueOf())\n  ) {\n    return false\n  }\n\n  return true\n}\n\nexport const validateKeyAddPermissions = function (contractID        , signingKey       , state        , v                                  , skipPrivateCheck          ) {\n  const signingKeyPermissions = Array.isArray(signingKey.permissions) ? new Set(signingKey.permissions) : signingKey.permissions\n  const signingKeyAllowedActions = Array.isArray(signingKey.allowedActions) ? new Set(signingKey.allowedActions) : signingKey.allowedActions\n  if (!state._vm?.authorizedKeys?.[signingKey.id]) throw new Error('Singing key for OP_KEY_ADD or OP_KEY_UPDATE must exist in _vm.authorizedKeys. contractID=' + contractID + ' signingKeyId=' + signingKey.id)\n  const localSigningKey = state._vm.authorizedKeys[signingKey.id]\n  v.forEach(wk => {\n    // $FlowFixMe[prop-missing]\n    const data = this.config.unwrapMaybeEncryptedData(wk)\n    if (!data) return\n    const k = (data.data       )\n    if (!skipPrivateCheck && signingKey._private && !data.encryptionKeyId) {\n      throw new Error('Signing key is private but it tried adding a public key')\n    }\n    if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {\n      throw new Error('Signing key has ringLevel ' + localSigningKey.ringLevel + ' but attempted to add or update a key with ringLevel ' + k.ringLevel)\n    }\n    if (signingKeyPermissions !== '*') {\n      if (!Array.isArray(k.permissions) || !k.permissions.reduce((acc, cv) => acc && signingKeyPermissions.has(cv), true)) {\n        throw new Error('Unable to add or update a key with more permissions than the signing key. signingKey permissions: ' + String(signingKey?.permissions) + '; key add permissions: ' + String(k.permissions))\n      }\n    }\n    if (signingKeyAllowedActions !== '*' && k.allowedActions) {\n      if (!signingKeyAllowedActions || !Array.isArray(k.allowedActions) || !k.allowedActions.reduce((acc, cv) => acc && signingKeyAllowedActions.has(cv), true)) {\n        throw new Error('Unable to add or update a key with more allowed actions than the signing key. signingKey allowed actions: ' + String(signingKey?.allowedActions) + '; key add allowed actions: ' + String(k.allowedActions))\n      }\n    }\n  })\n}\n\nexport const validateKeyDelPermissions = function (contractID        , signingKey       , state        , v                                    ) {\n  if (!state._vm?.authorizedKeys?.[signingKey.id]) throw new Error('Singing key for OP_KEY_DEL must exist in _vm.authorizedKeys. contractID=' + contractID + ' signingKeyId=' + signingKey.id)\n  const localSigningKey = state._vm.authorizedKeys[signingKey.id]\n  v\n    .forEach((wid) => {\n      const data = this.config.unwrapMaybeEncryptedData(wid)\n      if (!data) return\n      const id = data.data\n      const k = state._vm.authorizedKeys[id]\n      if (!k) {\n        throw new Error('Nonexisting key ID ' + id)\n      }\n      if (signingKey._private) {\n        throw new Error('Signing key is private')\n      }\n      if (!k._private !== !data.encryptionKeyId) {\n        throw new Error('_private attribute must be preserved')\n      }\n      if (!Number.isSafeInteger(k.ringLevel) || k.ringLevel < localSigningKey.ringLevel) {\n        throw new Error('Signing key has ringLevel ' + localSigningKey.ringLevel + ' but attempted to remove a key with ringLevel ' + k.ringLevel)\n      }\n    })\n}\n\nexport const validateKeyUpdatePermissions = function (contractID        , signingKey       , state        , v                                              )                                     {\n  const updatedMap = ((Object.create(null)     )                         )\n  const keys = v.map((wuk)               => {\n    const data = this.config.unwrapMaybeEncryptedData(wuk)\n    if (!data) return undefined\n    const uk = (data.data             )\n\n    const existingKey = state._vm.authorizedKeys[uk.oldKeyId]\n    if (!existingKey) {\n      throw new ChelErrorWarning('Missing old key ID ' + uk.oldKeyId)\n    }\n    if (!existingKey._private !== !data.encryptionKeyId) {\n      throw new Error('_private attribute must be preserved')\n    }\n    if (uk.name !== existingKey.name) {\n      throw new Error('Name cannot be updated')\n    }\n    if (!uk.id !== !uk.data) {\n      throw new Error('Both or none of the id and data attributes must be provided. Old key ID: ' + uk.oldKeyId)\n    }\n    if (uk.data && existingKey.meta?.private && !(uk.meta?.private)) {\n      throw new Error('Missing private key. Old key ID: ' + uk.oldKeyId)\n    }\n    if (uk.id && uk.id !== uk.oldKeyId) {\n      updatedMap[uk.id] = uk.oldKeyId\n    }\n    // Discard `_notAfterHeight` and `_notBeforeHeight`, since retaining them\n    // can cause issues reprocessing messages.\n    // An example is reprocessing old messages in a chatroom using\n    // `chelonia/in/processMessage`: cloning `_notAfterHeight` will break key\n    // rotations, since the new key will have the same expiration value as the\n    // old key (the new key is supposed to have no expiration height).\n    const updatedKey = omit(existingKey, ['_notAfterHeight', '_notBeforeHeight'])\n    // Set the corresponding updated attributes\n    if (uk.permissions) {\n      updatedKey.permissions = uk.permissions\n    }\n    if (uk.allowedActions) {\n      updatedKey.allowedActions = uk.allowedActions\n    }\n    if (uk.purpose) {\n      updatedKey.purpose = uk.purpose\n    }\n    if (uk.meta) {\n      updatedKey.meta = uk.meta\n    }\n    if (uk.id) {\n      updatedKey.id = uk.id\n    }\n    if (uk.data) {\n      updatedKey.data = uk.data\n    }\n    return updatedKey\n  }).filter(Boolean)\n  validateKeyAddPermissions.call(this, contractID, signingKey, state, keys, true)\n  return [((keys     )         ), updatedMap]\n}\n\nexport const keyAdditionProcessor = function (_msg           , hash        , keys                                  , state        , contractID        , _signingKey       , internalSideEffectStack             ) {\n  const decryptedKeys = []\n  const keysToPersist = []\n\n  const storeSecretKey = (key, decryptedKey) => {\n    const decryptedDeserializedKey = deserializeKey(decryptedKey)\n    const transient = !!key.meta?.private?.transient\n    sbp('chelonia/storeSecretKeys', new Secret([{\n      key: decryptedDeserializedKey,\n      // We always set this to true because this could be done from\n      // an outgoing message\n      transient: true\n    }]))\n    if (!transient) {\n      keysToPersist.push({ key: decryptedDeserializedKey, transient })\n    }\n  }\n\n  for (const wkey of keys) {\n    const data = this.config.unwrapMaybeEncryptedData(wkey)\n    if (!data) continue\n    const key = data.data\n    let decryptedKey         \n    // Does the key have key.meta?.private? If so, attempt to decrypt it\n    if (key.meta?.private && key.meta.private.content) {\n      if (\n        key.id &&\n        key.meta.private.content &&\n        !sbp('chelonia/haveSecretKey', key.id, !key.meta.private.transient)\n      ) {\n        const decryptedKeyResult = this.config.unwrapMaybeEncryptedData(key.meta.private.content)\n        // Ignore data that couldn't be decrypted\n        if (decryptedKeyResult) {\n        // Data aren't encrypted\n          if (decryptedKeyResult.encryptionKeyId == null) {\n            throw new Error('Expected encrypted data but got unencrypted data for key with ID: ' + key.id)\n          }\n          decryptedKey = decryptedKeyResult.data\n          decryptedKeys.push([key.id, decryptedKey])\n          storeSecretKey(key, decryptedKey)\n        }\n      }\n    }\n\n    // Is this a #sak\n    if (key.name === '#sak') {\n      if (data.encryptionKeyId) {\n        throw new Error('#sak may not be encrypted')\n      }\n      if (key.permissions && (!Array.isArray(key.permissions) || key.permissions.length !== 0)) {\n        throw new Error('#sak may not have permissions')\n      }\n      if (!Array.isArray(key.purpose) || key.purpose.length !== 1 || key.purpose[0] !== 'sak') {\n        throw new Error(\"#sak must have exactly one purpose: 'sak'\")\n      }\n      if (key.ringLevel !== 0) {\n        throw new Error('#sak must have ringLevel 0')\n      }\n    }\n\n    // Is this a an invite key? If so, run logic for invite keys and invitation\n    // accounting\n    if (key.name.startsWith('#inviteKey-')) {\n      if (!state._vm.invites) state._vm.invites = Object.create(null)\n      const inviteSecret = decryptedKey || (\n        has(this.transientSecretKeys, key.id)\n          ? serializeKey(this.transientSecretKeys[key.id], true)\n          : undefined\n      )\n      state._vm.invites[key.id] = {\n        status: INVITE_STATUS.VALID,\n        initialQuantity: key.meta.quantity,\n        quantity: key.meta.quantity,\n        expires: key.meta.expires,\n        inviteSecret,\n        responses: []\n      }\n    }\n\n    // Is this KEY operation the result of requesting keys for another contract?\n    if (key.meta?.keyRequest?.contractID && findSuitableSecretKeyId(state, [SPMessage.OP_KEY_ADD], ['sig'])) {\n      const data = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.contractID)\n\n      // Are we subscribed to this contract?\n      // If we are not subscribed to the contract, we don't set pendingKeyRequests because we don't need that contract's state\n      // Setting pendingKeyRequests in these cases could result in issues\n      // when a corresponding OP_KEY_SHARE is received, which could trigger subscribing to this previously unsubscribed to contract\n      if (data && internalSideEffectStack) {\n        const keyRequestContractID = data.data\n        const reference = this.config.unwrapMaybeEncryptedData(key.meta.keyRequest.reference)\n\n        // Since now we'll make changes to keyRequestContractID, we need to\n        // do this while no other operations are running for that\n        // contract\n        internalSideEffectStack.push(() => {\n          sbp('chelonia/private/queueEvent', keyRequestContractID, () => {\n            const rootState = sbp(this.config.stateSelector)\n\n            const originatingContractState = rootState[contractID]\n            if (sbp('chelonia/contract/hasKeyShareBeenRespondedBy', originatingContractState, keyRequestContractID, reference)) {\n            // In the meantime, our key request has been responded, so we\n            // don't need to set pendingKeyRequests.\n              return\n            }\n\n            if (!has(rootState, keyRequestContractID)) this.config.reactiveSet(rootState, keyRequestContractID, Object.create(null))\n            const targetState = rootState[keyRequestContractID]\n\n            if (!targetState._volatile) {\n              this.config.reactiveSet(targetState, '_volatile', Object.create(null))\n            }\n            if (!targetState._volatile.pendingKeyRequests) {\n              this.config.reactiveSet(rootState[keyRequestContractID]._volatile, 'pendingKeyRequests', [])\n            }\n\n            if (targetState._volatile.pendingKeyRequests.some((pkr) => {\n              return pkr && pkr.contractID === contractID && pkr.hash === hash\n            })) {\n            // This pending key request has already been registered.\n            // Nothing left to do.\n              return\n            }\n\n            // Mark the contract for which keys were requested as pending keys\n            // The hash (of the current message) is added to this dictionary\n            // for cross-referencing puposes.\n            targetState._volatile.pendingKeyRequests.push({ contractID, name: key.name, hash, reference: reference?.data })\n\n            this.setPostSyncOp(contractID, 'pending-keys-for-' + keyRequestContractID, ['okTurtles.events/emit', CONTRACT_IS_PENDING_KEY_REQUESTS, { contractID: keyRequestContractID }])\n          }).catch((e) => {\n            // Using console.error instead of logEvtError because this\n            // is a side-effect and not relevant for outgoing messages\n            console.error('Error while setting or updating pendingKeyRequests', { contractID, keyRequestContractID, reference }, e)\n          })\n        })\n      }\n    }\n  }\n\n  // Any persistent keys are stored as a side-effect\n  if (keysToPersist.length) {\n    internalSideEffectStack?.push(() => {\n      sbp('chelonia/storeSecretKeys', new Secret(keysToPersist))\n    })\n  }\n  internalSideEffectStack?.push(() => subscribeToForeignKeyContracts.call(this, contractID, state))\n}\n\nexport const subscribeToForeignKeyContracts = function (contractID        , state        ) {\n  try {\n    // $FlowFixMe[incompatible-call]\n    Object.values((state._vm.authorizedKeys                        )).filter((key) => !!((key     )       ).foreignKey && findKeyIdByName(state, ((key     )       ).name) != null).forEach((key       ) => {\n      const foreignKey = String(key.foreignKey)\n      const fkUrl = new URL(foreignKey)\n      const foreignContract = fkUrl.pathname\n      const foreignKeyName = fkUrl.searchParams.get('keyName')\n\n      if (!foreignContract || !foreignKeyName) {\n        console.warn('Invalid foreign key: missing contract or key name', { contractID, keyId: key.id })\n        return\n      }\n\n      const rootState = sbp(this.config.stateSelector)\n\n      const signingKey = findSuitableSecretKeyId(state, [SPMessage.OP_KEY_DEL], ['sig'], key.ringLevel)\n      const canMirrorOperations = !!signingKey\n\n      // If we cannot mirror operations, then there is nothing left to do\n      if (!canMirrorOperations) return\n\n      // If the key is already being watched, do nothing\n      if (Array.isArray(rootState?.[foreignContract]?._volatile?.watch)) {\n        if (rootState[foreignContract]._volatile.watch.find((v) =>\n          v[0] === key.name && v[1] === contractID\n        )) return\n      }\n\n      if (!has(state._vm, 'pendingWatch')) this.config.reactiveSet(state._vm, 'pendingWatch', Object.create(null))\n      if (!has(state._vm.pendingWatch, foreignContract)) this.config.reactiveSet(state._vm.pendingWatch, foreignContract, [])\n      if (!state._vm.pendingWatch[foreignContract].find(([n]) => n === foreignKeyName)) {\n        state._vm.pendingWatch[foreignContract].push([foreignKeyName, key.id])\n      }\n\n      this.setPostSyncOp(contractID, `watchForeignKeys-${contractID}`, ['chelonia/private/watchForeignKeys', contractID])\n    })\n  } catch (e) {\n    console.warn('Error at subscribeToForeignKeyContracts: ' + (e.message || e))\n  }\n}\n\n// Messages might be sent before receiving already posted messages, which will\n// result in a conflict\n// When resending a message, race conditions might also occur (for example, if\n// key rotation is required and there are many clients simultaneously online, it\n// may be performed by all connected clients at once).\n// The following function handles re-signing of messages when a conflict\n// occurs (required because the message's previousHEAD will change) as well as\n// duplicate operations. For operations involving keys, the payload will be\n// rewritten to eliminate no-longer-relevant keys. In most cases, this would\n// result in an empty payload, in which case the message is omitted entirely.\nexport const recreateEvent = (entry           , state        , contractsState        )                               => {\n  const { HEAD: previousHEAD, height: previousHeight, previousKeyOp } = contractsState || {}\n  if (!previousHEAD) {\n    throw new Error('recreateEvent: Giving up because the contract has been removed')\n  }\n  const head = entry.head()\n\n  const [opT, rawOpV] = entry.rawOp()\n\n  const recreateOperation = (opT        , rawOpV                       ) => {\n    const opV = rawOpV.valueOf()\n    const recreateOperationInternal = (opT        , opV           )                               => {\n      let newOpV           \n      if (opT === SPMessage.OP_KEY_ADD) {\n        if (!Array.isArray(opV)) throw new Error('Invalid message format')\n        newOpV = ((opV     )            ).filter((k) => {\n          const kId = (k.valueOf()     ).id\n          return !has(state._vm.authorizedKeys, kId) || state._vm.authorizedKeys[kId]._notAfterHeight != null\n        })\n        // Has this key already been added? (i.e., present in authorizedKeys)\n        if (newOpV.length === 0) {\n          console.info('Omitting empty OP_KEY_ADD', { head })\n        } else if (newOpV.length === opV.length) {\n          return opV\n        }\n      } else if (opT === SPMessage.OP_KEY_DEL) {\n        if (!Array.isArray(opV)) throw new Error('Invalid message format')\n        // Has this key already been removed? (i.e., no longer in authorizedKeys)\n        newOpV = opV.filter((keyId) => {\n          const kId = (Object(keyId).valueOf()     )\n          return has(state._vm.authorizedKeys, kId) && state._vm.authorizedKeys[kId]._notAfterHeight == null\n        })\n        if (newOpV.length === 0) {\n          console.info('Omitting empty OP_KEY_DEL', { head })\n        } else if (newOpV.length === opV.length) {\n          return opV\n        }\n      } else if (opT === SPMessage.OP_KEY_UPDATE) {\n        if (!Array.isArray(opV)) throw new Error('Invalid message format')\n        // Has this key already been replaced? (i.e., no longer in authorizedKeys)\n        newOpV = ((opV     )               ).filter((k) => {\n          const oKId = (k.valueOf()     ).oldKeyId\n          const nKId = (k.valueOf()     ).id\n          return nKId == null || (has(state._vm.authorizedKeys, oKId) && state._vm.authorizedKeys[oKId]._notAfterHeight == null)\n        })\n        if (newOpV.length === 0) {\n          console.info('Omitting empty OP_KEY_UPDATE', { head })\n        } else if (newOpV.length === opV.length) {\n          return opV\n        }\n      } else if (opT === SPMessage.OP_ATOMIC) {\n        if (!Array.isArray(opV)) throw new Error('Invalid message format')\n        newOpV = ((((opV     )            ).map(([t, v]) => [t, recreateOperationInternal(t, v)]).filter(([, v]) => !!v)     )            )\n        if (newOpV.length === 0) {\n          console.info('Omitting empty OP_ATOMIC', { head })\n        } else if (newOpV.length === opV.length && newOpV.reduce((acc, cv, i) => acc && cv === opV[i], true)) {\n          return opV\n        } else {\n          return newOpV\n        }\n      } else {\n        return opV\n      }\n    }\n\n    const newOpV = recreateOperationInternal(opT, opV)\n\n    if (newOpV === opV) {\n      return rawOpV\n    } else if (newOpV === undefined) {\n      return\n    }\n\n    if (typeof rawOpV.recreate !== 'function') {\n      throw new Error('Unable to recreate operation')\n    }\n\n    return rawOpV.recreate(newOpV)\n  }\n\n  const newRawOpV = recreateOperation(opT, rawOpV)\n\n  if (!newRawOpV) return\n\n  const newOp = [opT, newRawOpV]\n\n  entry = SPMessage.cloneWith(\n    head, newOp, { previousKeyOp, previousHEAD, height: previousHeight + 1 }\n  )\n\n  return entry\n}\n\nexport const getContractIDfromKeyId = (contractID        , signingKeyId         , state        )          => {\n  if (!signingKeyId) return\n  return signingKeyId && state._vm?.authorizedKeys?.[signingKeyId]?.foreignKey\n    ? new URL(state._vm.authorizedKeys[signingKeyId].foreignKey).pathname\n    : contractID\n}\n\nexport function eventsAfter (contractID        , sinceHeight        , limit         , sinceHash         , { stream }                      = { stream: true })                                  {\n  if (!contractID) {\n    // Avoid making a network roundtrip to tell us what we already know\n    throw new Error('Missing contract ID')\n  }\n\n  let lastUrl\n  const fetchEventsStreamReader = async () => {\n    requestLimit = Math.min(limit ?? MAX_EVENTS_AFTER, remainingEvents)\n    lastUrl = `${this.config.connectionURL}/eventsAfter/${contractID}/${sinceHeight}${Number.isInteger(requestLimit) ? `/${requestLimit}` : ''}`\n    const eventsResponse = await this.config.fetch(lastUrl, { signal })\n    if (!eventsResponse.ok) {\n      const msg = `${eventsResponse.status}: ${eventsResponse.statusText}`\n      // $FlowFixMe[extra-arg]\n      if (eventsResponse.status === 404 || eventsResponse.status === 410) throw new ChelErrorResourceGone(msg, { cause: eventsResponse.status })\n      // $FlowFixMe[extra-arg]\n      throw new ChelErrorUnexpectedHttpResponseCode(msg, { cause: eventsResponse.status })\n    }\n    if (!eventsResponse.body) throw new Error('Missing body')\n    latestHeight = parseInt(eventsResponse.headers.get('shelter-headinfo-height'), 10)\n    if (!Number.isSafeInteger(latestHeight)) throw new Error('Invalid latest height')\n    requestCount++\n    // $FlowFixMe[incompatible-use]\n    return eventsResponse.body.getReader()\n  }\n  if (!Number.isSafeInteger(sinceHeight) || sinceHeight < 0) {\n    throw new TypeError('Invalid since height value. Expected positive integer.')\n  }\n  const signal = this.abortController.signal\n  let requestCount = 0\n  let remainingEvents = limit ?? Number.POSITIVE_INFINITY\n  let eventsStreamReader\n  let latestHeight\n  let state                                                                         = 'fetch'\n  let requestLimit        \n  let count        \n  let buffer         = ''\n  let currentEvent        \n  // return ReadableStream with a custom pull function to handle streamed data\n  const s = new ReadableStream({\n    // The pull function is called whenever the internal buffer of the stream\n    // becomes empty and needs more data.\n    async pull (controller) {\n      try {\n        for (;;) {\n        // Handle different states of the stream reading process.\n          switch (state) {\n          // When in 'fetch' state, initiate a new fetch request to obtain a\n          // stream reader for events.\n            case 'fetch': {\n              eventsStreamReader = await fetchEventsStreamReader()\n              // Transition to reading the new response and reset the processed\n              // events counter\n              state = 'read-new-response'\n              count = 0\n              break\n            }\n            case 'read-eos': // End of stream case\n            case 'read-new-response': // Just started reading a new response\n            case 'read': { // Reading from the response stream\n              const { done, value } = await eventsStreamReader.read()\n              // If done, determine if the stream should close or fetch more\n              // data by making a new request\n              if (done) {\n              // No more events to process or reached the latest event\n              // Using `>=` instead of `===` to avoid an infinite loop in the\n              // event of data loss on the server.\n                if (remainingEvents === 0 || sinceHeight >= latestHeight) {\n                  controller.close()\n                  return\n                } else if (state === 'read-new-response' || buffer) {\n                // If done prematurely, throw an error\n                  throw new Error('Invalid response: done too early')\n                } else {\n                // If there are still events to fetch, switch state to fetch\n                  state = 'fetch'\n                  break\n                }\n              }\n              if (!value) {\n              // If there's no value (e.g., empty response), throw an error\n                throw new Error('Invalid response: missing body')\n              }\n              // Concatenate new data to the buffer, trimming any\n              // leading/trailing whitespace (the response is a JSON array of\n              // base64-encoded data, meaning that whitespace is not significant)\n              buffer = buffer + Buffer.from(value).toString().trim()\n              // If there was only whitespace, try reading again\n              if (!buffer) break\n              if (state === 'read-new-response') {\n              // Response is in JSON format, so we look for the start of an\n              // array (`[`)\n                if (buffer[0] !== '[') {\n                  throw new Error('Invalid response: no array start delimiter')\n                }\n                // Trim the array start delimiter from the buffer\n                buffer = buffer.slice(1)\n              } else if (state === 'read-eos') {\n              // If in 'read-eos' state and still reading data, it's an error\n              // because the response isn't valid JSON (there should be\n              // nothing other than whitespace after `]`)\n                throw new Error('Invalid data at the end of response')\n              }\n              // If not handling new response or end-of-stream, switch to\n              // processing events\n              state = 'events'\n              break\n            }\n            case 'events': {\n            // Process events by looking for a comma or closing bracket that\n            // indicates the end of an event\n              const nextIdx = buffer.search(/(?<=\\s*)[,\\]]/)\n              // If the end of the event isn't found, go back to reading more\n              // data\n              if (nextIdx < 0) {\n                state = 'read'\n                break\n              }\n              let enqueued = false\n              try {\n              // Extract the current event's value and trim whitespace\n                const eventValue = buffer.slice(0, nextIdx).trim()\n                if (eventValue) {\n                // Check if the event limit is reached; if so, throw an error\n                  if (count === requestLimit) {\n                    throw new Error('Received too many events')\n                  }\n                  currentEvent = JSON.parse(b64ToStr(JSON.parse(eventValue))).message\n                  if (count === 0) {\n                    const hash = SPMessage.deserializeHEAD(currentEvent).hash\n                    const height = SPMessage.deserializeHEAD(currentEvent).head.height\n                    if (height !== sinceHeight || (sinceHash && sinceHash !== hash)) {\n                      if (height === sinceHeight && sinceHash && sinceHash !== hash) {\n                        throw new ChelErrorForkedChain(`Forked chain: hash(${hash}) !== since(${sinceHash})`)\n                      } else {\n                        throw new Error(`Unexpected data: hash(${hash}) !== since(${sinceHash || ''}) or height(${height}) !== since(${sinceHeight})`)\n                      }\n                    }\n                  }\n                  // If this is the first event in a second or later request,\n                  // drop the event because it's already been included in\n                  // a previous response\n                  if (count++ !== 0 || requestCount !== 0) {\n                    controller.enqueue(currentEvent)\n                    enqueued = true\n                    remainingEvents--\n                  }\n                }\n                // If the stream is finished (indicated by a closing bracket),\n                // update `since` (to make the next request if needed) and\n                // switch to 'read-eos'.\n                if (buffer[nextIdx] === ']') {\n                  if (currentEvent) {\n                    const deserialized = SPMessage.deserializeHEAD(currentEvent)\n                    sinceHeight = deserialized.head.height\n                    sinceHash = deserialized.hash\n                    state = 'read-eos'\n                  } else {\n                  // If the response came empty, assume there are no more events\n                  // after. Mostly this prevents infinite loops if a server is\n                  // claiming there are more events than it's willing to return\n                  // data for.\n                    state = 'eod'\n                  }\n                  // This should be an empty string now\n                  buffer = buffer.slice(nextIdx + 1).trim()\n                } else if (currentEvent) {\n                // Otherwise, move the buffer pointer to the next event\n                  buffer = buffer.slice(nextIdx + 1).trimStart()\n                } else {\n                // If the end delimiter (`]`) is missing, throw an error\n                  throw new Error('Missing end delimiter')\n                }\n                // If an event was successfully enqueued, exit the loop to wait\n                // for the next pull request\n                if (enqueued) {\n                  return\n                }\n              } catch (e) {\n                console.error('[chelonia] Error during event parsing', e)\n                throw e\n              }\n              break\n            }\n            case 'eod': {\n              if (remainingEvents === 0 || sinceHeight >= latestHeight) {\n                controller.close()\n              } else {\n                throw new Error('Unexpected end of data')\n              }\n              return\n            }\n          }\n        }\n      } catch (e) {\n        console.error('[eventsAfter] Error', { lastUrl }, e)\n        // $FlowFixMe[incompatible-use]\n        eventsStreamReader?.cancel('Error during pull').catch(e2 => {\n          console.error('Error canceling underlying event stream reader on error', e, e2)\n        })\n        throw e\n      }\n    }\n  })\n  if (stream) return s\n  // Workaround for <https://bugs.webkit.org/show_bug.cgi?id=215485>\n  return collectEventStream(s)\n}\n\nexport function buildShelterAuthorizationHeader (contractID        , state         )         {\n  if (!state) state = sbp(this.config.stateSelector)[contractID]\n  const SAKid = findKeyIdByName(state, '#sak')\n  if (!SAKid) {\n    throw new Error(`Missing #sak in ${contractID}`)\n  }\n  const SAK = this.transientSecretKeys[SAKid]\n  if (!SAK) {\n    throw new Error(`Missing secret #sak (${SAKid}) in ${contractID}`)\n  }\n  const deserializedSAK = typeof SAK === 'string' ? deserializeKey(SAK) : SAK\n\n  const nonceBytes = new Uint8Array(15)\n  // $FlowFixMe[cannot-resolve-name]\n  globalThis.crypto.getRandomValues(nonceBytes)\n\n  // <contractID> <UNIX ms time>.<nonce>\n  const data = `${contractID} ${sbp('chelonia/time')}.${Buffer.from(nonceBytes).toString('base64')}`\n\n  // shelter <contractID> <UNIX time>.<nonce>.<signature>\n  return `shelter ${data}.${sign(deserializedSAK, data)}`\n}\n\nexport function verifyShelterAuthorizationHeader (authorization        , rootState         )         {\n  const regex = /^shelter (([a-zA-Z0-9]+) ([0-9]+)\\.([a-zA-Z0-9+/=]{20}))\\.([a-zA-Z0-9+/=]+)$/i\n  if (authorization.length > 1024) {\n    throw new Error('Authorization header too long')\n  }\n  const matches = authorization.match(regex)\n  if (!matches) {\n    throw new Error('Unable to parse shelter authorization header')\n  }\n  // TODO: Remember nonces and reject already used ones\n  const [, data, contractID, timestamp, , signature] = matches\n  if (Math.abs(parseInt(timestamp) - Date.now()) > 60e3) {\n    throw new Error('Invalid signature time range')\n  }\n  if (!rootState) rootState = sbp('chelonia/rootState')\n  if (!has(rootState, contractID)) {\n    throw new Error(`Contract ${contractID} from shelter authorization header not found`)\n  }\n  const SAKid = findKeyIdByName(rootState[contractID], '#sak')\n  if (!SAKid) {\n    throw new Error(`Missing #sak in ${contractID}`)\n  }\n  const SAK = rootState[contractID]._vm.authorizedKeys[SAKid].data\n  if (!SAK) {\n    throw new Error(`Missing secret #sak (${SAKid}) in ${contractID}`)\n  }\n  const deserializedSAK = deserializeKey(SAK)\n\n  verifySignature(deserializedSAK, data, signature)\n\n  return contractID\n}\n\nexport const clearObject = (o        ) => {\n  Object.keys(o).forEach((k) => delete o[k])\n}\n\nexport const reactiveClearObject = (o        , fn                                        ) => {\n  Object.keys(o).forEach((k) => fn(o, k))\n}\n\nexport const checkCanBeGarbageCollected = function (id        )          {\n  const rootState = sbp(this.config.stateSelector)\n  return (\n    // Check persistent references\n    (!has(rootState.contracts, id) || !rootState.contracts[id] || !has(rootState.contracts[id], 'references')) &&\n    // Check ephemeral references\n    !has(this.ephemeralReferenceCount, id)) &&\n    // Check foreign keys (i.e., that no keys from this contract are being watched)\n    (!has(rootState, id) || !has(rootState[id], '_volatile') || !has(rootState[id]._volatile, 'watch') || rootState[id]._volatile.watch.length === 0 || rootState[id]._volatile.watch.filter(([, cID]) => this.subscriptionSet.has(cID)).length === 0)\n}\n\nexport const collectEventStream = async (s                )                 => {\n  const reader = s.getReader()\n  const r = []\n  for (;;) {\n    const { done, value } = await reader.read()\n    if (done) break\n    r.push(value)\n  }\n  return r\n}\n\n// Used inside processing functions for displaying errors at the 'warn' level\n// for outgoing messages to increase the signal-to-noise error. See issue #2773.\nexport const logEvtError = (msg           , ...args       ) => {\n  if (msg._direction === 'outgoing') {\n    console.warn(...args)\n  } else {\n    console.error(...args)\n  }\n}\n", "'use strict'\n\nimport { DAYS_MILLIS } from '@model/contracts/shared/time.js'\nimport sbp from '@sbp/sbp'\nimport { SPMessage } from '~/shared/domains/chelonia/SPMessage.js'\nimport { encryptedOutgoingData } from '~/shared/domains/chelonia/encryptedData.js'\nimport { findKeyIdByName, findSuitableSecretKeyId } from '~/shared/domains/chelonia/utils.js'\nimport { GIErrorMissingSigningKeyError, GIErrorUIRuntimeError, LError } from '@common/common.js'\nimport { EDWARDS25519SHA512BATCH, keyId, keygen, serializeKey } from '@chelonia/crypto'\n                                                \n\nconst enqueueDeferredPromise = (queue) => {\n  let finished            = Boolean // asssigned to keep Flow happy\n  const onFinishPromise = new Promise     ((resolve) => {\n    finished = resolve\n  })\n  sbp('okTurtles.eventQueue/queueEvent', queue, () => onFinishPromise)\n\n  return finished\n}\n\n// Utility function to send encrypted actions ('chelonia/out/actionEncrypted')\n// This function covers the common case of sending an encrypted action that is\n// both encrypted with that same contract's CEK and signed with that contract's\n// CSK.\n// It takes an optional handler function, which receives a sendMessage callback\n// to emit the encrypted action when appropriate.\n// Note that this function does not currently support specifying custom encryption\n// or signing keys, and that such keys in params get overridden.\nexport const encryptedAction = (\n  action        ,\n  humanError                   ,\n  handler                                                                                                                                                                                 ,\n  encryptionKeyName         ,\n  signingKeyName         ,\n  innerSigningKeyName         \n)         => {\n  const sendMessageFactory = (outerParams                , signingKeyId        , innerSigningKeyId         , encryptionKeyId        , originatingContractID         ) => (innerParams                         )                        => {\n    const params = innerParams ?? outerParams\n    const invocation = [\n      'chelonia/out/actionEncrypted',\n      {\n        ...params,\n        signingKeyId,\n        innerSigningKeyId,\n        encryptionKeyId,\n        action: action.replace('gi.actions', 'gi.contracts'),\n        originatingContractID\n      }\n    ]\n\n    if (params.returnInvocation) {\n      return invocation\n    } else {\n      return sbp(...invocation)\n    }\n  }\n  return {\n    [action]: async function (params                ) {\n      const contractID = params.contractID\n      if (!contractID) {\n        throw new Error('Missing contract ID')\n      }\n      const rootState = sbp('chelonia/rootState')\n      if (rootState.contracts[contractID] === null) {\n        console.warn(`[${action}] Contract is marked as permamently deleted, aborting`, contractID)\n        throw new Error('Contract permanently deleted: ' + contractID)\n      }\n\n      // The following ensures that logging out waits until all pending actions\n      // are written\n      const finished = enqueueDeferredPromise('encrypted-action')\n\n      let retainFailed = false\n      try {\n        // Writing to a contract requires being subscribed to it\n        // Since we're only interested in writing and we don't know whether\n        // we're subscribed or should be, we use an ephemeral retain here that\n        // is undone at the end in a finally block.\n        await sbp('chelonia/contract/retain', contractID, { ephemeral: true }).catch(e => {\n          // We use `retainFailed` because the `finally` block should only\n          // release when `retain` succeeded. Moving the `retain` call outside\n          // of the `try` block would have the same effect but would require\n          // duplicating the error handler.\n          retainFailed = true\n          throw e\n        })\n        const state = {\n          [contractID]: await sbp('chelonia/latestContractState', contractID)\n        }\n        const rootState = sbp('chelonia/rootState')\n\n        // Default signingContractID is the current contract\n        const signingContractID = params.signingContractID || contractID\n        if (!state[signingContractID]) {\n          state[signingContractID] = await sbp('chelonia/latestContractState', signingContractID)\n        }\n\n        // Default innerSigningContractID is the current logged in identity\n        // contract ID, unless we are signing for the current identity contract\n        // If params.innerSigningContractID is explicitly set to null, then\n        // no default value will be used.\n        const innerSigningContractID = params.innerSigningContractID !== undefined\n          ? params.innerSigningContractID\n          : contractID === rootState.loggedIn.identityContractID\n            ? null\n            : rootState.loggedIn.identityContractID\n\n        if (innerSigningContractID && !state[innerSigningContractID]) {\n          state[innerSigningContractID] = await sbp('chelonia/latestContractState', innerSigningContractID)\n        }\n\n        const signingKeyId = params.signingKeyId || findKeyIdByName(state[signingContractID], signingKeyName ?? 'csk')\n        // Inner signing key ID:\n        //  (1) If params.innerSigningKeyId is set, honor it\n        //      (a) If it's null, then no inner signature will be used\n        //      (b) If it's undefined, it's treated the same as if it's not set\n        //  (2) If params.innerSigningKeyId is not set:\n        //      (a) If innerSigningContractID is not set, then no inner\n        //          signature will be used\n        //      (b) Else, use the key by name `innerSigningKeyName` in\n        //          `innerSigningContractID`\n\n        const innerSigningKeyId = params.innerSigningKeyId || (\n          params.innerSigningKeyId !== null &&\n          innerSigningContractID &&\n          findKeyIdByName(state[innerSigningContractID], innerSigningKeyName ?? 'csk')\n        )\n        const encryptionKeyId = params.encryptionKeyId || findKeyIdByName(state[contractID], encryptionKeyName ?? 'cek')\n\n        if (!signingKeyId || !encryptionKeyId || !await sbp('chelonia/haveSecretKey', signingKeyId)) {\n          console.warn(`Refusing to send action ${action} due to missing CSK or CEK`, { contractID, action, signingKeyName, encryptionKeyName, signingKeyId, encryptionKeyId, signingContractID: params.signingContractID, originatingContractID: params.originatingContractID })\n          throw new GIErrorMissingSigningKeyError(`No key found to send ${action} for contract ${contractID}`)\n        }\n\n        if (innerSigningContractID && (!innerSigningKeyId || !await sbp('chelonia/haveSecretKey', innerSigningKeyId))) {\n          console.warn(`Refusing to send action ${action} due to missing inner signing key ID`, { contractID, action, signingKeyName, encryptionKeyName, signingKeyId, encryptionKeyId, signingContractID: params.signingContractID, originatingContractID: params.originatingContractID, innerSigningKeyId })\n          throw new GIErrorMissingSigningKeyError(`No key found to send ${action} for contract ${contractID}`)\n        }\n\n        const sm = sendMessageFactory(params, signingKeyId, innerSigningKeyId || null, encryptionKeyId, params.originatingContractID)\n\n        // make sure to await here so that if there's an error we show user-facing string\n        if (handler) {\n          return await handler(sm, params, signingKeyId, encryptionKeyId, params.originatingContractID)\n        } else {\n          return await sm()\n        }\n      } catch (e) {\n        const userFacingErrStr = typeof humanError === 'string'\n          ? `${humanError} ${LError(e).reportError}`\n          : humanError(params, e)\n        throw new GIErrorUIRuntimeError(userFacingErrStr, { cause: e })\n      } finally {\n        finished()\n        if (!retainFailed) {\n          await sbp('chelonia/contract/release', contractID, { ephemeral: true })\n        }\n      }\n    }\n  }\n}\n\nexport const encryptedNotification = (\n  action        ,\n  humanError                   ,\n  handler                                                                                                                                                                                 ,\n  encryptionKeyName         ,\n  signingKeyName         ,\n  innerSigningKeyName         \n)         => {\n  const sendMessageFactory = (outerParams                , signingKeyId        , innerSigningKeyId         , encryptionKeyId        , originatingContractID         ) => (innerParams                         )                        => {\n    const params = innerParams ?? outerParams\n\n    const actionReplaced = action.replace('gi.actions', 'gi.contracts')\n\n    return sbp('chelonia/out/encryptedOrUnencryptedPubMessage', {\n      contractID: params.contractID,\n      contractName: actionReplaced.split('/', 2).join('/'),\n      innerSigningKeyId,\n      encryptionKeyId,\n      signingKeyId,\n      data: [actionReplaced, params.data]\n    })\n  }\n  return {\n    [action]: async function (params                ) {\n      const contractID = params.contractID\n      if (!contractID) {\n        throw new Error('Missing contract ID')\n      }\n\n      try {\n        // Writing to a contract requires being subscribed to it\n        await sbp('chelonia/contract/retain', contractID, { ephemeral: true })\n        const state = {\n          [contractID]: await sbp('chelonia/latestContractState', contractID)\n        }\n        const rootState = sbp('chelonia/rootState')\n\n        // Default signingContractID is the current contract\n        const signingContractID = params.signingContractID || contractID\n        if (!state[signingContractID]) {\n          state[signingContractID] = await sbp('chelonia/latestContractState', signingContractID)\n        }\n\n        // Default innerSigningContractID is the current logged in identity\n        // contract ID, unless we are signing for the current identity contract\n        // If params.innerSigningContractID is explicitly set to null, then\n        // no default value will be used.\n        const innerSigningContractID = params.innerSigningContractID !== undefined\n          ? params.innerSigningContractID\n          : contractID === rootState.loggedIn.identityContractID\n            ? null\n            : rootState.loggedIn.identityContractID\n\n        if (innerSigningContractID && !state[innerSigningContractID]) {\n          state[innerSigningContractID] = await sbp('chelonia/latestContractState', innerSigningContractID)\n        }\n\n        const signingKeyId = params.signingKeyId || findKeyIdByName(state[signingContractID], signingKeyName ?? 'csk')\n        // Inner signing key ID:\n        //  (1) If params.innerSigningKeyId is set, honor it\n        //      (a) If it's null, then no inner signature will be used\n        //      (b) If it's undefined, it's treated the same as if it's not set\n        //  (2) If params.innerSigningKeyId is not set:\n        //      (a) If innerSigningContractID is not set, then no inner\n        //          signature will be used\n        //      (b) Else, use the key by name `innerSigningKeyName` in\n        //          `innerSigningContractID`\n\n        const innerSigningKeyId = params.innerSigningKeyId || (\n          params.innerSigningKeyId !== null &&\n          innerSigningContractID &&\n          findKeyIdByName(state[innerSigningContractID], innerSigningKeyName ?? 'csk')\n        )\n        const encryptionKeyId = params.encryptionKeyId || findKeyIdByName(state[contractID], encryptionKeyName ?? 'cek')\n\n        if (!signingKeyId || !encryptionKeyId || !await sbp('chelonia/haveSecretKey', signingKeyId)) {\n          console.warn(`Refusing to send action ${action} due to missing CSK or CEK`, { contractID, action, signingKeyName, encryptionKeyName, signingKeyId, encryptionKeyId, signingContractID: params.signingContractID, originatingContractID: params.originatingContractID })\n          throw new GIErrorMissingSigningKeyError(`No key found to send ${action} for contract ${contractID}`)\n        }\n\n        if (innerSigningContractID && (!innerSigningKeyId || !await sbp('chelonia/haveSecretKey', innerSigningKeyId))) {\n          console.warn(`Refusing to send action ${action} due to missing inner signing key ID`, { contractID, action, signingKeyName, encryptionKeyName, signingKeyId, encryptionKeyId, signingContractID: params.signingContractID, originatingContractID: params.originatingContractID, innerSigningKeyId })\n          throw new GIErrorMissingSigningKeyError(`No key found to send ${action} for contract ${contractID}`)\n        }\n\n        const sm = sendMessageFactory(params, signingKeyId, innerSigningKeyId || null, encryptionKeyId, params.originatingContractID)\n\n        // make sure to await here so that if there's an error we show user-facing string\n        if (handler) {\n          return await handler(sm, params, signingKeyId, encryptionKeyId, params.originatingContractID)\n        } else {\n          return await sm()\n        }\n      } catch (e) {\n        const userFacingErrStr = typeof humanError === 'string'\n          ? `${humanError} ${LError(e).reportError}`\n          : humanError(params, e)\n        throw new GIErrorUIRuntimeError(userFacingErrStr, { cause: e })\n      } finally {\n        await sbp('chelonia/contract/release', contractID, { ephemeral: true })\n      }\n    }\n  }\n}\n\nexport async function createInvite ({ contractID, quantity = 1, creatorID, expires, invitee }   \n                                                                                             \n )                                                                        {\n  const state = await sbp('chelonia/contract/state', contractID)\n\n  if (\n    !state ||\n    !state._vm ||\n    !findSuitableSecretKeyId(state, '*', ['sig']) ||\n    state._volatile?.pendingKeyRequests?.length\n  ) {\n    throw new Error('Invalid or missing current group state')\n  }\n\n  const CEKid = findKeyIdByName(state, 'cek')\n  const CSKid = findKeyIdByName(state, 'csk')\n\n  if (!CEKid || !CSKid) {\n    throw new Error('Contract is missing a CEK or CSK')\n  }\n\n  const inviteKey = keygen(EDWARDS25519SHA512BATCH)\n  const inviteKeyId = keyId(inviteKey)\n  const inviteKeyP = serializeKey(inviteKey, false)\n  const inviteKeyS = encryptedOutgoingData(state, CEKid, serializeKey(inviteKey, true))\n\n  await sbp('chelonia/out/keyAdd', {\n    contractID,\n    contractName: 'gi.contracts/group',\n    data: [{\n      id: inviteKeyId,\n      name: '#inviteKey-' + inviteKeyId,\n      purpose: ['sig'],\n      ringLevel: Number.MAX_SAFE_INTEGER,\n      permissions: [SPMessage.OP_KEY_REQUEST],\n      meta: {\n        quantity,\n        expires: Date.now() + DAYS_MILLIS * expires,\n        private: {\n          content: inviteKeyS\n        }\n      },\n      data: inviteKeyP\n    }],\n    signingKeyId: CSKid\n  })\n\n  return {\n    inviteKeyId,\n    creatorID,\n    invitee\n  }\n}\n\nexport function groupContractsByType (contracts         )         {\n  const contractIDs = Object.create(null)\n  if (contracts) {\n    // Note: `references` holds non-ephemeral references (i.e., explicit\n    // calls to `retain` without `{ ephemeral: true }`). These are the contracts\n    // that we want to restore.\n    // Apart from non-ephemeral references, `references` may not be set for\n    // contracts being 'watched' for foreign keys. The latter are managed\n    // directly by Chelonia, so we also don't subscribe to them\n    // $FlowFixMe[incompatible-use]\n    Object.entries(contracts)\n      .filter(([id, value]) => !!value)\n      // $FlowFixMe[incompatible-use]\n      .forEach(([id, { references, type }]) => {\n      // If the contract wasn't explicitly retained, skip it\n      // NB! Ignoring `references` could result in an exception being thrown, as\n      // as `sync` may only be called on contracts for which a reference count\n      // exists.\n        if (!references) return\n        if (!contractIDs[type]) {\n          contractIDs[type] = []\n        }\n        contractIDs[type].push(id)\n      })\n  }\n  return contractIDs\n}\n\nexport async function syncContractsInOrder (groupedContractIDs        )               {\n  // We need to sync contracts in this order to ensure that we have all the\n  // corresponding secret keys. Group chatrooms use group keys but there's\n  // no OP_KEY_SHARE, which will result in the keys not being available when\n  // the group keys are rotated.\n  // TODO: This functionality could be moved into Chelonia by keeping track\n  // of when secret keys without OP_KEY_SHARE become available.\n  const contractSyncPriorityList = [\n    'gi.contracts/identity',\n    'gi.contracts/group',\n    'gi.contracts/chatroom'\n  ]\n  const getContractSyncPriority = (key) => {\n    const index = contractSyncPriorityList.indexOf(key)\n    return index === -1 ? contractSyncPriorityList.length : index\n  }\n  const failedSyncs = []\n  try {\n    const sortedContractTypes = Object.entries(groupedContractIDs).sort(([a], [b]) => {\n      return getContractSyncPriority(a) - getContractSyncPriority(b)\n    })\n    for (const [type, contractIDs] of sortedContractTypes) {\n      // For each contract of this type, check if it still exists before syncing because\n      // e.g. syncing a group contract could have removed one of the chatroom contracts\n      // $FlowFixMe[incompatible-type]\n      for (const contractID of contractIDs) {\n        const { contracts } = sbp('chelonia/rootState')\n        if (contractID in contracts) {\n          try {\n            await sbp('chelonia/contract/sync', contractID)\n          } catch (e) {\n            console.error(`syncContractsInOrder: failed to sync ${type}(${contractID}):`, e)\n            if (e.name === 'ChelErrorResourceGone') {\n              console.info('[syncContractsInOrder] Contract ID ' + contractID + ' has been deleted')\n              sbp('chelonia/contract/remove', contractID, { permanent: true }).catch(e => {\n                console.error('[syncContractsInOrder] Error handling contract deletion', e)\n              })\n            } else {\n              failedSyncs.push(`${type}(\u2026${contractID.slice(-5)}) failed sync with '${e.message}'`)\n            }\n          }\n        } else {\n          console.warn(`syncContractsInOrder: skipping ${type}(${contractID}) as it was removed while syncing previous contracts`)\n        }\n      }\n    }\n    if (failedSyncs.length > 0) throw new Error(failedSyncs.join(', '))\n  } catch (err) {\n    console.error('Error during contract sync (syncing all contractIDs)', err)\n    throw err\n  }\n}\n"],
  "mappings": "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",
  "names": ["init_vue_esm", "import_vuelidate", "MAX_EVENTS_AFTER", "findKeyIdByName", "state", "name", "k", "findSuitableSecretKeyId", "state", "permissions", "purposes", "ringLevel", "allowedActions", "k", "esm_default", "acc", "permission", "purpose", "action", "a", "b", "createInvite", "contractID", "quantity", "creatorID", "expires", "invitee", "state", "esm_default", "findSuitableSecretKeyId", "CEKid", "findKeyIdByName", "CSKid", "inviteKey", "keygen", "EDWARDS25519SHA512BATCH", "inviteKeyId", "keyId", "inviteKeyP", "serializeKey", "inviteKeyS", "encryptedOutgoingData", "SPMessage", "DAYS_MILLIS", "__vue_script__", "ProposalTemplate_default", "mapState", "mapGetters", "index", "vue_esm_default", "inviteeSlots", "newInviteeSlot", "groupId", "invitee", "inviteCreated", "createInvite", "esm_default", "err", "form", "hasFailed", "expiresDateMs", "PROPOSAL_INVITE_MEMBER", "e", "__vue_render__", "_vm", "_h", "_c", "$event", "member", "__vue_staticRenderFns__", "__vue_inject_styles__", "inject", "__vue_scope_id__", "__vue_module_identifier__", "__vue_is_functional_template__", "__vue_normalize__", "template", "style", "script", "scope", "functional", "moduleIdentifier", "shadowMode", "createInjector", "createInjectorSSR", "createInjectorShadow", "component", "hook", "context", "originalRender", "h", "existing", "__vue_create_injector__", "styles", "isOldIE", "id", "css", "group", "code", "head", "el", "textNode", "nodes", "__vue_component__", "AddMembers_default"]
}
