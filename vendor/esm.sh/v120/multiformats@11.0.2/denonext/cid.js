/* esm.sh - esbuild bundle(multiformats@11.0.2/cid) denonext production */
var V=S,x=128,L=127,O=~L,T=Math.pow(2,31);function S(r,t,e){t=t||[],e=e||0;for(var n=e;r>=T;)t[e++]=r&255|x,r/=128;for(;r&O;)t[e++]=r&255|x,r>>>=7;return t[e]=r|0,S.bytes=e-n+1,t}var $=p,B=128,C=127;function p(r,n){var e=0,n=n||0,o=0,s=n,i,u=r.length;do{if(s>=u)throw p.bytes=0,new RangeError("Could not decode varint");i=r[s++],e+=o<28?(i&C)<<o:(i&C)*Math.pow(2,o),o+=7}while(i>=B);return p.bytes=s-n,e}var F=Math.pow(2,7),A=Math.pow(2,14),q=Math.pow(2,21),R=Math.pow(2,28),J=Math.pow(2,35),j=Math.pow(2,42),k=Math.pow(2,49),P=Math.pow(2,56),Q=Math.pow(2,63),U=function(r){return r<F?1:r<A?2:r<q?3:r<R?4:r<J?5:r<j?6:r<k?7:r<P?8:r<Q?9:10},G={encode:V,decode:$,encodingLength:U},H=G,h=H;var D=(r,t=0)=>[h.decode(r,t),h.decode.bytes],f=(r,t,e=0)=>(h.encode(r,t,e),t),g=r=>h.encodingLength(r);import*as a from"/v120/multiformats@11.0.2/denonext/hashes/digest.js";import{base58btc as c}from"/v120/multiformats@11.0.2/denonext/bases/base58.js";import{base32 as l}from"/v120/multiformats@11.0.2/denonext/bases/base32.js";import{coerce as K}from"/v120/multiformats@11.0.2/denonext/bytes.js";var w=(r,t)=>{let{bytes:e,version:n}=r;switch(n){case 0:return Y(e,v(r),t||c.encoder);default:return Z(e,v(r),t||l.encoder)}},ie=r=>({"/":w(r)}),ce=r=>m.parse(r["/"]),I=new WeakMap,v=r=>{let t=I.get(r);if(t==null){let e=new Map;return I.set(r,e),e}return t},m=class r{constructor(t,e,n,o){this.code=e,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==d)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==_)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=a.create(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n&&t.code===n.code&&t.version===n.version&&a.equals(t.multihash,n.multihash)}toString(t){return w(this,t)}toJSON(){return{"/":w(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:o,multihash:s,bytes:i}=e;return new r(n,o,s,i||E(n,o,s.bytes))}else if(e[ee]===!0){let{version:n,multihash:o,code:s}=e,i=a.decode(o);return r.create(n,s,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==d)throw new Error(`Version 0 CID must use dag-pb (code: ${d}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let o=E(t,e,n.bytes);return new r(t,e,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,d,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,o=K(t.subarray(n,n+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");let s=o.subarray(e.multihashSize-e.digestSize),i=new a.Digest(e.multihashCode,e.digestSize,s,o);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[z,N]=D(t.subarray(e));return e+=N,z},o=n(),s=d;if(o===18?(o=0,e=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let i=e,u=n(),b=n(),y=e+b,M=y-i;return{version:o,codec:s,multihashCode:u,digestSize:b,multihashSize:M,size:y}}static parse(t,e){let[n,o]=X(t,e),s=r.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return v(s).set(n,t),s}},X=(r,t)=>{switch(r[0]){case"Q":{let e=t||c;return[c.prefix,e.decode(`${c.prefix}${r}`)]}case c.prefix:{let e=t||c;return[c.prefix,e.decode(r)]}case l.prefix:{let e=t||l;return[l.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}},Y=(r,t,e)=>{let{prefix:n}=e;if(n!==c.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let o=t.get(n);if(o==null){let s=e.encode(r).slice(1);return t.set(n,s),s}else return o},Z=(r,t,e)=>{let{prefix:n}=e,o=t.get(n);if(o==null){let s=e.encode(r);return t.set(n,s),s}else return o},d=112,_=18,E=(r,t,e)=>{let n=g(r),o=n+g(t),s=new Uint8Array(o+e.byteLength);return f(r,s,0),f(t,s,n),s.set(e,o),s},ee=Symbol.for("@ipld/js-cid/CID");export{m as CID,w as format,ce as fromJSON,ie as toJSON};
//# sourceMappingURL=cid.js.map