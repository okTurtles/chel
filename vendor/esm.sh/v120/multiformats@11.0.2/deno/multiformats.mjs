/* esm.sh - esbuild bundle(multiformats@11.0.2) deno production */
var de=Object.defineProperty;var I=(r,t)=>{for(var e in t)de(r,e,{get:t[e],enumerable:!0})};var k={};I(k,{decode:()=>O,encodeTo:()=>E,encodingLength:()=>U});var fe=_,Y=128,pe=127,le=~pe,ue=Math.pow(2,31);function _(r,t,e){t=t||[],e=e||0;for(var n=e;r>=ue;)t[e++]=r&255|Y,r/=128;for(;r&le;)t[e++]=r&255|Y,r>>>=7;return t[e]=r|0,_.bytes=e-n+1,t}var we=R,be=128,H=127;function R(r,n){var e=0,n=n||0,o=0,s=n,i,c=r.length;do{if(s>=c)throw R.bytes=0,new RangeError("Could not decode varint");i=r[s++],e+=o<28?(i&H)<<o:(i&H)*Math.pow(2,o),o+=7}while(i>=be);return R.bytes=s-n,e}var ge=Math.pow(2,7),me=Math.pow(2,14),ye=Math.pow(2,21),xe=Math.pow(2,28),ve=Math.pow(2,35),Ae=Math.pow(2,42),Se=Math.pow(2,49),Ee=Math.pow(2,56),Ue=Math.pow(2,63),ze=function(r){return r<ge?1:r<me?2:r<ye?3:r<xe?4:r<ve?5:r<Ae?6:r<Se?7:r<Ee?8:r<Ue?9:10},Ce={encode:fe,decode:we,encodingLength:ze},Me=Ce,D=Me;var O=(r,t=0)=>[D.decode(r,t),D.decode.bytes],E=(r,t,e=0)=>(D.encode(r,t,e),t),U=r=>D.encodingLength(r);var F={};I(F,{Digest:()=>C,create:()=>V,decode:()=>P,equals:()=>j});var te={};I(te,{coerce:()=>z,empty:()=>ee,equals:()=>J,fromHex:()=>Oe,fromString:()=>De,isBinary:()=>Ve,toHex:()=>Ne,toString:()=>Le});var ee=new Uint8Array(0),Ne=r=>r.reduce((t,e)=>t+e.toString(16).padStart(2,"0"),""),Oe=r=>{let t=r.match(/../g);return t?new Uint8Array(t.map(e=>parseInt(e,16))):ee},J=(r,t)=>{if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0},z=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},Ve=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),De=r=>new TextEncoder().encode(r),Le=r=>new TextDecoder().decode(r);var V=(r,t)=>{let e=t.byteLength,n=U(r),o=n+U(e),s=new Uint8Array(o+e);return E(r,s,0),E(e,s,n),s.set(t,o),new C(r,e,t,s)},P=r=>{let t=z(r),[e,n]=O(t),[o,s]=O(t.subarray(n)),i=t.subarray(n+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new C(e,o,i,t)},j=(r,t)=>{if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&J(r.bytes,e.bytes)}},C=class{constructor(t,e,n,o){this.code=t,this.size=e,this.digest=n,this.bytes=o}};function Te(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var o=0;o<r.length;o++){var s=r.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var c=r.length,d=r.charAt(0),M=Math.log(c)/Math.log(256),p=Math.log(256)/Math.log(c);function N(a){if(a instanceof Uint8Array||(ArrayBuffer.isView(a)?a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength):Array.isArray(a)&&(a=Uint8Array.from(a))),!(a instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(a.length===0)return"";for(var f=0,S=0,u=0,b=a.length;u!==b&&a[u]===0;)u++,f++;for(var g=(b-u)*p+1>>>0,l=new Uint8Array(g);u!==b;){for(var m=a[u],A=0,w=g-1;(m!==0||A<S)&&w!==-1;w--,A++)m+=256*l[w]>>>0,l[w]=m%c>>>0,m=m/c>>>0;if(m!==0)throw new Error("Non-zero carry");S=A,u++}for(var x=g-S;x!==g&&l[x]===0;)x++;for(var $=d.repeat(f);x<g;++x)$+=r.charAt(l[x]);return $}function B(a){if(typeof a!="string")throw new TypeError("Expected String");if(a.length===0)return new Uint8Array;var f=0;if(a[f]!==" "){for(var S=0,u=0;a[f]===d;)S++,f++;for(var b=(a.length-f)*M+1>>>0,g=new Uint8Array(b);a[f];){var l=e[a.charCodeAt(f)];if(l===255)return;for(var m=0,A=b-1;(l!==0||m<u)&&A!==-1;A--,m++)l+=c*g[A]>>>0,g[A]=l%256>>>0,l=l/256>>>0;if(l!==0)throw new Error("Non-zero carry");u=m,f++}if(a[f]!==" "){for(var w=b-u;w!==b&&g[w]===0;)w++;for(var x=new Uint8Array(S+(b-w)),$=S;w!==b;)x[$++]=g[w++];return x}}}function he(a){var f=B(a);if(f)return f;throw new Error(`Non-${t} character`)}return{encode:N,decodeUnsafe:B,decode:he}}var Be=Te,$e=Be,re=$e;var Q=class{constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},G=class{constructor(t,e,n){if(this.name=t,this.prefix=e,e.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return ne(this,t)}},X=class{constructor(t){this.decoders=t}or(t){return ne(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}},ne=(r,t)=>new X({...r.decoders||{[r.prefix]:r},...t.decoders||{[t.prefix]:t}}),K=class{constructor(t,e,n,o){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=o,this.encoder=new Q(t,e,n),this.decoder=new G(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}},oe=({name:r,prefix:t,encode:e,decode:n})=>new K(r,t,e,n),W=({prefix:r,name:t,alphabet:e})=>{let{encode:n,decode:o}=re(e,t);return oe({prefix:r,name:t,encode:n,decode:s=>z(o(s))})},Ie=(r,t,e,n)=>{let o={};for(let p=0;p<t.length;++p)o[t[p]]=p;let s=r.length;for(;r[s-1]==="=";)--s;let i=new Uint8Array(s*e/8|0),c=0,d=0,M=0;for(let p=0;p<s;++p){let N=o[r[p]];if(N===void 0)throw new SyntaxError(`Non-${n} character`);d=d<<e|N,c+=e,c>=8&&(c-=8,i[M++]=255&d>>c)}if(c>=e||255&d<<8-c)throw new SyntaxError("Unexpected end of data");return i},ke=(r,t,e)=>{let n=t[t.length-1]==="=",o=(1<<e)-1,s="",i=0,c=0;for(let d=0;d<r.length;++d)for(c=c<<8|r[d],i+=8;i>e;)i-=e,s+=t[o&c>>i];if(i&&(s+=t[o&c<<e-i]),n)for(;s.length*e&7;)s+="=";return s},y=({name:r,prefix:t,bitsPerChar:e,alphabet:n})=>oe({prefix:t,name:r,encode(o){return ke(o,n,e)},decode(o){return Ie(o,n,e,r)}});var v=W({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),et=W({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var L=y({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),nt=y({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ot=y({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),st=y({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),it=y({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),at=y({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ct=y({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ht=y({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),dt=y({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var se=(r,t)=>{let{bytes:e,version:n}=r;switch(n){case 0:return qe(e,Z(r),t||v.encoder);default:return Re(e,Z(r),t||L.encoder)}};var ie=new WeakMap,Z=r=>{let t=ie.get(r);if(t==null){let e=new Map;return ie.set(r,e),e}return t},h=class{constructor(t,e,n,o){this.code=e,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==T)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Je)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return h.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=V(t,e);return h.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return h.equals(this,t)}static equals(t,e){let n=e;return n&&t.code===n.code&&t.version===n.version&&j(t.multihash,n.multihash)}toString(t){return se(this,t)}toJSON(){return{"/":se(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof h)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:o,multihash:s,bytes:i}=e;return new h(n,o,s,i||ae(n,o,s.bytes))}else if(e[Pe]===!0){let{version:n,multihash:o,code:s}=e,i=P(o);return h.create(n,s,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==T)throw new Error(`Version 0 CID must use dag-pb (code: ${T}) block encoding`);return new h(t,e,n,n.bytes)}case 1:{let o=ae(t,e,n.bytes);return new h(t,e,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return h.create(0,T,t)}static createV1(t,e){return h.create(1,t,e)}static decode(t){let[e,n]=h.decodeFirst(t);if(n.length)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=h.inspectBytes(t),n=e.size-e.multihashSize,o=z(t.subarray(n,n+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");let s=o.subarray(e.multihashSize-e.digestSize),i=new C(e.multihashCode,e.digestSize,s,o);return[e.version===0?h.createV0(i):h.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[N,B]=O(t.subarray(e));return e+=B,N},o=n(),s=T;if(o===18?(o=0,e=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let i=e,c=n(),d=n(),M=e+d,p=M-i;return{version:o,codec:s,multihashCode:c,digestSize:d,multihashSize:p,size:M}}static parse(t,e){let[n,o]=Fe(t,e),s=h.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Z(s).set(n,t),s}},Fe=(r,t)=>{switch(r[0]){case"Q":{let e=t||v;return[v.prefix,e.decode(`${v.prefix}${r}`)]}case v.prefix:{let e=t||v;return[v.prefix,e.decode(r)]}case L.prefix:{let e=t||L;return[L.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}},qe=(r,t,e)=>{let{prefix:n}=e;if(n!==v.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let o=t.get(n);if(o==null){let s=e.encode(r).slice(1);return t.set(n,s),s}else return o},Re=(r,t,e)=>{let{prefix:n}=e,o=t.get(n);if(o==null){let s=e.encode(r);return t.set(n,s),s}else return o},T=112,Je=18,ae=(r,t,e)=>{let n=U(r),o=n+U(t),s=new Uint8Array(o+e.byteLength);return E(r,s,0),E(t,s,n),s.set(e,o),s},Pe=Symbol.for("@ipld/js-cid/CID");var ce={};I(ce,{Hasher:()=>q,from:()=>je});var je=({name:r,code:t,encode:e})=>new q(r,t,e),q=class{constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?V(this.code,e):e.then(n=>V(this.code,n))}else throw Error("Unknown type, must be binary type")}};export{h as CID,te as bytes,F as digest,ce as hasher,k as varint};
//# sourceMappingURL=multiformats.mjs.map