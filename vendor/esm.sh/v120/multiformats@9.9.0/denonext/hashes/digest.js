/* esm.sh - esbuild bundle(multiformats@9.9.0/hashes/digest) denonext production */
var V=new Uint8Array(0);var w=(e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0},p=e=>{if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")};var x=v,g=128,M=127,L=~M,A=Math.pow(2,31);function v(e,t,r){t=t||[],r=r||0;for(var n=r;e>=A;)t[r++]=e&255|g,e/=128;for(;e&L;)t[r++]=e&255|g,e>>>=7;return t[r]=e|0,v.bytes=r-n+1,t}var l=d,N=128,u=127;function d(e,n){var r=0,n=n||0,o=0,c=n,s,b=e.length;do{if(c>=b)throw d.bytes=0,new RangeError("Could not decode varint");s=e[c++],r+=o<28?(s&u)<<o:(s&u)*Math.pow(2,o),o+=7}while(s>=N);return d.bytes=c-n,r}var B=Math.pow(2,7),S=Math.pow(2,14),T=Math.pow(2,21),U=Math.pow(2,28),m=Math.pow(2,35),z=Math.pow(2,42),E=Math.pow(2,49),O=Math.pow(2,56),q=Math.pow(2,63),I=function(e){return e<B?1:e<S?2:e<T?3:e<U?4:e<m?5:e<z?6:e<E?7:e<O?8:e<q?9:10},R={encode:x,decode:l,encodingLength:I},_=R,i=_;var f=(e,t=0)=>[i.decode(e,t),i.decode.bytes],h=(e,t,r=0)=>(i.encode(e,t,r),t),y=e=>i.encodingLength(e);var D=(e,t)=>{let r=t.byteLength,n=y(e),o=n+y(r),c=new Uint8Array(o+r);return h(e,c,0),h(r,c,n),c.set(t,o),new a(e,r,t,c)},F=e=>{let t=p(e),[r,n]=f(t),[o,c]=f(t.subarray(n)),s=t.subarray(n+c);if(s.byteLength!==o)throw new Error("Incorrect length");return new a(r,o,s,t)},G=(e,t)=>e===t?!0:e.code===t.code&&e.size===t.size&&w(e.bytes,t.bytes),a=class{constructor(t,r,n,o){this.code=t,this.size=r,this.digest=n,this.bytes=o}};export{a as Digest,D as create,F as decode,G as equals};
//# sourceMappingURL=digest.js.map