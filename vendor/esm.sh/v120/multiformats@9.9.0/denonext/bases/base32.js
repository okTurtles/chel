/* esm.sh - esbuild bundle(multiformats@9.9.0/bases/base32) denonext production */
var A=new Uint8Array(0);var c=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},p=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return u(this,e)}},l=class{constructor(e){this.decoders=e}or(e){return u(this,e)}decode(e){let r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}},u=(t,e)=>new l({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}}),w=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new c(e,r,n),this.decoder=new p(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}},y=({name:t,prefix:e,encode:r,decode:n})=>new w(t,e,r,n);var g=(t,e,r,n)=>{let o={};for(let d=0;d<e.length;++d)o[e[d]]=d;let a=t.length;for(;t[a-1]==="=";)--a;let f=new Uint8Array(a*r/8|0),i=0,h=0,x=0;for(let d=0;d<a;++d){let b=o[t[d]];if(b===void 0)throw new SyntaxError(`Non-${n} character`);h=h<<r|b,i+=r,i>=8&&(i-=8,f[x++]=255&h>>i)}if(i>=r||255&h<<8-i)throw new SyntaxError("Unexpected end of data");return f},v=(t,e,r)=>{let n=e[e.length-1]==="=",o=(1<<r)-1,a="",f=0,i=0;for(let h=0;h<t.length;++h)for(i=i<<8|t[h],f+=8;f>r;)f-=r,a+=e[o&i>>f];if(f&&(a+=e[o&i<<r-f]),n)for(;a.length*r&7;)a+="=";return a},s=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>y({prefix:e,name:t,encode(o){return v(o,n,r)},decode(o){return g(o,n,r,t)}});var k=s({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),M=s({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),$=s({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),B=s({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),R=s({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),T=s({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),V=s({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),q=s({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),D=s({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});export{k as base32,R as base32hex,V as base32hexpad,q as base32hexpadupper,T as base32hexupper,$ as base32pad,B as base32padupper,M as base32upper,D as base32z};
//# sourceMappingURL=base32.js.map