/* esm.sh - esbuild bundle(multiformats@9.9.0/cid) denonext production */
var N=v,C=128,V=127,z=~V,O=Math.pow(2,31);function v(r,e,t){e=e||[],t=t||0;for(var n=t;r>=O;)e[t++]=r&255|C,r/=128;for(;r&z;)e[t++]=r&255|C,r>>>=7;return e[t]=r|0,v.bytes=t-n+1,e}var T=w,U=128,D=127;function w(r,n){var t=0,n=n||0,o=0,s=n,i,f=r.length;do{if(s>=f)throw w.bytes=0,new RangeError("Could not decode varint");i=r[s++],t+=o<28?(i&D)<<o:(i&D)*Math.pow(2,o),o+=7}while(i>=U);return w.bytes=s-n,t}var $=Math.pow(2,7),R=Math.pow(2,14),j=Math.pow(2,21),k=Math.pow(2,28),q=Math.pow(2,35),F=Math.pow(2,42),H=Math.pow(2,49),P=Math.pow(2,56),W=Math.pow(2,63),G=function(r){return r<$?1:r<R?2:r<j?3:r<k?4:r<q?5:r<F?6:r<H?7:r<P?8:r<W?9:10},J={encode:N,decode:T,encodingLength:G},Q=J,d=Q;var I=(r,e=0)=>[d.decode(r,e),d.decode.bytes],g=(r,e,t=0)=>(d.encode(r,e,t),e),y=r=>d.encodingLength(r);import*as a from"/v120/multiformats@9.9.0/denonext/hashes/digest.js";import{base58btc as c}from"/v120/multiformats@9.9.0/denonext/bases/base58.js";import{base32 as p}from"/v120/multiformats@9.9.0/denonext/bases/base32.js";var se=new Uint8Array(0);var S=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")};var x=class r{constructor(e,t,n,o){this.code=t,this.version=e,this.multihash=n,this.bytes=o,this.byteOffset=o.byteOffset,this.byteLength=o.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:l,byteLength:l,code:u,version:u,multihash:u,bytes:u,_baseCache:l,asCID:l})}toV0(){switch(this.version){case 0:return this;default:{let{code:e,multihash:t}=this;if(e!==h)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==_)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(t)}}}toV1(){switch(this.version){case 0:{let{code:e,digest:t}=this.multihash,n=a.create(e,t);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&a.equals(this.multihash,e.multihash)}toString(e){let{bytes:t,version:n,_baseCache:o}=this;switch(n){case 0:return Y(t,o,e||c.encoder);default:return Z(t,o,e||p.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(e){return te(/^0\.0/,re),!!(e&&(e[A]||e.asCID===e))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(e){if(e instanceof r)return e;if(e!=null&&e.asCID===e){let{version:t,code:n,multihash:o,bytes:s}=e;return new r(t,n,o,s||E(t,n,o.bytes))}else if(e!=null&&e[A]===!0){let{version:t,multihash:n,code:o}=e,s=a.decode(n);return r.create(t,o,s)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");switch(e){case 0:{if(t!==h)throw new Error(`Version 0 CID must use dag-pb (code: ${h}) block encoding`);return new r(e,t,n,n.bytes)}case 1:{let o=E(e,t,n.bytes);return new r(e,t,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return r.create(0,h,e)}static createV1(e,t){return r.create(1,e,t)}static decode(e){let[t,n]=r.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){let t=r.inspectBytes(e),n=t.size-t.multihashSize,o=S(e.subarray(n,n+t.multihashSize));if(o.byteLength!==t.multihashSize)throw new Error("Incorrect length");let s=o.subarray(t.multihashSize-t.digestSize),i=new a.Digest(t.multihashCode,t.digestSize,s,o);return[t.version===0?r.createV0(i):r.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0,n=()=>{let[M,B]=I(e.subarray(t));return t+=B,M},o=n(),s=h;if(o===18?(o=0,t=0):o===1&&(s=n()),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let i=t,f=n(),b=n(),m=t+b,L=m-i;return{version:o,codec:s,multihashCode:f,digestSize:b,multihashSize:L,size:m}}static parse(e,t){let[n,o]=X(e,t),s=r.decode(o);return s._baseCache.set(n,e),s}},X=(r,e)=>{switch(r[0]){case"Q":{let t=e||c;return[c.prefix,t.decode(`${c.prefix}${r}`)]}case c.prefix:{let t=e||c;return[c.prefix,t.decode(r)]}case p.prefix:{let t=e||p;return[p.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}},Y=(r,e,t)=>{let{prefix:n}=t;if(n!==c.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);let o=e.get(n);if(o==null){let s=t.encode(r).slice(1);return e.set(n,s),s}else return o},Z=(r,e,t)=>{let{prefix:n}=t,o=e.get(n);if(o==null){let s=t.encode(r);return e.set(n,s),s}else return o},h=112,_=18,E=(r,e,t)=>{let n=y(r),o=n+y(e),s=new Uint8Array(o+t.byteLength);return g(r,s,0),g(e,s,n),s.set(t,o),s},A=Symbol.for("@ipld/js-cid/CID"),u={writable:!1,configurable:!1,enumerable:!0},l={writable:!1,enumerable:!1,configurable:!1},ee="0.0.0-dev",te=(r,e)=>{if(r.test(ee))console.warn(e);else throw new Error(e)},re=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;export{x as CID};
//# sourceMappingURL=cid.js.map