import{d as D}from"./chunk-GEXW5JDJ-cached.js";import{a as S,b as w}from"./chunk-FCHVKZ6M-cached.js";import{e as y,g as u,m as h}from"./chunk-WWKTCH3O-cached.js";import{b as l}from"./chunk-VUYUNB2W-cached.js";import{a as P}from"./chunk-OMOH7TRL-cached.js";import{b as g,d as f}from"./chunk-WBBXU2FL-cached.js";var v={computed:{...g(["currentGroupId"]),...f(["currentGroupState","dueDateForPeriod","groupPeriodPayments","groupSettings","groupCreatedDate","groupSortedPeriodKeys","ourIdentityContractId","ourPayments","periodAfterPeriod","periodBeforePeriod","periodStampGivenDate","paymentHashesForPeriod"])},methods:{async historicalPeriodStampGivenPayment(t){return await this.historicalPeriodStampGivenDate(t.date)},async getAllPeriodPayments(){return{...await this.getHistoricalPeriodPayments(),...this.groupPeriodPayments}},async getAllSortedPeriodKeys(){let t=new Date,e=new Date(this.groupSettings.distributionDate),o=new Date(this.groupCreatedDate),a=[...Object.keys(await this.getHistoricalPeriodPayments()).sort(),...this.groupSortedPeriodKeys].filter(s=>{let i=new Date(s);return i>new Date(o)&&i<=t});return a.length===1&&new Date(a[0])<e?[]:a},async historicalPeriodStampGivenDate(t){return y(t,{knownSortedStamps:await this.getAllSortedPeriodKeys(),periodLength:this.groupSettings.distributionPeriodLength}).current},async historicalPeriodBeforePeriod(t){return y(t,{knownSortedStamps:await this.getAllSortedPeriodKeys(),periodLength:this.groupSettings.distributionPeriodLength}).previous},async historicalPeriodAfterPeriod(t){return y(t,{knownSortedStamps:await this.getAllSortedPeriodKeys(),periodLength:this.groupSettings.distributionPeriodLength}).next},async getDueDateForPeriod(t){return await this.historicalPeriodAfterPeriod(t)},async getHistoricalPeriodPayments(){let t=`paymentsByPeriod/${this.ourIdentityContractId}/${this.currentGroupId}`;return await P("gi.db/archive/load",t)??{}},async getAllPaymentsInTypes(){let t=[],e=[],o=l(this.ourPayments?.todo??[]),r=await this.getAllPeriodPayments(),a=(s,i)=>s.meta.createdDate>i.meta.createdDate?1:-1;for(let s of Object.keys(r).sort().reverse()){let i=await this.getPaymentDetailsByPeriod(s),{paymentsFrom:c}=r[s];for(let m of Object.keys(c))for(let n of Object.keys(c[m]))if(n===this.ourIdentityContractId||m===this.ourIdentityContractId){let I=n===this.ourIdentityContractId?e:t;for(let d of c[m][n])if(d in i){let{data:p,meta:b}=i[d];I.push({hash:d,data:p,meta:b,amount:p.amount,toMemberID:n,period:s})}else console.error(`getAllPaymentsInTypes: couldn't find payment ${d} for period ${s}!`)}}return t.sort(a),e.sort(a),{received:e,sent:t,todo:o}},async getPaymentDetailsByPeriod(t){let e={};if(t in this.groupPeriodPayments){let o=this.paymentHashesForPeriod(t)||[];e=Object.fromEntries(o.map(r=>[r,this.currentGroupState.payments[r]]))}else{let o=await this.getHistoricalPeriodPayments(),r=S(o[t]),a=await this.getHistoricalPaymentDetailsByPeriod(t);for(let s of r)e[s]=a[s]}return e},async getPaymentsByPeriod(t){let e=[],o=await this.getPaymentDetailsByPeriod(t);for(let r of Object.keys(o)){let a=o[r];a.data.status===D&&e.push(w(r,a))}return e},async getHistoricalPaymentDetailsByPeriod(t){let e=`payments/${this.ourIdentityContractId}/${t}/${this.currentGroupId}`;return await P("gi.db/archive/load",e)||{}},async getHaveNeedsSnapshotByPeriod(t){if(Object.keys(this.groupPeriodPayments).includes(t))return this.groupPeriodPayments[t].haveNeedsSnapshot||[];let e=await this.getHistoricalPeriodPayments();return Object.keys(e).includes(t)?e[t].haveNeedsSnapshot||[]:[]},async getTotalTodoAmountForPeriod(t){let e=await this.getHaveNeedsSnapshotByPeriod(t),o=0;for(let{haveNeed:r}of e)r<0&&(o+=-1*r);return o},async getTotalPledgesDoneForPeriod(t){let e=await this.getPaymentsByPeriod(t),o=0;for(let{amount:r}of e)o+=r;return o},async getPaymentPeriod(t){return this.groupPeriodPayments[t]??(await this.getHistoricalPeriodPayments())[t]??{}},getPeriodFromStartToDueDate(t,e){let o=this.dueDateForPeriod(t,e);return`${h(u(t))} - ${h(u(o))}`}}},G=v;export{G as a};
//# sourceMappingURL=chunk-2XDYZHVW-cached.js.map
