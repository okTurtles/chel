{
  "version": 3,
  "sources": ["../../../frontend/model/contracts/shared/time.js"],
  "sourcesContent": ["'use strict'\n\nimport { L } from '@common/common.js'\n\nexport const MINS_MILLIS = 60000\nexport const HOURS_MILLIS = 60 * MINS_MILLIS\nexport const DAYS_MILLIS = 24 * HOURS_MILLIS\nexport const MONTHS_MILLIS = 30 * DAYS_MILLIS\nexport const YEARS_MILLIS = 365 * DAYS_MILLIS\n\nexport const plusOnePeriodLength = (timestamp        , periodLength        )         => (\n  dateToPeriodStamp(addTimeToDate(timestamp, periodLength))\n)\n\nexport const minusOnePeriodLength = (timestamp        , periodLength        )         => (\n  dateToPeriodStamp(addTimeToDate(timestamp, -periodLength))\n)\n\n// @param knownSortedStamps\n// - MUST be sorted in ascending order (lower timestamps first)\n// - MAY NOT contain duplicate elements\n// @param guess\n// - when truthy, will use periodLength to guess the period stamp for the return values\n// - otherwise, will return undefined if the date is not in the knownSortedStamps\nexport function periodStampsForDate (\n  date               ,\n  { knownSortedStamps, periodLength, guess }                                                                        \n)         {\n  // $FlowFixMe - Pedantic '[method-unbinding]' error\n  if (!(isIsoString(date) || Object.prototype.toString.call(date) === '[object Date]')) {\n    throw new TypeError('must be ISO string or Date object')\n  }\n  const timestamp = typeof date === 'string' ? date : date.toISOString()\n  let previous, current, next\n  if (knownSortedStamps.length) {\n    const latest = knownSortedStamps[knownSortedStamps.length - 1]\n    const earliest = knownSortedStamps[0]\n    if (timestamp >= latest) {\n      current = periodStampGivenDate({ recentDate: timestamp, periodStart: latest, periodLength })\n      next = plusOnePeriodLength(current, periodLength)\n      previous = current > latest\n        ? minusOnePeriodLength(current, periodLength)\n        : knownSortedStamps[knownSortedStamps.length - 2]\n    } else if (guess && timestamp < earliest) {\n      // handle dates earlier than all known stamps\n      current = periodStampGivenDate({ recentDate: timestamp, periodStart: earliest, periodLength })\n      next = plusOnePeriodLength(current, periodLength)\n      previous = minusOnePeriodLength(current, periodLength)\n    } else {\n      for (let i = knownSortedStamps.length - 2; i >= 0; i--) {\n        if (timestamp >= knownSortedStamps[i]) {\n          current = knownSortedStamps[i]\n          // `i + 1` is always a valid index.\n          next = knownSortedStamps[i + 1]\n          previous = i > 0\n            ? knownSortedStamps[i - 1]\n            : (guess ? minusOnePeriodLength(current, periodLength) : undefined)\n          break\n        }\n      }\n    }\n  }\n  return { previous, current, next }\n}\n\nexport function addMonthsToDate (date        , months        )       {\n  const now = new Date(date)\n  return new Date(now.setMonth(now.getMonth() + months))\n}\n\n// It might be tempting to deal directly with Dates and ISOStrings, since that's basically\n// what a period stamp is at the moment, but keeping this abstraction allows us to change\n// our mind in the future simply by editing these two functions.\n// TODO: We may want to, for example, get the time from the server instead of relying on\n// the client in case the client's clock isn't set correctly.\n// See: https://github.com/okTurtles/group-income/issues/531\nexport function dateToPeriodStamp (date               )         {\n  return new Date(date).toISOString()\n}\n\nexport function dateFromPeriodStamp (daystamp        )       {\n  return new Date(daystamp)\n}\n\nexport function periodStampGivenDate ({ recentDate, periodStart, periodLength }   \n                                                               \n )         {\n  const periodStartDate = dateFromPeriodStamp(periodStart)\n  let nextPeriod = addTimeToDate(periodStartDate, periodLength)\n  const curDate = new Date(recentDate)\n  let curPeriod\n  if (curDate < nextPeriod) {\n    if (curDate >= periodStartDate) {\n      return periodStart // we're still in the same period\n    } else {\n      // we're in a period before the current one\n      curPeriod = periodStartDate\n      do {\n        curPeriod = addTimeToDate(curPeriod, -periodLength)\n      } while (curDate < curPeriod)\n    }\n  } else {\n    // we're at least a period ahead of periodStart\n    do {\n      curPeriod = nextPeriod\n      nextPeriod = addTimeToDate(nextPeriod, periodLength)\n    } while (curDate >= nextPeriod)\n  }\n\n  return dateToPeriodStamp(curPeriod)\n}\n\nexport function dateIsWithinPeriod ({ date, periodStart, periodLength }   \n                                                         \n )          {\n  const dateObj = new Date(date)\n  const start = dateFromPeriodStamp(periodStart)\n  return dateObj > start && dateObj < addTimeToDate(start, periodLength)\n}\n\nexport function addTimeToDate (date               , timeMillis        )       {\n  const d = new Date(date)\n  d.setTime(d.getTime() + timeMillis)\n  return d\n}\n\nexport function dateToMonthstamp (date               )         {\n  // we could use Intl.DateTimeFormat but that doesn't support .format() on Android\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/format\n  return new Date(date).toISOString().slice(0, 7)\n}\n\nexport function dateFromMonthstamp (monthstamp        )       {\n  // this is a hack to prevent new Date('2020-01').getFullYear() => 2019\n  return new Date(`${monthstamp}-01T00:01:00.000Z`) // the Z is important\n}\n\n// TODO: to prevent conflicts among user timezones, we need\n//       to use the server's time, and not our time here.\n//       https://github.com/okTurtles/group-income/issues/531\nexport function currentMonthstamp ()         {\n  return dateToMonthstamp(new Date())\n}\n\nexport function prevMonthstamp (monthstamp        )         {\n  const date = dateFromMonthstamp(monthstamp)\n  date.setMonth(date.getMonth() - 1)\n  return dateToMonthstamp(date)\n}\n\nexport function comparePeriodStamps (periodA        , periodB        )         {\n  return dateFromPeriodStamp(periodA).getTime() - dateFromPeriodStamp(periodB).getTime()\n}\n\nexport function compareMonthstamps (monthstampA        , monthstampB        )         {\n  return dateFromMonthstamp(monthstampA).getTime() - dateFromMonthstamp(monthstampB).getTime()\n  // const A = dateA.getMonth() + dateA.getFullYear() * 12\n  // const B = dateB.getMonth() + dateB.getFullYear() * 12\n  // return A - B\n}\n\nexport function compareISOTimestamps (a        , b        )         {\n  return new Date(a).getTime() - new Date(b).getTime()\n}\n\nexport function lastDayOfMonth (date      )       {\n  return new Date(date.getFullYear(), date.getMonth() + 1, 0)\n}\n\nexport function firstDayOfMonth (date      )       {\n  return new Date(date.getFullYear(), date.getMonth(), 1)\n}\n\nexport function getLocale ()         {\n  const fallback = 'en-US-POSIX'\n\n  return typeof navigator === 'undefined'\n    // Fallback for Mocha tests.\n    ? fallback\n    // Flow considers `navigator.languages` to be of type `$ReadOnlyArray<string>`,\n    // which is not compatible with the `string[]` expected by `.toLocaleDateString()`.\n    // Casting to `string[]` through `any` as a workaround.\n    : (navigator.languages     ) ?? navigator.language ?? fallback\n}\n\nexport function humanDate (\n  date                        ,\n  options                              = { month: 'short', day: 'numeric' }\n)         {\n  const dateObj = new Date(date)\n  // NOTE: `.toLocaleDateString()` automatically takes local timezone differences into account.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString\n  const locale = getLocale()\n\n  // Avoid returning 'Invalid Date'\n  if (!isNaN(dateObj.valueOf())) return dateObj.toLocaleDateString(locale, options)\n  return ''\n}\n\nexport function humanTimeString (\n  date                        ,\n  options       = { hour: '2-digit', minute: '2-digit' }\n)         {\n  const dateObj = new Date(date)\n  return dateObj.toLocaleTimeString(getLocale(), options)\n}\n\nexport function isPeriodStamp (arg        )          {\n  return isIsoString(arg)\n}\n\nexport function isFullMonthstamp (arg        )          {\n  return /^\\d{4}-(0[1-9]|1[0-2])$/.test(arg)\n}\n\nexport function isIsoString (arg     )          {\n  return typeof arg === 'string' && /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/.test(arg)\n}\n\nexport function isMonthstamp (arg        )          {\n  return isShortMonthstamp(arg) || isFullMonthstamp(arg)\n}\n\nexport function isShortMonthstamp (arg        )          {\n  return /^(0[1-9]|1[0-2])$/.test(arg)\n}\n\nexport function monthName (monthstamp        )         {\n  return humanDate(dateFromMonthstamp(monthstamp), { month: 'long' })\n}\n\nexport function proximityDate (date      )         {\n  date = new Date(date)\n  const today = new Date()\n  const yesterday = (d => new Date(d.setDate(d.getDate() - 1)))(new Date())\n  const lastWeek = (d => new Date(d.setDate(d.getDate() - 7)))(new Date())\n\n  for (const toReset of [date, today, yesterday, lastWeek]) {\n    toReset.setHours(0)\n    toReset.setMinutes(0)\n    toReset.setSeconds(0, 0)\n  }\n\n  const datems = Number(date)\n  let pd = date > lastWeek ? humanDate(datems, { month: 'short', day: 'numeric', year: 'numeric' }) : humanDate(datems)\n  if (date.getTime() === yesterday.getTime()) pd = L('Yesterday')\n  if (date.getTime() === today.getTime()) pd = L('Today')\n\n  return pd\n}\n\nexport function timeSince (datems        , dateNow         = Date.now())         {\n  const interval = dateNow - datems\n\n  if (interval >= DAYS_MILLIS * 2) {\n    // Make sure to replace any ordinary space character by a non-breaking one.\n    // $FlowFixMe\n    return humanDate(datems).replaceAll(' ', '\\xa0')\n  }\n  if (interval >= DAYS_MILLIS) {\n    return L('1d')\n  }\n  if (interval >= HOURS_MILLIS) {\n    return L('{hours}h', { hours: Math.floor(interval / HOURS_MILLIS) })\n  }\n  if (interval >= MINS_MILLIS) {\n    // Maybe use 'min' symbol rather than 'm'?\n    return L('{minutes}m', { minutes: Math.max(1, Math.floor(interval / MINS_MILLIS)) })\n  }\n  return L('<1m')\n}\n\nexport function cycleAtDate (atDate               )         {\n  const now = new Date(atDate) // Just in case the parameter is a string type.\n  const partialCycles = now.getDate() / lastDayOfMonth(now).getDate()\n  return partialCycles\n}\n"],
  "mappings": "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",
  "names": ["MINS_MILLIS", "HOURS_MILLIS", "DAYS_MILLIS", "MONTHS_MILLIS", "YEARS_MILLIS", "plusOnePeriodLength", "timestamp", "periodLength", "dateToPeriodStamp", "addTimeToDate", "minusOnePeriodLength", "periodStampsForDate", "date", "knownSortedStamps", "guess", "isIsoString", "previous", "current", "next", "latest", "earliest", "periodStampGivenDate", "i", "dateToPeriodStamp", "date", "dateFromPeriodStamp", "daystamp", "periodStampGivenDate", "recentDate", "periodStart", "periodLength", "periodStartDate", "nextPeriod", "addTimeToDate", "curDate", "curPeriod", "dateIsWithinPeriod", "dateObj", "start", "timeMillis", "d", "dateToMonthstamp", "comparePeriodStamps", "periodA", "periodB", "dateFromPeriodStamp", "compareISOTimestamps", "a", "b", "getLocale", "fallback", "humanDate", "date", "options", "dateObj", "locale", "humanTimeString", "isIsoString", "arg", "proximityDate", "date", "today", "yesterday", "d", "lastWeek", "toReset", "datems", "pd", "humanDate", "L", "timeSince", "dateNow", "interval", "DAYS_MILLIS", "HOURS_MILLIS", "MINS_MILLIS"]
}
